namespace Fortran::common {

constexpr std::size_t CountEnumNames(const char *p) {
  std::size_t n{0};
  std::size_t any{0};
  for (; *p; ++p) {
    if (*p == ',') {
      n += any;
      any = 0;
    } else if (*p != ' ') {
      any = 1;
    }
  }
  return n + any;
}

template <std::size_t ITEMS>
constexpr std::array<std::string_view, ITEMS> EnumNames(const char *p) {
  std::array<std::string_view, ITEMS> result{""};
  std::size_t at{0};
  const char *start{nullptr};
  for (; *p; ++p) {
    if (*p == ',' || *p == ' ') {
      if (start) {
        result[at++] =
            std::string_view{start, static_cast<std::size_t>(p - start)};
        start = nullptr;
      }
    } else if (!start) {
      start = p;
    }
  }
  if (start) {
    result[at] = std::string_view{start, static_cast<std::size_t>(p - start)};
  }
  return result;
}
# 78 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-class.h"
}
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/variant.h" 1
# 28 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h" 1
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/api-attrs.h" 1
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h" 2



namespace Fortran::common {
namespace log2visit {

template <std::size_t LOW, std::size_t HIGH, typename RESULT, typename VISITOR,
    typename... VARIANT>
inline RESULT Log2VisitHelper(
    VISITOR &&visitor, std::size_t which, VARIANT &&...u) {
  if constexpr (LOW + 7 >= HIGH) {
    switch (which - LOW) {





      case 1: if constexpr (LOW + 1 <= HIGH) { return visitor(std::get<(LOW + 1)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 2: if constexpr (LOW + 2 <= HIGH) { return visitor(std::get<(LOW + 2)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 3: if constexpr (LOW + 3 <= HIGH) { return visitor(std::get<(LOW + 3)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 4: if constexpr (LOW + 4 <= HIGH) { return visitor(std::get<(LOW + 4)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 5: if constexpr (LOW + 5 <= HIGH) { return visitor(std::get<(LOW + 5)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 6: if constexpr (LOW + 6 <= HIGH) { return visitor(std::get<(LOW + 6)>(std::forward<VARIANT>(u))...); }
      [[fallthrough]];
      case 7: if constexpr (LOW + 7 <= HIGH) { return visitor(std::get<(LOW + 7)>(std::forward<VARIANT>(u))...); }

    }
    return visitor(std::get<LOW>(std::forward<VARIANT>(u))...);
  } else {
    static constexpr std::size_t mid{(HIGH + LOW) / 2};
    if (which <= mid) {
      return Log2VisitHelper<LOW, mid, RESULT>(
          std::forward<VISITOR>(visitor), which, std::forward<VARIANT>(u)...);
    } else {
      return Log2VisitHelper<(mid + 1), HIGH, RESULT>(
          std::forward<VISITOR>(visitor), which, std::forward<VARIANT>(u)...);
    }
  }
}

template <typename VISITOR, typename... VARIANT>
inline auto
visit(VISITOR &&visitor, VARIANT &&...u) -> decltype(visitor(std::get<0>(
                                             std::forward<VARIANT>(u))...)) {
  using Result = decltype(visitor(std::get<0>(std::forward<VARIANT>(u))...));
  if constexpr (sizeof...(u) == 1) {
    static constexpr std::size_t high{
        (std::variant_size_v<std::decay_t<decltype(u)>> * ...) - 1};
    return Log2VisitHelper<0, high, Result>(std::forward<VISITOR>(visitor),
        u.index()..., std::forward<VARIANT>(u)...);
  } else {

    return ::std::visit(
        std::forward<VISITOR>(visitor), std::forward<VARIANT>(u)...);
  }
}

}
# 99 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h"
using Fortran::common::log2visit::visit;


}
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 1 3
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 262 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3

#pragma clang diagnostic push
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _VoidPtr>
struct __list_node;
template <class _Tp, class _VoidPtr>
struct __list_node_base;

template <class _Tp, class _VoidPtr>
struct __list_node_pointer_traits {
  typedef __rebind_pointer_t<_VoidPtr, __list_node<_Tp, _VoidPtr> > __node_pointer;
  typedef __rebind_pointer_t<_VoidPtr, __list_node_base<_Tp, _VoidPtr> > __base_pointer;




  typedef __conditional_t<is_pointer<_VoidPtr>::value, __base_pointer, __node_pointer> __link_pointer;


  typedef __conditional_t<is_same<__link_pointer, __node_pointer>::value, __base_pointer, __node_pointer>
      __non_link_pointer;

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __link_pointer __unsafe_link_pointer_cast(__link_pointer __p) { return __p; }

  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __link_pointer __unsafe_link_pointer_cast(__non_link_pointer __p) {
    return static_cast<__link_pointer>(static_cast<_VoidPtr>(__p));
  }
};

template <class _Tp, class _VoidPtr>
struct __list_node_base {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__node_pointer __node_pointer;
  typedef typename _NodeTraits::__base_pointer __base_pointer;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __prev_;
  __link_pointer __next_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_node_base()
      : __prev_(_NodeTraits::__unsafe_link_pointer_cast(__self())),
        __next_(_NodeTraits::__unsafe_link_pointer_cast(__self())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __list_node_base(__link_pointer __prev, __link_pointer __next)
      : __prev_(__prev), __next_(__next) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __base_pointer __self() { return pointer_traits<__base_pointer>::pointer_to(*this); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __as_node() { return static_cast<__node_pointer>(__self()); }
};

template <class _Tp, class _VoidPtr>
struct __list_node : public __list_node_base<_Tp, _VoidPtr> {




private:
  union {
    _Tp __value_;
  };

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _Tp& __get_value() { return __value_; }
# 335 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
  typedef __list_node_base<_Tp, _VoidPtr> __base;
  typedef typename __base::__link_pointer __link_pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __list_node(__link_pointer __prev, __link_pointer __next) : __base(__prev, __next) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~__list_node() {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __link_pointer __as_link() { return static_cast<__link_pointer>(__base::__self()); }
};

template <class _Tp, class _Alloc = allocator<_Tp> >
class list;
template <class _Tp, class _Alloc>
class __list_imp;
template <class _Tp, class _VoidPtr>
class __list_const_iterator;

template <class _Tp, class _VoidPtr>
class __list_iterator {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __ptr_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __list_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}

  template <class, class>
  friend class list;
  template <class, class>
  friend class __list_imp;
  template <class, class>
  friend class __list_const_iterator;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef value_type& reference;
  typedef __rebind_pointer_t<_VoidPtr, value_type> pointer;
  typedef typename pointer_traits<pointer>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_iterator() noexcept : __ptr_(nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __ptr_->__as_node()->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_iterator& operator++() {
    __ptr_ = __ptr_->__next_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_iterator operator++(int) {
    __list_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_iterator& operator--() {
    __ptr_ = __ptr_->__prev_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_iterator operator--(int) {
    __list_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __list_iterator& __x, const __list_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __list_iterator& __x, const __list_iterator& __y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _VoidPtr>
class __list_const_iterator {
  typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
  typedef typename _NodeTraits::__link_pointer __link_pointer;

  __link_pointer __ptr_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __list_const_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}

  template <class, class>
  friend class list;
  template <class, class>
  friend class __list_imp;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef const value_type& reference;
  typedef __rebind_pointer_t<_VoidPtr, const value_type> pointer;
  typedef typename pointer_traits<pointer>::difference_type difference_type;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator() noexcept : __ptr_(nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) noexcept
      : __ptr_(__p.__ptr_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __ptr_->__as_node()->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator& operator++() {
    __ptr_ = __ptr_->__next_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator operator++(int) {
    __list_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator& operator--() {
    __ptr_ = __ptr_->__prev_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_const_iterator operator--(int) {
    __list_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _Alloc>
class __list_imp {
public:
  __list_imp(const __list_imp&) = delete;
  __list_imp& operator=(const __list_imp&) = delete;

  typedef _Alloc allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __alloc_traits::size_type size_type;

protected:
  typedef _Tp value_type;
  typedef typename __alloc_traits::void_pointer __void_pointer;
  typedef __list_iterator<value_type, __void_pointer> iterator;
  typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
  typedef __list_node_base<value_type, __void_pointer> __node_base;
  typedef __list_node<value_type, __void_pointer> __node_type;
  typedef __rebind_alloc<__alloc_traits, __node_type> __node_allocator;
  typedef allocator_traits<__node_allocator> __node_alloc_traits;
  typedef typename __node_alloc_traits::pointer __node_pointer;
  typedef typename __node_alloc_traits::pointer __node_const_pointer;
  typedef __list_node_pointer_traits<value_type, __void_pointer> __node_pointer_traits;
  typedef typename __node_pointer_traits::__link_pointer __link_pointer;
  typedef __link_pointer __link_const_pointer;
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::difference_type difference_type;

  typedef __rebind_alloc<__alloc_traits, __node_base> __node_base_allocator;
  typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;
  static_assert(!is_same<allocator_type, __node_allocator>::value,
                "internal allocator type must differ from user-specified type; otherwise overload resolution breaks");

  __node_base __end_;
  __compressed_pair<size_type, __node_allocator> __size_alloc_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __link_pointer __end_as_link() const noexcept {
    return __node_pointer_traits::__unsafe_link_pointer_cast(const_cast<__node_base&>(__end_).__self());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type& __sz() noexcept { return __size_alloc_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const size_type& __sz() const noexcept { return __size_alloc_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_allocator& __node_alloc() noexcept { return __size_alloc_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const __node_allocator& __node_alloc() const noexcept { return __size_alloc_.second(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type __node_alloc_max_size() const noexcept {
    return __node_alloc_traits::max_size(__node_alloc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static void __unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_imp() noexcept(is_nothrow_default_constructible<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_imp(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_imp(const __node_allocator& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __list_imp(__node_allocator&& __a) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~__list_imp();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return __sz() == 0; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return iterator(__end_.__next_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return const_iterator(__end_.__next_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return iterator(__end_as_link()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return const_iterator(__end_as_link()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(__list_imp& __c)

      noexcept;




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __list_imp& __c) {
    __copy_assign_alloc(
        __c, integral_constant<bool, __node_alloc_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__list_imp& __c)
      noexcept(!__node_alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value) {

    __move_assign_alloc(
        __c, integral_constant<bool, __node_alloc_traits::propagate_on_container_move_assignment::value>());
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __create_node(__link_pointer __prev, __link_pointer __next, _Args&&... __args) {
    __node_allocator& __alloc = __node_alloc();
    __allocation_guard<__node_allocator> __guard(__alloc, 1);






    std::__construct_at(std::addressof(*__guard.__get()), __prev, __next);


    __node_alloc_traits::construct(
        __alloc, std::addressof(__guard.__get()->__get_value()), std::forward<_Args>(__args)...);
    return __guard.__release_ptr();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __delete_node(__node_pointer __node) {


    __node_allocator& __alloc = __node_alloc();
    __node_alloc_traits::destroy(__alloc, std::addressof(__node->__get_value()));
    std::__destroy_at(std::addressof(*__node));
    __node_alloc_traits::deallocate(__alloc, __node, 1);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __list_imp& __c, true_type) {
    if (__node_alloc() != __c.__node_alloc())
      clear();
    __node_alloc() = __c.__node_alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __list_imp&, false_type) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__list_imp& __c, true_type)
      noexcept(is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::move(__c.__node_alloc());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__list_imp&, false_type) noexcept {}
};


template <class _Tp, class _Alloc>
inline void __list_imp<_Tp, _Alloc>::__unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept {
  __f->__prev_->__next_ = __l->__next_;
  __l->__next_->__prev_ = __f->__prev_;
}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp() noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    : __size_alloc_(0, __default_init_tag()) {}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a) : __size_alloc_(0, __node_allocator(__a)) {}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const __node_allocator& __a) : __size_alloc_(0, __a) {}


template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(__node_allocator&& __a) noexcept : __size_alloc_(0, std::move(__a)) {}


template <class _Tp, class _Alloc>
__list_imp<_Tp, _Alloc>::~__list_imp() {
  clear();
}

template <class _Tp, class _Alloc>
void __list_imp<_Tp, _Alloc>::clear() noexcept {
  if (!empty()) {
    __link_pointer __f = __end_.__next_;
    __link_pointer __l = __end_as_link();
    __unlink_nodes(__f, __l->__prev_);
    __sz() = 0;
    while (__f != __l) {
      __node_pointer __np = __f->__as_node();
      __f = __f->__next_;
      __delete_node(__np);
    }
  }
}

template <class _Tp, class _Alloc>
void __list_imp<_Tp, _Alloc>::swap(__list_imp& __c)

    noexcept



{
  ((void)0);



  using std::swap;
  std::__swap_allocator(__node_alloc(), __c.__node_alloc());
  swap(__sz(), __c.__sz());
  swap(__end_, __c.__end_);
  if (__sz() == 0)
    __end_.__next_ = __end_.__prev_ = __end_as_link();
  else
    __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_as_link();
  if (__c.__sz() == 0)
    __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_as_link();
  else
    __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_as_link();
}

template <class _Tp, class _Alloc >
class list : private __list_imp<_Tp, _Alloc> {
  typedef __list_imp<_Tp, _Alloc> base;
  typedef typename base::__node_type __node_type;
  typedef typename base::__node_allocator __node_allocator;
  typedef typename base::__node_pointer __node_pointer;
  typedef typename base::__node_alloc_traits __node_alloc_traits;
  typedef typename base::__node_base __node_base;
  typedef typename base::__node_base_pointer __node_base_pointer;
  typedef typename base::__link_pointer __link_pointer;

public:
  typedef _Tp value_type;
  typedef _Alloc allocator_type;
  static_assert(__check_valid_allocator<allocator_type>::value);
  static_assert(is_same<value_type, typename allocator_type::value_type>::value,
                "Allocator::value_type must be same type as value_type");
  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename base::pointer pointer;
  typedef typename base::const_pointer const_pointer;
  typedef typename base::size_type size_type;
  typedef typename base::difference_type difference_type;
  typedef typename base::iterator iterator;
  typedef typename base::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;



  typedef void __remove_return_type;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list() noexcept(is_nothrow_default_constructible<__node_allocator>::value) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit list(const allocator_type& __a) : base(__a) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit list(size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit list(size_type __n, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(size_type __n, const value_type& __x);
  template <__enable_if_t<__is_allocator<_Alloc>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(size_type __n, const value_type& __x, const allocator_type& __a) : base(__a) {
    for (; __n > 0; --__n)
      push_back(__x);
  }

  template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(_InpIter __f, _InpIter __l);

  template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(_InpIter __f, _InpIter __l, const allocator_type& __a);
# 722 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(const list& __c);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(const list& __c, const __type_identity_t<allocator_type>& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list& operator=(const list& __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(initializer_list<value_type> __il);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(initializer_list<value_type> __il, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(list&& __c) noexcept(is_nothrow_move_constructible<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list(list&& __c, const __type_identity_t<allocator_type>& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list& operator=(list&& __c)
      noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value&& is_nothrow_move_assignable<__node_allocator>::value);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) list& operator=(initializer_list<value_type> __il) {
    assign(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void assign(initializer_list<value_type> __il) { assign(__il.begin(), __il.end()); }


  template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void assign(_InpIter __f, _InpIter __l);
# 753 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void assign(size_type __n, const value_type& __x);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type size() const noexcept { return base::__sz(); }
  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return base::empty(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept {
    return std::min<size_type>(base::__node_alloc_max_size(), numeric_limits<difference_type >::max());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return base::begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return base::begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return base::end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return base::end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept { return base::begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return base::end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crend() const noexcept { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference front() {
    ((void)0);
    return base::__end_.__next_->__as_node()->__get_value();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reference front() const {
    ((void)0);
    return base::__end_.__next_->__as_node()->__get_value();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference back() {
    ((void)0);
    return base::__end_.__prev_->__as_node()->__get_value();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reference back() const {
    ((void)0);
    return base::__end_.__prev_->__as_node()->__get_value();
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_front(value_type&& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_back(value_type&& __x);
# 810 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
  template <class... _Args>

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference emplace_front(_Args&&... __args);



  template <class... _Args>

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference emplace_back(_Args&&... __args);



  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace(const_iterator __p, _Args&&... __args);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, value_type&& __x);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, initializer_list<value_type> __il) {
    return insert(__p, __il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_front(const value_type& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_back(const value_type& __x);


  template <class _Arg>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __emplace_back(_Arg&& __arg) {
    emplace_back(std::forward<_Arg>(__arg));
  }




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, const value_type& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, size_type __n, const value_type& __x);

  template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, _InpIter __f, _InpIter __l);
# 857 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(list& __c)

      noexcept



  {
    base::swap(__c);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { base::clear(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void pop_front();
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void pop_back();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void resize(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void resize(size_type __n, const value_type& __x);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list& __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list&& __c) { splice(__p, __c); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list&& __c, const_iterator __i) { splice(__p, __c, __i); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l) {
    splice(__p, __c, __f, __l);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list& __c, const_iterator __i);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type remove(const value_type& __x);
  template <class _Pred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type remove_if(_Pred __pred);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type unique() { return unique(__equal_to()); }
  template <class _BinaryPred>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type unique(_BinaryPred __binary_pred);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(list& __c);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(list&& __c) { merge(__c); }

  template <class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(list&& __c, _Comp __comp) {
    merge(__c, __comp);
  }

  template <class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(list& __c, _Comp __comp);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void sort();
  template <class _Comp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void sort(_Comp __comp);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void reverse() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __invariants() const;

private:
  template <class _Iterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __assign_with_sentinel(_Iterator __f, _Sentinel __l);

  template <class _Iterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_with_sentinel(const_iterator __p, _Iterator __f, _Sentinel __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static void __link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __link_nodes_at_front(__link_pointer __f, __link_pointer __l);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __link_nodes_at_back(__link_pointer __f, __link_pointer __l);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __iterator(size_type __n);

  template <class _Comp>
  __attribute__((__visibility__("hidden"))) static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(list& __c, true_type)
      noexcept(is_nothrow_move_assignable<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(list& __c, false_type);
};


template <class _InputIterator,
          class _Alloc = allocator<__iter_value_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Alloc>::value> >
list(_InputIterator, _InputIterator) -> list<__iter_value_type<_InputIterator>, _Alloc>;

template <class _InputIterator,
          class _Alloc,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Alloc>::value> >
list(_InputIterator, _InputIterator, _Alloc) -> list<__iter_value_type<_InputIterator>, _Alloc>;
# 956 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l) {
  __p->__prev_->__next_ = __f;
  __f->__prev_ = __p->__prev_;
  __p->__prev_ = __l;
  __l->__next_ = __p;
}


template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes_at_front(__link_pointer __f, __link_pointer __l) {
  __f->__prev_ = base::__end_as_link();
  __l->__next_ = base::__end_.__next_;
  __l->__next_->__prev_ = __l;
  base::__end_.__next_ = __f;
}


template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::__link_nodes_at_back(__link_pointer __f, __link_pointer __l) {
  __l->__next_ = base::__end_as_link();
  __f->__prev_ = base::__end_.__prev_;
  __f->__prev_->__next_ = __f;
  base::__end_.__prev_ = __l;
}

template <class _Tp, class _Alloc>
inline typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::__iterator(size_type __n) {
  return __n <= base::__sz() / 2 ? std::next(begin(), __n) : std::prev(end(), base::__sz() - __n);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n) {
  for (; __n > 0; --__n)

    emplace_back();



}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a) {
  for (; __n > 0; --__n)
    emplace_back();
}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x) {
  for (; __n > 0; --__n)
    push_back(__x);
}

template <class _Tp, class _Alloc>
template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> >
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l) {
  for (; __f != __l; ++__f)
    __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> >
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a) : base(__a) {
  for (; __f != __l; ++__f)
    __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c)
    : base(__node_alloc_traits::select_on_container_copy_construction(__c.__node_alloc())) {
  for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c, const __type_identity_t<allocator_type>& __a) : base(__a) {
  for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
    push_back(*__i);
}



template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a) : base(__a) {
  for (typename initializer_list<value_type>::const_iterator __i = __il.begin(), __e = __il.end(); __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il) {
  for (typename initializer_list<value_type>::const_iterator __i = __il.begin(), __e = __il.end(); __i != __e; ++__i)
    push_back(*__i);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list&& __c) noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : base(std::move(__c.__node_alloc())) {
  splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list&& __c, const __type_identity_t<allocator_type>& __a) : base(__a) {
  if (__a == __c.get_allocator())
    splice(end(), __c);
  else {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  }
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(list&& __c) noexcept(
    __node_alloc_traits::propagate_on_container_move_assignment::value &&
    is_nothrow_move_assignable<__node_allocator>::value) {
  __move_assign(__c, integral_constant<bool, __node_alloc_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::__move_assign(list& __c, false_type) {
  if (base::__node_alloc() != __c.__node_alloc()) {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__c.begin()), _Ip(__c.end()));
  } else
    __move_assign(__c, true_type());
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::__move_assign(list& __c,
                                      true_type) noexcept(is_nothrow_move_assignable<__node_allocator>::value) {
  clear();
  base::__move_assign_alloc(__c);
  splice(end(), __c);
}



template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>& list<_Tp, _Alloc>::operator=(const list& __c) {
  if (this != std::addressof(__c)) {
    base::__copy_assign_alloc(__c);
    assign(__c.begin(), __c.end());
  }
  return *this;
}

template <class _Tp, class _Alloc>
template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> >
void list<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l) {
  __assign_with_sentinel(__f, __l);
}

template <class _Tp, class _Alloc>
template <class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void list<_Tp, _Alloc>::__assign_with_sentinel(_Iterator __f, _Sentinel __l) {
  iterator __i = begin();
  iterator __e = end();
  for (; __f != __l && __i != __e; ++__f, (void)++__i)
    *__i = *__f;
  if (__i == __e)
    __insert_with_sentinel(__e, std::move(__f), std::move(__l));
  else
    erase(__i, __e);
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::assign(size_type __n, const value_type& __x) {
  iterator __i = begin();
  iterator __e = end();
  for (; __n > 0 && __i != __e; --__n, (void)++__i)
    *__i = __x;
  if (__i == __e)
    insert(__e, __n, __x);
  else
    erase(__i, __e);
}

template <class _Tp, class _Alloc>
inline _Alloc list<_Tp, _Alloc>::get_allocator() const noexcept {
  return allocator_type(base::__node_alloc());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, __x);
  __link_nodes(__p.__ptr_, __node->__as_link(), __node->__as_link());
  ++base::__sz();
  return iterator(__node->__as_link());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x) {
  iterator __r(__p.__ptr_);
  if (__n > 0) {
    size_type __ds = 0;
    __node_pointer __node = this->__create_node( nullptr, nullptr, __x);
    ++__ds;
    __r = iterator(__node->__as_link());
    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, (void)++__e, ++__ds) {
        __e.__ptr_->__next_ = this->__create_node( __e.__ptr_, nullptr, __x)->__as_link();
      }

    } catch (...) {
      while (true) {
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_pointer __current = __e.__ptr_->__as_node();
        this->__delete_node(__current);
        if (__prev == 0)
          break;
        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
  return __r;
}

template <class _Tp, class _Alloc>
template <class _InpIter, __enable_if_t<__has_input_iterator_category<_InpIter>::value, int> >
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l) {
  return __insert_with_sentinel(__p, __f, __l);
}

template <class _Tp, class _Alloc>
template <class _Iterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__insert_with_sentinel(const_iterator __p, _Iterator __f, _Sentinel __l) {
  iterator __r(__p.__ptr_);
  if (__f != __l) {
    size_type __ds = 0;
    __node_pointer __node = this->__create_node( nullptr, nullptr, *__f);
    ++__ds;
    __r = iterator(__node->__as_link());
    iterator __e = __r;

    try {

      for (++__f; __f != __l; ++__f, (void)++__e, ++__ds) {
        __e.__ptr_->__next_ = this->__create_node( __e.__ptr_, nullptr, *__f)->__as_link();
      }

    } catch (...) {
      while (true) {
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_pointer __current = __e.__ptr_->__as_node();
        this->__delete_node(__current);
        if (__prev == 0)
          break;
        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
  return __r;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_front(const value_type& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, __x);
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_front(__nl, __nl);
  ++base::__sz();
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_back(const value_type& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, __x);
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_back(__nl, __nl);
  ++base::__sz();
}



template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_front(value_type&& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, std::move(__x));
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_front(__nl, __nl);
  ++base::__sz();
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::push_back(value_type&& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, std::move(__x));
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_back(__nl, __nl);
  ++base::__sz();
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_front(_Args&&... __args) {
  __node_pointer __node =
      this->__create_node( nullptr, nullptr, std::forward<_Args>(__args)...);
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_front(__nl, __nl);
  ++base::__sz();

  return __node->__get_value();

}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_back(_Args&&... __args) {
  __node_pointer __node =
      this->__create_node( nullptr, nullptr, std::forward<_Args>(__args)...);
  __link_pointer __nl = __node->__as_link();
  __link_nodes_at_back(__nl, __nl);
  ++base::__sz();

  return __node->__get_value();

}

template <class _Tp, class _Alloc>
template <class... _Args>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args) {
  __node_pointer __node =
      this->__create_node( nullptr, nullptr, std::forward<_Args>(__args)...);
  __link_pointer __nl = __node->__as_link();
  __link_nodes(__p.__ptr_, __nl, __nl);
  ++base::__sz();
  return iterator(__nl);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x) {
  __node_pointer __node = this->__create_node( nullptr, nullptr, std::move(__x));
  __link_pointer __nl = __node->__as_link();
  __link_nodes(__p.__ptr_, __nl, __nl);
  ++base::__sz();
  return iterator(__nl);
}



template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::pop_front() {
  ((void)0);
  __link_pointer __n = base::__end_.__next_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
  this->__delete_node(__n->__as_node());
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::pop_back() {
  ((void)0);
  __link_pointer __n = base::__end_.__prev_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
  this->__delete_node(__n->__as_node());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::erase(const_iterator __p) {
  ((void)0);
  __link_pointer __n = __p.__ptr_;
  __link_pointer __r = __n->__next_;
  base::__unlink_nodes(__n, __n);
  --base::__sz();
  this->__delete_node(__n->__as_node());
  return iterator(__r);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator list<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l) {
  if (__f != __l) {
    base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);
    while (__f != __l) {
      __link_pointer __n = __f.__ptr_;
      ++__f;
      --base::__sz();
      this->__delete_node(__n->__as_node());
    }
  }
  return iterator(__l.__ptr_);
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::resize(size_type __n) {
  if (__n < base::__sz())
    erase(__iterator(__n), end());
  else if (__n > base::__sz()) {
    __n -= base::__sz();
    size_type __ds = 0;
    __node_pointer __node = this->__create_node( nullptr, nullptr);
    ++__ds;
    iterator __r = iterator(__node->__as_link());
    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, (void)++__e, ++__ds) {
        __e.__ptr_->__next_ = this->__create_node( __e.__ptr_, nullptr)->__as_link();
      }

    } catch (...) {
      while (true) {
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_pointer __current = __e.__ptr_->__as_node();
        this->__delete_node(__current);
        if (__prev == 0)
          break;
        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes_at_back(__r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::resize(size_type __n, const value_type& __x) {
  if (__n < base::__sz())
    erase(__iterator(__n), end());
  else if (__n > base::__sz()) {
    __n -= base::__sz();
    size_type __ds = 0;
    __node_pointer __node = this->__create_node( nullptr, nullptr, __x);
    ++__ds;
    __link_pointer __nl = __node->__as_link();
    iterator __r = iterator(__nl);
    iterator __e = __r;

    try {

      for (--__n; __n != 0; --__n, (void)++__e, ++__ds) {
        __e.__ptr_->__next_ = this->__create_node( __e.__ptr_, nullptr, __x)->__as_link();
      }

    } catch (...) {
      while (true) {
        __link_pointer __prev = __e.__ptr_->__prev_;
        __node_pointer __current = __e.__ptr_->__as_node();
        this->__delete_node(__current);
        if (__prev == 0)
          break;
        __e = iterator(__prev);
      }
      throw;
    }

    __link_nodes(base::__end_as_link(), __r.__ptr_, __e.__ptr_);
    base::__sz() += __ds;
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list& __c) {
  ((void)0);

  if (!__c.empty()) {
    __link_pointer __f = __c.__end_.__next_;
    __link_pointer __l = __c.__end_.__prev_;
    base::__unlink_nodes(__f, __l);
    __link_nodes(__p.__ptr_, __f, __l);
    base::__sz() += __c.__sz();
    __c.__sz() = 0;
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i) {
  if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_) {
    __link_pointer __f = __i.__ptr_;
    base::__unlink_nodes(__f, __f);
    __link_nodes(__p.__ptr_, __f, __f);
    --__c.__sz();
    ++base::__sz();
  }
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l) {
  if (__f != __l) {
    __link_pointer __first = __f.__ptr_;
    --__l;
    __link_pointer __last = __l.__ptr_;
    if (this != std::addressof(__c)) {
      size_type __s = std::distance(__f, __l) + 1;
      __c.__sz() -= __s;
      base::__sz() += __s;
    }
    base::__unlink_nodes(__first, __last);
    __link_nodes(__p.__ptr_, __first, __last);
  }
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type list<_Tp, _Alloc>::remove(const value_type& __x) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (const_iterator __i = begin(), __e = end(); __i != __e;) {
    if (*__i == __x) {
      const_iterator __j = std::next(__i);
      for (; __j != __e && *__j == __x; ++__j)
        ;
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
      if (__i != __e)
        ++__i;
    } else
      ++__i;
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _Pred>
typename list<_Tp, _Alloc>::__remove_return_type list<_Tp, _Alloc>::remove_if(_Pred __pred) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (iterator __i = begin(), __e = end(); __i != __e;) {
    if (__pred(*__i)) {
      iterator __j = std::next(__i);
      for (; __j != __e && __pred(*__j); ++__j)
        ;
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
      if (__i != __e)
        ++__i;
    } else
      ++__i;
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _BinaryPred>
typename list<_Tp, _Alloc>::__remove_return_type list<_Tp, _Alloc>::unique(_BinaryPred __binary_pred) {
  list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  for (iterator __i = begin(), __e = end(); __i != __e;) {
    iterator __j = std::next(__i);
    for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
      ;
    if (++__i != __j) {
      __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
      __i = __j;
    }
  }

  return (__remove_return_type)__deleted_nodes.size();
}

template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::merge(list& __c) {
  merge(__c, __less<>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
void list<_Tp, _Alloc>::merge(list& __c, _Comp __comp) {
  if (this != std::addressof(__c)) {
    iterator __f1 = begin();
    iterator __e1 = end();
    iterator __f2 = __c.begin();
    iterator __e2 = __c.end();
    while (__f1 != __e1 && __f2 != __e2) {
      if (__comp(*__f2, *__f1)) {
        size_type __ds = 1;
        iterator __m2 = std::next(__f2);
        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, (void)++__ds)
          ;
        base::__sz() += __ds;
        __c.__sz() -= __ds;
        __link_pointer __f = __f2.__ptr_;
        __link_pointer __l = __m2.__ptr_->__prev_;
        __f2 = __m2;
        base::__unlink_nodes(__f, __l);
        __m2 = std::next(__f1);
        __link_nodes(__f1.__ptr_, __f, __l);
        __f1 = __m2;
      } else
        ++__f1;
    }
    splice(__e1, __c);
  }
}

template <class _Tp, class _Alloc>
inline void list<_Tp, _Alloc>::sort() {
  sort(__less<>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
inline void list<_Tp, _Alloc>::sort(_Comp __comp) {
  __sort(begin(), end(), base::__sz(), __comp);
}

template <class _Tp, class _Alloc>
template <class _Comp>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp) {
  switch (__n) {
  case 0:
  case 1:
    return __f1;
  case 2:
    if (__comp(*--__e2, *__f1)) {
      __link_pointer __f = __e2.__ptr_;
      base::__unlink_nodes(__f, __f);
      __link_nodes(__f1.__ptr_, __f, __f);
      return __e2;
    }
    return __f1;
  }
  size_type __n2 = __n / 2;
  iterator __e1 = std::next(__f1, __n2);
  iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp);
  iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);
  if (__comp(*__f2, *__f1)) {
    iterator __m2 = std::next(__f2);
    for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
      ;
    __link_pointer __f = __f2.__ptr_;
    __link_pointer __l = __m2.__ptr_->__prev_;
    __r = __f2;
    __e1 = __f2 = __m2;
    base::__unlink_nodes(__f, __l);
    __m2 = std::next(__f1);
    __link_nodes(__f1.__ptr_, __f, __l);
    __f1 = __m2;
  } else
    ++__f1;
  while (__f1 != __e1 && __f2 != __e2) {
    if (__comp(*__f2, *__f1)) {
      iterator __m2 = std::next(__f2);
      for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
        ;
      __link_pointer __f = __f2.__ptr_;
      __link_pointer __l = __m2.__ptr_->__prev_;
      if (__e1 == __f2)
        __e1 = __m2;
      __f2 = __m2;
      base::__unlink_nodes(__f, __l);
      __m2 = std::next(__f1);
      __link_nodes(__f1.__ptr_, __f, __l);
      __f1 = __m2;
    } else
      ++__f1;
  }
  return __r;
}

template <class _Tp, class _Alloc>
void list<_Tp, _Alloc>::reverse() noexcept {
  if (base::__sz() > 1) {
    iterator __e = end();
    for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;) {
      std::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);
      __i.__ptr_ = __i.__ptr_->__prev_;
    }
    std::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);
  }
}

template <class _Tp, class _Alloc>
bool list<_Tp, _Alloc>::__invariants() const {
  return size() == std::distance(begin(), end());
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y) {
  return !(__y < __x);
}
# 1689 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1717 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
}}
# 1717 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic pop


#pragma clang diagnostic push
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 1720 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
namespace pmr {
template <class _ValueT>
using list = std::list<_ValueT, polymorphic_allocator<_ValueT>>;
}
}}
# 1725 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
#pragma clang diagnostic pop
# 32 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
using namespace std::literals::string_literals;

namespace Fortran::common {
# 61 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename... LAMBDAS> struct visitors : LAMBDAS... {
  using LAMBDAS::operator()...;
};

template <typename... LAMBDAS> visitors(LAMBDAS... x) -> visitors<LAMBDAS...>;


[[noreturn]] void die(const char *, ...);
# 123 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename T> constexpr T &Deref(T *p, const char *file, int line) {
  if (!p) {
    Fortran::common::die("nullptr dereference at %s(%d)", file, line);
  }
  return *p;
}

template <typename T>
constexpr T &Deref(const std::unique_ptr<T> &p, const char *file, int line) {
  if (!p) {
    Fortran::common::die("nullptr dereference at %s(%d)", file, line);
  }
  return *p;
}


template <typename A> A Clone(const A &x) { return x; }
# 152 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename A, typename... B>
using IfNoLvalue = std::enable_if_t<(... && !std::is_lvalue_reference_v<B>), A>;
template <typename... RVREF> using NoLvalue = IfNoLvalue<void, RVREF...>;
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" 2




namespace Fortran::common {

template <typename A> class Interval {
public:
  using type = A;
  constexpr Interval() {}
  constexpr Interval(const A &s, std::size_t n = 1) : start_{s}, size_{n} {}
  constexpr Interval(A &&s, std::size_t n = 1)
      : start_{std::move(s)}, size_{n} {}
  constexpr Interval(const Interval &) = default;
  constexpr Interval(Interval &&) = default;
  constexpr Interval &operator=(const Interval &) = default;
  constexpr Interval &operator=(Interval &&) = default;

  constexpr bool operator<(const Interval &that) const {
    return start_ < that.start_ ||
        (start_ == that.start_ && size_ < that.size_);
  }
  constexpr bool operator<=(const Interval &that) const {
    return start_ < that.start_ ||
        (start_ == that.start_ && size_ <= that.size_);
  }
  constexpr bool operator==(const Interval &that) const {
    return start_ == that.start_ && size_ == that.size_;
  }
  constexpr bool operator!=(const Interval &that) const {
    return !(*this == that);
  }
  constexpr bool operator>=(const Interval &that) const {
    return !(*this < that);
  }
  constexpr bool operator>(const Interval &that) const {
    return !(*this <= that);
  }

  constexpr const A &start() const { return start_; }
  constexpr std::size_t size() const { return size_; }
  constexpr bool empty() const { return size_ == 0; }

  constexpr bool Contains(const A &x) const {
    return start_ <= x && x < start_ + size_;
  }
  constexpr bool Contains(const Interval &that) const {
    return Contains(that.start_) &&
        ((that.size_ == 0) || Contains(that.start_ + (that.size_ - 1)));
  }
  constexpr bool IsDisjointWith(const Interval &that) const {
    return that.NextAfter() <= start_ || NextAfter() <= that.start_;
  }
  constexpr bool ImmediatelyPrecedes(const Interval &that) const {
    return NextAfter() == that.start_;
  }
  void Annex(const Interval &that) {
    size_ = (that.start_ + that.size_) - start_;
  }
  bool AnnexIfPredecessor(const Interval &that) {
    if (ImmediatelyPrecedes(that)) {
      size_ += that.size_;
      return true;
    }
    return false;
  }
  void ExtendToCover(const Interval &that) {
    if (size_ == 0) {
      *this = that;
    } else if (that.size_ != 0) {
      const auto end{std::max(NextAfter(), that.NextAfter())};
      start_ = std::min(start_, that.start_);
      size_ = end - start_;
    }
  }

  std::size_t MemberOffset(const A &x) const {
    ((Contains(x)) || (Fortran::common::die("CHECK(" "Contains(x)" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" "(%d)", 93), false));
    return x - start_;
  }
  A OffsetMember(std::size_t n) const {
    ((n <= size_) || (Fortran::common::die("CHECK(" "n <= size_" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" "(%d)", 97), false));
    return start_ + n;
  }

  constexpr A Last() const { return start_ + (size_ - 1); }
  constexpr A NextAfter() const { return start_ + size_; }
  constexpr Interval Prefix(std::size_t n) const {
    return {start_, std::min(size_, n)};
  }
  Interval Suffix(std::size_t n) const {
    n = std::min(n, size_);
    return {start_ + n, size_ - n};
  }

  constexpr Interval Intersection(const Interval &that) const {
    if (that.NextAfter() <= start_) {
      return {};
    } else if (that.start_ <= start_) {
      auto skip{start_ - that.start_};
      return {start_, std::min(size_, that.size_ - skip)};
    } else if (NextAfter() <= that.start_) {
      return {};
    } else {
      auto skip{that.start_ - start_};
      return {that.start_, std::min(that.size_, size_ - skip)};
    }
  }

private:
  A start_;
  std::size_t size_{0};
};
}
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-block.h" 2







namespace llvm {
class raw_ostream;
}

namespace Fortran::parser {

class CharBlock {
public:
  constexpr CharBlock() {}
  constexpr CharBlock(const char *x, std::size_t n = 1) : interval_{x, n} {}
  constexpr CharBlock(const char *b, const char *ep1)
      : interval_{b, static_cast<std::size_t>(ep1 - b)} {}
  CharBlock(const std::string &s) : interval_{s.data(), s.size()} {}
  constexpr CharBlock(const CharBlock &) = default;
  constexpr CharBlock(CharBlock &&) = default;
  constexpr CharBlock &operator=(const CharBlock &) = default;
  constexpr CharBlock &operator=(CharBlock &&) = default;

  constexpr bool empty() const { return interval_.empty(); }
  constexpr std::size_t size() const { return interval_.size(); }
  constexpr const char *begin() const { return interval_.start(); }
  constexpr const char *end() const {
    return interval_.start() + interval_.size();
  }
  constexpr const char &operator[](std::size_t j) const {
    return interval_.start()[j];
  }
  constexpr const char &front() const { return (*this)[0]; }
  constexpr const char &back() const { return (*this)[size() - 1]; }

  bool Contains(const CharBlock &that) const {
    return interval_.Contains(that.interval_);
  }

  void ExtendToCover(const CharBlock &that) {
    interval_.ExtendToCover(that.interval_);
  }



  char FirstNonBlank() const {
    for (char ch : *this) {
      if (ch != ' ' && ch != '\t') {
        return ch;
      }
    }
    return ' ';
  }



  char OnlyNonBlank() const {
    char result{' '};
    for (char ch : *this) {
      if (ch != ' ' && ch != '\t') {
        if (result == ' ') {
          result = ch;
        } else {
          return ' ';
        }
      }
    }
    return result;
  }

  std::size_t CountLeadingBlanks() const {
    std::size_t n{size()};
    std::size_t j{0};
    for (; j < n; ++j) {
      char ch{(*this)[j]};
      if (ch != ' ' && ch != '\t') {
        break;
      }
    }
    return j;
  }

  bool IsBlank() const { return FirstNonBlank() == ' '; }

  std::string ToString() const {
    return std::string{interval_.start(), interval_.size()};
  }


  std::string NULTerminatedToString() const {
    return std::string{interval_.start(),
                         strnlen(interval_.start(), interval_.size())};
  }

  bool operator<(const CharBlock &that) const { return Compare(that) < 0; }
  bool operator<=(const CharBlock &that) const { return Compare(that) <= 0; }
  bool operator==(const CharBlock &that) const { return Compare(that) == 0; }
  bool operator!=(const CharBlock &that) const { return Compare(that) != 0; }
  bool operator>=(const CharBlock &that) const { return Compare(that) >= 0; }
  bool operator>(const CharBlock &that) const { return Compare(that) > 0; }

  bool operator<(const char *that) const { return Compare(that) < 0; }
  bool operator<=(const char *that) const { return Compare(that) <= 0; }
  bool operator==(const char *that) const { return Compare(that) == 0; }
  bool operator!=(const char *that) const { return Compare(that) != 0; }
  bool operator>=(const char *that) const { return Compare(that) >= 0; }
  bool operator>(const char *that) const { return Compare(that) > 0; }

  friend bool operator<(const char *, const CharBlock &);
  friend bool operator<=(const char *, const CharBlock &);
  friend bool operator==(const char *, const CharBlock &);
  friend bool operator!=(const char *, const CharBlock &);
  friend bool operator>=(const char *, const CharBlock &);
  friend bool operator>(const char *, const CharBlock &);

private:
  int Compare(const CharBlock &that) const {



    if (size() == 0) {
      return that.size() == 0 ? 0 : -1;
    } else if (that.size() == 0) {
      return 1;
    } else {
      std::size_t bytes{std::min(size(), that.size())};
      int cmp{std::memcmp(static_cast<const void *>(begin()),
          static_cast<const void *>(that.begin()), bytes)};
      if (cmp != 0) {
        return cmp;
      } else {
        return size() < that.size() ? -1 : size() > that.size();
      }
    }
  }

  int Compare(const char *that) const {
    std::size_t bytes{size()};

    if (!bytes) {
      return that == nullptr ? 0 : -1;
    } else if (!that) {
      return 1;
    } else if (int cmp{std::strncmp(begin(), that, bytes)}) {
      return cmp;
    }
    return that[bytes] == '\0' ? 0 : -1;
  }

  common::Interval<const char *> interval_{nullptr, 0};
};

inline bool operator<(const char *left, const CharBlock &right) {
  return right > left;
}
inline bool operator<=(const char *left, const CharBlock &right) {
  return right >= left;
}
inline bool operator==(const char *left, const CharBlock &right) {
  return right == left;
}
inline bool operator!=(const char *left, const CharBlock &right) {
  return right != left;
}
inline bool operator>=(const char *left, const CharBlock &right) {
  return right <= left;
}
inline bool operator>(const char *left, const CharBlock &right) {
  return right < left;
}


struct CharBlockPointerComparator {
  bool operator()(CharBlock x, CharBlock y) const {
    return x.end() < y.begin();
  }
};

llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const CharBlock &x);

}


template <> struct std::hash<Fortran::parser::CharBlock> {
  std::size_t operator()(const Fortran::parser::CharBlock &x) const {
    std::size_t hash{0}, bytes{x.size()};
    for (std::size_t j{0}; j < bytes; ++j) {
      hash = (hash * 31) ^ x[j];
    }
    return hash;
  }
};
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/characters.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/characters.h"
namespace Fortran::parser {

extern bool useHexadecimalEscapeSequences;






enum class Encoding { LATIN_1, UTF_8 };

inline constexpr bool IsUpperCaseLetter(char ch) {
  return ch >= 'A' && ch <= 'Z';
}

inline constexpr bool IsLowerCaseLetter(char ch) {
  return ch >= 'a' && ch <= 'z';
}

inline constexpr bool IsLetter(char ch) {
  return IsUpperCaseLetter(ch) || IsLowerCaseLetter(ch);
}

inline constexpr bool IsDecimalDigit(char ch) { return ch >= '0' && ch <= '9'; }

inline constexpr bool IsHexadecimalDigit(char ch) {
  return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') ||
      (ch >= 'a' && ch <= 'f');
}

inline constexpr bool IsOctalDigit(char ch) { return ch >= '0' && ch <= '7'; }

inline constexpr bool IsLegalIdentifierStart(char ch) {
  return IsLetter(ch) || ch == '_' || ch == '@' || ch == '$';
}

inline constexpr bool IsLegalInIdentifier(char ch) {
  return IsLegalIdentifierStart(ch) || IsDecimalDigit(ch);
}

inline constexpr bool IsPrintable(char ch) { return ch >= ' ' && ch <= '~'; }

inline constexpr bool IsWhiteSpace(char ch) {
  return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\v' || ch == '\f' ||
      ch == '\r';
}

inline constexpr char ToLowerCaseLetter(char ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 'a' : ch;
}

inline constexpr char ToLowerCaseLetter(char &&ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 'a' : ch;
}

inline std::string ToLowerCaseLetters(std::string_view str) {
  std::string lowered{str};
  for (char &ch : lowered) {
    ch = ToLowerCaseLetter(ch);
  }
  return lowered;
}

inline constexpr char ToUpperCaseLetter(char ch) {
  return IsLowerCaseLetter(ch) ? ch - 'a' + 'A' : ch;
}

inline constexpr char ToUpperCaseLetter(char &&ch) {
  return IsLowerCaseLetter(ch) ? ch - 'a' + 'A' : ch;
}

inline std::string ToUpperCaseLetters(std::string_view str) {
  std::string raised{str};
  for (char &ch : raised) {
    ch = ToUpperCaseLetter(ch);
  }
  return raised;
}

inline constexpr bool IsSameApartFromCase(char x, char y) {
  return ToLowerCaseLetter(x) == ToLowerCaseLetter(y);
}

inline constexpr char DecimalDigitValue(char ch) { return ch - '0'; }

inline constexpr char HexadecimalDigitValue(char ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 10
      : IsLowerCaseLetter(ch) ? ch - 'a' + 10
                               : DecimalDigitValue(ch);
}

inline constexpr std::optional<char> BackslashEscapeValue(char ch) {
  switch (ch) {
  case 'a':
    return std::nullopt;
  case 'b':
    return '\b';
  case 'f':
    return '\f';
  case 'n':
    return '\n';
  case 'r':
    return '\r';
  case 't':
    return '\t';
  case 'v':
    return '\v';
  case '"':
  case '\'':
  case '\\':
    return ch;
  default:
    return std::nullopt;
  }
}

inline constexpr std::optional<char> BackslashEscapeChar(char ch) {
  switch (ch) {
  case '\a':
    return std::nullopt;
  case '\b':
    return 'b';
  case '\f':
    return 'f';
  case '\n':
    return 'n';
  case '\r':
    return 'r';
  case '\t':
    return 't';
  case '\v':
    return 'v';
  case '"':
  case '\'':
  case '\\':
    return ch;
  default:
    return std::nullopt;
  }
}


inline constexpr bool IsValidFortranTokenCharacter(char ch) {
  switch (ch) {
  case '"':
  case '%':
  case '\'':
  case '(':
  case ')':
  case '*':
  case '+':
  case ',':
  case '-':
  case '.':
  case '/':
  case ':':
  case ';':
  case '<':
  case '=':
  case '>':
  case '[':
  case ']':
  case '{':
  case '}':
    return true;
  default:
    return IsLegalIdentifierStart(ch) || IsDecimalDigit(ch);
  }
}

struct EncodedCharacter {
  static constexpr int maxEncodingBytes{6};
  char buffer[maxEncodingBytes];
  int bytes{0};
};

template <Encoding ENCODING> EncodedCharacter EncodeCharacter(char32_t ucs);
template <> EncodedCharacter EncodeCharacter<Encoding::LATIN_1>(char32_t);
template <> EncodedCharacter EncodeCharacter<Encoding::UTF_8>(char32_t);

EncodedCharacter EncodeCharacter(Encoding, char32_t ucs);

template <Encoding ENCODING, typename STRING>
std::string EncodeString(const STRING &);
extern template std::string EncodeString<Encoding::LATIN_1, std::string>(
    const std::string &);
extern template std::string EncodeString<Encoding::UTF_8, std::u32string>(
    const std::u32string &);



template <typename NORMAL, typename INSERTED>
void EmitQuotedChar(char32_t ch, const NORMAL &emit, const INSERTED &insert,
    bool backslashEscapes = true, Encoding encoding = Encoding::UTF_8) {
  auto emitOneByte{[&](std::uint8_t ch) {
    if (backslashEscapes && (ch < ' ' || ch >= 0x7f || ch == '\\')) {
      if (std::optional<char> escape{BackslashEscapeChar(ch)}) {
        insert('\\');
        emit(*escape);
      } else if (useHexadecimalEscapeSequences) {
        insert('\\');
        insert('x');
        int top{ch >> 4}, bottom{ch & 0xf};
        insert(top > 9 ? 'a' + top - 10 : '0' + top);
        insert(bottom > 9 ? 'a' + bottom - 10 : '0' + bottom);
      } else {

        insert('\\');
        insert('0' + (ch >> 6));
        insert('0' + ((ch >> 3) & 7));
        insert('0' + (ch & 7));
      }
    } else if (ch == '\n') {
      insert('\\');
      insert('n');
    } else {
      emit(ch);
    }
  }};
  if (ch <= 0x7f) {
    emitOneByte(ch);
  } else if (backslashEscapes && useHexadecimalEscapeSequences) {
    insert('\\');
    insert('u');
    if (ch > 0xffff) {
      unsigned c1{(ch >> 28) & 0xf}, c2{(ch >> 24) & 0xf}, c3{(ch >> 20) & 0xf},
          c4{(ch >> 16) & 0xf};
      insert(c1 > 9 ? 'a' + c1 - 10 : '0' + c1);
      insert(c2 > 9 ? 'a' + c2 - 10 : '0' + c2);
      insert(c3 > 9 ? 'a' + c3 - 10 : '0' + c3);
      insert(c4 > 9 ? 'a' + c4 - 10 : '0' + c4);
    }
    unsigned c1{(ch >> 12) & 0xf}, c2{(ch >> 8) & 0xf}, c3{(ch >> 4) & 0xf},
        c4{ch & 0xf};
    insert(c1 > 9 ? 'a' + c1 - 10 : '0' + c1);
    insert(c2 > 9 ? 'a' + c2 - 10 : '0' + c2);
    insert(c3 > 9 ? 'a' + c3 - 10 : '0' + c3);
    insert(c4 > 9 ? 'a' + c4 - 10 : '0' + c4);
  } else {
    EncodedCharacter encoded{EncodeCharacter(encoding, ch)};
    for (int j{0}; j < encoded.bytes; ++j) {
      emitOneByte(encoded.buffer[j]);
    }
  }
}

std::string QuoteCharacterLiteral(const std::string &,
    bool backslashEscapes = true, Encoding = Encoding::LATIN_1);
std::string QuoteCharacterLiteral(const std::u16string &,
    bool backslashEscapes = true, Encoding = Encoding::UTF_8);
std::string QuoteCharacterLiteral(const std::u32string &,
    bool backslashEscapes = true, Encoding = Encoding::UTF_8);

int UTF_8CharacterBytes(const char *);

struct DecodedCharacter {
  char32_t codepoint{0};
  int bytes{0};
};

template <Encoding ENCODING>
DecodedCharacter DecodeRawCharacter(const char *, std::size_t);
template <>
DecodedCharacter DecodeRawCharacter<Encoding::LATIN_1>(
    const char *, std::size_t);

template <>
DecodedCharacter DecodeRawCharacter<Encoding::UTF_8>(const char *, std::size_t);


template <Encoding ENCODING>
DecodedCharacter DecodeCharacter(
    const char *, std::size_t, bool backslashEscapes);
extern template DecodedCharacter DecodeCharacter<Encoding::LATIN_1>(
    const char *, std::size_t, bool);
extern template DecodedCharacter DecodeCharacter<Encoding::UTF_8>(
    const char *, std::size_t, bool);

DecodedCharacter DecodeCharacter(
    Encoding, const char *, std::size_t, bool backslashEscapes);

template <typename RESULT, Encoding ENCODING>
RESULT DecodeString(const std::string &, bool backslashEscapes);
extern template std::string DecodeString<std::string, Encoding::LATIN_1>(
    const std::string &, bool);
extern template std::u16string DecodeString<std::u16string, Encoding::UTF_8>(
    const std::string &, bool);
extern template std::u32string DecodeString<std::u32string, Encoding::UTF_8>(
    const std::string &, bool);
}
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h" 1
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 1 3
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 1 3
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 252 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/inttypes.h" 1 3
# 24 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/inttypes.h" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_inttypes.h" 1 3 4
# 225 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_inttypes.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/Availability.h" 1 3 4
# 226 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_inttypes.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_inttypes.h" 2 3 4



extern "C" {




__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
imaxabs(intmax_t j);


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx,introduced=10.4)))
extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
strtoimax(const char * __nptr,
   char * * __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
strtoumax(const char * __nptr,
   char * * __endptr,
   int __base);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
wcstoimax(const wchar_t * __nptr,
   wchar_t * * __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
wcstoumax(const wchar_t * __nptr,
   wchar_t * * __endptr,
   int __base);






}
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 1 3
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_ptrdiff_t.h" 1 3
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_size_t.h" 1 3
# 99 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 108 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_wchar_t.h" 1 3
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_nullptr_t.h" 1 3
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_offsetof.h" 1 3
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/xlocale/_inttypes.h" 2 3 4




extern "C" {
intmax_t strtoimax_l(const char * nptr,
  char * * endptr, int base, locale_t);
uintmax_t strtoumax_l(const char * nptr,
  char * * endptr, int base, locale_t);
intmax_t wcstoimax_l(const wchar_t * nptr,
  wchar_t * * endptr, int base, locale_t);
uintmax_t wcstoumax_l(const wchar_t * nptr,
  wchar_t * * endptr, int base, locale_t);





}
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/inttypes.h" 2 3 4
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/inttypes.h" 2 3
# 253 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 2 3
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 2 3
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3


#pragma clang diagnostic push
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

using ::imaxdiv_t __attribute__((__using_if_exists__));
using ::imaxabs __attribute__((__using_if_exists__));
using ::imaxdiv __attribute__((__using_if_exists__));
using ::strtoimax __attribute__((__using_if_exists__));
using ::strtoumax __attribute__((__using_if_exists__));
using ::wcstoimax __attribute__((__using_if_exists__));
using ::wcstoumax __attribute__((__using_if_exists__));

}}
# 268 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
#pragma clang diagnostic pop
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h" 2





namespace Fortran::format {
# 38 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
struct IntrinsicTypeDataEditDesc {
  enum class Kind { I, B, O, Z, F, E, EN, ES, EX, G, L, A, D };
  IntrinsicTypeDataEditDesc() = delete;
  IntrinsicTypeDataEditDesc(IntrinsicTypeDataEditDesc &&) = default;
  IntrinsicTypeDataEditDesc &operator=(IntrinsicTypeDataEditDesc &&) = default;
  IntrinsicTypeDataEditDesc(Kind &&k, std::optional<int> &&w,
      std::optional<int> &&d, std::optional<int> &&e)
      : kind{k}, width{std::move(w)}, digits{std::move(d)}, exponentWidth{
                                                                std::move(e)} {}
  Kind kind;
  std::optional<int> width;
  std::optional<int> digits;
  std::optional<int> exponentWidth;
};




struct DerivedTypeDataEditDesc {
  DerivedTypeDataEditDesc() = delete;
  DerivedTypeDataEditDesc(DerivedTypeDataEditDesc &&) = default;
  DerivedTypeDataEditDesc &operator=(DerivedTypeDataEditDesc &&) = default;
  DerivedTypeDataEditDesc(std::string &&t, std::list<std::int64_t> &&p)
      : type{std::move(t)}, parameters{std::move(p)} {}
  std::string type;
  std::list<std::int64_t> parameters;
};
# 76 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
struct ControlEditDesc {
  enum class Kind {
    T,
    TL,
    TR,
    X,
    Slash,
    Colon,
    SS,
    SP,
    S,
    P,
    BN,
    BZ,
    RU,
    RD,
    RZ,
    RN,
    RC,
    RP,
    DC,
    DP,
    Dollar,
    Backslash,
  };
  ControlEditDesc() = delete;
  ControlEditDesc(ControlEditDesc &&) = default;
  ControlEditDesc &operator=(ControlEditDesc &&) = default;
  explicit ControlEditDesc(Kind k) : kind{k} {}
  ControlEditDesc(Kind k, std::int64_t ct) : kind{k}, count{ct} {}
  ControlEditDesc(std::int64_t ct, Kind k) : kind{k}, count{ct} {}
  Kind kind;
  std::int64_t count{1};
};






struct FormatItem {
  FormatItem() = delete;
  FormatItem(FormatItem &&) = default;
  FormatItem &operator=(FormatItem &&) = default;
  template <typename A, typename = common::NoLvalue<A>>
  FormatItem(std::optional<std::uint64_t> &&r, A &&x)
      : repeatCount{std::move(r)}, u{std::move(x)} {}
  template <typename A, typename = common::NoLvalue<A>>
  explicit FormatItem(A &&x) : u{std::move(x)} {}
  std::optional<std::uint64_t> repeatCount;
  std::variant<IntrinsicTypeDataEditDesc, DerivedTypeDataEditDesc,
      ControlEditDesc, std::string, std::list<FormatItem>>
      u;
};





struct FormatSpecification {
  FormatSpecification() = delete;
  FormatSpecification(FormatSpecification &&) = default;
  FormatSpecification &operator=(FormatSpecification &&) = default;
  explicit FormatSpecification(std::list<FormatItem> &&is)
      : items(std::move(is)) {}
  FormatSpecification(std::list<FormatItem> &&is, std::list<FormatItem> &&us)
      : items(std::move(is)), unlimitedItems(std::move(us)) {}
  std::list<FormatItem> items, unlimitedItems;
};
}
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-set.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-set.h"
namespace Fortran::parser {

struct SetOfChars {
  constexpr SetOfChars() {}

  constexpr SetOfChars(char c) {






    if (c == '\n') {

      c = '^';
    } else if (c < 32 || c >= 127) {

      c = '?';
    } else if (c >= 96) {

      c -= 32;
    }

    bits_ = static_cast<std::uint64_t>(1) << (c - 32);
  }

  constexpr SetOfChars(const char str[], std::size_t n) {
    for (std::size_t j{0}; j < n; ++j) {
      bits_ |= SetOfChars{str[j]}.bits_;
    }
  }

  constexpr SetOfChars(const SetOfChars &) = default;
  constexpr SetOfChars(SetOfChars &&) = default;
  constexpr SetOfChars &operator=(const SetOfChars &) = default;
  constexpr SetOfChars &operator=(SetOfChars &&) = default;
  constexpr bool empty() const { return bits_ == 0; }

  constexpr bool Has(SetOfChars that) const {
    return (that.bits_ & ~bits_) == 0;
  }
  constexpr SetOfChars Union(SetOfChars that) const {
    return SetOfChars{bits_ | that.bits_};
  }
  constexpr SetOfChars Intersection(SetOfChars that) const {
    return SetOfChars{bits_ & that.bits_};
  }
  constexpr SetOfChars Difference(SetOfChars that) const {
    return SetOfChars{bits_ & ~that.bits_};
  }

  std::string ToString() const;

private:
  constexpr SetOfChars(std::uint64_t b) : bits_{b} {}
  std::uint64_t bits_{0};
};
}
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 1
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-buffer.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-buffer.h"
namespace Fortran::parser {

class CharBuffer {
public:
  CharBuffer() {}
  CharBuffer(CharBuffer &&that)
      : blocks_(std::move(that.blocks_)), bytes_{that.bytes_},
        lastBlockEmpty_{that.lastBlockEmpty_} {
    that.clear();
  }
  CharBuffer &operator=(CharBuffer &&that) {
    blocks_ = std::move(that.blocks_);
    bytes_ = that.bytes_;
    lastBlockEmpty_ = that.lastBlockEmpty_;
    that.clear();
    return *this;
  }

  bool empty() const { return bytes_ == 0; }
  std::size_t bytes() const { return bytes_; }

  void clear() {
    blocks_.clear();
    bytes_ = 0;
    lastBlockEmpty_ = false;
  }

  char *FreeSpace(std::size_t &);
  void Claim(std::size_t);



  std::size_t Put(const char *data, std::size_t n);
  std::size_t Put(const std::string &);
  std::size_t Put(char x) { return Put(&x, 1); }

  std::string Marshal() const;

private:
  struct Block {
    static constexpr std::size_t capacity{1 << 20};
    char data[capacity];
  };

  int LastBlockOffset() const { return bytes_ % Block::capacity; }
  std::list<Block> blocks_;
  std::size_t bytes_{0};
  bool lastBlockEmpty_{false};
};
}
# 14 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference.h"
namespace Fortran::common {
template <typename A> class Reference {
public:
  using type = A;
  Reference(type &x) : p_{&x} {}
  Reference(const Reference &that) : p_{that.p_} {}
  Reference(Reference &&that) : p_{that.p_} {}
  Reference &operator=(const Reference &that) {
    p_ = that.p_;
    return *this;
  }
  Reference &operator=(Reference &&that) {
    p_ = that.p_;
    return *this;
  }






  operator std::conditional_t<std::is_const_v<type>, type &, void>()
      const noexcept {
    if constexpr (std::is_const_v<type>) {
      return *p_;
    }
  }

  type &get() const noexcept { return *p_; }
  type *operator->() const { return p_; }
  type &operator*() const { return *p_; }

  bool operator==(std::add_const_t<A> &that) const {
    return p_ == &that || *p_ == that;
  }
  bool operator!=(std::add_const_t<A> &that) const { return !(*this == that); }
  bool operator==(const Reference &that) const {
    return p_ == that.p_ || *this == *that.p_;
  }
  bool operator!=(const Reference &that) const { return !(*this == that); }

private:
  type *p_;
};
template <typename A> Reference(A &) -> Reference<A>;
}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/DataTypes.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/ExternC.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 2

extern "C" {
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
#pragma clang diagnostic push
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
#pragma clang diagnostic error "-Wstrict-prototypes"







typedef int LLVMBool;
# 48 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
typedef struct LLVMOpaqueMemoryBuffer *LLVMMemoryBufferRef;




typedef struct LLVMOpaqueContext *LLVMContextRef;







typedef struct LLVMOpaqueModule *LLVMModuleRef;






typedef struct LLVMOpaqueType *LLVMTypeRef;






typedef struct LLVMOpaqueValue *LLVMValueRef;






typedef struct LLVMOpaqueBasicBlock *LLVMBasicBlockRef;






typedef struct LLVMOpaqueMetadata *LLVMMetadataRef;






typedef struct LLVMOpaqueNamedMDNode *LLVMNamedMDNodeRef;






typedef struct LLVMOpaqueValueMetadataEntry LLVMValueMetadataEntry;






typedef struct LLVMOpaqueBuilder *LLVMBuilderRef;






typedef struct LLVMOpaqueDIBuilder *LLVMDIBuilderRef;






typedef struct LLVMOpaqueModuleProvider *LLVMModuleProviderRef;


typedef struct LLVMOpaquePassManager *LLVMPassManagerRef;





typedef struct LLVMOpaqueUse *LLVMUseRef;




typedef struct LLVMOpaqueOperandBundle *LLVMOperandBundleRef;






typedef struct LLVMOpaqueAttributeRef *LLVMAttributeRef;




typedef struct LLVMOpaqueDiagnosticInfo *LLVMDiagnosticInfoRef;




typedef struct LLVMComdat *LLVMComdatRef;




typedef struct LLVMOpaqueModuleFlagEntry LLVMModuleFlagEntry;




typedef struct LLVMOpaqueJITEventListener *LLVMJITEventListenerRef;




typedef struct LLVMOpaqueBinary *LLVMBinaryRef;




typedef struct LLVMOpaqueDbgRecord *LLVMDbgRecordRef;





#pragma clang diagnostic pop
# 181 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
 }
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 1
# 47 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ADL.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ADL.h"
namespace llvm {



template <typename T, T> struct SameType;

namespace adl_detail {

using std::begin;

template <typename RangeT>
constexpr auto begin_impl(RangeT &&range)
    -> decltype(begin(std::forward<RangeT>(range))) {
  return begin(std::forward<RangeT>(range));
}

using std::end;

template <typename RangeT>
constexpr auto end_impl(RangeT &&range)
    -> decltype(end(std::forward<RangeT>(range))) {
  return end(std::forward<RangeT>(range));
}

using std::rbegin;

template <typename RangeT>
constexpr auto rbegin_impl(RangeT &&range)
    -> decltype(rbegin(std::forward<RangeT>(range))) {
  return rbegin(std::forward<RangeT>(range));
}

using std::rend;

template <typename RangeT>
constexpr auto rend_impl(RangeT &&range)
    -> decltype(rend(std::forward<RangeT>(range))) {
  return rend(std::forward<RangeT>(range));
}

using std::swap;

template <typename T>
constexpr void swap_impl(T &&lhs,
                         T &&rhs) noexcept(noexcept(swap(std::declval<T>(),
                                                         std::declval<T>()))) {
  swap(std::forward<T>(lhs), std::forward<T>(rhs));
}

using std::size;

template <typename RangeT>
constexpr auto size_impl(RangeT &&range)
    -> decltype(size(std::forward<RangeT>(range))) {
  return size(std::forward<RangeT>(range));
}

}



template <typename RangeT>
constexpr auto adl_begin(RangeT &&range)
    -> decltype(adl_detail::begin_impl(std::forward<RangeT>(range))) {
  return adl_detail::begin_impl(std::forward<RangeT>(range));
}



template <typename RangeT>
constexpr auto adl_end(RangeT &&range)
    -> decltype(adl_detail::end_impl(std::forward<RangeT>(range))) {
  return adl_detail::end_impl(std::forward<RangeT>(range));
}



template <typename RangeT>
constexpr auto adl_rbegin(RangeT &&range)
    -> decltype(adl_detail::rbegin_impl(std::forward<RangeT>(range))) {
  return adl_detail::rbegin_impl(std::forward<RangeT>(range));
}



template <typename RangeT>
constexpr auto adl_rend(RangeT &&range)
    -> decltype(adl_detail::rend_impl(std::forward<RangeT>(range))) {
  return adl_detail::rend_impl(std::forward<RangeT>(range));
}



template <typename T>
constexpr void adl_swap(T &&lhs, T &&rhs) noexcept(
    noexcept(adl_detail::swap_impl(std::declval<T>(), std::declval<T>()))) {
  adl_detail::swap_impl(std::forward<T>(lhs), std::forward<T>(rhs));
}



template <typename RangeT>
constexpr auto adl_size(RangeT &&range)
    -> decltype(adl_detail::size_impl(std::forward<RangeT>(range))) {
  return adl_detail::size_impl(std::forward<RangeT>(range));
}

namespace detail {

template <typename RangeT>
using IterOfRange = decltype(adl_begin(std::declval<RangeT &>()));

template <typename RangeT>
using ValueOfRange =
    std::remove_reference_t<decltype(*adl_begin(std::declval<RangeT &>()))>;

}
}
# 48 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/llvm-config.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h" 2
# 73 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h"
namespace llvm {

__attribute__((__visibility__("default"))) extern int EnableABIBreakingChecks;
__attribute__ ((visibility("hidden")))
__attribute__((weak)) int *VerifyEnableABIBreakingChecks =
    &EnableABIBreakingChecks;






}
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/DataTypes.h" 1
# 50 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 1 3
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_ptrdiff_t.h" 1 3
# 94 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3




# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_size_t.h" 1 3
# 99 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 108 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_wchar_t.h" 1 3
# 109 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 118 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_nullptr_t.h" 1 3
# 119 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 133 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/__stddef_offsetof.h" 1 3
# 134 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/17/include/stddef.h" 2 3
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 2 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h" 2
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h" 2

namespace llvm {
class StringRef;
class Twine;


typedef void (*fatal_error_handler_t)(void *user_data, const char *reason,
                                      bool gen_crash_diag);
# 43 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
__attribute__((visibility("default"))) void install_fatal_error_handler(fatal_error_handler_t handler,
                                          void *user_data = nullptr);


__attribute__((visibility("default"))) void remove_fatal_error_handler();




struct ScopedFatalErrorHandler {
  explicit ScopedFatalErrorHandler(fatal_error_handler_t handler,
                                   void *user_data = nullptr) {
    install_fatal_error_handler(handler, user_data);
  }

  ~ScopedFatalErrorHandler() { remove_fatal_error_handler(); }
};



[[noreturn]] __attribute__((visibility("default"))) void report_fatal_error(const char *reason,
                                              bool gen_crash_diag = true);
[[noreturn]] __attribute__((visibility("default"))) void report_fatal_error(StringRef reason,
                                              bool gen_crash_diag = true);
[[noreturn]] __attribute__((visibility("default"))) void report_fatal_error(const Twine &reason,
                                              bool gen_crash_diag = true);
# 77 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
[[noreturn]] __attribute__((visibility("default"))) void reportFatalInternalError(const char *reason);
[[noreturn]] __attribute__((visibility("default"))) void reportFatalInternalError(StringRef reason);
[[noreturn]] __attribute__((visibility("default"))) void reportFatalInternalError(const Twine &reason);
# 95 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
[[noreturn]] __attribute__((visibility("default"))) void reportFatalUsageError(const char *reason);
[[noreturn]] __attribute__((visibility("default"))) void reportFatalUsageError(StringRef reason);
[[noreturn]] __attribute__((visibility("default"))) void reportFatalUsageError(const Twine &reason);
# 115 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
__attribute__((visibility("default"))) void install_bad_alloc_error_handler(fatal_error_handler_t handler,
                                              void *user_data = nullptr);


__attribute__((visibility("default"))) void remove_bad_alloc_error_handler();

__attribute__((visibility("default"))) void install_out_of_memory_new_handler();
# 135 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
[[noreturn]] __attribute__((visibility("default"))) void report_bad_alloc_error(const char *Reason,
                                                  bool GenCrashDiag = true);




[[noreturn]] __attribute__((visibility("default"))) void llvm_unreachable_internal(const char *msg = nullptr,
                                                     const char *file = nullptr,
                                                     unsigned line = 0);
}
# 51 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLForwardCompat.h" 1
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLForwardCompat.h"
namespace llvm {





template <typename T>
struct remove_cvref
{
  using type = std::remove_cv_t<std::remove_reference_t<T>>;
};

template <typename T>
using remove_cvref_t
    = typename llvm::remove_cvref<T>::type;


template <typename T>
struct type_identity
{
  using type = T;
};



template <typename T>
using type_identity_t
    = typename llvm::type_identity<T>::type;







template <typename Optional, typename Function,
          typename Value = typename llvm::remove_cvref_t<Optional>::value_type>
std::optional<std::invoke_result_t<Function, Value>>
transformOptional(Optional &&O, Function &&F) {
  if (O) {
    return F(*std::forward<Optional>(O));
  }
  return std::nullopt;
}



template <typename Enum>
[[nodiscard]] constexpr std::underlying_type_t<Enum> to_underlying(Enum E) {
  return static_cast<std::underlying_type_t<Enum>>(E);
}


struct from_range_t {
  explicit from_range_t() = default;
};
inline constexpr from_range_t from_range{};
}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h" 1
# 69 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
namespace llvm {

enum class endianness {
  big,
  little,



  native = little

};




template <
    typename To, typename From,
    typename = std::enable_if_t<sizeof(To) == sizeof(From)>,
    typename = std::enable_if_t<std::is_trivially_constructible<To>::value>,
    typename = std::enable_if_t<std::is_trivially_copyable<To>::value>,
    typename = std::enable_if_t<std::is_trivially_copyable<From>::value>>
[[nodiscard]] inline To bit_cast(const From &from) noexcept {

  return __builtin_bit_cast(To, from);





}


template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
[[nodiscard]] constexpr T byteswap(T V) noexcept {
  if constexpr (sizeof(T) == 1) {
    return V;
  } else if constexpr (sizeof(T) == 2) {
    uint16_t UV = V;





    uint16_t Hi = UV << 8;
    uint16_t Lo = UV >> 8;
    return Hi | Lo;

  } else if constexpr (sizeof(T) == 4) {
    uint32_t UV = V;

    return __builtin_bswap32(UV);
# 129 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
  } else if constexpr (sizeof(T) == 8) {
    uint64_t UV = V;

    return __builtin_bswap64(UV);







  } else {
    static_assert(!sizeof(T *), "Don't know how to handle the given type.");
    return 0;
  }
}

template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr inline bool has_single_bit(T Value) noexcept {
  return (Value != 0) && ((Value & (Value - 1)) == 0);
}







template <typename T> [[nodiscard]] int countr_zero(T Val) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (!Val)
    return std::numeric_limits<T>::digits;


  if constexpr (sizeof(T) == 4) {

    return __builtin_ctz(Val);





  } else if constexpr (sizeof(T) == 8) {

    return __builtin_ctzll(Val);





  }


  unsigned ZeroBits = 0;
  T Shift = std::numeric_limits<T>::digits >> 1;
  T Mask = std::numeric_limits<T>::max() >> Shift;
  while (Shift) {
    if ((Val & Mask) == 0) {
      Val >>= Shift;
      ZeroBits |= Shift;
    }
    Shift >>= 1;
    Mask >>= Shift;
  }
  return ZeroBits;
}







template <typename T> [[nodiscard]] int countl_zero(T Val) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (!Val)
    return std::numeric_limits<T>::digits;


  if constexpr (sizeof(T) == 4) {

    return __builtin_clz(Val);





  } else if constexpr (sizeof(T) == 8) {

    return __builtin_clzll(Val);





  }


  unsigned ZeroBits = 0;
  for (T Shift = std::numeric_limits<T>::digits >> 1; Shift; Shift >>= 1) {
    T Tmp = Val >> Shift;
    if (Tmp)
      Val = Tmp;
    else
      ZeroBits |= Shift;
  }
  return ZeroBits;
}
# 247 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] int countl_one(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::countl_zero<T>(~Value);
}
# 260 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] int countr_one(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::countr_zero<T>(~Value);
}





template <typename T> [[nodiscard]] int bit_width(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return std::numeric_limits<T>::digits - llvm::countl_zero(Value);
}





template <typename T> [[nodiscard]] T bit_floor(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (!Value)
    return 0;
  return T(1) << (llvm::bit_width(Value) - 1);
}
# 295 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] T bit_ceil(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (Value < 2)
    return 1;
  return T(1) << llvm::bit_width<T>(Value - 1u);
}




template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] inline int popcount(T Value) noexcept {
  if constexpr (sizeof(T) <= 4) {

    return (int)__builtin_popcount(Value);






  } else if constexpr (sizeof(T) <= 8) {

    return (int)__builtin_popcountll(Value);







  } else {
    static_assert(sizeof(T) == 0, "T must be 8 bytes or less");
  }
}


template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr T rotr(T V, int R);

template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr T rotl(T V, int R) {
  unsigned N = std::numeric_limits<T>::digits;

  R = R % N;
  if (!R)
    return V;

  if (R < 0)
    return llvm::rotr(V, -R);

  return (V << R) | (V >> (N - R));
}

template <typename T, typename> [[nodiscard]] constexpr T rotr(T V, int R) {
  unsigned N = std::numeric_limits<T>::digits;

  R = R % N;
  if (!R)
    return V;

  if (R < 0)
    return llvm::rotl(V, -R);

  return (V >> R) | (V << (N - R));
}

}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 2



namespace llvm {

namespace sys {

constexpr bool IsBigEndianHost =
    llvm::endianness::native == llvm::endianness::big;

static const bool IsLittleEndianHost = !IsBigEndianHost;

inline unsigned char getSwappedBytes(unsigned char C) { return llvm::byteswap(C); }
inline signed char getSwappedBytes( signed char C) { return llvm::byteswap(C); }
inline char getSwappedBytes( char C) { return llvm::byteswap(C); }

inline unsigned short getSwappedBytes(unsigned short C) { return llvm::byteswap(C); }
inline signed short getSwappedBytes( signed short C) { return llvm::byteswap(C); }

inline unsigned int getSwappedBytes(unsigned int C) { return llvm::byteswap(C); }
inline signed int getSwappedBytes( signed int C) { return llvm::byteswap(C); }

inline unsigned long getSwappedBytes(unsigned long C) { return llvm::byteswap(C); }
inline signed long getSwappedBytes( signed long C) { return llvm::byteswap(C); }

inline unsigned long long getSwappedBytes(unsigned long long C) { return llvm::byteswap(C); }
inline signed long long getSwappedBytes( signed long long C) { return llvm::byteswap(C); }

inline float getSwappedBytes(float C) {
  return llvm::bit_cast<float>(llvm::byteswap(llvm::bit_cast<uint32_t>(C)));
}

inline double getSwappedBytes(double C) {
  return llvm::bit_cast<double>(llvm::byteswap(llvm::bit_cast<uint64_t>(C)));
}

template <typename T>
inline std::enable_if_t<std::is_enum_v<T>, T> getSwappedBytes(T C) {
  return static_cast<T>(llvm::byteswap(llvm::to_underlying(C)));
}

template<typename T>
inline void swapByteOrder(T &Value) {
  Value = getSwappedBytes(Value);
}

}
}
# 52 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h"
namespace llvm {
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h"
template <typename T> class is_integral_or_enum {
  using UnderlyingT = std::remove_reference_t<T>;

public:
  static const bool value =
      !std::is_class_v<UnderlyingT> &&
      !std::is_pointer_v<UnderlyingT> &&
      !std::is_floating_point_v<UnderlyingT> &&
      (std::is_enum_v<UnderlyingT> ||
       std::is_convertible_v<UnderlyingT, unsigned long long>);
};


template<typename T, typename Enable = void>
struct add_lvalue_reference_if_not_pointer { using type = T &; };

template <typename T>
struct add_lvalue_reference_if_not_pointer<
    T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = T;
};



template<typename T, typename Enable = void>
struct add_const_past_pointer { using type = const T; };

template <typename T>
struct add_const_past_pointer<T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = const std::remove_pointer_t<T> *;
};

template <typename T, typename Enable = void>
struct const_pointer_or_const_ref {
  using type = const T &;
};
template <typename T>
struct const_pointer_or_const_ref<T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = typename add_const_past_pointer<T>::type;
};

namespace detail {
template<class T>
union trivial_helper {
    T t;
};

}

template <typename T>
struct is_copy_assignable {
  template<class F>
    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<const F &>(), std::true_type{});
    static std::false_type get(...);
    static constexpr bool value = decltype(get((T*)nullptr))::value;
};

template <typename T>
struct is_move_assignable {
  template<class F>
    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<F &&>(), std::true_type{});
    static std::false_type get(...);
    static constexpr bool value = decltype(get((T*)nullptr))::value;
};

}
# 53 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_assert.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/_static_assert.h" 1 3 4
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 55 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2






namespace llvm {
template <typename T, typename Enable> struct DenseMapInfo;
# 76 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
class hash_code {
  size_t value;

public:


  hash_code() = default;


  hash_code(size_t value) : value(value) {}


               operator size_t() const { return value; }

  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {
    return lhs.value == rhs.value;
  }
  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {
    return lhs.value != rhs.value;
  }


  friend size_t hash_value(const hash_code &code) { return code.value; }
};
# 108 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T>
std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);




template <typename T> hash_code hash_value(const T *ptr);


template <typename T, typename U>
hash_code hash_value(const std::pair<T, U> &arg);


template <typename... Ts>
hash_code hash_value(const std::tuple<Ts...> &arg);


template <typename T>
hash_code hash_value(const std::basic_string<T> &arg);


template <typename T> hash_code hash_value(const std::optional<T> &arg);




namespace hashing {
namespace detail {

inline uint64_t fetch64(const char *p) {
  uint64_t result;
  std::memcpy(&result, p, sizeof(result));
  if (sys::IsBigEndianHost)
    sys::swapByteOrder(result);
  return result;
}

inline uint32_t fetch32(const char *p) {
  uint32_t result;
  std::memcpy(&result, p, sizeof(result));
  if (sys::IsBigEndianHost)
    sys::swapByteOrder(result);
  return result;
}


static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;
static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;
static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;
static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;




inline uint64_t rotate(uint64_t val, size_t shift) {

  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
}

inline uint64_t shift_mix(uint64_t val) {
  return val ^ (val >> 47);
}

inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {

  const uint64_t kMul = 0x9ddfea08eb382d69ULL;
  uint64_t a = (low ^ high) * kMul;
  a ^= (a >> 47);
  uint64_t b = (high ^ a) * kMul;
  b ^= (b >> 47);
  b *= kMul;
  return b;
}

inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {
  uint8_t a = s[0];
  uint8_t b = s[len >> 1];
  uint8_t c = s[len - 1];
  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);
  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);
  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;
}

inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch32(s);
  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));
}

inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch64(s);
  uint64_t b = fetch64(s + len - 8);
  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;
}

inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch64(s) * k1;
  uint64_t b = fetch64(s + 8);
  uint64_t c = fetch64(s + len - 8) * k2;
  uint64_t d = fetch64(s + len - 16) * k0;
  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +
                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,
                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);
}

inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t z = fetch64(s + 24);
  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;
  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);
  uint64_t c = llvm::rotr<uint64_t>(a, 37);
  a += fetch64(s + 8);
  c += llvm::rotr<uint64_t>(a, 7);
  a += fetch64(s + 16);
  uint64_t vf = a + z;
  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;
  a = fetch64(s + 16) + fetch64(s + len - 32);
  z = fetch64(s + len - 8);
  b = llvm::rotr<uint64_t>(a + z, 52);
  c = llvm::rotr<uint64_t>(a, 37);
  a += fetch64(s + len - 24);
  c += llvm::rotr<uint64_t>(a, 7);
  a += fetch64(s + len - 16);
  uint64_t wf = a + z;
  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;
  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);
  return shift_mix((seed ^ (r * k0)) + vs) * k2;
}

inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {
  if (length >= 4 && length <= 8)
    return hash_4to8_bytes(s, length, seed);
  if (length > 8 && length <= 16)
    return hash_9to16_bytes(s, length, seed);
  if (length > 16 && length <= 32)
    return hash_17to32_bytes(s, length, seed);
  if (length > 32)
    return hash_33to64_bytes(s, length, seed);
  if (length != 0)
    return hash_1to3_bytes(s, length, seed);

  return k2 ^ seed;
}




struct hash_state {
  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;




  static hash_state create(const char *s, uint64_t seed) {
    hash_state state = {0,
                        seed,
                        hash_16_bytes(seed, k1),
                        llvm::rotr<uint64_t>(seed ^ k1, 49),
                        seed * k1,
                        shift_mix(seed),
                        0};
    state.h6 = hash_16_bytes(state.h4, state.h5);
    state.mix(s);
    return state;
  }



  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {
    a += fetch64(s);
    uint64_t c = fetch64(s + 24);
    b = llvm::rotr<uint64_t>(b + a + c, 21);
    uint64_t d = a;
    a += fetch64(s + 8) + fetch64(s + 16);
    b += llvm::rotr<uint64_t>(a, 44) + d;
    a += c;
  }




  void mix(const char *s) {
    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;
    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;
    h0 ^= h6;
    h1 += h3 + fetch64(s + 40);
    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;
    h3 = h4 * k1;
    h4 = h0 + h5;
    mix_32_bytes(s, h3, h4);
    h5 = h2 + h6;
    h6 = h1 + fetch64(s + 16);
    mix_32_bytes(s + 32, h5, h6);
    std::swap(h2, h0);
  }



  uint64_t finalize(size_t length) {
    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,
                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);
  }
};





inline uint64_t get_execution_seed() {

  return static_cast<uint64_t>(
      reinterpret_cast<uintptr_t>(&install_fatal_error_handler));



}
# 336 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T> struct is_hashable_data
  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||
                                   std::is_pointer<T>::value) &&
                                  64 % sizeof(T) == 0)> {};





template <typename T, typename U> struct is_hashable_data<std::pair<T, U> >
  : std::integral_constant<bool, (is_hashable_data<T>::value &&
                                  is_hashable_data<U>::value &&
                                  (sizeof(T) + sizeof(U)) ==
                                   sizeof(std::pair<T, U>))> {};



template <typename T>
std::enable_if_t<is_hashable_data<T>::value, T>
get_hashable_data(const T &value) {
  return value;
}



template <typename T>
std::enable_if_t<!is_hashable_data<T>::value, size_t>
get_hashable_data(const T &value) {
  using ::llvm::hash_value;
  return hash_value(value);
}
# 375 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T>
bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,
                       size_t offset = 0) {
  size_t store_size = sizeof(value) - offset;
  if (buffer_ptr + store_size > buffer_end)
    return false;
  const char *value_data = reinterpret_cast<const char *>(&value);
  std::memcpy(buffer_ptr, value_data + offset, store_size);
  buffer_ptr += store_size;
  return true;
}






template <typename InputIteratorT>
hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {
  const uint64_t seed = get_execution_seed();
  char buffer[64], *buffer_ptr = buffer;
  char *const buffer_end = std::end(buffer);
  while (first != last && store_and_advance(buffer_ptr, buffer_end,
                                            get_hashable_data(*first)))
    ++first;
  if (first == last)
    return hash_short(buffer, buffer_ptr - buffer, seed);
  (__builtin_expect(!(buffer_ptr == buffer_end), 0) ? __assert_rtn(__func__, "Hashing.h", 402, "buffer_ptr == buffer_end") : (void)0);

  hash_state state = state.create(buffer, seed);
  size_t length = 64;
  while (first != last) {


    buffer_ptr = buffer;
    while (first != last && store_and_advance(buffer_ptr, buffer_end,
                                              get_hashable_data(*first)))
      ++first;




    std::rotate(buffer, buffer_ptr, buffer_end);


    state.mix(buffer);
    length += buffer_ptr - buffer;
  };

  return state.finalize(length);
}
# 435 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename ValueT>
std::enable_if_t<is_hashable_data<ValueT>::value, hash_code>
hash_combine_range_impl(ValueT *first, ValueT *last) {
  const uint64_t seed = get_execution_seed();
  const char *s_begin = reinterpret_cast<const char *>(first);
  const char *s_end = reinterpret_cast<const char *>(last);
  const size_t length = std::distance(s_begin, s_end);
  if (length <= 64)
    return hash_short(s_begin, length, seed);

  const char *s_aligned_end = s_begin + (length & ~63);
  hash_state state = state.create(s_begin, seed);
  s_begin += 64;
  while (s_begin != s_aligned_end) {
    state.mix(s_begin);
    s_begin += 64;
  }
  if (length & 63)
    state.mix(s_end - 64);

  return state.finalize(length);
}

}
}
# 468 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename InputIteratorT>
hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {
  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);
}


template <typename RangeT> hash_code hash_combine_range(RangeT &&R) {
  return hash_combine_range(adl_begin(R), adl_end(R));
}


namespace hashing {
namespace detail {
# 489 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
struct hash_combine_recursive_helper {
  char buffer[64] = {};
  hash_state state;
  const uint64_t seed;

public:




  hash_combine_recursive_helper()
    : seed(get_execution_seed()) {}







  template <typename T>
  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {
    if (!store_and_advance(buffer_ptr, buffer_end, data)) {




      size_t partial_store_size = buffer_end - buffer_ptr;
      std::memcpy(buffer_ptr, &data, partial_store_size);





      if (length == 0) {
        state = state.create(buffer, seed);
        length = 64;
      } else {

        state.mix(buffer);
        length += 64;
      }


      buffer_ptr = buffer;



      if (!store_and_advance(buffer_ptr, buffer_end, data,
                             partial_store_size))
        ::llvm::llvm_unreachable_internal("buffer smaller than stored type", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h", 538);
    }
    return buffer_ptr;
  }





  template <typename T, typename ...Ts>
  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,
                    const T &arg, const Ts &...args) {
    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));


    return combine(length, buffer_ptr, buffer_end, args...);
  }






  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {


    if (length == 0)
      return hash_short(buffer, buffer_ptr - buffer, seed);





    std::rotate(buffer, buffer_ptr, buffer_end);


    state.mix(buffer);
    length += buffer_ptr - buffer;

    return state.finalize(length);
  }
};

}
}
# 595 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename ...Ts> hash_code hash_combine(const Ts &...args) {

  ::llvm::hashing::detail::hash_combine_recursive_helper helper;
  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);
}



namespace hashing {
namespace detail {






inline hash_code hash_integer_value(uint64_t value) {

  const uint64_t seed = get_execution_seed();
  const char *s = reinterpret_cast<const char *>(&value);
  const uint64_t a = fetch32(s);
  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));
}

}
}



template <typename T>
std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {
  return ::llvm::hashing::detail::hash_integer_value(
      static_cast<uint64_t>(value));
}



template <typename T> hash_code hash_value(const T *ptr) {
  return ::llvm::hashing::detail::hash_integer_value(
    reinterpret_cast<uintptr_t>(ptr));
}



template <typename T, typename U>
hash_code hash_value(const std::pair<T, U> &arg) {
  return hash_combine(arg.first, arg.second);
}

template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {
  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);
}



template <typename T>
hash_code hash_value(const std::basic_string<T> &arg) {
  return hash_combine_range(arg);
}

template <typename T> hash_code hash_value(const std::optional<T> &arg) {
  return arg ? hash_combine(true, *arg) : hash_value(false);
}

template <> struct DenseMapInfo<hash_code, void> {
  static inline hash_code getEmptyKey() { return hash_code(-1); }
  static inline hash_code getTombstoneKey() { return hash_code(-2); }
  static unsigned getHashValue(hash_code val) {
    return static_cast<unsigned>(size_t(val));
  }
  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }
};

}


namespace std {

template<>
struct hash<llvm::hash_code> {
  size_t operator()(llvm::hash_code const& Val) const {
    return Val;
  }
};

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h" 2







namespace llvm {

namespace densemap::detail {


inline uint64_t mix(uint64_t x) {
  x *= 0xbf58476d1ce4e5b9u;
  x ^= x >> 31;
  return x;
}
}

namespace detail {


inline unsigned combineHashValue(unsigned a, unsigned b) {
  uint64_t x = (uint64_t)a << 32 | (uint64_t)b;
  return (unsigned)densemap::detail::mix(x);
}

}






template<typename T, typename Enable = void>
struct DenseMapInfo {




};






template<typename T>
struct DenseMapInfo<T*> {




  static constexpr uintptr_t Log2MaxAlign = 12;

  static constexpr T *getEmptyKey() {
    uintptr_t Val = static_cast<uintptr_t>(-1);
    Val <<= Log2MaxAlign;
    return reinterpret_cast<T*>(Val);
  }

  static constexpr T *getTombstoneKey() {
    uintptr_t Val = static_cast<uintptr_t>(-2);
    Val <<= Log2MaxAlign;
    return reinterpret_cast<T*>(Val);
  }

  static unsigned getHashValue(const T *PtrVal) {
    return (unsigned((uintptr_t)PtrVal) >> 4) ^
           (unsigned((uintptr_t)PtrVal) >> 9);
  }

  static bool isEqual(const T *LHS, const T *RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<char> {
  static constexpr char getEmptyKey() { return ~0; }
  static constexpr char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const char& Val) { return Val * 37U; }

  static bool isEqual(const char &LHS, const char &RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<unsigned char> {
  static constexpr unsigned char getEmptyKey() { return ~0; }
  static constexpr unsigned char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const unsigned char &Val) { return Val * 37U; }

  static bool isEqual(const unsigned char &LHS, const unsigned char &RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<unsigned short> {
  static constexpr unsigned short getEmptyKey() { return 0xFFFF; }
  static constexpr unsigned short getTombstoneKey() { return 0xFFFF - 1; }
  static unsigned getHashValue(const unsigned short &Val) { return Val * 37U; }

  static bool isEqual(const unsigned short &LHS, const unsigned short &RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned> {
  static constexpr unsigned getEmptyKey() { return ~0U; }
  static constexpr unsigned getTombstoneKey() { return ~0U - 1; }
  static unsigned getHashValue(const unsigned& Val) { return Val * 37U; }

  static bool isEqual(const unsigned& LHS, const unsigned& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long> {
  static constexpr unsigned long getEmptyKey() { return ~0UL; }
  static constexpr unsigned long getTombstoneKey() { return ~0UL - 1L; }

  static unsigned getHashValue(const unsigned long& Val) {
    if constexpr (sizeof(Val) == 4)
      return DenseMapInfo<unsigned>::getHashValue(Val);
    else
      return densemap::detail::mix(Val);
  }

  static bool isEqual(const unsigned long& LHS, const unsigned long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long long> {
  static constexpr unsigned long long getEmptyKey() { return ~0ULL; }
  static constexpr unsigned long long getTombstoneKey() { return ~0ULL - 1ULL; }

  static unsigned getHashValue(const unsigned long long& Val) {
    return densemap::detail::mix(Val);
  }

  static bool isEqual(const unsigned long long& LHS,
                      const unsigned long long& RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<short> {
  static constexpr short getEmptyKey() { return 0x7FFF; }
  static constexpr short getTombstoneKey() { return -0x7FFF - 1; }
  static unsigned getHashValue(const short &Val) { return Val * 37U; }
  static bool isEqual(const short &LHS, const short &RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<int> {
  static constexpr int getEmptyKey() { return 0x7fffffff; }
  static constexpr int getTombstoneKey() { return -0x7fffffff - 1; }
  static unsigned getHashValue(const int& Val) { return (unsigned)(Val * 37U); }

  static bool isEqual(const int& LHS, const int& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long> {
  static constexpr long getEmptyKey() {
    return (1UL << (sizeof(long) * 8 - 1)) - 1UL;
  }

  static constexpr long getTombstoneKey() { return getEmptyKey() - 1L; }

  static unsigned getHashValue(const long& Val) {
    return (unsigned)(Val * 37UL);
  }

  static bool isEqual(const long& LHS, const long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long long> {
  static constexpr long long getEmptyKey() { return 0x7fffffffffffffffLL; }
  static constexpr long long getTombstoneKey() {
    return -0x7fffffffffffffffLL - 1;
  }

  static unsigned getHashValue(const long long& Val) {
    return (unsigned)(Val * 37ULL);
  }

  static bool isEqual(const long long& LHS,
                      const long long& RHS) {
    return LHS == RHS;
  }
};


template<typename T, typename U>
struct DenseMapInfo<std::pair<T, U>> {
  using Pair = std::pair<T, U>;
  using FirstInfo = DenseMapInfo<T>;
  using SecondInfo = DenseMapInfo<U>;

  static constexpr Pair getEmptyKey() {
    return std::make_pair(FirstInfo::getEmptyKey(),
                          SecondInfo::getEmptyKey());
  }

  static constexpr Pair getTombstoneKey() {
    return std::make_pair(FirstInfo::getTombstoneKey(),
                          SecondInfo::getTombstoneKey());
  }

  static unsigned getHashValue(const Pair& PairVal) {
    return detail::combineHashValue(FirstInfo::getHashValue(PairVal.first),
                                    SecondInfo::getHashValue(PairVal.second));
  }




  static unsigned getHashValuePiecewise(const T &First, const U &Second) {
    return detail::combineHashValue(FirstInfo::getHashValue(First),
                                    SecondInfo::getHashValue(Second));
  }

  static bool isEqual(const Pair &LHS, const Pair &RHS) {
    return FirstInfo::isEqual(LHS.first, RHS.first) &&
           SecondInfo::isEqual(LHS.second, RHS.second);
  }
};


template <typename... Ts> struct DenseMapInfo<std::tuple<Ts...>> {
  using Tuple = std::tuple<Ts...>;

  static constexpr Tuple getEmptyKey() {
    return Tuple(DenseMapInfo<Ts>::getEmptyKey()...);
  }

  static constexpr Tuple getTombstoneKey() {
    return Tuple(DenseMapInfo<Ts>::getTombstoneKey()...);
  }

  template <unsigned I>
  static unsigned getHashValueImpl(const Tuple &values, std::false_type) {
    using EltType = std::tuple_element_t<I, Tuple>;
    std::integral_constant<bool, I + 1 == sizeof...(Ts)> atEnd;
    return detail::combineHashValue(
        DenseMapInfo<EltType>::getHashValue(std::get<I>(values)),
        getHashValueImpl<I + 1>(values, atEnd));
  }

  template <unsigned I>
  static unsigned getHashValueImpl(const Tuple &, std::true_type) {
    return 0;
  }

  static unsigned getHashValue(const std::tuple<Ts...> &values) {
    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
    return getHashValueImpl<0>(values, atEnd);
  }

  template <unsigned I>
  static bool isEqualImpl(const Tuple &lhs, const Tuple &rhs, std::false_type) {
    using EltType = std::tuple_element_t<I, Tuple>;
    std::integral_constant<bool, I + 1 == sizeof...(Ts)> atEnd;
    return DenseMapInfo<EltType>::isEqual(std::get<I>(lhs), std::get<I>(rhs)) &&
           isEqualImpl<I + 1>(lhs, rhs, atEnd);
  }

  template <unsigned I>
  static bool isEqualImpl(const Tuple &, const Tuple &, std::true_type) {
    return true;
  }

  static bool isEqual(const Tuple &lhs, const Tuple &rhs) {
    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
    return isEqualImpl<0>(lhs, rhs, atEnd);
  }
};


template <typename Enum>
struct DenseMapInfo<Enum, std::enable_if_t<std::is_enum_v<Enum>>> {
  using UnderlyingType = std::underlying_type_t<Enum>;
  using Info = DenseMapInfo<UnderlyingType>;
# 322 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h"
  static constexpr Enum getEmptyKey() {
    constexpr Enum V = static_cast<Enum>(Info::getEmptyKey());
    return V;
  }

  static constexpr Enum getTombstoneKey() {
    constexpr Enum V = static_cast<Enum>(Info::getTombstoneKey());
    return V;
  }

  static unsigned getHashValue(const Enum &Val) {
    return Info::getHashValue(static_cast<UnderlyingType>(Val));
  }

  static bool isEqual(const Enum &LHS, const Enum &RHS) { return LHS == RHS; }
};

template <typename T> struct DenseMapInfo<std::optional<T>> {
  using Optional = std::optional<T>;
  using Info = DenseMapInfo<T>;

  static constexpr Optional getEmptyKey() { return {Info::getEmptyKey()}; }

  static constexpr Optional getTombstoneKey() {
    return {Info::getTombstoneKey()};
  }

  static unsigned getHashValue(const Optional &OptionalVal) {
    return detail::combineHashValue(
        OptionalVal.has_value(),
        Info::getHashValue(OptionalVal.value_or(Info::getEmptyKey())));
  }

  static bool isEqual(const Optional &LHS, const Optional &RHS) {
    if (LHS && RHS) {
      return Info::isEqual(LHS.value(), RHS.value());
    }
    return !LHS && !RHS;
  }
};
}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 2
# 34 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
namespace llvm {

template <typename T> class ArrayRef;

template <typename IteratorT> class iterator_range;

template <class Iterator>
using EnableIfConvertibleToInputIterator = std::enable_if_t<std::is_convertible<
    typename std::iterator_traits<Iterator>::iterator_category,
    std::input_iterator_tag>::value>;
# 53 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <class Size_T> class SmallVectorBase {
protected:
  void *BeginX;
  Size_T Size = 0, Capacity;


  static constexpr size_t SizeTypeMax() {
    return std::numeric_limits<Size_T>::max();
  }

  SmallVectorBase() = delete;
  SmallVectorBase(void *FirstEl, size_t TotalCapacity)
      : BeginX(FirstEl), Capacity(static_cast<Size_T>(TotalCapacity)) {}




  __attribute__((visibility("default"))) void *mallocForGrow(void *FirstEl, size_t MinSize, size_t TSize,
                               size_t &NewCapacity);




  __attribute__((visibility("default"))) void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);

public:
  size_t size() const { return Size; }
  size_t capacity() const { return Capacity; }

  [[nodiscard]] bool empty() const { return !Size; }

protected:




  void set_size(size_t N) {
    (__builtin_expect(!(N <= capacity()), 0) ? __assert_rtn(__func__, "SmallVector.h", 90, "N <= capacity()") : (void)0);
    Size = static_cast<Size_T>(N);
  }





  void set_allocation_range(void *Begin, size_t N) {
    (__builtin_expect(!(N <= SizeTypeMax()), 0) ? __assert_rtn(__func__, "SmallVector.h", 99, "N <= SizeTypeMax()") : (void)0);
    BeginX = Begin;
    Capacity = static_cast<Size_T>(N);
  }
};

template <class T>
using SmallVectorSizeType =
    std::conditional_t<sizeof(T) < 4 && sizeof(void *) >= 8, uint64_t,
                       uint32_t>;


template <class T, typename = void> struct SmallVectorAlignmentAndSize {
  alignas(SmallVectorBase<SmallVectorSizeType<T>>) char Base[sizeof(
      SmallVectorBase<SmallVectorSizeType<T>>)];
  alignas(T) char FirstEl[sizeof(T)];
};




template <typename T, typename = void>
class SmallVectorTemplateCommon
    : public SmallVectorBase<SmallVectorSizeType<T>> {
  using Base = SmallVectorBase<SmallVectorSizeType<T>>;

protected:



  void *getFirstEl() const {
    return const_cast<void *>(reinterpret_cast<const void *>(
        reinterpret_cast<const char *>(this) +
        __builtin_offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));
  }


  SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}

  void grow_pod(size_t MinSize, size_t TSize) {
    Base::grow_pod(getFirstEl(), MinSize, TSize);
  }



  bool isSmall() const { return this->BeginX == getFirstEl(); }


  void resetToSmall() {
    this->BeginX = getFirstEl();
    this->Size = this->Capacity = 0;
  }


  bool isReferenceToRange(const void *V, const void *First, const void *Last) const {

    std::less<> LessThan;
    return !LessThan(V, First) && LessThan(V, Last);
  }


  bool isReferenceToStorage(const void *V) const {
    return isReferenceToRange(V, this->begin(), this->end());
  }



  bool isRangeInStorage(const void *First, const void *Last) const {

    std::less<> LessThan;
    return !LessThan(First, this->begin()) && !LessThan(Last, First) &&
           !LessThan(this->end(), Last);
  }



  bool isSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {

    if (__builtin_expect((bool)(!isReferenceToStorage(Elt)), true))
      return true;


    if (NewSize <= this->size())
      return Elt < this->begin() + NewSize;


    return NewSize <= this->capacity();
  }


  void assertSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {
    (__builtin_expect(!(isSafeToReferenceAfterResize(Elt, NewSize) && "Attempting to reference an element of the vector in an operation " "that invalidates it"), 0) ? __assert_rtn(__func__, "SmallVector.h", 192, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"") : (void)0);


  }



  void assertSafeToAdd(const void *Elt, size_t N = 1) {
    this->assertSafeToReferenceAfterResize(Elt, this->size() + N);
  }


  void assertSafeToReferenceAfterClear(const T *From, const T *To) {
    if (From == To)
      return;
    this->assertSafeToReferenceAfterResize(From, 0);
    this->assertSafeToReferenceAfterResize(To - 1, 0);
  }
  template <
      class ItTy,
      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,
                       bool> = false>
  void assertSafeToReferenceAfterClear(ItTy, ItTy) {}


  void assertSafeToAddRange(const T *From, const T *To) {
    if (From == To)
      return;
    this->assertSafeToAdd(From, To - From);
    this->assertSafeToAdd(To - 1, To - From);
  }
  template <
      class ItTy,
      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,
                       bool> = false>
  void assertSafeToAddRange(ItTy, ItTy) {}



  template <class U>
  static const T *reserveForParamAndGetAddressImpl(U *This, const T &Elt,
                                                   size_t N) {
    size_t NewSize = This->size() + N;
    if (__builtin_expect((bool)(NewSize <= This->capacity()), true))
      return &Elt;

    bool ReferencesStorage = false;
    int64_t Index = -1;
    if (!U::TakesParamByValue) {
      if (__builtin_expect((bool)(This->isReferenceToStorage(&Elt)), false)) {
        ReferencesStorage = true;
        Index = &Elt - This->begin();
      }
    }
    This->grow(NewSize);
    return ReferencesStorage ? This->begin() + Index : &Elt;
  }

public:
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using value_type = T;
  using iterator = T *;
  using const_iterator = const T *;

  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  using reverse_iterator = std::reverse_iterator<iterator>;

  using reference = T &;
  using const_reference = const T &;
  using pointer = T *;
  using const_pointer = const T *;

  using Base::capacity;
  using Base::empty;
  using Base::size;


  iterator begin() { return (iterator)this->BeginX; }
  const_iterator begin() const { return (const_iterator)this->BeginX; }
  iterator end() { return begin() + size(); }
  const_iterator end() const { return begin() + size(); }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}

  size_type size_in_bytes() const { return size() * sizeof(T); }
  size_type max_size() const {
    return std::min(this->SizeTypeMax(), size_type(-1) / sizeof(T));
  }

  size_t capacity_in_bytes() const { return capacity() * sizeof(T); }


  pointer data() { return pointer(begin()); }

  const_pointer data() const { return const_pointer(begin()); }

  reference operator[](size_type idx) {
    (__builtin_expect(!(idx < size()), 0) ? __assert_rtn(__func__, "SmallVector.h", 292, "idx < size()") : (void)0);
    return begin()[idx];
  }
  const_reference operator[](size_type idx) const {
    (__builtin_expect(!(idx < size()), 0) ? __assert_rtn(__func__, "SmallVector.h", 296, "idx < size()") : (void)0);
    return begin()[idx];
  }

  reference front() {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 301, "!empty()") : (void)0);
    return begin()[0];
  }
  const_reference front() const {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 305, "!empty()") : (void)0);
    return begin()[0];
  }

  reference back() {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 310, "!empty()") : (void)0);
    return end()[-1];
  }
  const_reference back() const {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 314, "!empty()") : (void)0);
    return end()[-1];
  }
};
# 327 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <typename T, bool = (std::is_trivially_copy_constructible<T>::value) &&
                             (std::is_trivially_move_constructible<T>::value) &&
                             std::is_trivially_destructible<T>::value>
class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {
  friend class SmallVectorTemplateCommon<T>;

protected:
  static constexpr bool TakesParamByValue = false;
  using ValueParamT = const T &;

  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}

  static void destroy_range(T *S, T *E) {
    while (S != E) {
      --E;
      E->~T();
    }
  }



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {
    std::uninitialized_move(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {
    std::uninitialized_copy(I, E, Dest);
  }




  void grow(size_t MinSize = 0);



  T *mallocForGrow(size_t MinSize, size_t &NewCapacity);



  void moveElementsForGrow(T *NewElts);


  void takeAllocationForGrow(T *NewElts, size_t NewCapacity);



  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {
    return this->reserveForParamAndGetAddressImpl(this, Elt, N);
  }



  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {
    return const_cast<T *>(
        this->reserveForParamAndGetAddressImpl(this, Elt, N));
  }

  static T &&forward_value_param(T &&V) { return std::move(V); }
  static const T &forward_value_param(const T &V) { return V; }

  void growAndAssign(size_t NumElts, const T &Elt) {

    size_t NewCapacity;
    T *NewElts = mallocForGrow(NumElts, NewCapacity);
    std::uninitialized_fill_n(NewElts, NumElts, Elt);
    this->destroy_range(this->begin(), this->end());
    takeAllocationForGrow(NewElts, NewCapacity);
    this->set_size(NumElts);
  }

  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {

    size_t NewCapacity;
    T *NewElts = mallocForGrow(0, NewCapacity);
    ::new ((void *)(NewElts + this->size())) T(std::forward<ArgTypes>(Args)...);
    moveElementsForGrow(NewElts);
    takeAllocationForGrow(NewElts, NewCapacity);
    this->set_size(this->size() + 1);
    return this->back();
  }

public:
  void push_back(const T &Elt) {
    const T *EltPtr = reserveForParamAndGetAddress(Elt);
    ::new ((void *)this->end()) T(*EltPtr);
    this->set_size(this->size() + 1);
  }

  void push_back(T &&Elt) {
    T *EltPtr = reserveForParamAndGetAddress(Elt);
    ::new ((void *)this->end()) T(::std::move(*EltPtr));
    this->set_size(this->size() + 1);
  }

  void pop_back() {
    this->set_size(this->size() - 1);
    this->end()->~T();
  }
};


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {
  size_t NewCapacity;
  T *NewElts = mallocForGrow(MinSize, NewCapacity);
  moveElementsForGrow(NewElts);
  takeAllocationForGrow(NewElts, NewCapacity);
}

template <typename T, bool TriviallyCopyable>
T *SmallVectorTemplateBase<T, TriviallyCopyable>::mallocForGrow(
    size_t MinSize, size_t &NewCapacity) {
  return static_cast<T *>(
      SmallVectorBase<SmallVectorSizeType<T>>::mallocForGrow(
          this->getFirstEl(), MinSize, sizeof(T), NewCapacity));
}


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::moveElementsForGrow(
    T *NewElts) {

  this->uninitialized_move(this->begin(), this->end(), NewElts);


  destroy_range(this->begin(), this->end());
}


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::takeAllocationForGrow(
    T *NewElts, size_t NewCapacity) {

  if (!this->isSmall())
    free(this->begin());

  this->set_allocation_range(NewElts, NewCapacity);
}





template <typename T>
class SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {
  friend class SmallVectorTemplateCommon<T>;

protected:


  static constexpr bool TakesParamByValue = sizeof(T) <= 2 * sizeof(void *);



  using ValueParamT = std::conditional_t<TakesParamByValue, T, const T &>;

  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}


  static void destroy_range(T *, T *) {}



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {

    uninitialized_copy(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {

    std::uninitialized_copy(I, E, Dest);
  }



  template <typename T1, typename T2>
  static void uninitialized_copy(
      T1 *I, T1 *E, T2 *Dest,
      std::enable_if_t<std::is_same<std::remove_const_t<T1>, T2>::value> * =
          nullptr) {




    if (I != E)
      std::memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));
  }



  void grow(size_t MinSize = 0) { this->grow_pod(MinSize, sizeof(T)); }



  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {
    return this->reserveForParamAndGetAddressImpl(this, Elt, N);
  }



  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {
    return const_cast<T *>(
        this->reserveForParamAndGetAddressImpl(this, Elt, N));
  }


  static ValueParamT forward_value_param(ValueParamT V) { return V; }

  void growAndAssign(size_t NumElts, T Elt) {


    this->set_size(0);
    this->grow(NumElts);
    std::uninitialized_fill_n(this->begin(), NumElts, Elt);
    this->set_size(NumElts);
  }

  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {



    push_back(T(std::forward<ArgTypes>(Args)...));
    return this->back();
  }

public:
  void push_back(ValueParamT Elt) {
    const T *EltPtr = reserveForParamAndGetAddress(Elt);
    std::memcpy(reinterpret_cast<void *>(this->end()), EltPtr, sizeof(T));
    this->set_size(this->size() + 1);
  }

  void pop_back() { this->set_size(this->size() - 1); }
};



template <typename T>
class SmallVectorImpl : public SmallVectorTemplateBase<T> {
  using SuperClass = SmallVectorTemplateBase<T>;

public:
  using iterator = typename SuperClass::iterator;
  using const_iterator = typename SuperClass::const_iterator;
  using reference = typename SuperClass::reference;
  using size_type = typename SuperClass::size_type;

protected:
  using SmallVectorTemplateBase<T>::TakesParamByValue;
  using ValueParamT = typename SuperClass::ValueParamT;


  explicit SmallVectorImpl(unsigned N)
      : SmallVectorTemplateBase<T>(N) {}

  void assignRemote(SmallVectorImpl &&RHS) {
    this->destroy_range(this->begin(), this->end());
    if (!this->isSmall())
      free(this->begin());
    this->BeginX = RHS.BeginX;
    this->Size = RHS.Size;
    this->Capacity = RHS.Capacity;
    RHS.resetToSmall();
  }

  ~SmallVectorImpl() {


    if (!this->isSmall())
      free(this->begin());
  }

public:
  SmallVectorImpl(const SmallVectorImpl &) = delete;

  void clear() {
    this->destroy_range(this->begin(), this->end());
    this->Size = 0;
  }

private:

  using SuperClass::set_size;

  template <bool ForOverwrite> void resizeImpl(size_type N) {
    if (N == this->size())
      return;

    if (N < this->size()) {
      this->truncate(N);
      return;
    }

    this->reserve(N);
    for (auto I = this->end(), E = this->begin() + N; I != E; ++I)
      if (ForOverwrite)
        new (&*I) T;
      else
        new (&*I) T();
    this->set_size(N);
  }

public:
  void resize(size_type N) { resizeImpl<false>(N); }


  void resize_for_overwrite(size_type N) { resizeImpl<true>(N); }


  void truncate(size_type N) {
    (__builtin_expect(!(this->size() >= N && "Cannot increase size with truncate"), 0) ? __assert_rtn(__func__, "SmallVector.h", 646, "this->size() >= N && \"Cannot increase size with truncate\"") : (void)0);
    this->destroy_range(this->begin() + N, this->end());
    this->set_size(N);
  }

  void resize(size_type N, ValueParamT NV) {
    if (N == this->size())
      return;

    if (N < this->size()) {
      this->truncate(N);
      return;
    }


    this->append(N - this->size(), NV);
  }

  void reserve(size_type N) {
    if (this->capacity() < N)
      this->grow(N);
  }

  void pop_back_n(size_type NumItems) {
    (__builtin_expect(!(this->size() >= NumItems), 0) ? __assert_rtn(__func__, "SmallVector.h", 670, "this->size() >= NumItems") : (void)0);
    truncate(this->size() - NumItems);
  }

  [[nodiscard]] T pop_back_val() {
    T Result = ::std::move(this->back());
    this->pop_back();
    return Result;
  }

  void swap(SmallVectorImpl &RHS);


  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  void append(ItTy in_start, ItTy in_end) {
    this->assertSafeToAddRange(in_start, in_end);
    size_type NumInputs = std::distance(in_start, in_end);
    this->reserve(this->size() + NumInputs);
    this->uninitialized_copy(in_start, in_end, this->end());
    this->set_size(this->size() + NumInputs);
  }


  void append(size_type NumInputs, ValueParamT Elt) {
    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumInputs);
    std::uninitialized_fill_n(this->end(), NumInputs, *EltPtr);
    this->set_size(this->size() + NumInputs);
  }

  void append(std::initializer_list<T> IL) {
    append(IL.begin(), IL.end());
  }

  void append(const SmallVectorImpl &RHS) { append(RHS.begin(), RHS.end()); }

  void assign(size_type NumElts, ValueParamT Elt) {

    if (NumElts > this->capacity()) {
      this->growAndAssign(NumElts, Elt);
      return;
    }


    std::fill_n(this->begin(), std::min(NumElts, this->size()), Elt);
    if (NumElts > this->size())
      std::uninitialized_fill_n(this->end(), NumElts - this->size(), Elt);
    else if (NumElts < this->size())
      this->destroy_range(this->begin() + NumElts, this->end());
    this->set_size(NumElts);
  }




  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  void assign(ItTy in_start, ItTy in_end) {
    this->assertSafeToReferenceAfterClear(in_start, in_end);
    clear();
    append(in_start, in_end);
  }

  void assign(std::initializer_list<T> IL) {
    clear();
    append(IL);
  }

  void assign(const SmallVectorImpl &RHS) { assign(RHS.begin(), RHS.end()); }

  iterator erase(const_iterator CI) {

    iterator I = const_cast<iterator>(CI);

    (__builtin_expect(!(this->isReferenceToStorage(CI) && "Iterator to erase is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 742, "this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\"") : (void)0);

    iterator N = I;

    std::move(I+1, this->end(), I);

    this->pop_back();
    return(N);
  }

  iterator erase(const_iterator CS, const_iterator CE) {

    iterator S = const_cast<iterator>(CS);
    iterator E = const_cast<iterator>(CE);

    (__builtin_expect(!(this->isRangeInStorage(S, E) && "Range to erase is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 757, "this->isRangeInStorage(S, E) && \"Range to erase is out of bounds.\"") : (void)0);

    iterator N = S;

    iterator I = std::move(E, this->end(), S);

    this->destroy_range(I, this->end());
    this->set_size(I - this->begin());
    return(N);
  }

private:
  template <class ArgType> iterator insert_one_impl(iterator I, ArgType &&Elt) {

    static_assert(
        std::is_same<std::remove_const_t<std::remove_reference_t<ArgType>>,
                     T>::value,
        "ArgType must be derived from T!");

    if (I == this->end()) {
      this->push_back(::std::forward<ArgType>(Elt));
      return this->end()-1;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 781, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);


    size_t Index = I - this->begin();
    std::remove_reference_t<ArgType> *EltPtr =
        this->reserveForParamAndGetAddress(Elt);
    I = this->begin() + Index;

    ::new ((void*) this->end()) T(::std::move(this->back()));

    std::move_backward(I, this->end()-1, this->end());
    this->set_size(this->size() + 1);



    static_assert(!TakesParamByValue || std::is_same<ArgType, T>::value,
                  "ArgType must be 'T' when taking by value!");
    if (!TakesParamByValue && this->isReferenceToRange(EltPtr, I, this->end()))
      ++EltPtr;

    *I = ::std::forward<ArgType>(*EltPtr);
    return I;
  }

public:
  iterator insert(iterator I, T &&Elt) {
    return insert_one_impl(I, this->forward_value_param(std::move(Elt)));
  }

  iterator insert(iterator I, const T &Elt) {
    return insert_one_impl(I, this->forward_value_param(Elt));
  }

  iterator insert(iterator I, size_type NumToInsert, ValueParamT Elt) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(NumToInsert, Elt);
      return this->begin()+InsertElt;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 823, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);



    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumToInsert);


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(std::move_iterator<iterator>(this->end() - NumToInsert),
             std::move_iterator<iterator>(this->end()));


      std::move_backward(I, OldEnd-NumToInsert, OldEnd);



      if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())
        EltPtr += NumToInsert;

      std::fill_n(I, NumToInsert, *EltPtr);
      return I;
    }





    T *OldEnd = this->end();
    this->set_size(this->size() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);



    if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())
      EltPtr += NumToInsert;


    std::fill_n(I, NumOverwritten, *EltPtr);


    std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, *EltPtr);
    return I;
  }

  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  iterator insert(iterator I, ItTy From, ItTy To) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(From, To);
      return this->begin()+InsertElt;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 885, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);


    this->assertSafeToAddRange(From, To);

    size_t NumToInsert = std::distance(From, To);


    reserve(this->size() + NumToInsert);


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(std::move_iterator<iterator>(this->end() - NumToInsert),
             std::move_iterator<iterator>(this->end()));


      std::move_backward(I, OldEnd-NumToInsert, OldEnd);

      std::copy(From, To, I);
      return I;
    }





    T *OldEnd = this->end();
    this->set_size(this->size() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);


    for (T *J = I; NumOverwritten > 0; --NumOverwritten) {
      *J = *From;
      ++J; ++From;
    }


    this->uninitialized_copy(From, To, OldEnd);
    return I;
  }

  void insert(iterator I, std::initializer_list<T> IL) {
    insert(I, IL.begin(), IL.end());
  }

  template <typename... ArgTypes> reference emplace_back(ArgTypes &&... Args) {
    if (__builtin_expect((bool)(this->size() >= this->capacity()), false))
      return this->growAndEmplaceBack(std::forward<ArgTypes>(Args)...);

    ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);
    this->set_size(this->size() + 1);
    return this->back();
  }

  SmallVectorImpl &operator=(const SmallVectorImpl &RHS);

  SmallVectorImpl &operator=(SmallVectorImpl &&RHS);

  bool operator==(const SmallVectorImpl &RHS) const {
    if (this->size() != RHS.size()) return false;
    return std::equal(this->begin(), this->end(), RHS.begin());
  }
  bool operator!=(const SmallVectorImpl &RHS) const {
    return !(*this == RHS);
  }

  bool operator<(const SmallVectorImpl &RHS) const {
    return std::lexicographical_compare(this->begin(), this->end(),
                                        RHS.begin(), RHS.end());
  }
  bool operator>(const SmallVectorImpl &RHS) const { return RHS < *this; }
  bool operator<=(const SmallVectorImpl &RHS) const { return !(*this > RHS); }
  bool operator>=(const SmallVectorImpl &RHS) const { return !(*this < RHS); }
};

template <typename T>
void SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {
  if (this == &RHS) return;


  if (!this->isSmall() && !RHS.isSmall()) {
    std::swap(this->BeginX, RHS.BeginX);
    std::swap(this->Size, RHS.Size);
    std::swap(this->Capacity, RHS.Capacity);
    return;
  }
  this->reserve(RHS.size());
  RHS.reserve(this->size());


  size_t NumShared = this->size();
  if (NumShared > RHS.size()) NumShared = RHS.size();
  for (size_type i = 0; i != NumShared; ++i)
    std::swap((*this)[i], RHS[i]);


  if (this->size() > RHS.size()) {
    size_t EltDiff = this->size() - RHS.size();
    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());
    RHS.set_size(RHS.size() + EltDiff);
    this->destroy_range(this->begin()+NumShared, this->end());
    this->set_size(NumShared);
  } else if (RHS.size() > this->size()) {
    size_t EltDiff = RHS.size() - this->size();
    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());
    this->set_size(this->size() + EltDiff);
    this->destroy_range(RHS.begin()+NumShared, RHS.end());
    RHS.set_size(NumShared);
  }
}

template <typename T>
SmallVectorImpl<T> &SmallVectorImpl<T>::
  operator=(const SmallVectorImpl<T> &RHS) {

  if (this == &RHS) return *this;



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd;
    if (RHSSize)
      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());
    else
      NewEnd = this->begin();


    this->destroy_range(NewEnd, this->end());


    this->set_size(RHSSize);
    return *this;
  }




  if (this->capacity() < RHSSize) {

    this->clear();
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->set_size(RHSSize);
  return *this;
}

template <typename T>
SmallVectorImpl<T> &SmallVectorImpl<T>::operator=(SmallVectorImpl<T> &&RHS) {

  if (this == &RHS) return *this;


  if (!RHS.isSmall()) {
    this->assignRemote(std::move(RHS));
    return *this;
  }



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd = this->begin();
    if (RHSSize)
      NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);


    this->destroy_range(NewEnd, this->end());
    this->set_size(RHSSize);


    RHS.clear();

    return *this;
  }





  if (this->capacity() < RHSSize) {

    this->clear();
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::move(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_move(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->set_size(RHSSize);

  RHS.clear();
  return *this;
}



template <typename T, unsigned N>
struct SmallVectorStorage {
  alignas(T) char InlineElts[N * sizeof(T)];
};




template <typename T> struct alignas(T) SmallVectorStorage<T, 0> {};




template <typename T, unsigned N> class [[gsl::Owner]] SmallVector;






template <typename T> struct CalculateSmallVectorDefaultInlinedElements {







  static constexpr size_t kPreferredSmallVectorSizeof = 64;
# 1162 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
  static_assert(
      sizeof(T) <= 256,
      "You are trying to use a default number of inlined elements for "
      "`SmallVector<T>` but `sizeof(T)` is really big! Please use an "
      "explicit number of inlined elements with `SmallVector<T, N>` to make "
      "sure you really want that much inline storage.");



  static constexpr size_t PreferredInlineBytes =
      kPreferredSmallVectorSizeof - sizeof(SmallVector<T, 0>);
  static constexpr size_t NumElementsThatFit = PreferredInlineBytes / sizeof(T);
  static constexpr size_t value =
      NumElementsThatFit == 0 ? 1 : NumElementsThatFit;
};
# 1194 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <typename T,
          unsigned N = CalculateSmallVectorDefaultInlinedElements<T>::value>
class [[gsl::Owner]] SmallVector : public SmallVectorImpl<T>,
                                   SmallVectorStorage<T, N> {
public:
  SmallVector() : SmallVectorImpl<T>(N) {}

  ~SmallVector() {

    this->destroy_range(this->begin(), this->end());
  }

  explicit SmallVector(size_t Size)
    : SmallVectorImpl<T>(N) {
    this->resize(Size);
  }

  SmallVector(size_t Size, const T &Value)
    : SmallVectorImpl<T>(N) {
    this->assign(Size, Value);
  }

  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N) {
    this->append(S, E);
  }

  template <typename RangeTy>
  explicit SmallVector(const iterator_range<RangeTy> &R)
      : SmallVectorImpl<T>(N) {
    this->append(R.begin(), R.end());
  }

  SmallVector(std::initializer_list<T> IL) : SmallVectorImpl<T>(N) {
    this->append(IL);
  }

  template <typename U,
            typename = std::enable_if_t<std::is_convertible<U, T>::value>>
  explicit SmallVector(ArrayRef<U> A) : SmallVectorImpl<T>(N) {
    this->append(A.begin(), A.end());
  }

  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(RHS);
  }

  SmallVector &operator=(const SmallVector &RHS) {
    SmallVectorImpl<T>::operator=(RHS);
    return *this;
  }

  SmallVector(SmallVector &&RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(::std::move(RHS));
  }

  SmallVector(SmallVectorImpl<T> &&RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(::std::move(RHS));
  }

  SmallVector &operator=(SmallVector &&RHS) {
    if (N) {
      SmallVectorImpl<T>::operator=(::std::move(RHS));
      return *this;
    }


    if (this == &RHS)
      return *this;
    if (RHS.empty()) {
      this->destroy_range(this->begin(), this->end());
      this->Size = 0;
    } else {
      this->assignRemote(std::move(RHS));
    }
    return *this;
  }

  SmallVector &operator=(SmallVectorImpl<T> &&RHS) {
    SmallVectorImpl<T>::operator=(::std::move(RHS));
    return *this;
  }

  SmallVector &operator=(std::initializer_list<T> IL) {
    this->assign(IL);
    return *this;
  }
};

template <typename T, unsigned N>
inline size_t capacity_in_bytes(const SmallVector<T, N> &X) {
  return X.capacity_in_bytes();
}

template <typename RangeType>
using ValueTypeFromRangeType =
    std::remove_const_t<std::remove_reference_t<decltype(*std::begin(
        std::declval<RangeType &>()))>>;




template <unsigned Size, typename R>
SmallVector<ValueTypeFromRangeType<R>, Size> to_vector(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}
template <typename R>
SmallVector<ValueTypeFromRangeType<R>> to_vector(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}

template <typename Out, unsigned Size, typename R>
SmallVector<Out, Size> to_vector_of(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}

template <typename Out, typename R> SmallVector<Out> to_vector_of(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}


extern template class llvm::SmallVectorBase<uint32_t>;

extern template class llvm::SmallVectorBase<uint64_t>;



template <typename T, unsigned N> struct DenseMapInfo<llvm::SmallVector<T, N>> {
  static SmallVector<T, N> getEmptyKey() {
    return {DenseMapInfo<T>::getEmptyKey()};
  }

  static SmallVector<T, N> getTombstoneKey() {
    return {DenseMapInfo<T>::getTombstoneKey()};
  }

  static unsigned getHashValue(const SmallVector<T, N> &V) {
    return static_cast<unsigned>(hash_combine_range(V));
  }

  static bool isEqual(const SmallVector<T, N> &LHS,
                      const SmallVector<T, N> &RHS) {
    return LHS == RHS;
  }
};

}

namespace std {


  template<typename T>
  inline void
  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {
    LHS.swap(RHS);
  }


  template<typename T, unsigned N>
  inline void
  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {
    LHS.swap(RHS);
  }

}
# 14 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 1
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h" 1
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h"
namespace llvm {
# 37 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h"
template<typename Fn> class function_ref;

template <typename Ret, typename... Params>
class [[gsl::Pointer]] function_ref<Ret(Params...)> {
  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;
  intptr_t callable;

  template<typename Callable>
  static Ret callback_fn(intptr_t callable, Params ...params) {
    return (*reinterpret_cast<Callable*>(callable))(
        std::forward<Params>(params)...);
  }

public:
  function_ref() = default;
  function_ref(std::nullptr_t) {}

  template <typename Callable>
  function_ref(
      Callable &&callable [[clang::lifetimebound]],

      std::enable_if_t<!std::is_same<remove_cvref_t<Callable>,
                                     function_ref>::value> * = nullptr,

      std::enable_if_t<std::is_void<Ret>::value ||
                       std::is_convertible<decltype(std::declval<Callable>()(
                                               std::declval<Params>()...)),
                                           Ret>::value> * = nullptr)
      : callback(callback_fn<std::remove_reference_t<Callable>>),
        callable(reinterpret_cast<intptr_t>(&callable)) {}

  Ret operator()(Params ...params) const {
    return callback(callable, std::forward<Params>(params)...);
  }

  explicit operator bool() const { return callback; }

  bool operator==(const function_ref<Ret(Params...)> &Other) const {
    return callable == Other.callable;
  }
};

}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator_range.h" 1
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator_range.h"
namespace llvm {

template <typename From, typename To, typename = void>
struct explicitly_convertible : std::false_type {};

template <typename From, typename To>
struct explicitly_convertible<
    From, To,
    std::void_t<decltype(static_cast<To>(
        std::declval<std::add_rvalue_reference_t<From>>()))>> : std::true_type {
};





template <typename IteratorT>
class iterator_range {
  IteratorT begin_iterator, end_iterator;

public:






  template <
      typename Container,
      std::enable_if_t<explicitly_convertible<
          llvm::detail::IterOfRange<Container>, IteratorT>::value> * = nullptr>

  iterator_range(Container &&c)
      : begin_iterator(adl_begin(c)), end_iterator(adl_end(c)) {
  }
  iterator_range(IteratorT begin_iterator, IteratorT end_iterator)
      : begin_iterator(std::move(begin_iterator)),
        end_iterator(std::move(end_iterator)) {}

  IteratorT begin() const { return begin_iterator; }
  IteratorT end() const { return end_iterator; }
  bool empty() const { return begin_iterator == end_iterator; }
};

template <typename Container>
iterator_range(Container &&)
    -> iterator_range<llvm::detail::IterOfRange<Container>>;





template <class T> iterator_range<T> make_range(T x, T y) {
  return iterator_range<T>(std::move(x), std::move(y));
}

template <typename T> iterator_range<T> make_range(std::pair<T, T> p) {
  return iterator_range<T>(std::move(p.first), std::move(p.second));
}

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h" 2





namespace llvm {
# 77 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
template <typename DerivedT, typename IteratorCategoryT, typename T,
          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,
          typename ReferenceT = T &>
class iterator_facade_base {
public:
  using iterator_category = IteratorCategoryT;
  using value_type = T;
  using difference_type = DifferenceTypeT;
  using pointer = PointerT;
  using reference = ReferenceT;

protected:
  enum {
    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,
                                     IteratorCategoryT>::value,
    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,
                                      IteratorCategoryT>::value,
  };






  class ReferenceProxy {
    friend iterator_facade_base;

    DerivedT I;

    ReferenceProxy(DerivedT I) : I(std::move(I)) {}

  public:
    operator ReferenceT() const { return *I; }
  };





  class PointerProxy {
    friend iterator_facade_base;

    ReferenceT R;

    template <typename RefT>
    PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {}

  public:
    PointerT operator->() const { return &R; }
  };

public:
  DerivedT operator+(DifferenceTypeT n) const {
    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
    static_assert(
        IsRandomAccess,
        "The '+' operator is only defined for random access iterators.");
    DerivedT tmp = *static_cast<const DerivedT *>(this);
    tmp += n;
    return tmp;
  }
  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {
    static_assert(
        IsRandomAccess,
        "The '+' operator is only defined for random access iterators.");
    return i + n;
  }
  DerivedT operator-(DifferenceTypeT n) const {
    static_assert(
        IsRandomAccess,
        "The '-' operator is only defined for random access iterators.");
    DerivedT tmp = *static_cast<const DerivedT *>(this);
    tmp -= n;
    return tmp;
  }

  DerivedT &operator++() {
    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
    return static_cast<DerivedT *>(this)->operator+=(1);
  }
  DerivedT operator++(int) {
    DerivedT tmp = *static_cast<DerivedT *>(this);
    ++*static_cast<DerivedT *>(this);
    return tmp;
  }
  DerivedT &operator--() {
    static_assert(
        IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    return static_cast<DerivedT *>(this)->operator-=(1);
  }
  DerivedT operator--(int) {
    static_assert(
        IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    DerivedT tmp = *static_cast<DerivedT *>(this);
    --*static_cast<DerivedT *>(this);
    return tmp;
  }


  bool operator!=(const DerivedT &RHS) const {
    return !(static_cast<const DerivedT &>(*this) == RHS);
  }


  bool operator>(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) < RHS) &&
           !(static_cast<const DerivedT &>(*this) == RHS);
  }
  bool operator<=(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) > RHS);
  }
  bool operator>=(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) < RHS);
  }

  PointerProxy operator->() const {
    return static_cast<const DerivedT *>(this)->operator*();
  }
  ReferenceProxy operator[](DifferenceTypeT n) const {
    static_assert(IsRandomAccess,
                  "Subscripting is only defined for random access iterators.");
    return static_cast<const DerivedT *>(this)->operator+(n);
  }
};






template <
    typename DerivedT, typename WrappedIteratorT,
    typename IteratorCategoryT =
        typename std::iterator_traits<WrappedIteratorT>::iterator_category,
    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,
    typename DifferenceTypeT =
        typename std::iterator_traits<WrappedIteratorT>::difference_type,
    typename PointerT = std::conditional_t<
        std::is_same<T, typename std::iterator_traits<
                            WrappedIteratorT>::value_type>::value,
        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,
    typename ReferenceT = std::conditional_t<
        std::is_same<T, typename std::iterator_traits<
                            WrappedIteratorT>::value_type>::value,
        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>
class iterator_adaptor_base
    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,
                                  DifferenceTypeT, PointerT, ReferenceT> {
  using BaseT = typename iterator_adaptor_base::iterator_facade_base;

protected:
  WrappedIteratorT I;

  iterator_adaptor_base() = default;

  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {
    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
  }

  const WrappedIteratorT &wrapped() const { return I; }

public:
  using difference_type = DifferenceTypeT;

  DerivedT &operator+=(difference_type n) {
    static_assert(
        BaseT::IsRandomAccess,
        "The '+=' operator is only defined for random access iterators.");
    I += n;
    return *static_cast<DerivedT *>(this);
  }
  DerivedT &operator-=(difference_type n) {
    static_assert(
        BaseT::IsRandomAccess,
        "The '-=' operator is only defined for random access iterators.");
    I -= n;
    return *static_cast<DerivedT *>(this);
  }
  using BaseT::operator-;
  difference_type operator-(const DerivedT &RHS) const {
    static_assert(
        BaseT::IsRandomAccess,
        "The '-' operator is only defined for random access iterators.");
    return I - RHS.I;
  }



  using BaseT::operator++;
  DerivedT &operator++() {
    ++I;
    return *static_cast<DerivedT *>(this);
  }
  using BaseT::operator--;
  DerivedT &operator--() {
    static_assert(
        BaseT::IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    --I;
    return *static_cast<DerivedT *>(this);
  }

  friend bool operator==(const iterator_adaptor_base &LHS,
                         const iterator_adaptor_base &RHS) {
    return LHS.I == RHS.I;
  }
  friend bool operator<(const iterator_adaptor_base &LHS,
                        const iterator_adaptor_base &RHS) {
    static_assert(
        BaseT::IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return LHS.I < RHS.I;
  }

  ReferenceT operator*() const { return *I; }
};
# 317 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
template <typename WrappedIteratorT,
          typename T = std::remove_reference_t<decltype(
              **std::declval<WrappedIteratorT>())>>
struct pointee_iterator
    : iterator_adaptor_base<
          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,
          typename std::iterator_traits<WrappedIteratorT>::iterator_category,
          T> {
  pointee_iterator() = default;
  template <typename U>
  pointee_iterator(U &&u)
      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}

  T &operator*() const { return **this->I; }
};

template <typename RangeT, typename WrappedIteratorT =
                               decltype(std::begin(std::declval<RangeT>()))>
iterator_range<pointee_iterator<WrappedIteratorT>>
make_pointee_range(RangeT &&Range) {
  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;
  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),
                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));
}

template <typename WrappedIteratorT,
          typename T = decltype(&*std::declval<WrappedIteratorT>())>
class pointer_iterator
    : public iterator_adaptor_base<
          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,
          typename std::iterator_traits<WrappedIteratorT>::iterator_category,
          T> {
  mutable T Ptr;

public:
  pointer_iterator() = default;

  explicit pointer_iterator(WrappedIteratorT u)
      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}

  T &operator*() const { return Ptr = &*this->I; }
};

template <typename RangeT, typename WrappedIteratorT =
                               decltype(std::begin(std::declval<RangeT>()))>
iterator_range<pointer_iterator<WrappedIteratorT>>
make_pointer_range(RangeT &&Range) {
  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;
  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),
                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));
}

template <typename WrappedIteratorT,
          typename T1 = std::remove_reference_t<decltype(
              **std::declval<WrappedIteratorT>())>,
          typename T2 = std::add_pointer_t<T1>>
using raw_pointer_iterator =
    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;

}
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2
# 47 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
namespace llvm {





template <typename T> struct make_const_ptr {
  using type = std::add_pointer_t<std::add_const_t<T>>;
};

template <typename T> struct make_const_ref {
  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;
};

namespace detail {
template <class, template <class...> class Op, class... Args> struct detector {
  using value_t = std::false_type;
};
template <template <class...> class Op, class... Args>
struct detector<std::void_t<Op<Args...>>, Op, Args...> {
  using value_t = std::true_type;
};
}
# 78 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <template <class...> class Op, class... Args>
using is_detected = typename detail::detector<void, Op, Args...>::value_t;





template <typename T, bool isClass = std::is_class<T>::value>
struct function_traits : public function_traits<decltype(&T::operator())> {};


template <typename ClassType, typename ReturnType, typename... Args>
struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {

  enum { num_args = sizeof...(Args) };


  using result_t = ReturnType;


  template <size_t Index>
  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;
};

template <typename ClassType, typename ReturnType, typename... Args>
struct function_traits<ReturnType (ClassType::*)(Args...), false>
    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};

template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (*)(Args...), false> {

  enum { num_args = sizeof...(Args) };


  using result_t = ReturnType;


  template <size_t i>
  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;
};
template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (*const)(Args...), false>
    : public function_traits<ReturnType (*)(Args...)> {};

template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (&)(Args...), false>
    : public function_traits<ReturnType (*)(Args...)> {};



template <typename T, typename... Ts>
using is_one_of = std::disjunction<std::is_same<T, Ts>...>;



template <typename T, typename... Ts>
using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;

namespace detail {
template <typename T, typename... Us> struct TypesAreDistinct;
template <typename T, typename... Us>
struct TypesAreDistinct
    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&
                                       TypesAreDistinct<Us...>::value> {};
template <typename T> struct TypesAreDistinct<T> : std::true_type {};
}
# 152 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... Ts> struct TypesAreDistinct;
template <> struct TypesAreDistinct<> : std::true_type {};
template <typename... Ts>
struct TypesAreDistinct
    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};
# 168 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T, typename... Us> struct FirstIndexOfType;
template <typename T, typename U, typename... Us>
struct FirstIndexOfType<T, U, Us...>
    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};
template <typename T, typename... Us>
struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};




template <size_t I, typename... Ts>
using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;



template <typename EnumTy1, typename EnumTy2,
          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,
                                          std::underlying_type_t<EnumTy1>>,
          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,
                                          std::underlying_type_t<EnumTy2>>>
constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {
  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);
}





namespace callable_detail {
# 208 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T,
          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>>
class Callable {
  using value_type = std::remove_reference_t<T>;
  using reference = value_type &;
  using const_reference = value_type const &;

  std::optional<value_type> Obj;

  static_assert(!std::is_pointer_v<value_type>,
                "Pointers to non-functions are not callable.");

public:
  Callable() = default;
  Callable(T const &O) : Obj(std::in_place, O) {}

  Callable(Callable const &Other) = default;
  Callable(Callable &&Other) = default;

  Callable &operator=(Callable const &Other) {
    Obj = std::nullopt;
    if (Other.Obj)
      Obj.emplace(*Other.Obj);
    return *this;
  }

  Callable &operator=(Callable &&Other) {
    Obj = std::nullopt;
    if (Other.Obj)
      Obj.emplace(std::move(*Other.Obj));
    return *this;
  }

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) {
    return (*Obj)(std::forward<Pn>(Params)...);
  }

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) const {
    return (*Obj)(std::forward<Pn>(Params)...);
  }

  bool valid() const { return Obj != std::nullopt; }
  bool reset() { return Obj = std::nullopt; }

  operator reference() { return *Obj; }
  operator const_reference() const { return *Obj; }
};



template <typename T> class Callable<T, true> {
  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;

  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;
  using CastT = std::conditional_t<IsPtr, T, T &>;

private:
  StorageT Func = nullptr;

private:
  template <typename In> static constexpr auto convertIn(In &&I) {
    if constexpr (IsPtr) {

      return I;
    } else {

      return &I;
    }
  }

public:
  Callable() = default;





  template <
    typename FnPtrOrRef,
    std::enable_if_t<
      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int
    > = 0
  >
  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) const {
    return Func(std::forward<Pn>(Params)...);
  }

  bool valid() const { return Func != nullptr; }
  void reset() { Func = nullptr; }

  operator T const &() const {
    if constexpr (IsPtr) {

      return Func;
    } else {
      static_assert(std::is_reference_v<T>,
                    "Expected a reference to a function.");

      return *Func;
    }
  }
};

}


template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {
  auto B = adl_begin(C);
  auto E = adl_end(C);
  return B != E && std::next(B) == E;
}



template <typename ContainerTy>
decltype(auto) getSingleElement(ContainerTy &&C) {
  (__builtin_expect(!(hasSingleElement(C) && "expected container with single element"), 0) ? __assert_rtn(__func__, "STLExtras.h", 332, "hasSingleElement(C) && \"expected container with single element\"") : (void)0);
  return *adl_begin(C);
}



template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {
  return make_range(std::next(adl_begin(RangeOrContainer), N),
                    adl_end(RangeOrContainer));
}



template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {
  return make_range(adl_begin(RangeOrContainer),
                    std::prev(adl_end(RangeOrContainer), N));
}




template <typename ItTy, typename FuncTy,
          typename ReferenceTy =
              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>
class mapped_iterator
    : public iterator_adaptor_base<
          mapped_iterator<ItTy, FuncTy>, ItTy,
          typename std::iterator_traits<ItTy>::iterator_category,
          std::remove_reference_t<ReferenceTy>,
          typename std::iterator_traits<ItTy>::difference_type,
          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
public:
  mapped_iterator() = default;
  mapped_iterator(ItTy U, FuncTy F)
    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}

  ItTy getCurrent() { return this->I; }

  const FuncTy &getFunction() const { return F; }

  ReferenceTy operator*() const { return F(*this->I); }

private:
  callable_detail::Callable<FuncTy> F{};
};



template <class ItTy, class FuncTy>
inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {
  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));
}

template <class ContainerTy, class FuncTy>
auto map_range(ContainerTy &&C, FuncTy F) {
  return make_range(map_iterator(adl_begin(C), F), map_iterator(adl_end(C), F));
}






template <typename DerivedT, typename ItTy, typename ReferenceTy>
class mapped_iterator_base
    : public iterator_adaptor_base<
          DerivedT, ItTy,
          typename std::iterator_traits<ItTy>::iterator_category,
          std::remove_reference_t<ReferenceTy>,
          typename std::iterator_traits<ItTy>::difference_type,
          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
public:
  using BaseT = mapped_iterator_base;

  mapped_iterator_base(ItTy U)
      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}

  ItTy getCurrent() { return this->I; }

  ReferenceTy operator*() const {
    return static_cast<const DerivedT &>(*this).mapElement(*this->I);
  }
};

namespace detail {
template <typename Range>
using check_has_free_function_rbegin =
    decltype(adl_rbegin(std::declval<Range &>()));

template <typename Range>
static constexpr bool HasFreeFunctionRBegin =
    is_detected<check_has_free_function_rbegin, Range>::value;
}



template <typename ContainerTy> [[nodiscard]] auto reverse(ContainerTy &&C) {
  if constexpr (detail::HasFreeFunctionRBegin<ContainerTy>)
    return make_range(adl_rbegin(C), adl_rend(C));
  else
    return make_range(std::make_reverse_iterator(adl_end(C)),
                      std::make_reverse_iterator(adl_begin(C)));
}
# 452 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename WrappedIteratorT, typename PredicateT, typename IterTag>
class filter_iterator_base
    : public iterator_adaptor_base<
          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,
          WrappedIteratorT,
          std::common_type_t<IterTag,
                             typename std::iterator_traits<
                                 WrappedIteratorT>::iterator_category>> {
  using BaseT = typename filter_iterator_base::iterator_adaptor_base;

protected:
  WrappedIteratorT End;
  PredicateT Pred;

  void findNextValid() {
    while (this->I != End && !Pred(*this->I))
      BaseT::operator++();
  }

  filter_iterator_base() = default;




  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : BaseT(Begin), End(End), Pred(Pred) {
    findNextValid();
  }

public:
  using BaseT::operator++;

  filter_iterator_base &operator++() {
    BaseT::operator++();
    findNextValid();
    return *this;
  }

  decltype(auto) operator*() const {
    (__builtin_expect(!(BaseT::wrapped() != End && "Cannot dereference end iterator!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 492, "BaseT::wrapped() != End && \"Cannot dereference end iterator!\"") : (void)0);
    return BaseT::operator*();
  }

  decltype(auto) operator->() const {
    (__builtin_expect(!(BaseT::wrapped() != End && "Cannot dereference end iterator!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 497, "BaseT::wrapped() != End && \"Cannot dereference end iterator!\"") : (void)0);
    return BaseT::operator->();
  }
};


template <typename WrappedIteratorT, typename PredicateT,
          typename IterTag = std::forward_iterator_tag>
class filter_iterator_impl
    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {
public:
  filter_iterator_impl() = default;

  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}
};


template <typename WrappedIteratorT, typename PredicateT>
class filter_iterator_impl<WrappedIteratorT, PredicateT,
                           std::bidirectional_iterator_tag>
    : public filter_iterator_base<WrappedIteratorT, PredicateT,
                                  std::bidirectional_iterator_tag> {
  using BaseT = typename filter_iterator_impl::filter_iterator_base;

  void findPrevValid() {
    while (!this->Pred(*this->I))
      BaseT::operator--();
  }

public:
  using BaseT::operator--;

  filter_iterator_impl() = default;

  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : BaseT(Begin, End, Pred) {}

  filter_iterator_impl &operator--() {
    BaseT::operator--();
    findPrevValid();
    return *this;
  }
};

namespace detail {

template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {
  using type = std::forward_iterator_tag;
};

template <> struct fwd_or_bidi_tag_impl<true> {
  using type = std::bidirectional_iterator_tag;
};




template <typename IterT> struct fwd_or_bidi_tag {
  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<
      std::bidirectional_iterator_tag,
      typename std::iterator_traits<IterT>::iterator_category>::value>::type;
};

}



template <typename WrappedIteratorT, typename PredicateT>
using filter_iterator = filter_iterator_impl<
    WrappedIteratorT, PredicateT,
    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;
# 579 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename RangeT, typename PredicateT>
iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>
make_filter_range(RangeT &&Range, PredicateT Pred) {
  using FilterIteratorT =
      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;
  auto B = adl_begin(Range);
  auto E = adl_end(Range);
  return make_range(FilterIteratorT(B, E, Pred), FilterIteratorT(E, E, Pred));
}
# 606 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename WrappedIteratorT>
class early_inc_iterator_impl
    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,
                                   WrappedIteratorT, std::input_iterator_tag> {
  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;

  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;

protected:

  bool IsEarlyIncremented = false;


public:
  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}

  using BaseT::operator*;
  decltype(*std::declval<WrappedIteratorT>()) operator*() {

    (__builtin_expect(!(!IsEarlyIncremented && "Cannot dereference twice!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 625, "!IsEarlyIncremented && \"Cannot dereference twice!\"") : (void)0);
    IsEarlyIncremented = true;

    return *(this->I)++;
  }

  using BaseT::operator++;
  early_inc_iterator_impl &operator++() {

    (__builtin_expect(!(IsEarlyIncremented && "Cannot increment before dereferencing!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 634, "IsEarlyIncremented && \"Cannot increment before dereferencing!\"") : (void)0);
    IsEarlyIncremented = false;

    return *this;
  }

  friend bool operator==(const early_inc_iterator_impl &LHS,
                         const early_inc_iterator_impl &RHS) {

    (__builtin_expect(!(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 643, "!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\"") : (void)0);

    return (const BaseT &)LHS == (const BaseT &)RHS;
  }
};
# 661 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename RangeT>
iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>
make_early_inc_range(RangeT &&Range) {
  using EarlyIncIteratorT =
      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;
  return make_range(EarlyIncIteratorT(adl_begin(Range)),
                    EarlyIncIteratorT(adl_end(Range)));
}


template <typename R, typename UnaryPredicate>
bool all_of(R &&range, UnaryPredicate P);

template <typename R, typename UnaryPredicate>
bool any_of(R &&range, UnaryPredicate P);

template <typename T> bool all_equal(std::initializer_list<T> Values);

template <typename R> constexpr size_t range_size(R &&Range);

namespace detail {

using std::declval;



template<typename... Iters> struct ZipTupleType {
  using type = std::tuple<decltype(*declval<Iters>())...>;
};

template <typename ZipType, typename ReferenceTupleType, typename... Iters>
using zip_traits = iterator_facade_base<
    ZipType,
    std::common_type_t<
        std::bidirectional_iterator_tag,
        typename std::iterator_traits<Iters>::iterator_category...>,

    ReferenceTupleType,
    typename std::iterator_traits<
        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,




    ReferenceTupleType *, ReferenceTupleType>;

template <typename ZipType, typename ReferenceTupleType, typename... Iters>
struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {
  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;
  using IndexSequence = std::index_sequence_for<Iters...>;
  using value_type = typename Base::value_type;

  std::tuple<Iters...> iterators;

protected:
  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
    return value_type(*std::get<Ns>(iterators)...);
  }

  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {
    (++std::get<Ns>(iterators), ...);
  }

  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {
    (--std::get<Ns>(iterators), ...);
  }

  template <size_t... Ns>
  bool test_all_equals(const zip_common &other,
                       std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&
            ...);
  }

public:
  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}

  value_type operator*() const { return deref(IndexSequence{}); }

  ZipType &operator++() {
    tup_inc(IndexSequence{});
    return static_cast<ZipType &>(*this);
  }

  ZipType &operator--() {
    static_assert(Base::IsBidirectional,
                  "All inner iterators must be at least bidirectional.");
    tup_dec(IndexSequence{});
    return static_cast<ZipType &>(*this);
  }


  bool all_equals(zip_common &other) {
    return test_all_equals(other, IndexSequence{});
  }
};

template <typename... Iters>
struct zip_first : zip_common<zip_first<Iters...>,
                              typename ZipTupleType<Iters...>::type, Iters...> {
  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,
                   Iters...>::zip_common;

  bool operator==(const zip_first &other) const {
    return std::get<0>(this->iterators) == std::get<0>(other.iterators);
  }
};

template <typename... Iters>
struct zip_shortest
    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,
                 Iters...> {
  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,
                   Iters...>::zip_common;

  bool operator==(const zip_shortest &other) const {
    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});
  }

private:
  template <size_t... Ns>
  bool any_iterator_equals(const zip_shortest &other,
                           std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||
            ...);
  }
};


template <template <typename...> class ItType, typename TupleStorageType,
          typename IndexSequence>
struct ZippyIteratorTuple;


template <template <typename...> class ItType, typename... Args,
          std::size_t... Ns>
struct ZippyIteratorTuple<ItType, std::tuple<Args...>,
                          std::index_sequence<Ns...>> {
  using type = ItType<decltype(adl_begin(
      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;
};


template <template <typename...> class ItType, typename... Args,
          std::size_t... Ns>
struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,
                          std::index_sequence<Ns...>> {
  using type = ItType<decltype(adl_begin(
      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;
};

template <template <typename...> class ItType, typename... Args> class zippy {
private:
  std::tuple<Args...> storage;
  using IndexSequence = std::index_sequence_for<Args...>;

public:
  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),
                                               IndexSequence>::type;
  using const_iterator =
      typename ZippyIteratorTuple<ItType, const decltype(storage),
                                  IndexSequence>::type;
  using iterator_category = typename iterator::iterator_category;
  using value_type = typename iterator::value_type;
  using difference_type = typename iterator::difference_type;
  using pointer = typename iterator::pointer;
  using reference = typename iterator::reference;
  using const_reference = typename const_iterator::reference;

  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}

  const_iterator begin() const { return begin_impl(IndexSequence{}); }
  iterator begin() { return begin_impl(IndexSequence{}); }
  const_iterator end() const { return end_impl(IndexSequence{}); }
  iterator end() { return end_impl(IndexSequence{}); }

private:
  template <size_t... Ns>
  const_iterator begin_impl(std::index_sequence<Ns...>) const {
    return const_iterator(adl_begin(std::get<Ns>(storage))...);
  }
  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {
    return iterator(adl_begin(std::get<Ns>(storage))...);
  }

  template <size_t... Ns>
  const_iterator end_impl(std::index_sequence<Ns...>) const {
    return const_iterator(adl_end(std::get<Ns>(storage))...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
    return iterator(adl_end(std::get<Ns>(storage))...);
  }
};

}



template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,
                                                       Args &&...args) {
  return detail::zippy<detail::zip_shortest, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}




template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,
                                                          Args &&...args) {
  (__builtin_expect(!(all_equal({range_size(t), range_size(u), range_size(args)...}) && "Iteratees do not have equal length"), 0) ? __assert_rtn(__func__, "STLExtras.h", 873, "all_equal({range_size(t), range_size(u), range_size(args)...}) && \"Iteratees do not have equal length\"") : (void)0);

  return detail::zippy<detail::zip_first, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}





template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,
                                                          Args &&...args) {
  (__builtin_expect(!(range_size(t) <= std::min({range_size(u), range_size(args)...}) && "First iteratee is not the shortest"), 0) ? __assert_rtn(__func__, "STLExtras.h", 886, "range_size(t) <= std::min({range_size(u), range_size(args)...}) && \"First iteratee is not the shortest\"") : (void)0);


  return detail::zippy<detail::zip_first, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}

namespace detail {
template <typename Iter>
Iter next_or_end(const Iter &I, const Iter &End) {
  if (I == End)
    return End;
  return std::next(I);
}

template <typename Iter>
auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<
    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {
  if (I == End)
    return std::nullopt;
  return *I;
}

template <typename Iter> struct ZipLongestItemType {
  using type = std::optional<std::remove_const_t<
      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;
};

template <typename... Iters> struct ZipLongestTupleType {
  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;
};

template <typename... Iters>
class zip_longest_iterator
    : public iterator_facade_base<
          zip_longest_iterator<Iters...>,
          std::common_type_t<
              std::forward_iterator_tag,
              typename std::iterator_traits<Iters>::iterator_category...>,
          typename ZipLongestTupleType<Iters...>::type,
          typename std::iterator_traits<
              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,
          typename ZipLongestTupleType<Iters...>::type *,
          typename ZipLongestTupleType<Iters...>::type> {
public:
  using value_type = typename ZipLongestTupleType<Iters...>::type;

private:
  std::tuple<Iters...> iterators;
  std::tuple<Iters...> end_iterators;

  template <size_t... Ns>
  bool test(const zip_longest_iterator<Iters...> &other,
            std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||
            ...);
  }

  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
    return value_type(
        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
  }

  template <size_t... Ns>
  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
    return std::tuple<Iters...>(
        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
  }

public:
  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)
      : iterators(std::forward<Iters>(ts.first)...),
        end_iterators(std::forward<Iters>(ts.second)...) {}

  value_type operator*() const {
    return deref(std::index_sequence_for<Iters...>{});
  }

  zip_longest_iterator<Iters...> &operator++() {
    iterators = tup_inc(std::index_sequence_for<Iters...>{});
    return *this;
  }

  bool operator==(const zip_longest_iterator<Iters...> &other) const {
    return !test(other, std::index_sequence_for<Iters...>{});
  }
};

template <typename... Args> class zip_longest_range {
public:
  using iterator =
      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;
  using iterator_category = typename iterator::iterator_category;
  using value_type = typename iterator::value_type;
  using difference_type = typename iterator::difference_type;
  using pointer = typename iterator::pointer;
  using reference = typename iterator::reference;

private:
  std::tuple<Args...> ts;

  template <size_t... Ns>
  iterator begin_impl(std::index_sequence<Ns...>) const {
    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),
                                   adl_end(std::get<Ns>(ts)))...);
  }

  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),
                                   adl_end(std::get<Ns>(ts)))...);
  }

public:
  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}

  iterator begin() const {
    return begin_impl(std::index_sequence_for<Args...>{});
  }
  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
};
}




template <typename T, typename U, typename... Args>
detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,
                                                     Args &&... args) {
  return detail::zip_longest_range<T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}
# 1027 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename ValueT, typename... IterTs>
class concat_iterator
    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,
                                  std::forward_iterator_tag, ValueT> {
  using BaseT = typename concat_iterator::iterator_facade_base;

  static constexpr bool ReturnsByValue =
      !(std::is_reference_v<decltype(*std::declval<IterTs>())> && ...);

  using reference_type =
      typename std::conditional_t<ReturnsByValue, ValueT, ValueT &>;

  using handle_type =
      typename std::conditional_t<ReturnsByValue, std::optional<ValueT>,
                                  ValueT *>;







  std::tuple<IterTs...> Begins;
  std::tuple<IterTs...> Ends;





  template <size_t Index> bool incrementHelper() {
    auto &Begin = std::get<Index>(Begins);
    auto &End = std::get<Index>(Ends);
    if (Begin == End)
      return false;

    ++Begin;
    return true;
  }




  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {

    bool (concat_iterator::*IncrementHelperFns[])() = {
        &concat_iterator::incrementHelper<Ns>...};


    for (auto &IncrementHelperFn : IncrementHelperFns)
      if ((this->*IncrementHelperFn)())
        return;

    ::llvm::llvm_unreachable_internal("Attempted to increment an end concat iterator!", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h", 1079);
  }




  template <size_t Index> handle_type getHelper() const {
    auto &Begin = std::get<Index>(Begins);
    auto &End = std::get<Index>(Ends);
    if (Begin == End)
      return {};

    if constexpr (ReturnsByValue)
      return *Begin;
    else
      return &*Begin;
  }





  template <size_t... Ns> reference_type get(std::index_sequence<Ns...>) const {

    handle_type (concat_iterator::*GetHelperFns[])()
        const = {&concat_iterator::getHelper<Ns>...};


    for (auto &GetHelperFn : GetHelperFns)
      if (auto P = (this->*GetHelperFn)())
        return *P;

    ::llvm::llvm_unreachable_internal("Attempted to get a pointer from an end concat iterator!", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h", 1111);
  }

public:




  template <typename... RangeTs>
  explicit concat_iterator(RangeTs &&...Ranges)
      : Begins(adl_begin(Ranges)...), Ends(adl_end(Ranges)...) {}

  using BaseT::operator++;

  concat_iterator &operator++() {
    increment(std::index_sequence_for<IterTs...>());
    return *this;
  }

  reference_type operator*() const {
    return get(std::index_sequence_for<IterTs...>());
  }

  bool operator==(const concat_iterator &RHS) const {
    return Begins == RHS.Begins && Ends == RHS.Ends;
  }
};

namespace detail {






template <typename ValueT, typename... RangeTs> class concat_range {
public:
  using iterator =
      concat_iterator<ValueT,
                      decltype(adl_begin(std::declval<RangeTs &>()))...>;

private:
  std::tuple<RangeTs...> Ranges;

  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {
    return iterator(std::get<Ns>(Ranges)...);
  }
  template <size_t... Ns>
  iterator begin_impl(std::index_sequence<Ns...>) const {
    return iterator(std::get<Ns>(Ranges)...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
    return iterator(make_range(adl_end(std::get<Ns>(Ranges)),
                               adl_end(std::get<Ns>(Ranges)))...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
    return iterator(make_range(adl_end(std::get<Ns>(Ranges)),
                               adl_end(std::get<Ns>(Ranges)))...);
  }

public:
  concat_range(RangeTs &&... Ranges)
      : Ranges(std::forward<RangeTs>(Ranges)...) {}

  iterator begin() {
    return begin_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator begin() const {
    return begin_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator end() {
    return end_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator end() const {
    return end_impl(std::index_sequence_for<RangeTs...>{});
  }
};

}





template <typename ValueT, typename... RangeTs>
[[nodiscard]] detail::concat_range<ValueT, RangeTs...>
concat(RangeTs &&...Ranges) {
  static_assert(sizeof...(RangeTs) > 1,
                "Need more than one range to concatenate!");
  return detail::concat_range<ValueT, RangeTs...>(
      std::forward<RangeTs>(Ranges)...);
}



template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_iterator
    : public llvm::iterator_facade_base<DerivedT,
                                        std::random_access_iterator_tag, T,
                                        std::ptrdiff_t, PointerT, ReferenceT> {
public:
  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {
    (__builtin_expect(!(base == rhs.base && "incompatible iterators"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1214, "base == rhs.base && \"incompatible iterators\"") : (void)0);
    return index - rhs.index;
  }
  bool operator==(const indexed_accessor_iterator &rhs) const {
    (__builtin_expect(!(base == rhs.base && "incompatible iterators"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1218, "base == rhs.base && \"incompatible iterators\"") : (void)0);
    return index == rhs.index;
  }
  bool operator<(const indexed_accessor_iterator &rhs) const {
    (__builtin_expect(!(base == rhs.base && "incompatible iterators"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1222, "base == rhs.base && \"incompatible iterators\"") : (void)0);
    return index < rhs.index;
  }

  DerivedT &operator+=(ptrdiff_t offset) {
    this->index += offset;
    return static_cast<DerivedT &>(*this);
  }
  DerivedT &operator-=(ptrdiff_t offset) {
    this->index -= offset;
    return static_cast<DerivedT &>(*this);
  }


  ptrdiff_t getIndex() const { return index; }


  const BaseT &getBase() const { return base; }

protected:
  indexed_accessor_iterator(BaseT base, ptrdiff_t index)
      : base(base), index(index) {}
  BaseT base;
  ptrdiff_t index;
};

namespace detail {
# 1259 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_range_base {
public:
  using RangeBaseT = indexed_accessor_range_base;


  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,
                                                    PointerT, ReferenceT> {
  public:

    ReferenceT operator*() const {
      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());
    }

  private:
    iterator(BaseT owner, ptrdiff_t curIndex)
        : iterator::indexed_accessor_iterator(owner, curIndex) {}


    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
                                       ReferenceT>;
  };

  indexed_accessor_range_base(iterator begin, iterator end)
      : base(offset_base(begin.getBase(), begin.getIndex())),
        count(end.getIndex() - begin.getIndex()) {}
  indexed_accessor_range_base(const iterator_range<iterator> &range)
      : indexed_accessor_range_base(range.begin(), range.end()) {}
  indexed_accessor_range_base(BaseT base, ptrdiff_t count)
      : base(base), count(count) {}

  iterator begin() const { return iterator(base, 0); }
  iterator end() const { return iterator(base, count); }
  ReferenceT operator[](size_t Index) const {
    (__builtin_expect(!(Index < size() && "invalid index for value range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1294, "Index < size() && \"invalid index for value range\"") : (void)0);
    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));
  }
  ReferenceT front() const {
    (__builtin_expect(!(!empty() && "expected non-empty range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1298, "!empty() && \"expected non-empty range\"") : (void)0);
    return (*this)[0];
  }
  ReferenceT back() const {
    (__builtin_expect(!(!empty() && "expected non-empty range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1302, "!empty() && \"expected non-empty range\"") : (void)0);
    return (*this)[size() - 1];
  }


  size_t size() const { return count; }


  bool empty() const { return size() == 0; }


  DerivedT slice(size_t n, size_t m) const {
    (__builtin_expect(!(n + m <= size() && "invalid size specifiers"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1314, "n + m <= size() && \"invalid size specifiers\"") : (void)0);
    return DerivedT(offset_base(base, n), m);
  }


  DerivedT drop_front(size_t n = 1) const {
    (__builtin_expect(!(size() >= n && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1320, "size() >= n && \"Dropping more elements than exist\"") : (void)0);
    return slice(n, size() - n);
  }

  DerivedT drop_back(size_t n = 1) const {
    (__builtin_expect(!(size() >= n && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1325, "size() >= n && \"Dropping more elements than exist\"") : (void)0);
    return DerivedT(base, size() - n);
  }


  DerivedT take_front(size_t n = 1) const {
    return n < size() ? drop_back(size() - n)
                      : static_cast<const DerivedT &>(*this);
  }


  DerivedT take_back(size_t n = 1) const {
    return n < size() ? drop_front(size() - n)
                      : static_cast<const DerivedT &>(*this);
  }


  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<
                                 RangeT, iterator_range<iterator>>::value>>
  operator RangeT() const {
    return RangeT(iterator_range<iterator>(*this));
  }


  const BaseT &getBase() const { return base; }

private:

  static BaseT offset_base(const BaseT &base, size_t n) {
    return n == 0 ? base : DerivedT::offset_base(base, n);
  }

protected:
  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;
  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;
  indexed_accessor_range_base &
  operator=(const indexed_accessor_range_base &) = default;


  BaseT base;

  ptrdiff_t count;
};


template <typename OtherT, typename DerivedT, typename BaseT, typename T,
          typename PointerT, typename ReferenceT>
bool operator==(const indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
                                                  ReferenceT> &lhs,
                const OtherT &rhs) {
  return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
}

template <typename OtherT, typename DerivedT, typename BaseT, typename T,
          typename PointerT, typename ReferenceT>
bool operator!=(const indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
                                                  ReferenceT> &lhs,
                const OtherT &rhs) {
  return !(lhs == rhs);
}
}
# 1394 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_range
    : public detail::indexed_accessor_range_base<
          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {
public:
  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)
      : detail::indexed_accessor_range_base<
            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(
            std::make_pair(base, startIndex), count) {}
  using detail::indexed_accessor_range_base<
      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,
      ReferenceT>::indexed_accessor_range_base;


  const BaseT &getBase() const { return this->base.first; }


  ptrdiff_t getStartIndex() const { return this->base.second; }


  static std::pair<BaseT, ptrdiff_t>
  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {


    return std::make_pair(base.first, base.second + index);
  }

  static ReferenceT
  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,
                       ptrdiff_t index) {
    return DerivedT::dereference(base.first, base.second + index);
  }
};

namespace detail {






template <typename EltTy, typename FirstTy> class first_or_second_type {
public:
  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,
                                  std::remove_reference_t<FirstTy>>;
};
}


template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {
  using EltTy = decltype(*adl_begin(c));
  return llvm::map_range(std::forward<ContainerTy>(c),
                         [](EltTy elt) -> typename detail::first_or_second_type<
                                           EltTy, decltype((elt.first))>::type {
                           return elt.first;
                         });
}


template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {
  using EltTy = decltype(*adl_begin(c));
  return llvm::map_range(
      std::forward<ContainerTy>(c),
      [](EltTy elt) ->
      typename detail::first_or_second_type<EltTy,
                                            decltype((elt.second))>::type {
        return elt.second;
      });
}
# 1472 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
struct less_first {
  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));
  }
};




struct less_second {
  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));
  }
};



template<typename FuncTy>
struct on_first {
  FuncTy func;

  template <typename T>
  decltype(auto) operator()(const T &lhs, const T &rhs) const {
    return func(lhs.first, rhs.first);
  }
};



template <int N> struct rank : rank<N - 1> {};
template <> struct rank<0> {};

namespace detail {
template <typename... Ts> struct Visitor;

template <typename HeadT, typename... TailTs>
struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {
  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)
      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),
        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}
  using remove_cvref_t<HeadT>::operator();
  using Visitor<TailTs...>::operator();
};

template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {
  explicit constexpr Visitor(HeadT &&Head)
      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}
  using remove_cvref_t<HeadT>::operator();
};
}
# 1551 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... CallableTs>
constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {
  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);
}







template <class Iterator, class RNG>
void shuffle(Iterator first, Iterator last, RNG &&g) {


  typedef
      typename std::iterator_traits<Iterator>::difference_type difference_type;
  for (auto size = last - first; size > 1; ++first, (void)--size) {
    difference_type offset = g() % size;


    if (offset != difference_type(0))
      std::iter_swap(first, first + offset);
  }
}


template<typename T>
inline int array_pod_sort_comparator(const void *P1, const void *P2) {
  if (std::less<T>()(*reinterpret_cast<const T*>(P1),
                     *reinterpret_cast<const T*>(P2)))
    return -1;
  if (std::less<T>()(*reinterpret_cast<const T*>(P2),
                     *reinterpret_cast<const T*>(P1)))
    return 1;
  return 0;
}



template<typename T>
inline int (*get_array_pod_sort_comparator(const T &))
             (const void*, const void*) {
  return array_pod_sort_comparator<T>;
}
# 1628 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template<class IteratorTy>
inline void array_pod_sort(IteratorTy Start, IteratorTy End) {


  auto NElts = End - Start;
  if (NElts <= 1) return;



  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));
}

template <class IteratorTy>
inline void array_pod_sort(
    IteratorTy Start, IteratorTy End,
    int (*Compare)(
        const typename std::iterator_traits<IteratorTy>::value_type *,
        const typename std::iterator_traits<IteratorTy>::value_type *)) {


  auto NElts = End - Start;
  if (NElts <= 1) return;



  qsort(&*Start, NElts, sizeof(*Start),
        reinterpret_cast<int (*)(const void *, const void *)>(Compare));
}

namespace detail {
template <typename T>


using sort_trivially_copyable = std::conjunction<
    std::is_pointer<T>,
    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;
}



template <typename IteratorTy>
inline void sort(IteratorTy Start, IteratorTy End) {
  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {


    array_pod_sort(Start, End);
  } else {



    std::sort(Start, End);
  }
}

template <typename Container> inline void sort(Container &&C) {
  llvm::sort(adl_begin(C), adl_end(C));
}

template <typename IteratorTy, typename Compare>
inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {



  std::sort(Start, End, Comp);
}

template <typename Container, typename Compare>
inline void sort(Container &&C, Compare Comp) {
  llvm::sort(adl_begin(C), adl_end(C), Comp);
}



template <typename R>
auto size(R &&Range,
          std::enable_if_t<
              std::is_base_of<std::random_access_iterator_tag,
                              typename std::iterator_traits<decltype(
                                  Range.begin())>::iterator_category>::value,
              void> * = nullptr) {
  return std::distance(Range.begin(), Range.end());
}

namespace detail {
template <typename Range>
using check_has_free_function_size =
    decltype(adl_size(std::declval<Range &>()));

template <typename Range>
static constexpr bool HasFreeFunctionSize =
    is_detected<check_has_free_function_size, Range>::value;
}







template <typename R> constexpr size_t range_size(R &&Range) {
  if constexpr (detail::HasFreeFunctionSize<R>)
    return adl_size(Range);
  else
    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));
}



template <typename R, typename UnaryFunction>
UnaryFunction for_each(R &&Range, UnaryFunction F) {
  return std::for_each(adl_begin(Range), adl_end(Range), F);
}



template <typename R, typename UnaryPredicate>
bool all_of(R &&Range, UnaryPredicate P) {
  return std::all_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
bool any_of(R &&Range, UnaryPredicate P) {
  return std::any_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
bool none_of(R &&Range, UnaryPredicate P) {
  return std::none_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename T> void fill(R &&Range, T &&Value) {
  std::fill(adl_begin(Range), adl_end(Range), std::forward<T>(Value));
}



template <typename R, typename T> auto find(R &&Range, const T &Val) {
  return std::find(adl_begin(Range), adl_end(Range), Val);
}



template <typename R, typename UnaryPredicate>
auto find_if(R &&Range, UnaryPredicate P) {
  return std::find_if(adl_begin(Range), adl_end(Range), P);
}

template <typename R, typename UnaryPredicate>
auto find_if_not(R &&Range, UnaryPredicate P) {
  return std::find_if_not(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
auto remove_if(R &&Range, UnaryPredicate P) {
  return std::remove_if(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename OutputIt, typename UnaryPredicate>
OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {
  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);
}






template <typename T, typename R, typename Predicate>
T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {
  T *RC = nullptr;
  for (auto &&A : Range) {
    if (T *PRC = P(A, AllowRepeats)) {
      if (RC) {
        if (!AllowRepeats || PRC != RC)
          return nullptr;
      } else {
        RC = PRC;
      }
    }
  }
  return RC;
}
# 1830 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T, typename R, typename Predicate>
std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,
                                           bool AllowRepeats = false) {
  T *RC = nullptr;
  for (auto *A : Range) {
    std::pair<T *, bool> PRC = P(A, AllowRepeats);
    if (PRC.second) {
      (__builtin_expect(!(PRC.first == nullptr && "Inconsistent return values in find_singleton_nested."), 0) ? __assert_rtn(__func__, "STLExtras.h", 1838, "PRC.first == nullptr && \"Inconsistent return values in find_singleton_nested.\"") : (void)0);

      return PRC;
    }
    if (PRC.first) {
      if (RC) {
        if (!AllowRepeats || PRC.first != RC)
          return {nullptr, true};
      } else {
        RC = PRC.first;
      }
    }
  }
  return {RC, false};
}

template <typename R, typename OutputIt>
OutputIt copy(R &&Range, OutputIt Out) {
  return std::copy(adl_begin(Range), adl_end(Range), Out);
}



template <typename R, typename OutputIt, typename UnaryPredicate, typename T>
OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,
                         const T &NewValue) {
  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,
                              NewValue);
}



template <typename R, typename OutputIt, typename T>
OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,
                      const T &NewValue) {
  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,
                           NewValue);
}



template <typename R, typename T>
void replace(R &&Range, const T &OldValue, const T &NewValue) {
  std::replace(adl_begin(Range), adl_end(Range), OldValue, NewValue);
}



template <typename R, typename OutputIt>
OutputIt move(R &&Range, OutputIt Out) {
  return std::move(adl_begin(Range), adl_end(Range), Out);
}

namespace detail {
template <typename Range, typename Element>
using check_has_member_contains_t =
    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));

template <typename Range, typename Element>
static constexpr bool HasMemberContains =
    is_detected<check_has_member_contains_t, Range, Element>::value;

template <typename Range, typename Element>
using check_has_member_find_t =
    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=
             std::declval<Range &>().end());

template <typename Range, typename Element>
static constexpr bool HasMemberFind =
    is_detected<check_has_member_find_t, Range, Element>::value;

}






template <typename R, typename E>
bool is_contained(R &&Range, const E &Element) {
  if constexpr (detail::HasMemberContains<R, E>)
    return Range.contains(Element);
  else if constexpr (detail::HasMemberFind<R, E>)
    return Range.find(Element) != Range.end();
  else
    return std::find(adl_begin(Range), adl_end(Range), Element) !=
           adl_end(Range);
}



template <typename T, typename E>
constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {

  for (const T &V : Set)
    if (V == Element)
      return true;
  return false;
}



template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {
  return std::is_sorted(adl_begin(Range), adl_end(Range), C);
}



template <typename R> bool is_sorted(R &&Range) {
  return std::is_sorted(adl_begin(Range), adl_end(Range));
}





template <typename R1, typename R2> bool includes(R1 &&Range1, R2 &&Range2) {
  (__builtin_expect(!(is_sorted(Range1) && "Range1 must be sorted in non-descending order"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1954, "is_sorted(Range1) && \"Range1 must be sorted in non-descending order\"") : (void)0);
  (__builtin_expect(!(is_sorted(Range2) && "Range2 must be sorted in non-descending order"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1955, "is_sorted(Range2) && \"Range2 must be sorted in non-descending order\"") : (void)0);
  return std::includes(adl_begin(Range1), adl_end(Range1), adl_begin(Range2),
                       adl_end(Range2));
}




template <typename R1, typename R2, typename Compare>
bool includes(R1 &&Range1, R2 &&Range2, Compare &&C) {
  (__builtin_expect(!(is_sorted(Range1, C) && "Range1 must be sorted with respect to C"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1965, "is_sorted(Range1, C) && \"Range1 must be sorted with respect to C\"") : (void)0);
  (__builtin_expect(!(is_sorted(Range2, C) && "Range2 must be sorted with respect to C"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1966, "is_sorted(Range2, C) && \"Range2 must be sorted with respect to C\"") : (void)0);
  return std::includes(adl_begin(Range1), adl_end(Range1), adl_begin(Range2),
                       adl_end(Range2), std::forward<Compare>(C));
}



template <typename R, typename E> auto count(R &&Range, const E &Element) {
  return std::count(adl_begin(Range), adl_end(Range), Element);
}



template <typename R, typename UnaryPredicate>
auto count_if(R &&Range, UnaryPredicate P) {
  return std::count_if(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename OutputIt, typename UnaryFunction>
OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {
  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);
}



template <typename R, typename UnaryPredicate>
auto partition(R &&Range, UnaryPredicate P) {
  return std::partition(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename T> auto binary_search(R &&Range, T &&Value) {
  return std::binary_search(adl_begin(Range), adl_end(Range),
                            std::forward<T>(Value));
}

template <typename R, typename T, typename Compare>
auto binary_search(R &&Range, T &&Value, Compare C) {
  return std::binary_search(adl_begin(Range), adl_end(Range),
                            std::forward<T>(Value), C);
}



template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {
  return std::lower_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value));
}

template <typename R, typename T, typename Compare>
auto lower_bound(R &&Range, T &&Value, Compare C) {
  return std::lower_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value), C);
}



template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {
  return std::upper_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value));
}

template <typename R, typename T, typename Compare>
auto upper_bound(R &&Range, T &&Value, Compare C) {
  return std::upper_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value), C);
}



template <typename R> auto min_element(R &&Range) {
  return std::min_element(adl_begin(Range), adl_end(Range));
}

template <typename R, typename Compare> auto min_element(R &&Range, Compare C) {
  return std::min_element(adl_begin(Range), adl_end(Range), C);
}



template <typename R> auto max_element(R &&Range) {
  return std::max_element(adl_begin(Range), adl_end(Range));
}

template <typename R, typename Compare> auto max_element(R &&Range, Compare C) {
  return std::max_element(adl_begin(Range), adl_end(Range), C);
}
# 2066 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename R1, typename R2> auto mismatch(R1 &&Range1, R2 &&Range2) {
  return std::mismatch(adl_begin(Range1), adl_end(Range1), adl_begin(Range2),
                       adl_end(Range2));
}

template <typename R, typename IterTy>
auto uninitialized_copy(R &&Src, IterTy Dst) {
  return std::uninitialized_copy(adl_begin(Src), adl_end(Src), Dst);
}

template <typename R>
void stable_sort(R &&Range) {
  std::stable_sort(adl_begin(Range), adl_end(Range));
}

template <typename R, typename Compare>
void stable_sort(R &&Range, Compare C) {
  std::stable_sort(adl_begin(Range), adl_end(Range), C);
}



template <typename R, typename Predicate,
          typename Val = decltype(*adl_begin(std::declval<R>()))>
auto partition_point(R &&Range, Predicate P) {
  return std::partition_point(adl_begin(Range), adl_end(Range), P);
}

template<typename Range, typename Predicate>
auto unique(Range &&R, Predicate P) {
  return std::unique(adl_begin(R), adl_end(R), P);
}



template <typename Range> auto unique(Range &&R) {
  return std::unique(adl_begin(R), adl_end(R));
}



template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {
  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),
                    adl_end(RRange));
}

template <typename L, typename R, typename BinaryPredicate>
bool equal(L &&LRange, R &&RRange, BinaryPredicate P) {
  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),
                    adl_end(RRange), P);
}


template <typename R> bool all_equal(R &&Range) {
  auto Begin = adl_begin(Range);
  auto End = adl_end(Range);
  return Begin == End || std::equal(std::next(Begin), End, Begin);
}



template <typename T> bool all_equal(std::initializer_list<T> Values) {
  return all_equal<std::initializer_list<T>>(std::move(Values));
}
# 2138 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename Container, typename UnaryPredicate>
void erase_if(Container &C, UnaryPredicate P) {
  C.erase(remove_if(C, P), C.end());
}




template <typename Container, typename ValueType>
void erase(Container &C, ValueType V) {
  C.erase(std::remove(C.begin(), C.end(), V), C.end());
}




template <typename Container, typename Range>
void append_range(Container &C, Range &&R) {
  C.insert(C.end(), adl_begin(R), adl_end(R));
}


template <typename Container, typename... Args>
void append_values(Container &C, Args &&...Values) {
  C.reserve(range_size(C) + sizeof...(Args));

  ((void)C.insert(C.end(), std::forward<Args>(Values)), ...);
}



template <typename Container, typename RandomAccessIterator>
void replace(Container &Cont, typename Container::iterator ContIt,
             typename Container::iterator ContEnd, RandomAccessIterator ValIt,
             RandomAccessIterator ValEnd) {
  while (true) {
    if (ValIt == ValEnd) {
      Cont.erase(ContIt, ContEnd);
      return;
    }
    if (ContIt == ContEnd) {
      Cont.insert(ContIt, ValIt, ValEnd);
      return;
    }
    *ContIt = *ValIt;
    ++ContIt;
    ++ValIt;
  }
}



template <typename Container, typename Range = std::initializer_list<
                                  typename Container::value_type>>
void replace(Container &Cont, typename Container::iterator ContIt,
             typename Container::iterator ContEnd, Range &&R) {
  replace(Cont, ContIt, ContEnd, adl_begin(R), adl_end(R));
}
# 2207 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename ForwardIterator, typename UnaryFunctor,
          typename NullaryFunctor,
          typename = std::enable_if_t<
              !std::is_constructible<StringRef, UnaryFunctor>::value &&
              !std::is_constructible<StringRef, NullaryFunctor>::value>>
inline void interleave(ForwardIterator begin, ForwardIterator end,
                       UnaryFunctor each_fn, NullaryFunctor between_fn) {
  if (begin == end)
    return;
  each_fn(*begin);
  ++begin;
  for (; begin != end; ++begin) {
    between_fn();
    each_fn(*begin);
  }
}

template <typename Container, typename UnaryFunctor, typename NullaryFunctor,
          typename = std::enable_if_t<
              !std::is_constructible<StringRef, UnaryFunctor>::value &&
              !std::is_constructible<StringRef, NullaryFunctor>::value>>
inline void interleave(const Container &c, UnaryFunctor each_fn,
                       NullaryFunctor between_fn) {
  interleave(adl_begin(c), adl_end(c), each_fn, between_fn);
}


template <typename Container, typename UnaryFunctor, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,
                       const StringRef &separator) {
  interleave(adl_begin(c), adl_end(c), each_fn, [&] { os << separator; });
}
template <typename Container, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleave(const Container &c, StreamT &os,
                       const StringRef &separator) {
  interleave(
      c, os, [&](const T &a) { os << a; }, separator);
}

template <typename Container, typename UnaryFunctor, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleaveComma(const Container &c, StreamT &os,
                            UnaryFunctor each_fn) {
  interleave(c, os, each_fn, ", ");
}
template <typename Container, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleaveComma(const Container &c, StreamT &os) {
  interleaveComma(c, os, [&](const T &a) { os << a; });
}





struct FreeDeleter {
  void operator()(void* v) {
    ::free(v);
  }
};

template<typename First, typename Second>
struct pair_hash {
  size_t operator()(const std::pair<First, Second> &P) const {
    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);
  }
};



template <typename T> struct deref {
  T func;




  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {
    (__builtin_expect(!(lhs), 0) ? __assert_rtn(__func__, "STLExtras.h", 2286, "lhs") : (void)0);
    (__builtin_expect(!(rhs), 0) ? __assert_rtn(__func__, "STLExtras.h", 2287, "rhs") : (void)0);
    return func(*lhs, *rhs);
  }
};

namespace detail {


template <typename... Refs> struct enumerator_result;

template <typename... Iters>
using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;
# 2311 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... Iters>
struct zip_enumerator : zip_common<zip_enumerator<Iters...>,
                                   EnumeratorTupleType<Iters...>, Iters...> {
  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");
  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,
                   Iters...>::zip_common;

  bool operator==(const zip_enumerator &Other) const {
    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);
  }
};

template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {
  static constexpr std::size_t NumRefs = sizeof...(Refs);
  static_assert(NumRefs != 0);

  static constexpr std::size_t NumValues = NumRefs + 1;


  using range_reference_tuple = std::tuple<Refs...>;


  using value_reference_tuple = std::tuple<std::size_t, Refs...>;

  enumerator_result(std::size_t Index, Refs &&...Rs)
      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}



  std::size_t index() const { return Idx; }



  decltype(auto) value() const {
    if constexpr (NumRefs == 1)
      return std::get<0>(Storage);
    else
      return Storage;
  }


  template <std::size_t I, typename = std::enable_if_t<I == 0>>
  friend std::size_t get(const enumerator_result &Result) {
    return Result.Idx;
  }



  template <std::size_t I, typename = std::enable_if_t<I != 0>>
  friend decltype(auto) get(const enumerator_result &Result) {



    return std::get<I - 1>(Result.Storage);
  }

  template <typename... Ts>
  friend bool operator==(const enumerator_result &Result,
                         const std::tuple<std::size_t, Ts...> &Other) {
    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");
    if (Result.Idx != std::get<0>(Other))
      return false;
    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});
  }

private:
  template <typename Tuple, std::size_t... Idx>
  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {
    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);
  }

  std::size_t Idx;







  mutable range_reference_tuple Storage;
};

struct index_iterator
    : llvm::iterator_facade_base<index_iterator,
                                 std::random_access_iterator_tag, std::size_t> {
  index_iterator(std::size_t Index) : Index(Index) {}

  index_iterator &operator+=(std::ptrdiff_t N) {
    Index += N;
    return *this;
  }

  index_iterator &operator-=(std::ptrdiff_t N) {
    Index -= N;
    return *this;
  }

  std::ptrdiff_t operator-(const index_iterator &R) const {
    return Index - R.Index;
  }






  std::size_t operator*() const { return Index; }

  friend bool operator==(const index_iterator &Lhs, const index_iterator &Rhs) {
    return Lhs.Index == Rhs.Index;
  }

  friend bool operator<(const index_iterator &Lhs, const index_iterator &Rhs) {
    return Lhs.Index < Rhs.Index;
  }

private:
  std::size_t Index;
};


struct index_stream {
  index_iterator begin() const { return {0}; }
  index_iterator end() const {


    return index_iterator{std::numeric_limits<std::size_t>::max()};
  }
};

}


class index_range {
  std::size_t Begin;
  std::size_t End;

public:
  index_range(std::size_t Begin, std::size_t End) : Begin(Begin), End(End) {}
  detail::index_iterator begin() const { return {Begin}; }
  detail::index_iterator end() const { return {End}; }
};
# 2490 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename FirstRange, typename... RestRanges>
auto enumerate(FirstRange &&First, RestRanges &&...Rest) {
  if constexpr (sizeof...(Rest) != 0) {



    size_t sizes[] = {range_size(First), range_size(Rest)...};
    (__builtin_expect(!(all_equal(sizes) && "Ranges have different length"), 0) ? __assert_rtn(__func__, "STLExtras.h", 2497, "all_equal(sizes) && \"Ranges have different length\"") : (void)0);

  }
  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,
                                   FirstRange, RestRanges...>;
  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),
                    std::forward<RestRanges>(Rest)...);
}

namespace detail {

template <typename Predicate, typename... Args>
bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {
  auto z = zip(args...);
  auto it = z.begin();
  auto end = z.end();
  while (it != end) {
    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))
      return false;
    ++it;
  }
  return it.all_equals(end);
}



template <typename... ArgsThenPredicate, size_t... InputIndexes>
bool all_of_zip_predicate_last(
    std::tuple<ArgsThenPredicate...> argsThenPredicate,
    std::index_sequence<InputIndexes...>) {
  auto constexpr OutputIndex =
      std::tuple_size<decltype(argsThenPredicate)>::value - 1;
  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),
                             std::get<InputIndexes>(argsThenPredicate)...);
}

}




template <typename... ArgsAndPredicate>
bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {
  return detail::all_of_zip_predicate_last(
      std::forward_as_tuple(argsAndPredicate...),
      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});
}




template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItems(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted =
        [](const decltype(*std::declval<IterTy>()) &) { return true; },
    std::enable_if_t<
        !std::is_base_of<std::random_access_iterator_tag,
                         typename std::iterator_traits<std::remove_reference_t<
                             decltype(Begin)>>::iterator_category>::value,
        void> * = nullptr) {
  for (; N; ++Begin) {
    if (Begin == End)
      return false;
    N -= ShouldBeCounted(*Begin);
  }
  for (; Begin != End; ++Begin)
    if (ShouldBeCounted(*Begin))
      return false;
  return true;
}




template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItemsOrMore(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted =
        [](const decltype(*std::declval<IterTy>()) &) { return true; },
    std::enable_if_t<
        !std::is_base_of<std::random_access_iterator_tag,
                         typename std::iterator_traits<std::remove_reference_t<
                             decltype(Begin)>>::iterator_category>::value,
        void> * = nullptr) {
  for (; N; ++Begin) {
    if (Begin == End)
      return false;
    N -= ShouldBeCounted(*Begin);
  }
  return true;
}



template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItemsOrLess(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {
      return true;
    }) {
  (__builtin_expect(!(N != std::numeric_limits<unsigned>::max()), 0) ? __assert_rtn(__func__, "STLExtras.h", 2601, "N != std::numeric_limits<unsigned>::max()") : (void)0);
  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);
}


template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {
  return hasNItems(adl_begin(C), adl_end(C), N);
}


template <typename ContainerTy>
bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {
  return hasNItemsOrMore(adl_begin(C), adl_end(C), N);
}


template <typename ContainerTy>
bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {
  return hasNItemsOrLess(adl_begin(C), adl_end(C), N);
}
# 2629 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }
template <class T> constexpr T *to_address(T *P) { return P; }


namespace detail {
template <typename T> using has_sizeof = decltype(sizeof(T));
}



template <typename T>
constexpr bool is_incomplete_v = !is_detected<detail::has_sizeof, T>::value;

}

namespace std {
template <typename... Refs>
struct tuple_size<llvm::detail::enumerator_result<Refs...>>
    : std::integral_constant<std::size_t, sizeof...(Refs)> {};

template <std::size_t I, typename... Refs>
struct tuple_element<I, llvm::detail::enumerator_result<Refs...>>
    : std::tuple_element<I, std::tuple<Refs...>> {};

template <std::size_t I, typename... Refs>
struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>>
    : std::tuple_element<I, std::tuple<Refs...>> {};

}
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2







namespace llvm {
  template<typename T> class [[nodiscard]] MutableArrayRef;
# 40 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class [[gsl::Pointer]] [[nodiscard]] ArrayRef {
  public:
    using value_type = T;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using iterator = const_pointer;
    using const_iterator = const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;

  private:

    const T *Data = nullptr;


    size_type Length = 0;

  public:




                 ArrayRef() = default;


                 __attribute__((deprecated("Use {} or ArrayRef<T>() instead", "{}")))
    ArrayRef(std::nullopt_t) {}


                 ArrayRef(const T &OneElt [[clang::lifetimebound]])
        : Data(&OneElt), Length(1) {}


    constexpr ArrayRef(const T *data [[clang::lifetimebound]],
                                    size_t length)
        : Data(data), Length(length) {}


    constexpr ArrayRef(const T *begin [[clang::lifetimebound]], const T *end)
        : Data(begin), Length(end - begin) {
      (__builtin_expect(!(begin <= end), 0) ? __assert_rtn(__func__, "ArrayRef.h", 85, "begin <= end") : (void)0);
    }



    template <
        typename C,
        typename = std::enable_if_t<
            std::conjunction_v<
                std::is_convertible<
                    decltype(std::declval<const C &>().data()) *,
                    const T *const *>,
                std::is_integral<decltype(std::declval<const C &>().size())>>,
            void>>
                 constexpr ArrayRef(const C &V)
        : Data(V.data()), Length(V.size()) {}


    template <size_t N>
                 constexpr ArrayRef(const T (&Arr [[clang::lifetimebound]])[N])
        : Data(Arr), Length(N) {}
# 115 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
    constexpr ArrayRef(
        std::initializer_list<T> Vec [[clang::lifetimebound]])
        : Data(Vec.begin() == Vec.end() ? (T *)nullptr : Vec.begin()),
          Length(Vec.size()) {}







    template <typename U, typename = std::enable_if_t<
                              std::is_convertible_v<U *const *, T *const *>>>
    ArrayRef(const iterator_range<U *> &Range)
        : Data(Range.begin()), Length(llvm::size(Range)) {}





    iterator begin() const { return Data; }
    iterator end() const { return Data + Length; }

    reverse_iterator rbegin() const { return reverse_iterator(end()); }
    reverse_iterator rend() const { return reverse_iterator(begin()); }


    bool empty() const { return Length == 0; }

    const T *data() const { return Data; }


    size_t size() const { return Length; }


    const T &front() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 151, "!empty()") : (void)0);
      return Data[0];
    }


    const T &back() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 157, "!empty()") : (void)0);
      return Data[Length-1];
    }


    const T &consume_front() {
      const T &Ret = front();
      *this = drop_front();
      return Ret;
    }


    const T &consume_back() {
      const T &Ret = back();
      *this = drop_back();
      return Ret;
    }


    template <typename Allocator> MutableArrayRef<T> copy(Allocator &A) {
      T *Buff = A.template Allocate<T>(Length);
      llvm::uninitialized_copy(*this, Buff);
      return MutableArrayRef<T>(Buff, Length);
    }


    bool equals(ArrayRef RHS) const {
      if (Length != RHS.Length)
        return false;
      return std::equal(begin(), end(), RHS.begin());
    }



    ArrayRef<T> slice(size_t N, size_t M) const {
      (__builtin_expect(!(N+M <= size() && "Invalid specifier"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 192, "N+M <= size() && \"Invalid specifier\"") : (void)0);
      return ArrayRef<T>(data()+N, M);
    }


    ArrayRef<T> slice(size_t N) const { return drop_front(N); }


    ArrayRef<T> drop_front(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 201, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(N, size() - N);
    }


    ArrayRef<T> drop_back(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 207, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(0, size() - N);
    }



    template <class PredicateT> ArrayRef<T> drop_while(PredicateT Pred) const {
      return ArrayRef<T>(find_if_not(*this, Pred), end());
    }



    template <class PredicateT> ArrayRef<T> drop_until(PredicateT Pred) const {
      return ArrayRef<T>(find_if(*this, Pred), end());
    }


    ArrayRef<T> take_front(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_back(size() - N);
    }


    ArrayRef<T> take_back(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_front(size() - N);
    }



    template <class PredicateT> ArrayRef<T> take_while(PredicateT Pred) const {
      return ArrayRef<T>(begin(), find_if_not(*this, Pred));
    }



    template <class PredicateT> ArrayRef<T> take_until(PredicateT Pred) const {
      return ArrayRef<T>(begin(), find_if(*this, Pred));
    }




    const T &operator[](size_t Index) const {
      (__builtin_expect(!(Index < Length && "Invalid index!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 253, "Index < Length && \"Invalid index!\"") : (void)0);
      return Data[Index];
    }





    template <typename U>
    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
    operator=(U &&Temporary) = delete;





    template <typename U>
    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
    operator=(std::initializer_list<U>) = delete;




    std::vector<T> vec() const {
      return std::vector<T>(Data, Data+Length);
    }




    operator std::vector<T>() const {
      return std::vector<T>(Data, Data+Length);
    }


  };
# 302 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class [[nodiscard]] MutableArrayRef : public ArrayRef<T> {
  public:
    using value_type = T;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using iterator = pointer;
    using const_iterator = const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;


                 MutableArrayRef() = default;


                 MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}


                 MutableArrayRef(T *data, size_t length)
      : ArrayRef<T>(data, length) {}


    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}



    template <typename C,
              typename = std::enable_if_t<
                  std::conjunction_v<
                      std::is_convertible<
                          decltype(std::declval<C &>().data()) *, T *const *>,
                      std::is_integral<decltype(std::declval<C &>().size())>>,
                  void>>
                 constexpr MutableArrayRef(const C &V) : ArrayRef<T>(V) {}


    template <size_t N>
                 constexpr MutableArrayRef(T (&Arr)[N]) : ArrayRef<T>(Arr) {}

    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }

    iterator begin() const { return data(); }
    iterator end() const { return data() + this->size(); }

    reverse_iterator rbegin() const { return reverse_iterator(end()); }
    reverse_iterator rend() const { return reverse_iterator(begin()); }


    T &front() const {
      (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 355, "!this->empty()") : (void)0);
      return data()[0];
    }


    T &back() const {
      (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 361, "!this->empty()") : (void)0);
      return data()[this->size()-1];
    }


    T &consume_front() {
      T &Ret = front();
      *this = drop_front();
      return Ret;
    }


    T &consume_back() {
      T &Ret = back();
      *this = drop_back();
      return Ret;
    }



    MutableArrayRef<T> slice(size_t N, size_t M) const {
      (__builtin_expect(!(N + M <= this->size() && "Invalid specifier"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 382, "N + M <= this->size() && \"Invalid specifier\"") : (void)0);
      return MutableArrayRef<T>(this->data() + N, M);
    }


    MutableArrayRef<T> slice(size_t N) const {
      return slice(N, this->size() - N);
    }


    MutableArrayRef<T> drop_front(size_t N = 1) const {
      (__builtin_expect(!(this->size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 393, "this->size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(N, this->size() - N);
    }

    MutableArrayRef<T> drop_back(size_t N = 1) const {
      (__builtin_expect(!(this->size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 398, "this->size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(0, this->size() - N);
    }



    template <class PredicateT>
    MutableArrayRef<T> drop_while(PredicateT Pred) const {
      return MutableArrayRef<T>(find_if_not(*this, Pred), end());
    }



    template <class PredicateT>
    MutableArrayRef<T> drop_until(PredicateT Pred) const {
      return MutableArrayRef<T>(find_if(*this, Pred), end());
    }


    MutableArrayRef<T> take_front(size_t N = 1) const {
      if (N >= this->size())
        return *this;
      return drop_back(this->size() - N);
    }


    MutableArrayRef<T> take_back(size_t N = 1) const {
      if (N >= this->size())
        return *this;
      return drop_front(this->size() - N);
    }



    template <class PredicateT>
    MutableArrayRef<T> take_while(PredicateT Pred) const {
      return MutableArrayRef<T>(begin(), find_if_not(*this, Pred));
    }



    template <class PredicateT>
    MutableArrayRef<T> take_until(PredicateT Pred) const {
      return MutableArrayRef<T>(begin(), find_if(*this, Pred));
    }




    T &operator[](size_t Index) const {
      (__builtin_expect(!(Index < this->size() && "Invalid index!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 448, "Index < this->size() && \"Invalid index!\"") : (void)0);
      return data()[Index];
    }
  };


  template <typename T> class OwningArrayRef : public MutableArrayRef<T> {
  public:
    OwningArrayRef() = default;
    OwningArrayRef(size_t Size) : MutableArrayRef<T>(new T[Size], Size) {}

    OwningArrayRef(ArrayRef<T> Data)
        : MutableArrayRef<T>(new T[Data.size()], Data.size()) {
      std::copy(Data.begin(), Data.end(), this->begin());
    }

    OwningArrayRef(OwningArrayRef &&Other) { *this = std::move(Other); }

    OwningArrayRef &operator=(OwningArrayRef &&Other) {
      delete[] this->data();
      this->MutableArrayRef<T>::operator=(Other);
      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());
      return *this;
    }

    ~OwningArrayRef() { delete[] this->data(); }
  };




  template <typename T> ArrayRef(const T &OneElt) -> ArrayRef<T>;


  template <typename T> ArrayRef(const T *data, size_t length) -> ArrayRef<T>;


  template <typename T> ArrayRef(const T *data, const T *end) -> ArrayRef<T>;


  template <typename T> ArrayRef(const SmallVectorImpl<T> &Vec) -> ArrayRef<T>;


  template <typename T, unsigned N>
  ArrayRef(const SmallVector<T, N> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(const std::vector<T> &Vec) -> ArrayRef<T>;


  template <typename T, std::size_t N>
  ArrayRef(const std::array<T, N> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(const ArrayRef<T> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(ArrayRef<T> &Vec) -> ArrayRef<T>;


  template <typename T, size_t N> ArrayRef(const T (&Arr)[N]) -> ArrayRef<T>;






  template <class T> MutableArrayRef(T &OneElt) -> MutableArrayRef<T>;



  template <class T>
  MutableArrayRef(T *data, size_t length) -> MutableArrayRef<T>;


  template <class T>
  MutableArrayRef(SmallVectorImpl<T> &Vec) -> MutableArrayRef<T>;

  template <class T, unsigned N>
  MutableArrayRef(SmallVector<T, N> &Vec) -> MutableArrayRef<T>;


  template <class T> MutableArrayRef(std::vector<T> &Vec) -> MutableArrayRef<T>;


  template <class T, std::size_t N>
  MutableArrayRef(std::array<T, N> &Vec) -> MutableArrayRef<T>;


  template <typename T, size_t N>
  MutableArrayRef(T (&Arr)[N]) -> MutableArrayRef<T>;





  template<typename T>
  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return LHS.equals(RHS);
  }

  template <typename T>
  inline bool operator==(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
    return ArrayRef<T>(LHS).equals(RHS);
  }

  template <typename T>
  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return !(LHS == RHS);
  }

  template <typename T>
  inline bool operator!=(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
    return !(LHS == RHS);
  }

  template <typename T>
  inline bool operator<(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return std::lexicographical_compare(LHS.begin(), LHS.end(), RHS.begin(),
                                        RHS.end());
  }

  template <typename T>
  inline bool operator>(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return RHS < LHS;
  }

  template <typename T>
  inline bool operator<=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return !(LHS > RHS);
  }

  template <typename T>
  inline bool operator>=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return !(LHS < RHS);
  }



  template <typename T> hash_code hash_value(ArrayRef<T> S) {
    return hash_combine_range(S);
  }


  template <typename T> struct DenseMapInfo<ArrayRef<T>, void> {
    static inline ArrayRef<T> getEmptyKey() {
      return ArrayRef<T>(
          reinterpret_cast<const T *>(~static_cast<uintptr_t>(0)), size_t(0));
    }

    static inline ArrayRef<T> getTombstoneKey() {
      return ArrayRef<T>(
          reinterpret_cast<const T *>(~static_cast<uintptr_t>(1)), size_t(0));
    }

    static unsigned getHashValue(ArrayRef<T> Val) {
      (__builtin_expect(!(Val.data() != getEmptyKey().data() && "Cannot hash the empty key!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 605, "Val.data() != getEmptyKey().data() && \"Cannot hash the empty key!\"") : (void)0);

      (__builtin_expect(!(Val.data() != getTombstoneKey().data() && "Cannot hash the tombstone key!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 607, "Val.data() != getTombstoneKey().data() && \"Cannot hash the tombstone key!\"") : (void)0);

      return (unsigned)(hash_value(Val));
    }

    static bool isEqual(ArrayRef<T> LHS, ArrayRef<T> RHS) {
      if (RHS.data() == getEmptyKey().data())
        return LHS.data() == getEmptyKey().data();
      if (RHS.data() == getTombstoneKey().data())
        return LHS.data() == getTombstoneKey().data();
      return LHS == RHS;
    }
  };

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 2
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
namespace llvm {

  class APInt;
  class hash_code;
  template <typename T> class SmallVectorImpl;
  class StringRef;


  __attribute__((visibility("default"))) bool getAsUnsignedInteger(StringRef Str, unsigned Radix,
                                     unsigned long long &Result);

  __attribute__((visibility("default"))) bool getAsSignedInteger(StringRef Str, unsigned Radix,
                                   long long &Result);

  __attribute__((visibility("default"))) unsigned getAutoSenseRadix(StringRef &Str);

  __attribute__((visibility("default"))) bool consumeUnsignedInteger(StringRef &Str, unsigned Radix,
                                       unsigned long long &Result);
  __attribute__((visibility("default"))) bool consumeSignedInteger(StringRef &Str, unsigned Radix,
                                     long long &Result);
# 55 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
  class [[gsl::Pointer]] StringRef {
  public:
    static constexpr size_t npos = ~size_t(0);

    using iterator = const char *;
    using const_iterator = const char *;
    using size_type = size_t;
    using value_type = char;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  private:

    const char *Data = nullptr;


    size_t Length = 0;



    static int compareMemory(const char *Lhs, const char *Rhs, size_t Length) {
      if (Length == 0) { return 0; }
      return ::memcmp(Lhs,Rhs,Length);
    }

  public:




                 StringRef() = default;



    StringRef(std::nullptr_t) = delete;


                 constexpr StringRef(const char *Str [[clang::lifetimebound]])
        : Data(Str), Length(Str ?




                                std::char_traits<char>::length(Str)

                                : 0) {
    }


                 constexpr StringRef(const char *data [[clang::lifetimebound]],
                                     size_t length)
        : Data(data), Length(length) {}


                 StringRef(const std::string &Str)
        : Data(Str.data()), Length(Str.length()) {}


                 constexpr StringRef(std::string_view Str)
        : Data(Str.data()), Length(Str.size()) {}





    iterator begin() const { return data(); }

    iterator end() const { return data() + size(); }

    reverse_iterator rbegin() const {
      return std::make_reverse_iterator(end());
    }

    reverse_iterator rend() const {
      return std::make_reverse_iterator(begin());
    }

    const unsigned char *bytes_begin() const {
      return reinterpret_cast<const unsigned char *>(begin());
    }
    const unsigned char *bytes_end() const {
      return reinterpret_cast<const unsigned char *>(end());
    }
    iterator_range<const unsigned char *> bytes() const {
      return make_range(bytes_begin(), bytes_end());
    }







    [[nodiscard]] constexpr const char *data() const { return Data; }


    [[nodiscard]] constexpr bool empty() const { return size() == 0; }


    [[nodiscard]] constexpr size_t size() const { return Length; }


    [[nodiscard]] char front() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "StringRef.h", 158, "!empty()") : (void)0);
      return data()[0];
    }


    [[nodiscard]] char back() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "StringRef.h", 164, "!empty()") : (void)0);
      return data()[size() - 1];
    }


    template <typename Allocator>
    [[nodiscard]] StringRef copy(Allocator &A) const {

      if (empty())
        return StringRef();
      char *S = A.template Allocate<char>(size());
      std::copy(begin(), end(), S);
      return StringRef(S, size());
    }


    [[nodiscard]] bool equals_insensitive(StringRef RHS) const {
      return size() == RHS.size() && compare_insensitive(RHS) == 0;
    }




    [[nodiscard]] int compare(StringRef RHS) const {

      if (int Res =
              compareMemory(data(), RHS.data(), std::min(size(), RHS.size())))
        return Res < 0 ? -1 : 1;


      if (size() == RHS.size())
        return 0;
      return size() < RHS.size() ? -1 : 1;
    }


    [[nodiscard]] __attribute__((visibility("default"))) int compare_insensitive(StringRef RHS) const;



    [[nodiscard]] __attribute__((visibility("default"))) int compare_numeric(StringRef RHS) const;
# 224 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] __attribute__((visibility("default"))) unsigned
    edit_distance(StringRef Other, bool AllowReplacements = true,
                  unsigned MaxEditDistance = 0) const;

    [[nodiscard]] __attribute__((visibility("default"))) unsigned
    edit_distance_insensitive(StringRef Other, bool AllowReplacements = true,
                              unsigned MaxEditDistance = 0) const;


    [[nodiscard]] std::string str() const {
      if (!data())
        return std::string();
      return std::string(data(), size());
    }





    [[nodiscard]] char operator[](size_t Index) const {
      (__builtin_expect(!(Index < size() && "Invalid index!"), 0) ? __assert_rtn(__func__, "StringRef.h", 244, "Index < size() && \"Invalid index!\"") : (void)0);
      return data()[Index];
    }





    template <typename T>
    std::enable_if_t<std::is_same<T, std::string>::value, StringRef> &
    operator=(T &&Str) = delete;





    constexpr operator std::string_view() const {
      return std::string_view(data(), size());
    }






    [[nodiscard]] bool starts_with(StringRef Prefix) const {
      return size() >= Prefix.size() &&
             compareMemory(data(), Prefix.data(), Prefix.size()) == 0;
    }
    [[nodiscard]] bool starts_with(char Prefix) const {
      return !empty() && front() == Prefix;
    }


    [[nodiscard]] __attribute__((visibility("default"))) bool starts_with_insensitive(StringRef Prefix) const;


    [[nodiscard]] bool ends_with(StringRef Suffix) const {
      return size() >= Suffix.size() &&
             compareMemory(end() - Suffix.size(), Suffix.data(),
                           Suffix.size()) == 0;
    }
    [[nodiscard]] bool ends_with(char Suffix) const {
      return !empty() && back() == Suffix;
    }


    [[nodiscard]] __attribute__((visibility("default"))) bool ends_with_insensitive(StringRef Suffix) const;
# 301 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] size_t find(char C, size_t From = 0) const {
      return std::string_view(*this).find(C, From);
    }





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_insensitive(char C,
                                                   size_t From = 0) const;





    [[nodiscard]] size_t find_if(function_ref<bool(char)> F,
                                 size_t From = 0) const {
      StringRef S = drop_front(From);
      while (!S.empty()) {
        if (F(S.front()))
          return size() - S.size();
        S = S.drop_front();
      }
      return npos;
    }





    [[nodiscard]] size_t find_if_not(function_ref<bool(char)> F,
                                     size_t From = 0) const {
      return find_if([F](char c) { return !F(c); }, From);
    }





    [[nodiscard]] __attribute__((visibility("default"))) size_t find(StringRef Str, size_t From = 0) const;





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_insensitive(StringRef Str,
                                                   size_t From = 0) const;





    [[nodiscard]] size_t rfind(char C, size_t From = npos) const {
      size_t I = std::min(From, size());
      while (I) {
        --I;
        if (data()[I] == C)
          return I;
      }
      return npos;
    }





    [[nodiscard]] __attribute__((visibility("default"))) size_t rfind_insensitive(char C,
                                                    size_t From = npos) const;





    [[nodiscard]] __attribute__((visibility("default"))) size_t rfind(StringRef Str) const;





    [[nodiscard]] __attribute__((visibility("default"))) size_t rfind_insensitive(StringRef Str) const;



    [[nodiscard]] size_t find_first_of(char C, size_t From = 0) const {
      return find(C, From);
    }





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_first_of(StringRef Chars,
                                                size_t From = 0) const;



    [[nodiscard]] __attribute__((visibility("default"))) size_t find_first_not_of(char C,
                                                    size_t From = 0) const;





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_first_not_of(StringRef Chars,
                                                    size_t From = 0) const;



    [[nodiscard]] size_t find_last_of(char C, size_t From = npos) const {
      return rfind(C, From);
    }





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_last_of(StringRef Chars,
                                               size_t From = npos) const;



    [[nodiscard]] __attribute__((visibility("default"))) size_t find_last_not_of(char C,
                                                   size_t From = npos) const;





    [[nodiscard]] __attribute__((visibility("default"))) size_t find_last_not_of(StringRef Chars,
                                                   size_t From = npos) const;



    [[nodiscard]] bool contains(StringRef Other) const {
      return find(Other) != npos;
    }



    [[nodiscard]] bool contains(char C) const {
      return find_first_of(C) != npos;
    }



    [[nodiscard]] bool contains_insensitive(StringRef Other) const {
      return find_insensitive(Other) != npos;
    }



    [[nodiscard]] bool contains_insensitive(char C) const {
      return find_insensitive(C) != npos;
    }






    [[nodiscard]] size_t count(char C) const {
      size_t Count = 0;
      for (size_t I = 0; I != size(); ++I)
        if (data()[I] == C)
          ++Count;
      return Count;
    }



    __attribute__((visibility("default"))) size_t count(StringRef Str) const;
# 480 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    template <typename T> bool getAsInteger(unsigned Radix, T &Result) const {
      if constexpr (std::numeric_limits<T>::is_signed) {
        long long LLVal;
        if (getAsSignedInteger(*this, Radix, LLVal) ||
            static_cast<T>(LLVal) != LLVal)
          return true;
        Result = LLVal;
      } else {
        unsigned long long ULLVal;



        if (getAsUnsignedInteger(*this, Radix, ULLVal) ||
            static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)
          return true;
        Result = ULLVal;
      }
      return false;
    }
# 509 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    template <typename T> bool consumeInteger(unsigned Radix, T &Result) {
      if constexpr (std::numeric_limits<T>::is_signed) {
        long long LLVal;
        if (consumeSignedInteger(*this, Radix, LLVal) ||
            static_cast<long long>(static_cast<T>(LLVal)) != LLVal)
          return true;
        Result = LLVal;
      } else {
        unsigned long long ULLVal;
        if (consumeUnsignedInteger(*this, Radix, ULLVal) ||
            static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)
          return true;
        Result = ULLVal;
      }
      return false;
    }
# 536 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    __attribute__((visibility("default"))) bool getAsInteger(unsigned Radix, APInt &Result) const;
# 547 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    __attribute__((visibility("default"))) bool consumeInteger(unsigned Radix, APInt &Result);
# 556 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    __attribute__((visibility("default"))) bool getAsDouble(double &Result, bool AllowInexact = true) const;






    [[nodiscard]] __attribute__((visibility("default"))) std::string lower() const;


    [[nodiscard]] __attribute__((visibility("default"))) std::string upper() const;
# 581 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] constexpr StringRef substr(size_t Start,
                                             size_t N = npos) const {
      Start = std::min(Start, size());
      return StringRef(data() + Start, std::min(N, size() - Start));
    }




    [[nodiscard]] StringRef take_front(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_back(size() - N);
    }




    [[nodiscard]] StringRef take_back(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_front(size() - N);
    }



    [[nodiscard]] StringRef take_while(function_ref<bool(char)> F) const {
      return substr(0, find_if_not(F));
    }



    [[nodiscard]] StringRef take_until(function_ref<bool(char)> F) const {
      return substr(0, find_if(F));
    }



    [[nodiscard]] StringRef drop_front(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "StringRef.h", 620, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return substr(N);
    }



    [[nodiscard]] StringRef drop_back(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "StringRef.h", 627, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return substr(0, size()-N);
    }



    [[nodiscard]] StringRef drop_while(function_ref<bool(char)> F) const {
      return substr(find_if_not(F));
    }



    [[nodiscard]] StringRef drop_until(function_ref<bool(char)> F) const {
      return substr(find_if(F));
    }



    bool consume_front(StringRef Prefix) {
      if (!starts_with(Prefix))
        return false;

      *this = substr(Prefix.size());
      return true;
    }



    bool consume_front_insensitive(StringRef Prefix) {
      if (!starts_with_insensitive(Prefix))
        return false;

      *this = substr(Prefix.size());
      return true;
    }



    bool consume_back(StringRef Suffix) {
      if (!ends_with(Suffix))
        return false;

      *this = substr(0, size() - Suffix.size());
      return true;
    }



    bool consume_back_insensitive(StringRef Suffix) {
      if (!ends_with_insensitive(Suffix))
        return false;

      *this = substr(0, size() - Suffix.size());
      return true;
    }
# 694 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] StringRef slice(size_t Start, size_t End) const {
      Start = std::min(Start, size());
      End = std::clamp(End, Start, size());
      return StringRef(data() + Start, End - Start);
    }
# 710 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef> split(char Separator) const {
      return split(StringRef(&Separator, 1));
    }
# 724 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef>
    split(StringRef Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), substr(Idx + Separator.size()));
    }
# 742 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef>
    rsplit(StringRef Separator) const {
      size_t Idx = rfind(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), substr(Idx + Separator.size()));
    }
# 764 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    __attribute__((visibility("default"))) void split(SmallVectorImpl<StringRef> &A, StringRef Separator,
                        int MaxSplit = -1, bool KeepEmpty = true) const;
# 781 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    __attribute__((visibility("default"))) void split(SmallVectorImpl<StringRef> &A, char Separator,
                        int MaxSplit = -1, bool KeepEmpty = true) const;
# 794 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef> rsplit(char Separator) const {
      return rsplit(StringRef(&Separator, 1));
    }



    [[nodiscard]] StringRef ltrim(char Char) const {
      return drop_front(std::min(size(), find_first_not_of(Char)));
    }



    [[nodiscard]] StringRef ltrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_front(std::min(size(), find_first_not_of(Chars)));
    }



    [[nodiscard]] StringRef rtrim(char Char) const {
      return drop_back(size() - std::min(size(), find_last_not_of(Char) + 1));
    }



    [[nodiscard]] StringRef rtrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_back(size() - std::min(size(), find_last_not_of(Chars) + 1));
    }



    [[nodiscard]] StringRef trim(char Char) const {
      return ltrim(Char).rtrim(Char);
    }



    [[nodiscard]] StringRef trim(StringRef Chars = " \t\n\v\f\r") const {
      return ltrim(Chars).rtrim(Chars);
    }







    [[nodiscard]] StringRef detectEOL() const {
      size_t Pos = find('\r');
      if (Pos == npos) {

        return "\n";
      }
      if (Pos + 1 < size() && data()[Pos + 1] == '\n')
        return "\r\n";
      if (Pos > 0 && data()[Pos - 1] == '\n')
        return "\n\r";
      return "\r";
    }

  };
# 862 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
  class StringLiteral : public StringRef {
  private:
    constexpr StringLiteral(const char *Str, size_t N) : StringRef(Str, N) {
    }

  public:
    template <size_t N>
    constexpr StringLiteral(const char (&Str)[N])

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"
        __attribute((enable_if(__builtin_strlen(Str) == N - 1,
                               "invalid string literal")))
#pragma clang diagnostic pop

        : StringRef(Str, N - 1) {
    }


    template <size_t N>
    static constexpr StringLiteral withInnerNUL(const char (&Str)[N]) {
      return StringLiteral(Str, N - 1);
    }
  };




  inline bool operator==(StringRef LHS, StringRef RHS) {
    if (LHS.size() != RHS.size())
      return false;
    if (LHS.empty())
      return true;
    return ::memcmp(LHS.data(), RHS.data(), LHS.size()) == 0;
  }

  inline bool operator!=(StringRef LHS, StringRef RHS) { return !(LHS == RHS); }

  inline bool operator<(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) < 0;
  }

  inline bool operator<=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) <= 0;
  }

  inline bool operator>(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) > 0;
  }

  inline bool operator>=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) >= 0;
  }

  inline std::string &operator+=(std::string &buffer, StringRef string) {
    return buffer.append(string.data(), string.size());
  }




  [[nodiscard]] __attribute__((visibility("default"))) hash_code hash_value(StringRef S);


  template <> struct DenseMapInfo<StringRef, void> {
    static inline StringRef getEmptyKey() {
      return StringRef(
          reinterpret_cast<const char *>(~static_cast<uintptr_t>(0)), 0);
    }

    static inline StringRef getTombstoneKey() {
      return StringRef(
          reinterpret_cast<const char *>(~static_cast<uintptr_t>(1)), 0);
    }

    __attribute__((visibility("default"))) static unsigned getHashValue(StringRef Val);

    static bool isEqual(StringRef LHS, StringRef RHS) {
      if (RHS.data() == getEmptyKey().data())
        return LHS.data() == getEmptyKey().data();
      if (RHS.data() == getTombstoneKey().data())
        return LHS.data() == getTombstoneKey().data();
      return LHS == RHS;
    }
  };

}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h" 2




namespace llvm {

  class formatv_object_base;
  class raw_ostream;
# 82 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h"
  class Twine {

    enum NodeKind : unsigned char {


      NullKind,


      EmptyKind,


      TwineKind,


      CStringKind,


      StdStringKind,




      PtrAndLengthKind,



      StringLiteralKind,


      FormatvObjectKind,


      CharKind,


      DecUIKind,


      DecIKind,



      DecULKind,


      DecLKind,



      DecULLKind,


      DecLLKind,



      UHexKind
    };

    union Child
    {
      const Twine *twine;
      const char *cString;
      const std::string *stdString;
      struct {
        const char *ptr;
        size_t length;
      } ptrAndLength;
      const formatv_object_base *formatvObject;
      char character;
      unsigned int decUI;
      int decI;
      const unsigned long *decUL;
      const long *decL;
      const unsigned long long *decULL;
      const long long *decLL;
      const uint64_t *uHex;
    };



    Child LHS;



    Child RHS;


    NodeKind LHSKind = EmptyKind;


    NodeKind RHSKind = EmptyKind;


    explicit Twine(NodeKind Kind) : LHSKind(Kind) {
      (__builtin_expect(!(isNullary() && "Invalid kind!"), 0) ? __assert_rtn(__func__, "Twine.h", 177, "isNullary() && \"Invalid kind!\"") : (void)0);
    }


    explicit Twine(const Twine &LHS, const Twine &RHS)
        : LHSKind(TwineKind), RHSKind(TwineKind) {
      this->LHS.twine = &LHS;
      this->RHS.twine = &RHS;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 185, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    explicit Twine(Child LHS, NodeKind LHSKind, Child RHS, NodeKind RHSKind)
        : LHS(LHS), RHS(RHS), LHSKind(LHSKind), RHSKind(RHSKind) {
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 191, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    bool isNull() const {
      return getLHSKind() == NullKind;
    }


    bool isEmpty() const {
      return getLHSKind() == EmptyKind;
    }


    bool isNullary() const {
      return isNull() || isEmpty();
    }


    bool isUnary() const {
      return getRHSKind() == EmptyKind && !isNullary();
    }


    bool isBinary() const {
      return getLHSKind() != NullKind && getRHSKind() != EmptyKind;
    }



    bool isValid() const {

      if (isNullary() && getRHSKind() != EmptyKind)
        return false;


      if (getRHSKind() == NullKind)
        return false;


      if (getRHSKind() != EmptyKind && getLHSKind() == EmptyKind)
        return false;


      if (getLHSKind() == TwineKind &&
          !LHS.twine->isBinary())
        return false;
      if (getRHSKind() == TwineKind &&
          !RHS.twine->isBinary())
        return false;

      return true;
    }


    NodeKind getLHSKind() const { return LHSKind; }


    NodeKind getRHSKind() const { return RHSKind; }


    void printOneChild(raw_ostream &OS, Child Ptr, NodeKind Kind) const;


    void printOneChildRepr(raw_ostream &OS, Child Ptr,
                           NodeKind Kind) const;

  public:




                 Twine() {
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 264, "isValid() && \"Invalid twine!\"") : (void)0);
    }

    Twine(const Twine &) = default;






                 Twine(const char *Str) {
      if (Str[0] != '\0') {
        LHS.cString = Str;
        LHSKind = CStringKind;
      } else {
        LHSKind = EmptyKind;
      }

      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 282, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(std::nullptr_t) = delete;


                 Twine(const std::string &Str) : LHSKind(StdStringKind) {
      LHS.stdString = &Str;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 291, "isValid() && \"Invalid twine!\"") : (void)0);
    }





                 Twine(const std::string_view &Str)
        : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.length();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 302, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringRef &Str) : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 309, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringLiteral &Str)
        : LHSKind(StringLiteralKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 317, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const SmallVectorImpl<char> &Str)
        : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 325, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const formatv_object_base &Fmt)
        : LHSKind(FormatvObjectKind) {
      LHS.formatvObject = &Fmt;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 332, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    explicit Twine(char Val) : LHSKind(CharKind) {
      LHS.character = Val;
    }


    explicit Twine(signed char Val) : LHSKind(CharKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned char Val) : LHSKind(CharKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned Val) : LHSKind(DecUIKind) {
      LHS.decUI = Val;
    }


    explicit Twine(int Val) : LHSKind(DecIKind) {
      LHS.decI = Val;
    }


    explicit Twine(const unsigned long &Val) : LHSKind(DecULKind) {
      LHS.decUL = &Val;
    }


    explicit Twine(const long &Val) : LHSKind(DecLKind) {
      LHS.decL = &Val;
    }


    explicit Twine(const unsigned long long &Val) : LHSKind(DecULLKind) {
      LHS.decULL = &Val;
    }


    explicit Twine(const long long &Val) : LHSKind(DecLLKind) {
      LHS.decLL = &Val;
    }







                 Twine(const char *LHS, const StringRef &RHS)
        : LHSKind(CStringKind), RHSKind(PtrAndLengthKind) {
      this->LHS.cString = LHS;
      this->RHS.ptrAndLength.ptr = RHS.data();
      this->RHS.ptrAndLength.length = RHS.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 391, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringRef &LHS, const char *RHS)
        : LHSKind(PtrAndLengthKind), RHSKind(CStringKind) {
      this->LHS.ptrAndLength.ptr = LHS.data();
      this->LHS.ptrAndLength.length = LHS.size();
      this->RHS.cString = RHS;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 400, "isValid() && \"Invalid twine!\"") : (void)0);
    }



    Twine &operator=(const Twine &) = delete;



    static Twine createNull() {
      return Twine(NullKind);
    }






    static Twine utohexstr(const uint64_t &Val) {
      Child LHS, RHS;
      LHS.uHex = &Val;
      RHS.twine = nullptr;
      return Twine(LHS, UHexKind, RHS, EmptyKind);
    }







    bool isTriviallyEmpty() const {
      return isNullary();
    }


    bool isSingleStringLiteral() const {
      return isUnary() && getLHSKind() == StringLiteralKind;
    }



    bool isSingleStringRef() const {
      if (getRHSKind() != EmptyKind) return false;

      switch (getLHSKind()) {
      case EmptyKind:
      case CStringKind:
      case StdStringKind:
      case PtrAndLengthKind:
      case StringLiteralKind:
        return true;
      default:
        return false;
      }
    }





    Twine concat(const Twine &Suffix) const;






    __attribute__((visibility("default"))) std::string str() const;


    __attribute__((visibility("default"))) void toVector(SmallVectorImpl<char> &Out) const;



    StringRef getSingleStringRef() const {
      (__builtin_expect(!(isSingleStringRef() &&"This cannot be had as a single stringref!"), 0) ? __assert_rtn(__func__, "Twine.h", 476, "isSingleStringRef() &&\"This cannot be had as a single stringref!\"") : (void)0);
      switch (getLHSKind()) {
      default: ::llvm::llvm_unreachable_internal("Out of sync with isSingleStringRef", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h", 478);
      case EmptyKind:
        return StringRef();
      case CStringKind:
        return StringRef(LHS.cString);
      case StdStringKind:
        return StringRef(*LHS.stdString);
      case PtrAndLengthKind:
      case StringLiteralKind:
        return StringRef(LHS.ptrAndLength.ptr, LHS.ptrAndLength.length);
      }
    }




    StringRef toStringRef(SmallVectorImpl<char> &Out) const {
      if (isSingleStringRef())
        return getSingleStringRef();
      toVector(Out);
      return StringRef(Out.data(), Out.size());
    }






    __attribute__((visibility("default"))) StringRef
    toNullTerminatedStringRef(SmallVectorImpl<char> &Out) const;



    __attribute__((visibility("default"))) void print(raw_ostream &OS) const;


    __attribute__((visibility("default"))) void printRepr(raw_ostream &OS) const;



    __attribute__((noinline)) __attribute__((__used__)) __attribute__((__retain__)) void dump() const;


    __attribute__((noinline)) __attribute__((__used__)) __attribute__((__retain__)) void dumpRepr() const;



  };




  inline Twine Twine::concat(const Twine &Suffix) const {

    if (isNull() || Suffix.isNull())
      return Twine(NullKind);


    if (isEmpty())
      return Suffix;
    if (Suffix.isEmpty())
      return *this;



    Child NewLHS, NewRHS;
    NewLHS.twine = this;
    NewRHS.twine = &Suffix;
    NodeKind NewLHSKind = TwineKind, NewRHSKind = TwineKind;
    if (isUnary()) {
      NewLHS = LHS;
      NewLHSKind = getLHSKind();
    }
    if (Suffix.isUnary()) {
      NewRHS = Suffix.LHS;
      NewRHSKind = Suffix.getLHSKind();
    }

    return Twine(NewLHS, NewLHSKind, NewRHS, NewRHSKind);
  }

  inline Twine operator+(const Twine &LHS, const Twine &RHS) {
    return LHS.concat(RHS);
  }




  inline Twine operator+(const char *LHS, const StringRef &RHS) {
    return Twine(LHS, RHS);
  }




  inline Twine operator+(const StringRef &LHS, const char *RHS) {
    return Twine(LHS, RHS);
  }

  inline raw_ostream &operator<<(raw_ostream &OS, const Twine &RHS) {
    RHS.print(OS);
    return OS;
  }



}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 1
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h" 2






namespace llvm {





template <typename T, typename U>
using enableif_int =
    std::enable_if_t<std::is_integral_v<T> && std::is_integral_v<U>>;


template <typename T, typename U, typename = enableif_int<T, U>>
using common_uint =
    std::common_type_t<std::make_unsigned_t<T>, std::make_unsigned_t<U>>;
template <typename T, typename U, typename = enableif_int<T, U>>
using common_sint =
    std::common_type_t<std::make_signed_t<T>, std::make_signed_t<U>>;


namespace numbers {


constexpr double e = 0x1.5bf0a8b145769P+1,
                 egamma = 0x1.2788cfc6fb619P-1,
                 ln2 = 0x1.62e42fefa39efP-1,
                 ln10 = 0x1.26bb1bbb55516P+1,
                 log2e = 0x1.71547652b82feP+0,
                 log10e = 0x1.bcb7b1526e50eP-2,
                 pi = 0x1.921fb54442d18P+1,
                 inv_pi = 0x1.45f306dc9c883P-2,
                 sqrtpi = 0x1.c5bf891b4ef6bP+0,
                 inv_sqrtpi = 0x1.20dd750429b6dP-1,
                 sqrt2 = 0x1.6a09e667f3bcdP+0,
                 inv_sqrt2 = 0x1.6a09e667f3bcdP-1,
                 sqrt3 = 0x1.bb67ae8584caaP+0,
                 inv_sqrt3 = 0x1.279a74590331cP-1,
                 phi = 0x1.9e3779b97f4a8P+0;
constexpr float ef = 0x1.5bf0a8P+1F,
                egammaf = 0x1.2788d0P-1F,
                ln2f = 0x1.62e430P-1F,
                ln10f = 0x1.26bb1cP+1F,
                log2ef = 0x1.715476P+0F,
                log10ef = 0x1.bcb7b2P-2F,
                pif = 0x1.921fb6P+1F,
                inv_pif = 0x1.45f306P-2F,
                sqrtpif = 0x1.c5bf8aP+0F,
                inv_sqrtpif = 0x1.20dd76P-1F,
                sqrt2f = 0x1.6a09e6P+0F,
                inv_sqrt2f = 0x1.6a09e6P-1F,
                sqrt3f = 0x1.bb67aeP+0F,
                inv_sqrt3f = 0x1.279a74P-1F,
                phif = 0x1.9e377aP+0F;

}



template <typename T> constexpr T maskTrailingOnes(unsigned N) {
  static_assert(std::is_unsigned_v<T>, "Invalid type!");
  const unsigned Bits = 8 * sizeof(T);
  (__builtin_expect(!(N <= Bits && "Invalid bit index"), 0) ? __assert_rtn(__func__, "MathExtras.h", 85, "N <= Bits && \"Invalid bit index\"") : (void)0);
  if (N == 0)
    return 0;
  return T(-1) >> (Bits - N);
}



template <typename T> constexpr T maskLeadingOnes(unsigned N) {
  return ~maskTrailingOnes<T>(8 * sizeof(T) - N);
}



template <typename T> constexpr T maskTrailingZeros(unsigned N) {
  return maskLeadingOnes<T>(8 * sizeof(T) - N);
}



template <typename T> constexpr T maskLeadingZeros(unsigned N) {
  return maskTrailingOnes<T>(8 * sizeof(T) - N);
}




static const unsigned char BitReverseTable256[256] = {



  0, 0 + 2 * 64, 0 + 1 * 64, 0 + 3 * 64, 0 + 2 * 16, 0 + 2 * 16 + 2 * 64, 0 + 2 * 16 + 1 * 64, 0 + 2 * 16 + 3 * 64, 0 + 1 * 16, 0 + 1 * 16 + 2 * 64, 0 + 1 * 16 + 1 * 64, 0 + 1 * 16 + 3 * 64, 0 + 3 * 16, 0 + 3 * 16 + 2 * 64, 0 + 3 * 16 + 1 * 64, 0 + 3 * 16 + 3 * 64, 0 + 2 * 4, 0 + 2 * 4 + 2 * 64, 0 + 2 * 4 + 1 * 64, 0 + 2 * 4 + 3 * 64, 0 + 2 * 4 + 2 * 16, 0 + 2 * 4 + 2 * 16 + 2 * 64, 0 + 2 * 4 + 2 * 16 + 1 * 64, 0 + 2 * 4 + 2 * 16 + 3 * 64, 0 + 2 * 4 + 1 * 16, 0 + 2 * 4 + 1 * 16 + 2 * 64, 0 + 2 * 4 + 1 * 16 + 1 * 64, 0 + 2 * 4 + 1 * 16 + 3 * 64, 0 + 2 * 4 + 3 * 16, 0 + 2 * 4 + 3 * 16 + 2 * 64, 0 + 2 * 4 + 3 * 16 + 1 * 64, 0 + 2 * 4 + 3 * 16 + 3 * 64, 0 + 1 * 4, 0 + 1 * 4 + 2 * 64, 0 + 1 * 4 + 1 * 64, 0 + 1 * 4 + 3 * 64, 0 + 1 * 4 + 2 * 16, 0 + 1 * 4 + 2 * 16 + 2 * 64, 0 + 1 * 4 + 2 * 16 + 1 * 64, 0 + 1 * 4 + 2 * 16 + 3 * 64, 0 + 1 * 4 + 1 * 16, 0 + 1 * 4 + 1 * 16 + 2 * 64, 0 + 1 * 4 + 1 * 16 + 1 * 64, 0 + 1 * 4 + 1 * 16 + 3 * 64, 0 + 1 * 4 + 3 * 16, 0 + 1 * 4 + 3 * 16 + 2 * 64, 0 + 1 * 4 + 3 * 16 + 1 * 64, 0 + 1 * 4 + 3 * 16 + 3 * 64, 0 + 3 * 4, 0 + 3 * 4 + 2 * 64, 0 + 3 * 4 + 1 * 64, 0 + 3 * 4 + 3 * 64, 0 + 3 * 4 + 2 * 16, 0 + 3 * 4 + 2 * 16 + 2 * 64, 0 + 3 * 4 + 2 * 16 + 1 * 64, 0 + 3 * 4 + 2 * 16 + 3 * 64, 0 + 3 * 4 + 1 * 16, 0 + 3 * 4 + 1 * 16 + 2 * 64, 0 + 3 * 4 + 1 * 16 + 1 * 64, 0 + 3 * 4 + 1 * 16 + 3 * 64, 0 + 3 * 4 + 3 * 16, 0 + 3 * 4 + 3 * 16 + 2 * 64, 0 + 3 * 4 + 3 * 16 + 1 * 64, 0 + 3 * 4 + 3 * 16 + 3 * 64, 2, 2 + 2 * 64, 2 + 1 * 64, 2 + 3 * 64, 2 + 2 * 16, 2 + 2 * 16 + 2 * 64, 2 + 2 * 16 + 1 * 64, 2 + 2 * 16 + 3 * 64, 2 + 1 * 16, 2 + 1 * 16 + 2 * 64, 2 + 1 * 16 + 1 * 64, 2 + 1 * 16 + 3 * 64, 2 + 3 * 16, 2 + 3 * 16 + 2 * 64, 2 + 3 * 16 + 1 * 64, 2 + 3 * 16 + 3 * 64, 2 + 2 * 4, 2 + 2 * 4 + 2 * 64, 2 + 2 * 4 + 1 * 64, 2 + 2 * 4 + 3 * 64, 2 + 2 * 4 + 2 * 16, 2 + 2 * 4 + 2 * 16 + 2 * 64, 2 + 2 * 4 + 2 * 16 + 1 * 64, 2 + 2 * 4 + 2 * 16 + 3 * 64, 2 + 2 * 4 + 1 * 16, 2 + 2 * 4 + 1 * 16 + 2 * 64, 2 + 2 * 4 + 1 * 16 + 1 * 64, 2 + 2 * 4 + 1 * 16 + 3 * 64, 2 + 2 * 4 + 3 * 16, 2 + 2 * 4 + 3 * 16 + 2 * 64, 2 + 2 * 4 + 3 * 16 + 1 * 64, 2 + 2 * 4 + 3 * 16 + 3 * 64, 2 + 1 * 4, 2 + 1 * 4 + 2 * 64, 2 + 1 * 4 + 1 * 64, 2 + 1 * 4 + 3 * 64, 2 + 1 * 4 + 2 * 16, 2 + 1 * 4 + 2 * 16 + 2 * 64, 2 + 1 * 4 + 2 * 16 + 1 * 64, 2 + 1 * 4 + 2 * 16 + 3 * 64, 2 + 1 * 4 + 1 * 16, 2 + 1 * 4 + 1 * 16 + 2 * 64, 2 + 1 * 4 + 1 * 16 + 1 * 64, 2 + 1 * 4 + 1 * 16 + 3 * 64, 2 + 1 * 4 + 3 * 16, 2 + 1 * 4 + 3 * 16 + 2 * 64, 2 + 1 * 4 + 3 * 16 + 1 * 64, 2 + 1 * 4 + 3 * 16 + 3 * 64, 2 + 3 * 4, 2 + 3 * 4 + 2 * 64, 2 + 3 * 4 + 1 * 64, 2 + 3 * 4 + 3 * 64, 2 + 3 * 4 + 2 * 16, 2 + 3 * 4 + 2 * 16 + 2 * 64, 2 + 3 * 4 + 2 * 16 + 1 * 64, 2 + 3 * 4 + 2 * 16 + 3 * 64, 2 + 3 * 4 + 1 * 16, 2 + 3 * 4 + 1 * 16 + 2 * 64, 2 + 3 * 4 + 1 * 16 + 1 * 64, 2 + 3 * 4 + 1 * 16 + 3 * 64, 2 + 3 * 4 + 3 * 16, 2 + 3 * 4 + 3 * 16 + 2 * 64, 2 + 3 * 4 + 3 * 16 + 1 * 64, 2 + 3 * 4 + 3 * 16 + 3 * 64, 1, 1 + 2 * 64, 1 + 1 * 64, 1 + 3 * 64, 1 + 2 * 16, 1 + 2 * 16 + 2 * 64, 1 + 2 * 16 + 1 * 64, 1 + 2 * 16 + 3 * 64, 1 + 1 * 16, 1 + 1 * 16 + 2 * 64, 1 + 1 * 16 + 1 * 64, 1 + 1 * 16 + 3 * 64, 1 + 3 * 16, 1 + 3 * 16 + 2 * 64, 1 + 3 * 16 + 1 * 64, 1 + 3 * 16 + 3 * 64, 1 + 2 * 4, 1 + 2 * 4 + 2 * 64, 1 + 2 * 4 + 1 * 64, 1 + 2 * 4 + 3 * 64, 1 + 2 * 4 + 2 * 16, 1 + 2 * 4 + 2 * 16 + 2 * 64, 1 + 2 * 4 + 2 * 16 + 1 * 64, 1 + 2 * 4 + 2 * 16 + 3 * 64, 1 + 2 * 4 + 1 * 16, 1 + 2 * 4 + 1 * 16 + 2 * 64, 1 + 2 * 4 + 1 * 16 + 1 * 64, 1 + 2 * 4 + 1 * 16 + 3 * 64, 1 + 2 * 4 + 3 * 16, 1 + 2 * 4 + 3 * 16 + 2 * 64, 1 + 2 * 4 + 3 * 16 + 1 * 64, 1 + 2 * 4 + 3 * 16 + 3 * 64, 1 + 1 * 4, 1 + 1 * 4 + 2 * 64, 1 + 1 * 4 + 1 * 64, 1 + 1 * 4 + 3 * 64, 1 + 1 * 4 + 2 * 16, 1 + 1 * 4 + 2 * 16 + 2 * 64, 1 + 1 * 4 + 2 * 16 + 1 * 64, 1 + 1 * 4 + 2 * 16 + 3 * 64, 1 + 1 * 4 + 1 * 16, 1 + 1 * 4 + 1 * 16 + 2 * 64, 1 + 1 * 4 + 1 * 16 + 1 * 64, 1 + 1 * 4 + 1 * 16 + 3 * 64, 1 + 1 * 4 + 3 * 16, 1 + 1 * 4 + 3 * 16 + 2 * 64, 1 + 1 * 4 + 3 * 16 + 1 * 64, 1 + 1 * 4 + 3 * 16 + 3 * 64, 1 + 3 * 4, 1 + 3 * 4 + 2 * 64, 1 + 3 * 4 + 1 * 64, 1 + 3 * 4 + 3 * 64, 1 + 3 * 4 + 2 * 16, 1 + 3 * 4 + 2 * 16 + 2 * 64, 1 + 3 * 4 + 2 * 16 + 1 * 64, 1 + 3 * 4 + 2 * 16 + 3 * 64, 1 + 3 * 4 + 1 * 16, 1 + 3 * 4 + 1 * 16 + 2 * 64, 1 + 3 * 4 + 1 * 16 + 1 * 64, 1 + 3 * 4 + 1 * 16 + 3 * 64, 1 + 3 * 4 + 3 * 16, 1 + 3 * 4 + 3 * 16 + 2 * 64, 1 + 3 * 4 + 3 * 16 + 1 * 64, 1 + 3 * 4 + 3 * 16 + 3 * 64, 3, 3 + 2 * 64, 3 + 1 * 64, 3 + 3 * 64, 3 + 2 * 16, 3 + 2 * 16 + 2 * 64, 3 + 2 * 16 + 1 * 64, 3 + 2 * 16 + 3 * 64, 3 + 1 * 16, 3 + 1 * 16 + 2 * 64, 3 + 1 * 16 + 1 * 64, 3 + 1 * 16 + 3 * 64, 3 + 3 * 16, 3 + 3 * 16 + 2 * 64, 3 + 3 * 16 + 1 * 64, 3 + 3 * 16 + 3 * 64, 3 + 2 * 4, 3 + 2 * 4 + 2 * 64, 3 + 2 * 4 + 1 * 64, 3 + 2 * 4 + 3 * 64, 3 + 2 * 4 + 2 * 16, 3 + 2 * 4 + 2 * 16 + 2 * 64, 3 + 2 * 4 + 2 * 16 + 1 * 64, 3 + 2 * 4 + 2 * 16 + 3 * 64, 3 + 2 * 4 + 1 * 16, 3 + 2 * 4 + 1 * 16 + 2 * 64, 3 + 2 * 4 + 1 * 16 + 1 * 64, 3 + 2 * 4 + 1 * 16 + 3 * 64, 3 + 2 * 4 + 3 * 16, 3 + 2 * 4 + 3 * 16 + 2 * 64, 3 + 2 * 4 + 3 * 16 + 1 * 64, 3 + 2 * 4 + 3 * 16 + 3 * 64, 3 + 1 * 4, 3 + 1 * 4 + 2 * 64, 3 + 1 * 4 + 1 * 64, 3 + 1 * 4 + 3 * 64, 3 + 1 * 4 + 2 * 16, 3 + 1 * 4 + 2 * 16 + 2 * 64, 3 + 1 * 4 + 2 * 16 + 1 * 64, 3 + 1 * 4 + 2 * 16 + 3 * 64, 3 + 1 * 4 + 1 * 16, 3 + 1 * 4 + 1 * 16 + 2 * 64, 3 + 1 * 4 + 1 * 16 + 1 * 64, 3 + 1 * 4 + 1 * 16 + 3 * 64, 3 + 1 * 4 + 3 * 16, 3 + 1 * 4 + 3 * 16 + 2 * 64, 3 + 1 * 4 + 3 * 16 + 1 * 64, 3 + 1 * 4 + 3 * 16 + 3 * 64, 3 + 3 * 4, 3 + 3 * 4 + 2 * 64, 3 + 3 * 4 + 1 * 64, 3 + 3 * 4 + 3 * 64, 3 + 3 * 4 + 2 * 16, 3 + 3 * 4 + 2 * 16 + 2 * 64, 3 + 3 * 4 + 2 * 16 + 1 * 64, 3 + 3 * 4 + 2 * 16 + 3 * 64, 3 + 3 * 4 + 1 * 16, 3 + 3 * 4 + 1 * 16 + 2 * 64, 3 + 3 * 4 + 1 * 16 + 1 * 64, 3 + 3 * 4 + 1 * 16 + 3 * 64, 3 + 3 * 4 + 3 * 16, 3 + 3 * 4 + 3 * 16 + 2 * 64, 3 + 3 * 4 + 3 * 16 + 1 * 64, 3 + 3 * 4 + 3 * 16 + 3 * 64



};


template <typename T> constexpr T reverseBits(T Val) {

  if constexpr (std::is_same_v<T, uint8_t>)
    return __builtin_bitreverse8(Val);


  if constexpr (std::is_same_v<T, uint16_t>)
    return __builtin_bitreverse16(Val);


  if constexpr (std::is_same_v<T, uint32_t>)
    return __builtin_bitreverse32(Val);


  if constexpr (std::is_same_v<T, uint64_t>)
    return __builtin_bitreverse64(Val);


  unsigned char in[sizeof(Val)];
  unsigned char out[sizeof(Val)];
  std::memcpy(in, &Val, sizeof(Val));
  for (unsigned i = 0; i < sizeof(Val); ++i)
    out[(sizeof(Val) - i) - 1] = BitReverseTable256[in[i]];
  std::memcpy(&Val, out, sizeof(Val));
  return Val;
}






constexpr uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


constexpr uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}


constexpr uint64_t Make_64(uint32_t High, uint32_t Low) {
  return ((uint64_t)High << 32) | (uint64_t)Low;
}


template <unsigned N> constexpr bool isInt(int64_t x) {
  if constexpr (N == 0)
    return 0 == x;
  if constexpr (N == 8)
    return static_cast<int8_t>(x) == x;
  if constexpr (N == 16)
    return static_cast<int16_t>(x) == x;
  if constexpr (N == 32)
    return static_cast<int32_t>(x) == x;
  if constexpr (N < 64)
    return -((1LL) << (N - 1)) <= x && x < ((1LL) << (N - 1));
  (void)x;
  return true;
}


template <unsigned N, unsigned S>
constexpr bool isShiftedInt(int64_t x) {
  static_assert(S < 64, "isShiftedInt<N, S> with S >= 64 is too much.");
  static_assert(N + S <= 64, "isShiftedInt<N, S> with N + S > 64 is too wide.");
  return isInt<N + S>(x) && (x % ((1ULL) << S) == 0);
}


template <unsigned N> constexpr bool isUInt(uint64_t x) {
  if constexpr (N == 0)
    return 0 == x;
  if constexpr (N == 8)
    return static_cast<uint8_t>(x) == x;
  if constexpr (N == 16)
    return static_cast<uint16_t>(x) == x;
  if constexpr (N == 32)
    return static_cast<uint32_t>(x) == x;
  if constexpr (N < 64)
    return x < ((1ULL) << (N));
  (void)x;
  return true;
}


template <unsigned N, unsigned S>
constexpr bool isShiftedUInt(uint64_t x) {
  static_assert(S < 64, "isShiftedUInt<N, S> with S >= 64 is too much.");
  static_assert(N + S <= 64,
                "isShiftedUInt<N, S> with N + S > 64 is too wide.");

  return isUInt<N + S>(x) && (x % ((1ULL) << S) == 0);
}


inline constexpr uint64_t maxUIntN(uint64_t N) {
  (__builtin_expect(!(N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 221, "N <= 64 && \"integer width out of range\"") : (void)0);
# 230 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
  if (N == 0)
    return 0;
  return 18446744073709551615ULL >> (64 - N);
}


inline constexpr int64_t minIntN(int64_t N) {
  (__builtin_expect(!(N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 237, "N <= 64 && \"integer width out of range\"") : (void)0);

  if (N == 0)
    return 0;
  return (1ULL) + ~((1ULL) << (N - 1));
}


inline constexpr int64_t maxIntN(int64_t N) {
  (__builtin_expect(!(N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 246, "N <= 64 && \"integer width out of range\"") : (void)0);



  if (N == 0)
    return 0;
  return ((1ULL) << (N - 1)) - 1;
}


inline constexpr bool isUIntN(unsigned N, uint64_t x) {
  return N >= 64 || x <= maxUIntN(N);
}


inline constexpr bool isIntN(unsigned N, int64_t x) {
  return N >= 64 || (minIntN(N) <= x && x <= maxIntN(N));
}




constexpr bool isMask_32(uint32_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}



constexpr bool isMask_64(uint64_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}



constexpr bool isShiftedMask_32(uint32_t Value) {
  return Value && isMask_32((Value - 1) | Value);
}



constexpr bool isShiftedMask_64(uint64_t Value) {
  return Value && isMask_64((Value - 1) | Value);
}



constexpr bool isPowerOf2_32(uint32_t Value) {
  return llvm::has_single_bit(Value);
}


constexpr bool isPowerOf2_64(uint64_t Value) {
  return llvm::has_single_bit(Value);
}






inline bool isShiftedMask_32(uint32_t Value, unsigned &MaskIdx,
                             unsigned &MaskLen) {
  if (!isShiftedMask_32(Value))
    return false;
  MaskIdx = llvm::countr_zero(Value);
  MaskLen = llvm::popcount(Value);
  return true;
}





inline bool isShiftedMask_64(uint64_t Value, unsigned &MaskIdx,
                             unsigned &MaskLen) {
  if (!isShiftedMask_64(Value))
    return false;
  MaskIdx = llvm::countr_zero(Value);
  MaskLen = llvm::popcount(Value);
  return true;
}



template <size_t kValue> constexpr size_t CTLog2() {
  static_assert(llvm::isPowerOf2_64(kValue), "Value is not a valid power of 2");
  return 1 + CTLog2<kValue / 2>();
}

template <> constexpr size_t CTLog2<1>() { return 0; }




inline unsigned Log2_32(uint32_t Value) {
  return 31 - llvm::countl_zero(Value);
}



inline unsigned Log2_64(uint64_t Value) {
  return 63 - llvm::countl_zero(Value);
}




inline unsigned Log2_32_Ceil(uint32_t Value) {
  return 32 - llvm::countl_zero(Value - 1);
}



inline unsigned Log2_64_Ceil(uint64_t Value) {
  return 64 - llvm::countl_zero(Value - 1);
}



template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T MinAlign(U A, V B) {





  return (A | B) & (1 + ~(A | B));
}


constexpr uint64_t MinAlign(uint64_t A, uint64_t B) {
  return (A | B) & (1 + ~(A | B));
}



constexpr uint64_t NextPowerOf2(uint64_t A) {
  A |= (A >> 1);
  A |= (A >> 2);
  A |= (A >> 4);
  A |= (A >> 8);
  A |= (A >> 16);
  A |= (A >> 32);
  return A + 1;
}



inline uint64_t PowerOf2Ceil(uint64_t A) {
  if (!A || A > 18446744073709551615ULL / 2)
    return 0;
  return (1ULL) << Log2_64_Ceil(A);
}



template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T divideCeil(U Numerator, V Denominator) {
  (__builtin_expect(!(Denominator && "Division by zero"), 0) ? __assert_rtn(__func__, "MathExtras.h", 404, "Denominator && \"Division by zero\"") : (void)0);
  T Bias = (Numerator != 0);
  return (Numerator - Bias) / Denominator + Bias;
}


constexpr uint64_t divideCeil(uint64_t Numerator, uint64_t Denominator) {
  (__builtin_expect(!(Denominator && "Division by zero"), 0) ? __assert_rtn(__func__, "MathExtras.h", 411, "Denominator && \"Division by zero\"") : (void)0);
  uint64_t Bias = (Numerator != 0);
  return (Numerator - Bias) / Denominator + Bias;
}



template <typename U, typename V>
constexpr bool divideSignedWouldOverflow(U Numerator, V Denominator) {
  return Numerator == std::numeric_limits<U>::min() && Denominator == -1;
}



template <typename U, typename V, typename T = common_sint<U, V>>
constexpr T divideCeilSigned(U Numerator, V Denominator) {
  (__builtin_expect(!(Denominator && "Division by zero"), 0) ? __assert_rtn(__func__, "MathExtras.h", 427, "Denominator && \"Division by zero\"") : (void)0);
  (__builtin_expect(!(!divideSignedWouldOverflow(Numerator, Denominator) && "Divide would overflow"), 0) ? __assert_rtn(__func__, "MathExtras.h", 429, "!divideSignedWouldOverflow(Numerator, Denominator) && \"Divide would overflow\"") : (void)0);

  if (!Numerator)
    return 0;

  T Bias = Denominator >= 0 ? 1 : -1;
  bool SameSign = (Numerator >= 0) == (Denominator >= 0);
  return SameSign ? (Numerator - Bias) / Denominator + 1
                  : Numerator / Denominator;
}



template <typename U, typename V, typename T = common_sint<U, V>>
constexpr T divideFloorSigned(U Numerator, V Denominator) {
  (__builtin_expect(!(Denominator && "Division by zero"), 0) ? __assert_rtn(__func__, "MathExtras.h", 443, "Denominator && \"Division by zero\"") : (void)0);
  (__builtin_expect(!(!divideSignedWouldOverflow(Numerator, Denominator) && "Divide would overflow"), 0) ? __assert_rtn(__func__, "MathExtras.h", 445, "!divideSignedWouldOverflow(Numerator, Denominator) && \"Divide would overflow\"") : (void)0);

  if (!Numerator)
    return 0;

  T Bias = Denominator >= 0 ? -1 : 1;
  bool SameSign = (Numerator >= 0) == (Denominator >= 0);
  return SameSign ? Numerator / Denominator
                  : (Numerator - Bias) / Denominator - 1;
}



template <typename U, typename V, typename T = common_sint<U, V>>
constexpr T mod(U Numerator, V Denominator) {
  (__builtin_expect(!(Denominator >= 1 && "Mod by non-positive number"), 0) ? __assert_rtn(__func__, "MathExtras.h", 459, "Denominator >= 1 && \"Mod by non-positive number\"") : (void)0);
  T Mod = Numerator % Denominator;
  return Mod < 0 ? Mod + Denominator : Mod;
}



template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T divideNearest(U Numerator, V Denominator) {
  (__builtin_expect(!(Denominator && "Division by zero"), 0) ? __assert_rtn(__func__, "MathExtras.h", 468, "Denominator && \"Division by zero\"") : (void)0);
  T Mod = Numerator % Denominator;
  return (Numerator / Denominator) +
         (Mod > (static_cast<T>(Denominator) - 1) / 2);
}
# 486 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T alignTo(U Value, V Align) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 488, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  T CeilDiv = divideCeil(Value, Align);
  return CeilDiv * Align;
}


constexpr uint64_t alignTo(uint64_t Value, uint64_t Align) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 495, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  uint64_t CeilDiv = divideCeil(Value, Align);
  return CeilDiv * Align;
}


template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T alignToPowerOf2(U Value, V Align) {
  (__builtin_expect(!(Align != 0 && (Align & (Align - 1)) == 0 && "Align must be a power of 2"), 0) ? __assert_rtn(__func__, "MathExtras.h", 504, "Align != 0 && (Align & (Align - 1)) == 0 && \"Align must be a power of 2\"") : (void)0);

  T NegAlign = static_cast<T>(0) - Align;
  return (Value + (Align - 1)) & NegAlign;
}


constexpr uint64_t alignToPowerOf2(uint64_t Value, uint64_t Align) {
  (__builtin_expect(!(Align != 0 && (Align & (Align - 1)) == 0 && "Align must be a power of 2"), 0) ? __assert_rtn(__func__, "MathExtras.h", 512, "Align != 0 && (Align & (Align - 1)) == 0 && \"Align must be a power of 2\"") : (void)0);

  uint64_t NegAlign = 0 - Align;
  return (Value + (Align - 1)) & NegAlign;
}
# 531 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
template <typename U, typename V, typename W,
          typename T = common_uint<common_uint<U, V>, W>>
constexpr T alignTo(U Value, V Align, W Skew) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 534, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  Skew %= Align;
  return alignTo(Value - Skew, Align) + Skew;
}





template <auto Align, typename V, typename T = common_uint<decltype(Align), V>>
constexpr T alignTo(V Value) {
  static_assert(Align != 0u, "Align must be non-zero");
  T CeilDiv = divideCeil(Value, Align);
  return CeilDiv * Align;
}




template <typename U, typename V, typename W = uint8_t,
          typename T = common_uint<common_uint<U, V>, W>>
constexpr T alignDown(U Value, V Align, W Skew = 0) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 556, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  Skew %= Align;
  return (Value - Skew) / Align * Align + Skew;
}



template <unsigned B> constexpr int32_t SignExtend32(uint32_t X) {
  static_assert(B <= 32, "Bit width out of range.");
  if constexpr (B == 0)
    return 0;
  return int32_t(X << (32 - B)) >> (32 - B);
}



inline int32_t SignExtend32(uint32_t X, unsigned B) {
  (__builtin_expect(!(B <= 32 && "Bit width out of range."), 0) ? __assert_rtn(__func__, "MathExtras.h", 573, "B <= 32 && \"Bit width out of range.\"") : (void)0);
  if (B == 0)
    return 0;
  return int32_t(X << (32 - B)) >> (32 - B);
}



template <unsigned B> constexpr int64_t SignExtend64(uint64_t x) {
  static_assert(B <= 64, "Bit width out of range.");
  if constexpr (B == 0)
    return 0;
  return int64_t(x << (64 - B)) >> (64 - B);
}



inline int64_t SignExtend64(uint64_t X, unsigned B) {
  (__builtin_expect(!(B <= 64 && "Bit width out of range."), 0) ? __assert_rtn(__func__, "MathExtras.h", 591, "B <= 64 && \"Bit width out of range.\"") : (void)0);
  if (B == 0)
    return 0;
  return int64_t(X << (64 - B)) >> (64 - B);
}




template <typename T, typename U = std::make_unsigned_t<T>>
constexpr U AbsoluteValue(T X) {

  return X < 0 ? -static_cast<U>(X) : X;
}



template <typename U, typename V, typename T = common_uint<U, V>>
constexpr T AbsoluteDifference(U X, V Y) {
  return X > Y ? (X - Y) : (Y - X);
}




template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingAdd(T X, T Y, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;

  T Z = X + Y;
  Overflowed = (Z < X || Z < Y);
  if (Overflowed)
    return std::numeric_limits<T>::max();
  else
    return Z;
}



template <class T, class... Ts>
std::enable_if_t<std::is_unsigned_v<T>, T> SaturatingAdd(T X, T Y, T Z,
                                                         Ts... Args) {
  bool Overflowed = false;
  T XY = SaturatingAdd(X, Y, &Overflowed);
  if (Overflowed)
    return SaturatingAdd(std::numeric_limits<T>::max(), T(1), Args...);
  return SaturatingAdd(XY, Z, Args...);
}




template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingMultiply(T X, T Y, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;






  Overflowed = false;




  int Log2Z = Log2_64(X) + Log2_64(Y);
  const T Max = std::numeric_limits<T>::max();
  int Log2Max = Log2_64(Max);
  if (Log2Z < Log2Max) {
    return X * Y;
  }
  if (Log2Z > Log2Max) {
    Overflowed = true;
    return Max;
  }




  T Z = (X >> 1) * Y;
  if (Z & ~(Max >> 1)) {
    Overflowed = true;
    return Max;
  }
  Z <<= 1;
  if (X & 1)
    return SaturatingAdd(Z, Y, ResultOverflowed);

  return Z;
}





template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingMultiplyAdd(T X, T Y, T A, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;

  T Product = SaturatingMultiply(X, Y, &Overflowed);
  if (Overflowed)
    return Product;

  return SaturatingAdd(A, Product, &Overflowed);
}


__attribute__((visibility("default"))) extern const float huge_valf;



template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> AddOverflow(T X, T Y, T &Result) {

  return __builtin_add_overflow(X, Y, &Result);
# 731 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
}



template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> SubOverflow(T X, T Y, T &Result) {

  return __builtin_sub_overflow(X, Y, &Result);
# 757 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
}



template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> MulOverflow(T X, T Y, T &Result) {

  return __builtin_mul_overflow(X, Y, &Result);
# 788 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
}






using stack_float_t = float;


}
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 2





namespace llvm {







struct Align {
private:
  uint8_t ShiftValue = 0;


  friend struct MaybeAlign;
  friend unsigned Log2(Align);
  friend bool operator==(Align Lhs, Align Rhs);
  friend bool operator!=(Align Lhs, Align Rhs);
  friend bool operator<=(Align Lhs, Align Rhs);
  friend bool operator>=(Align Lhs, Align Rhs);
  friend bool operator<(Align Lhs, Align Rhs);
  friend bool operator>(Align Lhs, Align Rhs);
  friend unsigned encode(struct MaybeAlign A);
  friend struct MaybeAlign decodeMaybeAlign(unsigned Value);
# 62 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
  struct LogValue {
    uint8_t Log;
  };

public:

  constexpr Align() = default;


  constexpr Align(const Align &Other) = default;
  constexpr Align(Align &&Other) = default;
  Align &operator=(const Align &Other) = default;
  Align &operator=(Align &&Other) = default;

  explicit Align(uint64_t Value) {
    (__builtin_expect(!(Value > 0 && "Value must not be 0"), 0) ? __assert_rtn(__func__, "Alignment.h", 77, "Value > 0 && \"Value must not be 0\"") : (void)0);
    (__builtin_expect(!(llvm::isPowerOf2_64(Value) && "Alignment is not a power of 2"), 0) ? __assert_rtn(__func__, "Alignment.h", 78, "llvm::isPowerOf2_64(Value) && \"Alignment is not a power of 2\"") : (void)0);
    ShiftValue = Log2_64(Value);
    (__builtin_expect(!(ShiftValue < 64 && "Broken invariant"), 0) ? __assert_rtn(__func__, "Alignment.h", 80, "ShiftValue < 64 && \"Broken invariant\"") : (void)0);
  }



  uint64_t value() const { return uint64_t(1) << ShiftValue; }


  Align previous() const {
    (__builtin_expect(!(ShiftValue != 0 && "Undefined operation"), 0) ? __assert_rtn(__func__, "Alignment.h", 89, "ShiftValue != 0 && \"Undefined operation\"") : (void)0);
    Align Out;
    Out.ShiftValue = ShiftValue - 1;
    return Out;
  }


  template <size_t kValue> constexpr static Align Constant() {
    return LogValue{static_cast<uint8_t>(CTLog2<kValue>())};
  }



  template <typename T> constexpr static Align Of() {
    return Constant<std::alignment_of_v<T>>();
  }


  constexpr Align(LogValue CA) : ShiftValue(CA.Log) {}
};


inline Align assumeAligned(uint64_t Value) {
  return Value ? Align(Value) : Align();
}



struct MaybeAlign : public std::optional<Align> {
private:
  using UP = std::optional<Align>;

public:

  MaybeAlign() = default;


  MaybeAlign(const MaybeAlign &Other) = default;
  MaybeAlign &operator=(const MaybeAlign &Other) = default;
  MaybeAlign(MaybeAlign &&Other) = default;
  MaybeAlign &operator=(MaybeAlign &&Other) = default;

  constexpr MaybeAlign(std::nullopt_t None) : UP(None) {}
  constexpr MaybeAlign(Align Value) : UP(Value) {}
  explicit MaybeAlign(uint64_t Value) {
    (__builtin_expect(!((Value == 0 || llvm::isPowerOf2_64(Value)) && "Alignment is neither 0 nor a power of 2"), 0) ? __assert_rtn(__func__, "Alignment.h", 135, "(Value == 0 || llvm::isPowerOf2_64(Value)) && \"Alignment is neither 0 nor a power of 2\"") : (void)0);

    if (Value)
      emplace(Value);
  }


  Align valueOrOne() const { return value_or(Align()); }
};


inline bool isAligned(Align Lhs, uint64_t SizeInBytes) {
  return SizeInBytes % Lhs.value() == 0;
}


inline bool isAddrAligned(Align Lhs, const void *Addr) {
  return isAligned(Lhs, reinterpret_cast<uintptr_t>(Addr));
}


inline uint64_t alignTo(uint64_t Size, Align A) {
  const uint64_t Value = A.value();
# 166 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
  return (Size + Value - 1) & ~(Value - 1U);
}
# 180 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
inline uint64_t alignTo(uint64_t Size, Align A, uint64_t Skew) {
  const uint64_t Value = A.value();
  Skew %= Value;
  return alignTo(Size - Skew, A) + Skew;
}


inline uintptr_t alignAddr(const void *Addr, Align Alignment) {
  uintptr_t ArithAddr = reinterpret_cast<uintptr_t>(Addr);
  (__builtin_expect(!(static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && "Overflow"), 0) ? __assert_rtn(__func__, "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"") : (void)0);


  return alignTo(ArithAddr, Alignment);
}



inline uint64_t offsetToAlignment(uint64_t Value, Align Alignment) {
  return alignTo(Value, Alignment) - Value;
}



inline uint64_t offsetToAlignedAddr(const void *Addr, Align Alignment) {
  return offsetToAlignment(reinterpret_cast<uintptr_t>(Addr), Alignment);
}


inline unsigned Log2(Align A) { return A.ShiftValue; }



inline Align commonAlignment(Align A, uint64_t Offset) {
  return Align(MinAlign(A.value(), Offset));
}


inline unsigned encode(MaybeAlign A) { return A ? A->ShiftValue + 1 : 0; }


inline MaybeAlign decodeMaybeAlign(unsigned Value) {
  if (Value == 0)
    return MaybeAlign();
  Align Out;
  Out.ShiftValue = Value - 1;
  return Out;
}



inline unsigned encode(Align A) { return encode(MaybeAlign(A)); }


inline bool operator==(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 234, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() == Rhs;
}
inline bool operator!=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 238, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() != Rhs;
}
inline bool operator<=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 242, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() <= Rhs;
}
inline bool operator>=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 246, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() >= Rhs;
}
inline bool operator<(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 250, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() < Rhs;
}
inline bool operator>(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 254, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() > Rhs;
}


inline bool operator==(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue == Rhs.ShiftValue;
}
inline bool operator!=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue != Rhs.ShiftValue;
}
inline bool operator<=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue <= Rhs.ShiftValue;
}
inline bool operator>=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue >= Rhs.ShiftValue;
}
inline bool operator<(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue < Rhs.ShiftValue;
}
inline bool operator>(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue > Rhs.ShiftValue;
}


bool operator<=(Align Lhs, MaybeAlign Rhs) = delete;
bool operator>=(Align Lhs, MaybeAlign Rhs) = delete;
bool operator<(Align Lhs, MaybeAlign Rhs) = delete;
bool operator>(Align Lhs, MaybeAlign Rhs) = delete;

bool operator<=(MaybeAlign Lhs, Align Rhs) = delete;
bool operator>=(MaybeAlign Lhs, Align Rhs) = delete;
bool operator<(MaybeAlign Lhs, Align Rhs) = delete;
bool operator>(MaybeAlign Lhs, Align Rhs) = delete;

bool operator<=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator>=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator<(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator>(MaybeAlign Lhs, MaybeAlign Rhs) = delete;


inline bool operator==(MaybeAlign Lhs, Align Rhs) { return Lhs && *Lhs == Rhs; }
inline bool operator!=(MaybeAlign Lhs, Align Rhs) { return !(Lhs == Rhs); }
inline bool operator==(Align Lhs, MaybeAlign Rhs) { return Rhs == Lhs; }
inline bool operator!=(Align Lhs, MaybeAlign Rhs) { return !(Rhs == Lhs); }

inline bool operator==(MaybeAlign Lhs, MaybeAlign Rhs) {
  return (Lhs && Rhs && (*Lhs == *Rhs)) || (!Lhs && !Rhs);
}
inline bool operator!=(MaybeAlign Lhs, MaybeAlign Rhs) { return !(Lhs == Rhs); }

inline bool operator==(MaybeAlign Lhs, std::nullopt_t) { return !bool(Lhs); }
inline bool operator!=(MaybeAlign Lhs, std::nullopt_t) { return bool(Lhs); }
inline bool operator==(std::nullopt_t, MaybeAlign Rhs) { return !bool(Rhs); }
inline bool operator!=(std::nullopt_t, MaybeAlign Rhs) { return bool(Rhs); }



inline std::string DebugStr(const Align &A) {
  return std::to_string(A.value());
}

inline std::string DebugStr(const MaybeAlign &MA) {
  if (MA)
    return std::to_string(MA->value());
  return "None";
}




}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 2




namespace llvm {
# 34 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename From> struct simplify_type {
  using SimpleType = From;


  static SimpleType &getSimplifiedValue(From &Val) { return Val; }
};

template <typename From> struct simplify_type<const From> {
  using NonConstSimpleType = typename simplify_type<From>::SimpleType;
  using SimpleType = typename add_const_past_pointer<NonConstSimpleType>::type;
  using RetType =
      typename add_lvalue_reference_if_not_pointer<SimpleType>::type;

  static RetType getSimplifiedValue(const From &Val) {
    return simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val));
  }
};
# 63 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enabler = void> struct isa_impl {
  static inline bool doit(const From &Val) { return To::classof(&Val); }
};


template <typename To, typename From>
struct isa_impl<To, From, std::enable_if_t<std::is_base_of_v<To, From>>> {
  static inline bool doit(const From &) { return true; }
};

template <typename To, typename From> struct isa_impl_cl {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From> {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From>
struct isa_impl_cl<To, const std::unique_ptr<From>> {
  static inline bool doit(const std::unique_ptr<From> &Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 88, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl_cl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From *> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 95, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From *const> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 102, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From *> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 109, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From>
struct isa_impl_cl<To, const From *const> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 117, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From, typename SimpleFrom>
struct isa_impl_wrap {


  static bool doit(const From &Val) {
    return isa_impl_wrap<To, SimpleFrom,
                         typename simplify_type<SimpleFrom>::SimpleType>::
        doit(simplify_type<const From>::getSimplifiedValue(Val));
  }
};

template <typename To, typename FromTy>
struct isa_impl_wrap<To, FromTy, FromTy> {

  static bool doit(const FromTy &Val) {
    return isa_impl_cl<To, FromTy>::doit(Val);
  }
};





template <class To, class From> struct cast_retty;



template <class To, class From> struct cast_retty_impl {
  using ret_type = To &;
};
template <class To, class From> struct cast_retty_impl<To, const From> {
  using ret_type = const To &;
};

template <class To, class From> struct cast_retty_impl<To, From *> {
  using ret_type = To *;
};

template <class To, class From> struct cast_retty_impl<To, const From *> {
  using ret_type = const To *;
};

template <class To, class From> struct cast_retty_impl<To, const From *const> {
  using ret_type = const To *;
};

template <class To, class From>
struct cast_retty_impl<To, std::unique_ptr<From>> {
private:
  using PointerType = typename cast_retty_impl<To, From *>::ret_type;
  using ResultType = std::remove_pointer_t<PointerType>;

public:
  using ret_type = std::unique_ptr<ResultType>;
};

template <class To, class From, class SimpleFrom> struct cast_retty_wrap {



  using ret_type = typename cast_retty<To, SimpleFrom>::ret_type;
};

template <class To, class FromTy> struct cast_retty_wrap<To, FromTy, FromTy> {

  using ret_type = typename cast_retty_impl<To, FromTy>::ret_type;
};

template <class To, class From> struct cast_retty {
  using ret_type = typename cast_retty_wrap<
      To, From, typename simplify_type<From>::SimpleType>::ret_type;
};
# 202 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <class To, class From, class SimpleFrom> struct cast_convert_val {

  static typename cast_retty<To, From>::ret_type doit(const From &Val) {
    return cast_convert_val<To, SimpleFrom,
                            typename simplify_type<SimpleFrom>::SimpleType>::
        doit(simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val)));
  }
};

template <class To, class FromTy> struct cast_convert_val<To, FromTy, FromTy> {

  static typename cast_retty<To, FromTy>::ret_type doit(const FromTy &Val) {
    return *(std::remove_reference_t<typename cast_retty<To, FromTy>::ret_type>
                 *)&const_cast<FromTy &>(Val);
  }
};

template <class To, class FromTy>
struct cast_convert_val<To, FromTy *, FromTy *> {

  static typename cast_retty<To, FromTy *>::ret_type doit(const FromTy *Val) {
    return (typename cast_retty<To, FromTy *>::ret_type) const_cast<FromTy *>(
        Val);
  }
};





template <class X> struct is_simple_type {
  static const bool value =
      std::is_same_v<X, typename simplify_type<X>::SimpleType>;
};
# 252 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enable = void>
struct CastIsPossible {
  static inline bool isPossible(const From &f) {
    return isa_impl_wrap<
        To, const From,
        typename simplify_type<const From>::SimpleType>::doit(f);
  }
};





template <typename To, typename From>
struct CastIsPossible<To, std::optional<From>> {
  static inline bool isPossible(const std::optional<From> &f) {
    (__builtin_expect(!(f && "CastIsPossible::isPossible called on a nullopt!"), 0) ? __assert_rtn(__func__, "Casting.h", 268, "f && \"CastIsPossible::isPossible called on a nullopt!\"") : (void)0);
    return isa_impl_wrap<
        To, const From,
        typename simplify_type<const From>::SimpleType>::doit(*f);
  }
};



template <typename To, typename From>
struct CastIsPossible<To, From, std::enable_if_t<std::is_base_of_v<To, From>>> {
  static inline bool isPossible(const From &f) { return true; }
};
# 301 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To> struct NullableValueCastFailed {
  static To castFailed() { return To(nullptr); }
};




template <typename To, typename From, typename Derived>
struct DefaultDoCastIfPossible {
  static To doCastIfPossible(From f) {
    if (!Derived::isPossible(f))
      return Derived::castFailed();
    return Derived::doCast(f);
  }
};

namespace detail {


template <typename OptionalDerived, typename Default>
using SelfType = std::conditional_t<std::is_same_v<OptionalDerived, void>,
                                    Default, OptionalDerived>;
}




template <typename To, typename From, typename Derived = void>
struct ValueFromPointerCast
    : public CastIsPossible<To, From *>,
      public NullableValueCastFailed<To>,
      public DefaultDoCastIfPossible<
          To, From *,
          detail::SelfType<Derived, ValueFromPointerCast<To, From>>> {
  static inline To doCast(From *f) { return To(f); }
};





template <typename To, typename From, typename Derived = void>
struct UniquePtrCast : public CastIsPossible<To, From *> {
  using Self = detail::SelfType<Derived, UniquePtrCast<To, From>>;
  using CastResultType = std::unique_ptr<
      std::remove_reference_t<typename cast_retty<To, From>::ret_type>>;

  static inline CastResultType doCast(std::unique_ptr<From> &&f) {
    return CastResultType((typename CastResultType::element_type *)f.release());
  }

  static inline CastResultType castFailed() { return CastResultType(nullptr); }

  static inline CastResultType doCastIfPossible(std::unique_ptr<From> &f) {
    if (!Self::isPossible(f.get()))
      return castFailed();
    return doCast(std::move(f));
  }
};




template <typename To, typename From, typename Derived = void>
struct OptionalValueCast
    : public CastIsPossible<To, From>,
      public DefaultDoCastIfPossible<
          std::optional<To>, From,
          detail::SelfType<Derived, OptionalValueCast<To, From>>> {
  static inline std::optional<To> castFailed() { return std::optional<To>{}; }

  static inline std::optional<To> doCast(const From &f) { return To(f); }
};
# 387 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename ForwardTo>
struct ConstStrippingForwardingCast {

  using DecayedFrom = std::remove_cv_t<std::remove_pointer_t<From>>;

  using NonConstFrom =
      std::conditional_t<std::is_pointer_v<From>, DecayedFrom *, DecayedFrom &>;

  static inline bool isPossible(const From &f) {
    return ForwardTo::isPossible(const_cast<NonConstFrom>(f));
  }

  static inline decltype(auto) castFailed() { return ForwardTo::castFailed(); }

  static inline decltype(auto) doCast(const From &f) {
    return ForwardTo::doCast(const_cast<NonConstFrom>(f));
  }

  static inline decltype(auto) doCastIfPossible(const From &f) {
    return ForwardTo::doCastIfPossible(const_cast<NonConstFrom>(f));
  }
};
# 422 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename ForwardTo>
struct ForwardToPointerCast {
  static inline bool isPossible(const From &f) {
    return ForwardTo::isPossible(&f);
  }

  static inline decltype(auto) doCast(const From &f) {
    return *ForwardTo::doCast(&f);
  }
};
# 475 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enable = void>
struct CastInfo : public CastIsPossible<To, From> {
  using Self = CastInfo<To, From, Enable>;

  using CastReturnType = typename cast_retty<To, From>::ret_type;

  static inline CastReturnType doCast(const From &f) {
    return cast_convert_val<
        To, From,
        typename simplify_type<From>::SimpleType>::doit(const_cast<From &>(f));
  }




  static inline CastReturnType castFailed() { return CastReturnType(nullptr); }

  static inline CastReturnType doCastIfPossible(const From &f) {
    if (!Self::isPossible(f))
      return castFailed();
    return doCast(f);
  }
};




template <typename To, typename From>
struct CastInfo<To, From, std::enable_if_t<!is_simple_type<From>::value>> {
  using Self = CastInfo<To, From>;
  using SimpleFrom = typename simplify_type<From>::SimpleType;
  using SimplifiedSelf = CastInfo<To, SimpleFrom>;

  static inline bool isPossible(From &f) {
    return SimplifiedSelf::isPossible(
        simplify_type<From>::getSimplifiedValue(f));
  }

  static inline decltype(auto) doCast(From &f) {
    return SimplifiedSelf::doCast(simplify_type<From>::getSimplifiedValue(f));
  }

  static inline decltype(auto) castFailed() {
    return SimplifiedSelf::castFailed();
  }

  static inline decltype(auto) doCastIfPossible(From &f) {
    return SimplifiedSelf::doCastIfPossible(
        simplify_type<From>::getSimplifiedValue(f));
  }
};






template <typename To, typename From>
struct CastInfo<To, std::unique_ptr<From>> : public UniquePtrCast<To, From> {};




template <typename To, typename From>
struct CastInfo<To, std::optional<From>> : public OptionalValueCast<To, From> {
};






template <typename To, typename From>
[[nodiscard]] inline bool isa(const From &Val) {
  return CastInfo<To, const From>::isPossible(Val);
}

template <typename First, typename Second, typename... Rest, typename From>
[[nodiscard]] inline bool isa(const From &Val) {
  return isa<First>(Val) || isa<Second, Rest...>(Val);
}
# 564 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(const From &Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, const From>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(From &Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 572, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, From>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(From *Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, From *>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(std::unique_ptr<From> &&Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 584, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, std::unique_ptr<From>>::doCast(std::move(Val));
}





template <typename T>
constexpr bool IsNullable =
    std::is_pointer_v<T> || std::is_constructible_v<T, std::nullptr_t>;







template <typename T, typename Enable = void> struct ValueIsPresent {
  using UnwrappedType = T;
  static inline bool isPresent(const T &t) { return true; }
  static inline decltype(auto) unwrapValue(T &t) { return t; }
};


template <typename T> struct ValueIsPresent<std::optional<T>> {
  using UnwrappedType = T;
  static inline bool isPresent(const std::optional<T> &t) {
    return t.has_value();
  }
  static inline decltype(auto) unwrapValue(std::optional<T> &t) { return *t; }
};



template <typename T>
struct ValueIsPresent<T, std::enable_if_t<IsNullable<T>>> {
  using UnwrappedType = T;
  static inline bool isPresent(const T &t) { return t != T(nullptr); }
  static inline decltype(auto) unwrapValue(T &t) { return t; }
};

namespace detail {


template <typename T> inline bool isPresent(const T &t) {
  return ValueIsPresent<typename simplify_type<T>::SimpleType>::isPresent(
      simplify_type<T>::getSimplifiedValue(const_cast<T &>(t)));
}


template <typename T> inline decltype(auto) unwrapValue(T &t) {
  return ValueIsPresent<T>::unwrapValue(t);
}
}
# 648 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(const From &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, const From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 656, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, From *>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr<From> &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 668, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, std::unique_ptr<From>>::doCastIfPossible(Val);
}



template <typename... X, class Y>
[[nodiscard]] inline bool isa_and_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return false;
  return isa<X...>(Val);
}

template <typename... X, class Y>
[[nodiscard]] inline bool isa_and_nonnull(const Y &Val) {
  return isa_and_present<X...>(Val);
}



template <class X, class Y>
[[nodiscard]] inline auto cast_if_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, const Y>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 692, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 699, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y *Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y *>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 706, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y>
[[nodiscard]] inline auto cast_if_present(std::unique_ptr<Y> &&Val) {
  if (!detail::isPresent(Val))
    return UniquePtrCast<X, Y>::castFailed();
  return UniquePtrCast<X, Y>::doCast(std::move(Val));
}




template <class X, class Y> auto cast_or_null(const Y &Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(Y &Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(Y *Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(std::unique_ptr<Y> &&Val) {
  return cast_if_present<X>(std::move(Val));
}



template <class X, class Y> auto dyn_cast_if_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, const Y>::castFailed();
  return CastInfo<X, const Y>::doCastIfPossible(detail::unwrapValue(Val));
}

template <class X, class Y> auto dyn_cast_if_present(Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y>::castFailed();
  return CastInfo<X, Y>::doCastIfPossible(detail::unwrapValue(Val));
}

template <class X, class Y> auto dyn_cast_if_present(Y *Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y *>::castFailed();
  return CastInfo<X, Y *>::doCastIfPossible(detail::unwrapValue(Val));
}




template <class X, class Y> auto dyn_cast_or_null(const Y &Val) {
  return dyn_cast_if_present<X>(Val);
}

template <class X, class Y> auto dyn_cast_or_null(Y &Val) {
  return dyn_cast_if_present<X>(Val);
}

template <class X, class Y> auto dyn_cast_or_null(Y *Val) {
  return dyn_cast_if_present<X>(Val);
}






template <class X, class Y>
[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
unique_dyn_cast(std::unique_ptr<Y> &Val) {
  if (!isa<X>(Val))
    return nullptr;
  return cast<X>(std::move(Val));
}

template <class X, class Y>
[[nodiscard]] inline auto unique_dyn_cast(std::unique_ptr<Y> &&Val) {
  return unique_dyn_cast<X, Y>(Val);
}



template <class X, class Y>
[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
unique_dyn_cast_or_null(std::unique_ptr<Y> &Val) {
  if (!Val)
    return nullptr;
  return unique_dyn_cast<X, Y>(Val);
}

template <class X, class Y>
[[nodiscard]] inline auto unique_dyn_cast_or_null(std::unique_ptr<Y> &&Val) {
  return unique_dyn_cast_or_null<X, Y>(Val);
}
# 813 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
namespace detail {
template <typename... Types> struct IsaCheckPredicate {
  template <typename T> [[nodiscard]] bool operator()(const T &Val) const {
    return isa<Types...>(Val);
  }
};

template <typename... Types> struct IsaAndPresentCheckPredicate {
  template <typename T> [[nodiscard]] bool operator()(const T &Val) const {
    return isa_and_present<Types...>(Val);
  }
};
}
# 835 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename... Types>
inline constexpr detail::IsaCheckPredicate<Types...> IsaPred{};
# 846 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename... Types>
inline constexpr detail::IsaAndPresentCheckPredicate<Types...>
    IsaAndPresentPred{};

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h" 2
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 2





namespace llvm {
# 55 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h"
template<class T>
class ErrorOr {
  template <class OtherT> friend class ErrorOr;

  static constexpr bool isRef = std::is_reference_v<T>;

  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;

public:
  using storage_type = std::conditional_t<isRef, wrap, T>;

private:
  using reference = std::remove_reference_t<T> &;
  using const_reference = const std::remove_reference_t<T> &;
  using pointer = std::remove_reference_t<T> *;
  using const_pointer = const std::remove_reference_t<T> *;

public:
  template <class E>
  ErrorOr(E ErrorCode,
          std::enable_if_t<std::is_error_code_enum<E>::value ||
                               std::is_error_condition_enum<E>::value,
                           void *> = nullptr)
      : HasError(true) {
    new (getErrorStorage()) std::error_code(make_error_code(ErrorCode));
  }

  ErrorOr(std::error_code EC) : HasError(true) {
    new (getErrorStorage()) std::error_code(EC);
  }

  template <class OtherT>
  ErrorOr(OtherT &&Val,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr)
      : HasError(false) {
    new (getStorage()) storage_type(std::forward<OtherT>(Val));
  }

  ErrorOr(const ErrorOr &Other) {
    copyConstruct(Other);
  }

  template <class OtherT>
  ErrorOr(const ErrorOr<OtherT> &Other,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr) {
    copyConstruct(Other);
  }

  template <class OtherT>
  explicit ErrorOr(
      const ErrorOr<OtherT> &Other,
      std::enable_if_t<!std::is_convertible_v<OtherT, const T &>> * = nullptr) {
    copyConstruct(Other);
  }

  ErrorOr(ErrorOr &&Other) {
    moveConstruct(std::move(Other));
  }

  template <class OtherT>
  ErrorOr(ErrorOr<OtherT> &&Other,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr) {
    moveConstruct(std::move(Other));
  }



  template <class OtherT>
  explicit ErrorOr(
      ErrorOr<OtherT> &&Other,
      std::enable_if_t<!std::is_convertible_v<OtherT, T>> * = nullptr) {
    moveConstruct(std::move(Other));
  }

  ErrorOr &operator=(const ErrorOr &Other) {
    copyAssign(Other);
    return *this;
  }

  ErrorOr &operator=(ErrorOr &&Other) {
    moveAssign(std::move(Other));
    return *this;
  }

  ~ErrorOr() {
    if (!HasError)
      getStorage()->~storage_type();
  }


  explicit operator bool() const {
    return !HasError;
  }

  reference get() { return *getStorage(); }
  const_reference get() const { return const_cast<ErrorOr<T> *>(this)->get(); }

  std::error_code getError() const {
    return HasError ? *getErrorStorage() : std::error_code();
  }

  pointer operator ->() {
    return toPointer(getStorage());
  }

  const_pointer operator->() const { return toPointer(getStorage()); }

  reference operator *() {
    return *getStorage();
  }

  const_reference operator*() const { return *getStorage(); }

private:
  template <class OtherT>
  void copyConstruct(const ErrorOr<OtherT> &Other) {
    if (!Other.HasError) {

      HasError = false;
      new (getStorage()) storage_type(*Other.getStorage());
    } else {

      HasError = true;
      new (getErrorStorage()) std::error_code(Other.getError());
    }
  }

  template <class T1>
  static bool compareThisIfSameType(const T1 &a, const T1 &b) {
    return &a == &b;
  }

  template <class T1, class T2>
  static bool compareThisIfSameType(const T1 &, const T2 &) {
    return false;
  }

  template <class OtherT>
  void copyAssign(const ErrorOr<OtherT> &Other) {
    if (compareThisIfSameType(*this, Other))
      return;

    this->~ErrorOr();
    new (this) ErrorOr(Other);
  }

  template <class OtherT>
  void moveConstruct(ErrorOr<OtherT> &&Other) {
    if (!Other.HasError) {

      HasError = false;
      new (getStorage()) storage_type(std::move(*Other.getStorage()));
    } else {

      HasError = true;
      new (getErrorStorage()) std::error_code(Other.getError());
    }
  }

  template <class OtherT>
  void moveAssign(ErrorOr<OtherT> &&Other) {
    if (compareThisIfSameType(*this, Other))
      return;

    this->~ErrorOr();
    new (this) ErrorOr(std::move(Other));
  }

  pointer toPointer(pointer Val) {
    return Val;
  }

  const_pointer toPointer(const_pointer Val) const { return Val; }

  pointer toPointer(wrap *Val) {
    return &Val->get();
  }

  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }

  storage_type *getStorage() {
    (__builtin_expect(!(!HasError && "Cannot get value when an error exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 236, "!HasError && \"Cannot get value when an error exists!\"") : (void)0);
    return &TStorage;
  }

  const storage_type *getStorage() const {
    (__builtin_expect(!(!HasError && "Cannot get value when an error exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 241, "!HasError && \"Cannot get value when an error exists!\"") : (void)0);
    return &TStorage;
  }

  std::error_code *getErrorStorage() {
    (__builtin_expect(!(HasError && "Cannot get error when a value exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 246, "HasError && \"Cannot get error when a value exists!\"") : (void)0);
    return &ErrorStorage;
  }

  const std::error_code *getErrorStorage() const {
    (__builtin_expect(!(HasError && "Cannot get error when a value exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 251, "HasError && \"Cannot get error when a value exists!\"") : (void)0);
    return &ErrorStorage;
  }

  union {
    storage_type TStorage;
    std::error_code ErrorStorage;
  };
  bool HasError : 1;
};

template <class T, class E>
std::enable_if_t<std::is_error_code_enum<E>::value ||
                     std::is_error_condition_enum<E>::value,
                 bool>
operator==(const ErrorOr<T> &Err, E Code) {
  return Err.getError() == Code;
}

}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBufferRef.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBufferRef.h"
namespace llvm {

class MemoryBuffer;

class MemoryBufferRef {
  StringRef Buffer;
  StringRef Identifier;

public:
  MemoryBufferRef() = default;
  __attribute__((visibility("default"))) MemoryBufferRef(const MemoryBuffer &Buffer);
  MemoryBufferRef(StringRef Buffer, StringRef Identifier)
      : Buffer(Buffer), Identifier(Identifier) {}

  StringRef getBuffer() const { return Buffer; }
  StringRef getBufferIdentifier() const { return Identifier; }

  const char *getBufferStart() const { return Buffer.begin(); }
  const char *getBufferEnd() const { return Buffer.end(); }
  size_t getBufferSize() const { return Buffer.size(); }


  friend bool operator==(const MemoryBufferRef &LHS,
                         const MemoryBufferRef &RHS) {
    return LHS.Buffer.begin() == RHS.Buffer.begin() &&
           LHS.Buffer.end() == RHS.Buffer.end() &&
           LHS.Identifier.begin() == RHS.Identifier.begin() &&
           LHS.Identifier.end() == RHS.Identifier.end();
  }

  friend bool operator!=(const MemoryBufferRef &LHS,
                         const MemoryBufferRef &RHS) {
    return !(LHS == RHS);
  }
};

}
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2




namespace llvm {
namespace sys {
namespace fs {





using file_t = int;

}
}
# 52 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
class __attribute__((visibility("default"))) MemoryBuffer {
  const char *BufferStart;
  const char *BufferEnd;

protected:
  MemoryBuffer() = default;

  void init(const char *BufStart, const char *BufEnd,
            bool RequiresNullTerminator);

public:
  MemoryBuffer(const MemoryBuffer &) = delete;
  MemoryBuffer &operator=(const MemoryBuffer &) = delete;
  virtual ~MemoryBuffer();

  const char *getBufferStart() const { return BufferStart; }
  const char *getBufferEnd() const { return BufferEnd; }
  size_t getBufferSize() const { return BufferEnd-BufferStart; }

  StringRef getBuffer() const {
    return StringRef(BufferStart, getBufferSize());
  }



  virtual StringRef getBufferIdentifier() const { return "Unknown buffer"; }






  virtual void dontNeedIfMmap() {}
# 98 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFile(const Twine &Filename, bool IsText = false,
          bool RequiresNullTerminator = true, bool IsVolatile = false,
          std::optional<Align> Alignment = std::nullopt);




  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileAsStream(const Twine &Filename);




  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
                   int64_t Offset, bool IsVolatile = false,
                   std::optional<Align> Alignment = std::nullopt);
# 126 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
              bool RequiresNullTerminator = true, bool IsVolatile = false,
              std::optional<Align> Alignment = std::nullopt);



  static std::unique_ptr<MemoryBuffer>
  getMemBuffer(StringRef InputData, StringRef BufferName = "",
               bool RequiresNullTerminator = true);

  static std::unique_ptr<MemoryBuffer>
  getMemBuffer(MemoryBufferRef Ref, bool RequiresNullTerminator = true);



  static std::unique_ptr<MemoryBuffer>
  getMemBufferCopy(StringRef InputData, const Twine &BufferName = "");


  static ErrorOr<std::unique_ptr<MemoryBuffer>> getSTDIN();



  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileOrSTDIN(const Twine &Filename, bool IsText = false,
                 bool RequiresNullTerminator = true,
                 std::optional<Align> Alignment = std::nullopt);


  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
               bool IsVolatile = false,
               std::optional<Align> Alignment = std::nullopt);






  enum BufferKind {
    MemoryBuffer_Malloc,
    MemoryBuffer_MMap
  };



  virtual BufferKind getBufferKind() const = 0;

  MemoryBufferRef getMemBufferRef() const;
};





class WritableMemoryBuffer : public MemoryBuffer {
protected:
  WritableMemoryBuffer() = default;

public:
  using MemoryBuffer::getBuffer;
  using MemoryBuffer::getBufferEnd;
  using MemoryBuffer::getBufferStart;



  char *getBufferStart() {
    return const_cast<char *>(MemoryBuffer::getBufferStart());
  }
  char *getBufferEnd() {
    return const_cast<char *>(MemoryBuffer::getBufferEnd());
  }
  MutableArrayRef<char> getBuffer() {
    return {getBufferStart(), getBufferEnd()};
  }

  __attribute__((visibility("default"))) static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
  getFile(const Twine &Filename, bool IsVolatile = false,
          std::optional<Align> Alignment = std::nullopt);


  __attribute__((visibility("default"))) static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
               bool IsVolatile = false,
               std::optional<Align> Alignment = std::nullopt);







  __attribute__((visibility("default"))) static std::unique_ptr<WritableMemoryBuffer>
  getNewUninitMemBuffer(size_t Size, const Twine &BufferName = "",
                        std::optional<Align> Alignment = std::nullopt);




  __attribute__((visibility("default"))) static std::unique_ptr<WritableMemoryBuffer>
  getNewMemBuffer(size_t Size, const Twine &BufferName = "");

private:



  using MemoryBuffer::getFileAsStream;
  using MemoryBuffer::getFileOrSTDIN;
  using MemoryBuffer::getMemBuffer;
  using MemoryBuffer::getMemBufferCopy;
  using MemoryBuffer::getOpenFile;
  using MemoryBuffer::getOpenFileSlice;
  using MemoryBuffer::getSTDIN;
};





class WriteThroughMemoryBuffer : public MemoryBuffer {
protected:
  WriteThroughMemoryBuffer() = default;

public:
  using MemoryBuffer::getBuffer;
  using MemoryBuffer::getBufferEnd;
  using MemoryBuffer::getBufferStart;



  char *getBufferStart() {
    return const_cast<char *>(MemoryBuffer::getBufferStart());
  }
  char *getBufferEnd() {
    return const_cast<char *>(MemoryBuffer::getBufferEnd());
  }
  MutableArrayRef<char> getBuffer() {
    return {getBufferStart(), getBufferEnd()};
  }

  __attribute__((visibility("default"))) static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
  getFile(const Twine &Filename, int64_t FileSize = -1);


  __attribute__((visibility("default"))) static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset);

private:



  using MemoryBuffer::getFileAsStream;
  using MemoryBuffer::getFileOrSTDIN;
  using MemoryBuffer::getMemBuffer;
  using MemoryBuffer::getMemBufferCopy;
  using MemoryBuffer::getOpenFile;
  using MemoryBuffer::getOpenFileSlice;
  using MemoryBuffer::getSTDIN;
};


inline MemoryBuffer *unwrap(LLVMMemoryBufferRef P) { return reinterpret_cast<MemoryBuffer*>(P); } inline LLVMMemoryBufferRef wrap(const MemoryBuffer *P) { return reinterpret_cast<LLVMMemoryBufferRef>(const_cast<MemoryBuffer*>(P)); }

}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h" 2
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
namespace llvm {

class Duration;
class formatv_object_base;
class format_object_base;
class FormattedString;
class FormattedNumber;
class FormattedBytes;
template <class T> class [[nodiscard]] Expected;

namespace sys {
namespace fs {
enum FileAccess : unsigned;
enum OpenFlags : unsigned;
enum CreationDisposition : unsigned;
class FileLocker;
}
}





class __attribute__((visibility("default"))) raw_ostream {
public:

  enum class OStreamKind {
    OK_OStream,
    OK_FDStream,
    OK_SVecStream,
  };

private:
  OStreamKind Kind;
# 83 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  char *OutBufStart, *OutBufEnd, *OutBufCur;
  bool ColorEnabled = false;

  enum class BufferKind {
    Unbuffered = 0,
    InternalBuffer,
    ExternalBuffer
  } BufferMode;

public:

  enum class Colors {
    BLACK = 0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE,
    BRIGHT_BLACK,
    BRIGHT_RED,
    BRIGHT_GREEN,
    BRIGHT_YELLOW,
    BRIGHT_BLUE,
    BRIGHT_MAGENTA,
    BRIGHT_CYAN,
    BRIGHT_WHITE,
    SAVEDCOLOR,
    RESET,
  };

  static constexpr Colors BLACK = Colors::BLACK;
  static constexpr Colors RED = Colors::RED;
  static constexpr Colors GREEN = Colors::GREEN;
  static constexpr Colors YELLOW = Colors::YELLOW;
  static constexpr Colors BLUE = Colors::BLUE;
  static constexpr Colors MAGENTA = Colors::MAGENTA;
  static constexpr Colors CYAN = Colors::CYAN;
  static constexpr Colors WHITE = Colors::WHITE;
  static constexpr Colors BRIGHT_BLACK = Colors::BRIGHT_BLACK;
  static constexpr Colors BRIGHT_RED = Colors::BRIGHT_RED;
  static constexpr Colors BRIGHT_GREEN = Colors::BRIGHT_GREEN;
  static constexpr Colors BRIGHT_YELLOW = Colors::BRIGHT_YELLOW;
  static constexpr Colors BRIGHT_BLUE = Colors::BRIGHT_BLUE;
  static constexpr Colors BRIGHT_MAGENTA = Colors::BRIGHT_MAGENTA;
  static constexpr Colors BRIGHT_CYAN = Colors::BRIGHT_CYAN;
  static constexpr Colors BRIGHT_WHITE = Colors::BRIGHT_WHITE;
  static constexpr Colors SAVEDCOLOR = Colors::SAVEDCOLOR;
  static constexpr Colors RESET = Colors::RESET;

  explicit raw_ostream(bool unbuffered = false,
                       OStreamKind K = OStreamKind::OK_OStream)
      : Kind(K), BufferMode(unbuffered ? BufferKind::Unbuffered
                                       : BufferKind::InternalBuffer) {

    OutBufStart = OutBufEnd = OutBufCur = nullptr;
  }

  raw_ostream(const raw_ostream &) = delete;
  void operator=(const raw_ostream &) = delete;

  virtual ~raw_ostream();


  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }

  OStreamKind get_kind() const { return Kind; }
# 161 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual void reserveExtraSpace(uint64_t ExtraSize) { (void)ExtraSize; }



  void SetBuffered();


  void SetBufferSize(size_t Size) {
    flush();
    SetBufferAndMode(new char[Size], Size, BufferKind::InternalBuffer);
  }

  size_t GetBufferSize() const {


    if (BufferMode != BufferKind::Unbuffered && OutBufStart == nullptr)
      return preferred_buffer_size();


    return OutBufEnd - OutBufStart;
  }




  void SetUnbuffered() {
    flush();
    SetBufferAndMode(nullptr, 0, BufferKind::Unbuffered);
  }

  size_t GetNumBytesInBuffer() const {
    return OutBufCur - OutBufStart;
  }





  void flush() {
    if (OutBufCur != OutBufStart)
      flush_nonempty();
  }

  raw_ostream &operator<<(char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(unsigned char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(signed char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(StringRef Str) {

    size_t Size = Str.size();


    if (Size > (size_t)(OutBufEnd - OutBufCur))
      return write(Str.data(), Size);

    if (Size) {
      memcpy(OutBufCur, Str.data(), Size);
      OutBufCur += Size;
    }
    return *this;
  }
# 254 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  raw_ostream &operator<<(const char *Str) {



    return this->operator<<(StringRef(Str));
  }

  raw_ostream &operator<<(const std::string &Str) {

    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(const std::string_view &Str) {
    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
    return write(Str.data(), Str.size());
  }

  raw_ostream &operator<<(unsigned long N);
  raw_ostream &operator<<(long N);
  raw_ostream &operator<<(unsigned long long N);
  raw_ostream &operator<<(long long N);
  raw_ostream &operator<<(const void *P);

  raw_ostream &operator<<(unsigned int N) {
    return this->operator<<(static_cast<unsigned long>(N));
  }

  raw_ostream &operator<<(int N) {
    return this->operator<<(static_cast<long>(N));
  }

  raw_ostream &operator<<(double N);


  raw_ostream &write_hex(unsigned long long N);


  raw_ostream &operator<<(Colors C);


  using uuid_t = uint8_t[16];
  raw_ostream &write_uuid(const uuid_t UUID);



  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);

  raw_ostream &write(unsigned char C);
  raw_ostream &write(const char *Ptr, size_t Size);


  raw_ostream &operator<<(const format_object_base &Fmt);


  raw_ostream &operator<<(const FormattedString &);


  raw_ostream &operator<<(const FormattedNumber &);


  raw_ostream &operator<<(const formatv_object_base &);


  raw_ostream &operator<<(const FormattedBytes &);


  raw_ostream &indent(unsigned NumSpaces);


  raw_ostream &write_zeros(unsigned NumZeros);
# 335 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual raw_ostream &changeColor(enum Colors Color, bool Bold = false,
                                   bool BG = false);



  virtual raw_ostream &resetColor();


  virtual raw_ostream &reverseColor();




  virtual bool is_displayed() const { return false; }



  virtual bool has_colors() const { return is_displayed(); }



  virtual void enable_colors(bool enable) { ColorEnabled = enable; }

  bool colors_enabled() const { return ColorEnabled; }





private:
# 378 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual void write_impl(const char *Ptr, size_t Size) = 0;



  virtual uint64_t current_pos() const = 0;

protected:



  void SetBuffer(char *BufferStart, size_t Size) {
    SetBufferAndMode(BufferStart, Size, BufferKind::ExternalBuffer);
  }


  virtual size_t preferred_buffer_size() const;



  const char *getBufferStart() const { return OutBufStart; }




private:

  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);



  void flush_nonempty();



  void copy_to_buffer(const char *Ptr, size_t Size);



  bool prepare_colors();

  virtual void anchor();
};



template <typename OStream, typename T>
std::enable_if_t<!std::is_reference_v<OStream> &&
                     std::is_base_of_v<raw_ostream, OStream>,
                 OStream &&>
operator<<(OStream &&OS, const T &Value) {
  OS << Value;
  return std::move(OS);
}




class __attribute__((visibility("default"))) raw_pwrite_stream : public raw_ostream {
  virtual void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) = 0;
  void anchor() override;

public:
  explicit raw_pwrite_stream(bool Unbuffered = false,
                             OStreamKind K = OStreamKind::OK_OStream)
      : raw_ostream(Unbuffered, K) {}
  void pwrite(const char *Ptr, size_t Size, uint64_t Offset) {

    uint64_t Pos = tell();


    if (Pos)
      (__builtin_expect(!(Size + Offset <= Pos && "We don't support extending the stream"), 0) ? __assert_rtn(__func__, "raw_ostream.h", 449, "Size + Offset <= Pos && \"We don't support extending the stream\"") : (void)0);

    pwrite_impl(Ptr, Size, Offset);
  }
};







class __attribute__((visibility("default"))) raw_fd_ostream : public raw_pwrite_stream {
  int FD;
  bool ShouldClose;
  bool SupportsSeeking = false;
  bool IsRegularFile = false;
  mutable std::optional<bool> HasColors;



  raw_ostream *TiedStream = nullptr;







  std::error_code EC;

  uint64_t pos = 0;


  void write_impl(const char *Ptr, size_t Size) override;

  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;



  uint64_t current_pos() const override { return pos; }


  size_t preferred_buffer_size() const override;

  void anchor() override;

protected:

  void error_detected(std::error_code EC) { this->EC = EC; }


  int get_fd() const { return FD; }


  void inc_pos(uint64_t Delta) { pos += Delta; }

public:
# 515 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  raw_fd_ostream(StringRef Filename, std::error_code &EC);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::CreationDisposition Disp);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::FileAccess Access);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::OpenFlags Flags);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                 sys::fs::OpenFlags Flags);




  raw_fd_ostream(int fd, bool shouldClose, bool unbuffered = false,
                 OStreamKind K = OStreamKind::OK_OStream);

  ~raw_fd_ostream() override;



  void close();

  bool supportsSeeking() const { return SupportsSeeking; }

  bool isRegularFile() const { return IsRegularFile; }



  uint64_t seek(uint64_t off);

  bool is_displayed() const override;

  bool has_colors() const override;






  void tie(raw_ostream *TieTo) { TiedStream = TieTo; }

  std::error_code error() const { return EC; }





  bool has_error() const { return bool(EC); }
# 574 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  void clear_error() { EC = std::error_code(); }
# 596 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  [[nodiscard]] Expected<sys::fs::FileLocker> lock();
# 605 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  [[nodiscard]] Expected<sys::fs::FileLocker>
  tryLockFor(Duration const &Timeout);
};



__attribute__((visibility("default"))) raw_fd_ostream &outs();






__attribute__((visibility("default"))) raw_fd_ostream &errs();


__attribute__((visibility("default"))) raw_ostream &nulls();







class raw_fd_stream : public raw_fd_ostream {
public:



  __attribute__((visibility("default"))) raw_fd_stream(StringRef Filename, std::error_code &EC);

  __attribute__((visibility("default"))) raw_fd_stream(int fd, bool shouldClose);
# 647 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  __attribute__((visibility("default"))) ssize_t read(char *Ptr, size_t Size);


  __attribute__((visibility("default"))) static bool classof(const raw_ostream *OS);
};
# 662 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
class __attribute__((visibility("default"))) raw_string_ostream : public raw_ostream {
  std::string &OS;


  void write_impl(const char *Ptr, size_t Size) override;



  uint64_t current_pos() const override { return OS.size(); }

public:
  explicit raw_string_ostream(std::string &O) : OS(O) {
    SetUnbuffered();
  }




  std::string &str() { return OS; }

  void reserveExtraSpace(uint64_t ExtraSize) override {
    OS.reserve(tell() + ExtraSize);
  }
};






class __attribute__((visibility("default"))) raw_svector_ostream : public raw_pwrite_stream {
  SmallVectorImpl<char> &OS;


  void write_impl(const char *Ptr, size_t Size) override;

  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;


  uint64_t current_pos() const override;

public:




  explicit raw_svector_ostream(SmallVectorImpl<char> &O)
      : raw_pwrite_stream(false, raw_ostream::OStreamKind::OK_SVecStream),
        OS(O) {


    SetUnbuffered();
  }

  ~raw_svector_ostream() override = default;

  void flush() = delete;


  StringRef str() const { return StringRef(OS.data(), OS.size()); }
  SmallVectorImpl<char> &buffer() { return OS; }

  void reserveExtraSpace(uint64_t ExtraSize) override {
    OS.reserve(tell() + ExtraSize);
  }

  static bool classof(const raw_ostream *OS);
};


class __attribute__((visibility("default"))) raw_null_ostream : public raw_pwrite_stream {

  void write_impl(const char *Ptr, size_t size) override;
  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;



  uint64_t current_pos() const override;

public:
  explicit raw_null_ostream() = default;
  ~raw_null_ostream() override;
};

class __attribute__((visibility("default"))) buffer_ostream : public raw_svector_ostream {
  raw_ostream &OS;
  SmallVector<char, 0> Buffer;

  void anchor() override;

public:
  buffer_ostream(raw_ostream &OS) : raw_svector_ostream(Buffer), OS(OS) {}
  ~buffer_ostream() override { OS << str(); }
};

class __attribute__((visibility("default"))) buffer_unique_ostream : public raw_svector_ostream {
  std::unique_ptr<raw_ostream> OS;
  SmallVector<char, 0> Buffer;

  void anchor() override;

public:
  buffer_unique_ostream(std::unique_ptr<raw_ostream> OS)
      : raw_svector_ostream(Buffer), OS(std::move(OS)) {


    this->OS->SetUnbuffered();
  }
  ~buffer_unique_ostream() override { *OS << str(); }
};
# 782 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
struct indent {

  unsigned NumIndents;
  unsigned Scale;

  explicit indent(unsigned NumIndents, unsigned Scale = 1)
      : NumIndents(NumIndents), Scale(Scale) {}


  void operator+=(unsigned N) { NumIndents += N; }
  void operator-=(unsigned N) {
    (__builtin_expect(!(NumIndents >= N && "Indentation underflow"), 0) ? __assert_rtn(__func__, "raw_ostream.h", 793, "NumIndents >= N && \"Indentation underflow\"") : (void)0);
    NumIndents -= N;
  }
  indent operator+(unsigned N) const { return indent(NumIndents + N, Scale); }
  indent operator-(unsigned N) const {
    (__builtin_expect(!(NumIndents >= N && "Indentation undeflow"), 0) ? __assert_rtn(__func__, "raw_ostream.h", 798, "NumIndents >= N && \"Indentation undeflow\"") : (void)0);
    return indent(NumIndents - N, Scale);
  }
  indent &operator++() {
    ++NumIndents;
    return *this;
  }
  indent operator++(int) {
    indent Old = *this;
    ++NumIndents;
    return Old;
  }
  indent &operator--() {
    (__builtin_expect(!(NumIndents >= 1), 0) ? __assert_rtn(__func__, "raw_ostream.h", 811, "NumIndents >= 1") : (void)0);
    --NumIndents;
    return *this;
  }
  indent operator--(int) {
    indent Old = *this;
    (__builtin_expect(!(NumIndents >= 1), 0) ? __assert_rtn(__func__, "raw_ostream.h", 817, "NumIndents >= 1") : (void)0);
    --NumIndents;
    return Old;
  }
  indent &operator=(unsigned N) {
    NumIndents = N;
    return *this;
  }
};

inline raw_ostream &operator<<(raw_ostream &OS, const indent &Indent) {
  return OS.indent(Indent.NumIndents * Indent.Scale);
}

class Error;







__attribute__((visibility("default"))) Error writeToOutput(StringRef OutputFileName,
                             std::function<Error(raw_ostream &)> Write);

__attribute__((visibility("default"))) raw_ostream &operator<<(raw_ostream &OS, std::nullopt_t);

template <typename T, typename = decltype(std::declval<raw_ostream &>()
                                          << std::declval<const T &>())>
raw_ostream &operator<<(raw_ostream &OS, const std::optional<T> &O) {
  if (O)
    OS << *O;
  else
    OS << std::nullopt;
  return OS;
}

}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 1 3
# 593 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 1 3
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 2 3

#pragma clang diagnostic push
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class, class, class, class>
class map;
template <class, class, class, class>
class multimap;
template <class, class, class>
class set;
template <class, class, class>
class multiset;

template <class _Tp, class _Compare, class _Allocator>
class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
class __tree_const_iterator;

template <class _Pointer>
class __tree_end_node;
template <class _VoidPtr>
class __tree_node_base;
template <class _Tp, class _VoidPtr>
class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator>
class __map_node_destructor;
template <class _TreeIterator>
class __map_iterator;
template <class _TreeIterator>
class __map_const_iterator;
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __tree_is_left_child(_NodePtr __x) noexcept {
  return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned __tree_sub_invariant(_NodePtr __x) {
  if (__x == nullptr)
    return 1;


  if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
    return 0;

  if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
    return 0;

  if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
    return 0;

  if (!__x->__is_black_) {
    if (__x->__left_ && !__x->__left_->__is_black_)
      return 0;
    if (__x->__right_ && !__x->__right_->__is_black_)
      return 0;
  }
  unsigned __h = std::__tree_sub_invariant(__x->__left_);
  if (__h == 0)
    return 0;
  if (__h != std::__tree_sub_invariant(__x->__right_))
    return 0;
  return __h + __x->__is_black_;
}




template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __tree_invariant(_NodePtr __root) {
  if (__root == nullptr)
    return true;

  if (__root->__parent_ == nullptr)
    return false;
  if (!std::__tree_is_left_child(__root))
    return false;

  if (!__root->__is_black_)
    return false;

  return std::__tree_sub_invariant(__root) != 0;
}


template <class _NodePtr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodePtr __tree_min(_NodePtr __x) noexcept {
  ((void)0);
  while (__x->__left_ != nullptr)
    __x = __x->__left_;
  return __x;
}


template <class _NodePtr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodePtr __tree_max(_NodePtr __x) noexcept {
  ((void)0);
  while (__x->__right_ != nullptr)
    __x = __x->__right_;
  return __x;
}


template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodePtr __tree_next(_NodePtr __x) noexcept {
  ((void)0);
  if (__x->__right_ != nullptr)
    return std::__tree_min(__x->__right_);
  while (!std::__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _EndNodePtr __tree_next_iter(_NodePtr __x) noexcept {
  ((void)0);
  if (__x->__right_ != nullptr)
    return static_cast<_EndNodePtr>(std::__tree_min(__x->__right_));
  while (!std::__tree_is_left_child(__x))
    __x = __x->__parent_unsafe();
  return static_cast<_EndNodePtr>(__x->__parent_);
}



template <class _NodePtr, class _EndNodePtr>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodePtr __tree_prev_iter(_EndNodePtr __x) noexcept {
  ((void)0);
  if (__x->__left_ != nullptr)
    return std::__tree_max(__x->__left_);
  _NodePtr __xx = static_cast<_NodePtr>(__x);
  while (std::__tree_is_left_child(__xx))
    __xx = __xx->__parent_unsafe();
  return __xx->__parent_unsafe();
}


template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodePtr __tree_leaf(_NodePtr __x) noexcept {
  ((void)0);
  while (true) {
    if (__x->__left_ != nullptr) {
      __x = __x->__left_;
      continue;
    }
    if (__x->__right_ != nullptr) {
      __x = __x->__right_;
      continue;
    }
    break;
  }
  return __x;
}



template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree_left_rotate(_NodePtr __x) noexcept {
  ((void)0);
  ((void)0);
  _NodePtr __y = __x->__right_;
  __x->__right_ = __y->__left_;
  if (__x->__right_ != nullptr)
    __x->__right_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (std::__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__left_ = __x;
  __x->__set_parent(__y);
}



template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree_right_rotate(_NodePtr __x) noexcept {
  ((void)0);
  ((void)0);
  _NodePtr __y = __x->__left_;
  __x->__left_ = __y->__right_;
  if (__x->__left_ != nullptr)
    __x->__left_->__set_parent(__x);
  __y->__parent_ = __x->__parent_;
  if (std::__tree_is_left_child(__x))
    __x->__parent_->__left_ = __y;
  else
    __x->__parent_unsafe()->__right_ = __y;
  __y->__right_ = __x;
  __x->__set_parent(__y);
}
# 279 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept {
  ((void)0);
  ((void)0);
  __x->__is_black_ = __x == __root;
  while (__x != __root && !__x->__parent_unsafe()->__is_black_) {

    if (std::__tree_is_left_child(__x->__parent_unsafe())) {
      _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (!std::__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          std::__tree_left_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        std::__tree_right_rotate(__x);
        break;
      }
    } else {
      _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
      if (__y != nullptr && !__y->__is_black_) {
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = __x == __root;
        __y->__is_black_ = true;
      } else {
        if (std::__tree_is_left_child(__x)) {
          __x = __x->__parent_unsafe();
          std::__tree_right_rotate(__x);
        }
        __x = __x->__parent_unsafe();
        __x->__is_black_ = true;
        __x = __x->__parent_unsafe();
        __x->__is_black_ = false;
        std::__tree_left_rotate(__x);
        break;
      }
    }
  }
}






template <class _NodePtr>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree_remove(_NodePtr __root, _NodePtr __z) noexcept {
  ((void)0);
  ((void)0);
  ((void)0);




  _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ? __z : std::__tree_next(__z);

  _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

  _NodePtr __w = nullptr;

  if (__x != nullptr)
    __x->__parent_ = __y->__parent_;
  if (std::__tree_is_left_child(__y)) {
    __y->__parent_->__left_ = __x;
    if (__y != __root)
      __w = __y->__parent_unsafe()->__right_;
    else
      __root = __x;
  } else {
    __y->__parent_unsafe()->__right_ = __x;

    __w = __y->__parent_->__left_;
  }
  bool __removed_black = __y->__is_black_;


  if (__y != __z) {

    __y->__parent_ = __z->__parent_;
    if (std::__tree_is_left_child(__z))
      __y->__parent_->__left_ = __y;
    else
      __y->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __z->__left_;
    __y->__left_->__set_parent(__y);
    __y->__right_ = __z->__right_;
    if (__y->__right_ != nullptr)
      __y->__right_->__set_parent(__y);
    __y->__is_black_ = __z->__is_black_;
    if (__root == __z)
      __root = __y;
  }


  if (__removed_black && __root != nullptr) {
# 397 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
    if (__x != nullptr)
      __x->__is_black_ = true;
    else {





      while (true) {
        if (!std::__tree_is_left_child(__w))
        {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            std::__tree_left_rotate(__w->__parent_unsafe());


            if (__root == __w->__left_)
              __root = __w;

            __w = __w->__left_->__right_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (__x == __root || !__x->__is_black_) {
              __x->__is_black_ = true;
              break;
            }

            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;

          } else
          {
            if (__w->__right_ == nullptr || __w->__right_->__is_black_) {

              __w->__left_->__is_black_ = true;
              __w->__is_black_ = false;
              std::__tree_right_rotate(__w);


              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__right_->__is_black_ = true;
            std::__tree_left_rotate(__w->__parent_unsafe());
            break;
          }
        } else {
          if (!__w->__is_black_) {
            __w->__is_black_ = true;
            __w->__parent_unsafe()->__is_black_ = false;
            std::__tree_right_rotate(__w->__parent_unsafe());


            if (__root == __w->__right_)
              __root = __w;

            __w = __w->__right_->__left_;
          }

          if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
              (__w->__right_ == nullptr || __w->__right_->__is_black_)) {
            __w->__is_black_ = false;
            __x = __w->__parent_unsafe();

            if (!__x->__is_black_ || __x == __root) {
              __x->__is_black_ = true;
              break;
            }

            __w = std::__tree_is_left_child(__x) ? __x->__parent_unsafe()->__right_ : __x->__parent_->__left_;

          } else
          {
            if (__w->__left_ == nullptr || __w->__left_->__is_black_) {

              __w->__right_->__is_black_ = true;
              __w->__is_black_ = false;
              std::__tree_left_rotate(__w);


              __w = __w->__parent_unsafe();
            }

            __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
            __w->__parent_unsafe()->__is_black_ = true;
            __w->__left_->__is_black_ = true;
            std::__tree_right_rotate(__w->__parent_unsafe());
            break;
          }
        }
      }
    }
  }
}



template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class... _Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<__remove_cvref_t<_One> > {};

template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static key_type const& __get_key(_Tp const& __v) { return __v; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type const& __get_value(__node_value_type const& __v) { return __v; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type* __get_ptr(__node_value_type& __n) { return std::addressof(__n); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type&& __move(__node_value_type& __v) { return std::move(__v); }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static key_type const& __get_key(__node_value_type const& __t) {
    return __t.__get_value().first;
  }

  template <class _Up, __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static key_type const& __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type const& __get_value(__node_value_type const& __t) {
    return __t.__get_value();
  }

  template <class _Up, __enable_if_t<__is_same_uncvref<_Up, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type const& __get_value(_Up& __t) {
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::addressof(__n.__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) { return __v.__move(); }
};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef __rebind_pointer_t<_VoidPtr, __node_base_type> __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef __rebind_pointer_t<_VoidPtr, __end_node_type> __end_node_pointer;



  typedef __conditional_t< is_pointer<__end_node_pointer>::value, __end_node_pointer, __node_base_pointer>
      __parent_pointer;


private:
  static_assert(is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value,
                "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>, bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef __rebind_pointer_t<_AllocPtr, _Mv> __map_value_type_pointer;
  typedef __rebind_pointer_t<_AllocPtr, const _Mv> __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>, __tree_key_value_types<_Tp>, __tree_map_pointer_types<_Tp, _VoidPtr> {
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;

public:
  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef __rebind_pointer_t<_VoidPtr, __node_value_type> __node_value_type_pointer;
  typedef __rebind_pointer_t<_VoidPtr, const __node_value_type> __const_node_value_type_pointer;



  typedef __conditional_t< is_pointer<__node_pointer>::value, typename __base::__end_node_pointer, __node_pointer>
      __iter_pointer;


private:
  static_assert(!is_const<__node_type>::value, "_NodePtr should never be a pointer to const");
  static_assert(is_same<__rebind_pointer_t<_VoidPtr, __node_type>, _NodePtr>::value,
                "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef __rebind_pointer_t<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> > _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer>
class __tree_end_node {
public:
  typedef _Pointer pointer;
  pointer __left_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node_base : public __tree_node_base_types<_VoidPtr>::__end_node_type {
  typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
  typedef typename _NodeBaseTypes::__node_base_pointer pointer;
  typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

  pointer __right_;
  __parent_pointer __parent_;
  bool __is_black_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer __parent_unsafe() const { return static_cast<pointer>(__parent_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __set_parent(pointer __p) { __parent_ = static_cast<__parent_pointer>(__p); }

  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node : public __tree_node_base<_VoidPtr> {
public:
  typedef _Tp __node_value_type;

  __node_value_type __value_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _Tp& __get_value() { return __value_; }

  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};

template <class _Allocator>
class __tree_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  typedef __tree_node_types<pointer> _NodeTypes;
  allocator_type& __na_;

public:
  bool __value_constructed;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_node_destructor(const __tree_node_destructor&) = default;
  __tree_node_destructor& operator=(const __tree_node_destructor&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
      : __na_(__na),
        __value_constructed(__val) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator()(pointer __p) noexcept {
    if (__value_constructed)
      __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }

  template <class>
  friend class __map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;
template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc> : __tree_node_destructor<_Alloc> {
  using __tree_node_destructor<_Alloc>::__tree_node_destructor;
};


template <class _Tp, class _NodePtr, class _DiffType>
class __tree_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef _NodePtr __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef value_type& reference;
  typedef typename _NodeTypes::__node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_iterator() noexcept

      : __ptr_(nullptr)

  {
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __get_np()->__value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__get_np()->__value_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_iterator& operator++() {
    __ptr_ = static_cast<__iter_pointer>(
        std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_iterator operator++(int) {
    __tree_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_iterator& operator--() {
    __ptr_ = static_cast<__iter_pointer>(
        std::__tree_prev_iter<__node_base_pointer>(static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_iterator operator--(int) {
    __tree_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __tree_iterator& __x, const __tree_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
  template <class, class, class>
  friend class __tree;
  template <class, class, class>
  friend class __tree_const_iterator;
  template <class>
  friend class __map_iterator;
  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class, class, class>
  friend class set;
  template <class, class, class>
  friend class multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __tree_const_iterator {
  typedef __tree_node_types<_NodePtr> _NodeTypes;
  typedef typename _NodeTypes::__node_pointer __node_pointer;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
  typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;
  typedef pointer_traits<__node_pointer> __pointer_traits;

  __iter_pointer __ptr_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef _Tp value_type;
  typedef _DiffType difference_type;
  typedef const value_type& reference;
  typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator() noexcept

      : __ptr_(nullptr)

  {
  }

private:
  typedef __tree_iterator<value_type, __node_pointer, difference_type> __non_const_iterator;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator(__non_const_iterator __p) noexcept : __ptr_(__p.__ptr_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __get_np()->__value_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__get_np()->__value_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator& operator++() {
    __ptr_ = static_cast<__iter_pointer>(
        std::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator operator++(int) {
    __tree_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator& operator--() {
    __ptr_ = static_cast<__iter_pointer>(
        std::__tree_prev_iter<__node_base_pointer>(static_cast<__end_node_pointer>(__ptr_)));
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree_const_iterator operator--(int) {
    __tree_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y) {
    return !(__x == __y);
  }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree_const_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree_const_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

  template <class, class, class>
  friend class __tree;
  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class, class, class>
  friend class set;
  template <class, class, class>
  friend class multiset;
  template <class>
  friend class __map_const_iterator;
};

template <class _Tp, class _Compare>

__attribute__((__diagnose_if__(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree {
public:
  typedef _Tp value_type;
  typedef _Compare value_compare;
  typedef _Allocator allocator_type;

private:
  typedef allocator_traits<allocator_type> __alloc_traits;
  typedef typename __make_tree_node_types<value_type, typename __alloc_traits::void_pointer>::type _NodeTypes;
  typedef typename _NodeTypes::key_type key_type;

public:
  typedef typename _NodeTypes::__node_value_type __node_value_type;
  typedef typename _NodeTypes::__container_value_type __container_value_type;

  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;

public:
  typedef typename _NodeTypes::__void_pointer __void_pointer;

  typedef typename _NodeTypes::__node_type __node;
  typedef typename _NodeTypes::__node_pointer __node_pointer;

  typedef typename _NodeTypes::__node_base_type __node_base;
  typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

  typedef typename _NodeTypes::__end_node_type __end_node_t;
  typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

  typedef typename _NodeTypes::__parent_pointer __parent_pointer;
  typedef typename _NodeTypes::__iter_pointer __iter_pointer;

  typedef __rebind_alloc<__alloc_traits, __node> __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;

private:



  static_assert(is_same<__node_pointer, typename __node_traits::pointer>::value,
                "Allocator does not rebind pointers in a sane manner.");
  typedef __rebind_alloc<__node_traits, __node_base> __node_base_allocator;
  typedef allocator_traits<__node_base_allocator> __node_base_traits;
  static_assert(is_same<__node_base_pointer, typename __node_base_traits::pointer>::value,
                "Allocator does not rebind pointers in a sane manner.");

private:
  __iter_pointer __begin_node_;
  __compressed_pair<__end_node_t, __node_allocator> __pair1_;
  __compressed_pair<size_type, value_compare> __pair3_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __iter_pointer __end_node() noexcept {
    return static_cast<__iter_pointer>(pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first()));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __iter_pointer __end_node() const noexcept {
    return static_cast<__iter_pointer>(
        pointer_traits<__end_node_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first())));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_allocator& __node_alloc() noexcept { return __pair1_.second(); }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const __node_allocator& __node_alloc() const noexcept { return __pair1_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __iter_pointer& __begin_node() noexcept { return __begin_node_; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const __iter_pointer& __begin_node() const noexcept { return __begin_node_; }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type __alloc() const noexcept { return allocator_type(__node_alloc()); }

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type& size() noexcept { return __pair3_.first(); }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const size_type& size() const noexcept { return __pair3_.first(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare& value_comp() noexcept { return __pair3_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const value_compare& value_comp() const noexcept { return __pair3_.second(); }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __root() const noexcept {
    return static_cast<__node_pointer>(__end_node()->__left_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer* __root_ptr() const noexcept {
    return std::addressof(__end_node()->__left_);
  }

  typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
  typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree(const value_compare& __comp) noexcept(is_nothrow_default_constructible<__node_allocator>::value&& is_nothrow_copy_constructible<value_compare>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __tree(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree(const value_compare& __comp, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree(const __tree& __t);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree& operator=(const __tree& __t);
  template <class _ForwardIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __assign_multi(_InputIterator __first, _InputIterator __last);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree(__tree&& __t) noexcept(is_nothrow_move_constructible<__node_allocator>::value&& is_nothrow_move_constructible<value_compare>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree(__tree&& __t, const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __tree& operator=(__tree&& __t) noexcept(__node_traits::propagate_on_container_move_assignment::value&& is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~__tree();

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return iterator(__begin_node()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return const_iterator(__begin_node()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return iterator(__end_node()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return const_iterator(__end_node()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept {
    return std::min<size_type>(__node_traits::max_size(__node_alloc()), numeric_limits<difference_type >::max());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(__tree& __t)




      noexcept(__is_nothrow_swappable_v<value_compare>);


  template <class _Key, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique_key_args(_Key const&, _Args&&... __args);
  template <class _Key, class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_multi(_Args&&... __args);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique(_Pp&& __x) {
    return __emplace_unique_extract_key(std::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First,
            class _Second,
            __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique(_First&& __f, _Second&& __s) {
    return __emplace_unique_key_args(__f, std::forward<_First>(__f), std::forward<_Second>(__s));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique(_Args&&... __args) {
    return __emplace_unique_impl(std::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
    return __emplace_unique_impl(std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
    return __emplace_unique_key_args(__x, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
    return __emplace_unique_key_args(__x.first, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
    return __emplace_hint_unique_extract_key(__p, std::forward<_Pp>(__x), __can_extract_key<_Pp, key_type>());
  }

  template <class _First,
            class _Second,
            __enable_if_t<__can_extract_map_key<_First, key_type, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
    return __emplace_hint_unique_key_args(__p, __f, std::forward<_First>(__f), std::forward<_Second>(__s)).first;
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
    return __emplace_hint_unique_impl(__p, std::forward<_Args>(__args)...);
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
    return __emplace_hint_unique_impl(__p, std::forward<_Pp>(__x));
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
    return __emplace_hint_unique_key_args(__p, __x, std::forward<_Pp>(__x)).first;
  }

  template <class _Pp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator
  __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
    return __emplace_hint_unique_key_args(__p, __x.first, std::forward<_Pp>(__x)).first;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
    return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
    return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::move(__v)).first;
  }

  template <class _Vp, __enable_if_t<!is_same<__remove_const_ref_t<_Vp>, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> __insert_unique(_Vp&& __v) {
    return __emplace_unique(std::forward<_Vp>(__v));
  }

  template <class _Vp, __enable_if_t<!is_same<__remove_const_ref_t<_Vp>, __container_value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_unique(const_iterator __p, _Vp&& __v) {
    return __emplace_hint_unique(__p, std::forward<_Vp>(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_multi(__container_value_type&& __v) {
    return __emplace_multi(std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
    return __emplace_hint_multi(__p, std::move(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_multi(_Vp&& __v) {
    return __emplace_multi(std::forward<_Vp>(__v));
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_multi(const_iterator __p, _Vp&& __v) {
    return __emplace_hint_multi(__p, std::forward<_Vp>(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool>
  __node_assign_unique(const __container_value_type& __v, __node_pointer __dest);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __node_insert_multi(__node_pointer __nd);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __remove_node_pointer(__node_pointer) noexcept;


  template <class _NodeHandle, class _InsertReturnType>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);
  template <class _NodeHandle>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);
  template <class _Tree>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __node_handle_merge_unique(_Tree& __source);

  template <class _NodeHandle>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __node_handle_insert_multi(_NodeHandle&&);
  template <class _NodeHandle>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);
  template <class _Tree>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __node_handle_merge_multi(_Tree& __source);

  template <class _NodeHandle>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodeHandle __node_handle_extract(key_type const&);
  template <class _NodeHandle>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodeHandle __node_handle_extract(const_iterator);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type __erase_unique(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type __erase_multi(const _Key& __k);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
  __insert_node_at(__parent_pointer __parent, __node_base_pointer& __child, __node_base_pointer __new_node) noexcept;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const _Key& __v);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const _Key& __v) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type __count_unique(const _Key& __k) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type __count_multi(const _Key& __k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const _Key& __v) {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __lower_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const _Key& __v) const {
    return __lower_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator
  __lower_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const _Key& __v) {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __upper_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const _Key& __v) const {
    return __upper_bound(__v, __root(), __end_node());
  }
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator
  __upper_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result) const;
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> __equal_range_unique(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> __equal_range_unique(const _Key& __k) const;

  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> __equal_range_multi(const _Key& __k);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> __equal_range_multi(const _Key& __k) const;

  typedef __tree_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_holder remove(const_iterator __p) noexcept;

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer& __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer& __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer&
  __find_leaf(const_iterator __hint, __parent_pointer& __parent, const key_type& __v);


  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer& __find_equal(__parent_pointer& __parent, const _Key& __v);
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer& __find_equal(__parent_pointer& __parent, const _Key& __v) const {
    return const_cast<__tree*>(this)->__find_equal(__parent, __v);
  }
  template <class _Key>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_base_pointer&
  __find_equal(const_iterator __hint, __parent_pointer& __parent, __node_base_pointer& __dummy, const _Key& __v);

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_holder __construct_node(_Args&&... __args);


  __attribute__((__visibility__("hidden"))) void destroy(__node_pointer __nd) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __tree& __t) {
    __copy_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __tree& __t, true_type) {
    if (__node_alloc() != __t.__node_alloc())
      clear();
    __node_alloc() = __t.__node_alloc();
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __tree&, false_type) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(__tree& __t, false_type);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(__tree& __t, true_type) noexcept(is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__tree& __t)
      noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value) {

    __move_assign_alloc(__t, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__tree& __t, true_type)
      noexcept(is_nothrow_move_assignable<__node_allocator>::value) {
    __node_alloc() = std::move(__t.__node_alloc());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__tree&, false_type) noexcept {}

  struct _DetachedTreeCache {
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit _DetachedTreeCache(__tree* __t) noexcept
        : __t_(__t),
          __cache_root_(__detach_from_tree(__t)) {
      __advance();
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __get() const noexcept { return __cache_elem_; }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __advance() noexcept {
      __cache_elem_ = __cache_root_;
      if (__cache_root_) {
        __cache_root_ = __detach_next(__cache_root_);
      }
    }

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~_DetachedTreeCache() {
      __t_->destroy(__cache_elem_);
      if (__cache_root_) {
        while (__cache_root_->__parent_ != nullptr)
          __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
        __t_->destroy(__cache_root_);
      }
    }

    _DetachedTreeCache(_DetachedTreeCache const&) = delete;
    _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

  private:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __node_pointer __detach_from_tree(__tree* __t) noexcept;
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __node_pointer __detach_next(__node_pointer) noexcept;

    __tree* __t_;
    __node_pointer __cache_root_;
    __node_pointer __cache_elem_;
  };

  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp) noexcept(is_nothrow_default_constructible<__node_allocator>::value&& is_nothrow_copy_constructible<value_compare>::value)

    : __pair3_(0, __comp) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag()) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp, const allocator_type& __a)
    : __begin_node_(__iter_pointer()), __pair1_(__default_init_tag(), __node_allocator(__a)), __pair3_(0, __comp) {
  __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree* __t) noexcept {
  __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
  __t->__begin_node() = __t->__end_node();
  __t->__end_node()->__left_->__parent_ = nullptr;
  __t->__end_node()->__left_ = nullptr;
  __t->size() = 0;

  if (__cache->__right_ != nullptr)
    __cache = static_cast<__node_pointer>(__cache->__right_);


  return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) noexcept {
  if (__cache->__parent_ == nullptr)
    return nullptr;
  if (std::__tree_is_left_child(static_cast<__node_base_pointer>(__cache))) {
    __cache->__parent_->__left_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__right_ == nullptr)
      return __cache;
    return static_cast<__node_pointer>(std::__tree_leaf(__cache->__right_));
  }

  __cache->__parent_unsafe()->__right_ = nullptr;
  __cache = static_cast<__node_pointer>(__cache->__parent_);
  if (__cache->__left_ == nullptr)
    return __cache;
  return static_cast<__node_pointer>(std::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t) {
  if (this != std::addressof(__t)) {
    value_comp() = __t.value_comp();
    __copy_assign_alloc(__t);
    __assign_multi(__t.begin(), __t.end());
  }
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last) {
  typedef iterator_traits<_ForwardIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(is_same<_ItValueType, __container_value_type>::value,
                "__assign_unique may only be called with the containers value type");
  static_assert(
      __has_forward_iterator_category<_ForwardIterator>::value, "__assign_unique requires a forward iterator");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() != nullptr && __first != __last; ++__first) {
      if (__node_assign_unique(*__first, __cache.__get()).second)
        __cache.__advance();
    }
  }
  for (; __first != __last; ++__first)
    __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void __tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last) {
  typedef iterator_traits<_InputIterator> _ITraits;
  typedef typename _ITraits::value_type _ItValueType;
  static_assert(
      (is_same<_ItValueType, __container_value_type>::value || is_same<_ItValueType, __node_value_type>::value),
      "__assign_multi may only be called with the containers value type"
      " or the nodes value type");
  if (size() != 0) {
    _DetachedTreeCache __cache(this);
    for (; __cache.__get() && __first != __last; ++__first) {
      __cache.__get()->__value_ = *__first;
      __node_insert_multi(__cache.__get());
      __cache.__advance();
    }
  }
  for (; __first != __last; ++__first)
    __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp()) {
  __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t) noexcept(is_nothrow_move_constructible<__node_allocator>::value&& is_nothrow_move_constructible<value_compare>::value)

    : __begin_node_(std::move(__t.__begin_node_)),
      __pair1_(std::move(__t.__pair1_)),
      __pair3_(std::move(__t.__pair3_)) {
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)), __pair3_(0, std::move(__t.value_comp())) {
  if (__a == __t.__alloc()) {
    if (__t.size() == 0)
      __begin_node() = __end_node();
    else {
      __begin_node() = __t.__begin_node();
      __end_node()->__left_ = __t.__end_node()->__left_;
      __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
      size() = __t.size();
      __t.__begin_node() = __t.__end_node();
      __t.__end_node()->__left_ = nullptr;
      __t.size() = 0;
    }
  } else {
    __begin_node() = __end_node();
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value) {
  destroy(static_cast<__node_pointer>(__end_node()->__left_));
  __begin_node_ = __t.__begin_node_;
  __pair1_.first() = __t.__pair1_.first();
  __move_assign_alloc(__t);
  __pair3_ = std::move(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else {
    __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    __t.__begin_node() = __t.__end_node();
    __t.__end_node()->__left_ = nullptr;
    __t.size() = 0;
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type) {
  if (__node_alloc() == __t.__node_alloc())
    __move_assign(__t, true_type());
  else {
    value_comp() = std::move(__t.value_comp());
    const_iterator __e = end();
    if (size() != 0) {
      _DetachedTreeCache __cache(this);
      while (__cache.__get() != nullptr && __t.size() != 0) {
        __cache.__get()->__value_ = std::move(__t.remove(__t.begin())->__value_);
        __node_insert_multi(__cache.__get());
        __cache.__advance();
      }
    }
    while (__t.size() != 0)
      __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
  }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>& __tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t) noexcept(__node_traits::propagate_on_container_move_assignment::value&& is_nothrow_move_assignable<value_compare>::value&& is_nothrow_move_assignable<__node_allocator>::value)



{
  __move_assign(__t, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree() {
  static_assert(is_copy_constructible<value_compare>::value, "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept {
  if (__nd != nullptr) {
    destroy(static_cast<__node_pointer>(__nd->__left_));
    destroy(static_cast<__node_pointer>(__nd->__right_));
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
    __node_traits::deallocate(__na, __nd, 1);
  }
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)




    noexcept(__is_nothrow_swappable_v<value_compare>)

{
  using std::swap;
  swap(__begin_node_, __t.__begin_node_);
  swap(__pair1_.first(), __t.__pair1_.first());
  std::__swap_allocator(__node_alloc(), __t.__node_alloc());
  __pair3_.swap(__t.__pair3_);
  if (size() == 0)
    __begin_node() = __end_node();
  else
    __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
  if (__t.size() == 0)
    __t.__begin_node() = __t.__end_node();
  else
    __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::clear() noexcept {
  destroy(__root());
  size() = 0;
  __begin_node() = __end_node();
  __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent, const key_type& __v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent, const key_type& __v) {
  __node_pointer __nd = __root();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__left_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else {
        if (__nd->__right_ != nullptr)
          __nd = static_cast<__node_pointer>(__nd->__right_);
        else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint, __parent_pointer& __parent, const key_type& __v) {
  if (__hint == end() || !value_comp()(*__hint, __v))
  {

    const_iterator __prior = __hint;
    if (__prior == begin() || !value_comp()(__v, *--__prior)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_leaf_high(__parent, __v);
  }

  return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent, const _Key& __v) {
  __node_pointer __nd = __root();
  __node_base_pointer* __nd_ptr = __root_ptr();
  if (__nd != nullptr) {
    while (true) {
      if (value_comp()(__v, __nd->__value_)) {
        if (__nd->__left_ != nullptr) {
          __nd_ptr = std::addressof(__nd->__left_);
          __nd = static_cast<__node_pointer>(__nd->__left_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __parent->__left_;
        }
      } else if (value_comp()(__nd->__value_, __v)) {
        if (__nd->__right_ != nullptr) {
          __nd_ptr = std::addressof(__nd->__right_);
          __nd = static_cast<__node_pointer>(__nd->__right_);
        } else {
          __parent = static_cast<__parent_pointer>(__nd);
          return __nd->__right_;
        }
      } else {
        __parent = static_cast<__parent_pointer>(__nd);
        return *__nd_ptr;
      }
    }
  }
  __parent = static_cast<__parent_pointer>(__end_node());
  return __parent->__left_;
}
# 1713 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer& __tree<_Tp, _Compare, _Allocator>::__find_equal(
    const_iterator __hint, __parent_pointer& __parent, __node_base_pointer& __dummy, const _Key& __v) {
  if (__hint == end() || value_comp()(__v, *__hint))
  {

    const_iterator __prior = __hint;
    if (__prior == begin() || value_comp()(*--__prior, __v)) {

      if (__hint.__ptr_->__left_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return __parent->__left_;
      } else {
        __parent = static_cast<__parent_pointer>(__prior.__ptr_);
        return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
      }
    }

    return __find_equal(__parent, __v);
  } else if (value_comp()(*__hint, __v))
  {

    const_iterator __next = std::next(__hint);
    if (__next == end() || value_comp()(__v, *__next)) {

      if (__hint.__get_np()->__right_ == nullptr) {
        __parent = static_cast<__parent_pointer>(__hint.__ptr_);
        return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
      } else {
        __parent = static_cast<__parent_pointer>(__next.__ptr_);
        return __parent->__left_;
      }
    }

    return __find_equal(__parent, __v);
  }

  __parent = static_cast<__parent_pointer>(__hint.__ptr_);
  __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
  return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer& __child, __node_base_pointer __new_node) noexcept {
  __new_node->__left_ = nullptr;
  __new_node->__right_ = nullptr;
  __new_node->__parent_ = __parent;

  __child = __new_node;
  if (__begin_node()->__left_ != nullptr)
    __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
  std::__tree_balance_after_insert(__end_node()->__left_, __child);
  ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args) {
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args) {
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&&... __args) {
  static_assert(!__is_tree_value_type<_Args...>::value, "Cannot construct from __value_type");
  __node_allocator& __na = __node_alloc();
  __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
  __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::forward<_Args>(__args)...);
  __h.get_deleter().__value_constructed = true;
  return __h;
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    __r = __h.release();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p, _Args&&... __args) {
  __node_holder __h = __construct_node(std::forward<_Args>(__args)...);
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
  return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type& __v, __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__v));
  __node_pointer __r = static_cast<__node_pointer>(__child);
  bool __inserted = false;
  if (__child == nullptr) {
    __nd->__value_ = __v;
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    __r = __nd;
    __inserted = true;
  }
  return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p, __node_pointer __nd) {
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
  return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) noexcept {
  iterator __r(__ptr);
  ++__r;
  if (__begin_node() == __ptr)
    __begin_node() = __r.__ptr_;
  --size();
  std::__tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__ptr));
  return __r;
}


template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle, class _InsertReturnType>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _InsertReturnType
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(_NodeHandle&& __nh) {
  if (__nh.empty())
    return _InsertReturnType{end(), false, _NodeHandle()};

  __node_pointer __ptr = __nh.__ptr_;
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_equal(__parent, __ptr->__value_);
  if (__child != nullptr)
    return _InsertReturnType{iterator(static_cast<__node_pointer>(__child)), false, std::move(__nh)};

  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(const_iterator __hint, _NodeHandle&& __nh) {
  if (__nh.empty())
    return end();

  __node_pointer __ptr = __nh.__ptr_;
  __parent_pointer __parent;
  __node_base_pointer __dummy;
  __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy, __ptr->__value_);
  __node_pointer __r = static_cast<__node_pointer>(__child);
  if (__child == nullptr) {
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __r = __ptr;
    __nh.__release_ptr();
  }
  return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodeHandle __tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key) {
  iterator __it = find(__key);
  if (__it == end())
    return _NodeHandle();
  return __node_handle_extract<_NodeHandle>(__it);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _NodeHandle __tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p) {
  __node_pointer __np = __p.__get_np();
  __remove_node_pointer(__np);
  return _NodeHandle(__np, __alloc());
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source) {
  static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

  for (typename _Tree::iterator __i = __source.begin(); __i != __source.end();) {
    __node_pointer __src_ptr = __i.__get_np();
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__src_ptr->__value_));
    ++__i;
    if (__child != nullptr)
      continue;
    __source.__remove_node_pointer(__src_ptr);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__src_ptr));
  }
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh) {
  if (__nh.empty())
    return end();
  __node_pointer __ptr = __nh.__ptr_;
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__ptr->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(const_iterator __hint, _NodeHandle&& __nh) {
  if (__nh.empty())
    return end();

  __node_pointer __ptr = __nh.__ptr_;
  __parent_pointer __parent;
  __node_base_pointer& __child = __find_leaf(__hint, __parent, _NodeTypes::__get_key(__ptr->__value_));
  __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
  __nh.__release_ptr();
  return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source) {
  static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

  for (typename _Tree::iterator __i = __source.begin(); __i != __source.end();) {
    __node_pointer __src_ptr = __i.__get_np();
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__src_ptr->__value_));
    ++__i;
    __source.__remove_node_pointer(__src_ptr);
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__src_ptr));
  }
}



template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p) {
  __node_pointer __np = __p.__get_np();
  iterator __r = __remove_node_pointer(__np);
  __node_allocator& __na = __node_alloc();
  __node_traits::destroy(__na, _NodeTypes::__get_ptr(const_cast<__node_value_type&>(*__p)));
  __node_traits::deallocate(__na, __np, 1);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l) {
  while (__f != __l)
    __f = erase(__f);
  return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k) {
  iterator __i = find(__k);
  if (__i == end())
    return 0;
  erase(__i);
  return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k) {
  pair<iterator, iterator> __p = __equal_range_multi(__k);
  size_type __r = 0;
  for (; __p.first != __p.second; ++__r)
    __p.first = erase(__p.first);
  return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator __tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) {
  iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const {
  const_iterator __p = __lower_bound(__v, __root(), __end_node());
  if (__p != end() && !value_comp()(__v, *__p))
    return __p;
  return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const {
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return 1;
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const {
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return std::distance(
          __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
          __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result) {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__lower_bound(
    const _Key& __v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (!value_comp()(__root->__value_, __v)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v, __node_pointer __root, __iter_pointer __result) {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator __tree<_Tp, _Compare, _Allocator>::__upper_bound(
    const _Key& __v, __node_pointer __root, __iter_pointer __result) const {
  while (__root != nullptr) {
    if (value_comp()(__v, __root->__value_)) {
      __result = static_cast<__iter_pointer>(__root);
      __root = static_cast<__node_pointer>(__root->__left_);
    } else
      __root = static_cast<__node_pointer>(__root->__right_);
  }
  return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(iterator(__rt),
                 iterator(__rt->__right_ != nullptr ? static_cast<__iter_pointer>(std::__tree_min(__rt->__right_))
                                                    : __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(
          const_iterator(__rt),
          const_iterator(
              __rt->__right_ != nullptr ? static_cast<__iter_pointer>(std::__tree_min(__rt->__right_)) : __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) {
  typedef pair<iterator, iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const {
  typedef pair<const_iterator, const_iterator> _Pp;
  __iter_pointer __result = __end_node();
  __node_pointer __rt = __root();
  while (__rt != nullptr) {
    if (value_comp()(__k, __rt->__value_)) {
      __result = static_cast<__iter_pointer>(__rt);
      __rt = static_cast<__node_pointer>(__rt->__left_);
    } else if (value_comp()(__rt->__value_, __k))
      __rt = static_cast<__node_pointer>(__rt->__right_);
    else
      return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                 __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
  }
  return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept {
  __node_pointer __np = __p.__get_np();
  if (__begin_node() == __p.__ptr_) {
    if (__np->__right_ != nullptr)
      __begin_node() = static_cast<__iter_pointer>(__np->__right_);
    else
      __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
  }
  --size();
  std::__tree_remove(__end_node()->__left_, static_cast<__node_base_pointer>(__np));
  return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(__tree<_Tp, _Compare, _Allocator>& __x, __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

}}
# 2295 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
#pragma clang diagnostic pop
# 594 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 617 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 621 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3

#pragma clang diagnostic push
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 622 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Key,
          class _CP,
          class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare : private _Compare {
public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_value_compare() noexcept(is_nothrow_default_constructible<_Compare>::value)
      : _Compare() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_value_compare(_Compare __c) noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : _Compare(__c) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const _Compare& key_comp() const noexcept { return *this; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _CP& __y) const {
    return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _Key& __y) const {
    return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _Key& __x, const _CP& __y) const {
    return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(__map_value_compare& __y) noexcept(__is_nothrow_swappable_v<_Compare>) {
    using std::swap;
    swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
  }


  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _K2& __x, const _CP& __y) const {
    return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _K2& __y) const {
    return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);
  }

};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false> {
  _Compare __comp_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_value_compare() noexcept(is_nothrow_default_constructible<_Compare>::value)
      : __comp_() {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_value_compare(_Compare __c) noexcept(is_nothrow_copy_constructible<_Compare>::value)
      : __comp_(__c) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const _Compare& key_comp() const noexcept { return __comp_; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _CP& __y) const {
    return __comp_(__x.__get_value().first, __y.__get_value().first);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _Key& __y) const {
    return __comp_(__x.__get_value().first, __y);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _Key& __x, const _CP& __y) const {
    return __comp_(__x, __y.__get_value().first);
  }
  void swap(__map_value_compare& __y) noexcept(__is_nothrow_swappable_v<_Compare>) {
    using std::swap;
    swap(__comp_, __y.__comp_);
  }


  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _K2& __x, const _CP& __y) const {
    return __comp_(__x, __y.__get_value().first);
  }

  template <typename _K2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const _CP& __x, const _K2& __y) const {
    return __comp_(__x.__get_value().first, __y);
  }

};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x, __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor {
  typedef _Allocator allocator_type;
  typedef allocator_traits<allocator_type> __alloc_traits;

public:
  typedef typename __alloc_traits::pointer pointer;

private:
  allocator_type& __na_;

public:
  bool __first_constructed;
  bool __second_constructed;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __map_node_destructor(allocator_type& __na) noexcept
      : __na_(__na),
        __first_constructed(false),
        __second_constructed(false) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
      : __na_(__x.__na_),
        __first_constructed(__x.__value_constructed),
        __second_constructed(__x.__value_constructed) {
    __x.__value_constructed = false;
  }


  __map_node_destructor& operator=(const __map_node_destructor&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator()(pointer __p) noexcept {
    if (__second_constructed)
      __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().second));
    if (__first_constructed)
      __alloc_traits::destroy(__na_, std::addressof(__p->__value_.__get_value().first));
    if (__p)
      __alloc_traits::deallocate(__na_, __p, 1);
  }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
class multimap;
template <class _TreeIterator>
class __map_const_iterator;



template <class _Key, class _Tp>
struct __attribute__((__standalone_debug__)) __value_type {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
  typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
  value_type __cc_;

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_type& __get_value() {

    return *std::launder(std::addressof(__cc_));



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const value_type& __get_value() const {

    return *std::launder(std::addressof(__cc_));



  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __nc_ref_pair_type __ref() {
    value_type& __v = __get_value();
    return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __nc_rref_pair_type __move() {
    value_type& __v = __get_value();
    return __nc_rref_pair_type(std::move(const_cast<key_type&>(__v.first)), std::move(__v.second));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __value_type& operator=(const __value_type& __v) {
    __ref() = __v.__get_value();
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __value_type& operator=(__value_type&& __v) {
    __ref() = __v.__move();
    return *this;
  }

  template <class _ValueTp, __enable_if_t<__is_same_uncvref<_ValueTp, value_type>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __value_type& operator=(_ValueTp&& __v) {
    __ref() = std::forward<_ValueTp>(__v);
    return *this;
  }

  __value_type() = delete;
  ~__value_type() = delete;
  __value_type(const __value_type&) = delete;
  __value_type(__value_type&&) = delete;
};
# 840 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __map_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef value_type& reference;
  typedef typename _NodeTypes::__map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator() noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __i_->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator& operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator operator++(int) {
    __map_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator& operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_iterator operator--(int) {
    __map_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __map_iterator& __x, const __map_iterator& __y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __map_iterator& __x, const __map_iterator& __y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class>
  friend class __map_const_iterator;
};

template <class _TreeIterator>
class __map_const_iterator {
  typedef typename _TreeIterator::_NodeTypes _NodeTypes;
  typedef typename _TreeIterator::__pointer_traits __pointer_traits;

  _TreeIterator __i_;

public:
  typedef bidirectional_iterator_tag iterator_category;
  typedef typename _NodeTypes::__map_value_type value_type;
  typedef typename _TreeIterator::difference_type difference_type;
  typedef const value_type& reference;
  typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator() noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  __map_const_iterator(__map_iterator< typename _TreeIterator::__non_const_iterator> __i) noexcept : __i_(__i.__i_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __i_->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const { return pointer_traits<pointer>::pointer_to(__i_->__get_value()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator& operator++() {
    ++__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator operator++(int) {
    __map_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator& operator--() {
    --__i_;
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __map_const_iterator operator--(int) {
    __map_const_iterator __t(*this);
    --(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y) {
    return __x.__i_ == __y.__i_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y) {
    return __x.__i_ != __y.__i_;
  }

  template <class, class, class, class>
  friend class map;
  template <class, class, class, class>
  friend class multimap;
  template <class, class, class>
  friend class __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>, class _Allocator = allocator<pair<const _Key, _Tp> > >
class map {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef __type_identity_t<_Compare> key_compare;
  typedef __type_identity_t<_Allocator> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;

  static_assert(is_same<typename allocator_type::value_type, value_type>::value,
                "Allocator::value_type must be same type as value_type");

  class value_compare : public __binary_function<value_type, value_type, bool> {
    friend class map;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare(key_compare __c) : comp(__c) {}

  public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const value_type& __x, const value_type& __y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  static_assert(__check_valid_allocator<allocator_type>::value, "");

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


  typedef __map_node_handle<typename __base::__node, allocator_type> node_type;
  typedef __insert_return_type<iterator, node_type> insert_return_type;


  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class map;
  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map() noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_default_constructible<key_compare>::value&& is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit map(const key_compare& __comp) noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit map(const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(_InputIterator __f, _InputIterator __l, const key_compare& __comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  map(_InputIterator __f, _InputIterator __l, const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }
# 1062 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
      : map(__f, __l, key_compare(), __a) {}
# 1073 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(const map& __m) : __tree_(__m.__tree_) { insert(__m.begin(), __m.end()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map& operator=(const map& __m) {

    __tree_ = __m.__tree_;
# 1086 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(map&& __m) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::move(__m.__tree_)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(map&& __m, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map& operator=(map&& __m) noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::move(__m.__tree_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(initializer_list<value_type> __il, const allocator_type& __a)
      : map(__il, key_compare(), __a) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map& operator=(initializer_list<value_type> __il) {
    __tree_.__assign_unique(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit map(const allocator_type& __a) : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) map(const map& __m, const allocator_type& __a)
      : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~map() { static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), ""); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crend() const noexcept { return rend(); }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept { return __tree_.max_size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) mapped_type& operator[](const key_type& __k);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) mapped_type& operator[](key_type&& __k);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) mapped_type& at(const key_type& __k);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const mapped_type& at(const key_type& __k) const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept { return allocator_type(__tree_.__alloc()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) key_compare key_comp() const { return __tree_.value_comp().key_comp(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare value_comp() const { return value_compare(__tree_.value_comp().key_comp()); }


  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> emplace(_Args&&... __args) {
    return __tree_.__emplace_unique(std::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace_hint(const_iterator __p, _Args&&... __args) {
    return __tree_.__emplace_hint_unique(__p.__i_, std::forward<_Args>(__args)...);
  }

  template <class _Pp, __enable_if_t<is_constructible<value_type, _Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert(_Pp&& __p) {
    return __tree_.__insert_unique(std::forward<_Pp>(__p));
  }

  template <class _Pp, __enable_if_t<is_constructible<value_type, _Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __pos, _Pp&& __p) {
    return __tree_.__insert_unique(__pos.__i_, std::forward<_Pp>(__p));
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert(const value_type& __v) { return __tree_.__insert_unique(__v); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, const value_type& __v) {
    return __tree_.__insert_unique(__p.__i_, __v);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert(value_type&& __v) {
    return __tree_.__insert_unique(std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, value_type&& __v) {
    return __tree_.__insert_unique(__p.__i_, std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }


  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      insert(__e.__i_, *__f);
  }
# 1222 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args) {
    return __tree_.__emplace_unique_key_args(
        __k,
        std::piecewise_construct,
        std::forward_as_tuple(__k),
        std::forward_as_tuple(std::forward<_Args>(__args)...));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args) {
    return __tree_.__emplace_unique_key_args(
        __k,
        std::piecewise_construct,
        std::forward_as_tuple(std::move(__k)),
        std::forward_as_tuple(std::forward<_Args>(__args)...));
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args) {
    return __tree_
        .__emplace_hint_unique_key_args(
            __h.__i_,
            __k,
            std::piecewise_construct,
            std::forward_as_tuple(__k),
            std::forward_as_tuple(std::forward<_Args>(__args)...))
        .first;
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args) {
    return __tree_
        .__emplace_hint_unique_key_args(
            __h.__i_,
            __k,
            std::piecewise_construct,
            std::forward_as_tuple(std::move(__k)),
            std::forward_as_tuple(std::forward<_Args>(__args)...))
        .first;
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v) {
    iterator __p = lower_bound(__k);
    if (__p != end() && !key_comp()(__k, __p->first)) {
      __p->second = std::forward<_Vp>(__v);
      return std::make_pair(__p, false);
    }
    return std::make_pair(emplace_hint(__p, __k, std::forward<_Vp>(__v)), true);
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v) {
    iterator __p = lower_bound(__k);
    if (__p != end() && !key_comp()(__k, __p->first)) {
      __p->second = std::forward<_Vp>(__v);
      return std::make_pair(__p, false);
    }
    return std::make_pair(emplace_hint(__p, std::move(__k), std::forward<_Vp>(__v)), true);
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_or_assign(const_iterator __h, const key_type& __k, _Vp&& __v) {
    auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(__h.__i_, __k, __k, std::forward<_Vp>(__v));

    if (!__inserted)
      __r->__get_value().second = std::forward<_Vp>(__v);

    return __r;
  }

  template <class _Vp>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_or_assign(const_iterator __h, key_type&& __k, _Vp&& __v) {
    auto [__r, __inserted] =
        __tree_.__emplace_hint_unique_key_args(__h.__i_, __k, std::move(__k), std::forward<_Vp>(__v));

    if (!__inserted)
      __r->__get_value().second = std::forward<_Vp>(__v);

    return __r;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type erase(const key_type& __k) { return __tree_.__erase_unique(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { __tree_.clear(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) insert_return_type insert(node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_unique< node_type, insert_return_type>(std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __hint, node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_unique<node_type>(__hint.__i_, std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(key_type const& __key) {
    return __tree_.template __node_handle_extract<node_type>(__key);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(const_iterator __it) {
    return __tree_.template __node_handle_extract<node_type>(__it.__i_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(map& __m) noexcept(__is_nothrow_swappable_v<__base>) { __tree_.swap(__m.__tree_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const key_type& __k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const key_type& __k) const { return __tree_.find(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const _K2& __k) {
    return __tree_.find(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const _K2& __k) const {
    return __tree_.find(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const key_type& __k) const { return __tree_.__count_unique(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const _K2& __k) const {
    return __tree_.__count_multi(__k);
  }
# 1389 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const key_type& __k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const key_type& __k) const { return __tree_.lower_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const _K2& __k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const _K2& __k) const {
    return __tree_.lower_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const key_type& __k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const key_type& __k) const { return __tree_.upper_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const _K2& __k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const _K2& __k) const {
    return __tree_.upper_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __tree_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __tree_.__equal_range_unique(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const _K2& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __tree_.__equal_range_multi(__k);
  }


private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;
  typedef typename __base::__node_base_pointer __node_base_pointer;
  typedef typename __base::__parent_pointer __parent_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;




};


template <class _InputIterator,
          class _Compare = less<__iter_key_type<_InputIterator>>,
          class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
    -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;
# 1468 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key,
          class _Tp,
          class _Compare = less<remove_const_t<_Key>>,
          class _Allocator = allocator<pair<const _Key, _Tp>>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>,
    _Compare = _Compare(),
    _Allocator = _Allocator()) -> map<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Allocator)
    -> map<__iter_key_type<_InputIterator>,
           __iter_mapped_type<_InputIterator>,
           less<__iter_key_type<_InputIterator>>,
           _Allocator>;







template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>,
    _Allocator) -> map<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::move(__m.__tree_), typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_unique(__e.__i_, __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
  }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp& map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k) {
  return __tree_
      .__emplace_unique_key_args(__k, std::piecewise_construct, std::forward_as_tuple(__k), std::forward_as_tuple())
      .first->__get_value()
      .second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp& map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k) {


  return __tree_
      .__emplace_unique_key_args(
          __k, std::piecewise_construct, std::forward_as_tuple(std::move(__k)), std::forward_as_tuple())
      .first->__get_value()
      .second;

}
# 1559 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp& map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) {
  __parent_pointer __parent;
  __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
  if (__child == nullptr)
    __throw_out_of_range("map::at:  key not found");
  return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp& map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const {
  __parent_pointer __parent;
  __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
  if (__child == nullptr)
    __throw_out_of_range("map::at:  key not found");
  return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x, const map<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__y < __x);
}
# 1625 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x, map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1640 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>, class _Allocator = allocator<pair<const _Key, _Tp> > >
class multimap {
public:

  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef pair<const key_type, mapped_type> value_type;
  typedef __type_identity_t<_Compare> key_compare;
  typedef __type_identity_t<_Allocator> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;

  static_assert(__check_valid_allocator<allocator_type>::value, "");
  static_assert(is_same<typename allocator_type::value_type, value_type>::value,
                "Allocator::value_type must be same type as value_type");

  class value_compare : public __binary_function<value_type, value_type, bool> {
    friend class multimap;

  protected:
    key_compare comp;

    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare(key_compare __c) : comp(__c) {}

  public:
    __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator()(const value_type& __x, const value_type& __y) const {
      return comp(__x.first, __y.first);
    }
  };

private:
  typedef std::__value_type<key_type, mapped_type> __value_type;
  typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
  typedef __rebind_alloc<allocator_traits<allocator_type>, __value_type> __allocator_type;
  typedef __tree<__value_type, __vc, __allocator_type> __base;
  typedef typename __base::__node_traits __node_traits;
  typedef allocator_traits<allocator_type> __alloc_traits;

  __base __tree_;

public:
  typedef typename __alloc_traits::pointer pointer;
  typedef typename __alloc_traits::const_pointer const_pointer;
  typedef typename __alloc_traits::size_type size_type;
  typedef typename __alloc_traits::difference_type difference_type;
  typedef __map_iterator<typename __base::iterator> iterator;
  typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


  typedef __map_node_handle<typename __base::__node, allocator_type> node_type;


  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class map;
  template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
  friend class multimap;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap() noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_default_constructible<key_compare>::value&& is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(__vc(key_compare())) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multimap(const key_compare& __comp) noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__vc(__comp)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multimap(const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(_InputIterator __f, _InputIterator __l, const key_compare& __comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  multimap(_InputIterator __f, _InputIterator __l, const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__f, __l);
  }
# 1737 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
      : multimap(__f, __l, key_compare(), __a) {}
# 1748 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(const multimap& __m)
      : __tree_(__m.__tree_.value_comp(),
                __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc())) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap& operator=(const multimap& __m) {

    __tree_ = __m.__tree_;
# 1765 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(multimap&& __m) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::move(__m.__tree_)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(multimap&& __m, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap& operator=(multimap&& __m) noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::move(__m.__tree_);
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
      : __tree_(__vc(__comp)) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
      : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(initializer_list<value_type> __il, const allocator_type& __a)
      : multimap(__il, key_compare(), __a) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap& operator=(initializer_list<value_type> __il) {
    __tree_.__assign_multi(__il.begin(), __il.end());
    return *this;
  }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multimap(const allocator_type& __a) : __tree_(typename __base::allocator_type(__a)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multimap(const multimap& __m, const allocator_type& __a)
      : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a)) {
    insert(__m.begin(), __m.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~multimap() { static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), ""); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crend() const noexcept { return rend(); }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept { return __tree_.max_size(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept { return allocator_type(__tree_.__alloc()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) key_compare key_comp() const { return __tree_.value_comp().key_comp(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare value_comp() const { return value_compare(__tree_.value_comp().key_comp()); }



  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace(_Args&&... __args) {
    return __tree_.__emplace_multi(std::forward<_Args>(__args)...);
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace_hint(const_iterator __p, _Args&&... __args) {
    return __tree_.__emplace_hint_multi(__p.__i_, std::forward<_Args>(__args)...);
  }

  template <class _Pp, __enable_if_t<is_constructible<value_type, _Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(_Pp&& __p) {
    return __tree_.__insert_multi(std::forward<_Pp>(__p));
  }

  template <class _Pp, __enable_if_t<is_constructible<value_type, _Pp>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __pos, _Pp&& __p) {
    return __tree_.__insert_multi(__pos.__i_, std::forward<_Pp>(__p));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(value_type&& __v) { return __tree_.__insert_multi(std::move(__v)); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, value_type&& __v) {
    return __tree_.__insert_multi(__p.__i_, std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }



  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const value_type& __v) { return __tree_.__insert_multi(__v); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, const value_type& __v) {
    return __tree_.__insert_multi(__p.__i_, __v);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_multi(__e.__i_, *__f);
  }
# 1889 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(iterator __p) { return __tree_.erase(__p.__i_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type erase(const key_type& __k) { return __tree_.__erase_multi(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l) {
    return __tree_.erase(__f.__i_, __l.__i_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_multi<node_type>(std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __hint, node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_multi<node_type>(__hint.__i_, std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(key_type const& __key) {
    return __tree_.template __node_handle_extract<node_type>(__key);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(const_iterator __it) {
    return __tree_.template __node_handle_extract<node_type>(__it.__i_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    return __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    return __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    return __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    return __tree_.__node_handle_merge_multi(__source.__tree_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { __tree_.clear(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(multimap& __m) noexcept(__is_nothrow_swappable_v<__base>) {
    __tree_.swap(__m.__tree_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const key_type& __k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const key_type& __k) const { return __tree_.find(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const _K2& __k) {
    return __tree_.find(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const _K2& __k) const {
    return __tree_.find(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const key_type& __k) const { return __tree_.__count_multi(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const _K2& __k) const {
    return __tree_.__count_multi(__k);
  }
# 1974 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const key_type& __k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const key_type& __k) const { return __tree_.lower_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const _K2& __k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const _K2& __k) const {
    return __tree_.lower_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const key_type& __k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const key_type& __k) const { return __tree_.upper_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const _K2& __k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const _K2& __k) const {
    return __tree_.upper_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __tree_.__equal_range_multi(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const _K2& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __tree_.__equal_range_multi(__k);
  }


private:
  typedef typename __base::__node __node;
  typedef typename __base::__node_allocator __node_allocator;
  typedef typename __base::__node_pointer __node_pointer;

  typedef __map_node_destructor<__node_allocator> _Dp;
  typedef unique_ptr<__node, _Dp> __node_holder;
};


template <class _InputIterator,
          class _Compare = less<__iter_key_type<_InputIterator>>,
          class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
    -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;
# 2047 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key,
          class _Tp,
          class _Compare = less<remove_const_t<_Key>>,
          class _Allocator = allocator<pair<const _Key, _Tp>>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>,
         _Compare = _Compare(),
         _Allocator = _Allocator()) -> multimap<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Allocator)
    -> multimap<__iter_key_type<_InputIterator>,
                __iter_mapped_type<_InputIterator>,
                less<__iter_key_type<_InputIterator>>,
                _Allocator>;







template <class _Key, class _Tp, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>,
         _Allocator) -> multimap<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::move(__m.__tree_), typename __base::allocator_type(__a)) {
  if (__a != __m.get_allocator()) {
    const_iterator __e = cend();
    while (!__m.empty())
      __tree_.__insert_multi(__e.__i_, std::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
  }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x, const multimap<_Key, _Tp, _Compare, _Allocator>& __y) {
  return !(__y < __x);
}
# 2139 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x, multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 2154 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
}}
# 2154 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic pop


#pragma clang diagnostic push
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 2157 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
namespace pmr {
template <class _KeyT, class _ValueT, class _CompareT = std::less<_KeyT>>
using map =
    std::map<_KeyT, _ValueT, _CompareT, polymorphic_allocator<std::pair<const _KeyT, _ValueT>>>;

template <class _KeyT, class _ValueT, class _CompareT = std::less<_KeyT>>
using multimap =
    std::multimap<_KeyT, _ValueT, _CompareT, polymorphic_allocator<std::pair<const _KeyT, _ValueT>>>;
}
}}
# 2167 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma clang diagnostic pop
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 1 3
# 552 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 556 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 2 3

#pragma clang diagnostic push
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 557 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Key, class _Compare, class _Allocator>
class multiset;

template <class _Key, class _Compare = less<_Key>, class _Allocator = allocator<_Key> >
class set {
public:

  typedef _Key key_type;
  typedef key_type value_type;
  typedef __type_identity_t<_Compare> key_compare;
  typedef key_compare value_compare;
  typedef __type_identity_t<_Allocator> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;

  static_assert(is_same<typename allocator_type::value_type, value_type>::value,
                "Allocator::value_type must be same type as value_type");

private:
  typedef __tree<value_type, value_compare, allocator_type> __base;
  typedef allocator_traits<allocator_type> __alloc_traits;

  static_assert(__check_valid_allocator<allocator_type>::value, "");

  __base __tree_;

public:
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::const_iterator iterator;
  typedef typename __base::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


  typedef __set_node_handle<typename __base::__node, allocator_type> node_type;
  typedef __insert_return_type<iterator, node_type> insert_return_type;


  template <class _Key2, class _Compare2, class _Alloc2>
  friend class set;
  template <class _Key2, class _Compare2, class _Alloc2>
  friend class multiset;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set() noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_default_constructible<key_compare>::value&& is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(value_compare()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit set(const value_compare& __comp) noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__comp) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit set(const value_compare& __comp, const allocator_type& __a) : __tree_(__comp, __a) {}
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(_InputIterator __f, _InputIterator __l, const value_compare& __comp = value_compare())
      : __tree_(__comp) {
    insert(__f, __l);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  set(_InputIterator __f, _InputIterator __l, const value_compare& __comp, const allocator_type& __a)
      : __tree_(__comp, __a) {
    insert(__f, __l);
  }
# 641 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
      : set(__f, __l, key_compare(), __a) {}
# 652 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(const set& __s) : __tree_(__s.__tree_) { insert(__s.begin(), __s.end()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set& operator=(const set& __s) {
    __tree_ = __s.__tree_;
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(set&& __s) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::move(__s.__tree_)) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit set(const allocator_type& __a) : __tree_(__a) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(const set& __s, const allocator_type& __a) : __tree_(__s.__tree_.value_comp(), __a) {
    insert(__s.begin(), __s.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(set&& __s, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
      : __tree_(__comp) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(initializer_list<value_type> __il, const value_compare& __comp, const allocator_type& __a)
      : __tree_(__comp, __a) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set(initializer_list<value_type> __il, const allocator_type& __a)
      : set(__il, key_compare(), __a) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set& operator=(initializer_list<value_type> __il) {
    __tree_.__assign_unique(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) set& operator=(set&& __s) noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::move(__s.__tree_);
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~set() { static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), ""); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crend() const noexcept { return rend(); }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept { return __tree_.max_size(); }



  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> emplace(_Args&&... __args) {
    return __tree_.__emplace_unique(std::forward<_Args>(__args)...);
  }
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace_hint(const_iterator __p, _Args&&... __args) {
    return __tree_.__emplace_hint_unique(__p, std::forward<_Args>(__args)...);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert(const value_type& __v) { return __tree_.__insert_unique(__v); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, const value_type& __v) {
    return __tree_.__insert_unique(__p, __v);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_unique(__e, *__f);
  }
# 754 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, bool> insert(value_type&& __v) {
    return __tree_.__insert_unique(std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, value_type&& __v) {
    return __tree_.__insert_unique(__p, std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p) { return __tree_.erase(__p); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type erase(const key_type& __k) { return __tree_.__erase_unique(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l) { return __tree_.erase(__f, __l); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { __tree_.clear(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) insert_return_type insert(node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_unique< node_type, insert_return_type>(std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __hint, node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_unique<node_type>(__hint, std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(key_type const& __key) {
    return __tree_.template __node_handle_extract<node_type>(__key);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(const_iterator __it) {
    return __tree_.template __node_handle_extract<node_type>(__it);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(set<key_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(set<key_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multiset<key_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multiset<key_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_unique(__source.__tree_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(set& __s) noexcept(__is_nothrow_swappable_v<__base>) { __tree_.swap(__s.__tree_); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept { return __tree_.__alloc(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) key_compare key_comp() const { return __tree_.value_comp(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare value_comp() const { return __tree_.value_comp(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const key_type& __k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const key_type& __k) const { return __tree_.find(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const _K2& __k) {
    return __tree_.find(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const _K2& __k) const {
    return __tree_.find(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const key_type& __k) const { return __tree_.__count_unique(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const _K2& __k) const {
    return __tree_.__count_multi(__k);
  }
# 849 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const key_type& __k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const key_type& __k) const { return __tree_.lower_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const _K2& __k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const _K2& __k) const {
    return __tree_.lower_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const key_type& __k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const key_type& __k) const { return __tree_.upper_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const _K2& __k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const _K2& __k) const {
    return __tree_.upper_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __tree_.__equal_range_unique(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __tree_.__equal_range_unique(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const _K2& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __tree_.__equal_range_multi(__k);
  }

};


template <class _InputIterator,
          class _Compare = less<__iter_value_type<_InputIterator>>,
          class _Allocator = allocator<__iter_value_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>>
set(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
    -> set<__iter_value_type<_InputIterator>, _Compare, _Allocator>;
# 914 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key,
          class _Compare = less<_Key>,
          class _Allocator = allocator<_Key>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
set(initializer_list<_Key>, _Compare = _Compare(), _Allocator = _Allocator()) -> set<_Key, _Compare, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
set(_InputIterator,
    _InputIterator,
    _Allocator) -> set<__iter_value_type<_InputIterator>, less<__iter_value_type<_InputIterator>>, _Allocator>;
# 936 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value, void>>
set(initializer_list<_Key>, _Allocator) -> set<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a) : __tree_(std::move(__s.__tree_), __a) {
  if (__a != __s.get_allocator()) {
    const_iterator __e = cend();
    while (!__s.empty())
      insert(__e, std::move(__s.__tree_.remove(__s.begin())->__value_));
  }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator==(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator!=(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>=(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<=(const set<_Key, _Compare, _Allocator>& __x, const set<_Key, _Compare, _Allocator>& __y) {
  return !(__y < __x);
}
# 1002 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(set<_Key, _Compare, _Allocator>& __x, set<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1016 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Compare = less<_Key>, class _Allocator = allocator<_Key> >
class multiset {
public:

  typedef _Key key_type;
  typedef key_type value_type;
  typedef __type_identity_t<_Compare> key_compare;
  typedef key_compare value_compare;
  typedef __type_identity_t<_Allocator> allocator_type;
  typedef value_type& reference;
  typedef const value_type& const_reference;

  static_assert(is_same<typename allocator_type::value_type, value_type>::value,
                "Allocator::value_type must be same type as value_type");

private:
  typedef __tree<value_type, value_compare, allocator_type> __base;
  typedef allocator_traits<allocator_type> __alloc_traits;

  static_assert(__check_valid_allocator<allocator_type>::value, "");

  __base __tree_;

public:
  typedef typename __base::pointer pointer;
  typedef typename __base::const_pointer const_pointer;
  typedef typename __base::size_type size_type;
  typedef typename __base::difference_type difference_type;
  typedef typename __base::const_iterator iterator;
  typedef typename __base::const_iterator const_iterator;
  typedef std::reverse_iterator<iterator> reverse_iterator;
  typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


  typedef __set_node_handle<typename __base::__node, allocator_type> node_type;


  template <class _Key2, class _Compare2, class _Alloc2>
  friend class set;
  template <class _Key2, class _Compare2, class _Alloc2>
  friend class multiset;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset() noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_default_constructible<key_compare>::value&& is_nothrow_copy_constructible<key_compare>::value)


      : __tree_(value_compare()) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multiset(const value_compare& __comp) noexcept(is_nothrow_default_constructible<allocator_type>::value&& is_nothrow_copy_constructible<key_compare>::value)

      : __tree_(__comp) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multiset(const value_compare& __comp, const allocator_type& __a)
      : __tree_(__comp, __a) {}
  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(_InputIterator __f, _InputIterator __l, const value_compare& __comp = value_compare())
      : __tree_(__comp) {
    insert(__f, __l);
  }


  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
      : multiset(__f, __l, key_compare(), __a) {}


  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  multiset(_InputIterator __f, _InputIterator __l, const value_compare& __comp, const allocator_type& __a)
      : __tree_(__comp, __a) {
    insert(__f, __l);
  }
# 1105 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(const multiset& __s)
      : __tree_(__s.__tree_.value_comp(),
                __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc())) {
    insert(__s.begin(), __s.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset& operator=(const multiset& __s) {
    __tree_ = __s.__tree_;
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(multiset&& __s) noexcept(is_nothrow_move_constructible<__base>::value)
      : __tree_(std::move(__s.__tree_)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(multiset&& __s, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit multiset(const allocator_type& __a) : __tree_(__a) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(const multiset& __s, const allocator_type& __a)
      : __tree_(__s.__tree_.value_comp(), __a) {
    insert(__s.begin(), __s.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
      : __tree_(__comp) {
    insert(__il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  multiset(initializer_list<value_type> __il, const value_compare& __comp, const allocator_type& __a)
      : __tree_(__comp, __a) {
    insert(__il.begin(), __il.end());
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset(initializer_list<value_type> __il, const allocator_type& __a)
      : multiset(__il, key_compare(), __a) {}


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset& operator=(initializer_list<value_type> __il) {
    __tree_.__assign_multi(__il.begin(), __il.end());
    return *this;
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) multiset& operator=(multiset&& __s) noexcept(is_nothrow_move_assignable<__base>::value) {
    __tree_ = std::move(__s.__tree_);
    return *this;
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~multiset() { static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), ""); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept { return __tree_.begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return __tree_.end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return __tree_.end(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rbegin() noexcept { return reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(end()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reverse_iterator rend() noexcept { return reverse_iterator(begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator rend() const noexcept { return const_reverse_iterator(begin()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept { return begin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return end(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crbegin() const noexcept { return rbegin(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reverse_iterator crend() const noexcept { return rend(); }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept { return __tree_.size() == 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type size() const noexcept { return __tree_.size(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept { return __tree_.max_size(); }



  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace(_Args&&... __args) {
    return __tree_.__emplace_multi(std::forward<_Args>(__args)...);
  }
  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace_hint(const_iterator __p, _Args&&... __args) {
    return __tree_.__emplace_hint_multi(__p, std::forward<_Args>(__args)...);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const value_type& __v) { return __tree_.__insert_multi(__v); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, const value_type& __v) {
    return __tree_.__insert_multi(__p, __v);
  }

  template <class _InputIterator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(_InputIterator __f, _InputIterator __l) {
    for (const_iterator __e = cend(); __f != __l; ++__f)
      __tree_.__insert_multi(__e, *__f);
  }
# 1211 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(value_type&& __v) { return __tree_.__insert_multi(std::move(__v)); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __p, value_type&& __v) {
    return __tree_.__insert_multi(__p, std::move(__v));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void insert(initializer_list<value_type> __il) { insert(__il.begin(), __il.end()); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __p) { return __tree_.erase(__p); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type erase(const key_type& __k) { return __tree_.__erase_multi(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase(const_iterator __f, const_iterator __l) { return __tree_.erase(__f, __l); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { __tree_.clear(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_multi<node_type>(std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert(const_iterator __hint, node_type&& __nh) {
    ((void)0);

    return __tree_.template __node_handle_insert_multi<node_type>(__hint, std::move(__nh));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(key_type const& __key) {
    return __tree_.template __node_handle_extract<node_type>(__key);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) node_type extract(const_iterator __it) {
    return __tree_.template __node_handle_extract<node_type>(__it);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multiset<key_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(multiset<key_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(set<key_type, _Compare2, allocator_type>& __source) {
    ((void)0);

    __tree_.__node_handle_merge_multi(__source.__tree_);
  }
  template <class _Compare2>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(set<key_type, _Compare2, allocator_type>&& __source) {
    ((void)0);

    __tree_.__node_handle_merge_multi(__source.__tree_);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(multiset& __s) noexcept(__is_nothrow_swappable_v<__base>) {
    __tree_.swap(__s.__tree_);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept { return __tree_.__alloc(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) key_compare key_comp() const { return __tree_.value_comp(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) value_compare value_comp() const { return __tree_.value_comp(); }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const key_type& __k) { return __tree_.find(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const key_type& __k) const { return __tree_.find(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator find(const _K2& __k) {
    return __tree_.find(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator find(const _K2& __k) const {
    return __tree_.find(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const key_type& __k) const { return __tree_.__count_multi(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type count(const _K2& __k) const {
    return __tree_.__count_multi(__k);
  }
# 1306 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const key_type& __k) { return __tree_.lower_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const key_type& __k) const { return __tree_.lower_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator lower_bound(const _K2& __k) {
    return __tree_.lower_bound(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator lower_bound(const _K2& __k) const {
    return __tree_.lower_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const key_type& __k) { return __tree_.upper_bound(__k); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const key_type& __k) const { return __tree_.upper_bound(__k); }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator upper_bound(const _K2& __k) {
    return __tree_.upper_bound(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator upper_bound(const _K2& __k) const {
    return __tree_.upper_bound(__k);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const key_type& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const key_type& __k) const {
    return __tree_.__equal_range_multi(__k);
  }

  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<iterator, iterator> equal_range(const _K2& __k) {
    return __tree_.__equal_range_multi(__k);
  }
  template <typename _K2, enable_if_t<__is_transparent_v<_Compare, _K2>, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pair<const_iterator, const_iterator> equal_range(const _K2& __k) const {
    return __tree_.__equal_range_multi(__k);
  }

};


template <class _InputIterator,
          class _Compare = less<__iter_value_type<_InputIterator>>,
          class _Allocator = allocator<__iter_value_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>>
multiset(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
    -> multiset<__iter_value_type<_InputIterator>, _Compare, _Allocator>;
# 1371 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key,
          class _Compare = less<_Key>,
          class _Allocator = allocator<_Key>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>,
          class = enable_if_t<!__is_allocator<_Compare>::value, void>>
multiset(initializer_list<_Key>,
         _Compare = _Compare(),
         _Allocator = _Allocator()) -> multiset<_Key, _Compare, _Allocator>;

template <class _InputIterator,
          class _Allocator,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value, void>,
          class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multiset(_InputIterator, _InputIterator, _Allocator)
    -> multiset<__iter_value_type<_InputIterator>, less<__iter_value_type<_InputIterator>>, _Allocator>;
# 1394 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Allocator, class = enable_if_t<__is_allocator<_Allocator>::value, void>>
multiset(initializer_list<_Key>, _Allocator) -> multiset<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)
    : __tree_(std::move(__s.__tree_), __a) {
  if (__a != __s.get_allocator()) {
    const_iterator __e = cend();
    while (!__s.empty())
      insert(__e, std::move(__s.__tree_.remove(__s.begin())->__value_));
  }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return __x.size() == __y.size() && std::equal(__x.begin(), __x.end(), __y.begin());
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x, const multiset<_Key, _Compare, _Allocator>& __y) {
  return !(__y < __x);
}
# 1461 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Compare, class _Allocator>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
swap(multiset<_Key, _Compare, _Allocator>& __x, multiset<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1476 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
}}
# 1476 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic pop


#pragma clang diagnostic push
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 1479 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
namespace pmr {
template <class _KeyT, class _CompareT = std::less<_KeyT>>
using set = std::set<_KeyT, _CompareT, polymorphic_allocator<_KeyT>>;

template <class _KeyT, class _CompareT = std::less<_KeyT>>
using multiset = std::multiset<_KeyT, _CompareT, polymorphic_allocator<_KeyT>>;
}
}}
# 1487 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
#pragma clang diagnostic pop
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2




namespace llvm {
class raw_ostream;
}

namespace Fortran::parser {

std::string DirectoryName(std::string path);
std::optional<std::string> LocateSourceFile(
    std::string name, const std::list<std::string> &searchPath);
std::vector<std::string> LocateSourceFileAll(
    std::string name, const std::vector<std::string> &searchPath);

class SourceFile;

struct SourcePosition {
  common::Reference<const SourceFile> sourceFile;
  common::Reference<const std::string>
      path;
  int line, column;
  int trueLineNumber;
};

class SourceFile {
public:
  explicit SourceFile(Encoding e) : encoding_{e} {}
  ~SourceFile();
  const std::string &path() const { return path_; }
  llvm::ArrayRef<char> content() const {
    return buf_->getBuffer().slice(bom_end_, buf_end_ - bom_end_);
  }
  std::size_t bytes() const { return content().size(); }
  std::size_t lines() const { return lineStart_.size(); }
  Encoding encoding() const { return encoding_; }

  bool Open(std::string path, llvm::raw_ostream &error);
  bool ReadStandardInput(llvm::raw_ostream &error);
  void Close();
  SourcePosition GetSourcePosition(std::size_t) const;
  std::size_t GetLineStartOffset(int lineNumber) const {
    return lineStart_.at(lineNumber - 1);
  }
  const std::string &SavePath(std::string &&);
  void LineDirective(int trueLineNumber, const std::string &, int);
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct SourcePositionOrigin {
    const std::string &path;
    int line;
  };

  void ReadFile();
  void IdentifyPayload();
  void RecordLineStarts();

  std::string path_;
  std::unique_ptr<llvm::WritableMemoryBuffer> buf_;
  std::vector<std::size_t> lineStart_;
  std::size_t bom_end_{0};
  std::size_t buf_end_;
  Encoding encoding_;
  std::set<std::string> distinctPaths_;
  std::map<std::size_t, SourcePositionOrigin> origins_;
};
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 2
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h"
namespace Fortran::parser {
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h"
class AllSources;
class AllCookedSources;

class Provenance {
public:
  Provenance() {}
  Provenance(std::size_t offset) : offset_{offset} { ((offset > 0) || (Fortran::common::die("CHECK(" "offset > 0" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 55), false)); }
  Provenance(const Provenance &that) = default;
  Provenance(Provenance &&that) = default;
  Provenance &operator=(const Provenance &that) = default;
  Provenance &operator=(Provenance &&that) = default;

  std::size_t offset() const { return offset_; }

  Provenance operator+(ptrdiff_t n) const {
    ((n > -static_cast<ptrdiff_t>(offset_)) || (Fortran::common::die("CHECK(" "n > -static_cast<ptrdiff_t>(offset_)" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 64), false));
    return {offset_ + static_cast<std::size_t>(n)};
  }
  Provenance operator+(std::size_t n) const { return {offset_ + n}; }
  std::size_t operator-(Provenance that) const {
    ((that <= *this) || (Fortran::common::die("CHECK(" "that <= *this" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 69), false));
    return offset_ - that.offset_;
  }
  bool operator<(Provenance that) const { return offset_ < that.offset_; }
  bool operator<=(Provenance that) const { return !(that < *this); }
  bool operator==(Provenance that) const { return offset_ == that.offset_; }
  bool operator!=(Provenance that) const { return !(*this == that); }

private:
  std::size_t offset_{0};
};

using ProvenanceRange = common::Interval<Provenance>;






class ProvenanceRangeToOffsetMappings {
public:
  ProvenanceRangeToOffsetMappings();
  ~ProvenanceRangeToOffsetMappings();
  bool empty() const { return map_.empty(); }
  void Put(ProvenanceRange, std::size_t offset);
  std::optional<std::size_t> Map(ProvenanceRange) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:



  struct WhollyPrecedes {
    bool operator()(ProvenanceRange, ProvenanceRange) const;
  };

  std::multimap<ProvenanceRange, std::size_t, WhollyPrecedes> map_;
};





class OffsetToProvenanceMappings {
public:
  OffsetToProvenanceMappings() {}
  void clear();
  void swap(OffsetToProvenanceMappings &);
  void shrink_to_fit();
  std::size_t SizeInBytes() const;
  void Put(ProvenanceRange);
  void Put(const OffsetToProvenanceMappings &);
  ProvenanceRange Map(std::size_t at) const;
  void RemoveLastBytes(std::size_t);
  ProvenanceRangeToOffsetMappings Invert(const AllSources &) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct ContiguousProvenanceMapping {
    std::size_t start;
    ProvenanceRange range;
  };



  std::vector<ContiguousProvenanceMapping> provenanceMap_;
};



class AllSources {
public:
  AllSources();
  ~AllSources();

  std::size_t size() const { return range_.size(); }
  const char &operator[](Provenance) const;
  Encoding encoding() const { return encoding_; }
  AllSources &set_encoding(Encoding e) {
    encoding_ = e;
    return *this;
  }

  void ClearSearchPath();
  void AppendSearchPathDirectory(std::string);
  const SourceFile *OpenPath(std::string path, llvm::raw_ostream &error);
  const SourceFile *Open(std::string path, llvm::raw_ostream &error,
      std::optional<std::string> &&prependPath = std::nullopt);
  const SourceFile *ReadStandardInput(llvm::raw_ostream &error);

  ProvenanceRange AddIncludedFile(
      const SourceFile &, ProvenanceRange, bool isModule = false);
  ProvenanceRange AddMacroCall(
      ProvenanceRange def, ProvenanceRange use, const std::string &expansion);
  ProvenanceRange AddCompilerInsertion(std::string);



  Provenance GetReplacedProvenance(Provenance) const;

  bool IsValid(Provenance at) const { return range_.Contains(at); }
  bool IsValid(ProvenanceRange range) const {
    return range.size() > 0 && range_.Contains(range);
  }
  void setShowColors(bool showColors) { showColors_ = showColors; }
  bool getShowColors() const { return showColors_; }
  std::optional<ProvenanceRange> GetInclusionInfo(
      const std::optional<ProvenanceRange> &) const;
  void EmitMessage(llvm::raw_ostream &, const std::optional<ProvenanceRange> &,
      const std::string &message, const std::string &prefix,
      llvm::raw_ostream::Colors color, bool echoSourceLine = false) const;
  const SourceFile *GetSourceFile(
      Provenance, std::size_t *offset = nullptr, bool topLevel = false) const;
  const char *GetSource(ProvenanceRange) const;
  std::optional<SourcePosition> GetSourcePosition(Provenance) const;
  std::optional<ProvenanceRange> GetFirstFileProvenance() const;
  std::string GetPath(Provenance, bool topLevel = false) const;
  int GetLineNumber(Provenance) const;
  Provenance CompilerInsertionProvenance(char ch);
  ProvenanceRange IntersectionWithSourceFiles(ProvenanceRange) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct Inclusion {
    const SourceFile &source;
    bool isModule{false};
  };
  struct Macro {
    ProvenanceRange definition;
    std::string expansion;
  };
  struct CompilerInsertion {
    std::string text;
  };

  struct Origin {
    Origin(ProvenanceRange, const SourceFile &);
    Origin(ProvenanceRange, const SourceFile &, ProvenanceRange,
        bool isModule = false);
    Origin(ProvenanceRange, ProvenanceRange def, ProvenanceRange use,
        const std::string &expansion);
    Origin(ProvenanceRange, const std::string &);

    const char &operator[](std::size_t) const;

    std::variant<Inclusion, Macro, CompilerInsertion> u;
    ProvenanceRange covers, replaces;
  };

  const Origin &MapToOrigin(Provenance) const;


  std::vector<Origin> origin_;
  ProvenanceRange range_;
  std::map<char, Provenance> compilerInsertionProvenance_;
  std::vector<std::unique_ptr<SourceFile>> ownedSourceFiles_;
  std::list<std::string> searchPath_;
  Encoding encoding_{Encoding::UTF_8};
  bool showColors_{false};
};




class CookedSource {
public:
  explicit CookedSource(AllSources &allSources) : allSources_{allSources} {};

  int number() const { return number_; }
  void set_number(int n) { number_ = n; }

  CharBlock AsCharBlock() const { return CharBlock{data_}; }
  std::optional<ProvenanceRange> GetProvenanceRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlock(ProvenanceRange) const;



  std::size_t Put(const char *data, std::size_t bytes) {
    return buffer_.Put(data, bytes);
  }
  std::size_t Put(const std::string &s) { return buffer_.Put(s); }
  std::size_t Put(char ch) { return buffer_.Put(&ch, 1); }
  std::size_t Put(char ch, Provenance p) {
    provenanceMap_.Put(ProvenanceRange{p, 1});
    return buffer_.Put(&ch, 1);
  }

  void PutProvenance(Provenance p) { provenanceMap_.Put(ProvenanceRange{p}); }
  void PutProvenance(ProvenanceRange pr) { provenanceMap_.Put(pr); }
  void PutProvenanceMappings(const OffsetToProvenanceMappings &pm) {
    provenanceMap_.Put(pm);
  }

  void MarkPossibleFixedFormContinuation() {
    possibleFixedFormContinuations_.push_back(BufferedBytes());
  }

  std::size_t BufferedBytes() const;
  void Marshal(AllCookedSources &);
  void CompileProvenanceRangeToOffsetMappings(AllSources &);
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  AllSources &allSources_;
  int number_{0};
  CharBuffer buffer_;
  std::string data_;
  OffsetToProvenanceMappings provenanceMap_;
  ProvenanceRangeToOffsetMappings invertedMap_;
  std::list<std::size_t> possibleFixedFormContinuations_;
};

class AllCookedSources {
public:
  explicit AllCookedSources(AllSources &);
  ~AllCookedSources();

  AllSources &allSources() { return allSources_; }
  const AllSources &allSources() const { return allSources_; }

  CookedSource &NewCookedSource();

  const CookedSource *Find(CharBlock) const;
  const CookedSource *Find(const char *p) const { return Find(CharBlock{p}); }

  bool IsValid(ProvenanceRange r) const { return allSources_.IsValid(r); }

  std::optional<ProvenanceRange> GetProvenanceRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlockFromLineAndColumns(
      int line, int startColumn, int endColumn) const;
  std::optional<std::pair<SourcePosition, SourcePosition>>
      GetSourcePositionRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlock(ProvenanceRange) const;
  void Dump(llvm::raw_ostream &) const;


  bool Precedes(CharBlock, CharBlock) const;


  void Register(CookedSource &);

private:
  AllSources &allSources_;
  std::list<CookedSource> cooked_;
  std::map<CharBlock, const CookedSource &, CharBlockPointerComparator> index_;
};

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference-counted.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference-counted.h"
namespace Fortran::common {


template <typename A> class ReferenceCounted {
public:
  ReferenceCounted() {}
  int references() const { return references_; }
  void TakeReference() { ++references_; }
  void DropReference() {
    if (--references_ == 0) {
      delete static_cast<A *>(this);
    }
  }

private:
  int references_{0};
};


template <typename A> class CountedReference {
public:
  using type = A;
  CountedReference() {}
  CountedReference(type *m) : p_{m} { Take(); }
  CountedReference(const CountedReference &c) : p_{c.p_} { Take(); }
  CountedReference(CountedReference &&c) : p_{c.p_} { c.p_ = nullptr; }
  CountedReference &operator=(const CountedReference &c) {
    c.Take();
    Drop();
    p_ = c.p_;
    return *this;
  }
  CountedReference &operator=(CountedReference &&c) {
    A *p{c.p_};
    c.p_ = nullptr;
    Drop();
    p_ = p;
    return *this;
  }
  ~CountedReference() { Drop(); }
  operator bool() const { return p_ != nullptr; }
  type *get() const { return p_; }
  type &operator*() const { return *p_; }
  type *operator->() const { return p_; }

private:
  void Take() const {
    if (p_) {
      p_->TakeReference();
    }
  }
  void Drop() {
    if (p_) {
      p_->DropReference();
      p_ = nullptr;
    }
  }

  type *p_{nullptr};
};
}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/restorer.h" 1
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/restorer.h"
namespace Fortran::common {
template <typename A> class Restorer {
public:
  explicit Restorer(A &p, A original)
      : p_{p}, original_{std::move(original)} {}
               ~Restorer() { p_ = std::move(original_); }



  Restorer(const Restorer &) = delete;
  Restorer(Restorer &&that) = delete;
  const Restorer &operator=(const Restorer &) = delete;
  const Restorer &operator=(Restorer &&that) = delete;

private:
  A &p_;
  A original_;
};

template <typename A, typename B>
             common::IfNoLvalue<Restorer<A>, B> ScopedSet(A &to, B &&from) {
  A original{std::move(to)};
  to = std::move(from);
  return Restorer<A>{to, std::move(original)};
}
template <typename A, typename B>
             common::IfNoLvalue<Restorer<A>, B> ScopedSet(
    A &to, const B &from) {
  A original{std::move(to)};
  to = from;
  return Restorer<A>{to, std::move(original)};
}
}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran-features.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran-features.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran-consts.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran-consts.h"
namespace Fortran::common {



enum class TypeCategory { Integer, Unsigned, Real, Complex, Character, Logical, Derived }; [[maybe_unused]] static constexpr std::size_t TypeCategory_enumSize{ ::Fortran::common::CountEnumNames("Integer, Unsigned, Real, Complex, Character, Logical, Derived")}; [[maybe_unused]] static inline std::size_t EnumToInt(TypeCategory e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(TypeCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<TypeCategory_enumSize>("Integer, Unsigned, Real, Complex, Character, Logical, Derived")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachTypeCategory(std::function<void(TypeCategory)> f) { for (std::size_t i{0}; i < TypeCategory_enumSize; ++i) { f(static_cast<TypeCategory>(i)); } }

enum class VectorElementCategory { Integer, Unsigned, Real }; [[maybe_unused]] static constexpr std::size_t VectorElementCategory_enumSize{ ::Fortran::common::CountEnumNames("Integer, Unsigned, Real")}; [[maybe_unused]] static inline std::size_t EnumToInt(VectorElementCategory e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(VectorElementCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<VectorElementCategory_enumSize>("Integer, Unsigned, Real")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachVectorElementCategory(std::function<void(VectorElementCategory)> f) { for (std::size_t i{0}; i < VectorElementCategory_enumSize; ++i) { f(static_cast<VectorElementCategory>(i)); } }

enum class IoStmtKind { None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write }; [[maybe_unused]] static constexpr std::size_t IoStmtKind_enumSize{ ::Fortran::common::CountEnumNames("None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write")}; [[maybe_unused]] static inline std::size_t EnumToInt(IoStmtKind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(IoStmtKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IoStmtKind_enumSize>("None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIoStmtKind(std::function<void(IoStmtKind)> f) { for (std::size_t i{0}; i < IoStmtKind_enumSize; ++i) { f(static_cast<IoStmtKind>(i)); } }



enum class DefinedIo { ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted }; [[maybe_unused]] static constexpr std::size_t DefinedIo_enumSize{ ::Fortran::common::CountEnumNames("ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted")}; [[maybe_unused]] static inline std::size_t EnumToInt(DefinedIo e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(DefinedIo e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DefinedIo_enumSize>("ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachDefinedIo(std::function<void(DefinedIo)> f) { for (std::size_t i{0}; i < DefinedIo_enumSize; ++i) { f(static_cast<DefinedIo>(i)); } }



static constexpr int maxRank{15};





enum class RoundingMode : std::uint8_t {
  ToZero,
  TiesToEven,
  Up,
  Down,
  TiesAwayFromZero,
};

}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/bit-population-count.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/bit-population-count.h"
namespace Fortran::common {

template <typename INT,
    std::enable_if_t<(sizeof(INT) > 4 && sizeof(INT) <= 8), int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x5555555555555555) + ((x >> 1) & 0x5555555555555555);

  x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);

  x = (x & 0x0f0f0f0f0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f0f0f0f0f);

  x = (x & 0x001f001f001f001f) + ((x >> 8) & 0x001f001f001f001f);

  x = (x & 0x0000003f0000003f) + ((x >> 16) & 0x0000003f0000003f);

  return (x & 0x7f) + (x >> 32);
}

template <typename INT,
    std::enable_if_t<(sizeof(INT) > 2 && sizeof(INT) <= 4), int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x55555555) + ((x >> 1) & 0x55555555);

  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);

  x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);

  x = (x & 0x001f001f) + ((x >> 8) & 0x001f001f);

  return (x & 0x3f) + (x >> 16);
}

template <typename INT, std::enable_if_t<sizeof(INT) == 2, int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x5555) + ((x >> 1) & 0x5555);

  x = (x & 0x3333) + ((x >> 2) & 0x3333);

  x = (x & 0x0f0f) + ((x >> 4) & 0x0f0f);

  return (x & 0x1f) + (x >> 8);
}

template <typename INT, std::enable_if_t<sizeof(INT) == 1, int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x55) + ((x >> 1) & 0x55);

  x = (x & 0x33) + ((x >> 2) & 0x33);

  return (x & 0xf) + (x >> 4);
}

template <typename INT> inline constexpr bool Parity(INT x) {
  return BitPopulationCount(x) & 1;
}



template <typename INT> inline constexpr int TrailingZeroBitCount(INT x) {
  if ((x & 1) != 0) {
    return 0;
  } else if (x == 0) {
    return 8 * sizeof x;
  } else {
    return BitPopulationCount(static_cast<INT>(x ^ (x - 1))) - 1;
  }
}
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h" 1
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h"
namespace Fortran::common {
namespace {
# 38 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h"
static constexpr std::uint64_t deBruijn{0x07edd5e59a4e28c2};
static constexpr std::uint8_t mapping[64]{63, 0, 58, 1, 59, 47, 53, 2, 60, 39,
    48, 27, 54, 33, 42, 3, 61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43,
    14, 22, 4, 62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,
    56, 45, 25, 31, 35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5};
}

inline constexpr int LeadingZeroBitCount(std::uint64_t x) {
  if (x == 0) {
    return 64;
  } else {
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    x -= x >> 1;




    int base2Log{mapping[(x * deBruijn) >> 58]};
    return 63 - base2Log;
  }
}

inline constexpr int LeadingZeroBitCount(std::uint32_t x) {
  return LeadingZeroBitCount(static_cast<std::uint64_t>(x)) - 32;
}

inline constexpr int LeadingZeroBitCount(std::uint16_t x) {
  return LeadingZeroBitCount(static_cast<std::uint64_t>(x)) - 48;
}

namespace {
static constexpr std::uint8_t eightBitLeadingZeroBitCount[256]{8, 7, 6, 6, 5, 5,
    5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
}

inline constexpr int LeadingZeroBitCount(std::uint8_t x) {
  return eightBitLeadingZeroBitCount[x];
}

template <typename A> inline constexpr int BitsNeededFor(A x) {
  return 8 * sizeof x - LeadingZeroBitCount(x);
}
}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h" 2



namespace Fortran::common {

template <bool IS_SIGNED = false> class Int128 {
public:
  constexpr Int128() {}


  constexpr Int128(unsigned n) : low_{n} {}
  constexpr Int128(unsigned long n) : low_{n} {}
  constexpr Int128(unsigned long long n) : low_{n} {}
  constexpr Int128(int n) {
    low_ = static_cast<std::uint64_t>(n);
    high_ = -static_cast<std::uint64_t>(n < 0);
  }
  constexpr Int128(long n) {
    low_ = static_cast<std::uint64_t>(n);
    high_ = -static_cast<std::uint64_t>(n < 0);
  }
  constexpr Int128(long long n) {
    low_ = static_cast<std::uint64_t>(n);
    high_ = -static_cast<std::uint64_t>(n < 0);
  }
  constexpr Int128(const Int128 &) = default;
  constexpr Int128(Int128 &&) = default;
  constexpr Int128 &operator=(const Int128 &) = default;
  constexpr Int128 &operator=(Int128 &&) = default;

  explicit constexpr Int128(const Int128<!IS_SIGNED> &n)
      : low_{n.low()}, high_{n.high()} {}
  explicit constexpr Int128(Int128<!IS_SIGNED> &&n)
      : low_{n.low()}, high_{n.high()} {}

  constexpr Int128 operator+() const { return *this; }
  constexpr Int128 operator~() const { return {~high_, ~low_}; }
  constexpr Int128 operator-() const { return ~*this + 1; }
  constexpr bool operator!() const { return !low_ && !high_; }
  constexpr explicit operator bool() const { return low_ || high_; }
  constexpr explicit operator std::uint64_t() const { return low_; }
  constexpr explicit operator std::int64_t() const { return low_; }
  constexpr explicit operator int() const { return static_cast<int>(low_); }

  constexpr std::uint64_t high() const { return high_; }
  constexpr std::uint64_t low() const { return low_; }

  constexpr Int128 operator++( ) {
    *this += 1;
    return *this;
  }
  constexpr Int128 operator++(int ) {
    Int128 result{*this};
    *this += 1;
    return result;
  }
  constexpr Int128 operator--( ) {
    *this -= 1;
    return *this;
  }
  constexpr Int128 operator--(int ) {
    Int128 result{*this};
    *this -= 1;
    return result;
  }

  constexpr Int128 operator&(Int128 that) const {
    return {high_ & that.high_, low_ & that.low_};
  }
  constexpr Int128 operator|(Int128 that) const {
    return {high_ | that.high_, low_ | that.low_};
  }
  constexpr Int128 operator^(Int128 that) const {
    return {high_ ^ that.high_, low_ ^ that.low_};
  }

  constexpr Int128 operator<<(Int128 that) const {
    if (that >= 128) {
      return {};
    } else if (that == 0) {
      return *this;
    } else {
      std::uint64_t n{that.low_};
      if (n >= 64) {
        return {low_ << (n - 64), 0};
      } else {
        return {(high_ << n) | (low_ >> (64 - n)), low_ << n};
      }
    }
  }
  constexpr Int128 operator>>(Int128 that) const {
    if (that >= 128) {
      return {};
    } else if (that == 0) {
      return *this;
    } else {
      std::uint64_t n{that.low_};
      if (n >= 64) {
        return {0, high_ >> (n - 64)};
      } else {
        return {high_ >> n, (high_ << (64 - n)) | (low_ >> n)};
      }
    }
  }

  constexpr Int128 operator+(Int128 that) const {
    std::uint64_t lower{(low_ & ~topBit) + (that.low_ & ~topBit)};
    bool carry{((lower >> 63) + (low_ >> 63) + (that.low_ >> 63)) > 1};
    return {high_ + that.high_ + carry, low_ + that.low_};
  }
  constexpr Int128 operator-(Int128 that) const { return *this + -that; }

  constexpr Int128 operator*(Int128 that) const {
    std::uint64_t mask32{0xffffffff};
    if (high_ == 0 && that.high_ == 0) {
      std::uint64_t x0{low_ & mask32}, x1{low_ >> 32};
      std::uint64_t y0{that.low_ & mask32}, y1{that.low_ >> 32};
      Int128 x0y0{x0 * y0}, x0y1{x0 * y1};
      Int128 x1y0{x1 * y0}, x1y1{x1 * y1};
      return x0y0 + ((x0y1 + x1y0) << 32) + (x1y1 << 64);
    } else {
      std::uint64_t x0{low_ & mask32}, x1{low_ >> 32}, x2{high_ & mask32},
          x3{high_ >> 32};
      std::uint64_t y0{that.low_ & mask32}, y1{that.low_ >> 32},
          y2{that.high_ & mask32}, y3{that.high_ >> 32};
      Int128 x0y0{x0 * y0}, x0y1{x0 * y1}, x0y2{x0 * y2}, x0y3{x0 * y3};
      Int128 x1y0{x1 * y0}, x1y1{x1 * y1}, x1y2{x1 * y2};
      Int128 x2y0{x2 * y0}, x2y1{x2 * y1};
      Int128 x3y0{x3 * y0};
      return x0y0 + ((x0y1 + x1y0) << 32) + ((x0y2 + x1y1 + x2y0) << 64) +
          ((x0y3 + x1y2 + x2y1 + x3y0) << 96);
    }
  }

  constexpr Int128 operator/(Int128 that) const {
    int j{LeadingZeroes()};
    Int128 bits{*this};
    bits <<= j;
    Int128 numerator{};
    Int128 quotient{};
    for (; j < 128; ++j) {
      numerator <<= 1;
      if (bits.high_ & topBit) {
        numerator.low_ |= 1;
      }
      bits <<= 1;
      quotient <<= 1;
      if (numerator >= that) {
        ++quotient;
        numerator -= that;
      }
    }
    return quotient;
  }

  constexpr Int128 operator%(Int128 that) const {
    int j{LeadingZeroes()};
    Int128 bits{*this};
    bits <<= j;
    Int128 remainder{};
    for (; j < 128; ++j) {
      remainder <<= 1;
      if (bits.high_ & topBit) {
        remainder.low_ |= 1;
      }
      bits <<= 1;
      if (remainder >= that) {
        remainder -= that;
      }
    }
    return remainder;
  }

  constexpr bool operator<(Int128 that) const {
    if (IS_SIGNED && (high_ ^ that.high_) & topBit) {
      return (high_ & topBit) != 0;
    }
    return high_ < that.high_ || (high_ == that.high_ && low_ < that.low_);
  }
  constexpr bool operator<=(Int128 that) const { return !(*this > that); }
  constexpr bool operator==(Int128 that) const {
    return low_ == that.low_ && high_ == that.high_;
  }
  constexpr bool operator!=(Int128 that) const { return !(*this == that); }
  constexpr bool operator>=(Int128 that) const { return that <= *this; }
  constexpr bool operator>(Int128 that) const { return that < *this; }

  constexpr Int128 &operator&=(const Int128 &that) {
    *this = *this & that;
    return *this;
  }
  constexpr Int128 &operator|=(const Int128 &that) {
    *this = *this | that;
    return *this;
  }
  constexpr Int128 &operator^=(const Int128 &that) {
    *this = *this ^ that;
    return *this;
  }
  constexpr Int128 &operator<<=(const Int128 &that) {
    *this = *this << that;
    return *this;
  }
  constexpr Int128 &operator>>=(const Int128 &that) {
    *this = *this >> that;
    return *this;
  }
  constexpr Int128 &operator+=(const Int128 &that) {
    *this = *this + that;
    return *this;
  }
  constexpr Int128 &operator-=(const Int128 &that) {
    *this = *this - that;
    return *this;
  }
  constexpr Int128 &operator*=(const Int128 &that) {
    *this = *this * that;
    return *this;
  }
  constexpr Int128 &operator/=(const Int128 &that) {
    *this = *this / that;
    return *this;
  }
  constexpr Int128 &operator%=(const Int128 &that) {
    *this = *this % that;
    return *this;
  }

private:
  constexpr Int128(std::uint64_t hi, std::uint64_t lo) {
    low_ = lo;
    high_ = hi;
  }
  constexpr int LeadingZeroes() const {
    if (high_ == 0) {
      return 64 + LeadingZeroBitCount(low_);
    } else {
      return LeadingZeroBitCount(high_);
    }
  }

  static constexpr std::uint64_t topBit{std::uint64_t{1} << 63};


  std::uint64_t low_{0}, high_{0};





};

using UnsignedInt128 = Int128<false>;
using SignedInt128 = Int128<true>;




using uint128_t = __uint128_t;
using int128_t = __int128_t;






template <int BITS> struct HostUnsignedIntTypeHelper {
  using type = std::conditional_t<(BITS <= 8), std::uint8_t,
      std::conditional_t<(BITS <= 16), std::uint16_t,
          std::conditional_t<(BITS <= 32), std::uint32_t,
              std::conditional_t<(BITS <= 64), std::uint64_t, uint128_t>>>>;
};
template <int BITS> struct HostSignedIntTypeHelper {
  using type = std::conditional_t<(BITS <= 8), std::int8_t,
      std::conditional_t<(BITS <= 16), std::int16_t,
          std::conditional_t<(BITS <= 32), std::int32_t,
              std::conditional_t<(BITS <= 64), std::int64_t, int128_t>>>>;
};
template <int BITS>
using HostUnsignedIntType = typename HostUnsignedIntTypeHelper<BITS>::type;
template <int BITS>
using HostSignedIntType = typename HostSignedIntTypeHelper<BITS>::type;

}
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 2






namespace Fortran::common {

template <int BITS> class BitSet {
  static_assert(BITS > 0 && BITS <= 128);
  using Word = HostUnsignedIntType<(BITS <= 32 ? 32 : BITS)>;
  static constexpr Word allBits{
      ~static_cast<Word>(0) >> (8 * sizeof(Word) - BITS)};

  constexpr BitSet(Word b) : bits_{b} {}

public:
  constexpr BitSet() {}
  constexpr BitSet(const std::initializer_list<int> &xs) {
    for (auto x : xs) {
      set(x);
    }
  }
  constexpr BitSet(const BitSet &) = default;
  constexpr BitSet(BitSet &&) = default;
  constexpr BitSet &operator=(const BitSet &) = default;
  constexpr BitSet &operator=(BitSet &&) = default;

  constexpr BitSet &operator&=(const BitSet &that) {
    bits_ &= that.bits_;
    return *this;
  }
  constexpr BitSet &operator&=(BitSet &&that) {
    bits_ &= that.bits_;
    return *this;
  }
  constexpr BitSet &operator^=(const BitSet &that) {
    bits_ ^= that.bits_;
    return *this;
  }
  constexpr BitSet &operator^=(BitSet &&that) {
    bits_ ^= that.bits_;
    return *this;
  }
  constexpr BitSet &operator|=(const BitSet &that) {
    bits_ |= that.bits_;
    return *this;
  }
  constexpr BitSet &operator|=(BitSet &&that) {
    bits_ |= that.bits_;
    return *this;
  }

  constexpr BitSet operator~() const { return ~bits_; }
  constexpr BitSet operator&(const BitSet &that) const {
    return bits_ & that.bits_;
  }
  constexpr BitSet operator&(BitSet &&that) const { return bits_ & that.bits_; }
  constexpr BitSet operator^(const BitSet &that) const {
    return bits_ ^ that.bits_;
  }
  constexpr BitSet operator^(BitSet &&that) const { return bits_ & that.bits_; }
  constexpr BitSet operator|(const BitSet &that) const {
    return bits_ | that.bits_;
  }
  constexpr BitSet operator|(BitSet &&that) const { return bits_ | that.bits_; }

  constexpr bool operator==(const BitSet &that) const {
    return bits_ == that.bits_;
  }
  constexpr bool operator==(BitSet &&that) const { return bits_ == that.bits_; }
  constexpr bool operator!=(const BitSet &that) const {
    return bits_ != that.bits_;
  }
  constexpr bool operator!=(BitSet &&that) const { return bits_ != that.bits_; }

  static constexpr std::size_t size() { return BITS; }
  constexpr bool test(std::size_t x) const {
    return x < BITS && ((bits_ >> x) & 1) != 0;
  }

  constexpr bool all() const { return bits_ == allBits; }
  constexpr bool any() const { return bits_ != 0; }
  constexpr bool none() const { return bits_ == 0; }

  constexpr std::size_t count() const { return BitPopulationCount(bits_); }

  constexpr BitSet &set() {
    bits_ = allBits;
    return *this;
  }
  constexpr BitSet set(std::size_t x, bool value = true) {
    if (!value) {
      return reset(x);
    } else {
      bits_ |= static_cast<Word>(1) << x;
      return *this;
    }
  }
  constexpr BitSet &reset() {
    bits_ = 0;
    return *this;
  }
  constexpr BitSet &reset(std::size_t x) {
    bits_ &= ~(static_cast<Word>(1) << x);
    return *this;
  }
  constexpr BitSet &flip() {
    bits_ ^= allBits;
    return *this;
  }
  constexpr BitSet &flip(std::size_t x) {
    bits_ ^= static_cast<Word>(1) << x;
    return *this;
  }

  constexpr std::optional<std::size_t> LeastElement() const {
    if (bits_ == 0) {
      return std::nullopt;
    } else {
      return {TrailingZeroBitCount(bits_)};
    }
  }

  Word bits() const { return bits_; }

private:
  Word bits_{0};
};
}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 1 3
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 1 3
# 19 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3


#pragma clang diagnostic push
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 21 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _CharT>
using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;

}}
# 26 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__type_traits/is_char_like_type.h" 3
#pragma clang diagnostic pop
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3

#pragma clang diagnostic push
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> > {
  static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_[_N_words];

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit constexpr __bitset(unsigned long long __v) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference __make_ref(size_t __pos) noexcept {
    return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr const_reference __make_ref(size_t __pos) const noexcept {
    return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __make_iter(size_t __pos) noexcept {
    return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator __make_iter(size_t __pos) const noexcept {
    return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator&=(const __bitset& __v) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator|=(const __bitset& __v) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator^=(const __bitset& __v) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void flip() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong() const {
    return to_ulong(integral_constant < bool, _Size< sizeof(unsigned long) * 8>());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong() const {
    return to_ullong(integral_constant < bool, _Size< sizeof(unsigned long long) * 8>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool all() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool any() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t __hash_code() const noexcept;

private:




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong(false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong(true_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong(false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong(true_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong(true_type, false_type) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline constexpr __bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 276 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
template <size_t _N_words, size_t _Size>
inline constexpr __bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
{



}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept {
  for (size_type __i = 0; __i < _N_words; ++__i)
    __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __bitset<_N_words, _Size>::flip() noexcept {

  size_type __n = _Size;
  __storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    *__p = ~*__p;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    __storage_type __b = *__p & __m;
    *__p &= ~__m;
    *__p |= ~__b & __m;
  }
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i = std::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ulong overflow error");

  return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const {
  const_iterator __e = __make_iter(_Size);
  const_iterator __i = std::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
  if (__i != __e)
    __throw_overflow_error("bitset to_ullong overflow error");

  return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const {
  return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const {
  return __first_[0];
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const {
  unsigned long long __r = __first_[0];
#pragma clang diagnostic push

  for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
    __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
#pragma clang diagnostic pop
  return __r;
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __bitset<_N_words, _Size>::all() const noexcept {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (~*__p)
      return false;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (~*__p & __m)
      return false;
  }
  return true;
}

template <size_t _N_words, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __bitset<_N_words, _Size>::any() const noexcept {

  size_type __n = _Size;
  __const_storage_pointer __p = __first_;
  for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
    if (*__p)
      return true;

  if (__n > 0) {
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
    if (*__p & __m)
      return true;
  }
  return false;
}

template <size_t _N_words, size_t _Size>
inline size_t __bitset<_N_words, _Size>::__hash_code() const noexcept {
  size_t __h = 0;
  for (size_type __i = 0; __i < _N_words; ++__i)
    __h ^= __first_[__i];
  return __h;
}

template <size_t _Size>
class __bitset<1, _Size> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  __storage_type __first_;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit constexpr __bitset(unsigned long long __v) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference __make_ref(size_t __pos) noexcept {
    return reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr const_reference __make_ref(size_t __pos) const noexcept {
    return const_reference(&__first_, __storage_type(1) << __pos);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __make_iter(size_t __pos) noexcept {
    return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator __make_iter(size_t __pos) const noexcept {
    return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator&=(const __bitset& __v) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator|=(const __bitset& __v) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator^=(const __bitset& __v) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void flip() noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong() const;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool all() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool any() const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline constexpr __bitset<1, _Size>::__bitset() noexcept : __first_(0) {}

template <size_t _Size>
inline constexpr __bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(_Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                        : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)) {}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept {
  __first_ &= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept {
  __first_ |= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept {
  __first_ ^= __v.__first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __bitset<1, _Size>::flip() noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  __first_ = ~__first_;
  __first_ &= __m;
}

template <size_t _Size>
inline unsigned long __bitset<1, _Size>::to_ulong() const {
  return __first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long __bitset<1, _Size>::to_ullong() const {
  return __first_;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __bitset<1, _Size>::all() const noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return !(~__first_ & __m);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool __bitset<1, _Size>::any() const noexcept {
  __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
  return __first_ & __m;
}

template <size_t _Size>
inline size_t __bitset<1, _Size>::__hash_code() const noexcept {
  return __first_;
}

template <>
class __bitset<0, 0> {
public:
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;
  typedef size_type __storage_type;

protected:
  typedef __bitset __self;
  typedef __storage_type* __storage_pointer;
  typedef const __storage_type* __const_storage_pointer;
  static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

  friend class __bit_reference<__bitset>;
  friend class __bit_const_reference<__bitset>;
  friend class __bit_iterator<__bitset, false>;
  friend class __bit_iterator<__bitset, true>;
  friend struct __bit_array<__bitset>;

  typedef __bit_reference<__bitset> reference;
  typedef __bit_const_reference<__bitset> const_reference;
  typedef __bit_iterator<__bitset, false> iterator;
  typedef __bit_iterator<__bitset, true> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr __bitset() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit constexpr __bitset(unsigned long long) noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference __make_ref(size_t) noexcept {
    return reference(nullptr, 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr const_reference __make_ref(size_t) const noexcept {
    return const_reference(nullptr, 1);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __make_iter(size_t) noexcept {
    return iterator(nullptr, 0);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator __make_iter(size_t) const noexcept {
    return const_iterator(nullptr, 0);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator&=(const __bitset&) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator|=(const __bitset&) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void operator^=(const __bitset&) noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void flip() noexcept {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong() const { return 0; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong() const { return 0; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool all() const noexcept { return true; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool any() const noexcept { return false; }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t __hash_code() const noexcept { return 0; }
};

inline constexpr __bitset<0, 0>::__bitset() noexcept {}

inline constexpr __bitset<0, 0>::__bitset(unsigned long long) noexcept {}

template <size_t _Size>
class bitset;
template <size_t _Size>
struct hash<bitset<_Size> >;

template <size_t _Size>
class bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size> {
public:
  static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
  typedef __bitset<__n_words, _Size> base;

public:
  typedef typename base::reference reference;
  typedef typename base::const_reference const_reference;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr bitset() noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr bitset(unsigned long long __v) noexcept : base(__v) {}
  template <class _CharT, __enable_if_t<_IsCharLikeType<_CharT>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit bitset(
      const _CharT* __str,



      typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,

      _CharT __zero = _CharT('0'),
      _CharT __one = _CharT('1')) {

    size_t __rlen = std::min(__n, char_traits<_CharT>::length(__str));
    __init_from_string_view(basic_string_view<_CharT>(__str, __rlen), __zero, __one);
  }
# 652 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
  template <class _CharT, class _Traits, class _Allocator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit bitset(
      const basic_string<_CharT, _Traits, _Allocator>& __str,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __pos = 0,
      typename basic_string<_CharT, _Traits, _Allocator>::size_type __n =
          basic_string<_CharT, _Traits, _Allocator>::npos,
      _CharT __zero = _CharT('0'),
      _CharT __one = _CharT('1')) {
    if (__pos > __str.size())
      std::__throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::min(__n, __str.size() - __pos);
    __init_from_string_view(basic_string_view<_CharT, _Traits>(__str.data() + __pos, __rlen), __zero, __one);
  }


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& operator&=(const bitset& __rhs) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& operator|=(const bitset& __rhs) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& operator^=(const bitset& __rhs) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& operator<<=(size_t __pos) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& operator>>=(size_t __pos) noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& set() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& set(size_t __pos, bool __val = true);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& reset() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& reset(size_t __pos);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset operator~() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& flip() noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset& flip(size_t __pos);





  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr const_reference operator[](size_t __p) const { return base::__make_ref(__p); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator[](size_t __p) { return base::__make_ref(__p); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long to_ulong() const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long to_ullong() const;
  template <class _CharT, class _Traits, class _Allocator>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, _Traits, _Allocator>
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT, class _Traits>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, _Traits, allocator<_CharT> >
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  template <class _CharT>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
  to_string(_CharT __zero = _CharT('0'), _CharT __one = _CharT('1')) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<char, char_traits<char>, allocator<char> >
  to_string(char __zero = '0', char __one = '1') const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t count() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) constexpr size_t size() const noexcept { return _Size; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const bitset& __rhs) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const bitset& __rhs) const noexcept;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool test(size_t __pos) const;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool all() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool any() const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool none() const noexcept { return !any(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset operator<<(size_t __pos) const noexcept;
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset operator>>(size_t __pos) const noexcept;

private:
  template <class _CharT, class _Traits>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
  __init_from_string_view(basic_string_view<_CharT, _Traits> __str, _CharT __zero, _CharT __one) {
    for (size_t __i = 0; __i < __str.size(); ++__i)
      if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
        std::__throw_invalid_argument("bitset string ctor has invalid argument");

    size_t __mp = std::min(__str.size(), _Size);
    size_t __i = 0;
    for (; __i < __mp; ++__i) {
      _CharT __c = __str[__mp - 1 - __i];
      (*this)[__i] = _Traits::eq(__c, __one);
    }
    std::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t __hash_code() const noexcept { return base::__hash_code(); }

  friend struct hash<bitset>;
};

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept {
  base::operator&=(__rhs);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept {
  base::operator|=(__rhs);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept {
  base::operator^=(__rhs);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::operator<<=(size_t __pos) noexcept {
  __pos = std::min(__pos, _Size);
  std::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
  std::fill_n(base::__make_iter(0), __pos, false);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::operator>>=(size_t __pos) noexcept {
  __pos = std::min(__pos, _Size);
  std::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
  std::fill_n(base::__make_iter(_Size - __pos), __pos, false);
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::set() noexcept {
  std::fill_n(base::__make_iter(0), _Size, true);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::set(size_t __pos, bool __val) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset set argument out of range");

  (*this)[__pos] = __val;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::reset() noexcept {
  std::fill_n(base::__make_iter(0), _Size, false);
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::reset(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset reset argument out of range");

  (*this)[__pos] = false;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size> bitset<_Size>::operator~() const noexcept {
  bitset __x(*this);
  __x.flip();
  return __x;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::flip() noexcept {
  base::flip();
  return *this;
}

template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>& bitset<_Size>::flip(size_t __pos) {
  if (__pos >= _Size)
    __throw_out_of_range("bitset flip argument out of range");

  reference __r = base::__make_ref(__pos);
  __r = ~__r;
  return *this;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long bitset<_Size>::to_ulong() const {
  return base::to_ulong();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) unsigned long long bitset<_Size>::to_ullong() const {
  return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
  for (size_t __i = 0; __i != _Size; ++__i) {
    if ((*this)[__i])
      __r[_Size - 1 - __i] = __one;
  }
  return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const {
  return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const {
  return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t bitset<_Size>::count() const noexcept {
  return static_cast<size_t>(std::count(base::__make_iter(0), base::__make_iter(_Size), true));
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept {
  return std::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}



template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool bitset<_Size>::operator!=(const bitset& __rhs) const noexcept {
  return !(*this == __rhs);
}



template <size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool bitset<_Size>::test(size_t __pos) const {
  if (__pos >= _Size)
    __throw_out_of_range("bitset test argument out of range");

  return (*this)[__pos];
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool bitset<_Size>::all() const noexcept {
  return base::all();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool bitset<_Size>::any() const noexcept {
  return base::any();
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept {
  bitset __r = *this;
  __r <<= __pos;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept {
  bitset __r = *this;
  __r >>= __pos;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept {
  bitset<_Size> __r = __x;
  __r &= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept {
  bitset<_Size> __r = __x;
  __r |= __y;
  return __r;
}

template <size_t _Size>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept {
  bitset<_Size> __r = __x;
  __r ^= __y;
  return __r;
}

template <size_t _Size>
struct hash<bitset<_Size> > : public __unary_function<bitset<_Size>, size_t> {
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_t operator()(const bitset<_Size>& __bs) const noexcept { return __bs.__hash_code(); }
};

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

}}
# 959 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
#pragma clang diagnostic pop
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 2






namespace Fortran::common {

template <typename ENUM, std::size_t BITS> class EnumSet {
  static_assert(BITS > 0);

public:


  using bitsetType =
      std::conditional_t<(BITS <= 64), common::BitSet<BITS>, std::bitset<BITS>>;
  using enumerationType = ENUM;

  constexpr EnumSet() {}
  constexpr EnumSet(const std::initializer_list<enumerationType> &enums) {
    for (auto it{enums.begin()}; it != enums.end(); ++it) {
      set(*it);
    }
  }
  constexpr EnumSet(const EnumSet &) = default;
  constexpr EnumSet(EnumSet &&) = default;

  constexpr EnumSet &operator=(const EnumSet &) = default;
  constexpr EnumSet &operator=(EnumSet &&) = default;

  const bitsetType &bitset() const { return bitset_; }

  constexpr EnumSet &operator&=(const EnumSet &that) {
    bitset_ &= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator&=(EnumSet &&that) {
    bitset_ &= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator|=(const EnumSet &that) {
    bitset_ |= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator|=(EnumSet &&that) {
    bitset_ |= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator^=(const EnumSet &that) {
    bitset_ ^= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator^=(EnumSet &&that) {
    bitset_ ^= that.bitset_;
    return *this;
  }

  constexpr EnumSet operator~() const {
    EnumSet result;
    result.bitset_ = ~bitset_;
    return result;
  }
  constexpr EnumSet operator&(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ &= that.bitset_;
    return result;
  }
  constexpr EnumSet operator&(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ &= that.bitset_;
    return result;
  }
  constexpr EnumSet operator|(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ |= that.bitset_;
    return result;
  }
  constexpr EnumSet operator|(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ |= that.bitset_;
    return result;
  }
  constexpr EnumSet operator^(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ ^= that.bitset_;
    return result;
  }
  constexpr EnumSet operator^(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ ^= that.bitset_;
    return result;
  }

  constexpr EnumSet operator+(enumerationType v) const {
    return {*this | EnumSet{v}};
  }
  constexpr EnumSet operator-(enumerationType v) const {
    return {*this & ~EnumSet{v}};
  }

  constexpr bool operator==(const EnumSet &that) const {
    return bitset_ == that.bitset_;
  }
  constexpr bool operator==(EnumSet &&that) const {
    return bitset_ == that.bitset_;
  }
  constexpr bool operator!=(const EnumSet &that) const {
    return bitset_ != that.bitset_;
  }
  constexpr bool operator!=(EnumSet &&that) const {
    return bitset_ != that.bitset_;
  }



  static constexpr std::size_t max_size() { return BITS; }
  constexpr bool test(enumerationType x) const {
    return bitset_.test(static_cast<std::size_t>(x));
  }
  constexpr bool all() const { return bitset_.all(); }
  constexpr bool any() const { return bitset_.any(); }
  constexpr bool none() const { return bitset_.none(); }



  constexpr std::size_t count() const { return bitset_.count(); }
  constexpr std::size_t count(enumerationType x) const {
    return test(x) ? 1 : 0;
  }

  constexpr EnumSet &set() {
    bitset_.set();
    return *this;
  }
  constexpr EnumSet &set(enumerationType x, bool value = true) {
    bitset_.set(static_cast<std::size_t>(x), value);
    return *this;
  }
  constexpr EnumSet &reset() {
    bitset_.reset();
    return *this;
  }
  constexpr EnumSet &reset(enumerationType x) {
    bitset_.reset(static_cast<std::size_t>(x));
    return *this;
  }
  constexpr EnumSet &flip() {
    bitset_.flip();
    return *this;
  }
  constexpr EnumSet &flip(enumerationType x) {
    bitset_.flip(static_cast<std::size_t>(x));
    return *this;
  }

  constexpr bool empty() const { return none(); }
  void clear() { reset(); }
  void insert(enumerationType x) { set(x); }
  void insert(enumerationType &&x) { set(x); }
  void emplace(enumerationType &&x) { set(x); }
  void erase(enumerationType x) { reset(x); }
  void erase(enumerationType &&x) { reset(x); }

  constexpr std::optional<enumerationType> LeastElement() const {
    if (empty()) {
      return std::nullopt;
    } else if constexpr (std::is_same_v<bitsetType, common::BitSet<BITS>>) {
      return {static_cast<enumerationType>(bitset_.LeastElement().value())};
    } else {

      for (std::size_t j{0}; j < BITS; ++j) {
        auto enumerator{static_cast<enumerationType>(j)};
        if (bitset_.test(j)) {
          return {enumerator};
        }
      }
      die("EnumSet::LeastElement(): no bit found in non-empty std::bitset");
    }
  }

  template <typename FUNC> void IterateOverMembers(const FUNC &f) const {
    EnumSet copy{*this};
    while (auto least{copy.LeastElement()}) {
      f(*least);
      copy.erase(*least);
    }
  }

  template <typename STREAM>
  STREAM &Dump(
      STREAM &o, std::string_view EnumToString(enumerationType)) const {
    char sep{'{'};
    IterateOverMembers([&](auto e) {
      o << sep << EnumToString(e);
      sep = ',';
    });
    return o << (sep == '{' ? "{}" : "}");
  }

private:
  bitsetType bitset_{};
};
}

template <typename ENUM, std::size_t values>
struct std::hash<Fortran::common::EnumSet<ENUM, values>> {
  std::size_t operator()(
      const Fortran::common::EnumSet<ENUM, values> &x) const {
    return std::hash(x.bitset());
  }
};
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran.h" 2





namespace Fortran::common {
class LanguageFeatureControl;

constexpr bool IsNumericTypeCategory(TypeCategory category) {
  return category == TypeCategory::Integer ||
      category == TypeCategory::Unsigned || category == TypeCategory::Real ||
      category == TypeCategory::Complex;
}


enum class ImportKind { Default, Only, None, All }; [[maybe_unused]] static constexpr std::size_t ImportKind_enumSize{ ::Fortran::common::CountEnumNames("Default, Only, None, All")}; [[maybe_unused]] static inline std::size_t EnumToInt(ImportKind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(ImportKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImportKind_enumSize>("Default, Only, None, All")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachImportKind(std::function<void(ImportKind)> f) { for (std::size_t i{0}; i < ImportKind_enumSize; ++i) { f(static_cast<ImportKind>(i)); } }


enum class TypeParamAttr { Kind, Len }; [[maybe_unused]] static constexpr std::size_t TypeParamAttr_enumSize{ ::Fortran::common::CountEnumNames("Kind, Len")}; [[maybe_unused]] static inline std::size_t EnumToInt(TypeParamAttr e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(TypeParamAttr e) { static const constexpr auto names{ ::Fortran::common::EnumNames<TypeParamAttr_enumSize>("Kind, Len")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachTypeParamAttr(std::function<void(TypeParamAttr)> f) { for (std::size_t i{0}; i < TypeParamAttr_enumSize; ++i) { f(static_cast<TypeParamAttr>(i)); } }

enum class NumericOperator { Power, Multiply, Divide, Add, Subtract }; [[maybe_unused]] static constexpr std::size_t NumericOperator_enumSize{ ::Fortran::common::CountEnumNames("Power, Multiply, Divide, Add, Subtract")}; [[maybe_unused]] static inline std::size_t EnumToInt(NumericOperator e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(NumericOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<NumericOperator_enumSize>("Power, Multiply, Divide, Add, Subtract")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachNumericOperator(std::function<void(NumericOperator)> f) { for (std::size_t i{0}; i < NumericOperator_enumSize; ++i) { f(static_cast<NumericOperator>(i)); } }
const char *AsFortran(NumericOperator);

enum class LogicalOperator { And, Or, Eqv, Neqv, Not }; [[maybe_unused]] static constexpr std::size_t LogicalOperator_enumSize{ ::Fortran::common::CountEnumNames("And, Or, Eqv, Neqv, Not")}; [[maybe_unused]] static inline std::size_t EnumToInt(LogicalOperator e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(LogicalOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<LogicalOperator_enumSize>("And, Or, Eqv, Neqv, Not")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachLogicalOperator(std::function<void(LogicalOperator)> f) { for (std::size_t i{0}; i < LogicalOperator_enumSize; ++i) { f(static_cast<LogicalOperator>(i)); } }
const char *AsFortran(LogicalOperator);

enum class RelationalOperator { LT, LE, EQ, NE, GE, GT }; [[maybe_unused]] static constexpr std::size_t RelationalOperator_enumSize{ ::Fortran::common::CountEnumNames("LT, LE, EQ, NE, GE, GT")}; [[maybe_unused]] static inline std::size_t EnumToInt(RelationalOperator e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(RelationalOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<RelationalOperator_enumSize>("LT, LE, EQ, NE, GE, GT")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachRelationalOperator(std::function<void(RelationalOperator)> f) { for (std::size_t i{0}; i < RelationalOperator_enumSize; ++i) { f(static_cast<RelationalOperator>(i)); } }
const char *AsFortran(RelationalOperator);

enum class Intent { Default, In, Out, InOut }; [[maybe_unused]] static constexpr std::size_t Intent_enumSize{ ::Fortran::common::CountEnumNames("Default, In, Out, InOut")}; [[maybe_unused]] static inline std::size_t EnumToInt(Intent e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Intent e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Intent_enumSize>("Default, In, Out, InOut")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIntent(std::function<void(Intent)> f) { for (std::size_t i{0}; i < Intent_enumSize; ++i) { f(static_cast<Intent>(i)); } }


enum class IoSpecKind { Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose, }; [[maybe_unused]] static constexpr std::size_t IoSpecKind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose,")}; [[maybe_unused]] static inline std::size_t EnumToInt(IoSpecKind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(IoSpecKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IoSpecKind_enumSize>("Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose,")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIoSpecKind(std::function<void(IoSpecKind)> f) { for (std::size_t i{0}; i < IoSpecKind_enumSize; ++i) { f(static_cast<IoSpecKind>(i)); } }
# 59 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran.h"
const char *AsFortran(DefinedIo);


using Label = std::uint64_t;


enum class CUDASubprogramAttrs { Host, Device, HostDevice, Global, Grid_Global }; [[maybe_unused]] static constexpr std::size_t CUDASubprogramAttrs_enumSize{ ::Fortran::common::CountEnumNames("Host, Device, HostDevice, Global, Grid_Global")}; [[maybe_unused]] static inline std::size_t EnumToInt(CUDASubprogramAttrs e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(CUDASubprogramAttrs e) { static const constexpr auto names{ ::Fortran::common::EnumNames<CUDASubprogramAttrs_enumSize>("Host, Device, HostDevice, Global, Grid_Global")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachCUDASubprogramAttrs(std::function<void(CUDASubprogramAttrs)> f) { for (std::size_t i{0}; i < CUDASubprogramAttrs_enumSize; ++i) { f(static_cast<CUDASubprogramAttrs>(i)); } }


enum class CUDADataAttr { Constant, Device, Managed, Pinned, Shared, Texture, Unified }; [[maybe_unused]] static constexpr std::size_t CUDADataAttr_enumSize{ ::Fortran::common::CountEnumNames("Constant, Device, Managed, Pinned, Shared, Texture, Unified")}; [[maybe_unused]] static inline std::size_t EnumToInt(CUDADataAttr e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(CUDADataAttr e) { static const constexpr auto names{ ::Fortran::common::EnumNames<CUDADataAttr_enumSize>("Constant, Device, Managed, Pinned, Shared, Texture, Unified")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachCUDADataAttr(std::function<void(CUDADataAttr)> f) { for (std::size_t i{0}; i < CUDADataAttr_enumSize; ++i) { f(static_cast<CUDADataAttr>(i)); } }



enum class OpenACCDeviceType { Star, Default, Nvidia, Radeon, Host, Multicore, None }; [[maybe_unused]] static constexpr std::size_t OpenACCDeviceType_enumSize{ ::Fortran::common::CountEnumNames("Star, Default, Nvidia, Radeon, Host, Multicore, None")}; [[maybe_unused]] static inline std::size_t EnumToInt(OpenACCDeviceType e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(OpenACCDeviceType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<OpenACCDeviceType_enumSize>("Star, Default, Nvidia, Radeon, Host, Multicore, None")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachOpenACCDeviceType(std::function<void(OpenACCDeviceType)> f) { for (std::size_t i{0}; i < OpenACCDeviceType_enumSize; ++i) { f(static_cast<OpenACCDeviceType>(i)); } }



enum class OmpMemoryOrderType { Acq_Rel, Acquire, Relaxed, Release, Seq_Cst }; [[maybe_unused]] static constexpr std::size_t OmpMemoryOrderType_enumSize{ ::Fortran::common::CountEnumNames("Acq_Rel, Acquire, Relaxed, Release, Seq_Cst")}; [[maybe_unused]] static inline std::size_t EnumToInt(OmpMemoryOrderType e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(OmpMemoryOrderType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<OmpMemoryOrderType_enumSize>("Acq_Rel, Acquire, Relaxed, Release, Seq_Cst")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachOmpMemoryOrderType(std::function<void(OmpMemoryOrderType)> f) { for (std::size_t i{0}; i < OmpMemoryOrderType_enumSize; ++i) { f(static_cast<OmpMemoryOrderType>(i)); } }


static constexpr int maxNameLen{63};



enum class IgnoreTKR { Type, Kind, Rank, Device, Managed, Contiguous }; [[maybe_unused]] static constexpr std::size_t IgnoreTKR_enumSize{ ::Fortran::common::CountEnumNames("Type, Kind, Rank, Device, Managed, Contiguous")}; [[maybe_unused]] static inline std::size_t EnumToInt(IgnoreTKR e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(IgnoreTKR e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IgnoreTKR_enumSize>("Type, Kind, Rank, Device, Managed, Contiguous")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIgnoreTKR(std::function<void(IgnoreTKR)> f) { for (std::size_t i{0}; i < IgnoreTKR_enumSize; ++i) { f(static_cast<IgnoreTKR>(i)); } }







using IgnoreTKRSet = EnumSet<IgnoreTKR, 8>;

static constexpr IgnoreTKRSet ignoreTKRAll{IgnoreTKR::Type, IgnoreTKR::Kind,
    IgnoreTKR::Rank, IgnoreTKR::Device, IgnoreTKR::Managed};
std::string AsFortran(IgnoreTKRSet);

bool AreCompatibleCUDADataAttrs(std::optional<CUDADataAttr>,
    std::optional<CUDADataAttr>, IgnoreTKRSet, bool allowUnifiedMatchingRule,
    bool isHostDeviceProcedure,
    const LanguageFeatureControl *features = nullptr);

static constexpr char blankCommonObjectName[] = "__BLNK__";



inline std::string GetExternalAssemblyName(
    std::string symbolName, bool underscoring) {
  return underscoring ? std::move(symbolName) + "_" : std::move(symbolName);
}

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran-features.h" 2




namespace Fortran::common {


enum class LanguageFeature { BackslashEscapes, OldDebugLines, FixedFormContinuationWithColumn1Ampersand, LogicalAbbreviations, XOROperator, PunctuationInNames, OptionalFreeFormSpace, BOZExtensions, EmptyStatement, AlternativeNE, ExecutionPartNamelist, DECStructures, DoubleComplex, Byte, StarKind, ExponentMatchingKindParam, QuadPrecision, SlashInitialization, TripletInArrayConstructor, MissingColons, SignedComplexLiteral, OldStyleParameter, ComplexConstructor, PercentLOC, SignedMultOperand, FileName, Carriagecontrol, Convert, Dispose, IOListLeadingComma, AbbreviatedEditDescriptor, ProgramParentheses, PercentRefAndVal, OmitFunctionDummies, CrayPointer, Hollerith, ArithmeticIF, Assign, AssignedGOTO, Pause, OpenACC, OpenMP, CUDA, CruftAfterAmpersand, ClassicCComments, AdditionalFormats, BigIntLiterals, RealDoControls, EquivalenceNumericWithCharacter, EquivalenceNonDefaultNumeric, EquivalenceSameNonSequence, AdditionalIntrinsics, AnonymousParents, OldLabelDoEndStatements, LogicalIntegerAssignment, EmptySourceFile, ProgramReturn, ImplicitNoneTypeNever, ImplicitNoneTypeAlways, ImplicitNoneExternal, ForwardRefImplicitNone, OpenAccessAppend, BOZAsDefaultInteger, DistinguishableSpecifics, DefaultSave, PointerInSeqType, NonCharacterFormat, SaveMainProgram, SaveBigMainProgramVariables, DistinctArrayConstructorLengths, PPCVector, RelaxedIntentInChecking, ForwardRefImplicitNoneData, NullActualForAllocatable, ActualIntegerConvertedToSmallerKind, HollerithOrCharacterAsBOZ, BindingAsProcedure, StatementFunctionExtensions, UseGenericIntrinsicWhenSpecificDoesntMatch, DataStmtExtensions, RedundantContiguous, RedundantAttribute, InitBlankCommon, EmptyBindCDerivedType, MiscSourceExtensions, AllocateToOtherLength, LongNames, IntrinsicAsSpecific, BenignNameClash, BenignRedundancy, NullMoldAllocatableComponentValue, NopassScalarBase, MiscUseExtensions, ImpliedDoIndexScope, DistinctCommonSizes, OddIndexVariableRestrictions, IndistinguishableSpecifics, SubroutineAndFunctionSpecifics, EmptySequenceType, NonSequenceCrayPointee, BranchIntoConstruct, BadBranchTarget, HollerithPolymorphic, ListDirectedSize, NonBindCInteroperability, CudaManaged, CudaUnified, PolymorphicActualAllocatableOrPointerToMonomorphicDummy, RelaxedPureDummy, UndefinableAsynchronousOrVolatileActual, AutomaticInMainProgram, PrintCptr, SavedLocalInSpecExpr, PrintNamelist, AssumedRankPassedToNonAssumedRank, IgnoreIrrelevantAttributes, Unsigned, AmbiguousStructureConstructor, ContiguousOkForSeqAssociation, ForwardRefExplicitTypeDummy, InaccessibleDeferredOverride, CudaWarpMatchFunction, DoConcurrentOffload, TransferBOZ }; [[maybe_unused]] static constexpr std::size_t LanguageFeature_enumSize{ ::Fortran::common::CountEnumNames("BackslashEscapes, OldDebugLines, FixedFormContinuationWithColumn1Ampersand, LogicalAbbreviations, XOROperator, PunctuationInNames, OptionalFreeFormSpace, BOZExtensions, EmptyStatement, AlternativeNE, ExecutionPartNamelist, DECStructures, DoubleComplex, Byte, StarKind, ExponentMatchingKindParam, QuadPrecision, SlashInitialization, TripletInArrayConstructor, MissingColons, SignedComplexLiteral, OldStyleParameter, ComplexConstructor, PercentLOC, SignedMultOperand, FileName, Carriagecontrol, Convert, Dispose, IOListLeadingComma, AbbreviatedEditDescriptor, ProgramParentheses, PercentRefAndVal, OmitFunctionDummies, CrayPointer, Hollerith, ArithmeticIF, Assign, AssignedGOTO, Pause, OpenACC, OpenMP, CUDA, CruftAfterAmpersand, ClassicCComments, AdditionalFormats, BigIntLiterals, RealDoControls, EquivalenceNumericWithCharacter, EquivalenceNonDefaultNumeric, EquivalenceSameNonSequence, AdditionalIntrinsics, AnonymousParents, OldLabelDoEndStatements, LogicalIntegerAssignment, EmptySourceFile, ProgramReturn, ImplicitNoneTypeNever, ImplicitNoneTypeAlways, ImplicitNoneExternal, ForwardRefImplicitNone, OpenAccessAppend, BOZAsDefaultInteger, DistinguishableSpecifics, DefaultSave, PointerInSeqType, NonCharacterFormat, SaveMainProgram, SaveBigMainProgramVariables, DistinctArrayConstructorLengths, PPCVector, RelaxedIntentInChecking, ForwardRefImplicitNoneData, NullActualForAllocatable, ActualIntegerConvertedToSmallerKind, HollerithOrCharacterAsBOZ, BindingAsProcedure, StatementFunctionExtensions, UseGenericIntrinsicWhenSpecificDoesntMatch, DataStmtExtensions, RedundantContiguous, RedundantAttribute, InitBlankCommon, EmptyBindCDerivedType, MiscSourceExtensions, AllocateToOtherLength, LongNames, IntrinsicAsSpecific, BenignNameClash, BenignRedundancy, NullMoldAllocatableComponentValue, NopassScalarBase, MiscUseExtensions, ImpliedDoIndexScope, DistinctCommonSizes, OddIndexVariableRestrictions, IndistinguishableSpecifics, SubroutineAndFunctionSpecifics, EmptySequenceType, NonSequenceCrayPointee, BranchIntoConstruct, BadBranchTarget, HollerithPolymorphic, ListDirectedSize, NonBindCInteroperability, CudaManaged, CudaUnified, PolymorphicActualAllocatableOrPointerToMonomorphicDummy, RelaxedPureDummy, UndefinableAsynchronousOrVolatileActual, AutomaticInMainProgram, PrintCptr, SavedLocalInSpecExpr, PrintNamelist, AssumedRankPassedToNonAssumedRank, IgnoreIrrelevantAttributes, Unsigned, AmbiguousStructureConstructor, ContiguousOkForSeqAssociation, ForwardRefExplicitTypeDummy, InaccessibleDeferredOverride, CudaWarpMatchFunction, DoConcurrentOffload, TransferBOZ")}; [[maybe_unused]] static inline std::size_t EnumToInt(LanguageFeature e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(LanguageFeature e) { static const constexpr auto names{ ::Fortran::common::EnumNames<LanguageFeature_enumSize>("BackslashEscapes, OldDebugLines, FixedFormContinuationWithColumn1Ampersand, LogicalAbbreviations, XOROperator, PunctuationInNames, OptionalFreeFormSpace, BOZExtensions, EmptyStatement, AlternativeNE, ExecutionPartNamelist, DECStructures, DoubleComplex, Byte, StarKind, ExponentMatchingKindParam, QuadPrecision, SlashInitialization, TripletInArrayConstructor, MissingColons, SignedComplexLiteral, OldStyleParameter, ComplexConstructor, PercentLOC, SignedMultOperand, FileName, Carriagecontrol, Convert, Dispose, IOListLeadingComma, AbbreviatedEditDescriptor, ProgramParentheses, PercentRefAndVal, OmitFunctionDummies, CrayPointer, Hollerith, ArithmeticIF, Assign, AssignedGOTO, Pause, OpenACC, OpenMP, CUDA, CruftAfterAmpersand, ClassicCComments, AdditionalFormats, BigIntLiterals, RealDoControls, EquivalenceNumericWithCharacter, EquivalenceNonDefaultNumeric, EquivalenceSameNonSequence, AdditionalIntrinsics, AnonymousParents, OldLabelDoEndStatements, LogicalIntegerAssignment, EmptySourceFile, ProgramReturn, ImplicitNoneTypeNever, ImplicitNoneTypeAlways, ImplicitNoneExternal, ForwardRefImplicitNone, OpenAccessAppend, BOZAsDefaultInteger, DistinguishableSpecifics, DefaultSave, PointerInSeqType, NonCharacterFormat, SaveMainProgram, SaveBigMainProgramVariables, DistinctArrayConstructorLengths, PPCVector, RelaxedIntentInChecking, ForwardRefImplicitNoneData, NullActualForAllocatable, ActualIntegerConvertedToSmallerKind, HollerithOrCharacterAsBOZ, BindingAsProcedure, StatementFunctionExtensions, UseGenericIntrinsicWhenSpecificDoesntMatch, DataStmtExtensions, RedundantContiguous, RedundantAttribute, InitBlankCommon, EmptyBindCDerivedType, MiscSourceExtensions, AllocateToOtherLength, LongNames, IntrinsicAsSpecific, BenignNameClash, BenignRedundancy, NullMoldAllocatableComponentValue, NopassScalarBase, MiscUseExtensions, ImpliedDoIndexScope, DistinctCommonSizes, OddIndexVariableRestrictions, IndistinguishableSpecifics, SubroutineAndFunctionSpecifics, EmptySequenceType, NonSequenceCrayPointee, BranchIntoConstruct, BadBranchTarget, HollerithPolymorphic, ListDirectedSize, NonBindCInteroperability, CudaManaged, CudaUnified, PolymorphicActualAllocatableOrPointerToMonomorphicDummy, RelaxedPureDummy, UndefinableAsynchronousOrVolatileActual, AutomaticInMainProgram, PrintCptr, SavedLocalInSpecExpr, PrintNamelist, AssumedRankPassedToNonAssumedRank, IgnoreIrrelevantAttributes, Unsigned, AmbiguousStructureConstructor, ContiguousOkForSeqAssociation, ForwardRefExplicitTypeDummy, InaccessibleDeferredOverride, CudaWarpMatchFunction, DoConcurrentOffload, TransferBOZ")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachLanguageFeature(std::function<void(LanguageFeature)> f) { for (std::size_t i{0}; i < LanguageFeature_enumSize; ++i) { f(static_cast<LanguageFeature>(i)); } }
# 62 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran-features.h"
enum class UsageWarning { Portability, PointerToUndefinable, NonTargetPassedToTarget, PointerToPossibleNoncontiguous, ShortCharacterActual, ShortArrayActual, ImplicitInterfaceActual, PolymorphicTransferArg, PointerComponentTransferArg, TransferSizePresence, F202XAllocatableBreakingChange, OptionalMustBePresent, CommonBlockPadding, LogicalVsCBool, BindCCharLength, ProcDummyArgShapes, ExternalNameConflict, FoldingException, FoldingAvoidsRuntimeCrash, FoldingValueChecks, FoldingFailure, FoldingLimit, Interoperability, CharacterInteroperability, Bounds, Preprocessing, Scanning, OpenAccUsage, ProcPointerCompatibility, VoidMold, KnownBadImplicitInterface, EmptyCase, CaseOverflow, CUDAUsage, IgnoreTKRUsage, ExternalInterfaceMismatch, DefinedOperatorArgs, Final, ZeroDoStep, UnusedForallIndex, OpenMPUsage, DataLength, IgnoredDirective, HomonymousSpecific, HomonymousResult, IgnoredIntrinsicFunctionType, PreviousScalarUse, RedeclaredInaccessibleComponent, ImplicitShared, IndexVarRedefinition, IncompatibleImplicitInterfaces, VectorSubscriptFinalization, UndefinedFunctionResult, UselessIomsg, MismatchingDummyProcedure, SubscriptedEmptyArray, UnsignedLiteralTruncation, CompatibleDeclarationsFromDistinctModules, NullActualForDefaultIntentAllocatable, UseAssociationIntoSameNameSubprogram, HostAssociatedIntentOutInSpecExpr, NonVolatilePointerToVolatile }; [[maybe_unused]] static constexpr std::size_t UsageWarning_enumSize{ ::Fortran::common::CountEnumNames("Portability, PointerToUndefinable, NonTargetPassedToTarget, PointerToPossibleNoncontiguous, ShortCharacterActual, ShortArrayActual, ImplicitInterfaceActual, PolymorphicTransferArg, PointerComponentTransferArg, TransferSizePresence, F202XAllocatableBreakingChange, OptionalMustBePresent, CommonBlockPadding, LogicalVsCBool, BindCCharLength, ProcDummyArgShapes, ExternalNameConflict, FoldingException, FoldingAvoidsRuntimeCrash, FoldingValueChecks, FoldingFailure, FoldingLimit, Interoperability, CharacterInteroperability, Bounds, Preprocessing, Scanning, OpenAccUsage, ProcPointerCompatibility, VoidMold, KnownBadImplicitInterface, EmptyCase, CaseOverflow, CUDAUsage, IgnoreTKRUsage, ExternalInterfaceMismatch, DefinedOperatorArgs, Final, ZeroDoStep, UnusedForallIndex, OpenMPUsage, DataLength, IgnoredDirective, HomonymousSpecific, HomonymousResult, IgnoredIntrinsicFunctionType, PreviousScalarUse, RedeclaredInaccessibleComponent, ImplicitShared, IndexVarRedefinition, IncompatibleImplicitInterfaces, VectorSubscriptFinalization, UndefinedFunctionResult, UselessIomsg, MismatchingDummyProcedure, SubscriptedEmptyArray, UnsignedLiteralTruncation, CompatibleDeclarationsFromDistinctModules, NullActualForDefaultIntentAllocatable, UseAssociationIntoSameNameSubprogram, HostAssociatedIntentOutInSpecExpr, NonVolatilePointerToVolatile")}; [[maybe_unused]] static inline std::size_t EnumToInt(UsageWarning e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(UsageWarning e) { static const constexpr auto names{ ::Fortran::common::EnumNames<UsageWarning_enumSize>("Portability, PointerToUndefinable, NonTargetPassedToTarget, PointerToPossibleNoncontiguous, ShortCharacterActual, ShortArrayActual, ImplicitInterfaceActual, PolymorphicTransferArg, PointerComponentTransferArg, TransferSizePresence, F202XAllocatableBreakingChange, OptionalMustBePresent, CommonBlockPadding, LogicalVsCBool, BindCCharLength, ProcDummyArgShapes, ExternalNameConflict, FoldingException, FoldingAvoidsRuntimeCrash, FoldingValueChecks, FoldingFailure, FoldingLimit, Interoperability, CharacterInteroperability, Bounds, Preprocessing, Scanning, OpenAccUsage, ProcPointerCompatibility, VoidMold, KnownBadImplicitInterface, EmptyCase, CaseOverflow, CUDAUsage, IgnoreTKRUsage, ExternalInterfaceMismatch, DefinedOperatorArgs, Final, ZeroDoStep, UnusedForallIndex, OpenMPUsage, DataLength, IgnoredDirective, HomonymousSpecific, HomonymousResult, IgnoredIntrinsicFunctionType, PreviousScalarUse, RedeclaredInaccessibleComponent, ImplicitShared, IndexVarRedefinition, IncompatibleImplicitInterfaces, VectorSubscriptFinalization, UndefinedFunctionResult, UselessIomsg, MismatchingDummyProcedure, SubscriptedEmptyArray, UnsignedLiteralTruncation, CompatibleDeclarationsFromDistinctModules, NullActualForDefaultIntentAllocatable, UseAssociationIntoSameNameSubprogram, HostAssociatedIntentOutInSpecExpr, NonVolatilePointerToVolatile")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachUsageWarning(std::function<void(UsageWarning)> f) { for (std::size_t i{0}; i < UsageWarning_enumSize; ++i) { f(static_cast<UsageWarning>(i)); } }
# 83 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Support/Fortran-features.h"
using LanguageFeatures = EnumSet<LanguageFeature, LanguageFeature_enumSize>;
using UsageWarnings = EnumSet<UsageWarning, UsageWarning_enumSize>;
using LanguageFeatureOrWarning = std::variant<LanguageFeature, UsageWarning>;
using LanguageControlFlag =
    std::pair<LanguageFeatureOrWarning, bool>;

class LanguageFeatureControl {
public:
  LanguageFeatureControl();
  LanguageFeatureControl(const LanguageFeatureControl &) = default;

  void Enable(LanguageFeature f, bool yes = true) { disable_.set(f, !yes); }
  void EnableWarning(LanguageFeature f, bool yes = true) {
    warnLanguage_.set(f, yes);
  }
  void EnableWarning(UsageWarning w, bool yes = true) {
    warnUsage_.set(w, yes);
  }
  void EnableWarning(LanguageFeatureOrWarning flag, bool yes = true) {
    if (std::holds_alternative<LanguageFeature>(flag)) {
      EnableWarning(std::get<LanguageFeature>(flag), yes);
    } else {
      EnableWarning(std::get<UsageWarning>(flag), yes);
    }
  }
  void WarnOnAllNonstandard(bool yes = true);
  bool IsWarnOnAllNonstandard() const { return warnAllLanguage_; }
  void WarnOnAllUsage(bool yes = true);
  bool IsWarnOnAllUsage() const { return warnAllUsage_; }
  void DisableAllNonstandardWarnings() {
    warnAllLanguage_ = false;
    warnLanguage_.clear();
  }
  void DisableAllUsageWarnings() {
    warnAllUsage_ = false;
    warnUsage_.clear();
  }
  void DisableAllWarnings() {
    disableAllWarnings_ = true;
    DisableAllNonstandardWarnings();
    DisableAllUsageWarnings();
  }
  bool AreWarningsDisabled() const { return disableAllWarnings_; }
  bool IsEnabled(LanguageFeature f) const { return !disable_.test(f); }
  bool ShouldWarn(LanguageFeature f) const { return warnLanguage_.test(f); }
  bool ShouldWarn(UsageWarning w) const { return warnUsage_.test(w); }


  std::optional<LanguageControlFlag> FindWarning(std::string_view input);


  bool EnableWarning(std::string_view input);




  void AddAlternativeCliSpelling(LanguageFeature f, std::string input) {
    cliOptions_.insert({input, {f}});
  }
  void AddAlternativeCliSpelling(UsageWarning w, std::string input) {
    cliOptions_.insert({input, {w}});
  }
  void ReplaceCliCanonicalSpelling(LanguageFeature f, std::string input);
  void ReplaceCliCanonicalSpelling(UsageWarning w, std::string input);
  std::string_view getDefaultCliSpelling(LanguageFeature f) const {
    return languageFeatureCliCanonicalSpelling_[EnumToInt(f)];
  };
  std::string_view getDefaultCliSpelling(UsageWarning w) const {
    return usageWarningCliCanonicalSpelling_[EnumToInt(w)];
  };

  std::vector<const char *> GetNames(LogicalOperator) const;
  std::vector<const char *> GetNames(RelationalOperator) const;

private:


  std::unordered_map<std::string, LanguageFeatureOrWarning> cliOptions_;



  std::array<std::string, LanguageFeature_enumSize>
      languageFeatureCliCanonicalSpelling_;
  std::array<std::string, UsageWarning_enumSize>
      usageWarningCliCanonicalSpelling_;
  LanguageFeatures disable_;
  LanguageFeatures warnLanguage_;
  bool warnAllLanguage_{false};
  UsageWarnings warnUsage_;
  bool warnAllUsage_{false};
  bool disableAllWarnings_{false};
};
}
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 1 3
# 251 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 255 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 2 3

#pragma clang diagnostic push
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {

template <class _Tp, class _VoidPtr>
struct __forward_list_node;
template <class _NodePtr>
struct __forward_begin_node;

template <class>
struct __forward_list_node_value_type;

template <class _Tp, class _VoidPtr>
struct __forward_list_node_value_type<__forward_list_node<_Tp, _VoidPtr> > {
  typedef _Tp type;
};

template <class _NodePtr>
struct __forward_node_traits {
  typedef __remove_cv_t<typename pointer_traits<_NodePtr>::element_type> __node_type;
  typedef typename __forward_list_node_value_type<__node_type>::type __node_value_type;
  typedef _NodePtr __node_pointer;
  typedef __forward_begin_node<_NodePtr> __begin_node;
  typedef __rebind_pointer_t<_NodePtr, __begin_node> __begin_node_pointer;
  typedef __rebind_pointer_t<_NodePtr, void> __void_pointer;




  typedef __conditional_t<is_pointer<__void_pointer>::value, __begin_node_pointer, __node_pointer> __iter_node_pointer;


  typedef __conditional_t<is_same<__iter_node_pointer, __node_pointer>::value, __begin_node_pointer, __node_pointer>
      __non_iter_node_pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __iter_node_pointer __as_iter_node(__iter_node_pointer __p) { return __p; }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) static __iter_node_pointer __as_iter_node(__non_iter_node_pointer __p) {
    return static_cast<__iter_node_pointer>(static_cast<__void_pointer>(__p));
  }
};

template <class _NodePtr>
struct __forward_begin_node {
  typedef _NodePtr pointer;
  typedef __rebind_pointer_t<_NodePtr, __forward_begin_node> __begin_node_pointer;

  pointer __next_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_begin_node() : __next_(nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_begin_node(pointer __n) : __next_(__n) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __begin_node_pointer __next_as_begin() const {
    return static_cast<__begin_node_pointer>(__next_);
  }
};

template <class _Tp, class _VoidPtr>
using __begin_node_of = __forward_begin_node<__rebind_pointer_t<_VoidPtr, __forward_list_node<_Tp, _VoidPtr> > >;

template <class _Tp, class _VoidPtr>
struct __forward_list_node : public __begin_node_of<_Tp, _VoidPtr> {
  typedef _Tp value_type;
  typedef __begin_node_of<_Tp, _VoidPtr> _Base;
  typedef typename _Base::pointer _NodePtr;





private:
  union {
    _Tp __value_;
  };

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) _Tp& __get_value() { return __value_; }
# 339 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_node(_NodePtr __next) : _Base(__next) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~__forward_list_node() {}
};

template <class _Tp, class _Alloc = allocator<_Tp> >
class forward_list;
template <class _NodeConstPtr>
class __forward_list_const_iterator;

template <class _NodePtr>
class __forward_list_iterator {
  typedef __forward_node_traits<_NodePtr> __traits;
  typedef typename __traits::__node_pointer __node_pointer;
  typedef typename __traits::__begin_node_pointer __begin_node_pointer;
  typedef typename __traits::__iter_node_pointer __iter_node_pointer;
  typedef typename __traits::__void_pointer __void_pointer;

  __iter_node_pointer __ptr_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __begin_node_pointer __get_begin() const {
    return static_cast<__begin_node_pointer>(static_cast<__void_pointer>(__ptr_));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __get_unsafe_node_pointer() const {
    return static_cast<__node_pointer>(static_cast<__void_pointer>(__ptr_));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_iterator(nullptr_t) noexcept : __ptr_(nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_iterator(__begin_node_pointer __p) noexcept
      : __ptr_(__traits::__as_iter_node(__p)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_iterator(__node_pointer __p) noexcept
      : __ptr_(__traits::__as_iter_node(__p)) {}

  template <class, class>
  friend class forward_list;
  template <class>
  friend class __forward_list_const_iterator;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename __traits::__node_value_type value_type;
  typedef value_type& reference;
  typedef typename pointer_traits<__node_pointer>::difference_type difference_type;
  typedef __rebind_pointer_t<__node_pointer, value_type> pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_iterator() noexcept : __ptr_(nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __get_unsafe_node_pointer()->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_unsafe_node_pointer()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_iterator& operator++() {
    __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_iterator operator++(int) {
    __forward_list_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const __forward_list_iterator& __x, const __forward_list_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator!=(const __forward_list_iterator& __x, const __forward_list_iterator& __y) {
    return !(__x == __y);
  }
};

template <class _NodeConstPtr>
class __forward_list_const_iterator {
  static_assert(!is_const<typename pointer_traits<_NodeConstPtr>::element_type>::value, "");
  typedef _NodeConstPtr _NodePtr;

  typedef __forward_node_traits<_NodePtr> __traits;
  typedef typename __traits::__node_type __node_type;
  typedef typename __traits::__node_pointer __node_pointer;
  typedef typename __traits::__begin_node_pointer __begin_node_pointer;
  typedef typename __traits::__iter_node_pointer __iter_node_pointer;
  typedef typename __traits::__void_pointer __void_pointer;

  __iter_node_pointer __ptr_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __begin_node_pointer __get_begin() const {
    return static_cast<__begin_node_pointer>(static_cast<__void_pointer>(__ptr_));
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __get_unsafe_node_pointer() const {
    return static_cast<__node_pointer>(static_cast<__void_pointer>(__ptr_));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_const_iterator(nullptr_t) noexcept : __ptr_(nullptr) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_const_iterator(__begin_node_pointer __p) noexcept
      : __ptr_(__traits::__as_iter_node(__p)) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_const_iterator(__node_pointer __p) noexcept
      : __ptr_(__traits::__as_iter_node(__p)) {}

  template <class, class>
  friend class forward_list;

public:
  typedef forward_iterator_tag iterator_category;
  typedef typename __traits::__node_value_type value_type;
  typedef const value_type& reference;
  typedef typename pointer_traits<__node_pointer>::difference_type difference_type;
  typedef __rebind_pointer_t<__node_pointer, const value_type> pointer;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_const_iterator() noexcept : __ptr_(nullptr) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_const_iterator(__forward_list_iterator<__node_pointer> __p) noexcept
      : __ptr_(__p.__ptr_) {}

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference operator*() const { return __get_unsafe_node_pointer()->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) pointer operator->() const {
    return pointer_traits<pointer>::pointer_to(__get_unsafe_node_pointer()->__get_value());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_const_iterator& operator++() {
    __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
    return *this;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_const_iterator operator++(int) {
    __forward_list_const_iterator __t(*this);
    ++(*this);
    return __t;
  }

  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
  operator==(const __forward_list_const_iterator& __x, const __forward_list_const_iterator& __y) {
    return __x.__ptr_ == __y.__ptr_;
  }
  friend __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
  operator!=(const __forward_list_const_iterator& __x, const __forward_list_const_iterator& __y) {
    return !(__x == __y);
  }
};

template <class _Tp, class _Alloc>
class __forward_list_base {
protected:
  typedef _Tp value_type;
  typedef _Alloc allocator_type;

  typedef typename allocator_traits<allocator_type>::void_pointer void_pointer;
  typedef __forward_list_node<value_type, void_pointer> __node_type;
  typedef __begin_node_of<value_type, void_pointer> __begin_node;
  typedef __rebind_alloc<allocator_traits<allocator_type>, __node_type> __node_allocator;
  typedef allocator_traits<__node_allocator> __node_traits;
  typedef typename __node_traits::pointer __node_pointer;

  typedef __rebind_alloc<allocator_traits<allocator_type>, __begin_node> __begin_node_allocator;
  typedef typename allocator_traits<__begin_node_allocator>::pointer __begin_node_pointer;

  __compressed_pair<__begin_node, __node_allocator> __before_begin_;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __begin_node_pointer __before_begin() noexcept {
    return pointer_traits<__begin_node_pointer>::pointer_to(__before_begin_.first());
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __begin_node_pointer __before_begin() const noexcept {
    return pointer_traits<__begin_node_pointer>::pointer_to(const_cast<__begin_node&>(__before_begin_.first()));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_allocator& __alloc() noexcept { return __before_begin_.second(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const __node_allocator& __alloc() const noexcept { return __before_begin_.second(); }

  typedef __forward_list_iterator<__node_pointer> iterator;
  typedef __forward_list_const_iterator<__node_pointer> const_iterator;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_base() noexcept(is_nothrow_default_constructible<__node_allocator>::value)
      : __before_begin_(__begin_node(), __default_init_tag()) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_base(const allocator_type& __a)
      : __before_begin_(__begin_node(), __node_allocator(__a)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit __forward_list_base(const __node_allocator& __a)
      : __before_begin_(__begin_node(), __a) {}

public:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102")))
  __forward_list_base(__forward_list_base&& __x) noexcept(is_nothrow_move_constructible<__node_allocator>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __forward_list_base(__forward_list_base&& __x, const allocator_type& __a);


  __forward_list_base(const __forward_list_base&) = delete;
  __forward_list_base& operator=(const __forward_list_base&) = delete;

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) ~__forward_list_base();

protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __forward_list_base& __x) {
    __copy_assign_alloc(__x, integral_constant<bool, __node_traits::propagate_on_container_copy_assignment::value>());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__forward_list_base& __x)
      noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value) {

    __move_assign_alloc(__x, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  }

  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __create_node(__node_pointer __next, _Args&&... __args) {
    __node_allocator& __a = __alloc();
    __allocation_guard<__node_allocator> __guard(__a, 1);






    std::__construct_at(std::addressof(*__guard.__get()), __next);


    __node_traits::construct(__a, std::addressof(__guard.__get()->__get_value()), std::forward<_Args>(__args)...);
    return __guard.__release_ptr();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __delete_node(__node_pointer __node) {


    __node_allocator& __a = __alloc();
    __node_traits::destroy(__a, std::addressof(__node->__get_value()));
    std::__destroy_at(std::addressof(*__node));
    __node_traits::deallocate(__a, __node, 1);
  }

public:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(__forward_list_base& __x)

      noexcept;




protected:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept;

private:
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __forward_list_base&, false_type) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __copy_assign_alloc(const __forward_list_base& __x, true_type) {
    if (__alloc() != __x.__alloc())
      clear();
    __alloc() = __x.__alloc();
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__forward_list_base&, false_type) noexcept {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign_alloc(__forward_list_base& __x, true_type)
      noexcept(is_nothrow_move_assignable<__node_allocator>::value) {
    __alloc() = std::move(__x.__alloc());
  }
};



template <class _Tp, class _Alloc>
inline __forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x) noexcept(
    is_nothrow_move_constructible<__node_allocator>::value)
    : __before_begin_(std::move(__x.__before_begin_)) {
  __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
inline __forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x, const allocator_type& __a)
    : __before_begin_(__begin_node(), __node_allocator(__a)) {
  if (__alloc() == __x.__alloc()) {
    __before_begin()->__next_ = __x.__before_begin()->__next_;
    __x.__before_begin()->__next_ = nullptr;
  }
}



template <class _Tp, class _Alloc>
__forward_list_base<_Tp, _Alloc>::~__forward_list_base() {
  clear();
}

template <class _Tp, class _Alloc>
inline void __forward_list_base<_Tp, _Alloc>::swap(__forward_list_base& __x)

    noexcept



{
  std::__swap_allocator(
      __alloc(), __x.__alloc(), integral_constant<bool, __node_traits::propagate_on_container_swap::value>());
  using std::swap;
  swap(__before_begin()->__next_, __x.__before_begin()->__next_);
}

template <class _Tp, class _Alloc>
void __forward_list_base<_Tp, _Alloc>::clear() noexcept {
  for (__node_pointer __p = __before_begin()->__next_; __p != nullptr;) {
    __node_pointer __next = __p->__next_;
    __delete_node(__p);
    __p = __next;
  }
  __before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc >
class forward_list : private __forward_list_base<_Tp, _Alloc> {
  typedef __forward_list_base<_Tp, _Alloc> base;
  typedef typename base::__node_allocator __node_allocator;
  typedef typename base::__node_type __node_type;
  typedef typename base::__node_traits __node_traits;
  typedef typename base::__node_pointer __node_pointer;
  typedef typename base::__begin_node_pointer __begin_node_pointer;

public:
  typedef _Tp value_type;
  typedef _Alloc allocator_type;

  static_assert(__check_valid_allocator<allocator_type>::value, "");

  static_assert(is_same<value_type, typename allocator_type::value_type>::value,
                "Allocator::value_type must be same type as value_type");

  static_assert(!is_same<allocator_type, __node_allocator>::value,
                "internal allocator type must differ from user-specified type; otherwise overload resolution breaks");

  typedef value_type& reference;
  typedef const value_type& const_reference;
  typedef typename allocator_traits<allocator_type>::pointer pointer;
  typedef typename allocator_traits<allocator_type>::const_pointer const_pointer;
  typedef typename allocator_traits<allocator_type>::size_type size_type;
  typedef typename allocator_traits<allocator_type>::difference_type difference_type;

  typedef typename base::iterator iterator;
  typedef typename base::const_iterator const_iterator;



  typedef void __remove_return_type;


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list() noexcept(is_nothrow_default_constructible<__node_allocator>::value) {
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit forward_list(const allocator_type& __a);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit forward_list(size_type __n);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) explicit forward_list(size_type __n, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(size_type __n, const value_type& __v);

  template <__enable_if_t<__is_allocator<_Alloc>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(size_type __n, const value_type& __v, const allocator_type& __a) : base(__a) {
    insert_after(cbefore_begin(), __n, __v);
  }

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(_InputIterator __f, _InputIterator __l);

  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(_InputIterator __f, _InputIterator __l, const allocator_type& __a);
# 704 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(const forward_list& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(const forward_list& __x, const __type_identity_t<allocator_type>& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list& operator=(const forward_list& __x);


  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(forward_list&& __x) noexcept(is_nothrow_move_constructible<base>::value)
      : base(std::move(__x)) {}
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(forward_list&& __x, const __type_identity_t<allocator_type>& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(initializer_list<value_type> __il);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list(initializer_list<value_type> __il, const allocator_type& __a);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list& operator=(forward_list&& __x) noexcept(
      __node_traits::propagate_on_container_move_assignment::value &&
      is_nothrow_move_assignable<allocator_type>::value);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) forward_list& operator=(initializer_list<value_type> __il);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void assign(initializer_list<value_type> __il);




  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  void __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) assign(_InputIterator __f, _InputIterator __l);
# 738 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void assign(size_type __n, const value_type& __v);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) allocator_type get_allocator() const noexcept { return allocator_type(base::__alloc()); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator begin() noexcept { return iterator(base::__before_begin()->__next_); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator begin() const noexcept {
    return const_iterator(base::__before_begin()->__next_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator end() noexcept { return iterator(nullptr); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator end() const noexcept { return const_iterator(nullptr); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbegin() const noexcept {
    return const_iterator(base::__before_begin()->__next_);
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cend() const noexcept { return const_iterator(nullptr); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator before_begin() noexcept { return iterator(base::__before_begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator before_begin() const noexcept { return const_iterator(base::__before_begin()); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_iterator cbefore_begin() const noexcept {
    return const_iterator(base::__before_begin());
  }

  [[__nodiscard__]] __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool empty() const noexcept {
    return base::__before_begin()->__next_ == nullptr;
  }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) size_type max_size() const noexcept {
    return std::min<size_type>(__node_traits::max_size(base::__alloc()), numeric_limits<difference_type>::max());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference front() { return base::__before_begin()->__next_->__get_value(); }
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) const_reference front() const { return base::__before_begin()->__next_->__get_value(); }



  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) reference emplace_front(_Args&&... __args);




  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_front(value_type&& __v);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void push_front(const value_type& __v);
# 789 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void pop_front();


  template <class... _Args>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator emplace_after(const_iterator __p, _Args&&... __args);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_after(const_iterator __p, value_type&& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_after(const_iterator __p, initializer_list<value_type> __il) {
    return insert_after(__p, __il.begin(), __il.end());
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_after(const_iterator __p, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_after(const_iterator __p, size_type __n, const value_type& __v);
  template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> = 0>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator insert_after(const_iterator __p, _InputIterator __f, _InputIterator __l);
# 812 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
  template <class _InputIterator, class _Sentinel>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator __insert_after_with_sentinel(const_iterator __p, _InputIterator __f, _Sentinel __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase_after(const_iterator __p);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) iterator erase_after(const_iterator __f, const_iterator __l);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(forward_list& __x)

      noexcept



  {
    base::swap(__x);
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void resize(size_type __n);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void resize(size_type __n, const value_type& __v);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void clear() noexcept { base::clear(); }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice_after(const_iterator __p, forward_list&& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice_after(const_iterator __p, forward_list&& __x, const_iterator __i);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
  splice_after(const_iterator __p, forward_list&& __x, const_iterator __f, const_iterator __l);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice_after(const_iterator __p, forward_list& __x);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void splice_after(const_iterator __p, forward_list& __x, const_iterator __i);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
  splice_after(const_iterator __p, forward_list& __x, const_iterator __f, const_iterator __l);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type remove(const value_type& __v);
  template <class _Predicate>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type remove_if(_Predicate __pred);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type unique() { return unique(__equal_to()); }
  template <class _BinaryPredicate>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __remove_return_type unique(_BinaryPredicate __binary_pred);

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(forward_list&& __x) { merge(__x, __less<>()); }
  template <class _Compare>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(forward_list&& __x, _Compare __comp) {
    merge(__x, std::move(__comp));
  }

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(forward_list& __x) { merge(__x, __less<>()); }
  template <class _Compare>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void merge(forward_list& __x, _Compare __comp);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void sort() { sort(__less<>()); }
  template <class _Compare>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void sort(_Compare __comp);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void reverse() noexcept;

private:

  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(forward_list& __x, true_type)
      noexcept(is_nothrow_move_assignable<allocator_type>::value);
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __move_assign(forward_list& __x, false_type);


  template <class _Iter, class _Sent>
  __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void __assign_with_sentinel(_Iter __f, _Sent __l);

  template <class _Compare>
  static __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) __node_pointer __merge(__node_pointer __f1, __node_pointer __f2, _Compare& __comp);


  template <class _Compare>
  static __attribute__((__visibility__("hidden"))) __node_pointer __sort(__node_pointer __f, difference_type __sz, _Compare& __comp);
};


template <class _InputIterator,
          class _Alloc = allocator<__iter_value_type<_InputIterator>>,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Alloc>::value> >
forward_list(_InputIterator, _InputIterator) -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;

template <class _InputIterator,
          class _Alloc,
          class = enable_if_t<__has_input_iterator_category<_InputIterator>::value>,
          class = enable_if_t<__is_allocator<_Alloc>::value> >
forward_list(_InputIterator, _InputIterator, _Alloc) -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;
# 900 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
template <class _Tp, class _Alloc>
inline forward_list<_Tp, _Alloc>::forward_list(const allocator_type& __a) : base(__a) {}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n) {
  if (__n > 0) {
    for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n, __p = __p->__next_as_begin()) {
      __p->__next_ = this->__create_node( nullptr);
    }
  }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const allocator_type& __base_alloc) : base(__base_alloc) {
  if (__n > 0) {
    for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n, __p = __p->__next_as_begin()) {
      __p->__next_ = this->__create_node( nullptr);
    }
  }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v) {
  insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l) {
  insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l, const allocator_type& __a) : base(__a) {
  insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x)
    : base(__node_traits::select_on_container_copy_construction(__x.__alloc())) {
  insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x, const __type_identity_t<allocator_type>& __a)
    : base(__a) {
  insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>& forward_list<_Tp, _Alloc>::operator=(const forward_list& __x) {
  if (this != std::addressof(__x)) {
    base::__copy_assign_alloc(__x);
    assign(__x.begin(), __x.end());
  }
  return *this;
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(forward_list&& __x, const __type_identity_t<allocator_type>& __a)
    : base(std::move(__x), __a) {
  if (base::__alloc() != __x.__alloc()) {
    typedef move_iterator<iterator> _Ip;
    insert_after(cbefore_begin(), _Ip(__x.begin()), _Ip(__x.end()));
  }
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il) {
  insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il, const allocator_type& __a) : base(__a) {
  insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value) {
  clear();
  base::__move_assign_alloc(__x);
  base::__before_begin()->__next_ = __x.__before_begin()->__next_;
  __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, false_type) {
  if (base::__alloc() == __x.__alloc())
    __move_assign(__x, true_type());
  else {
    typedef move_iterator<iterator> _Ip;
    assign(_Ip(__x.begin()), _Ip(__x.end()));
  }
}

template <class _Tp, class _Alloc>
inline forward_list<_Tp, _Alloc>& forward_list<_Tp, _Alloc>::operator=(forward_list&& __x) noexcept(__node_traits::propagate_on_container_move_assignment::value&& is_nothrow_move_assignable<allocator_type>::value) {

  __move_assign(__x, integral_constant<bool, __node_traits::propagate_on_container_move_assignment::value>());
  return *this;
}

template <class _Tp, class _Alloc>
inline forward_list<_Tp, _Alloc>& forward_list<_Tp, _Alloc>::operator=(initializer_list<value_type> __il) {
  assign(__il.begin(), __il.end());
  return *this;
}



template <class _Tp, class _Alloc>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
void forward_list<_Tp, _Alloc>::assign(_InputIterator __f, _InputIterator __l) {
  __assign_with_sentinel(__f, __l);
}

template <class _Tp, class _Alloc>
template <class _Iter, class _Sent>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void forward_list<_Tp, _Alloc>::__assign_with_sentinel(_Iter __f, _Sent __l) {
  iterator __i = before_begin();
  iterator __j = std::next(__i);
  iterator __e = end();
  for (; __j != __e && __f != __l; ++__i, (void)++__j, ++__f)
    *__j = *__f;
  if (__j == __e)
    __insert_after_with_sentinel(__i, std::move(__f), std::move(__l));
  else
    erase_after(__i, __e);
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::assign(size_type __n, const value_type& __v) {
  iterator __i = before_begin();
  iterator __j = std::next(__i);
  iterator __e = end();
  for (; __j != __e && __n > 0; --__n, ++__i, ++__j)
    *__j = __v;
  if (__j == __e)
    insert_after(__i, __n, __v);
  else
    erase_after(__i, __e);
}



template <class _Tp, class _Alloc>
inline void forward_list<_Tp, _Alloc>::assign(initializer_list<value_type> __il) {
  assign(__il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename forward_list<_Tp, _Alloc>::reference



forward_list<_Tp, _Alloc>::emplace_front(_Args&&... __args) {
  base::__before_begin()->__next_ =
      this->__create_node( base::__before_begin()->__next_, std::forward<_Args>(__args)...);

  return base::__before_begin()->__next_->__get_value();

}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::push_front(value_type&& __v) {
  base::__before_begin()->__next_ = this->__create_node( base::__before_begin()->__next_, std::move(__v));
}



template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::push_front(const value_type& __v) {
  base::__before_begin()->__next_ = this->__create_node( base::__before_begin()->__next_, __v);
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::pop_front() {
  __node_pointer __p = base::__before_begin()->__next_;
  base::__before_begin()->__next_ = __p->__next_;
  this->__delete_node(__p);
}



template <class _Tp, class _Alloc>
template <class... _Args>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::emplace_after(const_iterator __p, _Args&&... __args) {
  __begin_node_pointer const __r = __p.__get_begin();
  __r->__next_ = this->__create_node( __r->__next_, std::forward<_Args>(__args)...);
  return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, value_type&& __v) {
  __begin_node_pointer const __r = __p.__get_begin();
  __r->__next_ = this->__create_node( __r->__next_, std::move(__v));
  return iterator(__r->__next_);
}



template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, const value_type& __v) {
  __begin_node_pointer const __r = __p.__get_begin();
  __r->__next_ = this->__create_node( __r->__next_, __v);
  return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, size_type __n, const value_type& __v) {
  __begin_node_pointer __r = __p.__get_begin();
  if (__n > 0) {
    __node_pointer __first = this->__create_node( nullptr, __v);
    __node_pointer __last = __first;

    try {

      for (--__n; __n != 0; --__n, __last = __last->__next_) {
        __last->__next_ = this->__create_node( nullptr, __v);
      }

    } catch (...) {
      while (__first != nullptr) {
        __node_pointer __next = __first->__next_;
        this->__delete_node(__first);
        __first = __next;
      }
      throw;
    }

    __last->__next_ = __r->__next_;
    __r->__next_ = __first;
    __r = static_cast<__begin_node_pointer>(__last);
  }
  return iterator(__r);
}

template <class _Tp, class _Alloc>
template <class _InputIterator, __enable_if_t<__has_input_iterator_category<_InputIterator>::value, int> >
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, _InputIterator __f, _InputIterator __l) {
  return __insert_after_with_sentinel(__p, std::move(__f), std::move(__l));
}

template <class _Tp, class _Alloc>
template <class _InputIterator, class _Sentinel>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::__insert_after_with_sentinel(const_iterator __p, _InputIterator __f, _Sentinel __l) {
  __begin_node_pointer __r = __p.__get_begin();

  if (__f != __l) {
    __node_pointer __first = this->__create_node( nullptr, *__f);
    __node_pointer __last = __first;


    try {

      for (++__f; __f != __l; ++__f, ((void)(__last = __last->__next_))) {
        __last->__next_ = this->__create_node( nullptr, *__f);
      }

    } catch (...) {
      while (__first != nullptr) {
        __node_pointer __next = __first->__next_;
        this->__delete_node(__first);
        __first = __next;
      }
      throw;
    }


    __last->__next_ = __r->__next_;
    __r->__next_ = __first;
    __r = static_cast<__begin_node_pointer>(__last);
  }

  return iterator(__r);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator forward_list<_Tp, _Alloc>::erase_after(const_iterator __f) {
  __begin_node_pointer __p = __f.__get_begin();
  __node_pointer __n = __p->__next_;
  __p->__next_ = __n->__next_;
  this->__delete_node(__n);
  return iterator(__p->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f, const_iterator __l) {
  __node_pointer __e = __l.__get_unsafe_node_pointer();
  if (__f != __l) {
    __begin_node_pointer __bp = __f.__get_begin();

    __node_pointer __n = __bp->__next_;
    if (__n != __e) {
      __bp->__next_ = __e;
      do {
        __node_pointer __tmp = __n->__next_;
        this->__delete_node(__n);
        __n = __tmp;
      } while (__n != __e);
    }
  }
  return iterator(__e);
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::resize(size_type __n) {
  size_type __sz = 0;
  iterator __p = before_begin();
  iterator __i = begin();
  iterator __e = end();
  for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
    ;
  if (__i != __e)
    erase_after(__p, __e);
  else {
    __n -= __sz;
    if (__n > 0) {
      for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n, __ptr = __ptr->__next_as_begin()) {
        __ptr->__next_ = this->__create_node( nullptr);
      }
    }
  }
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::resize(size_type __n, const value_type& __v) {
  size_type __sz = 0;
  iterator __p = before_begin();
  iterator __i = begin();
  iterator __e = end();
  for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
    ;
  if (__i != __e)
    erase_after(__p, __e);
  else {
    __n -= __sz;
    if (__n > 0) {
      for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n, __ptr = __ptr->__next_as_begin()) {
        __ptr->__next_ = this->__create_node( nullptr, __v);
      }
    }
  }
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::splice_after(const_iterator __p, forward_list& __x) {
  if (!__x.empty()) {
    if (__p.__get_begin()->__next_ != nullptr) {
      const_iterator __lm1 = __x.before_begin();
      while (__lm1.__get_begin()->__next_ != nullptr)
        ++__lm1;
      __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
    }
    __p.__get_begin()->__next_ = __x.__before_begin()->__next_;
    __x.__before_begin()->__next_ = nullptr;
  }
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::splice_after(const_iterator __p, forward_list& , const_iterator __i) {
  const_iterator __lm1 = std::next(__i);
  if (__p != __i && __p != __lm1) {
    __i.__get_begin()->__next_ = __lm1.__get_begin()->__next_;
    __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
    __p.__get_begin()->__next_ = __lm1.__get_unsafe_node_pointer();
  }
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::splice_after(
    const_iterator __p, forward_list& , const_iterator __f, const_iterator __l) {
  if (__f != __l && __p != __f) {
    const_iterator __lm1 = __f;
    while (__lm1.__get_begin()->__next_ != __l.__get_begin())
      ++__lm1;
    if (__f != __lm1) {
      __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
      __p.__get_begin()->__next_ = __f.__get_begin()->__next_;
      __f.__get_begin()->__next_ = __l.__get_unsafe_node_pointer();
    }
  }
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void forward_list<_Tp, _Alloc>::splice_after(const_iterator __p, forward_list&& __x) {
  splice_after(__p, __x);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p, forward_list&& __x, const_iterator __i) {
  splice_after(__p, __x, __i);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void forward_list<_Tp, _Alloc>::splice_after(
    const_iterator __p, forward_list&& __x, const_iterator __f, const_iterator __l) {
  splice_after(__p, __x, __f, __l);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::__remove_return_type forward_list<_Tp, _Alloc>::remove(const value_type& __v) {
  forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
  const iterator __e = end();
  for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;) {
    if (__i.__get_begin()->__next_->__get_value() == __v) {
      ++__count_removed;
      iterator __j = std::next(__i, 2);
      for (; __j != __e && *__j == __v; ++__j)
        ++__count_removed;
      __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
      if (__j == __e)
        break;
      __i = __j;
    } else
      ++__i;
  }

  return (__remove_return_type)__count_removed;
}

template <class _Tp, class _Alloc>
template <class _Predicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type forward_list<_Tp, _Alloc>::remove_if(_Predicate __pred) {
  forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
  const iterator __e = end();
  for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;) {
    if (__pred(__i.__get_begin()->__next_->__get_value())) {
      ++__count_removed;
      iterator __j = std::next(__i, 2);
      for (; __j != __e && __pred(*__j); ++__j)
        ++__count_removed;
      __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
      if (__j == __e)
        break;
      __i = __j;
    } else
      ++__i;
  }

  return (__remove_return_type)__count_removed;
}

template <class _Tp, class _Alloc>
template <class _BinaryPredicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred) {
  forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
  typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
  for (iterator __i = begin(), __e = end(); __i != __e;) {
    iterator __j = std::next(__i);
    for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
      ++__count_removed;
    if (__i.__get_begin()->__next_ != __j.__get_unsafe_node_pointer())
      __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
    __i = __j;
  }

  return (__remove_return_type)__count_removed;
}

template <class _Tp, class _Alloc>
template <class _Compare>
void forward_list<_Tp, _Alloc>::merge(forward_list& __x, _Compare __comp) {
  if (this != std::addressof(__x)) {
    base::__before_begin()->__next_ = __merge(base::__before_begin()->__next_, __x.__before_begin()->__next_, __comp);
    __x.__before_begin()->__next_ = nullptr;
  }
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__merge(__node_pointer __f1, __node_pointer __f2, _Compare& __comp) {
  if (__f1 == nullptr)
    return __f2;
  if (__f2 == nullptr)
    return __f1;
  __node_pointer __r;
  if (__comp(__f2->__get_value(), __f1->__get_value())) {
    __node_pointer __t = __f2;
    while (__t->__next_ != nullptr && __comp(__t->__next_->__get_value(), __f1->__get_value()))
      __t = __t->__next_;
    __r = __f2;
    __f2 = __t->__next_;
    __t->__next_ = __f1;
  } else
    __r = __f1;
  __node_pointer __p = __f1;
  __f1 = __f1->__next_;
  while (__f1 != nullptr && __f2 != nullptr) {
    if (__comp(__f2->__get_value(), __f1->__get_value())) {
      __node_pointer __t = __f2;
      while (__t->__next_ != nullptr && __comp(__t->__next_->__get_value(), __f1->__get_value()))
        __t = __t->__next_;
      __p->__next_ = __f2;
      __f2 = __t->__next_;
      __t->__next_ = __f1;
    }
    __p = __f1;
    __f1 = __f1->__next_;
  }
  if (__f2 != nullptr)
    __p->__next_ = __f2;
  return __r;
}

template <class _Tp, class _Alloc>
template <class _Compare>
inline void forward_list<_Tp, _Alloc>::sort(_Compare __comp) {
  base::__before_begin()->__next_ = __sort(base::__before_begin()->__next_, std::distance(begin(), end()), __comp);
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__sort(__node_pointer __f1, difference_type __sz, _Compare& __comp) {
  switch (__sz) {
  case 0:
  case 1:
    return __f1;
  case 2:
    if (__comp(__f1->__next_->__get_value(), __f1->__get_value())) {
      __node_pointer __t = __f1->__next_;
      __t->__next_ = __f1;
      __f1->__next_ = nullptr;
      __f1 = __t;
    }
    return __f1;
  }
  difference_type __sz1 = __sz / 2;
  difference_type __sz2 = __sz - __sz1;
  __node_pointer __t = std::next(iterator(__f1), __sz1 - 1).__get_unsafe_node_pointer();
  __node_pointer __f2 = __t->__next_;
  __t->__next_ = nullptr;
  return __merge(__sort(__f1, __sz1, __comp), __sort(__f2, __sz2, __comp), __comp);
}

template <class _Tp, class _Alloc>
void forward_list<_Tp, _Alloc>::reverse() noexcept {
  __node_pointer __p = base::__before_begin()->__next_;
  if (__p != nullptr) {
    __node_pointer __f = __p->__next_;
    __p->__next_ = nullptr;
    while (__f != nullptr) {
      __node_pointer __t = __f->__next_;
      __f->__next_ = __p;
      __p = __f;
      __f = __t;
    }
    base::__before_begin()->__next_ = __p;
  }
}

template <class _Tp, class _Alloc>
__attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool operator==(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  typedef forward_list<_Tp, _Alloc> _Cp;
  typedef typename _Cp::const_iterator _Ip;
  _Ip __ix = __x.begin();
  _Ip __ex = __x.end();
  _Ip __iy = __y.begin();
  _Ip __ey = __y.end();
  for (; __ix != __ex && __iy != __ey; ++__ix, ++__iy)
    if (!(*__ix == *__iy))
      return false;
  return (__ix == __ex) == (__iy == __ey);
}



template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator!=(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  return std::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator>=(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) bool
operator<=(const forward_list<_Tp, _Alloc>& __x, const forward_list<_Tp, _Alloc>& __y) {
  return !(__y < __x);
}
# 1528 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
template <class _Tp, class _Alloc>
inline __attribute__((__visibility__("hidden"))) __attribute__((__exclude_from_explicit_instantiation__)) __attribute__((__abi_tag__("ne190102"))) void swap(forward_list<_Tp, _Alloc>& __x, forward_list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y))) {
  __x.swap(__y);
}
# 1548 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
}}
# 1548 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic pop


#pragma clang diagnostic push
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++11-extensions"
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++14-extensions"
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++17-extensions"
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++20-extensions"
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic ignored "-Wc++23-extensions"
# 1551 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
 namespace __attribute__((__type_visibility__("default"))) std { inline namespace __1 {
namespace pmr {
template <class _ValueT>
using forward_list = std::forward_list<_ValueT, polymorphic_allocator<_ValueT>>;
}
}}
# 1556 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
#pragma clang diagnostic pop
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2






namespace Fortran::parser {




enum class Severity {
  Error,
  Warning,
  Portability,
  Because,
  Context,
  Todo,
  None
};

class MessageFixedText {
public:
  constexpr MessageFixedText() {}
  constexpr MessageFixedText(
      const char str[], std::size_t n, Severity severity = Severity::None)
      : text_{str, n}, severity_{severity} {}
  constexpr MessageFixedText(const MessageFixedText &) = default;
  constexpr MessageFixedText(MessageFixedText &&) = default;
  constexpr MessageFixedText &operator=(const MessageFixedText &) = default;
  constexpr MessageFixedText &operator=(MessageFixedText &&) = default;

  CharBlock text() const { return text_; }
  bool empty() const { return text_.empty(); }
  Severity severity() const { return severity_; }
  MessageFixedText &set_severity(Severity severity) {
    severity_ = severity;
    return *this;
  }
  bool IsFatal() const {
    return severity_ == Severity::Error || severity_ == Severity::Todo;
  }

private:
  CharBlock text_;
  Severity severity_{Severity::None};
};

inline namespace literals {
constexpr MessageFixedText operator""_err_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Error};
}
constexpr MessageFixedText operator""_warn_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Warning};
}
constexpr MessageFixedText operator""_port_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Portability};
}
constexpr MessageFixedText operator""_because_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Because};
}
constexpr MessageFixedText operator""_todo_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Todo};
}
constexpr MessageFixedText operator""_en_US(const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::None};
}
}






class MessageFormattedText {
public:
  template <typename... A>
  MessageFormattedText(const MessageFixedText &text, A &&...x)
      : severity_{text.severity()} {
    Format(&text, Convert(std::forward<A>(x))...);
  }
  MessageFormattedText(const MessageFormattedText &) = default;
  MessageFormattedText(MessageFormattedText &&) = default;
  MessageFormattedText &operator=(const MessageFormattedText &) = default;
  MessageFormattedText &operator=(MessageFormattedText &&) = default;
  const std::string &string() const { return string_; }
  bool IsFatal() const {
    return severity_ == Severity::Error || severity_ == Severity::Todo;
  }
  Severity severity() const { return severity_; }
  MessageFormattedText &set_severity(Severity severity) {
    severity_ = severity;
    return *this;
  }
  std::string MoveString() { return std::move(string_); }
  bool operator==(const MessageFormattedText &that) const {
    return severity_ == that.severity_ && string_ == that.string_;
  }
  bool operator!=(const MessageFormattedText &that) const {
    return !(*this == that);
  }

private:
  void Format(const MessageFixedText *, ...);

  template <typename A> A Convert(const A &x) {
    static_assert(!std::is_class_v<std::decay_t<A>>);
    return x;
  }
  template <typename A> common::IfNoLvalue<A, A> Convert(A &&x) {
    static_assert(!std::is_class_v<std::decay_t<A>>);
    return std::move(x);
  }
  const char *Convert(const char *s) { return s; }
  const char *Convert(char *s) { return s; }
  const char *Convert(const std::string &);
  const char *Convert(std::string &&);
  const char *Convert(const std::string_view &);
  const char *Convert(std::string_view &&);
  const char *Convert(CharBlock);
  std::intmax_t Convert(std::int64_t x) { return x; }
  std::uintmax_t Convert(std::uint64_t x) { return x; }

  Severity severity_;
  std::string string_;
  std::forward_list<std::string> conversions_;
};



class MessageExpectedText {
public:
  MessageExpectedText(const char *s, std::size_t n) {
    if (n == std::string::npos) {
      n = std::strlen(s);
    }
    if (n == 1) {

      u_ = SetOfChars{*s};
    } else {
      u_ = CharBlock{s, n};
    }
  }
  constexpr explicit MessageExpectedText(CharBlock cb) : u_{cb} {}
  constexpr explicit MessageExpectedText(char ch) : u_{SetOfChars{ch}} {}
  constexpr explicit MessageExpectedText(SetOfChars set) : u_{set} {}
  MessageExpectedText(const MessageExpectedText &) = default;
  MessageExpectedText(MessageExpectedText &&) = default;
  MessageExpectedText &operator=(const MessageExpectedText &) = default;
  MessageExpectedText &operator=(MessageExpectedText &&) = default;

  std::string ToString() const;
  bool Merge(const MessageExpectedText &);

private:
  std::variant<CharBlock, SetOfChars> u_;
};

class Message : public common::ReferenceCounted<Message> {
public:
  using Reference = common::CountedReference<Message>;

  Message(const Message &) = default;
  Message(Message &&) = default;
  Message &operator=(const Message &) = default;
  Message &operator=(Message &&) = default;

  Message(ProvenanceRange pr, const MessageFixedText &t)
      : location_{pr}, text_{t} {}
  Message(ProvenanceRange pr, const MessageFormattedText &s)
      : location_{pr}, text_{s} {}
  Message(ProvenanceRange pr, MessageFormattedText &&s)
      : location_{pr}, text_{std::move(s)} {}
  Message(ProvenanceRange pr, const MessageExpectedText &t)
      : location_{pr}, text_{t} {}

  Message(common::LanguageFeature feature, ProvenanceRange pr,
      const MessageFixedText &t)
      : location_{pr}, text_{t}, languageFeature_{feature} {}
  Message(common::LanguageFeature feature, ProvenanceRange pr,
      const MessageFormattedText &s)
      : location_{pr}, text_{s}, languageFeature_{feature} {}
  Message(common::LanguageFeature feature, ProvenanceRange pr,
      MessageFormattedText &&s)
      : location_{pr}, text_{std::move(s)}, languageFeature_{feature} {}

  Message(common::UsageWarning warning, ProvenanceRange pr,
      const MessageFixedText &t)
      : location_{pr}, text_{t}, usageWarning_{warning} {}
  Message(common::UsageWarning warning, ProvenanceRange pr,
      const MessageFormattedText &s)
      : location_{pr}, text_{s}, usageWarning_{warning} {}
  Message(common::UsageWarning warning, ProvenanceRange pr,
      MessageFormattedText &&s)
      : location_{pr}, text_{std::move(s)}, usageWarning_{warning} {}

  Message(CharBlock csr, const MessageFixedText &t)
      : location_{csr}, text_{t} {}
  Message(CharBlock csr, const MessageFormattedText &s)
      : location_{csr}, text_{s} {}
  Message(CharBlock csr, MessageFormattedText &&s)
      : location_{csr}, text_{std::move(s)} {}
  Message(CharBlock csr, const MessageExpectedText &t)
      : location_{csr}, text_{t} {}

  Message(
      common::LanguageFeature feature, CharBlock csr, const MessageFixedText &t)
      : location_{csr}, text_{t}, languageFeature_{feature} {}
  Message(common::LanguageFeature feature, CharBlock csr,
      const MessageFormattedText &s)
      : location_{csr}, text_{s}, languageFeature_{feature} {}
  Message(
      common::LanguageFeature feature, CharBlock csr, MessageFormattedText &&s)
      : location_{csr}, text_{std::move(s)}, languageFeature_{feature} {}

  Message(
      common::UsageWarning warning, CharBlock csr, const MessageFixedText &t)
      : location_{csr}, text_{t}, usageWarning_{warning} {}
  Message(common::UsageWarning warning, CharBlock csr,
      const MessageFormattedText &s)
      : location_{csr}, text_{s}, usageWarning_{warning} {}
  Message(common::UsageWarning warning, CharBlock csr, MessageFormattedText &&s)
      : location_{csr}, text_{std::move(s)}, usageWarning_{warning} {}

  template <typename RANGE, typename A, typename... As>
  Message(RANGE r, const MessageFixedText &t, A &&x, As &&...xs)
      : location_{r}, text_{MessageFormattedText{
                          t, std::forward<A>(x), std::forward<As>(xs)...}} {}
  template <typename RANGE, typename A, typename... As>
  Message(common::LanguageFeature feature, RANGE r, const MessageFixedText &t,
      A &&x, As &&...xs)
      : location_{r}, text_{MessageFormattedText{
                          t, std::forward<A>(x), std::forward<As>(xs)...}},
        languageFeature_{feature} {}
  template <typename RANGE, typename A, typename... As>
  Message(common::UsageWarning warning, RANGE r, const MessageFixedText &t,
      A &&x, As &&...xs)
      : location_{r}, text_{MessageFormattedText{
                          t, std::forward<A>(x), std::forward<As>(xs)...}},
        usageWarning_{warning} {}

  Reference attachment() const { return attachment_; }

  void SetContext(Message *c) {
    attachment_ = c;
    attachmentIsContext_ = true;
  }
  Message &Attach(Message *);
  Message &Attach(std::unique_ptr<Message> &&);
  template <typename... A> Message &Attach(A &&...args) {
    return Attach(new Message{std::forward<A>(args)...});
  }

  bool SortBefore(const Message &that) const;
  bool IsFatal() const;
  Severity severity() const;
  Message &set_severity(Severity);
  std::optional<common::LanguageFeature> languageFeature() const;
  Message &set_languageFeature(common::LanguageFeature);
  std::optional<common::UsageWarning> usageWarning() const;
  Message &set_usageWarning(common::UsageWarning);
  std::string ToString() const;
  std::optional<ProvenanceRange> GetProvenanceRange(
      const AllCookedSources &) const;
  void Emit(llvm::raw_ostream &, const AllCookedSources &,
      bool echoSourceLine = true,
      const common::LanguageFeatureControl *hintFlags = nullptr) const;



  void ResolveProvenances(const AllCookedSources &);

  bool IsMergeable() const {
    return std::holds_alternative<MessageExpectedText>(text_);
  }
  bool Merge(const Message &);
  bool operator==(const Message &that) const;
  bool operator!=(const Message &that) const { return !(*this == that); }

private:
  bool AtSameLocation(const Message &) const;
  std::variant<ProvenanceRange, CharBlock> location_;
  std::variant<MessageFixedText, MessageFormattedText, MessageExpectedText>
      text_;
  bool attachmentIsContext_{false};
  Reference attachment_;
  std::optional<common::LanguageFeature> languageFeature_;
  std::optional<common::UsageWarning> usageWarning_;
};

class Messages {
public:
  Messages() {}
  Messages(Messages &&that) : messages_{std::move(that.messages_)} {}
  Messages &operator=(Messages &&that) {
    messages_ = std::move(that.messages_);
    return *this;
  }

  std::list<Message> &messages() { return messages_; }
  bool empty() const { return messages_.empty(); }
  void clear() { messages_.clear(); }

  template <typename... A> Message &Say(A &&...args) {
    return messages_.emplace_back(std::forward<A>(args)...);
  }

  template <typename... A>
  Message &Say(common::LanguageFeature feature, A &&...args) {
    return Say(std::forward<A>(args)...).set_languageFeature(feature);
  }

  template <typename... A>
  Message &Say(common::UsageWarning warning, A &&...args) {
    return Say(std::forward<A>(args)...).set_usageWarning(warning);
  }

  void Annex(Messages &&that) {
    messages_.splice(messages_.end(), that.messages_);
  }

  bool Merge(const Message &);
  void Merge(Messages &&);
  void Copy(const Messages &);
  void ResolveProvenances(const AllCookedSources &);
  void Emit(llvm::raw_ostream &, const AllCookedSources &,
      bool echoSourceLines = true,
      const common::LanguageFeatureControl *hintFlags = nullptr,
      std::size_t maxErrorsToEmit = 0, bool warningsAreErrors = false) const;
  void AttachTo(Message &, std::optional<Severity> = std::nullopt);
  bool AnyFatalError(bool warningsAreErrors = false) const;

private:
  std::list<Message> messages_;
};

class ContextualMessages {
public:
  ContextualMessages() = default;
  ContextualMessages(CharBlock at, Messages *m) : at_{at}, messages_{m} {}
  explicit ContextualMessages(Messages *m) : messages_{m} {}
  ContextualMessages(const ContextualMessages &that)
      : at_{that.at_}, messages_{that.messages_} {}

  CharBlock at() const { return at_; }
  Messages *messages() const { return messages_; }
  Message::Reference contextMessage() const { return contextMessage_; }
  bool empty() const { return !messages_ || messages_->empty(); }


  common::Restorer<CharBlock> SetLocation(CharBlock at) {
    if (at.empty()) {
      at = at_;
    }
    return common::ScopedSet(at_, std::move(at));
  }

  common::Restorer<Message::Reference> SetContext(Message *m) {
    if (!m) {
      m = contextMessage_.get();
    }
    return common::ScopedSet(contextMessage_, m);
  }



  common::Restorer<Messages *> SetMessages(Messages &buffer) {
    return common::ScopedSet(messages_, &buffer);
  }

  common::Restorer<Messages *> DiscardMessages() {
    return common::ScopedSet(messages_, nullptr);
  }

  template <typename... A> Message *Say(A &&...args) {
    return Say(at_, std::forward<A>(args)...);
  }

  template <typename... A> Message *Say(CharBlock at, A &&...args) {
    if (messages_ != nullptr) {
      auto &msg{messages_->Say(at, std::forward<A>(args)...)};
      if (contextMessage_) {
        msg.SetContext(contextMessage_.get());
      }
      return &msg;
    } else {
      return nullptr;
    }
  }

  template <typename... A>
  Message *Say(std::optional<CharBlock> at, A &&...args) {
    return Say(at.value_or(at_), std::forward<A>(args)...);
  }

  template <typename... A>
  Message *Say(common::LanguageFeature feature, A &&...args) {
    Message *msg{Say(std::forward<A>(args)...)};
    if (msg) {
      msg->set_languageFeature(feature);
    }
    return msg;
  }

  template <typename... A>
  Message *Say(common::UsageWarning warning, A &&...args) {
    Message *msg{Say(std::forward<A>(args)...)};
    if (msg) {
      msg->set_usageWarning(warning);
    }
    return msg;
  }

  Message *Say(Message &&msg) {
    if (messages_ != nullptr) {
      if (contextMessage_) {
        msg.SetContext(contextMessage_.get());
      }
      return &messages_->Say(std::move(msg));
    } else {
      return nullptr;
    }
  }

private:
  CharBlock at_;
  Messages *messages_{nullptr};
  Message::Reference contextMessage_;
};
}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" 1
# 28 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h"
namespace Fortran::common {


template <typename A, bool COPY = false> class Indirection {
public:
  using element_type = A;
  Indirection() = delete;
  Indirection(A *&&p) : p_{p} {
    ((p_ && "assigning null pointer to Indirection") || (Fortran::common::die("CHECK(" "p_ && \"assigning null pointer to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 36), false));
    p = nullptr;
  }
  Indirection(A &&x) : p_{new A(std::move(x))} {}
  Indirection(Indirection &&that) : p_{that.p_} {
    ((p_ && "move construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "p_ && \"move construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 41), false));
    that.p_ = nullptr;
  }
  ~Indirection() {
    delete p_;
    p_ = nullptr;
  }
  Indirection &operator=(Indirection &&that) {
    ((that.p_ && "move assignment of null Indirection to Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"move assignment of null Indirection to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 49), false));
    auto tmp{p_};
    p_ = that.p_;
    that.p_ = tmp;
    return *this;
  }

  A &value() { return *p_; }
  const A &value() const { return *p_; }

  bool operator==(const A &that) const { return *p_ == that; }
  bool operator==(const Indirection &that) const { return *p_ == *that.p_; }

  template <typename... ARGS>
  static common::IfNoLvalue<Indirection, ARGS...> Make(ARGS &&...args) {
    return {new A(std::move(args)...)};
  }

private:
  A *p_{nullptr};
};


template <typename A> class Indirection<A, true> {
public:
  using element_type = A;

  Indirection() = delete;
  Indirection(A *&&p) : p_{p} {
    ((p_ && "assigning null pointer to Indirection") || (Fortran::common::die("CHECK(" "p_ && \"assigning null pointer to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 78), false));
    p = nullptr;
  }
  Indirection(const A &x) : p_{new A(x)} {}
  Indirection(A &&x) : p_{new A(std::move(x))} {}
  Indirection(const Indirection &that) {
    ((that.p_ && "copy construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"copy construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 84), false));
    p_ = new A(*that.p_);
  }
  Indirection(Indirection &&that) : p_{that.p_} {
    ((p_ && "move construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "p_ && \"move construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 88), false));
    that.p_ = nullptr;
  }
  ~Indirection() {
    delete p_;
    p_ = nullptr;
  }
  Indirection &operator=(const Indirection &that) {
    ((that.p_ && "copy assignment of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"copy assignment of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 96), false));
    *p_ = *that.p_;
    return *this;
  }
  Indirection &operator=(Indirection &&that) {
    ((that.p_ && "move assignment of null Indirection to Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"move assignment of null Indirection to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 101), false));
    auto tmp{p_};
    p_ = that.p_;
    that.p_ = tmp;
    return *this;
  }

  A &value() { return *p_; }
  const A &value() const { return *p_; }

  bool operator==(const A &that) const { return *p_ == that; }
  bool operator==(const Indirection &that) const { return *p_ == *that.p_; }

  template <typename... ARGS>
  static common::IfNoLvalue<Indirection, ARGS...> Make(ARGS &&...args) {
    return {new A(std::move(args)...)};
  }

private:
  A *p_{nullptr};
};

template <typename A> using CopyableIndirection = Indirection<A, true>;



template <typename A> class ForwardOwningPointer {
public:
  ForwardOwningPointer() {}
  ForwardOwningPointer(A *p, void (*del)(A *)) : p_{p}, deleter_{del} {}
  ForwardOwningPointer(ForwardOwningPointer &&that)
      : p_{that.p_}, deleter_{that.deleter_} {
    that.p_ = nullptr;
  }
  ForwardOwningPointer &operator=(ForwardOwningPointer &&that) {
    p_ = that.p_;
    that.p_ = nullptr;
    deleter_ = that.deleter_;
    return *this;
  }
  ~ForwardOwningPointer() {
    if (p_) {
      deleter_(p_);
    }
  }

  A &operator*() const { return *p_; }
  A *operator->() const { return p_; }
  operator bool() const { return p_ != nullptr; }
  A *get() { return p_; }
  auto get() const { return reinterpret_cast<std::add_const_t<A> *>(p_); }
  A *release() {
    A *result{p_};
    p_ = nullptr;
    return result;
  }

  void Reset(A *p = nullptr) {
    if (p_) {
      deleter_(p_);
    }
    p_ = p;
  }
  void Reset(A *p, void (*del)(A *)) {
    Reset(p);
    deleter_ = del;
  }

private:
  A *p_{nullptr};
  void (*deleter_)(A *){nullptr};
};
}
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 1




# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h" 2
# 99 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h"
namespace llvm {



template <typename E, typename Enable = void>
struct is_bitmask_enum : std::false_type {};

template <typename E>
struct is_bitmask_enum<
    E, std::enable_if_t<sizeof(E::LLVM_BITMASK_LARGEST_ENUMERATOR) >= 0>>
    : std::true_type {};


template <typename E, typename Enable = void> struct largest_bitmask_enum_bit;

template <typename E>
struct largest_bitmask_enum_bit<
    E, std::enable_if_t<sizeof(E::LLVM_BITMASK_LARGEST_ENUMERATOR) >= 0>> {
  using UnderlyingTy = std::underlying_type_t<E>;
  static constexpr UnderlyingTy value =
      static_cast<UnderlyingTy>(E::LLVM_BITMASK_LARGEST_ENUMERATOR);
};

namespace BitmaskEnumDetail {



template <typename E> constexpr std::underlying_type_t<E> Mask() {


  return NextPowerOf2(largest_bitmask_enum_bit<E>::value) - 1;
}



template <typename E> constexpr std::underlying_type_t<E> Underlying(E Val) {
  auto U = llvm::to_underlying(Val);
  (__builtin_expect(!(U >= 0 && "Negative enum values are not allowed."), 0) ? __assert_rtn(__func__, "BitmaskEnum.h", 136, "U >= 0 && \"Negative enum values are not allowed.\"") : (void)0);
  (__builtin_expect(!(U <= Mask<E>() && "Enum value too large (or largest val too small?)"), 0) ? __assert_rtn(__func__, "BitmaskEnum.h", 137, "U <= Mask<E>() && \"Enum value too large (or largest val too small?)\"") : (void)0);
  return U;
}

constexpr unsigned bitWidth(uint64_t Value) {
  return Value ? 1 + bitWidth(Value >> 1) : 0;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr bool operator!(E Val) {
  return Val == static_cast<E>(0);
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr bool any(E Val) {
  return Val != static_cast<E>(0);
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator~(E Val) {
  return static_cast<E>(~Underlying(Val) & Mask<E>());
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator|(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) | Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator&(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) & Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator^(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) ^ Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator<<(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) << Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator>>(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) >> Underlying(RHS));
}




template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator|=(E &LHS, E RHS) {
  LHS = LHS | RHS;
  return LHS;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator&=(E &LHS, E RHS) {
  LHS = LHS & RHS;
  return LHS;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator^=(E &LHS, E RHS) {
  LHS = LHS ^ RHS;
  return LHS;
}

template <typename e, typename = std::enable_if_t<is_bitmask_enum<e>::value>>
e &operator<<=(e &lhs, e rhs) {
  lhs = lhs << rhs;
  return lhs;
}

template <typename e, typename = std::enable_if_t<is_bitmask_enum<e>::value>>
e &operator>>=(e &lhs, e rhs) {
  lhs = lhs >> rhs;
  return lhs;
}

}


using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator<<; using ::llvm::BitmaskEnumDetail::operator>>; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::operator<<=; using ::llvm::BitmaskEnumDetail::operator>>=; using ::llvm::BitmaskEnumDetail::operator!; using ::llvm::BitmaskEnumDetail::any;
template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr unsigned BitWidth = BitmaskEnumDetail::bitWidth(
    uint64_t{llvm::to_underlying(E::LLVM_BITMASK_LARGEST_ENUMERATOR)});

}
# 6 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Sequence.h" 1
# 83 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Sequence.h"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 84 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Sequence.h" 2







namespace llvm {







template <typename EnumT> struct enum_iteration_traits {
  static constexpr bool is_iterable = false;
};

struct force_iteration_on_noniterable_enum_t {
  explicit force_iteration_on_noniterable_enum_t() = default;
};

inline constexpr force_iteration_on_noniterable_enum_t
    force_iteration_on_noniterable_enum;

namespace detail {


template <typename T, typename U> bool canTypeFitValue(const U Value) {
  const intmax_t BotT = intmax_t(std::numeric_limits<T>::min());
  const intmax_t BotU = intmax_t(std::numeric_limits<U>::min());
  const uintmax_t TopT = uintmax_t(std::numeric_limits<T>::max());
  const uintmax_t TopU = uintmax_t(std::numeric_limits<U>::max());
  return !((BotT > BotU && Value < static_cast<U>(BotT)) ||
           (TopT < TopU && Value > static_cast<U>(TopT)));
}





struct CheckedInt {

  template <typename Integral,
            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0>
  static CheckedInt from(Integral FromValue) {
    if (!canTypeFitValue<intmax_t>(FromValue))
      assertOutOfBounds();
    CheckedInt Result;
    Result.Value = static_cast<intmax_t>(FromValue);
    return Result;
  }


  template <typename Enum,
            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0>
  static CheckedInt from(Enum FromValue) {
    using type = std::underlying_type_t<Enum>;
    return from<type>(static_cast<type>(FromValue));
  }


  bool operator==(const CheckedInt &O) const { return Value == O.Value; }
  bool operator!=(const CheckedInt &O) const { return Value != O.Value; }

  CheckedInt operator+(intmax_t Offset) const {
    CheckedInt Result;
    if (AddOverflow(Value, Offset, Result.Value))
      assertOutOfBounds();
    return Result;
  }

  intmax_t operator-(CheckedInt Other) const {
    intmax_t Result;
    if (SubOverflow(Value, Other.Value, Result))
      assertOutOfBounds();
    return Result;
  }


  template <typename Integral,
            std::enable_if_t<std::is_integral<Integral>::value, bool> = 0>
  Integral to() const {
    if (!canTypeFitValue<Integral>(Value))
      assertOutOfBounds();
    return static_cast<Integral>(Value);
  }



  template <typename Enum,
            std::enable_if_t<std::is_enum<Enum>::value, bool> = 0>
  Enum to() const {
    using type = std::underlying_type_t<Enum>;
    return Enum(to<type>());
  }

private:
  static void assertOutOfBounds() { (__builtin_expect(!(false && "Out of bounds"), 0) ? __assert_rtn(__func__, "Sequence.h", 183, "false && \"Out of bounds\"") : (void)0); }

  intmax_t Value;
};

template <typename T, bool IsReverse> struct SafeIntIterator {
  using iterator_category = std::random_access_iterator_tag;
  using value_type = T;
  using difference_type = intmax_t;
  using pointer = T *;
  using reference = value_type;


  explicit SafeIntIterator(T Value) : SI(CheckedInt::from<T>(Value)) {}

  SafeIntIterator(const SafeIntIterator<T, !IsReverse> &O) : SI(O.SI) {}


  reference operator*() const { return SI.to<T>(); }

  reference operator[](intmax_t Offset) const { return *(*this + Offset); }


  bool operator==(const SafeIntIterator &O) const { return SI == O.SI; }
  bool operator!=(const SafeIntIterator &O) const { return SI != O.SI; }

  bool operator<(const SafeIntIterator &O) const { return (*this - O) < 0; }
  bool operator>(const SafeIntIterator &O) const { return (*this - O) > 0; }
  bool operator<=(const SafeIntIterator &O) const { return (*this - O) <= 0; }
  bool operator>=(const SafeIntIterator &O) const { return (*this - O) >= 0; }


  void operator++() { offset(1); }
  void operator--() { offset(-1); }


  SafeIntIterator operator++(int) {
    const auto Copy = *this;
    ++*this;
    return Copy;
  }
  SafeIntIterator operator--(int) {
    const auto Copy = *this;
    --*this;
    return Copy;
  }


  void operator+=(intmax_t Offset) { offset(Offset); }
  void operator-=(intmax_t Offset) { offset(-Offset); }


  SafeIntIterator operator+(intmax_t Offset) const { return add(Offset); }
  SafeIntIterator operator-(intmax_t Offset) const { return add(-Offset); }


  intmax_t operator-(const SafeIntIterator &O) const {
    return IsReverse ? O.SI - SI : SI - O.SI;
  }

private:
  SafeIntIterator(const CheckedInt &SI) : SI(SI) {}

  static intmax_t getOffset(intmax_t Offset) {
    return IsReverse ? -Offset : Offset;
  }

  CheckedInt add(intmax_t Offset) const { return SI + getOffset(Offset); }

  void offset(intmax_t Offset) { SI = SI + getOffset(Offset); }

  CheckedInt SI;


  template <typename, bool> friend struct SafeIntIterator;
};

}

template <typename T> struct iota_range {
  using value_type = T;
  using reference = T &;
  using const_reference = const T &;
  using iterator = detail::SafeIntIterator<value_type, false>;
  using const_iterator = iterator;
  using reverse_iterator = detail::SafeIntIterator<value_type, true>;
  using const_reverse_iterator = reverse_iterator;
  using difference_type = intmax_t;
  using size_type = std::size_t;

  explicit iota_range(T Begin, T End, bool Inclusive)
      : BeginValue(Begin), PastEndValue(End) {
    (__builtin_expect(!(Begin <= End && "Begin must be less or equal to End."), 0) ? __assert_rtn(__func__, "Sequence.h", 275, "Begin <= End && \"Begin must be less or equal to End.\"") : (void)0);
    if (Inclusive)
      ++PastEndValue;
  }

  size_t size() const { return PastEndValue - BeginValue; }
  bool empty() const { return BeginValue == PastEndValue; }

  auto begin() const { return const_iterator(BeginValue); }
  auto end() const { return const_iterator(PastEndValue); }

  auto rbegin() const { return const_reverse_iterator(PastEndValue - 1); }
  auto rend() const { return const_reverse_iterator(BeginValue - 1); }

private:
  static_assert(std::is_integral<T>::value || std::is_enum<T>::value,
                "T must be an integral or enum type");
  static_assert(std::is_same<T, std::remove_cv_t<T>>::value,
                "T must not be const nor volatile");

  iterator BeginValue;
  iterator PastEndValue;
};





template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&
                                                  !std::is_enum<T>::value>>
auto seq(T Begin, T End) {
  return iota_range<T>(Begin, End, false);
}





template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&
                                                  !std::is_enum<T>::value>>
auto seq(T Size) {
  return seq<T>(0, Size);
}





template <typename T, typename = std::enable_if_t<std::is_integral<T>::value &&
                                                  !std::is_enum<T>::value>>
auto seq_inclusive(T Begin, T End) {
  return iota_range<T>(Begin, End, true);
}







template <typename EnumT,
          typename = std::enable_if_t<std::is_enum<EnumT>::value>>
auto enum_seq(EnumT Begin, EnumT End) {
  static_assert(enum_iteration_traits<EnumT>::is_iterable,
                "Enum type is not marked as iterable.");
  return iota_range<EnumT>(Begin, End, false);
}
# 350 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Sequence.h"
template <typename EnumT,
          typename = std::enable_if_t<std::is_enum<EnumT>::value>>
auto enum_seq(EnumT Begin, EnumT End, force_iteration_on_noniterable_enum_t) {
  return iota_range<EnumT>(Begin, End, false);
}







template <typename EnumT,
          typename = std::enable_if_t<std::is_enum<EnumT>::value>>
auto enum_seq_inclusive(EnumT Begin, EnumT End) {
  static_assert(enum_iteration_traits<EnumT>::is_iterable,
                "Enum type is not marked as iterable.");
  return iota_range<EnumT>(Begin, End, true);
}
# 377 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Sequence.h"
template <typename EnumT,
          typename = std::enable_if_t<std::is_enum<EnumT>::value>>
auto enum_seq_inclusive(EnumT Begin, EnumT End,
                        force_iteration_on_noniterable_enum_t) {
  return iota_range<EnumT>(Begin, End, true);
}

}
# 7 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/Directive/Spelling.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/Directive/Spelling.h"
namespace llvm::directive {

struct VersionRange {
  static constexpr int MaxValue = std::numeric_limits<int>::max();


  int Min = 0;
  int Max = MaxValue;

  bool operator<(const VersionRange &R) const {
    return std::tie(Min, Max) < std::tie(R.Min, R.Max);
  }
};

struct Spelling {
  StringRef Name;
  VersionRange Versions;
};

__attribute__((visibility("default"))) StringRef FindName(llvm::iterator_range<const Spelling *>,
                            unsigned Version);

}
# 9 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 2




namespace llvm {
namespace acc {

using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator<<; using ::llvm::BitmaskEnumDetail::operator>>; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::operator<<=; using ::llvm::BitmaskEnumDetail::operator>>=; using ::llvm::BitmaskEnumDetail::operator!; using ::llvm::BitmaskEnumDetail::any;

enum class Association {
  Block,
  First_ = Block,
  Declaration,
  Delimited,
  Loop,
  None,
  Separating,
  Last_ = Separating,
};

static constexpr std::size_t Association_enumSize = 6;

enum class Category {
  Declarative,
  First_ = Declarative,
  Executable,
  Informational,
  Meta,
  Subsidiary,
  Utility,
  Last_ = Utility,
};

static constexpr std::size_t Category_enumSize = 6;

enum class SourceLanguage : uint32_t {
  C = 1U,
  Fortran = 2U,
  LLVM_BITMASK_LARGEST_ENUMERATOR = Fortran
};

static constexpr std::size_t SourceLanguage_enumSize = 2;

enum class Directive {
  ACCD_atomic,
  First_ = ACCD_atomic,
  ACCD_cache,
  ACCD_data,
  ACCD_declare,
  ACCD_enter_data,
  ACCD_exit_data,
  ACCD_host_data,
  ACCD_init,
  ACCD_kernels,
  ACCD_kernels_loop,
  ACCD_loop,
  ACCD_parallel,
  ACCD_parallel_loop,
  ACCD_routine,
  ACCD_serial,
  ACCD_serial_loop,
  ACCD_set,
  ACCD_shutdown,
  ACCD_unknown,
  ACCD_update,
  ACCD_wait,
  Last_ = ACCD_wait,
};

static constexpr std::size_t Directive_enumSize = 21;

constexpr auto ACCD_atomic = Directive::ACCD_atomic;
constexpr auto ACCD_cache = Directive::ACCD_cache;
constexpr auto ACCD_data = Directive::ACCD_data;
constexpr auto ACCD_declare = Directive::ACCD_declare;
constexpr auto ACCD_enter_data = Directive::ACCD_enter_data;
constexpr auto ACCD_exit_data = Directive::ACCD_exit_data;
constexpr auto ACCD_host_data = Directive::ACCD_host_data;
constexpr auto ACCD_init = Directive::ACCD_init;
constexpr auto ACCD_kernels = Directive::ACCD_kernels;
constexpr auto ACCD_kernels_loop = Directive::ACCD_kernels_loop;
constexpr auto ACCD_loop = Directive::ACCD_loop;
constexpr auto ACCD_parallel = Directive::ACCD_parallel;
constexpr auto ACCD_parallel_loop = Directive::ACCD_parallel_loop;
constexpr auto ACCD_routine = Directive::ACCD_routine;
constexpr auto ACCD_serial = Directive::ACCD_serial;
constexpr auto ACCD_serial_loop = Directive::ACCD_serial_loop;
constexpr auto ACCD_set = Directive::ACCD_set;
constexpr auto ACCD_shutdown = Directive::ACCD_shutdown;
constexpr auto ACCD_unknown = Directive::ACCD_unknown;
constexpr auto ACCD_update = Directive::ACCD_update;
constexpr auto ACCD_wait = Directive::ACCD_wait;

enum class Clause {
  ACCC_async,
  First_ = ACCC_async,
  ACCC_attach,
  ACCC_auto,
  ACCC_bind,
  ACCC_capture,
  ACCC_collapse,
  ACCC_copy,
  ACCC_copyin,
  ACCC_copyout,
  ACCC_create,
  ACCC_default,
  ACCC_default_async,
  ACCC_delete,
  ACCC_detach,
  ACCC_device,
  ACCC_device_num,
  ACCC_deviceptr,
  ACCC_device_resident,
  ACCC_device_type,
  ACCC_finalize,
  ACCC_firstprivate,
  ACCC_gang,
  ACCC_host,
  ACCC_if,
  ACCC_if_present,
  ACCC_independent,
  ACCC_link,
  ACCC_no_create,
  ACCC_nohost,
  ACCC_num_gangs,
  ACCC_num_workers,
  ACCC_present,
  ACCC_private,
  ACCC_read,
  ACCC_reduction,
  ACCC_self,
  ACCC_seq,
  ACCC_shortloop,
  ACCC_tile,
  ACCC_unknown,
  ACCC_use_device,
  ACCC_vector,
  ACCC_vector_length,
  ACCC_wait,
  ACCC_worker,
  ACCC_write,
  Last_ = ACCC_write,
};

static constexpr std::size_t Clause_enumSize = 46;

constexpr auto ACCC_async = Clause::ACCC_async;
constexpr auto ACCC_attach = Clause::ACCC_attach;
constexpr auto ACCC_auto = Clause::ACCC_auto;
constexpr auto ACCC_bind = Clause::ACCC_bind;
constexpr auto ACCC_capture = Clause::ACCC_capture;
constexpr auto ACCC_collapse = Clause::ACCC_collapse;
constexpr auto ACCC_copy = Clause::ACCC_copy;
constexpr auto ACCC_copyin = Clause::ACCC_copyin;
constexpr auto ACCC_copyout = Clause::ACCC_copyout;
constexpr auto ACCC_create = Clause::ACCC_create;
constexpr auto ACCC_default = Clause::ACCC_default;
constexpr auto ACCC_default_async = Clause::ACCC_default_async;
constexpr auto ACCC_delete = Clause::ACCC_delete;
constexpr auto ACCC_detach = Clause::ACCC_detach;
constexpr auto ACCC_device = Clause::ACCC_device;
constexpr auto ACCC_device_num = Clause::ACCC_device_num;
constexpr auto ACCC_deviceptr = Clause::ACCC_deviceptr;
constexpr auto ACCC_device_resident = Clause::ACCC_device_resident;
constexpr auto ACCC_device_type = Clause::ACCC_device_type;
constexpr auto ACCC_finalize = Clause::ACCC_finalize;
constexpr auto ACCC_firstprivate = Clause::ACCC_firstprivate;
constexpr auto ACCC_gang = Clause::ACCC_gang;
constexpr auto ACCC_host = Clause::ACCC_host;
constexpr auto ACCC_if = Clause::ACCC_if;
constexpr auto ACCC_if_present = Clause::ACCC_if_present;
constexpr auto ACCC_independent = Clause::ACCC_independent;
constexpr auto ACCC_link = Clause::ACCC_link;
constexpr auto ACCC_no_create = Clause::ACCC_no_create;
constexpr auto ACCC_nohost = Clause::ACCC_nohost;
constexpr auto ACCC_num_gangs = Clause::ACCC_num_gangs;
constexpr auto ACCC_num_workers = Clause::ACCC_num_workers;
constexpr auto ACCC_present = Clause::ACCC_present;
constexpr auto ACCC_private = Clause::ACCC_private;
constexpr auto ACCC_read = Clause::ACCC_read;
constexpr auto ACCC_reduction = Clause::ACCC_reduction;
constexpr auto ACCC_self = Clause::ACCC_self;
constexpr auto ACCC_seq = Clause::ACCC_seq;
constexpr auto ACCC_shortloop = Clause::ACCC_shortloop;
constexpr auto ACCC_tile = Clause::ACCC_tile;
constexpr auto ACCC_unknown = Clause::ACCC_unknown;
constexpr auto ACCC_use_device = Clause::ACCC_use_device;
constexpr auto ACCC_vector = Clause::ACCC_vector;
constexpr auto ACCC_vector_length = Clause::ACCC_vector_length;
constexpr auto ACCC_wait = Clause::ACCC_wait;
constexpr auto ACCC_worker = Clause::ACCC_worker;
constexpr auto ACCC_write = Clause::ACCC_write;

enum class DefaultValue {
  ACC_Default_present=0,
  ACC_Default_none=1,
};

constexpr auto ACC_Default_present = DefaultValue::ACC_Default_present;
constexpr auto ACC_Default_none = DefaultValue::ACC_Default_none;


__attribute__((visibility("default"))) std::pair<Directive, directive::VersionRange> getOpenACCDirectiveKindAndVersions(StringRef Str);
inline Directive getOpenACCDirectiveKind(StringRef Str) {
  return getOpenACCDirectiveKindAndVersions(Str).first;
}

__attribute__((visibility("default"))) StringRef getOpenACCDirectiveName(Directive D, unsigned Ver = 0);

__attribute__((visibility("default"))) std::pair<Clause, directive::VersionRange> getOpenACCClauseKindAndVersions(StringRef Str);

inline Clause getOpenACCClauseKind(StringRef Str) {
  return getOpenACCClauseKindAndVersions(Str).first;
}

__attribute__((visibility("default"))) StringRef getOpenACCClauseName(Clause C, unsigned Ver = 0);


__attribute__((visibility("default"))) bool isAllowedClauseForDirective(Directive D, Clause C, unsigned Version);

constexpr std::size_t getMaxLeafCount() { return 2; }
__attribute__((visibility("default"))) Association getDirectiveAssociation(Directive D);
__attribute__((visibility("default"))) Category getDirectiveCategory(Directive D);
__attribute__((visibility("default"))) SourceLanguage getDirectiveLanguages(Directive D);
__attribute__((visibility("default"))) DefaultValue getDefaultValue(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenACCDefaultValueName(DefaultValue x);

}

template <> struct enum_iteration_traits<acc::Association> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<acc::Category> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<acc::Directive> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<acc::Clause> {
  static constexpr bool is_iterable = true;
};
}
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h.inc" 1
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h.inc"
namespace llvm {
namespace omp {

using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator<<; using ::llvm::BitmaskEnumDetail::operator>>; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::operator<<=; using ::llvm::BitmaskEnumDetail::operator>>=; using ::llvm::BitmaskEnumDetail::operator!; using ::llvm::BitmaskEnumDetail::any;

enum class Association {
  Block,
  First_ = Block,
  Declaration,
  Delimited,
  Loop,
  None,
  Separating,
  Last_ = Separating,
};

static constexpr std::size_t Association_enumSize = 6;

enum class Category {
  Declarative,
  First_ = Declarative,
  Executable,
  Informational,
  Meta,
  Subsidiary,
  Utility,
  Last_ = Utility,
};

static constexpr std::size_t Category_enumSize = 6;

enum class SourceLanguage : uint32_t {
  C = 1U,
  Fortran = 2U,
  LLVM_BITMASK_LARGEST_ENUMERATOR = Fortran
};

static constexpr std::size_t SourceLanguage_enumSize = 2;

enum class Directive {
  OMPD_allocate,
  First_ = OMPD_allocate,
  OMPD_allocators,
  OMPD_assume,
  OMPD_assumes,
  OMPD_atomic,
  OMPD_barrier,
  OMPD_begin_assumes,
  OMPD_begin_declare_target,
  OMPD_begin_declare_variant,
  OMPD_cancel,
  OMPD_cancellation_point,
  OMPD_critical,
  OMPD_declare_mapper,
  OMPD_declare_reduction,
  OMPD_declare_simd,
  OMPD_declare_target,
  OMPD_declare_variant,
  OMPD_depobj,
  OMPD_distribute,
  OMPD_distribute_parallel_do,
  OMPD_distribute_parallel_do_simd,
  OMPD_distribute_parallel_for,
  OMPD_distribute_parallel_for_simd,
  OMPD_distribute_simd,
  OMPD_do,
  OMPD_do_simd,
  OMPD_end_assumes,
  OMPD_end_declare_target,
  OMPD_end_declare_variant,
  OMPD_end_do,
  OMPD_end_do_simd,
  OMPD_end_scope,
  OMPD_end_sections,
  OMPD_end_single,
  OMPD_end_workshare,
  OMPD_error,
  OMPD_flush,
  OMPD_for,
  OMPD_for_simd,
  OMPD_interchange,
  OMPD_masked_taskloop,
  OMPD_masked_taskloop_simd,
  OMPD_master,
  OMPD_master_taskloop,
  OMPD_master_taskloop_simd,
  OMPD_metadirective,
  OMPD_nothing,
  OMPD_ordered,
  OMPD_parallel,
  OMPD_parallel_do,
  OMPD_parallel_do_simd,
  OMPD_parallel_for,
  OMPD_parallel_for_simd,
  OMPD_parallel_masked,
  OMPD_parallel_masked_taskloop,
  OMPD_parallel_masked_taskloop_simd,
  OMPD_parallel_master,
  OMPD_parallel_master_taskloop,
  OMPD_parallel_master_taskloop_simd,
  OMPD_parallel_sections,
  OMPD_parallel_workshare,
  OMPD_requires,
  OMPD_reverse,
  OMPD_scan,
  OMPD_scope,
  OMPD_section,
  OMPD_sections,
  OMPD_simd,
  OMPD_single,
  OMPD_stripe,
  OMPD_target,
  OMPD_target_data,
  OMPD_target_enter_data,
  OMPD_target_exit_data,
  OMPD_target_parallel,
  OMPD_target_parallel_do,
  OMPD_target_parallel_do_simd,
  OMPD_target_parallel_for,
  OMPD_target_parallel_for_simd,
  OMPD_target_simd,
  OMPD_target_teams,
  OMPD_target_teams_distribute,
  OMPD_target_teams_distribute_parallel_do,
  OMPD_target_teams_distribute_parallel_do_simd,
  OMPD_target_teams_distribute_parallel_for,
  OMPD_target_teams_distribute_parallel_for_simd,
  OMPD_target_teams_distribute_simd,
  OMPD_target_update,
  OMPD_task,
  OMPD_taskgroup,
  OMPD_taskloop,
  OMPD_taskloop_simd,
  OMPD_taskwait,
  OMPD_taskyield,
  OMPD_teams,
  OMPD_teams_distribute,
  OMPD_teams_distribute_parallel_do,
  OMPD_teams_distribute_parallel_do_simd,
  OMPD_teams_distribute_parallel_for,
  OMPD_teams_distribute_parallel_for_simd,
  OMPD_teams_distribute_simd,
  OMPD_threadprivate,
  OMPD_tile,
  OMPD_unknown,
  OMPD_unroll,
  OMPD_workshare,
  OMPD_dispatch,
  OMPD_interop,
  OMPD_loop,
  OMPD_masked,
  OMPD_parallel_loop,
  OMPD_target_loop,
  OMPD_target_parallel_loop,
  OMPD_target_teams_loop,
  OMPD_teams_loop,
  Last_ = OMPD_teams_loop,
};

static constexpr std::size_t Directive_enumSize = 115;

constexpr auto OMPD_allocate = Directive::OMPD_allocate;
constexpr auto OMPD_allocators = Directive::OMPD_allocators;
constexpr auto OMPD_assume = Directive::OMPD_assume;
constexpr auto OMPD_assumes = Directive::OMPD_assumes;
constexpr auto OMPD_atomic = Directive::OMPD_atomic;
constexpr auto OMPD_barrier = Directive::OMPD_barrier;
constexpr auto OMPD_begin_assumes = Directive::OMPD_begin_assumes;
constexpr auto OMPD_begin_declare_target = Directive::OMPD_begin_declare_target;
constexpr auto OMPD_begin_declare_variant = Directive::OMPD_begin_declare_variant;
constexpr auto OMPD_cancel = Directive::OMPD_cancel;
constexpr auto OMPD_cancellation_point = Directive::OMPD_cancellation_point;
constexpr auto OMPD_critical = Directive::OMPD_critical;
constexpr auto OMPD_declare_mapper = Directive::OMPD_declare_mapper;
constexpr auto OMPD_declare_reduction = Directive::OMPD_declare_reduction;
constexpr auto OMPD_declare_simd = Directive::OMPD_declare_simd;
constexpr auto OMPD_declare_target = Directive::OMPD_declare_target;
constexpr auto OMPD_declare_variant = Directive::OMPD_declare_variant;
constexpr auto OMPD_depobj = Directive::OMPD_depobj;
constexpr auto OMPD_distribute = Directive::OMPD_distribute;
constexpr auto OMPD_distribute_parallel_do = Directive::OMPD_distribute_parallel_do;
constexpr auto OMPD_distribute_parallel_do_simd = Directive::OMPD_distribute_parallel_do_simd;
constexpr auto OMPD_distribute_parallel_for = Directive::OMPD_distribute_parallel_for;
constexpr auto OMPD_distribute_parallel_for_simd = Directive::OMPD_distribute_parallel_for_simd;
constexpr auto OMPD_distribute_simd = Directive::OMPD_distribute_simd;
constexpr auto OMPD_do = Directive::OMPD_do;
constexpr auto OMPD_do_simd = Directive::OMPD_do_simd;
constexpr auto OMPD_end_assumes = Directive::OMPD_end_assumes;
constexpr auto OMPD_end_declare_target = Directive::OMPD_end_declare_target;
constexpr auto OMPD_end_declare_variant = Directive::OMPD_end_declare_variant;
constexpr auto OMPD_end_do = Directive::OMPD_end_do;
constexpr auto OMPD_end_do_simd = Directive::OMPD_end_do_simd;
constexpr auto OMPD_end_scope = Directive::OMPD_end_scope;
constexpr auto OMPD_end_sections = Directive::OMPD_end_sections;
constexpr auto OMPD_end_single = Directive::OMPD_end_single;
constexpr auto OMPD_end_workshare = Directive::OMPD_end_workshare;
constexpr auto OMPD_error = Directive::OMPD_error;
constexpr auto OMPD_flush = Directive::OMPD_flush;
constexpr auto OMPD_for = Directive::OMPD_for;
constexpr auto OMPD_for_simd = Directive::OMPD_for_simd;
constexpr auto OMPD_interchange = Directive::OMPD_interchange;
constexpr auto OMPD_masked_taskloop = Directive::OMPD_masked_taskloop;
constexpr auto OMPD_masked_taskloop_simd = Directive::OMPD_masked_taskloop_simd;
constexpr auto OMPD_master = Directive::OMPD_master;
constexpr auto OMPD_master_taskloop = Directive::OMPD_master_taskloop;
constexpr auto OMPD_master_taskloop_simd = Directive::OMPD_master_taskloop_simd;
constexpr auto OMPD_metadirective = Directive::OMPD_metadirective;
constexpr auto OMPD_nothing = Directive::OMPD_nothing;
constexpr auto OMPD_ordered = Directive::OMPD_ordered;
constexpr auto OMPD_parallel = Directive::OMPD_parallel;
constexpr auto OMPD_parallel_do = Directive::OMPD_parallel_do;
constexpr auto OMPD_parallel_do_simd = Directive::OMPD_parallel_do_simd;
constexpr auto OMPD_parallel_for = Directive::OMPD_parallel_for;
constexpr auto OMPD_parallel_for_simd = Directive::OMPD_parallel_for_simd;
constexpr auto OMPD_parallel_masked = Directive::OMPD_parallel_masked;
constexpr auto OMPD_parallel_masked_taskloop = Directive::OMPD_parallel_masked_taskloop;
constexpr auto OMPD_parallel_masked_taskloop_simd = Directive::OMPD_parallel_masked_taskloop_simd;
constexpr auto OMPD_parallel_master = Directive::OMPD_parallel_master;
constexpr auto OMPD_parallel_master_taskloop = Directive::OMPD_parallel_master_taskloop;
constexpr auto OMPD_parallel_master_taskloop_simd = Directive::OMPD_parallel_master_taskloop_simd;
constexpr auto OMPD_parallel_sections = Directive::OMPD_parallel_sections;
constexpr auto OMPD_parallel_workshare = Directive::OMPD_parallel_workshare;
constexpr auto OMPD_requires = Directive::OMPD_requires;
constexpr auto OMPD_reverse = Directive::OMPD_reverse;
constexpr auto OMPD_scan = Directive::OMPD_scan;
constexpr auto OMPD_scope = Directive::OMPD_scope;
constexpr auto OMPD_section = Directive::OMPD_section;
constexpr auto OMPD_sections = Directive::OMPD_sections;
constexpr auto OMPD_simd = Directive::OMPD_simd;
constexpr auto OMPD_single = Directive::OMPD_single;
constexpr auto OMPD_stripe = Directive::OMPD_stripe;
constexpr auto OMPD_target = Directive::OMPD_target;
constexpr auto OMPD_target_data = Directive::OMPD_target_data;
constexpr auto OMPD_target_enter_data = Directive::OMPD_target_enter_data;
constexpr auto OMPD_target_exit_data = Directive::OMPD_target_exit_data;
constexpr auto OMPD_target_parallel = Directive::OMPD_target_parallel;
constexpr auto OMPD_target_parallel_do = Directive::OMPD_target_parallel_do;
constexpr auto OMPD_target_parallel_do_simd = Directive::OMPD_target_parallel_do_simd;
constexpr auto OMPD_target_parallel_for = Directive::OMPD_target_parallel_for;
constexpr auto OMPD_target_parallel_for_simd = Directive::OMPD_target_parallel_for_simd;
constexpr auto OMPD_target_simd = Directive::OMPD_target_simd;
constexpr auto OMPD_target_teams = Directive::OMPD_target_teams;
constexpr auto OMPD_target_teams_distribute = Directive::OMPD_target_teams_distribute;
constexpr auto OMPD_target_teams_distribute_parallel_do = Directive::OMPD_target_teams_distribute_parallel_do;
constexpr auto OMPD_target_teams_distribute_parallel_do_simd = Directive::OMPD_target_teams_distribute_parallel_do_simd;
constexpr auto OMPD_target_teams_distribute_parallel_for = Directive::OMPD_target_teams_distribute_parallel_for;
constexpr auto OMPD_target_teams_distribute_parallel_for_simd = Directive::OMPD_target_teams_distribute_parallel_for_simd;
constexpr auto OMPD_target_teams_distribute_simd = Directive::OMPD_target_teams_distribute_simd;
constexpr auto OMPD_target_update = Directive::OMPD_target_update;
constexpr auto OMPD_task = Directive::OMPD_task;
constexpr auto OMPD_taskgroup = Directive::OMPD_taskgroup;
constexpr auto OMPD_taskloop = Directive::OMPD_taskloop;
constexpr auto OMPD_taskloop_simd = Directive::OMPD_taskloop_simd;
constexpr auto OMPD_taskwait = Directive::OMPD_taskwait;
constexpr auto OMPD_taskyield = Directive::OMPD_taskyield;
constexpr auto OMPD_teams = Directive::OMPD_teams;
constexpr auto OMPD_teams_distribute = Directive::OMPD_teams_distribute;
constexpr auto OMPD_teams_distribute_parallel_do = Directive::OMPD_teams_distribute_parallel_do;
constexpr auto OMPD_teams_distribute_parallel_do_simd = Directive::OMPD_teams_distribute_parallel_do_simd;
constexpr auto OMPD_teams_distribute_parallel_for = Directive::OMPD_teams_distribute_parallel_for;
constexpr auto OMPD_teams_distribute_parallel_for_simd = Directive::OMPD_teams_distribute_parallel_for_simd;
constexpr auto OMPD_teams_distribute_simd = Directive::OMPD_teams_distribute_simd;
constexpr auto OMPD_threadprivate = Directive::OMPD_threadprivate;
constexpr auto OMPD_tile = Directive::OMPD_tile;
constexpr auto OMPD_unknown = Directive::OMPD_unknown;
constexpr auto OMPD_unroll = Directive::OMPD_unroll;
constexpr auto OMPD_workshare = Directive::OMPD_workshare;
constexpr auto OMPD_dispatch = Directive::OMPD_dispatch;
constexpr auto OMPD_interop = Directive::OMPD_interop;
constexpr auto OMPD_loop = Directive::OMPD_loop;
constexpr auto OMPD_masked = Directive::OMPD_masked;
constexpr auto OMPD_parallel_loop = Directive::OMPD_parallel_loop;
constexpr auto OMPD_target_loop = Directive::OMPD_target_loop;
constexpr auto OMPD_target_parallel_loop = Directive::OMPD_target_parallel_loop;
constexpr auto OMPD_target_teams_loop = Directive::OMPD_target_teams_loop;
constexpr auto OMPD_teams_loop = Directive::OMPD_teams_loop;

enum class Clause {
  OMPC_absent,
  First_ = OMPC_absent,
  OMPC_acq_rel,
  OMPC_acquire,
  OMPC_adjust_args,
  OMPC_affinity,
  OMPC_align,
  OMPC_aligned,
  OMPC_allocate,
  OMPC_allocator,
  OMPC_append_args,
  OMPC_at,
  OMPC_atomic_default_mem_order,
  OMPC_bind,
  OMPC_cancellation_construct_type,
  OMPC_capture,
  OMPC_collapse,
  OMPC_compare,
  OMPC_contains,
  OMPC_copyprivate,
  OMPC_copyin,
  OMPC_default,
  OMPC_defaultmap,
  OMPC_depend,
  OMPC_depobj,
  OMPC_destroy,
  OMPC_detach,
  OMPC_device,
  OMPC_device_type,
  OMPC_dist_schedule,
  OMPC_doacross,
  OMPC_dynamic_allocators,
  OMPC_enter,
  OMPC_exclusive,
  OMPC_fail,
  OMPC_filter,
  OMPC_final,
  OMPC_firstprivate,
  OMPC_flush,
  OMPC_from,
  OMPC_full,
  OMPC_grainsize,
  OMPC_has_device_addr,
  OMPC_hint,
  OMPC_holds,
  OMPC_if,
  OMPC_in_reduction,
  OMPC_inbranch,
  OMPC_inclusive,
  OMPC_indirect,
  OMPC_init,
  OMPC_initializer,
  OMPC_is_device_ptr,
  OMPC_lastprivate,
  OMPC_linear,
  OMPC_link,
  OMPC_map,
  OMPC_match,
  OMPC_memory_order,
  OMPC_mergeable,
  OMPC_message,
  OMPC_nogroup,
  OMPC_no_openmp,
  OMPC_no_openmp_constructs,
  OMPC_no_openmp_routines,
  OMPC_no_parallelism,
  OMPC_nowait,
  OMPC_nocontext,
  OMPC_nontemporal,
  OMPC_notinbranch,
  OMPC_novariants,
  OMPC_num_tasks,
  OMPC_num_teams,
  OMPC_num_threads,
  OMPC_ompx_attribute,
  OMPC_ompx_bare,
  OMPC_ompx_dyn_cgroup_mem,
  OMPC_order,
  OMPC_ordered,
  OMPC_otherwise,
  OMPC_partial,
  OMPC_permutation,
  OMPC_priority,
  OMPC_private,
  OMPC_proc_bind,
  OMPC_read,
  OMPC_reduction,
  OMPC_relaxed,
  OMPC_release,
  OMPC_reverse_offload,
  OMPC_safelen,
  OMPC_schedule,
  OMPC_self_maps,
  OMPC_seq_cst,
  OMPC_severity,
  OMPC_shared,
  OMPC_simd,
  OMPC_simdlen,
  OMPC_sizes,
  OMPC_task_reduction,
  OMPC_thread_limit,
  OMPC_threadprivate,
  OMPC_threads,
  OMPC_to,
  OMPC_unified_address,
  OMPC_unified_shared_memory,
  OMPC_uniform,
  OMPC_unknown,
  OMPC_untied,
  OMPC_update,
  OMPC_use,
  OMPC_use_device_addr,
  OMPC_use_device_ptr,
  OMPC_uses_allocators,
  OMPC_weak,
  OMPC_when,
  OMPC_write,
  Last_ = OMPC_write,
};

static constexpr std::size_t Clause_enumSize = 116;

constexpr auto OMPC_absent = Clause::OMPC_absent;
constexpr auto OMPC_acq_rel = Clause::OMPC_acq_rel;
constexpr auto OMPC_acquire = Clause::OMPC_acquire;
constexpr auto OMPC_adjust_args = Clause::OMPC_adjust_args;
constexpr auto OMPC_affinity = Clause::OMPC_affinity;
constexpr auto OMPC_align = Clause::OMPC_align;
constexpr auto OMPC_aligned = Clause::OMPC_aligned;
constexpr auto OMPC_allocate = Clause::OMPC_allocate;
constexpr auto OMPC_allocator = Clause::OMPC_allocator;
constexpr auto OMPC_append_args = Clause::OMPC_append_args;
constexpr auto OMPC_at = Clause::OMPC_at;
constexpr auto OMPC_atomic_default_mem_order = Clause::OMPC_atomic_default_mem_order;
constexpr auto OMPC_bind = Clause::OMPC_bind;
constexpr auto OMPC_cancellation_construct_type = Clause::OMPC_cancellation_construct_type;
constexpr auto OMPC_capture = Clause::OMPC_capture;
constexpr auto OMPC_collapse = Clause::OMPC_collapse;
constexpr auto OMPC_compare = Clause::OMPC_compare;
constexpr auto OMPC_contains = Clause::OMPC_contains;
constexpr auto OMPC_copyprivate = Clause::OMPC_copyprivate;
constexpr auto OMPC_copyin = Clause::OMPC_copyin;
constexpr auto OMPC_default = Clause::OMPC_default;
constexpr auto OMPC_defaultmap = Clause::OMPC_defaultmap;
constexpr auto OMPC_depend = Clause::OMPC_depend;
constexpr auto OMPC_depobj = Clause::OMPC_depobj;
constexpr auto OMPC_destroy = Clause::OMPC_destroy;
constexpr auto OMPC_detach = Clause::OMPC_detach;
constexpr auto OMPC_device = Clause::OMPC_device;
constexpr auto OMPC_device_type = Clause::OMPC_device_type;
constexpr auto OMPC_dist_schedule = Clause::OMPC_dist_schedule;
constexpr auto OMPC_doacross = Clause::OMPC_doacross;
constexpr auto OMPC_dynamic_allocators = Clause::OMPC_dynamic_allocators;
constexpr auto OMPC_enter = Clause::OMPC_enter;
constexpr auto OMPC_exclusive = Clause::OMPC_exclusive;
constexpr auto OMPC_fail = Clause::OMPC_fail;
constexpr auto OMPC_filter = Clause::OMPC_filter;
constexpr auto OMPC_final = Clause::OMPC_final;
constexpr auto OMPC_firstprivate = Clause::OMPC_firstprivate;
constexpr auto OMPC_flush = Clause::OMPC_flush;
constexpr auto OMPC_from = Clause::OMPC_from;
constexpr auto OMPC_full = Clause::OMPC_full;
constexpr auto OMPC_grainsize = Clause::OMPC_grainsize;
constexpr auto OMPC_has_device_addr = Clause::OMPC_has_device_addr;
constexpr auto OMPC_hint = Clause::OMPC_hint;
constexpr auto OMPC_holds = Clause::OMPC_holds;
constexpr auto OMPC_if = Clause::OMPC_if;
constexpr auto OMPC_in_reduction = Clause::OMPC_in_reduction;
constexpr auto OMPC_inbranch = Clause::OMPC_inbranch;
constexpr auto OMPC_inclusive = Clause::OMPC_inclusive;
constexpr auto OMPC_indirect = Clause::OMPC_indirect;
constexpr auto OMPC_init = Clause::OMPC_init;
constexpr auto OMPC_initializer = Clause::OMPC_initializer;
constexpr auto OMPC_is_device_ptr = Clause::OMPC_is_device_ptr;
constexpr auto OMPC_lastprivate = Clause::OMPC_lastprivate;
constexpr auto OMPC_linear = Clause::OMPC_linear;
constexpr auto OMPC_link = Clause::OMPC_link;
constexpr auto OMPC_map = Clause::OMPC_map;
constexpr auto OMPC_match = Clause::OMPC_match;
constexpr auto OMPC_memory_order = Clause::OMPC_memory_order;
constexpr auto OMPC_mergeable = Clause::OMPC_mergeable;
constexpr auto OMPC_message = Clause::OMPC_message;
constexpr auto OMPC_nogroup = Clause::OMPC_nogroup;
constexpr auto OMPC_no_openmp = Clause::OMPC_no_openmp;
constexpr auto OMPC_no_openmp_constructs = Clause::OMPC_no_openmp_constructs;
constexpr auto OMPC_no_openmp_routines = Clause::OMPC_no_openmp_routines;
constexpr auto OMPC_no_parallelism = Clause::OMPC_no_parallelism;
constexpr auto OMPC_nowait = Clause::OMPC_nowait;
constexpr auto OMPC_nocontext = Clause::OMPC_nocontext;
constexpr auto OMPC_nontemporal = Clause::OMPC_nontemporal;
constexpr auto OMPC_notinbranch = Clause::OMPC_notinbranch;
constexpr auto OMPC_novariants = Clause::OMPC_novariants;
constexpr auto OMPC_num_tasks = Clause::OMPC_num_tasks;
constexpr auto OMPC_num_teams = Clause::OMPC_num_teams;
constexpr auto OMPC_num_threads = Clause::OMPC_num_threads;
constexpr auto OMPC_ompx_attribute = Clause::OMPC_ompx_attribute;
constexpr auto OMPC_ompx_bare = Clause::OMPC_ompx_bare;
constexpr auto OMPC_ompx_dyn_cgroup_mem = Clause::OMPC_ompx_dyn_cgroup_mem;
constexpr auto OMPC_order = Clause::OMPC_order;
constexpr auto OMPC_ordered = Clause::OMPC_ordered;
constexpr auto OMPC_otherwise = Clause::OMPC_otherwise;
constexpr auto OMPC_partial = Clause::OMPC_partial;
constexpr auto OMPC_permutation = Clause::OMPC_permutation;
constexpr auto OMPC_priority = Clause::OMPC_priority;
constexpr auto OMPC_private = Clause::OMPC_private;
constexpr auto OMPC_proc_bind = Clause::OMPC_proc_bind;
constexpr auto OMPC_read = Clause::OMPC_read;
constexpr auto OMPC_reduction = Clause::OMPC_reduction;
constexpr auto OMPC_relaxed = Clause::OMPC_relaxed;
constexpr auto OMPC_release = Clause::OMPC_release;
constexpr auto OMPC_reverse_offload = Clause::OMPC_reverse_offload;
constexpr auto OMPC_safelen = Clause::OMPC_safelen;
constexpr auto OMPC_schedule = Clause::OMPC_schedule;
constexpr auto OMPC_self_maps = Clause::OMPC_self_maps;
constexpr auto OMPC_seq_cst = Clause::OMPC_seq_cst;
constexpr auto OMPC_severity = Clause::OMPC_severity;
constexpr auto OMPC_shared = Clause::OMPC_shared;
constexpr auto OMPC_simd = Clause::OMPC_simd;
constexpr auto OMPC_simdlen = Clause::OMPC_simdlen;
constexpr auto OMPC_sizes = Clause::OMPC_sizes;
constexpr auto OMPC_task_reduction = Clause::OMPC_task_reduction;
constexpr auto OMPC_thread_limit = Clause::OMPC_thread_limit;
constexpr auto OMPC_threadprivate = Clause::OMPC_threadprivate;
constexpr auto OMPC_threads = Clause::OMPC_threads;
constexpr auto OMPC_to = Clause::OMPC_to;
constexpr auto OMPC_unified_address = Clause::OMPC_unified_address;
constexpr auto OMPC_unified_shared_memory = Clause::OMPC_unified_shared_memory;
constexpr auto OMPC_uniform = Clause::OMPC_uniform;
constexpr auto OMPC_unknown = Clause::OMPC_unknown;
constexpr auto OMPC_untied = Clause::OMPC_untied;
constexpr auto OMPC_update = Clause::OMPC_update;
constexpr auto OMPC_use = Clause::OMPC_use;
constexpr auto OMPC_use_device_addr = Clause::OMPC_use_device_addr;
constexpr auto OMPC_use_device_ptr = Clause::OMPC_use_device_ptr;
constexpr auto OMPC_uses_allocators = Clause::OMPC_uses_allocators;
constexpr auto OMPC_weak = Clause::OMPC_weak;
constexpr auto OMPC_when = Clause::OMPC_when;
constexpr auto OMPC_write = Clause::OMPC_write;

enum class BindKind {
  OMP_BIND_parallel=1,
  OMP_BIND_teams=2,
  OMP_BIND_thread=3,
};

constexpr auto OMP_BIND_parallel = BindKind::OMP_BIND_parallel;
constexpr auto OMP_BIND_teams = BindKind::OMP_BIND_teams;
constexpr auto OMP_BIND_thread = BindKind::OMP_BIND_thread;

enum class CancellationConstructType {
  OMP_CANCELLATION_CONSTRUCT_Parallel=1,
  OMP_CANCELLATION_CONSTRUCT_Loop=2,
  OMP_CANCELLATION_CONSTRUCT_Sections=3,
  OMP_CANCELLATION_CONSTRUCT_Taskgroup=4,
  OMP_CANCELLATION_CONSTRUCT_None=5,
};

constexpr auto OMP_CANCELLATION_CONSTRUCT_Parallel = CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Parallel;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Loop = CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Loop;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Sections = CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Sections;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Taskgroup = CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Taskgroup;
constexpr auto OMP_CANCELLATION_CONSTRUCT_None = CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_None;

enum class GrainsizeType {
  OMP_GRAINSIZE_Strict=1,
  OMP_GRAINSIZE_Unknown=2,
};

constexpr auto OMP_GRAINSIZE_Strict = GrainsizeType::OMP_GRAINSIZE_Strict;
constexpr auto OMP_GRAINSIZE_Unknown = GrainsizeType::OMP_GRAINSIZE_Unknown;

enum class MemoryOrderKind {
  OMP_MEMORY_ORDER_SeqCst=1,
  OMP_MEMORY_ORDER_AcqRel=2,
  OMP_MEMORY_ORDER_Acquire=3,
  OMP_MEMORY_ORDER_Release=4,
  OMP_MEMORY_ORDER_Relaxed=5,
  OMP_MEMORY_ORDER_Default=6,
};

constexpr auto OMP_MEMORY_ORDER_SeqCst = MemoryOrderKind::OMP_MEMORY_ORDER_SeqCst;
constexpr auto OMP_MEMORY_ORDER_AcqRel = MemoryOrderKind::OMP_MEMORY_ORDER_AcqRel;
constexpr auto OMP_MEMORY_ORDER_Acquire = MemoryOrderKind::OMP_MEMORY_ORDER_Acquire;
constexpr auto OMP_MEMORY_ORDER_Release = MemoryOrderKind::OMP_MEMORY_ORDER_Release;
constexpr auto OMP_MEMORY_ORDER_Relaxed = MemoryOrderKind::OMP_MEMORY_ORDER_Relaxed;
constexpr auto OMP_MEMORY_ORDER_Default = MemoryOrderKind::OMP_MEMORY_ORDER_Default;

enum class NumTasksType {
  OMP_NUMTASKS_Strict=1,
  OMP_NUMTASKS_Unknown=2,
};

constexpr auto OMP_NUMTASKS_Strict = NumTasksType::OMP_NUMTASKS_Strict;
constexpr auto OMP_NUMTASKS_Unknown = NumTasksType::OMP_NUMTASKS_Unknown;

enum class NumThreadsType {
  OMP_NUMTHREADS_Strict=1,
  OMP_NUMTHREADS_Unknown=2,
};

constexpr auto OMP_NUMTHREADS_Strict = NumThreadsType::OMP_NUMTHREADS_Strict;
constexpr auto OMP_NUMTHREADS_Unknown = NumThreadsType::OMP_NUMTHREADS_Unknown;

enum class OrderKind {
  OMP_ORDER_unknown=2,
  OMP_ORDER_concurrent=1,
};

constexpr auto OMP_ORDER_unknown = OrderKind::OMP_ORDER_unknown;
constexpr auto OMP_ORDER_concurrent = OrderKind::OMP_ORDER_concurrent;

enum class ProcBindKind {
  OMP_PROC_BIND_primary=5,
  OMP_PROC_BIND_master=2,
  OMP_PROC_BIND_close=3,
  OMP_PROC_BIND_spread=4,
  OMP_PROC_BIND_default=6,
  OMP_PROC_BIND_unknown=7,
};

constexpr auto OMP_PROC_BIND_primary = ProcBindKind::OMP_PROC_BIND_primary;
constexpr auto OMP_PROC_BIND_master = ProcBindKind::OMP_PROC_BIND_master;
constexpr auto OMP_PROC_BIND_close = ProcBindKind::OMP_PROC_BIND_close;
constexpr auto OMP_PROC_BIND_spread = ProcBindKind::OMP_PROC_BIND_spread;
constexpr auto OMP_PROC_BIND_default = ProcBindKind::OMP_PROC_BIND_default;
constexpr auto OMP_PROC_BIND_unknown = ProcBindKind::OMP_PROC_BIND_unknown;

enum class ScheduleKind {
  OMP_SCHEDULE_Static=2,
  OMP_SCHEDULE_Dynamic=3,
  OMP_SCHEDULE_Guided=4,
  OMP_SCHEDULE_Auto=5,
  OMP_SCHEDULE_Runtime=6,
  OMP_SCHEDULE_Default=7,
};

constexpr auto OMP_SCHEDULE_Static = ScheduleKind::OMP_SCHEDULE_Static;
constexpr auto OMP_SCHEDULE_Dynamic = ScheduleKind::OMP_SCHEDULE_Dynamic;
constexpr auto OMP_SCHEDULE_Guided = ScheduleKind::OMP_SCHEDULE_Guided;
constexpr auto OMP_SCHEDULE_Auto = ScheduleKind::OMP_SCHEDULE_Auto;
constexpr auto OMP_SCHEDULE_Runtime = ScheduleKind::OMP_SCHEDULE_Runtime;
constexpr auto OMP_SCHEDULE_Default = ScheduleKind::OMP_SCHEDULE_Default;


__attribute__((visibility("default"))) std::pair<Directive, directive::VersionRange> getOpenMPDirectiveKindAndVersions(StringRef Str);
inline Directive getOpenMPDirectiveKind(StringRef Str) {
  return getOpenMPDirectiveKindAndVersions(Str).first;
}

__attribute__((visibility("default"))) StringRef getOpenMPDirectiveName(Directive D, unsigned Ver = 0);

__attribute__((visibility("default"))) std::pair<Clause, directive::VersionRange> getOpenMPClauseKindAndVersions(StringRef Str);

inline Clause getOpenMPClauseKind(StringRef Str) {
  return getOpenMPClauseKindAndVersions(Str).first;
}

__attribute__((visibility("default"))) StringRef getOpenMPClauseName(Clause C, unsigned Ver = 0);


__attribute__((visibility("default"))) bool isAllowedClauseForDirective(Directive D, Clause C, unsigned Version);

constexpr std::size_t getMaxLeafCount() { return 6; }
__attribute__((visibility("default"))) Association getDirectiveAssociation(Directive D);
__attribute__((visibility("default"))) Category getDirectiveCategory(Directive D);
__attribute__((visibility("default"))) SourceLanguage getDirectiveLanguages(Directive D);
__attribute__((visibility("default"))) BindKind getBindKind(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPBindKindName(BindKind x);
__attribute__((visibility("default"))) CancellationConstructType getCancellationConstructType(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPCancellationConstructTypeName(CancellationConstructType x);
__attribute__((visibility("default"))) GrainsizeType getGrainsizeType(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPGrainsizeTypeName(GrainsizeType x);
__attribute__((visibility("default"))) MemoryOrderKind getMemoryOrderKind(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPMemoryOrderKindName(MemoryOrderKind x);
__attribute__((visibility("default"))) NumTasksType getNumTasksType(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPNumTasksTypeName(NumTasksType x);
__attribute__((visibility("default"))) NumThreadsType getNumThreadsType(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPNumThreadsTypeName(NumThreadsType x);
__attribute__((visibility("default"))) OrderKind getOrderKind(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPOrderKindName(OrderKind x);
__attribute__((visibility("default"))) ProcBindKind getProcBindKind(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPProcBindKindName(ProcBindKind x);
__attribute__((visibility("default"))) ScheduleKind getScheduleKind(StringRef Str);
__attribute__((visibility("default"))) StringRef getOpenMPScheduleKindName(ScheduleKind x);

}

template <> struct enum_iteration_traits<omp::Association> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<omp::Category> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<omp::Directive> {
  static constexpr bool is_iterable = true;
};

template <> struct enum_iteration_traits<omp::Clause> {
  static constexpr bool is_iterable = true;
};
}
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h" 2






namespace llvm::omp {
__attribute__((visibility("default"))) ArrayRef<Directive> getLeafConstructs(Directive D);
__attribute__((visibility("default"))) ArrayRef<Directive> getLeafConstructsOrSelf(Directive D);

__attribute__((visibility("default"))) ArrayRef<Directive>
getLeafOrCompositeConstructs(Directive D, SmallVectorImpl<Directive> &Output);

__attribute__((visibility("default"))) Directive getCompoundConstruct(ArrayRef<Directive> Parts);

__attribute__((visibility("default"))) bool isLeafConstruct(Directive D);
__attribute__((visibility("default"))) bool isCompositeConstruct(Directive D);
__attribute__((visibility("default"))) bool isCombinedConstruct(Directive D);


static constexpr inline bool canHaveIterator(Clause C) {

  switch (C) {
  case OMPC_affinity:
  case OMPC_depend:
  case OMPC_from:
  case OMPC_map:
  case OMPC_to:
    return true;
  default:
    return false;
  }
}


static constexpr inline bool isPrivatizingClause(Clause C) {
  switch (C) {
  case OMPC_detach:
  case OMPC_firstprivate:

  case OMPC_in_reduction:
  case OMPC_is_device_ptr:
  case OMPC_lastprivate:
  case OMPC_linear:
  case OMPC_private:
  case OMPC_reduction:
  case OMPC_task_reduction:
  case OMPC_use_device_ptr:
    return true;
  default:
    return false;
  }
}

static constexpr unsigned FallbackVersion = 52;
__attribute__((visibility("default"))) ArrayRef<unsigned> getOpenMPVersions();


__attribute__((visibility("default"))) std::string prettifyFunctionName(StringRef FunctionName);



__attribute__((visibility("default"))) std::string deconstructOpenMPKernelName(StringRef KernelName,
                                                 unsigned &LineNo);

}
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h"
namespace llvm {
namespace omp {
using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator<<; using ::llvm::BitmaskEnumDetail::operator>>; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::operator<<=; using ::llvm::BitmaskEnumDetail::operator>>=; using ::llvm::BitmaskEnumDetail::operator!; using ::llvm::BitmaskEnumDetail::any;


enum class InternalControlVar {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 157 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
ICV_nthreads,
ICV_active_levels,
ICV_cancel,
ICV_proc_bind,
ICV___last,
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 157 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto ICV_nthreads = omp::InternalControlVar::ICV_nthreads;
constexpr auto ICV_active_levels = omp::InternalControlVar::ICV_active_levels;
constexpr auto ICV_cancel = omp::InternalControlVar::ICV_cancel;
constexpr auto ICV_proc_bind = omp::InternalControlVar::ICV_proc_bind;
constexpr auto ICV___last = omp::InternalControlVar::ICV___last;
# 34 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2

enum class ICVInitValue {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 142 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
ICV_ZERO,
ICV_FALSE,
ICV_IMPLEMENTATION_DEFINED,
ICV_LAST,
# 38 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 142 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto ICV_ZERO = omp::ICVInitValue::ICV_ZERO;
constexpr auto ICV_FALSE = omp::ICVInitValue::ICV_FALSE;
constexpr auto ICV_IMPLEMENTATION_DEFINED = omp::ICVInitValue::ICV_IMPLEMENTATION_DEFINED;
constexpr auto ICV_LAST = omp::ICVInitValue::ICV_LAST;
# 43 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2


enum class RuntimeFunction {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 206 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMPRTL___kmpc_barrier,
OMPRTL___kmpc_cancel,
OMPRTL___kmpc_cancel_barrier,
OMPRTL___kmpc_error,
OMPRTL___kmpc_flush,
OMPRTL___kmpc_global_thread_num,
OMPRTL___kmpc_get_hardware_thread_id_in_block,
OMPRTL___kmpc_fork_call,
OMPRTL___kmpc_fork_call_if,

OMPRTL___kmpc_omp_taskwait,
OMPRTL___kmpc_omp_taskyield,
OMPRTL___kmpc_push_num_threads,

OMPRTL___kmpc_push_proc_bind,
OMPRTL___kmpc_omp_reg_task_with_affinity,



OMPRTL___kmpc_get_hardware_num_blocks,
OMPRTL___kmpc_get_hardware_num_threads_in_block,
OMPRTL___kmpc_get_warp_size,

OMPRTL_omp_get_thread_num,
OMPRTL_omp_get_num_threads,
OMPRTL_omp_get_max_threads,
OMPRTL_omp_in_parallel,
OMPRTL_omp_get_dynamic,
OMPRTL_omp_get_cancellation,
OMPRTL_omp_get_nested,
OMPRTL_omp_get_schedule,
OMPRTL_omp_get_thread_limit,
OMPRTL_omp_get_supported_active_levels,
OMPRTL_omp_get_max_active_levels,
OMPRTL_omp_get_level,
OMPRTL_omp_get_ancestor_thread_num,
OMPRTL_omp_get_team_size,
OMPRTL_omp_get_active_level,
OMPRTL_omp_in_final,
OMPRTL_omp_get_proc_bind,
OMPRTL_omp_get_num_places,
OMPRTL_omp_get_num_procs,
OMPRTL_omp_get_place_proc_ids,
OMPRTL_omp_get_place_num,
OMPRTL_omp_get_partition_num_places,
OMPRTL_omp_get_partition_place_nums,
OMPRTL_omp_get_wtime,

OMPRTL_omp_set_num_threads,
OMPRTL_omp_set_dynamic,
OMPRTL_omp_set_nested,
OMPRTL_omp_set_schedule,
OMPRTL_omp_set_max_active_levels,

OMPRTL___kmpc_master,
OMPRTL___kmpc_end_master,
OMPRTL___kmpc_masked,
OMPRTL___kmpc_end_masked,
OMPRTL___kmpc_critical,
OMPRTL___kmpc_critical_with_hint,

OMPRTL___kmpc_end_critical,


OMPRTL___kmpc_begin,
OMPRTL___kmpc_end,

OMPRTL___kmpc_reduce,

OMPRTL___kmpc_reduce_nowait,

OMPRTL___kmpc_end_reduce,
OMPRTL___kmpc_end_reduce_nowait,


OMPRTL___kmpc_ordered,
OMPRTL___kmpc_end_ordered,

OMPRTL___kmpc_for_static_init_4,

OMPRTL___kmpc_for_static_init_4u,

OMPRTL___kmpc_for_static_init_8,

OMPRTL___kmpc_for_static_init_8u,

OMPRTL___kmpc_for_static_fini,
OMPRTL___kmpc_distribute_static_init_4,

OMPRTL___kmpc_distribute_static_init_4u,

OMPRTL___kmpc_distribute_static_init_8,

OMPRTL___kmpc_distribute_static_init_8u,

OMPRTL___kmpc_distribute_static_fini,
OMPRTL___kmpc_dist_dispatch_init_4,

OMPRTL___kmpc_dist_dispatch_init_4u,

OMPRTL___kmpc_dist_dispatch_init_8,

OMPRTL___kmpc_dist_dispatch_init_8u,

OMPRTL___kmpc_dispatch_init_4,

OMPRTL___kmpc_dispatch_init_4u,

OMPRTL___kmpc_dispatch_init_8,

OMPRTL___kmpc_dispatch_init_8u,

OMPRTL___kmpc_dispatch_next_4,

OMPRTL___kmpc_dispatch_next_4u,

OMPRTL___kmpc_dispatch_next_8,

OMPRTL___kmpc_dispatch_next_8u,

OMPRTL___kmpc_dispatch_fini_4,
OMPRTL___kmpc_dispatch_fini_4u,
OMPRTL___kmpc_dispatch_fini_8,
OMPRTL___kmpc_dispatch_fini_8u,
OMPRTL___kmpc_dispatch_deinit,
OMPRTL___kmpc_team_static_init_4,

OMPRTL___kmpc_team_static_init_4u,

OMPRTL___kmpc_team_static_init_8,

OMPRTL___kmpc_team_static_init_8u,

OMPRTL___kmpc_dist_for_static_init_4,

OMPRTL___kmpc_dist_for_static_init_4u,

OMPRTL___kmpc_dist_for_static_init_8,

OMPRTL___kmpc_dist_for_static_init_8u,


OMPRTL___kmpc_single,
OMPRTL___kmpc_end_single,

OMPRTL___kmpc_omp_task_alloc,

OMPRTL___kmpc_omp_task,

OMPRTL___kmpc_end_taskgroup,
OMPRTL___kmpc_taskgroup,
OMPRTL___kmpc_omp_task_begin_if0,

OMPRTL___kmpc_omp_task_complete_if0,

OMPRTL___kmpc_omp_task_with_deps,



OMPRTL___kmpc_taskloop,


OMPRTL___kmpc_taskloop_5,


OMPRTL___kmpc_omp_target_task_alloc,

OMPRTL___kmpc_taskred_modifier_init,

OMPRTL___kmpc_taskred_init,

OMPRTL___kmpc_task_reduction_modifier_fini,

OMPRTL___kmpc_task_reduction_get_th_data,

OMPRTL___kmpc_task_reduction_init,
OMPRTL___kmpc_task_reduction_modifier_init,

OMPRTL___kmpc_proxy_task_completed_ooo,

OMPRTL___kmpc_omp_wait_deps,

OMPRTL___kmpc_omp_taskwait_deps_51,

OMPRTL___kmpc_cancellationpoint,

OMPRTL___kmpc_fork_teams,
OMPRTL___kmpc_push_num_teams,
OMPRTL___kmpc_push_num_teams_51,
OMPRTL___kmpc_set_thread_limit,

OMPRTL___kmpc_copyprivate,

OMPRTL___kmpc_threadprivate_cached,

OMPRTL___kmpc_threadprivate_register,


OMPRTL___kmpc_doacross_init,

OMPRTL___kmpc_doacross_post,
OMPRTL___kmpc_doacross_wait,
OMPRTL___kmpc_doacross_fini,

OMPRTL___kmpc_alloc,
OMPRTL___kmpc_aligned_alloc,

OMPRTL___kmpc_free,

OMPRTL___tgt_interop_init,

OMPRTL___tgt_interop_destroy,

OMPRTL___tgt_interop_use,


OMPRTL___kmpc_init_allocator,


OMPRTL___kmpc_destroy_allocator,


OMPRTL___kmpc_push_target_tripcount_mapper,
OMPRTL___tgt_target_mapper,

OMPRTL___tgt_target_nowait_mapper,


OMPRTL___tgt_target_teams_mapper,

OMPRTL___tgt_target_teams_nowait_mapper,


OMPRTL___tgt_target_kernel,

OMPRTL___tgt_target_kernel_nowait,

OMPRTL___tgt_target_data_begin_mapper,

OMPRTL___tgt_target_data_begin_nowait_mapper,


OMPRTL___tgt_target_data_begin_mapper_issue,

OMPRTL___tgt_target_data_begin_mapper_wait,
OMPRTL___tgt_target_data_end_mapper,

OMPRTL___tgt_target_data_end_nowait_mapper,


OMPRTL___tgt_target_data_update_mapper,

OMPRTL___tgt_target_data_update_nowait_mapper,


OMPRTL___tgt_mapper_num_components,
OMPRTL___tgt_push_mapper_component,

OMPRTL___kmpc_task_allow_completion_event,



OMPRTL___kmpc_target_init,
OMPRTL___kmpc_target_deinit,
OMPRTL___kmpc_kernel_prepare_parallel,
OMPRTL___kmpc_parallel_51,

OMPRTL___kmpc_for_static_loop_4,
OMPRTL___kmpc_for_static_loop_4u,
OMPRTL___kmpc_for_static_loop_8,
OMPRTL___kmpc_for_static_loop_8u,
OMPRTL___kmpc_distribute_static_loop_4,
OMPRTL___kmpc_distribute_static_loop_4u,
OMPRTL___kmpc_distribute_static_loop_8,
OMPRTL___kmpc_distribute_static_loop_8u,
OMPRTL___kmpc_distribute_for_static_loop_4,
OMPRTL___kmpc_distribute_for_static_loop_4u,
OMPRTL___kmpc_distribute_for_static_loop_8,
OMPRTL___kmpc_distribute_for_static_loop_8u,
OMPRTL___kmpc_kernel_parallel,
OMPRTL___kmpc_kernel_end_parallel,
OMPRTL___kmpc_serialized_parallel,
OMPRTL___kmpc_end_serialized_parallel,
OMPRTL___kmpc_shuffle_int32,
OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2,

OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2,


OMPRTL___kmpc_reduction_get_fixed_buffer,

OMPRTL___kmpc_shuffle_int64,

OMPRTL___kmpc_alloc_shared,
OMPRTL___kmpc_free_shared,
OMPRTL___kmpc_begin_sharing_variables,
OMPRTL___kmpc_end_sharing_variables,
OMPRTL___kmpc_get_shared_variables,
OMPRTL___kmpc_parallel_level,
OMPRTL___kmpc_is_spmd_exec_mode,
OMPRTL___kmpc_barrier_simple_spmd,
OMPRTL___kmpc_barrier_simple_generic,

OMPRTL___kmpc_warp_active_thread_mask,
OMPRTL___kmpc_syncwarp,

OMPRTL___llvm_profile_register_function,
OMPRTL___llvm_profile_register_names_function,

OMPRTL___last,
# 48 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 206 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMPRTL___kmpc_barrier = omp::RuntimeFunction::OMPRTL___kmpc_barrier;
constexpr auto OMPRTL___kmpc_cancel = omp::RuntimeFunction::OMPRTL___kmpc_cancel;
constexpr auto OMPRTL___kmpc_cancel_barrier = omp::RuntimeFunction::OMPRTL___kmpc_cancel_barrier;
constexpr auto OMPRTL___kmpc_error = omp::RuntimeFunction::OMPRTL___kmpc_error;
constexpr auto OMPRTL___kmpc_flush = omp::RuntimeFunction::OMPRTL___kmpc_flush;
constexpr auto OMPRTL___kmpc_global_thread_num = omp::RuntimeFunction::OMPRTL___kmpc_global_thread_num;
constexpr auto OMPRTL___kmpc_get_hardware_thread_id_in_block = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_thread_id_in_block;
constexpr auto OMPRTL___kmpc_fork_call = omp::RuntimeFunction::OMPRTL___kmpc_fork_call;
constexpr auto OMPRTL___kmpc_fork_call_if = omp::RuntimeFunction::OMPRTL___kmpc_fork_call_if;

constexpr auto OMPRTL___kmpc_omp_taskwait = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskwait;
constexpr auto OMPRTL___kmpc_omp_taskyield = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskyield;
constexpr auto OMPRTL___kmpc_push_num_threads = omp::RuntimeFunction::OMPRTL___kmpc_push_num_threads;

constexpr auto OMPRTL___kmpc_push_proc_bind = omp::RuntimeFunction::OMPRTL___kmpc_push_proc_bind;
constexpr auto OMPRTL___kmpc_omp_reg_task_with_affinity = omp::RuntimeFunction::OMPRTL___kmpc_omp_reg_task_with_affinity;



constexpr auto OMPRTL___kmpc_get_hardware_num_blocks = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_num_blocks;
constexpr auto OMPRTL___kmpc_get_hardware_num_threads_in_block = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_num_threads_in_block;
constexpr auto OMPRTL___kmpc_get_warp_size = omp::RuntimeFunction::OMPRTL___kmpc_get_warp_size;

constexpr auto OMPRTL_omp_get_thread_num = omp::RuntimeFunction::OMPRTL_omp_get_thread_num;
constexpr auto OMPRTL_omp_get_num_threads = omp::RuntimeFunction::OMPRTL_omp_get_num_threads;
constexpr auto OMPRTL_omp_get_max_threads = omp::RuntimeFunction::OMPRTL_omp_get_max_threads;
constexpr auto OMPRTL_omp_in_parallel = omp::RuntimeFunction::OMPRTL_omp_in_parallel;
constexpr auto OMPRTL_omp_get_dynamic = omp::RuntimeFunction::OMPRTL_omp_get_dynamic;
constexpr auto OMPRTL_omp_get_cancellation = omp::RuntimeFunction::OMPRTL_omp_get_cancellation;
constexpr auto OMPRTL_omp_get_nested = omp::RuntimeFunction::OMPRTL_omp_get_nested;
constexpr auto OMPRTL_omp_get_schedule = omp::RuntimeFunction::OMPRTL_omp_get_schedule;
constexpr auto OMPRTL_omp_get_thread_limit = omp::RuntimeFunction::OMPRTL_omp_get_thread_limit;
constexpr auto OMPRTL_omp_get_supported_active_levels = omp::RuntimeFunction::OMPRTL_omp_get_supported_active_levels;
constexpr auto OMPRTL_omp_get_max_active_levels = omp::RuntimeFunction::OMPRTL_omp_get_max_active_levels;
constexpr auto OMPRTL_omp_get_level = omp::RuntimeFunction::OMPRTL_omp_get_level;
constexpr auto OMPRTL_omp_get_ancestor_thread_num = omp::RuntimeFunction::OMPRTL_omp_get_ancestor_thread_num;
constexpr auto OMPRTL_omp_get_team_size = omp::RuntimeFunction::OMPRTL_omp_get_team_size;
constexpr auto OMPRTL_omp_get_active_level = omp::RuntimeFunction::OMPRTL_omp_get_active_level;
constexpr auto OMPRTL_omp_in_final = omp::RuntimeFunction::OMPRTL_omp_in_final;
constexpr auto OMPRTL_omp_get_proc_bind = omp::RuntimeFunction::OMPRTL_omp_get_proc_bind;
constexpr auto OMPRTL_omp_get_num_places = omp::RuntimeFunction::OMPRTL_omp_get_num_places;
constexpr auto OMPRTL_omp_get_num_procs = omp::RuntimeFunction::OMPRTL_omp_get_num_procs;
constexpr auto OMPRTL_omp_get_place_proc_ids = omp::RuntimeFunction::OMPRTL_omp_get_place_proc_ids;
constexpr auto OMPRTL_omp_get_place_num = omp::RuntimeFunction::OMPRTL_omp_get_place_num;
constexpr auto OMPRTL_omp_get_partition_num_places = omp::RuntimeFunction::OMPRTL_omp_get_partition_num_places;
constexpr auto OMPRTL_omp_get_partition_place_nums = omp::RuntimeFunction::OMPRTL_omp_get_partition_place_nums;
constexpr auto OMPRTL_omp_get_wtime = omp::RuntimeFunction::OMPRTL_omp_get_wtime;

constexpr auto OMPRTL_omp_set_num_threads = omp::RuntimeFunction::OMPRTL_omp_set_num_threads;
constexpr auto OMPRTL_omp_set_dynamic = omp::RuntimeFunction::OMPRTL_omp_set_dynamic;
constexpr auto OMPRTL_omp_set_nested = omp::RuntimeFunction::OMPRTL_omp_set_nested;
constexpr auto OMPRTL_omp_set_schedule = omp::RuntimeFunction::OMPRTL_omp_set_schedule;
constexpr auto OMPRTL_omp_set_max_active_levels = omp::RuntimeFunction::OMPRTL_omp_set_max_active_levels;

constexpr auto OMPRTL___kmpc_master = omp::RuntimeFunction::OMPRTL___kmpc_master;
constexpr auto OMPRTL___kmpc_end_master = omp::RuntimeFunction::OMPRTL___kmpc_end_master;
constexpr auto OMPRTL___kmpc_masked = omp::RuntimeFunction::OMPRTL___kmpc_masked;
constexpr auto OMPRTL___kmpc_end_masked = omp::RuntimeFunction::OMPRTL___kmpc_end_masked;
constexpr auto OMPRTL___kmpc_critical = omp::RuntimeFunction::OMPRTL___kmpc_critical;
constexpr auto OMPRTL___kmpc_critical_with_hint = omp::RuntimeFunction::OMPRTL___kmpc_critical_with_hint;

constexpr auto OMPRTL___kmpc_end_critical = omp::RuntimeFunction::OMPRTL___kmpc_end_critical;


constexpr auto OMPRTL___kmpc_begin = omp::RuntimeFunction::OMPRTL___kmpc_begin;
constexpr auto OMPRTL___kmpc_end = omp::RuntimeFunction::OMPRTL___kmpc_end;

constexpr auto OMPRTL___kmpc_reduce = omp::RuntimeFunction::OMPRTL___kmpc_reduce;

constexpr auto OMPRTL___kmpc_reduce_nowait = omp::RuntimeFunction::OMPRTL___kmpc_reduce_nowait;

constexpr auto OMPRTL___kmpc_end_reduce = omp::RuntimeFunction::OMPRTL___kmpc_end_reduce;
constexpr auto OMPRTL___kmpc_end_reduce_nowait = omp::RuntimeFunction::OMPRTL___kmpc_end_reduce_nowait;


constexpr auto OMPRTL___kmpc_ordered = omp::RuntimeFunction::OMPRTL___kmpc_ordered;
constexpr auto OMPRTL___kmpc_end_ordered = omp::RuntimeFunction::OMPRTL___kmpc_end_ordered;

constexpr auto OMPRTL___kmpc_for_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_4;

constexpr auto OMPRTL___kmpc_for_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_4u;

constexpr auto OMPRTL___kmpc_for_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_8;

constexpr auto OMPRTL___kmpc_for_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_8u;

constexpr auto OMPRTL___kmpc_for_static_fini = omp::RuntimeFunction::OMPRTL___kmpc_for_static_fini;
constexpr auto OMPRTL___kmpc_distribute_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_4;

constexpr auto OMPRTL___kmpc_distribute_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_4u;

constexpr auto OMPRTL___kmpc_distribute_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_8;

constexpr auto OMPRTL___kmpc_distribute_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_8u;

constexpr auto OMPRTL___kmpc_distribute_static_fini = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_fini;
constexpr auto OMPRTL___kmpc_dist_dispatch_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_4;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_4u;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_8;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_8u;

constexpr auto OMPRTL___kmpc_dispatch_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_4;

constexpr auto OMPRTL___kmpc_dispatch_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_4u;

constexpr auto OMPRTL___kmpc_dispatch_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_8;

constexpr auto OMPRTL___kmpc_dispatch_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_8u;

constexpr auto OMPRTL___kmpc_dispatch_next_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_4;

constexpr auto OMPRTL___kmpc_dispatch_next_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_4u;

constexpr auto OMPRTL___kmpc_dispatch_next_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_8;

constexpr auto OMPRTL___kmpc_dispatch_next_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_8u;

constexpr auto OMPRTL___kmpc_dispatch_fini_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_4;
constexpr auto OMPRTL___kmpc_dispatch_fini_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_4u;
constexpr auto OMPRTL___kmpc_dispatch_fini_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_8;
constexpr auto OMPRTL___kmpc_dispatch_fini_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_8u;
constexpr auto OMPRTL___kmpc_dispatch_deinit = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_deinit;
constexpr auto OMPRTL___kmpc_team_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_4;

constexpr auto OMPRTL___kmpc_team_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_4u;

constexpr auto OMPRTL___kmpc_team_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_8;

constexpr auto OMPRTL___kmpc_team_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_8u;

constexpr auto OMPRTL___kmpc_dist_for_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_4;

constexpr auto OMPRTL___kmpc_dist_for_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_4u;

constexpr auto OMPRTL___kmpc_dist_for_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_8;

constexpr auto OMPRTL___kmpc_dist_for_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_8u;


constexpr auto OMPRTL___kmpc_single = omp::RuntimeFunction::OMPRTL___kmpc_single;
constexpr auto OMPRTL___kmpc_end_single = omp::RuntimeFunction::OMPRTL___kmpc_end_single;

constexpr auto OMPRTL___kmpc_omp_task_alloc = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_alloc;

constexpr auto OMPRTL___kmpc_omp_task = omp::RuntimeFunction::OMPRTL___kmpc_omp_task;

constexpr auto OMPRTL___kmpc_end_taskgroup = omp::RuntimeFunction::OMPRTL___kmpc_end_taskgroup;
constexpr auto OMPRTL___kmpc_taskgroup = omp::RuntimeFunction::OMPRTL___kmpc_taskgroup;
constexpr auto OMPRTL___kmpc_omp_task_begin_if0 = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_begin_if0;

constexpr auto OMPRTL___kmpc_omp_task_complete_if0 = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_complete_if0;

constexpr auto OMPRTL___kmpc_omp_task_with_deps = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_with_deps;



constexpr auto OMPRTL___kmpc_taskloop = omp::RuntimeFunction::OMPRTL___kmpc_taskloop;


constexpr auto OMPRTL___kmpc_taskloop_5 = omp::RuntimeFunction::OMPRTL___kmpc_taskloop_5;


constexpr auto OMPRTL___kmpc_omp_target_task_alloc = omp::RuntimeFunction::OMPRTL___kmpc_omp_target_task_alloc;

constexpr auto OMPRTL___kmpc_taskred_modifier_init = omp::RuntimeFunction::OMPRTL___kmpc_taskred_modifier_init;

constexpr auto OMPRTL___kmpc_taskred_init = omp::RuntimeFunction::OMPRTL___kmpc_taskred_init;

constexpr auto OMPRTL___kmpc_task_reduction_modifier_fini = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_modifier_fini;

constexpr auto OMPRTL___kmpc_task_reduction_get_th_data = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_get_th_data;

constexpr auto OMPRTL___kmpc_task_reduction_init = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_init;
constexpr auto OMPRTL___kmpc_task_reduction_modifier_init = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_modifier_init;

constexpr auto OMPRTL___kmpc_proxy_task_completed_ooo = omp::RuntimeFunction::OMPRTL___kmpc_proxy_task_completed_ooo;

constexpr auto OMPRTL___kmpc_omp_wait_deps = omp::RuntimeFunction::OMPRTL___kmpc_omp_wait_deps;

constexpr auto OMPRTL___kmpc_omp_taskwait_deps_51 = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskwait_deps_51;

constexpr auto OMPRTL___kmpc_cancellationpoint = omp::RuntimeFunction::OMPRTL___kmpc_cancellationpoint;

constexpr auto OMPRTL___kmpc_fork_teams = omp::RuntimeFunction::OMPRTL___kmpc_fork_teams;
constexpr auto OMPRTL___kmpc_push_num_teams = omp::RuntimeFunction::OMPRTL___kmpc_push_num_teams;
constexpr auto OMPRTL___kmpc_push_num_teams_51 = omp::RuntimeFunction::OMPRTL___kmpc_push_num_teams_51;
constexpr auto OMPRTL___kmpc_set_thread_limit = omp::RuntimeFunction::OMPRTL___kmpc_set_thread_limit;

constexpr auto OMPRTL___kmpc_copyprivate = omp::RuntimeFunction::OMPRTL___kmpc_copyprivate;

constexpr auto OMPRTL___kmpc_threadprivate_cached = omp::RuntimeFunction::OMPRTL___kmpc_threadprivate_cached;

constexpr auto OMPRTL___kmpc_threadprivate_register = omp::RuntimeFunction::OMPRTL___kmpc_threadprivate_register;


constexpr auto OMPRTL___kmpc_doacross_init = omp::RuntimeFunction::OMPRTL___kmpc_doacross_init;

constexpr auto OMPRTL___kmpc_doacross_post = omp::RuntimeFunction::OMPRTL___kmpc_doacross_post;
constexpr auto OMPRTL___kmpc_doacross_wait = omp::RuntimeFunction::OMPRTL___kmpc_doacross_wait;
constexpr auto OMPRTL___kmpc_doacross_fini = omp::RuntimeFunction::OMPRTL___kmpc_doacross_fini;

constexpr auto OMPRTL___kmpc_alloc = omp::RuntimeFunction::OMPRTL___kmpc_alloc;
constexpr auto OMPRTL___kmpc_aligned_alloc = omp::RuntimeFunction::OMPRTL___kmpc_aligned_alloc;

constexpr auto OMPRTL___kmpc_free = omp::RuntimeFunction::OMPRTL___kmpc_free;

constexpr auto OMPRTL___tgt_interop_init = omp::RuntimeFunction::OMPRTL___tgt_interop_init;

constexpr auto OMPRTL___tgt_interop_destroy = omp::RuntimeFunction::OMPRTL___tgt_interop_destroy;

constexpr auto OMPRTL___tgt_interop_use = omp::RuntimeFunction::OMPRTL___tgt_interop_use;


constexpr auto OMPRTL___kmpc_init_allocator = omp::RuntimeFunction::OMPRTL___kmpc_init_allocator;


constexpr auto OMPRTL___kmpc_destroy_allocator = omp::RuntimeFunction::OMPRTL___kmpc_destroy_allocator;


constexpr auto OMPRTL___kmpc_push_target_tripcount_mapper = omp::RuntimeFunction::OMPRTL___kmpc_push_target_tripcount_mapper;
constexpr auto OMPRTL___tgt_target_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_mapper;

constexpr auto OMPRTL___tgt_target_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_nowait_mapper;


constexpr auto OMPRTL___tgt_target_teams_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_teams_mapper;

constexpr auto OMPRTL___tgt_target_teams_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_teams_nowait_mapper;


constexpr auto OMPRTL___tgt_target_kernel = omp::RuntimeFunction::OMPRTL___tgt_target_kernel;

constexpr auto OMPRTL___tgt_target_kernel_nowait = omp::RuntimeFunction::OMPRTL___tgt_target_kernel_nowait;

constexpr auto OMPRTL___tgt_target_data_begin_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper;

constexpr auto OMPRTL___tgt_target_data_begin_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_nowait_mapper;


constexpr auto OMPRTL___tgt_target_data_begin_mapper_issue = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper_issue;

constexpr auto OMPRTL___tgt_target_data_begin_mapper_wait = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper_wait;
constexpr auto OMPRTL___tgt_target_data_end_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_end_mapper;

constexpr auto OMPRTL___tgt_target_data_end_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_end_nowait_mapper;


constexpr auto OMPRTL___tgt_target_data_update_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_update_mapper;

constexpr auto OMPRTL___tgt_target_data_update_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_update_nowait_mapper;


constexpr auto OMPRTL___tgt_mapper_num_components = omp::RuntimeFunction::OMPRTL___tgt_mapper_num_components;
constexpr auto OMPRTL___tgt_push_mapper_component = omp::RuntimeFunction::OMPRTL___tgt_push_mapper_component;

constexpr auto OMPRTL___kmpc_task_allow_completion_event = omp::RuntimeFunction::OMPRTL___kmpc_task_allow_completion_event;



constexpr auto OMPRTL___kmpc_target_init = omp::RuntimeFunction::OMPRTL___kmpc_target_init;
constexpr auto OMPRTL___kmpc_target_deinit = omp::RuntimeFunction::OMPRTL___kmpc_target_deinit;
constexpr auto OMPRTL___kmpc_kernel_prepare_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_prepare_parallel;
constexpr auto OMPRTL___kmpc_parallel_51 = omp::RuntimeFunction::OMPRTL___kmpc_parallel_51;

constexpr auto OMPRTL___kmpc_for_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_4;
constexpr auto OMPRTL___kmpc_for_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_4u;
constexpr auto OMPRTL___kmpc_for_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_8;
constexpr auto OMPRTL___kmpc_for_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_8u;
constexpr auto OMPRTL___kmpc_distribute_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_4;
constexpr auto OMPRTL___kmpc_distribute_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_4u;
constexpr auto OMPRTL___kmpc_distribute_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_8;
constexpr auto OMPRTL___kmpc_distribute_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_8u;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_4;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_4u;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_8;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_8u;
constexpr auto OMPRTL___kmpc_kernel_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_parallel;
constexpr auto OMPRTL___kmpc_kernel_end_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_end_parallel;
constexpr auto OMPRTL___kmpc_serialized_parallel = omp::RuntimeFunction::OMPRTL___kmpc_serialized_parallel;
constexpr auto OMPRTL___kmpc_end_serialized_parallel = omp::RuntimeFunction::OMPRTL___kmpc_end_serialized_parallel;
constexpr auto OMPRTL___kmpc_shuffle_int32 = omp::RuntimeFunction::OMPRTL___kmpc_shuffle_int32;
constexpr auto OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2 = omp::RuntimeFunction::OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2;

constexpr auto OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2 = omp::RuntimeFunction::OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2;


constexpr auto OMPRTL___kmpc_reduction_get_fixed_buffer = omp::RuntimeFunction::OMPRTL___kmpc_reduction_get_fixed_buffer;

constexpr auto OMPRTL___kmpc_shuffle_int64 = omp::RuntimeFunction::OMPRTL___kmpc_shuffle_int64;

constexpr auto OMPRTL___kmpc_alloc_shared = omp::RuntimeFunction::OMPRTL___kmpc_alloc_shared;
constexpr auto OMPRTL___kmpc_free_shared = omp::RuntimeFunction::OMPRTL___kmpc_free_shared;
constexpr auto OMPRTL___kmpc_begin_sharing_variables = omp::RuntimeFunction::OMPRTL___kmpc_begin_sharing_variables;
constexpr auto OMPRTL___kmpc_end_sharing_variables = omp::RuntimeFunction::OMPRTL___kmpc_end_sharing_variables;
constexpr auto OMPRTL___kmpc_get_shared_variables = omp::RuntimeFunction::OMPRTL___kmpc_get_shared_variables;
constexpr auto OMPRTL___kmpc_parallel_level = omp::RuntimeFunction::OMPRTL___kmpc_parallel_level;
constexpr auto OMPRTL___kmpc_is_spmd_exec_mode = omp::RuntimeFunction::OMPRTL___kmpc_is_spmd_exec_mode;
constexpr auto OMPRTL___kmpc_barrier_simple_spmd = omp::RuntimeFunction::OMPRTL___kmpc_barrier_simple_spmd;
constexpr auto OMPRTL___kmpc_barrier_simple_generic = omp::RuntimeFunction::OMPRTL___kmpc_barrier_simple_generic;

constexpr auto OMPRTL___kmpc_warp_active_thread_mask = omp::RuntimeFunction::OMPRTL___kmpc_warp_active_thread_mask;
constexpr auto OMPRTL___kmpc_syncwarp = omp::RuntimeFunction::OMPRTL___kmpc_syncwarp;

constexpr auto OMPRTL___llvm_profile_register_function = omp::RuntimeFunction::OMPRTL___llvm_profile_register_function;
constexpr auto OMPRTL___llvm_profile_register_names_function = omp::RuntimeFunction::OMPRTL___llvm_profile_register_names_function;

constexpr auto OMPRTL___last = omp::RuntimeFunction::OMPRTL___last;
# 52 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2


enum class DefaultKind {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1168 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMP_DEFAULT_none,
OMP_DEFAULT_shared,
OMP_DEFAULT_private,
OMP_DEFAULT_firstprivate,
OMP_DEFAULT_unknown,
# 57 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1168 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMP_DEFAULT_none = omp::DefaultKind::OMP_DEFAULT_none;
constexpr auto OMP_DEFAULT_shared = omp::DefaultKind::OMP_DEFAULT_shared;
constexpr auto OMP_DEFAULT_private = omp::DefaultKind::OMP_DEFAULT_private;
constexpr auto OMP_DEFAULT_firstprivate = omp::DefaultKind::OMP_DEFAULT_firstprivate;
constexpr auto OMP_DEFAULT_unknown = omp::DefaultKind::OMP_DEFAULT_unknown;
# 62 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2



enum class IdentFlag {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1122 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMP_IDENT_FLAG_KMPC = 0x02,
OMP_IDENT_FLAG_ATOMIC_REDUCE = 0x10,
OMP_IDENT_FLAG_BARRIER_EXPL = 0x20,
OMP_IDENT_FLAG_BARRIER_IMPL = 0x0040,
OMP_IDENT_FLAG_BARRIER_IMPL_MASK = 0x01C0,
OMP_IDENT_FLAG_BARRIER_IMPL_FOR = 0x0040,
OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS = 0x00C0,
OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE = 0x0140,
OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE = 0x01C0,
# 68 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
 LLVM_BITMASK_LARGEST_ENUMERATOR = 0x7FFFFFFF
};


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1122 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMP_IDENT_FLAG_KMPC = omp::IdentFlag::OMP_IDENT_FLAG_KMPC;
constexpr auto OMP_IDENT_FLAG_ATOMIC_REDUCE = omp::IdentFlag::OMP_IDENT_FLAG_ATOMIC_REDUCE;
constexpr auto OMP_IDENT_FLAG_BARRIER_EXPL = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_EXPL;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_MASK = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_MASK;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_FOR = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_FOR;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE;
# 73 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
# 82 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h"
enum class OMPScheduleType {

  None = 0,


  BaseStaticChunked = 1,
  BaseStatic = 2,
  BaseDynamicChunked = 3,
  BaseGuidedChunked = 4,
  BaseRuntime = 5,
  BaseAuto = 6,
  BaseTrapezoidal = 7,
  BaseGreedy = 8,
  BaseBalanced = 9,
  BaseGuidedIterativeChunked = 10,
  BaseGuidedAnalyticalChunked = 11,
  BaseSteal = 12,


  BaseStaticBalancedChunked = 13,
  BaseGuidedSimd = 14,
  BaseRuntimeSimd = 15,


  BaseDistributeChunked = 27,
  BaseDistribute = 28,


  ModifierUnordered = (1 << 5),
  ModifierOrdered = (1 << 6),
  ModifierNomerge = (1 << 7),
  ModifierMonotonic = (1 << 29),
  ModifierNonmonotonic = (1 << 30),


  OrderingMask = ModifierUnordered | ModifierOrdered | ModifierNomerge,
  MonotonicityMask = ModifierMonotonic | ModifierNonmonotonic,
  ModifierMask = OrderingMask | MonotonicityMask,


  UnorderedStaticChunked = BaseStaticChunked | ModifierUnordered,
  UnorderedStatic = BaseStatic | ModifierUnordered,
  UnorderedDynamicChunked = BaseDynamicChunked | ModifierUnordered,
  UnorderedGuidedChunked = BaseGuidedChunked | ModifierUnordered,
  UnorderedRuntime = BaseRuntime | ModifierUnordered,
  UnorderedAuto = BaseAuto | ModifierUnordered,
  UnorderedTrapezoidal = BaseTrapezoidal | ModifierUnordered,
  UnorderedGreedy = BaseGreedy | ModifierUnordered,
  UnorderedBalanced = BaseBalanced | ModifierUnordered,
  UnorderedGuidedIterativeChunked =
      BaseGuidedIterativeChunked | ModifierUnordered,
  UnorderedGuidedAnalyticalChunked =
      BaseGuidedAnalyticalChunked | ModifierUnordered,
  UnorderedSteal = BaseSteal | ModifierUnordered,

  UnorderedStaticBalancedChunked =
      BaseStaticBalancedChunked | ModifierUnordered,
  UnorderedGuidedSimd = BaseGuidedSimd | ModifierUnordered,
  UnorderedRuntimeSimd = BaseRuntimeSimd | ModifierUnordered,

  OrderedStaticChunked = BaseStaticChunked | ModifierOrdered,
  OrderedStatic = BaseStatic | ModifierOrdered,
  OrderedDynamicChunked = BaseDynamicChunked | ModifierOrdered,
  OrderedGuidedChunked = BaseGuidedChunked | ModifierOrdered,
  OrderedRuntime = BaseRuntime | ModifierOrdered,
  OrderedAuto = BaseAuto | ModifierOrdered,
  OrderdTrapezoidal = BaseTrapezoidal | ModifierOrdered,

  OrderedDistributeChunked = BaseDistributeChunked | ModifierOrdered,
  OrderedDistribute = BaseDistribute | ModifierOrdered,

  NomergeUnorderedStaticChunked =
      BaseStaticChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedStatic =
      BaseStatic | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedDynamicChunked =
      BaseDynamicChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedChunked =
      BaseGuidedChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedRuntime =
      BaseRuntime | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedAuto = BaseAuto | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedTrapezoidal =
      BaseTrapezoidal | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGreedy =
      BaseGreedy | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedBalanced =
      BaseBalanced | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedIterativeChunked =
      BaseGuidedIterativeChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedAnalyticalChunked =
      BaseGuidedAnalyticalChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedSteal =
      BaseSteal | ModifierUnordered | ModifierNomerge,

  NomergeOrderedStaticChunked =
      BaseStaticChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedStatic = BaseStatic | ModifierOrdered | ModifierNomerge,
  NomergeOrderedDynamicChunked =
      BaseDynamicChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedGuidedChunked =
      BaseGuidedChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedRuntime =
      BaseRuntime | ModifierOrdered | ModifierNomerge,
  NomergeOrderedAuto = BaseAuto | ModifierOrdered | ModifierNomerge,
  NomergeOrderedTrapezoidal =
      BaseTrapezoidal | ModifierOrdered | ModifierNomerge,

  LLVM_BITMASK_LARGEST_ENUMERATOR = ModifierMask
};


inline constexpr const char *OmpDefaultMapperName = ".omp.default.mapper";



enum class OpenMPOffloadMappingFlags : uint64_t {

  OMP_MAP_NONE = 0x0,

  OMP_MAP_TO = 0x01,

  OMP_MAP_FROM = 0x02,


  OMP_MAP_ALWAYS = 0x04,


  OMP_MAP_DELETE = 0x08,


  OMP_MAP_PTR_AND_OBJ = 0x10,


  OMP_MAP_TARGET_PARAM = 0x20,



  OMP_MAP_RETURN_PARAM = 0x40,


  OMP_MAP_PRIVATE = 0x80,

  OMP_MAP_LITERAL = 0x100,

  OMP_MAP_IMPLICIT = 0x200,


  OMP_MAP_CLOSE = 0x400,


  OMP_MAP_PRESENT = 0x1000,







  OMP_MAP_OMPX_HOLD = 0x2000,



  OMP_MAP_NON_CONTIG = 0x100000000000,


  OMP_MAP_MEMBER_OF = 0xffff000000000000,
  LLVM_BITMASK_LARGEST_ENUMERATOR = OMP_MAP_MEMBER_OF
};

enum OpenMPOffloadingReservedDeviceIDs {


  OMP_DEVICEID_UNDEF = -1
};

enum class AddressSpace : unsigned {
  Generic = 0,
  Global = 1,
  Shared = 3,
  Constant = 4,
  Local = 5,
};


enum class OMPInteropType { Unknown, Target, TargetSync };


enum class OMPAtomicCompareOp : unsigned { EQ, MIN, MAX };


enum class RTLDependInfoFields { BaseAddr, Len, Flags };


enum class RTLDependenceKindTy {
  DepUnknown = 0x0,
  DepIn = 0x01,
  DepInOut = 0x3,
  DepMutexInOutSet = 0x4,
  DepInOutSet = 0x8,
  DepOmpAllMem = 0x80,
};


enum class WorksharingLoopType {

  ForStaticLoop,

  DistributeStaticLoop,

  DistributeForStaticLoop
};

}

}

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPDeviceConstants.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPDeviceConstants.h"
namespace llvm {
namespace omp {

enum OMPTgtExecModeFlags : unsigned char {
  OMP_TGT_EXEC_MODE_BARE = 0,
  OMP_TGT_EXEC_MODE_GENERIC = 1 << 0,
  OMP_TGT_EXEC_MODE_SPMD = 1 << 1,
  OMP_TGT_EXEC_MODE_GENERIC_SPMD =
      OMP_TGT_EXEC_MODE_GENERIC | OMP_TGT_EXEC_MODE_SPMD
};

}
}
# 300 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
# 31 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 51 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
namespace class_trait_ns_EmptyTrait { template <typename A> std::true_type test(typename A::EmptyTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::EmptyTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool EmptyTrait{class_trait_ns_EmptyTrait::trait_value<A>()};
namespace class_trait_ns_WrapperTrait { template <typename A> std::true_type test(typename A::WrapperTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::WrapperTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool WrapperTrait{class_trait_ns_WrapperTrait::trait_value<A>()};
namespace class_trait_ns_UnionTrait { template <typename A> std::true_type test(typename A::UnionTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::UnionTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool UnionTrait{class_trait_ns_UnionTrait::trait_value<A>()};
namespace class_trait_ns_TupleTrait { template <typename A> std::true_type test(typename A::TupleTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::TupleTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool TupleTrait{class_trait_ns_TupleTrait::trait_value<A>()};
namespace class_trait_ns_ConstraintTrait { template <typename A> std::true_type test(typename A::ConstraintTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::ConstraintTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool ConstraintTrait{class_trait_ns_ConstraintTrait::trait_value<A>()};




namespace Fortran::semantics {
class Symbol;
class DeclTypeSpec;
class DerivedTypeSpec;
}



namespace Fortran::evaluate {
struct GenericExprWrapper;
struct GenericAssignmentWrapper;
class ProcedureRef;
}
# 129 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
namespace Fortran::parser {





struct SpecificationPart;
struct ExecutableConstruct;
struct ActionStmt;
struct AcImpliedDo;
struct DataImpliedDo;
struct Designator;
struct Variable;
struct Expr;
struct WhereConstruct;
struct ForallConstruct;
struct InputImpliedDo;
struct OutputImpliedDo;
struct FunctionReference;
struct FunctionSubprogram;
struct SubroutineSubprogram;




struct DerivedTypeDef;
struct EnumDef;
struct TypeDeclarationStmt;
struct AccessStmt;
struct AllocatableStmt;
struct AsynchronousStmt;
struct BindStmt;
struct CodimensionStmt;
struct ContiguousStmt;
struct DataStmt;
struct DataStmtValue;
struct DimensionStmt;
struct IntentStmt;
struct OptionalStmt;
struct ParameterStmt;
struct OldParameterStmt;
struct PointerStmt;
struct ProtectedStmt;
struct SaveStmt;
struct TargetStmt;
struct ValueStmt;
struct VolatileStmt;
struct ImplicitStmt;
struct ImportStmt;
struct NamelistStmt;
struct EquivalenceStmt;
struct CommonStmt;
struct Substring;
struct CharLiteralConstantSubstring;
struct SubstringInquiry;
struct DataRef;
struct StructureComponent;
struct CoindexedNamedObject;
struct ArrayElement;
struct AllocateStmt;
struct NullifyStmt;
struct DeallocateStmt;
struct AssignmentStmt;
struct PointerAssignmentStmt;
struct WhereStmt;
struct ForallStmt;
struct AssociateConstruct;
struct BlockConstruct;
struct ChangeTeamConstruct;
struct CriticalConstruct;
struct DoConstruct;
struct LabelDoStmt;
struct ConcurrentHeader;
struct EndDoStmt;
struct CycleStmt;
struct IfConstruct;
struct IfStmt;
struct CaseConstruct;
struct SelectRankConstruct;
struct SelectTypeConstruct;
struct ExitStmt;
struct GotoStmt;
struct ComputedGotoStmt;
struct StopStmt;
struct NotifyWaitStmt;
struct SyncAllStmt;
struct SyncImagesStmt;
struct SyncMemoryStmt;
struct SyncTeamStmt;
struct EventPostStmt;
struct EventWaitSpec;
struct EventWaitStmt;
struct FormTeamStmt;
struct LockStmt;
struct UnlockStmt;
struct OpenStmt;
struct CloseStmt;
struct ReadStmt;
struct WriteStmt;
struct PrintStmt;
struct WaitStmt;
struct BackspaceStmt;
struct EndfileStmt;
struct RewindStmt;
struct FlushStmt;
struct InquireStmt;
struct FormatStmt;
struct MainProgram;
struct Module;
struct UseStmt;
struct Submodule;
struct BlockData;
struct InterfaceBlock;
struct GenericSpec;
struct GenericStmt;
struct ExternalStmt;
struct ProcedureDeclarationStmt;
struct IntrinsicStmt;
struct Call;
struct CallStmt;
struct ProcedureDesignator;
struct ActualArg;
struct SeparateModuleSubprogram;
struct EntryStmt;
struct ReturnStmt;
struct StmtFunctionStmt;


struct CompilerDirective;
struct BasedPointerStmt;
struct CUDAAttributesStmt;
struct StructureDef;
struct ArithmeticIfStmt;
struct AssignStmt;
struct AssignedGotoStmt;
struct PauseStmt;
struct OpenACCConstruct;
struct AccEndCombinedDirective;
struct OpenACCDeclarativeConstruct;
struct OpenACCRoutineConstruct;
struct OpenMPConstruct;
struct OpenMPLoopConstruct;
struct OpenMPDeclarativeConstruct;
struct OmpEndLoopDirective;
struct CUFKernelDoConstruct;


using Location = const char *;


struct Verbatim {

  constexpr Verbatim() {}
  Verbatim(Verbatim &&) = default; Verbatim &operator=(Verbatim &&) = default; Verbatim(const Verbatim &) = delete; Verbatim &operator=(const Verbatim &) = delete;
  using EmptyTrait = std::true_type;
  CharBlock source;
};






template <typename A> struct Scalar {
  using ConstraintTrait = std::true_type;
  Scalar(Scalar &&that) = default;
  Scalar(A &&that) : thing(std::move(that)) {}
  Scalar &operator=(Scalar &&) = default;
  A thing;
};

template <typename A> struct Constant {
  using ConstraintTrait = std::true_type;
  Constant(Constant &&that) = default;
  Constant(A &&that) : thing(std::move(that)) {}
  Constant &operator=(Constant &&) = default;
  A thing;
};

template <typename A> struct Integer {
  using ConstraintTrait = std::true_type;
  Integer(Integer &&that) = default;
  Integer(A &&that) : thing(std::move(that)) {}
  Integer &operator=(Integer &&) = default;
  A thing;
};

template <typename A> struct Logical {
  using ConstraintTrait = std::true_type;
  Logical(Logical &&that) = default;
  Logical(A &&that) : thing(std::move(that)) {}
  Logical &operator=(Logical &&) = default;
  A thing;
};

template <typename A> struct DefaultChar {
  using ConstraintTrait = std::true_type;
  DefaultChar(DefaultChar &&that) = default;
  DefaultChar(A &&that) : thing(std::move(that)) {}
  DefaultChar &operator=(DefaultChar &&) = default;
  A thing;
};

using LogicalExpr = Logical<common::Indirection<Expr>>;
using DefaultCharExpr = DefaultChar<common::Indirection<Expr>>;
using IntExpr = Integer<common::Indirection<Expr>>;
using ConstantExpr = Constant<common::Indirection<Expr>>;
using IntConstantExpr = Integer<ConstantExpr>;
using ScalarLogicalExpr = Scalar<LogicalExpr>;
using ScalarIntExpr = Scalar<IntExpr>;
using ScalarIntConstantExpr = Scalar<IntConstantExpr>;
using ScalarDefaultCharExpr = Scalar<DefaultCharExpr>;


using ScalarDefaultCharConstantExpr = Scalar<DefaultChar<ConstantExpr>>;


using Label = common::Label;



template <typename A> struct UnlabeledStatement {
  explicit UnlabeledStatement(A &&s) : statement(std::move(s)) {}
  CharBlock source;
  A statement;
};
template <typename A> struct Statement : public UnlabeledStatement<A> {
  Statement(std::optional<long> &&lab, A &&s)
      : UnlabeledStatement<A>{std::move(s)}, label(std::move(lab)) {}
  std::optional<Label> label;
};


struct ErrorRecovery { ErrorRecovery() {} ErrorRecovery(const ErrorRecovery &) {} ErrorRecovery(ErrorRecovery &&) {} ErrorRecovery &operator=(const ErrorRecovery &) { return *this; }; ErrorRecovery &operator=(ErrorRecovery &&) { return *this; }; using EmptyTrait = std::true_type; };
# 372 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OtherSpecificationStmt {
  template <typename A, typename = common::NoLvalue<A>> OtherSpecificationStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OtherSpecificationStmt(OtherSpecificationStmt &&) = default; OtherSpecificationStmt &operator=(OtherSpecificationStmt &&) = default; OtherSpecificationStmt(const OtherSpecificationStmt &) = delete; OtherSpecificationStmt &operator=(const OtherSpecificationStmt &) = delete; OtherSpecificationStmt() = delete;
  std::variant<common::Indirection<AccessStmt>,
      common::Indirection<AllocatableStmt>,
      common::Indirection<AsynchronousStmt>, common::Indirection<BindStmt>,
      common::Indirection<CodimensionStmt>, common::Indirection<ContiguousStmt>,
      common::Indirection<DimensionStmt>, common::Indirection<ExternalStmt>,
      common::Indirection<IntentStmt>, common::Indirection<IntrinsicStmt>,
      common::Indirection<NamelistStmt>, common::Indirection<OptionalStmt>,
      common::Indirection<PointerStmt>, common::Indirection<ProtectedStmt>,
      common::Indirection<SaveStmt>, common::Indirection<TargetStmt>,
      common::Indirection<ValueStmt>, common::Indirection<VolatileStmt>,
      common::Indirection<CommonStmt>, common::Indirection<EquivalenceStmt>,
      common::Indirection<BasedPointerStmt>,
      common::Indirection<CUDAAttributesStmt>>
      u;
};





struct SpecificationConstruct {
  template <typename A, typename = common::NoLvalue<A>> SpecificationConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; SpecificationConstruct(SpecificationConstruct &&) = default; SpecificationConstruct &operator=(SpecificationConstruct &&) = default; SpecificationConstruct(const SpecificationConstruct &) = delete; SpecificationConstruct &operator=(const SpecificationConstruct &) = delete; SpecificationConstruct() = delete;
  std::variant<common::Indirection<DerivedTypeDef>,
      common::Indirection<EnumDef>, Statement<common::Indirection<GenericStmt>>,
      common::Indirection<InterfaceBlock>,
      Statement<common::Indirection<ParameterStmt>>,
      Statement<common::Indirection<OldParameterStmt>>,
      Statement<common::Indirection<ProcedureDeclarationStmt>>,
      Statement<OtherSpecificationStmt>,
      Statement<common::Indirection<TypeDeclarationStmt>>,
      common::Indirection<StructureDef>,
      common::Indirection<OpenACCDeclarativeConstruct>,
      common::Indirection<OpenMPDeclarativeConstruct>,
      common::Indirection<CompilerDirective>>
      u;
};



struct ImplicitPartStmt {
  template <typename A, typename = common::NoLvalue<A>> ImplicitPartStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImplicitPartStmt(ImplicitPartStmt &&) = default; ImplicitPartStmt &operator=(ImplicitPartStmt &&) = default; ImplicitPartStmt(const ImplicitPartStmt &) = delete; ImplicitPartStmt &operator=(const ImplicitPartStmt &) = delete; ImplicitPartStmt() = delete;
  std::variant<Statement<common::Indirection<ImplicitStmt>>,
      Statement<common::Indirection<ParameterStmt>>,
      Statement<common::Indirection<OldParameterStmt>>,
      Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCDeclarativeConstruct>>
      u;
};


struct ImplicitPart { ImplicitPart(ImplicitPart &&) = default; ImplicitPart &operator=(ImplicitPart &&) = default; ImplicitPart(const ImplicitPart &) = delete; ImplicitPart &operator=(const ImplicitPart &) = delete; ImplicitPart() = delete; ImplicitPart(std::list<ImplicitPartStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ImplicitPartStmt> v; };




struct DeclarationConstruct {
  template <typename A, typename = common::NoLvalue<A>> DeclarationConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DeclarationConstruct(DeclarationConstruct &&) = default; DeclarationConstruct &operator=(DeclarationConstruct &&) = default; DeclarationConstruct(const DeclarationConstruct &) = delete; DeclarationConstruct &operator=(const DeclarationConstruct &) = delete; DeclarationConstruct() = delete;
  std::variant<SpecificationConstruct, Statement<common::Indirection<DataStmt>>,
      Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      Statement<common::Indirection<StmtFunctionStmt>>, ErrorRecovery>
      u;
};






struct SpecificationPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SpecificationPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SpecificationPart(SpecificationPart &&) = default; SpecificationPart &operator=(SpecificationPart &&) = default; SpecificationPart(const SpecificationPart &) = delete; SpecificationPart &operator=(const SpecificationPart &) = delete; SpecificationPart() = delete;
  std::tuple<std::list<OpenACCDeclarativeConstruct>,
      std::list<OpenMPDeclarativeConstruct>,
      std::list<common::Indirection<CompilerDirective>>,
      std::list<Statement<common::Indirection<UseStmt>>>,
      std::list<Statement<common::Indirection<ImportStmt>>>, ImplicitPart,
      std::list<DeclarationConstruct>>
      t;
};


struct InternalSubprogram {
  template <typename A, typename = common::NoLvalue<A>> InternalSubprogram(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InternalSubprogram(InternalSubprogram &&) = default; InternalSubprogram &operator=(InternalSubprogram &&) = default; InternalSubprogram(const InternalSubprogram &) = delete; InternalSubprogram &operator=(const InternalSubprogram &) = delete; InternalSubprogram() = delete;
  std::variant<common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>,
      common::Indirection<CompilerDirective>>
      u;
};


struct ContainsStmt { ContainsStmt() {} ContainsStmt(const ContainsStmt &) {} ContainsStmt(ContainsStmt &&) {} ContainsStmt &operator=(const ContainsStmt &) { return *this; }; ContainsStmt &operator=(ContainsStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct InternalSubprogramPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InternalSubprogramPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InternalSubprogramPart(InternalSubprogramPart &&) = default; InternalSubprogramPart &operator=(InternalSubprogramPart &&) = default; InternalSubprogramPart(const InternalSubprogramPart &) = delete; InternalSubprogramPart &operator=(const InternalSubprogramPart &) = delete; InternalSubprogramPart() = delete;
  std::tuple<Statement<ContainsStmt>, std::list<InternalSubprogram>> t;
};


struct ContinueStmt { ContinueStmt() {} ContinueStmt(const ContinueStmt &) {} ContinueStmt(ContinueStmt &&) {} ContinueStmt &operator=(const ContinueStmt &) { return *this; }; ContinueStmt &operator=(ContinueStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct FailImageStmt { FailImageStmt() {} FailImageStmt(const FailImageStmt &) {} FailImageStmt(FailImageStmt &&) {} FailImageStmt &operator=(const FailImageStmt &) { return *this; }; FailImageStmt &operator=(FailImageStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
# 490 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct ActionStmt {
  template <typename A, typename = common::NoLvalue<A>> ActionStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ActionStmt(ActionStmt &&) = default; ActionStmt &operator=(ActionStmt &&) = default; ActionStmt(const ActionStmt &) = delete; ActionStmt &operator=(const ActionStmt &) = delete; ActionStmt() = delete;
  std::variant<common::Indirection<AllocateStmt>,
      common::Indirection<AssignmentStmt>, common::Indirection<BackspaceStmt>,
      common::Indirection<CallStmt>, common::Indirection<CloseStmt>,
      ContinueStmt, common::Indirection<CycleStmt>,
      common::Indirection<DeallocateStmt>, common::Indirection<EndfileStmt>,
      common::Indirection<EventPostStmt>, common::Indirection<EventWaitStmt>,
      common::Indirection<ExitStmt>, FailImageStmt,
      common::Indirection<FlushStmt>, common::Indirection<FormTeamStmt>,
      common::Indirection<GotoStmt>, common::Indirection<IfStmt>,
      common::Indirection<InquireStmt>, common::Indirection<LockStmt>,
      common::Indirection<NotifyWaitStmt>, common::Indirection<NullifyStmt>,
      common::Indirection<OpenStmt>, common::Indirection<PointerAssignmentStmt>,
      common::Indirection<PrintStmt>, common::Indirection<ReadStmt>,
      common::Indirection<ReturnStmt>, common::Indirection<RewindStmt>,
      common::Indirection<StopStmt>, common::Indirection<SyncAllStmt>,
      common::Indirection<SyncImagesStmt>, common::Indirection<SyncMemoryStmt>,
      common::Indirection<SyncTeamStmt>, common::Indirection<UnlockStmt>,
      common::Indirection<WaitStmt>, common::Indirection<WhereStmt>,
      common::Indirection<WriteStmt>, common::Indirection<ComputedGotoStmt>,
      common::Indirection<ForallStmt>, common::Indirection<ArithmeticIfStmt>,
      common::Indirection<AssignStmt>, common::Indirection<AssignedGotoStmt>,
      common::Indirection<PauseStmt>>
      u;
};







struct ExecutableConstruct {
  template <typename A, typename = common::NoLvalue<A>> ExecutableConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ExecutableConstruct(ExecutableConstruct &&) = default; ExecutableConstruct &operator=(ExecutableConstruct &&) = default; ExecutableConstruct(const ExecutableConstruct &) = delete; ExecutableConstruct &operator=(const ExecutableConstruct &) = delete; ExecutableConstruct() = delete;
  std::variant<Statement<ActionStmt>, common::Indirection<AssociateConstruct>,
      common::Indirection<BlockConstruct>, common::Indirection<CaseConstruct>,
      common::Indirection<ChangeTeamConstruct>,
      common::Indirection<CriticalConstruct>,
      Statement<common::Indirection<LabelDoStmt>>,
      Statement<common::Indirection<EndDoStmt>>,
      common::Indirection<DoConstruct>, common::Indirection<IfConstruct>,
      common::Indirection<SelectRankConstruct>,
      common::Indirection<SelectTypeConstruct>,
      common::Indirection<WhereConstruct>, common::Indirection<ForallConstruct>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCConstruct>,
      common::Indirection<AccEndCombinedDirective>,
      common::Indirection<OpenMPConstruct>,
      common::Indirection<OmpEndLoopDirective>,
      common::Indirection<CUFKernelDoConstruct>>
      u;
};




struct ExecutionPartConstruct {
  template <typename A, typename = common::NoLvalue<A>> ExecutionPartConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ExecutionPartConstruct(ExecutionPartConstruct &&) = default; ExecutionPartConstruct &operator=(ExecutionPartConstruct &&) = default; ExecutionPartConstruct(const ExecutionPartConstruct &) = delete; ExecutionPartConstruct &operator=(const ExecutionPartConstruct &) = delete; ExecutionPartConstruct() = delete;
  std::variant<ExecutableConstruct, Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      Statement<common::Indirection<DataStmt>>,
      Statement<common::Indirection<NamelistStmt>>, ErrorRecovery>
      u;
};



using Block = std::list<ExecutionPartConstruct>;
struct ExecutionPart { ExecutionPart(ExecutionPart &&) = default; ExecutionPart &operator=(ExecutionPart &&) = default; ExecutionPart(const ExecutionPart &) = delete; ExecutionPart &operator=(const ExecutionPart &) = delete; ExecutionPart() = delete; ExecutionPart(Block &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Block v; };




struct ProgramUnit {
  template <typename A, typename = common::NoLvalue<A>> ProgramUnit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProgramUnit(ProgramUnit &&) = default; ProgramUnit &operator=(ProgramUnit &&) = default; ProgramUnit(const ProgramUnit &) = delete; ProgramUnit &operator=(const ProgramUnit &) = delete; ProgramUnit() = delete;
  std::variant<common::Indirection<MainProgram>,
      common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>, common::Indirection<Module>,
      common::Indirection<Submodule>, common::Indirection<BlockData>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCRoutineConstruct>>
      u;
};



struct Program { Program(Program &&) = default; Program &operator=(Program &&) = default; Program(const Program &) = delete; Program &operator=(const Program &) = delete; Program() = delete; Program(std::list<ProgramUnit> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ProgramUnit> v; };


struct Name {
  std::string ToString() const { return source.ToString(); }
  CharBlock source;
  mutable semantics::Symbol *symbol{nullptr};
};


struct Keyword { Keyword(Keyword &&) = default; Keyword &operator=(Keyword &&) = default; Keyword(const Keyword &) = delete; Keyword &operator=(const Keyword &) = delete; Keyword() = delete; Keyword(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct NamedConstant { NamedConstant(NamedConstant &&) = default; NamedConstant &operator=(NamedConstant &&) = default; NamedConstant(const NamedConstant &) = delete; NamedConstant &operator=(const NamedConstant &) = delete; NamedConstant() = delete; NamedConstant(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };






struct DefinedOpName { DefinedOpName(DefinedOpName &&) = default; DefinedOpName &operator=(DefinedOpName &&) = default; DefinedOpName(const DefinedOpName &) = delete; DefinedOpName &operator=(const DefinedOpName &) = delete; DefinedOpName() = delete; DefinedOpName(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };







struct DefinedOperator {
  template <typename A, typename = common::NoLvalue<A>> DefinedOperator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DefinedOperator(DefinedOperator &&) = default; DefinedOperator &operator=(DefinedOperator &&) = default; DefinedOperator(const DefinedOperator &) = delete; DefinedOperator &operator=(const DefinedOperator &) = delete; DefinedOperator() = delete;
  enum class IntrinsicOperator { Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV }; [[maybe_unused]] static constexpr std::size_t IntrinsicOperator_enumSize{ ::Fortran::common::CountEnumNames("Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV")}; [[maybe_unused]] static inline std::size_t EnumToInt(IntrinsicOperator e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(IntrinsicOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IntrinsicOperator_enumSize>("Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIntrinsicOperator(std::function<void(IntrinsicOperator)> f) { for (std::size_t i{0}; i < IntrinsicOperator_enumSize; ++i) { f(static_cast<IntrinsicOperator>(i)); } }

  std::variant<DefinedOpName, IntrinsicOperator> u;
};


using ObjectName = Name;




struct ImportStmt {
  ImportStmt(ImportStmt &&) = default; ImportStmt &operator=(ImportStmt &&) = default; ImportStmt(const ImportStmt &) = delete; ImportStmt &operator=(const ImportStmt &) = delete; ImportStmt() = delete;
  ImportStmt(common::ImportKind &&k) : kind{k} {}
  ImportStmt(std::list<Name> &&n) : names(std::move(n)) {}
  ImportStmt(common::ImportKind &&, std::list<Name> &&);
  common::ImportKind kind{common::ImportKind::Default};
  std::list<Name> names;
};





struct NamelistStmt {
  struct Group {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Group(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Group(Group &&) = default; Group &operator=(Group &&) = default; Group(const Group &) = delete; Group &operator=(const Group &) = delete; Group() = delete;
    std::tuple<Name, std::list<Name>> t;
  };
  NamelistStmt(NamelistStmt &&) = default; NamelistStmt &operator=(NamelistStmt &&) = default; NamelistStmt(const NamelistStmt &) = delete; NamelistStmt &operator=(const NamelistStmt &) = delete; NamelistStmt() = delete; NamelistStmt(std::list<Group> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Group> v;
};


struct Star { Star() {} Star(const Star &) {} Star(Star &&) {} Star &operator=(const Star &) { return *this; }; Star &operator=(Star &&) { return *this; }; using EmptyTrait = std::true_type; };

struct TypeParamValue {
  template <typename A, typename = common::NoLvalue<A>> TypeParamValue(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeParamValue(TypeParamValue &&) = default; TypeParamValue &operator=(TypeParamValue &&) = default; TypeParamValue(const TypeParamValue &) = delete; TypeParamValue &operator=(const TypeParamValue &) = delete; TypeParamValue() = delete;
  struct Deferred { Deferred() {} Deferred(const Deferred &) {} Deferred(Deferred &&) {} Deferred &operator=(const Deferred &) { return *this; }; Deferred &operator=(Deferred &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<ScalarIntExpr, Star, Deferred> u;
};




struct KindSelector {
  template <typename A, typename = common::NoLvalue<A>> KindSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; KindSelector(KindSelector &&) = default; KindSelector &operator=(KindSelector &&) = default; KindSelector(const KindSelector &) = delete; KindSelector &operator=(const KindSelector &) = delete; KindSelector() = delete;
  struct StarSize { StarSize(StarSize &&) = default; StarSize &operator=(StarSize &&) = default; StarSize(const StarSize &) = delete; StarSize &operator=(const StarSize &) = delete; StarSize() = delete; StarSize(std::uint64_t &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::uint64_t v; };
  std::variant<ScalarIntConstantExpr, StarSize> u;
};


struct IntegerTypeSpec { IntegerTypeSpec(IntegerTypeSpec &&) = default; IntegerTypeSpec &operator=(IntegerTypeSpec &&) = default; IntegerTypeSpec(const IntegerTypeSpec &) = delete; IntegerTypeSpec &operator=(const IntegerTypeSpec &) = delete; IntegerTypeSpec() = delete; IntegerTypeSpec(std::optional<KindSelector> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<KindSelector> v; };

struct UnsignedTypeSpec { UnsignedTypeSpec(UnsignedTypeSpec &&) = default; UnsignedTypeSpec &operator=(UnsignedTypeSpec &&) = default; UnsignedTypeSpec(const UnsignedTypeSpec &) = delete; UnsignedTypeSpec &operator=(const UnsignedTypeSpec &) = delete; UnsignedTypeSpec() = delete; UnsignedTypeSpec(std::optional<KindSelector> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<KindSelector> v; };


struct CharLength {
  template <typename A, typename = common::NoLvalue<A>> CharLength(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CharLength(CharLength &&) = default; CharLength &operator=(CharLength &&) = default; CharLength(const CharLength &) = delete; CharLength &operator=(const CharLength &) = delete; CharLength() = delete;
  std::variant<TypeParamValue, std::uint64_t> u;
};


struct LengthSelector {
  template <typename A, typename = common::NoLvalue<A>> LengthSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LengthSelector(LengthSelector &&) = default; LengthSelector &operator=(LengthSelector &&) = default; LengthSelector(const LengthSelector &) = delete; LengthSelector &operator=(const LengthSelector &) = delete; LengthSelector() = delete;
  std::variant<TypeParamValue, CharLength> u;
};






struct CharSelector {
  template <typename A, typename = common::NoLvalue<A>> CharSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CharSelector(CharSelector &&) = default; CharSelector &operator=(CharSelector &&) = default; CharSelector(const CharSelector &) = delete; CharSelector &operator=(const CharSelector &) = delete; CharSelector() = delete;
  struct LengthAndKind {
    LengthAndKind(LengthAndKind &&) = default; LengthAndKind &operator=(LengthAndKind &&) = default; LengthAndKind(const LengthAndKind &) = delete; LengthAndKind &operator=(const LengthAndKind &) = delete; LengthAndKind() = delete;
    LengthAndKind(std::optional<TypeParamValue> &&l, ScalarIntConstantExpr &&k)
        : length(std::move(l)), kind(std::move(k)) {}
    std::optional<TypeParamValue> length;
    ScalarIntConstantExpr kind;
  };
  CharSelector(TypeParamValue &&l, ScalarIntConstantExpr &&k)
      : u{LengthAndKind{std::make_optional(std::move(l)), std::move(k)}} {}
  CharSelector(ScalarIntConstantExpr &&k, std::optional<TypeParamValue> &&l)
      : u{LengthAndKind{std::move(l), std::move(k)}} {}
  std::variant<LengthSelector, LengthAndKind> u;
};






struct IntrinsicTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> IntrinsicTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IntrinsicTypeSpec(IntrinsicTypeSpec &&) = default; IntrinsicTypeSpec &operator=(IntrinsicTypeSpec &&) = default; IntrinsicTypeSpec(const IntrinsicTypeSpec &) = delete; IntrinsicTypeSpec &operator=(const IntrinsicTypeSpec &) = delete; IntrinsicTypeSpec() = delete;
  struct Real {
    Real(Real &&) = default; Real &operator=(Real &&) = default; Real(const Real &) = delete; Real &operator=(const Real &) = delete; Real() = delete;
    Real(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct DoublePrecision { DoublePrecision() {} DoublePrecision(const DoublePrecision &) {} DoublePrecision(DoublePrecision &&) {} DoublePrecision &operator=(const DoublePrecision &) { return *this; }; DoublePrecision &operator=(DoublePrecision &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Complex {
    Complex(Complex &&) = default; Complex &operator=(Complex &&) = default; Complex(const Complex &) = delete; Complex &operator=(const Complex &) = delete; Complex() = delete;
    Complex(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct Character {
    Character(Character &&) = default; Character &operator=(Character &&) = default; Character(const Character &) = delete; Character &operator=(const Character &) = delete; Character() = delete;
    Character(std::optional<CharSelector> &&s) : selector{std::move(s)} {}
    std::optional<CharSelector> selector;
  };
  struct Logical {
    Logical(Logical &&) = default; Logical &operator=(Logical &&) = default; Logical(const Logical &) = delete; Logical &operator=(const Logical &) = delete; Logical() = delete;
    Logical(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct DoubleComplex { DoubleComplex() {} DoubleComplex(const DoubleComplex &) {} DoubleComplex(DoubleComplex &&) {} DoubleComplex &operator=(const DoubleComplex &) { return *this; }; DoubleComplex &operator=(DoubleComplex &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<IntegerTypeSpec, UnsignedTypeSpec, Real, DoublePrecision,
      Complex, Character, Logical, DoubleComplex>
      u;
};


struct VectorElementType {
  template <typename A, typename = common::NoLvalue<A>> VectorElementType(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; VectorElementType(VectorElementType &&) = default; VectorElementType &operator=(VectorElementType &&) = default; VectorElementType(const VectorElementType &) = delete; VectorElementType &operator=(const VectorElementType &) = delete; VectorElementType() = delete;
  std::variant<IntegerTypeSpec, IntrinsicTypeSpec::Real, UnsignedTypeSpec> u;
};
struct IntrinsicVectorTypeSpec { IntrinsicVectorTypeSpec(IntrinsicVectorTypeSpec &&) = default; IntrinsicVectorTypeSpec &operator=(IntrinsicVectorTypeSpec &&) = default; IntrinsicVectorTypeSpec(const IntrinsicVectorTypeSpec &) = delete; IntrinsicVectorTypeSpec &operator=(const IntrinsicVectorTypeSpec &) = delete; IntrinsicVectorTypeSpec() = delete; IntrinsicVectorTypeSpec(VectorElementType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; VectorElementType v; };
struct VectorTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> VectorTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; VectorTypeSpec(VectorTypeSpec &&) = default; VectorTypeSpec &operator=(VectorTypeSpec &&) = default; VectorTypeSpec(const VectorTypeSpec &) = delete; VectorTypeSpec &operator=(const VectorTypeSpec &) = delete; VectorTypeSpec() = delete;
  struct PairVectorTypeSpec { PairVectorTypeSpec() {} PairVectorTypeSpec(const PairVectorTypeSpec &) {} PairVectorTypeSpec(PairVectorTypeSpec &&) {} PairVectorTypeSpec &operator=(const PairVectorTypeSpec &) { return *this; }; PairVectorTypeSpec &operator=(PairVectorTypeSpec &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct QuadVectorTypeSpec { QuadVectorTypeSpec() {} QuadVectorTypeSpec(const QuadVectorTypeSpec &) {} QuadVectorTypeSpec(QuadVectorTypeSpec &&) {} QuadVectorTypeSpec &operator=(const QuadVectorTypeSpec &) { return *this; }; QuadVectorTypeSpec &operator=(QuadVectorTypeSpec &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<IntrinsicVectorTypeSpec, PairVectorTypeSpec, QuadVectorTypeSpec>
      u;
};


struct TypeParamSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamSpec(TypeParamSpec &&) = default; TypeParamSpec &operator=(TypeParamSpec &&) = default; TypeParamSpec(const TypeParamSpec &) = delete; TypeParamSpec &operator=(const TypeParamSpec &) = delete; TypeParamSpec() = delete;
  std::tuple<std::optional<Keyword>, TypeParamValue> t;
};


struct DerivedTypeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeSpec(DerivedTypeSpec &&) = default; DerivedTypeSpec &operator=(DerivedTypeSpec &&) = default; DerivedTypeSpec(const DerivedTypeSpec &) = delete; DerivedTypeSpec &operator=(const DerivedTypeSpec &) = delete; DerivedTypeSpec() = delete;
  mutable const semantics::DerivedTypeSpec *derivedTypeSpec{nullptr};
  std::tuple<Name, std::list<TypeParamSpec>> t;
};


struct TypeSpec {
  template <typename A, typename = common::NoLvalue<A>> TypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeSpec(TypeSpec &&) = default; TypeSpec &operator=(TypeSpec &&) = default; TypeSpec(const TypeSpec &) = delete; TypeSpec &operator=(const TypeSpec &) = delete; TypeSpec() = delete;
  mutable const semantics::DeclTypeSpec *declTypeSpec{nullptr};
  std::variant<IntrinsicTypeSpec, DerivedTypeSpec> u;
};






struct DeclarationTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> DeclarationTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DeclarationTypeSpec(DeclarationTypeSpec &&) = default; DeclarationTypeSpec &operator=(DeclarationTypeSpec &&) = default; DeclarationTypeSpec(const DeclarationTypeSpec &) = delete; DeclarationTypeSpec &operator=(const DeclarationTypeSpec &) = delete; DeclarationTypeSpec() = delete;
  struct Type {
    Type(Type &&) = default; Type &operator=(Type &&) = default; Type(const Type &) = delete; Type &operator=(const Type &) = delete; Type() = delete;
    Type(DerivedTypeSpec &&dt) : derived(std::move(dt)) {}
    DerivedTypeSpec derived;
  };
  struct Class {
    Class(Class &&) = default; Class &operator=(Class &&) = default; Class(const Class &) = delete; Class &operator=(const Class &) = delete; Class() = delete;
    Class(DerivedTypeSpec &&dt) : derived(std::move(dt)) {}
    DerivedTypeSpec derived;
  };
  struct ClassStar { ClassStar() {} ClassStar(const ClassStar &) {} ClassStar(ClassStar &&) {} ClassStar &operator=(const ClassStar &) { return *this; }; ClassStar &operator=(ClassStar &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct TypeStar { TypeStar() {} TypeStar(const TypeStar &) {} TypeStar(TypeStar &&) {} TypeStar &operator=(const TypeStar &) { return *this; }; TypeStar &operator=(TypeStar &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Record { Record(Record &&) = default; Record &operator=(Record &&) = default; Record(const Record &) = delete; Record &operator=(const Record &) = delete; Record() = delete; Record(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };
  std::variant<IntrinsicTypeSpec, Type, Class, ClassStar, TypeStar, Record,
      VectorTypeSpec>
      u;
};


struct KindParam {
  template <typename A, typename = common::NoLvalue<A>> KindParam(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; KindParam(KindParam &&) = default; KindParam &operator=(KindParam &&) = default; KindParam(const KindParam &) = delete; KindParam &operator=(const KindParam &) = delete; KindParam() = delete;
  std::variant<std::uint64_t, Scalar<Integer<Constant<Name>>>> u;
};


struct SignedIntLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedIntLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedIntLiteralConstant(SignedIntLiteralConstant &&) = default; SignedIntLiteralConstant &operator=(SignedIntLiteralConstant &&) = default; SignedIntLiteralConstant(const SignedIntLiteralConstant &) = delete; SignedIntLiteralConstant &operator=(const SignedIntLiteralConstant &) = delete; SignedIntLiteralConstant() = delete;
  CharBlock source;
  std::tuple<CharBlock, std::optional<KindParam>> t;
};


struct IntLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IntLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntLiteralConstant(IntLiteralConstant &&) = default; IntLiteralConstant &operator=(IntLiteralConstant &&) = default; IntLiteralConstant(const IntLiteralConstant &) = delete; IntLiteralConstant &operator=(const IntLiteralConstant &) = delete; IntLiteralConstant() = delete;
  std::tuple<CharBlock, std::optional<KindParam>> t;
};


struct UnsignedLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> UnsignedLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; UnsignedLiteralConstant(UnsignedLiteralConstant &&) = default; UnsignedLiteralConstant &operator=(UnsignedLiteralConstant &&) = default; UnsignedLiteralConstant(const UnsignedLiteralConstant &) = delete; UnsignedLiteralConstant &operator=(const UnsignedLiteralConstant &) = delete; UnsignedLiteralConstant() = delete;
  std::tuple<CharBlock, std::optional<KindParam>> t;
};


enum class Sign { Positive, Negative };






struct RealLiteralConstant {
  RealLiteralConstant(RealLiteralConstant &&) = default; RealLiteralConstant &operator=(RealLiteralConstant &&) = default; RealLiteralConstant(const RealLiteralConstant &) = delete; RealLiteralConstant &operator=(const RealLiteralConstant &) = delete; RealLiteralConstant() = delete;
  struct Real {
    Real(Real &&) = default; Real &operator=(Real &&) = default; Real(const Real &) = delete; Real &operator=(const Real &) = delete;
    Real() {}
    CharBlock source;
  };
  RealLiteralConstant(Real &&r, std::optional<KindParam> &&k)
      : real{std::move(r)}, kind{std::move(k)} {}
  Real real;
  std::optional<KindParam> kind;
};


struct SignedRealLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedRealLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedRealLiteralConstant(SignedRealLiteralConstant &&) = default; SignedRealLiteralConstant &operator=(SignedRealLiteralConstant &&) = default; SignedRealLiteralConstant(const SignedRealLiteralConstant &) = delete; SignedRealLiteralConstant &operator=(const SignedRealLiteralConstant &) = delete; SignedRealLiteralConstant() = delete;
  std::tuple<std::optional<Sign>, RealLiteralConstant> t;
};







struct ComplexPart {
  template <typename A, typename = common::NoLvalue<A>> ComplexPart(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComplexPart(ComplexPart &&) = default; ComplexPart &operator=(ComplexPart &&) = default; ComplexPart(const ComplexPart &) = delete; ComplexPart &operator=(const ComplexPart &) = delete; ComplexPart() = delete;
  std::variant<SignedIntLiteralConstant, SignedRealLiteralConstant,
      NamedConstant>
      u;
};


struct ComplexLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComplexLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComplexLiteralConstant(ComplexLiteralConstant &&) = default; ComplexLiteralConstant &operator=(ComplexLiteralConstant &&) = default; ComplexLiteralConstant(const ComplexLiteralConstant &) = delete; ComplexLiteralConstant &operator=(const ComplexLiteralConstant &) = delete; ComplexLiteralConstant() = delete;
  std::tuple<ComplexPart, ComplexPart> t;
};


struct SignedComplexLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedComplexLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedComplexLiteralConstant(SignedComplexLiteralConstant &&) = default; SignedComplexLiteralConstant &operator=(SignedComplexLiteralConstant &&) = default; SignedComplexLiteralConstant(const SignedComplexLiteralConstant &) = delete; SignedComplexLiteralConstant &operator=(const SignedComplexLiteralConstant &) = delete; SignedComplexLiteralConstant() = delete;
  std::tuple<Sign, ComplexLiteralConstant> t;
};




struct CharLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CharLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharLiteralConstant(CharLiteralConstant &&) = default; CharLiteralConstant &operator=(CharLiteralConstant &&) = default; CharLiteralConstant(const CharLiteralConstant &) = delete; CharLiteralConstant &operator=(const CharLiteralConstant &) = delete; CharLiteralConstant() = delete;
  std::tuple<std::optional<KindParam>, std::string> t;
  std::string GetString() const { return std::get<std::string>(t); }
};


struct HollerithLiteralConstant {
  HollerithLiteralConstant(HollerithLiteralConstant &&) = default; HollerithLiteralConstant &operator=(HollerithLiteralConstant &&) = default; HollerithLiteralConstant(const HollerithLiteralConstant &) = delete; HollerithLiteralConstant &operator=(const HollerithLiteralConstant &) = delete; HollerithLiteralConstant() = delete; HollerithLiteralConstant(std::string &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::string v;
  std::string GetString() const { return v; }
};



struct LogicalLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LogicalLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LogicalLiteralConstant(LogicalLiteralConstant &&) = default; LogicalLiteralConstant &operator=(LogicalLiteralConstant &&) = default; LogicalLiteralConstant(const LogicalLiteralConstant &) = delete; LogicalLiteralConstant &operator=(const LogicalLiteralConstant &) = delete; LogicalLiteralConstant() = delete;
  std::tuple<bool, std::optional<KindParam>> t;
};
# 894 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct BOZLiteralConstant { BOZLiteralConstant(BOZLiteralConstant &&) = default; BOZLiteralConstant &operator=(BOZLiteralConstant &&) = default; BOZLiteralConstant(const BOZLiteralConstant &) = delete; BOZLiteralConstant &operator=(const BOZLiteralConstant &) = delete; BOZLiteralConstant() = delete; BOZLiteralConstant(std::string &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::string v; };





struct LiteralConstant {
  template <typename A, typename = common::NoLvalue<A>> LiteralConstant(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LiteralConstant(LiteralConstant &&) = default; LiteralConstant &operator=(LiteralConstant &&) = default; LiteralConstant(const LiteralConstant &) = delete; LiteralConstant &operator=(const LiteralConstant &) = delete; LiteralConstant() = delete;
  std::variant<HollerithLiteralConstant, IntLiteralConstant,
      RealLiteralConstant, ComplexLiteralConstant, BOZLiteralConstant,
      CharLiteralConstant, LogicalLiteralConstant, UnsignedLiteralConstant>
      u;
};


struct AccessSpec {
  enum class Kind { Public, Private }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Public, Private")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Public, Private")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  AccessSpec(AccessSpec &&) = default; AccessSpec &operator=(AccessSpec &&) = default; AccessSpec(const AccessSpec &) = delete; AccessSpec &operator=(const AccessSpec &) = delete; AccessSpec() = delete; AccessSpec(Kind &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Kind v;
};



struct Abstract { Abstract() {} Abstract(const Abstract &) {} Abstract(Abstract &&) {} Abstract &operator=(const Abstract &) { return *this; }; Abstract &operator=(Abstract &&) { return *this; }; using EmptyTrait = std::true_type; };
struct TypeAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> TypeAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeAttrSpec(TypeAttrSpec &&) = default; TypeAttrSpec &operator=(TypeAttrSpec &&) = default; TypeAttrSpec(const TypeAttrSpec &) = delete; TypeAttrSpec &operator=(const TypeAttrSpec &) = delete; TypeAttrSpec() = delete;
  struct BindC { BindC() {} BindC(const BindC &) {} BindC(BindC &&) {} BindC &operator=(const BindC &) { return *this; }; BindC &operator=(BindC &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Extends { Extends(Extends &&) = default; Extends &operator=(Extends &&) = default; Extends(const Extends &) = delete; Extends &operator=(const Extends &) = delete; Extends() = delete; Extends(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };
  std::variant<Abstract, AccessSpec, BindC, Extends> u;
};



struct DerivedTypeStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeStmt(DerivedTypeStmt &&) = default; DerivedTypeStmt &operator=(DerivedTypeStmt &&) = default; DerivedTypeStmt(const DerivedTypeStmt &) = delete; DerivedTypeStmt &operator=(const DerivedTypeStmt &) = delete; DerivedTypeStmt() = delete;
  std::tuple<std::list<TypeAttrSpec>, Name, std::list<Name>> t;
};


struct SequenceStmt { SequenceStmt() {} SequenceStmt(const SequenceStmt &) {} SequenceStmt(SequenceStmt &&) {} SequenceStmt &operator=(const SequenceStmt &) { return *this; }; SequenceStmt &operator=(SequenceStmt &&) { return *this; }; using EmptyTrait = std::true_type; };



struct PrivateStmt { PrivateStmt() {} PrivateStmt(const PrivateStmt &) {} PrivateStmt(PrivateStmt &&) {} PrivateStmt &operator=(const PrivateStmt &) { return *this; }; PrivateStmt &operator=(PrivateStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct PrivateOrSequence {
  template <typename A, typename = common::NoLvalue<A>> PrivateOrSequence(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PrivateOrSequence(PrivateOrSequence &&) = default; PrivateOrSequence &operator=(PrivateOrSequence &&) = default; PrivateOrSequence(const PrivateOrSequence &) = delete; PrivateOrSequence &operator=(const PrivateOrSequence &) = delete; PrivateOrSequence() = delete;
  std::variant<PrivateStmt, SequenceStmt> u;
};


struct TypeParamDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamDecl(TypeParamDecl &&) = default; TypeParamDecl &operator=(TypeParamDecl &&) = default; TypeParamDecl(const TypeParamDecl &) = delete; TypeParamDecl &operator=(const TypeParamDecl &) = delete; TypeParamDecl() = delete;
  std::tuple<Name, std::optional<ScalarIntConstantExpr>> t;
};




struct TypeParamDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamDefStmt(TypeParamDefStmt &&) = default; TypeParamDefStmt &operator=(TypeParamDefStmt &&) = default; TypeParamDefStmt(const TypeParamDefStmt &) = delete; TypeParamDefStmt &operator=(const TypeParamDefStmt &) = delete; TypeParamDefStmt() = delete;
  std::tuple<IntegerTypeSpec, common::TypeParamAttr, std::list<TypeParamDecl>>
      t;
};


struct SpecificationExpr { SpecificationExpr(SpecificationExpr &&) = default; SpecificationExpr &operator=(SpecificationExpr &&) = default; SpecificationExpr(const SpecificationExpr &) = delete; SpecificationExpr &operator=(const SpecificationExpr &) = delete; SpecificationExpr() = delete; SpecificationExpr(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };




struct ExplicitShapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ExplicitShapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ExplicitShapeSpec(ExplicitShapeSpec &&) = default; ExplicitShapeSpec &operator=(ExplicitShapeSpec &&) = default; ExplicitShapeSpec(const ExplicitShapeSpec &) = delete; ExplicitShapeSpec &operator=(const ExplicitShapeSpec &) = delete; ExplicitShapeSpec() = delete;
  std::tuple<std::optional<SpecificationExpr>, SpecificationExpr> t;
};



struct DeferredCoshapeSpecList { DeferredCoshapeSpecList(DeferredCoshapeSpecList &&) = default; DeferredCoshapeSpecList &operator=(DeferredCoshapeSpecList &&) = default; DeferredCoshapeSpecList(const DeferredCoshapeSpecList &) = delete; DeferredCoshapeSpecList &operator=(const DeferredCoshapeSpecList &) = delete; DeferredCoshapeSpecList() = delete; DeferredCoshapeSpecList(int &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; int v; };





struct ExplicitCoshapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ExplicitCoshapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ExplicitCoshapeSpec(ExplicitCoshapeSpec &&) = default; ExplicitCoshapeSpec &operator=(ExplicitCoshapeSpec &&) = default; ExplicitCoshapeSpec(const ExplicitCoshapeSpec &) = delete; ExplicitCoshapeSpec &operator=(const ExplicitCoshapeSpec &) = delete; ExplicitCoshapeSpec() = delete;
  std::tuple<std::list<ExplicitShapeSpec>, std::optional<SpecificationExpr>> t;
};


struct CoarraySpec {
  template <typename A, typename = common::NoLvalue<A>> CoarraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CoarraySpec(CoarraySpec &&) = default; CoarraySpec &operator=(CoarraySpec &&) = default; CoarraySpec(const CoarraySpec &) = delete; CoarraySpec &operator=(const CoarraySpec &) = delete; CoarraySpec() = delete;
  std::variant<DeferredCoshapeSpecList, ExplicitCoshapeSpec> u;
};



struct DeferredShapeSpecList { DeferredShapeSpecList(DeferredShapeSpecList &&) = default; DeferredShapeSpecList &operator=(DeferredShapeSpecList &&) = default; DeferredShapeSpecList(const DeferredShapeSpecList &) = delete; DeferredShapeSpecList &operator=(const DeferredShapeSpecList &) = delete; DeferredShapeSpecList() = delete; DeferredShapeSpecList(int &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; int v; };



struct ComponentArraySpec {
  template <typename A, typename = common::NoLvalue<A>> ComponentArraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentArraySpec(ComponentArraySpec &&) = default; ComponentArraySpec &operator=(ComponentArraySpec &&) = default; ComponentArraySpec(const ComponentArraySpec &) = delete; ComponentArraySpec &operator=(const ComponentArraySpec &) = delete; ComponentArraySpec() = delete;
  std::variant<std::list<ExplicitShapeSpec>, DeferredShapeSpecList> u;
};






struct Allocatable { Allocatable() {} Allocatable(const Allocatable &) {} Allocatable(Allocatable &&) {} Allocatable &operator=(const Allocatable &) { return *this; }; Allocatable &operator=(Allocatable &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Pointer { Pointer() {} Pointer(const Pointer &) {} Pointer(Pointer &&) {} Pointer &operator=(const Pointer &) { return *this; }; Pointer &operator=(Pointer &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Contiguous { Contiguous() {} Contiguous(const Contiguous &) {} Contiguous(Contiguous &&) {} Contiguous &operator=(const Contiguous &) { return *this; }; Contiguous &operator=(Contiguous &&) { return *this; }; using EmptyTrait = std::true_type; };
struct ComponentAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ComponentAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentAttrSpec(ComponentAttrSpec &&) = default; ComponentAttrSpec &operator=(ComponentAttrSpec &&) = default; ComponentAttrSpec(const ComponentAttrSpec &) = delete; ComponentAttrSpec &operator=(const ComponentAttrSpec &) = delete; ComponentAttrSpec() = delete;
  std::variant<AccessSpec, Allocatable, CoarraySpec, Contiguous,
      ComponentArraySpec, Pointer, common::CUDADataAttr, ErrorRecovery>
      u;
};


struct NullInit { NullInit(NullInit &&) = default; NullInit &operator=(NullInit &&) = default; NullInit(const NullInit &) = delete; NullInit &operator=(const NullInit &) = delete; NullInit() = delete; NullInit(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };


using InitialDataTarget = common::Indirection<Designator>;






struct Initialization {
  template <typename A, typename = common::NoLvalue<A>> Initialization(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Initialization(Initialization &&) = default; Initialization &operator=(Initialization &&) = default; Initialization(const Initialization &) = delete; Initialization &operator=(const Initialization &) = delete; Initialization() = delete;
  std::variant<ConstantExpr, NullInit, InitialDataTarget,
      std::list<common::Indirection<DataStmtValue>>>
      u;
};







struct ComponentDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComponentDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComponentDecl(ComponentDecl &&) = default; ComponentDecl &operator=(ComponentDecl &&) = default; ComponentDecl(const ComponentDecl &) = delete; ComponentDecl &operator=(const ComponentDecl &) = delete; ComponentDecl() = delete;
  ComponentDecl(Name &&name, CharLength &&length,
      std::optional<ComponentArraySpec> &&aSpec,
      std::optional<CoarraySpec> &&coaSpec,
      std::optional<Initialization> &&init)
      : t{std::move(name), std::move(aSpec), std::move(coaSpec),
            std::move(length), std::move(init)} {}
  std::tuple<Name, std::optional<ComponentArraySpec>,
      std::optional<CoarraySpec>, std::optional<CharLength>,
      std::optional<Initialization>>
      t;
};



struct FillDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FillDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FillDecl(FillDecl &&) = default; FillDecl &operator=(FillDecl &&) = default; FillDecl(const FillDecl &) = delete; FillDecl &operator=(const FillDecl &) = delete; FillDecl() = delete;
  std::tuple<Name, std::optional<ComponentArraySpec>, std::optional<CharLength>>
      t;
};

struct ComponentOrFill {
  template <typename A, typename = common::NoLvalue<A>> ComponentOrFill(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentOrFill(ComponentOrFill &&) = default; ComponentOrFill &operator=(ComponentOrFill &&) = default; ComponentOrFill(const ComponentOrFill &) = delete; ComponentOrFill &operator=(const ComponentOrFill &) = delete; ComponentOrFill() = delete;
  std::variant<ComponentDecl, FillDecl> u;
};




struct DataComponentDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataComponentDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataComponentDefStmt(DataComponentDefStmt &&) = default; DataComponentDefStmt &operator=(DataComponentDefStmt &&) = default; DataComponentDefStmt(const DataComponentDefStmt &) = delete; DataComponentDefStmt &operator=(const DataComponentDefStmt &) = delete; DataComponentDefStmt() = delete;
  std::tuple<DeclarationTypeSpec, std::list<ComponentAttrSpec>,
      std::list<ComponentOrFill>>
      t;
};



struct NoPass { NoPass() {} NoPass(const NoPass &) {} NoPass(NoPass &&) {} NoPass &operator=(const NoPass &) { return *this; }; NoPass &operator=(NoPass &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Pass { Pass(Pass &&) = default; Pass &operator=(Pass &&) = default; Pass(const Pass &) = delete; Pass &operator=(const Pass &) = delete; Pass() = delete; Pass(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
struct ProcComponentAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ProcComponentAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcComponentAttrSpec(ProcComponentAttrSpec &&) = default; ProcComponentAttrSpec &operator=(ProcComponentAttrSpec &&) = default; ProcComponentAttrSpec(const ProcComponentAttrSpec &) = delete; ProcComponentAttrSpec &operator=(const ProcComponentAttrSpec &) = delete; ProcComponentAttrSpec() = delete;
  std::variant<AccessSpec, NoPass, Pass, Pointer> u;
};



struct ProcPointerInit {
  template <typename A, typename = common::NoLvalue<A>> ProcPointerInit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcPointerInit(ProcPointerInit &&) = default; ProcPointerInit &operator=(ProcPointerInit &&) = default; ProcPointerInit(const ProcPointerInit &) = delete; ProcPointerInit &operator=(const ProcPointerInit &) = delete; ProcPointerInit() = delete;
  std::variant<NullInit, Name> u;
};



struct ProcInterface {
  template <typename A, typename = common::NoLvalue<A>> ProcInterface(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcInterface(ProcInterface &&) = default; ProcInterface &operator=(ProcInterface &&) = default; ProcInterface(const ProcInterface &) = delete; ProcInterface &operator=(const ProcInterface &) = delete; ProcInterface() = delete;
  std::variant<Name, DeclarationTypeSpec> u;
};


struct ProcDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcDecl(ProcDecl &&) = default; ProcDecl &operator=(ProcDecl &&) = default; ProcDecl(const ProcDecl &) = delete; ProcDecl &operator=(const ProcDecl &) = delete; ProcDecl() = delete;
  std::tuple<Name, std::optional<ProcPointerInit>> t;
};




struct ProcComponentDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcComponentDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcComponentDefStmt(ProcComponentDefStmt &&) = default; ProcComponentDefStmt &operator=(ProcComponentDefStmt &&) = default; ProcComponentDefStmt(const ProcComponentDefStmt &) = delete; ProcComponentDefStmt &operator=(const ProcComponentDefStmt &) = delete; ProcComponentDefStmt() = delete;
  std::tuple<std::optional<ProcInterface>, std::list<ProcComponentAttrSpec>,
      std::list<ProcDecl>>
      t;
};


struct ComponentDefStmt {
  template <typename A, typename = common::NoLvalue<A>> ComponentDefStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentDefStmt(ComponentDefStmt &&) = default; ComponentDefStmt &operator=(ComponentDefStmt &&) = default; ComponentDefStmt(const ComponentDefStmt &) = delete; ComponentDefStmt &operator=(const ComponentDefStmt &) = delete; ComponentDefStmt() = delete;
  std::variant<DataComponentDefStmt, ProcComponentDefStmt,
      common::Indirection<CompilerDirective>, ErrorRecovery

      >
      u;
};



struct BindAttr {
  template <typename A, typename = common::NoLvalue<A>> BindAttr(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; BindAttr(BindAttr &&) = default; BindAttr &operator=(BindAttr &&) = default; BindAttr(const BindAttr &) = delete; BindAttr &operator=(const BindAttr &) = delete; BindAttr() = delete;
  struct Deferred { Deferred() {} Deferred(const Deferred &) {} Deferred(Deferred &&) {} Deferred &operator=(const Deferred &) { return *this; }; Deferred &operator=(Deferred &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Non_Overridable { Non_Overridable() {} Non_Overridable(const Non_Overridable &) {} Non_Overridable(Non_Overridable &&) {} Non_Overridable &operator=(const Non_Overridable &) { return *this; }; Non_Overridable &operator=(Non_Overridable &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<AccessSpec, Deferred, Non_Overridable, NoPass, Pass> u;
};


struct TypeBoundProcDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundProcDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundProcDecl(TypeBoundProcDecl &&) = default; TypeBoundProcDecl &operator=(TypeBoundProcDecl &&) = default; TypeBoundProcDecl(const TypeBoundProcDecl &) = delete; TypeBoundProcDecl &operator=(const TypeBoundProcDecl &) = delete; TypeBoundProcDecl() = delete;
  std::tuple<Name, std::optional<Name>> t;
};






struct TypeBoundProcedureStmt {
  template <typename A, typename = common::NoLvalue<A>> TypeBoundProcedureStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeBoundProcedureStmt(TypeBoundProcedureStmt &&) = default; TypeBoundProcedureStmt &operator=(TypeBoundProcedureStmt &&) = default; TypeBoundProcedureStmt(const TypeBoundProcedureStmt &) = delete; TypeBoundProcedureStmt &operator=(const TypeBoundProcedureStmt &) = delete; TypeBoundProcedureStmt() = delete;
  struct WithoutInterface {
    WithoutInterface(WithoutInterface &&) = default; WithoutInterface &operator=(WithoutInterface &&) = default; WithoutInterface(const WithoutInterface &) = delete; WithoutInterface &operator=(const WithoutInterface &) = delete; WithoutInterface() = delete;
    WithoutInterface(
        std::list<BindAttr> &&as, std::list<TypeBoundProcDecl> &&ds)
        : attributes(std::move(as)), declarations(std::move(ds)) {}
    std::list<BindAttr> attributes;
    std::list<TypeBoundProcDecl> declarations;
  };
  struct WithInterface {
    WithInterface(WithInterface &&) = default; WithInterface &operator=(WithInterface &&) = default; WithInterface(const WithInterface &) = delete; WithInterface &operator=(const WithInterface &) = delete; WithInterface() = delete;
    WithInterface(Name &&n, std::list<BindAttr> &&as, std::list<Name> &&bs)
        : interfaceName(std::move(n)), attributes(std::move(as)),
          bindingNames(std::move(bs)) {}
    Name interfaceName;
    std::list<BindAttr> attributes;
    std::list<Name> bindingNames;
  };
  std::variant<WithoutInterface, WithInterface> u;
};



struct TypeBoundGenericStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundGenericStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundGenericStmt(TypeBoundGenericStmt &&) = default; TypeBoundGenericStmt &operator=(TypeBoundGenericStmt &&) = default; TypeBoundGenericStmt(const TypeBoundGenericStmt &) = delete; TypeBoundGenericStmt &operator=(const TypeBoundGenericStmt &) = delete; TypeBoundGenericStmt() = delete;
  std::tuple<std::optional<AccessSpec>, common::Indirection<GenericSpec>,
      std::list<Name>>
      t;
};


struct FinalProcedureStmt { FinalProcedureStmt(FinalProcedureStmt &&) = default; FinalProcedureStmt &operator=(FinalProcedureStmt &&) = default; FinalProcedureStmt(const FinalProcedureStmt &) = delete; FinalProcedureStmt &operator=(const FinalProcedureStmt &) = delete; FinalProcedureStmt() = delete; FinalProcedureStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };




struct TypeBoundProcBinding {
  template <typename A, typename = common::NoLvalue<A>> TypeBoundProcBinding(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeBoundProcBinding(TypeBoundProcBinding &&) = default; TypeBoundProcBinding &operator=(TypeBoundProcBinding &&) = default; TypeBoundProcBinding(const TypeBoundProcBinding &) = delete; TypeBoundProcBinding &operator=(const TypeBoundProcBinding &) = delete; TypeBoundProcBinding() = delete;
  std::variant<TypeBoundProcedureStmt, TypeBoundGenericStmt, FinalProcedureStmt,
      ErrorRecovery>
      u;
};



struct TypeBoundProcedurePart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundProcedurePart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundProcedurePart(TypeBoundProcedurePart &&) = default; TypeBoundProcedurePart &operator=(TypeBoundProcedurePart &&) = default; TypeBoundProcedurePart(const TypeBoundProcedurePart &) = delete; TypeBoundProcedurePart &operator=(const TypeBoundProcedurePart &) = delete; TypeBoundProcedurePart() = delete;
  std::tuple<Statement<ContainsStmt>, std::optional<Statement<PrivateStmt>>,
      std::list<Statement<TypeBoundProcBinding>>>
      t;
};


struct EndTypeStmt { EndTypeStmt(EndTypeStmt &&) = default; EndTypeStmt &operator=(EndTypeStmt &&) = default; EndTypeStmt(const EndTypeStmt &) = delete; EndTypeStmt &operator=(const EndTypeStmt &) = delete; EndTypeStmt() = delete; EndTypeStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };





struct DerivedTypeDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeDef(DerivedTypeDef &&) = default; DerivedTypeDef &operator=(DerivedTypeDef &&) = default; DerivedTypeDef(const DerivedTypeDef &) = delete; DerivedTypeDef &operator=(const DerivedTypeDef &) = delete; DerivedTypeDef() = delete;
  std::tuple<Statement<DerivedTypeStmt>, std::list<Statement<TypeParamDefStmt>>,
      std::list<Statement<PrivateOrSequence>>,
      std::list<Statement<ComponentDefStmt>>,
      std::optional<TypeBoundProcedurePart>, Statement<EndTypeStmt>>
      t;
};




struct ComponentDataSource { ComponentDataSource(ComponentDataSource &&) = default; ComponentDataSource &operator=(ComponentDataSource &&) = default; ComponentDataSource(const ComponentDataSource &) = delete; ComponentDataSource &operator=(const ComponentDataSource &) = delete; ComponentDataSource() = delete; ComponentDataSource(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };


struct ComponentSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComponentSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComponentSpec(ComponentSpec &&) = default; ComponentSpec &operator=(ComponentSpec &&) = default; ComponentSpec(const ComponentSpec &) = delete; ComponentSpec &operator=(const ComponentSpec &) = delete; ComponentSpec() = delete;
  std::tuple<std::optional<Keyword>, ComponentDataSource> t;
};


struct StructureConstructor {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureConstructor(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureConstructor(StructureConstructor &&) = default; StructureConstructor &operator=(StructureConstructor &&) = default; StructureConstructor(const StructureConstructor &) = delete; StructureConstructor &operator=(const StructureConstructor &) = delete; StructureConstructor() = delete;
  std::tuple<DerivedTypeSpec, std::list<ComponentSpec>> t;
};


struct EnumDefStmt { EnumDefStmt() {} EnumDefStmt(const EnumDefStmt &) {} EnumDefStmt(EnumDefStmt &&) {} EnumDefStmt &operator=(const EnumDefStmt &) { return *this; }; EnumDefStmt &operator=(EnumDefStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct Enumerator {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Enumerator(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Enumerator(Enumerator &&) = default; Enumerator &operator=(Enumerator &&) = default; Enumerator(const Enumerator &) = delete; Enumerator &operator=(const Enumerator &) = delete; Enumerator() = delete;
  std::tuple<NamedConstant, std::optional<ScalarIntConstantExpr>> t;
};


struct EnumeratorDefStmt { EnumeratorDefStmt(EnumeratorDefStmt &&) = default; EnumeratorDefStmt &operator=(EnumeratorDefStmt &&) = default; EnumeratorDefStmt(const EnumeratorDefStmt &) = delete; EnumeratorDefStmt &operator=(const EnumeratorDefStmt &) = delete; EnumeratorDefStmt() = delete; EnumeratorDefStmt(std::list<Enumerator> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Enumerator> v; };


struct EndEnumStmt { EndEnumStmt() {} EndEnumStmt(const EndEnumStmt &) {} EndEnumStmt(EndEnumStmt &&) {} EndEnumStmt &operator=(const EndEnumStmt &) { return *this; }; EndEnumStmt &operator=(EndEnumStmt &&) { return *this; }; using EmptyTrait = std::true_type; };




struct EnumDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EnumDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EnumDef(EnumDef &&) = default; EnumDef &operator=(EnumDef &&) = default; EnumDef(const EnumDef &) = delete; EnumDef &operator=(const EnumDef &) = delete; EnumDef() = delete;
  std::tuple<Statement<EnumDefStmt>, std::list<Statement<EnumeratorDefStmt>>,
      Statement<EndEnumStmt>>
      t;
};


struct AcValue {
  struct Triplet {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Triplet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Triplet(Triplet &&) = default; Triplet &operator=(Triplet &&) = default; Triplet(const Triplet &) = delete; Triplet &operator=(const Triplet &) = delete; Triplet() = delete;
    std::tuple<ScalarIntExpr, ScalarIntExpr, std::optional<ScalarIntExpr>> t;
  };
  template <typename A, typename = common::NoLvalue<A>> AcValue(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AcValue(AcValue &&) = default; AcValue &operator=(AcValue &&) = default; AcValue(const AcValue &) = delete; AcValue &operator=(const AcValue &) = delete; AcValue() = delete;
  std::variant<Triplet, common::Indirection<Expr>,
      common::Indirection<AcImpliedDo>>
      u;
};


struct AcSpec {
  AcSpec(AcSpec &&) = default; AcSpec &operator=(AcSpec &&) = default; AcSpec(const AcSpec &) = delete; AcSpec &operator=(const AcSpec &) = delete; AcSpec() = delete;
  AcSpec(std::optional<TypeSpec> &&ts, std::list<AcValue> &&xs)
      : type(std::move(ts)), values(std::move(xs)) {}
  explicit AcSpec(TypeSpec &&ts) : type{std::move(ts)} {}
  std::optional<TypeSpec> type;
  std::list<AcValue> values;
};


struct ArrayConstructor { ArrayConstructor(ArrayConstructor &&) = default; ArrayConstructor &operator=(ArrayConstructor &&) = default; ArrayConstructor(const ArrayConstructor &) = delete; ArrayConstructor &operator=(const ArrayConstructor &) = delete; ArrayConstructor() = delete; ArrayConstructor(AcSpec &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AcSpec v; };


using DoVariable = Scalar<Integer<Name>>;

template <typename VAR, typename BOUND> struct LoopBounds {
  LoopBounds(LoopBounds &&that) = default;
  LoopBounds(
      VAR &&name, BOUND &&lower, BOUND &&upper, std::optional<BOUND> &&step)
      : name{std::move(name)}, lower{std::move(lower)}, upper{std::move(upper)},
        step{std::move(step)} {}
  LoopBounds &operator=(LoopBounds &&) = default;
  VAR name;
  BOUND lower, upper;
  std::optional<BOUND> step;
};

using ScalarName = Scalar<Name>;
using ScalarExpr = Scalar<common::Indirection<Expr>>;





struct AcImpliedDoControl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AcImpliedDoControl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AcImpliedDoControl(AcImpliedDoControl &&) = default; AcImpliedDoControl &operator=(AcImpliedDoControl &&) = default; AcImpliedDoControl(const AcImpliedDoControl &) = delete; AcImpliedDoControl &operator=(const AcImpliedDoControl &) = delete; AcImpliedDoControl() = delete;
  using Bounds = LoopBounds<DoVariable, ScalarIntExpr>;
  std::tuple<std::optional<IntegerTypeSpec>, Bounds> t;
};


struct AcImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AcImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AcImpliedDo(AcImpliedDo &&) = default; AcImpliedDo &operator=(AcImpliedDo &&) = default; AcImpliedDo(const AcImpliedDo &) = delete; AcImpliedDo &operator=(const AcImpliedDo &) = delete; AcImpliedDo() = delete;
  std::tuple<std::list<AcValue>, AcImpliedDoControl> t;
};





struct LanguageBindingSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LanguageBindingSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LanguageBindingSpec(LanguageBindingSpec &&) = default; LanguageBindingSpec &operator=(LanguageBindingSpec &&) = default; LanguageBindingSpec(const LanguageBindingSpec &) = delete; LanguageBindingSpec &operator=(const LanguageBindingSpec &) = delete; LanguageBindingSpec() = delete;
  std::tuple<std::optional<ScalarDefaultCharConstantExpr>, bool> t;
};


struct NamedConstantDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NamedConstantDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NamedConstantDef(NamedConstantDef &&) = default; NamedConstantDef &operator=(NamedConstantDef &&) = default; NamedConstantDef(const NamedConstantDef &) = delete; NamedConstantDef &operator=(const NamedConstantDef &) = delete; NamedConstantDef() = delete;
  std::tuple<NamedConstant, ConstantExpr> t;
};


struct ParameterStmt { ParameterStmt(ParameterStmt &&) = default; ParameterStmt &operator=(ParameterStmt &&) = default; ParameterStmt(const ParameterStmt &) = delete; ParameterStmt &operator=(const ParameterStmt &) = delete; ParameterStmt() = delete; ParameterStmt(std::list<NamedConstantDef> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<NamedConstantDef> v; };


struct AssumedShapeSpec { AssumedShapeSpec(AssumedShapeSpec &&) = default; AssumedShapeSpec &operator=(AssumedShapeSpec &&) = default; AssumedShapeSpec(const AssumedShapeSpec &) = delete; AssumedShapeSpec &operator=(const AssumedShapeSpec &) = delete; AssumedShapeSpec() = delete; AssumedShapeSpec(std::optional<SpecificationExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<SpecificationExpr> v; };


struct AssumedImpliedSpec { AssumedImpliedSpec(AssumedImpliedSpec &&) = default; AssumedImpliedSpec &operator=(AssumedImpliedSpec &&) = default; AssumedImpliedSpec(const AssumedImpliedSpec &) = delete; AssumedImpliedSpec &operator=(const AssumedImpliedSpec &) = delete; AssumedImpliedSpec() = delete; AssumedImpliedSpec(std::optional<SpecificationExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<SpecificationExpr> v; };


struct AssumedSizeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssumedSizeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssumedSizeSpec(AssumedSizeSpec &&) = default; AssumedSizeSpec &operator=(AssumedSizeSpec &&) = default; AssumedSizeSpec(const AssumedSizeSpec &) = delete; AssumedSizeSpec &operator=(const AssumedSizeSpec &) = delete; AssumedSizeSpec() = delete;
  std::tuple<std::list<ExplicitShapeSpec>, AssumedImpliedSpec> t;
};





struct ImpliedShapeSpec { ImpliedShapeSpec(ImpliedShapeSpec &&) = default; ImpliedShapeSpec &operator=(ImpliedShapeSpec &&) = default; ImpliedShapeSpec(const ImpliedShapeSpec &) = delete; ImpliedShapeSpec &operator=(const ImpliedShapeSpec &) = delete; ImpliedShapeSpec() = delete; ImpliedShapeSpec(std::list<AssumedImpliedSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AssumedImpliedSpec> v; };


struct AssumedRankSpec { AssumedRankSpec() {} AssumedRankSpec(const AssumedRankSpec &) {} AssumedRankSpec(AssumedRankSpec &&) {} AssumedRankSpec &operator=(const AssumedRankSpec &) { return *this; }; AssumedRankSpec &operator=(AssumedRankSpec &&) { return *this; }; using EmptyTrait = std::true_type; };





struct ArraySpec {
  template <typename A, typename = common::NoLvalue<A>> ArraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ArraySpec(ArraySpec &&) = default; ArraySpec &operator=(ArraySpec &&) = default; ArraySpec(const ArraySpec &) = delete; ArraySpec &operator=(const ArraySpec &) = delete; ArraySpec() = delete;
  std::variant<std::list<ExplicitShapeSpec>, std::list<AssumedShapeSpec>,
      DeferredShapeSpecList, AssumedSizeSpec, ImpliedShapeSpec, AssumedRankSpec>
      u;
};


struct IntentSpec {
  enum class Intent { In, Out, InOut }; [[maybe_unused]] static constexpr std::size_t Intent_enumSize{ ::Fortran::common::CountEnumNames("In, Out, InOut")}; [[maybe_unused]] static inline std::size_t EnumToInt(Intent e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Intent e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Intent_enumSize>("In, Out, InOut")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachIntent(std::function<void(Intent)> f) { for (std::size_t i{0}; i < Intent_enumSize; ++i) { f(static_cast<Intent>(i)); } }
  IntentSpec(IntentSpec &&) = default; IntentSpec &operator=(IntentSpec &&) = default; IntentSpec(const IntentSpec &) = delete; IntentSpec &operator=(const IntentSpec &) = delete; IntentSpec() = delete; IntentSpec(Intent &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Intent v;
};
# 1378 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct Asynchronous { Asynchronous() {} Asynchronous(const Asynchronous &) {} Asynchronous(Asynchronous &&) {} Asynchronous &operator=(const Asynchronous &) { return *this; }; Asynchronous &operator=(Asynchronous &&) { return *this; }; using EmptyTrait = std::true_type; };
struct External { External() {} External(const External &) {} External(External &&) {} External &operator=(const External &) { return *this; }; External &operator=(External &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Intrinsic { Intrinsic() {} Intrinsic(const Intrinsic &) {} Intrinsic(Intrinsic &&) {} Intrinsic &operator=(const Intrinsic &) { return *this; }; Intrinsic &operator=(Intrinsic &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Optional { Optional() {} Optional(const Optional &) {} Optional(Optional &&) {} Optional &operator=(const Optional &) { return *this; }; Optional &operator=(Optional &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Parameter { Parameter() {} Parameter(const Parameter &) {} Parameter(Parameter &&) {} Parameter &operator=(const Parameter &) { return *this; }; Parameter &operator=(Parameter &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Protected { Protected() {} Protected(const Protected &) {} Protected(Protected &&) {} Protected &operator=(const Protected &) { return *this; }; Protected &operator=(Protected &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Save { Save() {} Save(const Save &) {} Save(Save &&) {} Save &operator=(const Save &) { return *this; }; Save &operator=(Save &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Target { Target() {} Target(const Target &) {} Target(Target &&) {} Target &operator=(const Target &) { return *this; }; Target &operator=(Target &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Value { Value() {} Value(const Value &) {} Value(Value &&) {} Value &operator=(const Value &) { return *this; }; Value &operator=(Value &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Volatile { Volatile() {} Volatile(const Volatile &) {} Volatile(Volatile &&) {} Volatile &operator=(const Volatile &) { return *this; }; Volatile &operator=(Volatile &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AttrSpec {
  template <typename A, typename = common::NoLvalue<A>> AttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AttrSpec(AttrSpec &&) = default; AttrSpec &operator=(AttrSpec &&) = default; AttrSpec(const AttrSpec &) = delete; AttrSpec &operator=(const AttrSpec &) = delete; AttrSpec() = delete;
  std::variant<AccessSpec, Allocatable, Asynchronous, CoarraySpec, Contiguous,
      ArraySpec, External, IntentSpec, Intrinsic, LanguageBindingSpec, Optional,
      Parameter, Pointer, Protected, Save, Target, Value, Volatile,
      common::CUDADataAttr>
      u;
};







struct EntityDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EntityDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EntityDecl(EntityDecl &&) = default; EntityDecl &operator=(EntityDecl &&) = default; EntityDecl(const EntityDecl &) = delete; EntityDecl &operator=(const EntityDecl &) = delete; EntityDecl() = delete;
  EntityDecl(ObjectName &&name, CharLength &&length,
      std::optional<ArraySpec> &&aSpec, std::optional<CoarraySpec> &&coaSpec,
      std::optional<Initialization> &&init)
      : t{std::move(name), std::move(aSpec), std::move(coaSpec),
            std::move(length), std::move(init)} {}
  std::tuple<ObjectName, std::optional<ArraySpec>, std::optional<CoarraySpec>,
      std::optional<CharLength>, std::optional<Initialization>>
      t;
};



struct TypeDeclarationStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeDeclarationStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeDeclarationStmt(TypeDeclarationStmt &&) = default; TypeDeclarationStmt &operator=(TypeDeclarationStmt &&) = default; TypeDeclarationStmt(const TypeDeclarationStmt &) = delete; TypeDeclarationStmt &operator=(const TypeDeclarationStmt &) = delete; TypeDeclarationStmt() = delete;
  std::tuple<DeclarationTypeSpec, std::list<AttrSpec>, std::list<EntityDecl>> t;
};



struct AccessId { AccessId(AccessId &&) = default; AccessId &operator=(AccessId &&) = default; AccessId(const AccessId &) = delete; AccessId &operator=(const AccessId &) = delete; AccessId() = delete; AccessId(common::Indirection<GenericSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<GenericSpec> v; };


struct AccessStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccessStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccessStmt(AccessStmt &&) = default; AccessStmt &operator=(AccessStmt &&) = default; AccessStmt(const AccessStmt &) = delete; AccessStmt &operator=(const AccessStmt &) = delete; AccessStmt() = delete;
  std::tuple<AccessSpec, std::list<AccessId>> t;
};





struct ObjectDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ObjectDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ObjectDecl(ObjectDecl &&) = default; ObjectDecl &operator=(ObjectDecl &&) = default; ObjectDecl(const ObjectDecl &) = delete; ObjectDecl &operator=(const ObjectDecl &) = delete; ObjectDecl() = delete;
  std::tuple<ObjectName, std::optional<ArraySpec>, std::optional<CoarraySpec>>
      t;
};


struct AllocatableStmt { AllocatableStmt(AllocatableStmt &&) = default; AllocatableStmt &operator=(AllocatableStmt &&) = default; AllocatableStmt(const AllocatableStmt &) = delete; AllocatableStmt &operator=(const AllocatableStmt &) = delete; AllocatableStmt() = delete; AllocatableStmt(std::list<ObjectDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectDecl> v; };


struct AsynchronousStmt { AsynchronousStmt(AsynchronousStmt &&) = default; AsynchronousStmt &operator=(AsynchronousStmt &&) = default; AsynchronousStmt(const AsynchronousStmt &) = delete; AsynchronousStmt &operator=(const AsynchronousStmt &) = delete; AsynchronousStmt() = delete; AsynchronousStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };


struct BindEntity {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BindEntity(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BindEntity(BindEntity &&) = default; BindEntity &operator=(BindEntity &&) = default; BindEntity(const BindEntity &) = delete; BindEntity &operator=(const BindEntity &) = delete; BindEntity() = delete;
  enum class Kind { Object, Common }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Object, Common")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Object, Common")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  std::tuple<Kind, Name> t;
};


struct BindStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BindStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BindStmt(BindStmt &&) = default; BindStmt &operator=(BindStmt &&) = default; BindStmt(const BindStmt &) = delete; BindStmt &operator=(const BindStmt &) = delete; BindStmt() = delete;
  std::tuple<LanguageBindingSpec, std::list<BindEntity>> t;
};


struct CodimensionDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CodimensionDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CodimensionDecl(CodimensionDecl &&) = default; CodimensionDecl &operator=(CodimensionDecl &&) = default; CodimensionDecl(const CodimensionDecl &) = delete; CodimensionDecl &operator=(const CodimensionDecl &) = delete; CodimensionDecl() = delete;
  std::tuple<Name, CoarraySpec> t;
};


struct CodimensionStmt { CodimensionStmt(CodimensionStmt &&) = default; CodimensionStmt &operator=(CodimensionStmt &&) = default; CodimensionStmt(const CodimensionStmt &) = delete; CodimensionStmt &operator=(const CodimensionStmt &) = delete; CodimensionStmt() = delete; CodimensionStmt(std::list<CodimensionDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<CodimensionDecl> v; };


struct ContiguousStmt { ContiguousStmt(ContiguousStmt &&) = default; ContiguousStmt &operator=(ContiguousStmt &&) = default; ContiguousStmt(const ContiguousStmt &) = delete; ContiguousStmt &operator=(const ContiguousStmt &) = delete; ContiguousStmt() = delete; ContiguousStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };



using ConstantSubobject = Constant<common::Indirection<Designator>>;


using TypedExpr = common::ForwardOwningPointer<evaluate::GenericExprWrapper>;
# 1487 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct DataStmtConstant {
  template <typename A, typename = common::NoLvalue<A>> DataStmtConstant(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtConstant(DataStmtConstant &&) = default; DataStmtConstant &operator=(DataStmtConstant &&) = default; DataStmtConstant(const DataStmtConstant &) = delete; DataStmtConstant &operator=(const DataStmtConstant &) = delete; DataStmtConstant() = delete;
  CharBlock source;
  mutable TypedExpr typedExpr;
  std::variant<common::Indirection<CharLiteralConstantSubstring>,
      LiteralConstant, SignedIntLiteralConstant, SignedRealLiteralConstant,
      SignedComplexLiteralConstant, NullInit, common::Indirection<Designator>,
      StructureConstructor, UnsignedLiteralConstant>
      u;
};





struct DataStmtRepeat {
  template <typename A, typename = common::NoLvalue<A>> DataStmtRepeat(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtRepeat(DataStmtRepeat &&) = default; DataStmtRepeat &operator=(DataStmtRepeat &&) = default; DataStmtRepeat(const DataStmtRepeat &) = delete; DataStmtRepeat &operator=(const DataStmtRepeat &) = delete; DataStmtRepeat() = delete;
  std::variant<IntLiteralConstant, Scalar<Integer<ConstantSubobject>>> u;
};


struct DataStmtValue {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataStmtValue(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataStmtValue(DataStmtValue &&) = default; DataStmtValue &operator=(DataStmtValue &&) = default; DataStmtValue(const DataStmtValue &) = delete; DataStmtValue &operator=(const DataStmtValue &) = delete; DataStmtValue() = delete;
  mutable std::int64_t repetitions{1};
  std::tuple<std::optional<DataStmtRepeat>, DataStmtConstant> t;
};



struct DataIDoObject {
  template <typename A, typename = common::NoLvalue<A>> DataIDoObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataIDoObject(DataIDoObject &&) = default; DataIDoObject &operator=(DataIDoObject &&) = default; DataIDoObject(const DataIDoObject &) = delete; DataIDoObject &operator=(const DataIDoObject &) = delete; DataIDoObject() = delete;
  std::variant<Scalar<common::Indirection<Designator>>,
      common::Indirection<DataImpliedDo>>
      u;
};






struct DataImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataImpliedDo(DataImpliedDo &&) = default; DataImpliedDo &operator=(DataImpliedDo &&) = default; DataImpliedDo(const DataImpliedDo &) = delete; DataImpliedDo &operator=(const DataImpliedDo &) = delete; DataImpliedDo() = delete;
  using Bounds = LoopBounds<DoVariable, ScalarIntConstantExpr>;
  std::tuple<std::list<DataIDoObject>, std::optional<IntegerTypeSpec>, Bounds>
      t;
};


struct DataStmtObject {
  template <typename A, typename = common::NoLvalue<A>> DataStmtObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtObject(DataStmtObject &&) = default; DataStmtObject &operator=(DataStmtObject &&) = default; DataStmtObject(const DataStmtObject &) = delete; DataStmtObject &operator=(const DataStmtObject &) = delete; DataStmtObject() = delete;
  std::variant<common::Indirection<Variable>, DataImpliedDo> u;
};


struct DataStmtSet {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataStmtSet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataStmtSet(DataStmtSet &&) = default; DataStmtSet &operator=(DataStmtSet &&) = default; DataStmtSet(const DataStmtSet &) = delete; DataStmtSet &operator=(const DataStmtSet &) = delete; DataStmtSet() = delete;
  std::tuple<std::list<DataStmtObject>, std::list<DataStmtValue>> t;
};


struct DataStmt { DataStmt(DataStmt &&) = default; DataStmt &operator=(DataStmt &&) = default; DataStmt(const DataStmt &) = delete; DataStmt &operator=(const DataStmt &) = delete; DataStmt() = delete; DataStmt(std::list<DataStmtSet> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<DataStmtSet> v; };




struct DimensionStmt {
  struct Declaration {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Declaration(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Declaration(Declaration &&) = default; Declaration &operator=(Declaration &&) = default; Declaration(const Declaration &) = delete; Declaration &operator=(const Declaration &) = delete; Declaration() = delete;
    std::tuple<Name, ArraySpec> t;
  };
  DimensionStmt(DimensionStmt &&) = default; DimensionStmt &operator=(DimensionStmt &&) = default; DimensionStmt(const DimensionStmt &) = delete; DimensionStmt &operator=(const DimensionStmt &) = delete; DimensionStmt() = delete; DimensionStmt(std::list<Declaration> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Declaration> v;
};


struct IntentStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IntentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntentStmt(IntentStmt &&) = default; IntentStmt &operator=(IntentStmt &&) = default; IntentStmt(const IntentStmt &) = delete; IntentStmt &operator=(const IntentStmt &) = delete; IntentStmt() = delete;
  std::tuple<IntentSpec, std::list<Name>> t;
};


struct OptionalStmt { OptionalStmt(OptionalStmt &&) = default; OptionalStmt &operator=(OptionalStmt &&) = default; OptionalStmt(const OptionalStmt &) = delete; OptionalStmt &operator=(const OptionalStmt &) = delete; OptionalStmt() = delete; OptionalStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct PointerDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PointerDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PointerDecl(PointerDecl &&) = default; PointerDecl &operator=(PointerDecl &&) = default; PointerDecl(const PointerDecl &) = delete; PointerDecl &operator=(const PointerDecl &) = delete; PointerDecl() = delete;
  std::tuple<Name, std::optional<DeferredShapeSpecList>> t;
};


struct PointerStmt { PointerStmt(PointerStmt &&) = default; PointerStmt &operator=(PointerStmt &&) = default; PointerStmt(const PointerStmt &) = delete; PointerStmt &operator=(const PointerStmt &) = delete; PointerStmt() = delete; PointerStmt(std::list<PointerDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PointerDecl> v; };


struct ProtectedStmt { ProtectedStmt(ProtectedStmt &&) = default; ProtectedStmt &operator=(ProtectedStmt &&) = default; ProtectedStmt(const ProtectedStmt &) = delete; ProtectedStmt &operator=(const ProtectedStmt &) = delete; ProtectedStmt() = delete; ProtectedStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct SavedEntity {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SavedEntity(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SavedEntity(SavedEntity &&) = default; SavedEntity &operator=(SavedEntity &&) = default; SavedEntity(const SavedEntity &) = delete; SavedEntity &operator=(const SavedEntity &) = delete; SavedEntity() = delete;
  enum class Kind { Entity, Common }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Entity, Common")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Entity, Common")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  std::tuple<Kind, Name> t;
};


struct SaveStmt { SaveStmt(SaveStmt &&) = default; SaveStmt &operator=(SaveStmt &&) = default; SaveStmt(const SaveStmt &) = delete; SaveStmt &operator=(const SaveStmt &) = delete; SaveStmt() = delete; SaveStmt(std::list<SavedEntity> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<SavedEntity> v; };


struct TargetStmt { TargetStmt(TargetStmt &&) = default; TargetStmt &operator=(TargetStmt &&) = default; TargetStmt(const TargetStmt &) = delete; TargetStmt &operator=(const TargetStmt &) = delete; TargetStmt() = delete; TargetStmt(std::list<ObjectDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectDecl> v; };


struct ValueStmt { ValueStmt(ValueStmt &&) = default; ValueStmt &operator=(ValueStmt &&) = default; ValueStmt(const ValueStmt &) = delete; ValueStmt &operator=(const ValueStmt &) = delete; ValueStmt() = delete; ValueStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };


struct VolatileStmt { VolatileStmt(VolatileStmt &&) = default; VolatileStmt &operator=(VolatileStmt &&) = default; VolatileStmt(const VolatileStmt &) = delete; VolatileStmt &operator=(const VolatileStmt &) = delete; VolatileStmt() = delete; VolatileStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };


struct LetterSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LetterSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LetterSpec(LetterSpec &&) = default; LetterSpec &operator=(LetterSpec &&) = default; LetterSpec(const LetterSpec &) = delete; LetterSpec &operator=(const LetterSpec &) = delete; LetterSpec() = delete;
  std::tuple<Location, std::optional<Location>> t;
};


struct ImplicitSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ImplicitSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ImplicitSpec(ImplicitSpec &&) = default; ImplicitSpec &operator=(ImplicitSpec &&) = default; ImplicitSpec(const ImplicitSpec &) = delete; ImplicitSpec &operator=(const ImplicitSpec &) = delete; ImplicitSpec() = delete;
  std::tuple<DeclarationTypeSpec, std::list<LetterSpec>> t;
};





struct ImplicitStmt {
  template <typename A, typename = common::NoLvalue<A>> ImplicitStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImplicitStmt(ImplicitStmt &&) = default; ImplicitStmt &operator=(ImplicitStmt &&) = default; ImplicitStmt(const ImplicitStmt &) = delete; ImplicitStmt &operator=(const ImplicitStmt &) = delete; ImplicitStmt() = delete;
  enum class ImplicitNoneNameSpec { External, Type }; [[maybe_unused]] static constexpr std::size_t ImplicitNoneNameSpec_enumSize{ ::Fortran::common::CountEnumNames("External, Type")}; [[maybe_unused]] static inline std::size_t EnumToInt(ImplicitNoneNameSpec e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(ImplicitNoneNameSpec e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImplicitNoneNameSpec_enumSize>("External, Type")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachImplicitNoneNameSpec(std::function<void(ImplicitNoneNameSpec)> f) { for (std::size_t i{0}; i < ImplicitNoneNameSpec_enumSize; ++i) { f(static_cast<ImplicitNoneNameSpec>(i)); } }
  std::variant<std::list<ImplicitSpec>, std::list<ImplicitNoneNameSpec>> u;
};


struct CommonBlockObject {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CommonBlockObject(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CommonBlockObject(CommonBlockObject &&) = default; CommonBlockObject &operator=(CommonBlockObject &&) = default; CommonBlockObject(const CommonBlockObject &) = delete; CommonBlockObject &operator=(const CommonBlockObject &) = delete; CommonBlockObject() = delete;
  std::tuple<Name, std::optional<ArraySpec>> t;
};




struct CommonStmt {
  struct Block {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Block(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Block(Block &&) = default; Block &operator=(Block &&) = default; Block(const Block &) = delete; Block &operator=(const Block &) = delete; Block() = delete;
    std::tuple<std::optional<Name>, std::list<CommonBlockObject>> t;
  };
  CommonStmt(CommonStmt &&) = default; CommonStmt &operator=(CommonStmt &&) = default; CommonStmt(const CommonStmt &) = delete; CommonStmt &operator=(const CommonStmt &) = delete; CommonStmt() = delete;
  CommonStmt(std::optional<Name> &&, std::list<CommonBlockObject> &&,
      std::list<Block> &&);
  std::list<Block> blocks;
};


struct EquivalenceObject { EquivalenceObject(EquivalenceObject &&) = default; EquivalenceObject &operator=(EquivalenceObject &&) = default; EquivalenceObject(const EquivalenceObject &) = delete; EquivalenceObject &operator=(const EquivalenceObject &) = delete; EquivalenceObject() = delete; EquivalenceObject(common::Indirection<Designator> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Designator> v; };



struct EquivalenceStmt { EquivalenceStmt(EquivalenceStmt &&) = default; EquivalenceStmt &operator=(EquivalenceStmt &&) = default; EquivalenceStmt(const EquivalenceStmt &) = delete; EquivalenceStmt &operator=(const EquivalenceStmt &) = delete; EquivalenceStmt() = delete; EquivalenceStmt(std::list<std::list<EquivalenceObject>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<std::list<EquivalenceObject>> v; };


struct SubstringRange {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubstringRange(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubstringRange(SubstringRange &&) = default; SubstringRange &operator=(SubstringRange &&) = default; SubstringRange(const SubstringRange &) = delete; SubstringRange &operator=(const SubstringRange &) = delete; SubstringRange() = delete;
  std::tuple<std::optional<ScalarIntExpr>, std::optional<ScalarIntExpr>> t;
};


using Subscript = ScalarIntExpr;


struct SubscriptTriplet {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubscriptTriplet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubscriptTriplet(SubscriptTriplet &&) = default; SubscriptTriplet &operator=(SubscriptTriplet &&) = default; SubscriptTriplet(const SubscriptTriplet &) = delete; SubscriptTriplet &operator=(const SubscriptTriplet &) = delete; SubscriptTriplet() = delete;
  std::tuple<std::optional<Subscript>, std::optional<Subscript>,
      std::optional<Subscript>>
      t;
};



struct SectionSubscript {
  template <typename A, typename = common::NoLvalue<A>> SectionSubscript(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; SectionSubscript(SectionSubscript &&) = default; SectionSubscript &operator=(SectionSubscript &&) = default; SectionSubscript(const SectionSubscript &) = delete; SectionSubscript &operator=(const SectionSubscript &) = delete; SectionSubscript() = delete;
  std::variant<IntExpr, SubscriptTriplet> u;
};


using Cosubscript = ScalarIntExpr;


struct TeamValue { TeamValue(TeamValue &&) = default; TeamValue &operator=(TeamValue &&) = default; TeamValue(const TeamValue &) = delete; TeamValue &operator=(const TeamValue &) = delete; TeamValue() = delete; TeamValue(Scalar<common::Indirection<Expr>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<common::Indirection<Expr>> v; };




struct ImageSelectorSpec {
  struct Stat { Stat(Stat &&) = default; Stat &operator=(Stat &&) = default; Stat(const Stat &) = delete; Stat &operator=(const Stat &) = delete; Stat() = delete; Stat(Scalar<Integer<common::Indirection<Variable>>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<Integer<common::Indirection<Variable>>> v; };
  struct Team_Number { Team_Number(Team_Number &&) = default; Team_Number &operator=(Team_Number &&) = default; Team_Number(const Team_Number &) = delete; Team_Number &operator=(const Team_Number &) = delete; Team_Number() = delete; Team_Number(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  template <typename A, typename = common::NoLvalue<A>> ImageSelectorSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImageSelectorSpec(ImageSelectorSpec &&) = default; ImageSelectorSpec &operator=(ImageSelectorSpec &&) = default; ImageSelectorSpec(const ImageSelectorSpec &) = delete; ImageSelectorSpec &operator=(const ImageSelectorSpec &) = delete; ImageSelectorSpec() = delete;
  std::variant<Stat, TeamValue, Team_Number> u;
};



struct ImageSelector {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ImageSelector(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ImageSelector(ImageSelector &&) = default; ImageSelector &operator=(ImageSelector &&) = default; ImageSelector(const ImageSelector &) = delete; ImageSelector &operator=(const ImageSelector &) = delete; ImageSelector() = delete;
  std::tuple<std::list<Cosubscript>, std::list<ImageSelectorSpec>> t;
};


struct Expr {
  template <typename A, typename = common::NoLvalue<A>> Expr(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Expr(Expr &&) = default; Expr &operator=(Expr &&) = default; Expr(const Expr &) = delete; Expr &operator=(const Expr &) = delete; Expr() = delete;

  struct IntrinsicUnary { IntrinsicUnary(IntrinsicUnary &&) = default; IntrinsicUnary &operator=(IntrinsicUnary &&) = default; IntrinsicUnary(const IntrinsicUnary &) = delete; IntrinsicUnary &operator=(const IntrinsicUnary &) = delete; IntrinsicUnary() = delete; IntrinsicUnary(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Parentheses : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct UnaryPlus : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct Negate : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct NOT : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };

  struct PercentLoc { PercentLoc(PercentLoc &&) = default; PercentLoc &operator=(PercentLoc &&) = default; PercentLoc(const PercentLoc &) = delete; PercentLoc &operator=(const PercentLoc &) = delete; PercentLoc() = delete; PercentLoc(common::Indirection<Variable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Variable> v; };

  struct DefinedUnary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedUnary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedUnary(DefinedUnary &&) = default; DefinedUnary &operator=(DefinedUnary &&) = default; DefinedUnary(const DefinedUnary &) = delete; DefinedUnary &operator=(const DefinedUnary &) = delete; DefinedUnary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>> t;
  };

  struct IntrinsicBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntrinsicBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntrinsicBinary(IntrinsicBinary &&) = default; IntrinsicBinary &operator=(IntrinsicBinary &&) = default; IntrinsicBinary(const IntrinsicBinary &) = delete; IntrinsicBinary &operator=(const IntrinsicBinary &) = delete; IntrinsicBinary() = delete;
    std::tuple<common::Indirection<Expr>, common::Indirection<Expr>> t;
  };
  struct Power : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Multiply : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Divide : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Add : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Subtract : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Concat : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQ : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct AND : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct OR : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NEQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };


  struct ComplexConstructor : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };

  struct DefinedBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedBinary(DefinedBinary &&) = default; DefinedBinary &operator=(DefinedBinary &&) = default; DefinedBinary(const DefinedBinary &) = delete; DefinedBinary &operator=(const DefinedBinary &) = delete; DefinedBinary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>,
        common::Indirection<Expr>>
        t;
  };

  explicit Expr(Designator &&);
  explicit Expr(FunctionReference &&);

  mutable TypedExpr typedExpr;

  CharBlock source;

  std::variant<common::Indirection<CharLiteralConstantSubstring>,
      LiteralConstant, common::Indirection<Designator>, ArrayConstructor,
      StructureConstructor, common::Indirection<FunctionReference>, Parentheses,
      UnaryPlus, Negate, NOT, PercentLoc, DefinedUnary, Power, Multiply, Divide,
      Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, AND, OR, EQV, NEQV,
      DefinedBinary, ComplexConstructor, common::Indirection<SubstringInquiry>>
      u;
};


struct PartRef {
  PartRef(PartRef &&) = default; PartRef &operator=(PartRef &&) = default; PartRef(const PartRef &) = delete; PartRef &operator=(const PartRef &) = delete; PartRef() = delete;
  PartRef(Name &&n, std::list<SectionSubscript> &&ss,
      std::optional<ImageSelector> &&is)
      : name{std::move(n)}, subscripts(std::move(ss)),
        imageSelector{std::move(is)} {}
  Name name;
  std::list<SectionSubscript> subscripts;
  std::optional<ImageSelector> imageSelector;
};


struct DataRef {
  template <typename A, typename = common::NoLvalue<A>> DataRef(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataRef(DataRef &&) = default; DataRef &operator=(DataRef &&) = default; DataRef(const DataRef &) = delete; DataRef &operator=(const DataRef &) = delete; DataRef() = delete;
  explicit DataRef(std::list<PartRef> &&);
  std::variant<Name, common::Indirection<StructureComponent>,
      common::Indirection<ArrayElement>,
      common::Indirection<CoindexedNamedObject>>
      u;
};
# 1835 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct Substring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Substring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Substring(Substring &&) = default; Substring &operator=(Substring &&) = default; Substring(const Substring &) = delete; Substring &operator=(const Substring &) = delete; Substring() = delete;
  std::tuple<DataRef, SubstringRange> t;
};

struct CharLiteralConstantSubstring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CharLiteralConstantSubstring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharLiteralConstantSubstring(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring &operator=(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring &operator=(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring() = delete;
  std::tuple<CharLiteralConstant, SubstringRange> t;
};





struct SubstringInquiry {
  CharBlock source;
  SubstringInquiry(SubstringInquiry &&) = default; SubstringInquiry &operator=(SubstringInquiry &&) = default; SubstringInquiry(const SubstringInquiry &) = delete; SubstringInquiry &operator=(const SubstringInquiry &) = delete; SubstringInquiry() = delete; SubstringInquiry(Substring &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Substring v;
};




struct Designator {
  template <typename A, typename = common::NoLvalue<A>> Designator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Designator(Designator &&) = default; Designator &operator=(Designator &&) = default; Designator(const Designator &) = delete; Designator &operator=(const Designator &) = delete; Designator() = delete;
  bool EndsInBareName() const;
  CharBlock source;
  std::variant<DataRef, Substring> u;
};


struct Variable {
  template <typename A, typename = common::NoLvalue<A>> Variable(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Variable(Variable &&) = default; Variable &operator=(Variable &&) = default; Variable(const Variable &) = delete; Variable &operator=(const Variable &) = delete; Variable() = delete;
  mutable TypedExpr typedExpr;
  CharBlock GetSource() const;
  std::variant<common::Indirection<Designator>,
      common::Indirection<FunctionReference>>
      u;
};



using ScalarLogicalVariable = Scalar<Logical<Variable>>;



using ScalarDefaultCharVariable = Scalar<DefaultChar<Variable>>;



using ScalarIntVariable = Scalar<Integer<Variable>>;


struct StructureComponent {
  StructureComponent(StructureComponent &&) = default; StructureComponent &operator=(StructureComponent &&) = default; StructureComponent(const StructureComponent &) = delete; StructureComponent &operator=(const StructureComponent &) = delete; StructureComponent() = delete;
  StructureComponent(DataRef &&dr, Name &&n)
      : base{std::move(dr)}, component(std::move(n)) {}
  DataRef base;
  Name component;
};



struct ProcComponentRef {
  ProcComponentRef(ProcComponentRef &&) = default; ProcComponentRef &operator=(ProcComponentRef &&) = default; ProcComponentRef(const ProcComponentRef &) = delete; ProcComponentRef &operator=(const ProcComponentRef &) = delete; ProcComponentRef() = delete; ProcComponentRef(Scalar<StructureComponent> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<StructureComponent> v;
};


struct CoindexedNamedObject {
  CoindexedNamedObject(CoindexedNamedObject &&) = default; CoindexedNamedObject &operator=(CoindexedNamedObject &&) = default; CoindexedNamedObject(const CoindexedNamedObject &) = delete; CoindexedNamedObject &operator=(const CoindexedNamedObject &) = delete; CoindexedNamedObject() = delete;
  CoindexedNamedObject(DataRef &&dr, ImageSelector &&is)
      : base{std::move(dr)}, imageSelector{std::move(is)} {}
  DataRef base;
  ImageSelector imageSelector;
};


struct ArrayElement {
  ArrayElement(ArrayElement &&) = default; ArrayElement &operator=(ArrayElement &&) = default; ArrayElement(const ArrayElement &) = delete; ArrayElement &operator=(const ArrayElement &) = delete; ArrayElement() = delete;
  ArrayElement(DataRef &&dr, std::list<SectionSubscript> &&ss)
      : base{std::move(dr)}, subscripts(std::move(ss)) {}
  Substring ConvertToSubstring();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
  DataRef base;
  std::list<SectionSubscript> subscripts;
};


struct AllocateObject {
  template <typename A, typename = common::NoLvalue<A>> AllocateObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocateObject(AllocateObject &&) = default; AllocateObject &operator=(AllocateObject &&) = default; AllocateObject(const AllocateObject &) = delete; AllocateObject &operator=(const AllocateObject &) = delete; AllocateObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};



using BoundExpr = ScalarIntExpr;



struct AllocateShapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateShapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateShapeSpec(AllocateShapeSpec &&) = default; AllocateShapeSpec &operator=(AllocateShapeSpec &&) = default; AllocateShapeSpec(const AllocateShapeSpec &) = delete; AllocateShapeSpec &operator=(const AllocateShapeSpec &) = delete; AllocateShapeSpec() = delete;
  std::tuple<std::optional<BoundExpr>, BoundExpr> t;
};

using AllocateCoshapeSpec = AllocateShapeSpec;



struct AllocateCoarraySpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateCoarraySpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateCoarraySpec(AllocateCoarraySpec &&) = default; AllocateCoarraySpec &operator=(AllocateCoarraySpec &&) = default; AllocateCoarraySpec(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec &operator=(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec() = delete;
  std::tuple<std::list<AllocateCoshapeSpec>, std::optional<BoundExpr>> t;
};




struct Allocation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Allocation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Allocation(Allocation &&) = default; Allocation &operator=(Allocation &&) = default; Allocation(const Allocation &) = delete; Allocation &operator=(const Allocation &) = delete; Allocation() = delete;
  std::tuple<AllocateObject, std::list<AllocateShapeSpec>,
      std::optional<AllocateCoarraySpec>>
      t;
};


struct StatVariable { StatVariable(StatVariable &&) = default; StatVariable &operator=(StatVariable &&) = default; StatVariable(const StatVariable &) = delete; StatVariable &operator=(const StatVariable &) = delete; StatVariable() = delete; StatVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };



struct MsgVariable { MsgVariable(MsgVariable &&) = default; MsgVariable &operator=(MsgVariable &&) = default; MsgVariable(const MsgVariable &) = delete; MsgVariable &operator=(const MsgVariable &) = delete; MsgVariable() = delete; MsgVariable(ScalarDefaultCharVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharVariable v; };



struct StatOrErrmsg {
  template <typename A, typename = common::NoLvalue<A>> StatOrErrmsg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StatOrErrmsg(StatOrErrmsg &&) = default; StatOrErrmsg &operator=(StatOrErrmsg &&) = default; StatOrErrmsg(const StatOrErrmsg &) = delete; StatOrErrmsg &operator=(const StatOrErrmsg &) = delete; StatOrErrmsg() = delete;
  std::variant<StatVariable, MsgVariable> u;
};







struct AllocOpt {
  template <typename A, typename = common::NoLvalue<A>> AllocOpt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocOpt(AllocOpt &&) = default; AllocOpt &operator=(AllocOpt &&) = default; AllocOpt(const AllocOpt &) = delete; AllocOpt &operator=(const AllocOpt &) = delete; AllocOpt() = delete;
  struct Mold { Mold(Mold &&) = default; Mold &operator=(Mold &&) = default; Mold(const Mold &) = delete; Mold &operator=(const Mold &) = delete; Mold() = delete; Mold(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Source { Source(Source &&) = default; Source &operator=(Source &&) = default; Source(const Source &) = delete; Source &operator=(const Source &) = delete; Source() = delete; Source(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Stream { Stream(Stream &&) = default; Stream &operator=(Stream &&) = default; Stream(const Stream &) = delete; Stream &operator=(const Stream &) = delete; Stream() = delete; Stream(common::Indirection<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarIntExpr> v; };
  struct Pinned { Pinned(Pinned &&) = default; Pinned &operator=(Pinned &&) = default; Pinned(const Pinned &) = delete; Pinned &operator=(const Pinned &) = delete; Pinned() = delete; Pinned(common::Indirection<ScalarLogicalVariable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarLogicalVariable> v; };
  std::variant<Mold, Source, StatOrErrmsg, Stream, Pinned> u;
};



struct AllocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateStmt(AllocateStmt &&) = default; AllocateStmt &operator=(AllocateStmt &&) = default; AllocateStmt(const AllocateStmt &) = delete; AllocateStmt &operator=(const AllocateStmt &) = delete; AllocateStmt() = delete;
  std::tuple<std::optional<TypeSpec>, std::list<Allocation>,
      std::list<AllocOpt>>
      t;
};



struct PointerObject {
  template <typename A, typename = common::NoLvalue<A>> PointerObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PointerObject(PointerObject &&) = default; PointerObject &operator=(PointerObject &&) = default; PointerObject(const PointerObject &) = delete; PointerObject &operator=(const PointerObject &) = delete; PointerObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};


struct NullifyStmt { NullifyStmt(NullifyStmt &&) = default; NullifyStmt &operator=(NullifyStmt &&) = default; NullifyStmt(const NullifyStmt &) = delete; NullifyStmt &operator=(const NullifyStmt &) = delete; NullifyStmt() = delete; NullifyStmt(std::list<PointerObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PointerObject> v; };



struct DeallocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DeallocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DeallocateStmt(DeallocateStmt &&) = default; DeallocateStmt &operator=(DeallocateStmt &&) = default; DeallocateStmt(const DeallocateStmt &) = delete; DeallocateStmt &operator=(const DeallocateStmt &) = delete; DeallocateStmt() = delete;
  std::tuple<std::list<AllocateObject>, std::list<StatOrErrmsg>> t;
};


struct AssignmentStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignmentStmt(AssignmentStmt &&) = default; AssignmentStmt &operator=(AssignmentStmt &&) = default; AssignmentStmt(const AssignmentStmt &) = delete; AssignmentStmt &operator=(const AssignmentStmt &) = delete; AssignmentStmt() = delete;
  using TypedAssignment =
      common::ForwardOwningPointer<evaluate::GenericAssignmentWrapper>;
  mutable TypedAssignment typedAssignment;
  std::tuple<Variable, Expr> t;
};


struct BoundsSpec { BoundsSpec(BoundsSpec &&) = default; BoundsSpec &operator=(BoundsSpec &&) = default; BoundsSpec(const BoundsSpec &) = delete; BoundsSpec &operator=(const BoundsSpec &) = delete; BoundsSpec() = delete; BoundsSpec(BoundExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; BoundExpr v; };


struct BoundsRemapping {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BoundsRemapping(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BoundsRemapping(BoundsRemapping &&) = default; BoundsRemapping &operator=(BoundsRemapping &&) = default; BoundsRemapping(const BoundsRemapping &) = delete; BoundsRemapping &operator=(const BoundsRemapping &) = delete; BoundsRemapping() = delete;
  std::tuple<BoundExpr, BoundExpr> t;
};
# 2040 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct PointerAssignmentStmt {
  struct Bounds {
    template <typename A, typename = common::NoLvalue<A>> Bounds(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Bounds(Bounds &&) = default; Bounds &operator=(Bounds &&) = default; Bounds(const Bounds &) = delete; Bounds &operator=(const Bounds &) = delete; Bounds() = delete;
    std::variant<std::list<BoundsRemapping>, std::list<BoundsSpec>> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PointerAssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PointerAssignmentStmt(PointerAssignmentStmt &&) = default; PointerAssignmentStmt &operator=(PointerAssignmentStmt &&) = default; PointerAssignmentStmt(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt &operator=(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt() = delete;
  mutable AssignmentStmt::TypedAssignment typedAssignment;
  std::tuple<DataRef, Bounds, Expr> t;
};




struct WhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereStmt(WhereStmt &&) = default; WhereStmt &operator=(WhereStmt &&) = default; WhereStmt(const WhereStmt &) = delete; WhereStmt &operator=(const WhereStmt &) = delete; WhereStmt() = delete;
  std::tuple<LogicalExpr, AssignmentStmt> t;
};


struct WhereConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstructStmt(WhereConstructStmt &&) = default; WhereConstructStmt &operator=(WhereConstructStmt &&) = default; WhereConstructStmt(const WhereConstructStmt &) = delete; WhereConstructStmt &operator=(const WhereConstructStmt &) = delete; WhereConstructStmt() = delete;
  std::tuple<std::optional<Name>, LogicalExpr> t;
};



struct WhereBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> WhereBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WhereBodyConstruct(WhereBodyConstruct &&) = default; WhereBodyConstruct &operator=(WhereBodyConstruct &&) = default; WhereBodyConstruct(const WhereBodyConstruct &) = delete; WhereBodyConstruct &operator=(const WhereBodyConstruct &) = delete; WhereBodyConstruct() = delete;
  std::variant<Statement<AssignmentStmt>, Statement<WhereStmt>,
      common::Indirection<WhereConstruct>>
      u;
};



struct MaskedElsewhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhereStmt(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt &operator=(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt &operator=(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt() = delete;
  std::tuple<LogicalExpr, std::optional<Name>> t;
};


struct ElsewhereStmt { ElsewhereStmt(ElsewhereStmt &&) = default; ElsewhereStmt &operator=(ElsewhereStmt &&) = default; ElsewhereStmt(const ElsewhereStmt &) = delete; ElsewhereStmt &operator=(const ElsewhereStmt &) = delete; ElsewhereStmt() = delete; ElsewhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndWhereStmt { EndWhereStmt(EndWhereStmt &&) = default; EndWhereStmt &operator=(EndWhereStmt &&) = default; EndWhereStmt(const EndWhereStmt &) = delete; EndWhereStmt &operator=(const EndWhereStmt &) = delete; EndWhereStmt() = delete; EndWhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };





struct WhereConstruct {
  struct MaskedElsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhere(MaskedElsewhere &&) = default; MaskedElsewhere &operator=(MaskedElsewhere &&) = default; MaskedElsewhere(const MaskedElsewhere &) = delete; MaskedElsewhere &operator=(const MaskedElsewhere &) = delete; MaskedElsewhere() = delete;
    std::tuple<Statement<MaskedElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  struct Elsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Elsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Elsewhere(Elsewhere &&) = default; Elsewhere &operator=(Elsewhere &&) = default; Elsewhere(const Elsewhere &) = delete; Elsewhere &operator=(const Elsewhere &) = delete; Elsewhere() = delete;
    std::tuple<Statement<ElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstruct(WhereConstruct &&) = default; WhereConstruct &operator=(WhereConstruct &&) = default; WhereConstruct(const WhereConstruct &) = delete; WhereConstruct &operator=(const WhereConstruct &) = delete; WhereConstruct() = delete;
  std::tuple<Statement<WhereConstructStmt>, std::list<WhereBodyConstruct>,
      std::list<MaskedElsewhere>, std::optional<Elsewhere>,
      Statement<EndWhereStmt>>
      t;
};



struct ForallConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstructStmt(ForallConstructStmt &&) = default; ForallConstructStmt &operator=(ForallConstructStmt &&) = default; ForallConstructStmt(const ForallConstructStmt &) = delete; ForallConstructStmt &operator=(const ForallConstructStmt &) = delete; ForallConstructStmt() = delete;
  std::tuple<std::optional<Name>, common::Indirection<ConcurrentHeader>> t;
};


struct ForallAssignmentStmt {
  template <typename A, typename = common::NoLvalue<A>> ForallAssignmentStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallAssignmentStmt(ForallAssignmentStmt &&) = default; ForallAssignmentStmt &operator=(ForallAssignmentStmt &&) = default; ForallAssignmentStmt(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt &operator=(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt() = delete;
  std::variant<AssignmentStmt, PointerAssignmentStmt> u;
};


struct ForallStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallStmt(ForallStmt &&) = default; ForallStmt &operator=(ForallStmt &&) = default; ForallStmt(const ForallStmt &) = delete; ForallStmt &operator=(const ForallStmt &) = delete; ForallStmt() = delete;
  std::tuple<common::Indirection<ConcurrentHeader>,
      UnlabeledStatement<ForallAssignmentStmt>>
      t;
};




struct ForallBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> ForallBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallBodyConstruct(ForallBodyConstruct &&) = default; ForallBodyConstruct &operator=(ForallBodyConstruct &&) = default; ForallBodyConstruct(const ForallBodyConstruct &) = delete; ForallBodyConstruct &operator=(const ForallBodyConstruct &) = delete; ForallBodyConstruct() = delete;
  std::variant<Statement<ForallAssignmentStmt>, Statement<WhereStmt>,
      WhereConstruct, common::Indirection<ForallConstruct>,
      Statement<ForallStmt>>
      u;
};


struct EndForallStmt { EndForallStmt(EndForallStmt &&) = default; EndForallStmt &operator=(EndForallStmt &&) = default; EndForallStmt(const EndForallStmt &) = delete; EndForallStmt &operator=(const EndForallStmt &) = delete; EndForallStmt() = delete; EndForallStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct ForallConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstruct(ForallConstruct &&) = default; ForallConstruct &operator=(ForallConstruct &&) = default; ForallConstruct(const ForallConstruct &) = delete; ForallConstruct &operator=(const ForallConstruct &) = delete; ForallConstruct() = delete;
  std::tuple<Statement<ForallConstructStmt>, std::list<ForallBodyConstruct>,
      Statement<EndForallStmt>>
      t;
};


struct Selector {
  template <typename A, typename = common::NoLvalue<A>> Selector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Selector(Selector &&) = default; Selector &operator=(Selector &&) = default; Selector(const Selector &) = delete; Selector &operator=(const Selector &) = delete; Selector() = delete;
  std::variant<Expr, Variable> u;
};


struct Association {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Association(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Association(Association &&) = default; Association &operator=(Association &&) = default; Association(const Association &) = delete; Association &operator=(const Association &) = delete; Association() = delete;
  std::tuple<Name, Selector> t;
};



struct AssociateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateStmt(AssociateStmt &&) = default; AssociateStmt &operator=(AssociateStmt &&) = default; AssociateStmt(const AssociateStmt &) = delete; AssociateStmt &operator=(const AssociateStmt &) = delete; AssociateStmt() = delete;
  std::tuple<std::optional<Name>, std::list<Association>> t;
};


struct EndAssociateStmt { EndAssociateStmt(EndAssociateStmt &&) = default; EndAssociateStmt &operator=(EndAssociateStmt &&) = default; EndAssociateStmt(const EndAssociateStmt &) = delete; EndAssociateStmt &operator=(const EndAssociateStmt &) = delete; EndAssociateStmt() = delete; EndAssociateStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct AssociateConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateConstruct(AssociateConstruct &&) = default; AssociateConstruct &operator=(AssociateConstruct &&) = default; AssociateConstruct(const AssociateConstruct &) = delete; AssociateConstruct &operator=(const AssociateConstruct &) = delete; AssociateConstruct() = delete;
  std::tuple<Statement<AssociateStmt>, Block, Statement<EndAssociateStmt>> t;
};


struct BlockStmt { BlockStmt(BlockStmt &&) = default; BlockStmt &operator=(BlockStmt &&) = default; BlockStmt(const BlockStmt &) = delete; BlockStmt &operator=(const BlockStmt &) = delete; BlockStmt() = delete; BlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockStmt { EndBlockStmt(EndBlockStmt &&) = default; EndBlockStmt &operator=(EndBlockStmt &&) = default; EndBlockStmt(const EndBlockStmt &) = delete; EndBlockStmt &operator=(const EndBlockStmt &) = delete; EndBlockStmt() = delete; EndBlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2191 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct BlockSpecificationPart { BlockSpecificationPart(BlockSpecificationPart &&) = default; BlockSpecificationPart &operator=(BlockSpecificationPart &&) = default; BlockSpecificationPart(const BlockSpecificationPart &) = delete; BlockSpecificationPart &operator=(const BlockSpecificationPart &) = delete; BlockSpecificationPart() = delete; BlockSpecificationPart(SpecificationPart &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; SpecificationPart v; };



struct BlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockConstruct(BlockConstruct &&) = default; BlockConstruct &operator=(BlockConstruct &&) = default; BlockConstruct(const BlockConstruct &) = delete; BlockConstruct &operator=(const BlockConstruct &) = delete; BlockConstruct() = delete;
  std::tuple<Statement<BlockStmt>, BlockSpecificationPart, Block,
      Statement<EndBlockStmt>>
      t;
};


struct CoarrayAssociation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CoarrayAssociation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CoarrayAssociation(CoarrayAssociation &&) = default; CoarrayAssociation &operator=(CoarrayAssociation &&) = default; CoarrayAssociation(const CoarrayAssociation &) = delete; CoarrayAssociation &operator=(const CoarrayAssociation &) = delete; CoarrayAssociation() = delete;
  std::tuple<CodimensionDecl, Selector> t;
};




struct ChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamStmt(ChangeTeamStmt &&) = default; ChangeTeamStmt &operator=(ChangeTeamStmt &&) = default; ChangeTeamStmt(const ChangeTeamStmt &) = delete; ChangeTeamStmt &operator=(const ChangeTeamStmt &) = delete; ChangeTeamStmt() = delete;
  std::tuple<std::optional<Name>, TeamValue, std::list<CoarrayAssociation>,
      std::list<StatOrErrmsg>>
      t;
};



struct EndChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EndChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EndChangeTeamStmt(EndChangeTeamStmt &&) = default; EndChangeTeamStmt &operator=(EndChangeTeamStmt &&) = default; EndChangeTeamStmt(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt &operator=(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt() = delete;
  std::tuple<std::list<StatOrErrmsg>, std::optional<Name>> t;
};


struct ChangeTeamConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamConstruct(ChangeTeamConstruct &&) = default; ChangeTeamConstruct &operator=(ChangeTeamConstruct &&) = default; ChangeTeamConstruct(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct &operator=(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct() = delete;
  std::tuple<Statement<ChangeTeamStmt>, Block, Statement<EndChangeTeamStmt>> t;
};



struct CriticalStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalStmt(CriticalStmt &&) = default; CriticalStmt &operator=(CriticalStmt &&) = default; CriticalStmt(const CriticalStmt &) = delete; CriticalStmt &operator=(const CriticalStmt &) = delete; CriticalStmt() = delete;
  std::tuple<std::optional<Name>, std::list<StatOrErrmsg>> t;
};


struct EndCriticalStmt { EndCriticalStmt(EndCriticalStmt &&) = default; EndCriticalStmt &operator=(EndCriticalStmt &&) = default; EndCriticalStmt(const EndCriticalStmt &) = delete; EndCriticalStmt &operator=(const EndCriticalStmt &) = delete; EndCriticalStmt() = delete; EndCriticalStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct CriticalConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalConstruct(CriticalConstruct &&) = default; CriticalConstruct &operator=(CriticalConstruct &&) = default; CriticalConstruct(const CriticalConstruct &) = delete; CriticalConstruct &operator=(const CriticalConstruct &) = delete; CriticalConstruct() = delete;
  std::tuple<Statement<CriticalStmt>, Block, Statement<EndCriticalStmt>> t;
};





struct ConcurrentControl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentControl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentControl(ConcurrentControl &&) = default; ConcurrentControl &operator=(ConcurrentControl &&) = default; ConcurrentControl(const ConcurrentControl &) = delete; ConcurrentControl &operator=(const ConcurrentControl &) = delete; ConcurrentControl() = delete;
  std::tuple<Name, ScalarIntExpr, ScalarIntExpr, std::optional<ScalarIntExpr>>
      t;
};




struct ConcurrentHeader {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentHeader(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentHeader(ConcurrentHeader &&) = default; ConcurrentHeader &operator=(ConcurrentHeader &&) = default; ConcurrentHeader(const ConcurrentHeader &) = delete; ConcurrentHeader &operator=(const ConcurrentHeader &) = delete; ConcurrentHeader() = delete;
  std::tuple<std::optional<IntegerTypeSpec>, std::list<ConcurrentControl>,
      std::optional<ScalarLogicalExpr>>
      t;
};






struct ReductionOperator {
  enum class Operator { Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv }; [[maybe_unused]] static constexpr std::size_t Operator_enumSize{ ::Fortran::common::CountEnumNames("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; [[maybe_unused]] static inline std::size_t EnumToInt(Operator e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Operator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Operator_enumSize>("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachOperator(std::function<void(Operator)> f) { for (std::size_t i{0}; i < Operator_enumSize; ++i) { f(static_cast<Operator>(i)); } }

  ReductionOperator(ReductionOperator &&) = default; ReductionOperator &operator=(ReductionOperator &&) = default; ReductionOperator(const ReductionOperator &) = delete; ReductionOperator &operator=(const ReductionOperator &) = delete; ReductionOperator() = delete; ReductionOperator(Operator &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Operator v;
  CharBlock source;
};





struct LocalitySpec {
  template <typename A, typename = common::NoLvalue<A>> LocalitySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LocalitySpec(LocalitySpec &&) = default; LocalitySpec &operator=(LocalitySpec &&) = default; LocalitySpec(const LocalitySpec &) = delete; LocalitySpec &operator=(const LocalitySpec &) = delete; LocalitySpec() = delete;
  struct Local { Local(Local &&) = default; Local &operator=(Local &&) = default; Local(const Local &) = delete; Local &operator=(const Local &) = delete; Local() = delete; Local(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct LocalInit { LocalInit(LocalInit &&) = default; LocalInit &operator=(LocalInit &&) = default; LocalInit(const LocalInit &) = delete; LocalInit &operator=(const LocalInit &) = delete; LocalInit() = delete; LocalInit(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct Reduce {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Reduce(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Reduce(Reduce &&) = default; Reduce &operator=(Reduce &&) = default; Reduce(const Reduce &) = delete; Reduce &operator=(const Reduce &) = delete; Reduce() = delete;
    using Operator = ReductionOperator;
    std::tuple<Operator, std::list<Name>> t;
  };
  struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct DefaultNone { DefaultNone() {} DefaultNone(const DefaultNone &) {} DefaultNone(DefaultNone &&) {} DefaultNone &operator=(const DefaultNone &) { return *this; }; DefaultNone &operator=(DefaultNone &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<Local, LocalInit, Reduce, Shared, DefaultNone> u;
};







struct LoopControl {
  template <typename A, typename = common::NoLvalue<A>> LoopControl(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LoopControl(LoopControl &&) = default; LoopControl &operator=(LoopControl &&) = default; LoopControl(const LoopControl &) = delete; LoopControl &operator=(const LoopControl &) = delete; LoopControl() = delete;
  struct Concurrent {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Concurrent(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Concurrent(Concurrent &&) = default; Concurrent &operator=(Concurrent &&) = default; Concurrent(const Concurrent &) = delete; Concurrent &operator=(const Concurrent &) = delete; Concurrent() = delete;
    std::tuple<ConcurrentHeader, std::list<LocalitySpec>> t;
  };
  using Bounds = LoopBounds<ScalarName, ScalarExpr>;
  std::variant<Bounds, ScalarLogicalExpr, Concurrent> u;
};



struct LabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LabelDoStmt(LabelDoStmt &&) = default; LabelDoStmt &operator=(LabelDoStmt &&) = default; LabelDoStmt(const LabelDoStmt &) = delete; LabelDoStmt &operator=(const LabelDoStmt &) = delete; LabelDoStmt() = delete;
  std::tuple<Label, std::optional<LoopControl>> t;
};


struct NonLabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NonLabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NonLabelDoStmt(NonLabelDoStmt &&) = default; NonLabelDoStmt &operator=(NonLabelDoStmt &&) = default; NonLabelDoStmt(const NonLabelDoStmt &) = delete; NonLabelDoStmt &operator=(const NonLabelDoStmt &) = delete; NonLabelDoStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Label>,
      std::optional<LoopControl>>
      t;
};


struct EndDoStmt { EndDoStmt(EndDoStmt &&) = default; EndDoStmt &operator=(EndDoStmt &&) = default; EndDoStmt(const EndDoStmt &) = delete; EndDoStmt &operator=(const EndDoStmt &) = delete; EndDoStmt() = delete; EndDoStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2338 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct DoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DoConstruct(DoConstruct &&) = default; DoConstruct &operator=(DoConstruct &&) = default; DoConstruct(const DoConstruct &) = delete; DoConstruct &operator=(const DoConstruct &) = delete; DoConstruct() = delete;
  const std::optional<LoopControl> &GetLoopControl() const;
  bool IsDoNormal() const;
  bool IsDoWhile() const;
  bool IsDoConcurrent() const;
  std::tuple<Statement<NonLabelDoStmt>, Block, Statement<EndDoStmt>> t;
};


struct CycleStmt { CycleStmt(CycleStmt &&) = default; CycleStmt &operator=(CycleStmt &&) = default; CycleStmt(const CycleStmt &) = delete; CycleStmt &operator=(const CycleStmt &) = delete; CycleStmt() = delete; CycleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct IfThenStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfThenStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfThenStmt(IfThenStmt &&) = default; IfThenStmt &operator=(IfThenStmt &&) = default; IfThenStmt(const IfThenStmt &) = delete; IfThenStmt &operator=(const IfThenStmt &) = delete; IfThenStmt() = delete;
  std::tuple<std::optional<Name>, ScalarLogicalExpr> t;
};



struct ElseIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfStmt(ElseIfStmt &&) = default; ElseIfStmt &operator=(ElseIfStmt &&) = default; ElseIfStmt(const ElseIfStmt &) = delete; ElseIfStmt &operator=(const ElseIfStmt &) = delete; ElseIfStmt() = delete;
  std::tuple<ScalarLogicalExpr, std::optional<Name>> t;
};


struct ElseStmt { ElseStmt(ElseStmt &&) = default; ElseStmt &operator=(ElseStmt &&) = default; ElseStmt(const ElseStmt &) = delete; ElseStmt &operator=(const ElseStmt &) = delete; ElseStmt() = delete; ElseStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndIfStmt { EndIfStmt(EndIfStmt &&) = default; EndIfStmt &operator=(EndIfStmt &&) = default; EndIfStmt(const EndIfStmt &) = delete; EndIfStmt &operator=(const EndIfStmt &) = delete; EndIfStmt() = delete; EndIfStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct IfConstruct {
  struct ElseIfBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfBlock(ElseIfBlock &&) = default; ElseIfBlock &operator=(ElseIfBlock &&) = default; ElseIfBlock(const ElseIfBlock &) = delete; ElseIfBlock &operator=(const ElseIfBlock &) = delete; ElseIfBlock() = delete;
    std::tuple<Statement<ElseIfStmt>, Block> t;
  };
  struct ElseBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseBlock(ElseBlock &&) = default; ElseBlock &operator=(ElseBlock &&) = default; ElseBlock(const ElseBlock &) = delete; ElseBlock &operator=(const ElseBlock &) = delete; ElseBlock() = delete;
    std::tuple<Statement<ElseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfConstruct(IfConstruct &&) = default; IfConstruct &operator=(IfConstruct &&) = default; IfConstruct(const IfConstruct &) = delete; IfConstruct &operator=(const IfConstruct &) = delete; IfConstruct() = delete;
  std::tuple<Statement<IfThenStmt>, Block, std::list<ElseIfBlock>,
      std::optional<ElseBlock>, Statement<EndIfStmt>>
      t;
};


struct IfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfStmt(IfStmt &&) = default; IfStmt &operator=(IfStmt &&) = default; IfStmt(const IfStmt &) = delete; IfStmt &operator=(const IfStmt &) = delete; IfStmt() = delete;
  std::tuple<ScalarLogicalExpr, UnlabeledStatement<ActionStmt>> t;
};



struct SelectCaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectCaseStmt(SelectCaseStmt &&) = default; SelectCaseStmt &operator=(SelectCaseStmt &&) = default; SelectCaseStmt(const SelectCaseStmt &) = delete; SelectCaseStmt &operator=(const SelectCaseStmt &) = delete; SelectCaseStmt() = delete;
  std::tuple<std::optional<Name>, Scalar<Expr>> t;
};


using CaseValue = Scalar<ConstantExpr>;



struct CaseValueRange {
  template <typename A, typename = common::NoLvalue<A>> CaseValueRange(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseValueRange(CaseValueRange &&) = default; CaseValueRange &operator=(CaseValueRange &&) = default; CaseValueRange(const CaseValueRange &) = delete; CaseValueRange &operator=(const CaseValueRange &) = delete; CaseValueRange() = delete;
  struct Range {
    Range(Range &&) = default; Range &operator=(Range &&) = default; Range(const Range &) = delete; Range &operator=(const Range &) = delete; Range() = delete;
    Range(std::optional<CaseValue> &&l, std::optional<CaseValue> &&u)
        : lower{std::move(l)}, upper{std::move(u)} {}
    std::optional<CaseValue> lower, upper;
  };
  std::variant<CaseValue, Range> u;
};


struct Default { Default() {} Default(const Default &) {} Default(Default &&) {} Default &operator=(const Default &) { return *this; }; Default &operator=(Default &&) { return *this; }; using EmptyTrait = std::true_type; };

struct CaseSelector {
  template <typename A, typename = common::NoLvalue<A>> CaseSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseSelector(CaseSelector &&) = default; CaseSelector &operator=(CaseSelector &&) = default; CaseSelector(const CaseSelector &) = delete; CaseSelector &operator=(const CaseSelector &) = delete; CaseSelector() = delete;
  std::variant<std::list<CaseValueRange>, Default> u;
};


struct CaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseStmt(CaseStmt &&) = default; CaseStmt &operator=(CaseStmt &&) = default; CaseStmt(const CaseStmt &) = delete; CaseStmt &operator=(const CaseStmt &) = delete; CaseStmt() = delete;
  std::tuple<CaseSelector, std::optional<Name>> t;
};




struct EndSelectStmt { EndSelectStmt(EndSelectStmt &&) = default; EndSelectStmt &operator=(EndSelectStmt &&) = default; EndSelectStmt(const EndSelectStmt &) = delete; EndSelectStmt &operator=(const EndSelectStmt &) = delete; EndSelectStmt() = delete; EndSelectStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct CaseConstruct {
  struct Case {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Case(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Case(Case &&) = default; Case &operator=(Case &&) = default; Case(const Case &) = delete; Case &operator=(const Case &) = delete; Case() = delete;
    std::tuple<Statement<CaseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseConstruct(CaseConstruct &&) = default; CaseConstruct &operator=(CaseConstruct &&) = default; CaseConstruct(const CaseConstruct &) = delete; CaseConstruct &operator=(const CaseConstruct &) = delete; CaseConstruct() = delete;
  std::tuple<Statement<SelectCaseStmt>, std::list<Case>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectRankStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankStmt(SelectRankStmt &&) = default; SelectRankStmt &operator=(SelectRankStmt &&) = default; SelectRankStmt(const SelectRankStmt &) = delete; SelectRankStmt &operator=(const SelectRankStmt &) = delete; SelectRankStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct SelectRankCaseStmt {
  struct Rank {
    template <typename A, typename = common::NoLvalue<A>> Rank(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rank(Rank &&) = default; Rank &operator=(Rank &&) = default; Rank(const Rank &) = delete; Rank &operator=(const Rank &) = delete; Rank() = delete;
    std::variant<ScalarIntConstantExpr, Star, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankCaseStmt(SelectRankCaseStmt &&) = default; SelectRankCaseStmt &operator=(SelectRankCaseStmt &&) = default; SelectRankCaseStmt(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt &operator=(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt() = delete;
  std::tuple<Rank, std::optional<Name>> t;
};




struct SelectRankConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankConstruct(SelectRankConstruct &&) = default; SelectRankConstruct &operator=(SelectRankConstruct &&) = default; SelectRankConstruct(const SelectRankConstruct &) = delete; SelectRankConstruct &operator=(const SelectRankConstruct &) = delete; SelectRankConstruct() = delete;
  struct RankCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> RankCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; RankCase(RankCase &&) = default; RankCase &operator=(RankCase &&) = default; RankCase(const RankCase &) = delete; RankCase &operator=(const RankCase &) = delete; RankCase() = delete;
    std::tuple<Statement<SelectRankCaseStmt>, Block> t;
  };
  std::tuple<Statement<SelectRankStmt>, std::list<RankCase>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectTypeStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeStmt(SelectTypeStmt &&) = default; SelectTypeStmt &operator=(SelectTypeStmt &&) = default; SelectTypeStmt(const SelectTypeStmt &) = delete; SelectTypeStmt &operator=(const SelectTypeStmt &) = delete; SelectTypeStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct TypeGuardStmt {
  struct Guard {
    template <typename A, typename = common::NoLvalue<A>> Guard(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Guard(Guard &&) = default; Guard &operator=(Guard &&) = default; Guard(const Guard &) = delete; Guard &operator=(const Guard &) = delete; Guard() = delete;
    std::variant<TypeSpec, DerivedTypeSpec, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeGuardStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeGuardStmt(TypeGuardStmt &&) = default; TypeGuardStmt &operator=(TypeGuardStmt &&) = default; TypeGuardStmt(const TypeGuardStmt &) = delete; TypeGuardStmt &operator=(const TypeGuardStmt &) = delete; TypeGuardStmt() = delete;
  std::tuple<Guard, std::optional<Name>> t;
};



struct SelectTypeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeConstruct(SelectTypeConstruct &&) = default; SelectTypeConstruct &operator=(SelectTypeConstruct &&) = default; SelectTypeConstruct(const SelectTypeConstruct &) = delete; SelectTypeConstruct &operator=(const SelectTypeConstruct &) = delete; SelectTypeConstruct() = delete;
  struct TypeCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeCase(TypeCase &&) = default; TypeCase &operator=(TypeCase &&) = default; TypeCase(const TypeCase &) = delete; TypeCase &operator=(const TypeCase &) = delete; TypeCase() = delete;
    std::tuple<Statement<TypeGuardStmt>, Block> t;
  };
  std::tuple<Statement<SelectTypeStmt>, std::list<TypeCase>,
      Statement<EndSelectStmt>>
      t;
};


struct ExitStmt { ExitStmt(ExitStmt &&) = default; ExitStmt &operator=(ExitStmt &&) = default; ExitStmt(const ExitStmt &) = delete; ExitStmt &operator=(const ExitStmt &) = delete; ExitStmt() = delete; ExitStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct GotoStmt { GotoStmt(GotoStmt &&) = default; GotoStmt &operator=(GotoStmt &&) = default; GotoStmt(const GotoStmt &) = delete; GotoStmt &operator=(const GotoStmt &) = delete; GotoStmt() = delete; GotoStmt(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };


struct ComputedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComputedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComputedGotoStmt(ComputedGotoStmt &&) = default; ComputedGotoStmt &operator=(ComputedGotoStmt &&) = default; ComputedGotoStmt(const ComputedGotoStmt &) = delete; ComputedGotoStmt &operator=(const ComputedGotoStmt &) = delete; ComputedGotoStmt() = delete;
  std::tuple<std::list<Label>, ScalarIntExpr> t;
};





struct StopCode { StopCode(StopCode &&) = default; StopCode &operator=(StopCode &&) = default; StopCode(const StopCode &) = delete; StopCode &operator=(const StopCode &) = delete; StopCode() = delete; StopCode(Scalar<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<Expr> v; };




struct StopStmt {
  enum class Kind { Stop, ErrorStop }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Stop, ErrorStop")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Stop, ErrorStop")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StopStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StopStmt(StopStmt &&) = default; StopStmt &operator=(StopStmt &&) = default; StopStmt(const StopStmt &) = delete; StopStmt &operator=(const StopStmt &) = delete; StopStmt() = delete;
  std::tuple<Kind, std::optional<StopCode>, std::optional<ScalarLogicalExpr>> t;
};



struct NotifyWaitStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NotifyWaitStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NotifyWaitStmt(NotifyWaitStmt &&) = default; NotifyWaitStmt &operator=(NotifyWaitStmt &&) = default; NotifyWaitStmt(const NotifyWaitStmt &) = delete; NotifyWaitStmt &operator=(const NotifyWaitStmt &) = delete; NotifyWaitStmt() = delete;
  std::tuple<Scalar<Variable>, std::list<EventWaitSpec>> t;
};


struct SyncAllStmt { SyncAllStmt(SyncAllStmt &&) = default; SyncAllStmt &operator=(SyncAllStmt &&) = default; SyncAllStmt(const SyncAllStmt &) = delete; SyncAllStmt &operator=(const SyncAllStmt &) = delete; SyncAllStmt() = delete; SyncAllStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };



struct SyncImagesStmt {
  struct ImageSet {
    template <typename A, typename = common::NoLvalue<A>> ImageSet(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImageSet(ImageSet &&) = default; ImageSet &operator=(ImageSet &&) = default; ImageSet(const ImageSet &) = delete; ImageSet &operator=(const ImageSet &) = delete; ImageSet() = delete;
    std::variant<IntExpr, Star> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncImagesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncImagesStmt(SyncImagesStmt &&) = default; SyncImagesStmt &operator=(SyncImagesStmt &&) = default; SyncImagesStmt(const SyncImagesStmt &) = delete; SyncImagesStmt &operator=(const SyncImagesStmt &) = delete; SyncImagesStmt() = delete;
  std::tuple<ImageSet, std::list<StatOrErrmsg>> t;
};


struct SyncMemoryStmt { SyncMemoryStmt(SyncMemoryStmt &&) = default; SyncMemoryStmt &operator=(SyncMemoryStmt &&) = default; SyncMemoryStmt(const SyncMemoryStmt &) = delete; SyncMemoryStmt &operator=(const SyncMemoryStmt &) = delete; SyncMemoryStmt() = delete; SyncMemoryStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };


struct SyncTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncTeamStmt(SyncTeamStmt &&) = default; SyncTeamStmt &operator=(SyncTeamStmt &&) = default; SyncTeamStmt(const SyncTeamStmt &) = delete; SyncTeamStmt &operator=(const SyncTeamStmt &) = delete; SyncTeamStmt() = delete;
  std::tuple<TeamValue, std::list<StatOrErrmsg>> t;
};


using EventVariable = Scalar<Variable>;


struct EventPostStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventPostStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventPostStmt(EventPostStmt &&) = default; EventPostStmt &operator=(EventPostStmt &&) = default; EventPostStmt(const EventPostStmt &) = delete; EventPostStmt &operator=(const EventPostStmt &) = delete; EventPostStmt() = delete;
  std::tuple<EventVariable, std::list<StatOrErrmsg>> t;
};


struct EventWaitSpec {
  template <typename A, typename = common::NoLvalue<A>> EventWaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; EventWaitSpec(EventWaitSpec &&) = default; EventWaitSpec &operator=(EventWaitSpec &&) = default; EventWaitSpec(const EventWaitSpec &) = delete; EventWaitSpec &operator=(const EventWaitSpec &) = delete; EventWaitSpec() = delete;
  std::variant<ScalarIntExpr, StatOrErrmsg> u;
};




struct EventWaitStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventWaitStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventWaitStmt(EventWaitStmt &&) = default; EventWaitStmt &operator=(EventWaitStmt &&) = default; EventWaitStmt(const EventWaitStmt &) = delete; EventWaitStmt &operator=(const EventWaitStmt &) = delete; EventWaitStmt() = delete;
  std::tuple<EventVariable, std::list<EventWaitSpec>> t;
};


using TeamVariable = Scalar<Variable>;





struct FormTeamStmt {
  struct FormTeamSpec {
    template <typename A, typename = common::NoLvalue<A>> FormTeamSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; FormTeamSpec(FormTeamSpec &&) = default; FormTeamSpec &operator=(FormTeamSpec &&) = default; FormTeamSpec(const FormTeamSpec &) = delete; FormTeamSpec &operator=(const FormTeamSpec &) = delete; FormTeamSpec() = delete;
    std::variant<ScalarIntExpr, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FormTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FormTeamStmt(FormTeamStmt &&) = default; FormTeamStmt &operator=(FormTeamStmt &&) = default; FormTeamStmt(const FormTeamStmt &) = delete; FormTeamStmt &operator=(const FormTeamStmt &) = delete; FormTeamStmt() = delete;
  std::tuple<ScalarIntExpr, TeamVariable, std::list<FormTeamSpec>> t;
};


using LockVariable = Scalar<Variable>;



struct LockStmt {
  struct LockStat {
    template <typename A, typename = common::NoLvalue<A>> LockStat(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LockStat(LockStat &&) = default; LockStat &operator=(LockStat &&) = default; LockStat(const LockStat &) = delete; LockStat &operator=(const LockStat &) = delete; LockStat() = delete;
    std::variant<Scalar<Logical<Variable>>, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LockStmt(LockStmt &&) = default; LockStmt &operator=(LockStmt &&) = default; LockStmt(const LockStmt &) = delete; LockStmt &operator=(const LockStmt &) = delete; LockStmt() = delete;
  std::tuple<LockVariable, std::list<LockStat>> t;
};


struct UnlockStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> UnlockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; UnlockStmt(UnlockStmt &&) = default; UnlockStmt &operator=(UnlockStmt &&) = default; UnlockStmt(const UnlockStmt &) = delete; UnlockStmt &operator=(const UnlockStmt &) = delete; UnlockStmt() = delete;
  std::tuple<LockVariable, std::list<StatOrErrmsg>> t;
};


struct FileUnitNumber { FileUnitNumber(FileUnitNumber &&) = default; FileUnitNumber &operator=(FileUnitNumber &&) = default; FileUnitNumber(const FileUnitNumber &) = delete; FileUnitNumber &operator=(const FileUnitNumber &) = delete; FileUnitNumber() = delete; FileUnitNumber(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
# 2643 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct IoUnit {
  template <typename A, typename = common::NoLvalue<A>> IoUnit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoUnit(IoUnit &&) = default; IoUnit &operator=(IoUnit &&) = default; IoUnit(const IoUnit &) = delete; IoUnit &operator=(const IoUnit &) = delete; IoUnit() = delete;
  std::variant<Variable, common::Indirection<Expr>, Star> u;
};


using FileNameExpr = ScalarDefaultCharExpr;
# 2668 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct StatusExpr { StatusExpr(StatusExpr &&) = default; StatusExpr &operator=(StatusExpr &&) = default; StatusExpr(const StatusExpr &) = delete; StatusExpr &operator=(const StatusExpr &) = delete; StatusExpr() = delete; StatusExpr(ScalarDefaultCharExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharExpr v; };
struct ErrLabel { ErrLabel(ErrLabel &&) = default; ErrLabel &operator=(ErrLabel &&) = default; ErrLabel(const ErrLabel &) = delete; ErrLabel &operator=(const ErrLabel &) = delete; ErrLabel() = delete; ErrLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };

struct ConnectSpec {
  template <typename A, typename = common::NoLvalue<A>> ConnectSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ConnectSpec(ConnectSpec &&) = default; ConnectSpec &operator=(ConnectSpec &&) = default; ConnectSpec(const ConnectSpec &) = delete; ConnectSpec &operator=(const ConnectSpec &) = delete; ConnectSpec() = delete;
  struct CharExpr {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }


    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Recl { Recl(Recl &&) = default; Recl &operator=(Recl &&) = default; Recl(const Recl &) = delete; Recl &operator=(const Recl &) = delete; Recl() = delete; Recl(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Newunit { Newunit(Newunit &&) = default; Newunit &operator=(Newunit &&) = default; Newunit(const Newunit &) = delete; Newunit &operator=(const Newunit &) = delete; Newunit() = delete; Newunit(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<FileUnitNumber, FileNameExpr, CharExpr, MsgVariable,
      StatVariable, Recl, Newunit, ErrLabel, StatusExpr>
      u;
};


struct OpenStmt { OpenStmt(OpenStmt &&) = default; OpenStmt &operator=(OpenStmt &&) = default; OpenStmt(const OpenStmt &) = delete; OpenStmt &operator=(const OpenStmt &) = delete; OpenStmt() = delete; OpenStmt(std::list<ConnectSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ConnectSpec> v; };






struct CloseStmt {
  struct CloseSpec {
    template <typename A, typename = common::NoLvalue<A>> CloseSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CloseSpec(CloseSpec &&) = default; CloseSpec &operator=(CloseSpec &&) = default; CloseSpec(const CloseSpec &) = delete; CloseSpec &operator=(const CloseSpec &) = delete; CloseSpec() = delete;
    std::variant<FileUnitNumber, StatVariable, MsgVariable, ErrLabel,
        StatusExpr>
        u;
  };
  CloseStmt(CloseStmt &&) = default; CloseStmt &operator=(CloseStmt &&) = default; CloseStmt(const CloseStmt &) = delete; CloseStmt &operator=(const CloseStmt &) = delete; CloseStmt() = delete; CloseStmt(std::list<CloseSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<CloseSpec> v;
};



struct Format {
  template <typename A, typename = common::NoLvalue<A>> Format(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Format(Format &&) = default; Format &operator=(Format &&) = default; Format(const Format &) = delete; Format &operator=(const Format &) = delete; Format() = delete;
  std::variant<Expr, Label, Star> u;
};


struct IdVariable { IdVariable(IdVariable &&) = default; IdVariable &operator=(IdVariable &&) = default; IdVariable(const IdVariable &) = delete; IdVariable &operator=(const IdVariable &) = delete; IdVariable() = delete; IdVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
# 2727 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct EndLabel { EndLabel(EndLabel &&) = default; EndLabel &operator=(EndLabel &&) = default; EndLabel(const EndLabel &) = delete; EndLabel &operator=(const EndLabel &) = delete; EndLabel() = delete; EndLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct EorLabel { EorLabel(EorLabel &&) = default; EorLabel &operator=(EorLabel &&) = default; EorLabel(const EorLabel &) = delete; EorLabel &operator=(const EorLabel &) = delete; EorLabel() = delete; EorLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct IoControlSpec {
  template <typename A, typename = common::NoLvalue<A>> IoControlSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoControlSpec(IoControlSpec &&) = default; IoControlSpec &operator=(IoControlSpec &&) = default; IoControlSpec(const IoControlSpec &) = delete; IoControlSpec &operator=(const IoControlSpec &) = delete; IoControlSpec() = delete;
  struct CharExpr {
    enum class Kind { Advance, Blank, Decimal, Delim, Pad, Round, Sign }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Asynchronous { Asynchronous(Asynchronous &&) = default; Asynchronous &operator=(Asynchronous &&) = default; Asynchronous(const Asynchronous &) = delete; Asynchronous &operator=(const Asynchronous &) = delete; Asynchronous() = delete; Asynchronous(ScalarDefaultCharConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharConstantExpr v; };
  struct Pos { Pos(Pos &&) = default; Pos &operator=(Pos &&) = default; Pos(const Pos &) = delete; Pos &operator=(const Pos &) = delete; Pos() = delete; Pos(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Rec { Rec(Rec &&) = default; Rec &operator=(Rec &&) = default; Rec(const Rec &) = delete; Rec &operator=(const Rec &) = delete; Rec() = delete; Rec(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Size { Size(Size &&) = default; Size &operator=(Size &&) = default; Size(const Size &) = delete; Size &operator=(const Size &) = delete; Size() = delete; Size(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<IoUnit, Format, Name, CharExpr, Asynchronous, EndLabel, EorLabel,
      ErrLabel, IdVariable, MsgVariable, StatVariable, Pos, Rec, Size>
      u;
};


struct InputItem {
  template <typename A, typename = common::NoLvalue<A>> InputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InputItem(InputItem &&) = default; InputItem &operator=(InputItem &&) = default; InputItem(const InputItem &) = delete; InputItem &operator=(const InputItem &) = delete; InputItem() = delete;
  std::variant<Variable, common::Indirection<InputImpliedDo>> u;
};




struct ReadStmt {
  ReadStmt(ReadStmt &&) = default; ReadStmt &operator=(ReadStmt &&) = default; ReadStmt(const ReadStmt &) = delete; ReadStmt &operator=(const ReadStmt &) = delete; ReadStmt() = delete;
  ReadStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<InputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;


  std::list<IoControlSpec> controls;
  std::list<InputItem> items;
};


struct OutputItem {
  template <typename A, typename = common::NoLvalue<A>> OutputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OutputItem(OutputItem &&) = default; OutputItem &operator=(OutputItem &&) = default; OutputItem(const OutputItem &) = delete; OutputItem &operator=(const OutputItem &) = delete; OutputItem() = delete;
  std::variant<Expr, common::Indirection<OutputImpliedDo>> u;
};


struct WriteStmt {
  WriteStmt(WriteStmt &&) = default; WriteStmt &operator=(WriteStmt &&) = default; WriteStmt(const WriteStmt &) = delete; WriteStmt &operator=(const WriteStmt &) = delete; WriteStmt() = delete;
  WriteStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<OutputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;

  std::list<IoControlSpec> controls;
  std::list<OutputItem> items;
};


struct PrintStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PrintStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PrintStmt(PrintStmt &&) = default; PrintStmt &operator=(PrintStmt &&) = default; PrintStmt(const PrintStmt &) = delete; PrintStmt &operator=(const PrintStmt &) = delete; PrintStmt() = delete;
  std::tuple<Format, std::list<OutputItem>> t;
};



using IoImpliedDoControl = LoopBounds<DoVariable, ScalarIntExpr>;



struct InputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InputImpliedDo(InputImpliedDo &&) = default; InputImpliedDo &operator=(InputImpliedDo &&) = default; InputImpliedDo(const InputImpliedDo &) = delete; InputImpliedDo &operator=(const InputImpliedDo &) = delete; InputImpliedDo() = delete;
  std::tuple<std::list<InputItem>, IoImpliedDoControl> t;
};

struct OutputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OutputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OutputImpliedDo(OutputImpliedDo &&) = default; OutputImpliedDo &operator=(OutputImpliedDo &&) = default; OutputImpliedDo(const OutputImpliedDo &) = delete; OutputImpliedDo &operator=(const OutputImpliedDo &) = delete; OutputImpliedDo() = delete;
  std::tuple<std::list<OutputItem>, IoImpliedDoControl> t;
};





struct IdExpr { IdExpr(IdExpr &&) = default; IdExpr &operator=(IdExpr &&) = default; IdExpr(const IdExpr &) = delete; IdExpr &operator=(const IdExpr &) = delete; IdExpr() = delete; IdExpr(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct WaitSpec {
  template <typename A, typename = common::NoLvalue<A>> WaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WaitSpec(WaitSpec &&) = default; WaitSpec &operator=(WaitSpec &&) = default; WaitSpec(const WaitSpec &) = delete; WaitSpec &operator=(const WaitSpec &) = delete; WaitSpec() = delete;
  std::variant<FileUnitNumber, EndLabel, EorLabel, ErrLabel, IdExpr,
      MsgVariable, StatVariable>
      u;
};


struct WaitStmt { WaitStmt(WaitStmt &&) = default; WaitStmt &operator=(WaitStmt &&) = default; WaitStmt(const WaitStmt &) = delete; WaitStmt &operator=(const WaitStmt &) = delete; WaitStmt() = delete; WaitStmt(std::list<WaitSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<WaitSpec> v; };







struct PositionOrFlushSpec {
  template <typename A, typename = common::NoLvalue<A>> PositionOrFlushSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PositionOrFlushSpec(PositionOrFlushSpec &&) = default; PositionOrFlushSpec &operator=(PositionOrFlushSpec &&) = default; PositionOrFlushSpec(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec &operator=(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec() = delete;
  std::variant<FileUnitNumber, MsgVariable, StatVariable, ErrLabel> u;
};



struct BackspaceStmt { BackspaceStmt(BackspaceStmt &&) = default; BackspaceStmt &operator=(BackspaceStmt &&) = default; BackspaceStmt(const BackspaceStmt &) = delete; BackspaceStmt &operator=(const BackspaceStmt &) = delete; BackspaceStmt() = delete; BackspaceStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };



struct EndfileStmt { EndfileStmt(EndfileStmt &&) = default; EndfileStmt &operator=(EndfileStmt &&) = default; EndfileStmt(const EndfileStmt &) = delete; EndfileStmt &operator=(const EndfileStmt &) = delete; EndfileStmt() = delete; EndfileStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct RewindStmt { RewindStmt(RewindStmt &&) = default; RewindStmt &operator=(RewindStmt &&) = default; RewindStmt(const RewindStmt &) = delete; RewindStmt &operator=(const RewindStmt &) = delete; RewindStmt() = delete; RewindStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct FlushStmt { FlushStmt(FlushStmt &&) = default; FlushStmt &operator=(FlushStmt &&) = default; FlushStmt(const FlushStmt &) = delete; FlushStmt &operator=(const FlushStmt &) = delete; FlushStmt() = delete; FlushStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };
# 2887 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct InquireSpec {
  template <typename A, typename = common::NoLvalue<A>> InquireSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireSpec(InquireSpec &&) = default; InquireSpec &operator=(InquireSpec &&) = default; InquireSpec(const InquireSpec &) = delete; InquireSpec &operator=(const InquireSpec &) = delete; InquireSpec() = delete;
  struct CharVar {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }



    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharVar(CharVar &&) = default; CharVar &operator=(CharVar &&) = default; CharVar(const CharVar &) = delete; CharVar &operator=(const CharVar &) = delete; CharVar() = delete;
    std::tuple<Kind, ScalarDefaultCharVariable> t;
  };
  struct IntVar {
    enum class Kind { Iostat, Nextrec, Number, Pos, Recl, Size }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Iostat, Nextrec, Number, Pos, Recl, Size")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Iostat, Nextrec, Number, Pos, Recl, Size")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntVar(IntVar &&) = default; IntVar &operator=(IntVar &&) = default; IntVar(const IntVar &) = delete; IntVar &operator=(const IntVar &) = delete; IntVar() = delete;
    std::tuple<Kind, ScalarIntVariable> t;
  };
  struct LogVar {
    enum class Kind { Exist, Named, Opened, Pending }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Exist, Named, Opened, Pending")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Exist, Named, Opened, Pending")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> LogVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LogVar(LogVar &&) = default; LogVar &operator=(LogVar &&) = default; LogVar(const LogVar &) = delete; LogVar &operator=(const LogVar &) = delete; LogVar() = delete;
    std::tuple<Kind, Scalar<Logical<Variable>>> t;
  };
  std::variant<FileUnitNumber, FileNameExpr, CharVar, IntVar, LogVar, IdExpr,
      ErrLabel>
      u;
};




struct InquireStmt {
  template <typename A, typename = common::NoLvalue<A>> InquireStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireStmt(InquireStmt &&) = default; InquireStmt &operator=(InquireStmt &&) = default; InquireStmt(const InquireStmt &) = delete; InquireStmt &operator=(const InquireStmt &) = delete; InquireStmt() = delete;
  struct Iolength {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Iolength(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Iolength(Iolength &&) = default; Iolength &operator=(Iolength &&) = default; Iolength(const Iolength &) = delete; Iolength &operator=(const Iolength &) = delete; Iolength() = delete;
    std::tuple<ScalarIntVariable, std::list<OutputItem>> t;
  };
  std::variant<std::list<InquireSpec>, Iolength> u;
};


struct FormatStmt { FormatStmt(FormatStmt &&) = default; FormatStmt &operator=(FormatStmt &&) = default; FormatStmt(const FormatStmt &) = delete; FormatStmt &operator=(const FormatStmt &) = delete; FormatStmt() = delete; FormatStmt(format::FormatSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; format::FormatSpecification v; };


struct ProgramStmt { ProgramStmt(ProgramStmt &&) = default; ProgramStmt &operator=(ProgramStmt &&) = default; ProgramStmt(const ProgramStmt &) = delete; ProgramStmt &operator=(const ProgramStmt &) = delete; ProgramStmt() = delete; ProgramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndProgramStmt { EndProgramStmt(EndProgramStmt &&) = default; EndProgramStmt &operator=(EndProgramStmt &&) = default; EndProgramStmt(const EndProgramStmt &) = delete; EndProgramStmt &operator=(const EndProgramStmt &) = delete; EndProgramStmt() = delete; EndProgramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct MainProgram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MainProgram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MainProgram(MainProgram &&) = default; MainProgram &operator=(MainProgram &&) = default; MainProgram(const MainProgram &) = delete; MainProgram &operator=(const MainProgram &) = delete; MainProgram() = delete;
  std::tuple<std::optional<Statement<ProgramStmt>>, SpecificationPart,
      ExecutionPart, std::optional<InternalSubprogramPart>,
      Statement<EndProgramStmt>>
      t;
};


struct ModuleStmt { ModuleStmt(ModuleStmt &&) = default; ModuleStmt &operator=(ModuleStmt &&) = default; ModuleStmt(const ModuleStmt &) = delete; ModuleStmt &operator=(const ModuleStmt &) = delete; ModuleStmt() = delete; ModuleStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };




struct ModuleSubprogram {
  template <typename A, typename = common::NoLvalue<A>> ModuleSubprogram(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ModuleSubprogram(ModuleSubprogram &&) = default; ModuleSubprogram &operator=(ModuleSubprogram &&) = default; ModuleSubprogram(const ModuleSubprogram &) = delete; ModuleSubprogram &operator=(const ModuleSubprogram &) = delete; ModuleSubprogram() = delete;
  std::variant<common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>,
      common::Indirection<SeparateModuleSubprogram>,
      common::Indirection<CompilerDirective>>
      u;
};


struct ModuleSubprogramPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ModuleSubprogramPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ModuleSubprogramPart(ModuleSubprogramPart &&) = default; ModuleSubprogramPart &operator=(ModuleSubprogramPart &&) = default; ModuleSubprogramPart(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart &operator=(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart() = delete;
  std::tuple<Statement<ContainsStmt>, std::list<ModuleSubprogram>> t;
};


struct EndModuleStmt { EndModuleStmt(EndModuleStmt &&) = default; EndModuleStmt &operator=(EndModuleStmt &&) = default; EndModuleStmt(const EndModuleStmt &) = delete; EndModuleStmt &operator=(const EndModuleStmt &) = delete; EndModuleStmt() = delete; EndModuleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Module {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Module(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Module(Module &&) = default; Module &operator=(Module &&) = default; Module(const Module &) = delete; Module &operator=(const Module &) = delete; Module() = delete;
  std::tuple<Statement<ModuleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndModuleStmt>>
      t;
};





struct Rename {
  template <typename A, typename = common::NoLvalue<A>> Rename(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rename(Rename &&) = default; Rename &operator=(Rename &&) = default; Rename(const Rename &) = delete; Rename &operator=(const Rename &) = delete; Rename() = delete;
  struct Names {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Names(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Names(Names &&) = default; Names &operator=(Names &&) = default; Names(const Names &) = delete; Names &operator=(const Names &) = delete; Names() = delete;
    std::tuple<Name, Name> t;
  };
  struct Operators {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Operators(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Operators(Operators &&) = default; Operators &operator=(Operators &&) = default; Operators(const Operators &) = delete; Operators &operator=(const Operators &) = delete; Operators() = delete;
    std::tuple<DefinedOpName, DefinedOpName> t;
  };
  std::variant<Names, Operators> u;
};


struct ParentIdentifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ParentIdentifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ParentIdentifier(ParentIdentifier &&) = default; ParentIdentifier &operator=(ParentIdentifier &&) = default; ParentIdentifier(const ParentIdentifier &) = delete; ParentIdentifier &operator=(const ParentIdentifier &) = delete; ParentIdentifier() = delete;
  std::tuple<Name, std::optional<Name>> t;
};


struct SubmoduleStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubmoduleStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubmoduleStmt(SubmoduleStmt &&) = default; SubmoduleStmt &operator=(SubmoduleStmt &&) = default; SubmoduleStmt(const SubmoduleStmt &) = delete; SubmoduleStmt &operator=(const SubmoduleStmt &) = delete; SubmoduleStmt() = delete;
  std::tuple<ParentIdentifier, Name> t;
};


struct EndSubmoduleStmt { EndSubmoduleStmt(EndSubmoduleStmt &&) = default; EndSubmoduleStmt &operator=(EndSubmoduleStmt &&) = default; EndSubmoduleStmt(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt &operator=(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt() = delete; EndSubmoduleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Submodule {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Submodule(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Submodule(Submodule &&) = default; Submodule &operator=(Submodule &&) = default; Submodule(const Submodule &) = delete; Submodule &operator=(const Submodule &) = delete; Submodule() = delete;
  std::tuple<Statement<SubmoduleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndSubmoduleStmt>>
      t;
};


struct BlockDataStmt { BlockDataStmt(BlockDataStmt &&) = default; BlockDataStmt &operator=(BlockDataStmt &&) = default; BlockDataStmt(const BlockDataStmt &) = delete; BlockDataStmt &operator=(const BlockDataStmt &) = delete; BlockDataStmt() = delete; BlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockDataStmt { EndBlockDataStmt(EndBlockDataStmt &&) = default; EndBlockDataStmt &operator=(EndBlockDataStmt &&) = default; EndBlockDataStmt(const EndBlockDataStmt &) = delete; EndBlockDataStmt &operator=(const EndBlockDataStmt &) = delete; EndBlockDataStmt() = delete; EndBlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct BlockData {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockData(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockData(BlockData &&) = default; BlockData &operator=(BlockData &&) = default; BlockData(const BlockData &) = delete; BlockData &operator=(const BlockData &) = delete; BlockData() = delete;
  std::tuple<Statement<BlockDataStmt>, SpecificationPart,
      Statement<EndBlockDataStmt>>
      t;
};







struct GenericSpec {
  template <typename A, typename = common::NoLvalue<A>> GenericSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; GenericSpec(GenericSpec &&) = default; GenericSpec &operator=(GenericSpec &&) = default; GenericSpec(const GenericSpec &) = delete; GenericSpec &operator=(const GenericSpec &) = delete; GenericSpec() = delete;
  struct Assignment { Assignment() {} Assignment(const Assignment &) {} Assignment(Assignment &&) {} Assignment &operator=(const Assignment &) { return *this; }; Assignment &operator=(Assignment &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadFormatted { ReadFormatted() {} ReadFormatted(const ReadFormatted &) {} ReadFormatted(ReadFormatted &&) {} ReadFormatted &operator=(const ReadFormatted &) { return *this; }; ReadFormatted &operator=(ReadFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadUnformatted { ReadUnformatted() {} ReadUnformatted(const ReadUnformatted &) {} ReadUnformatted(ReadUnformatted &&) {} ReadUnformatted &operator=(const ReadUnformatted &) { return *this; }; ReadUnformatted &operator=(ReadUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteFormatted { WriteFormatted() {} WriteFormatted(const WriteFormatted &) {} WriteFormatted(WriteFormatted &&) {} WriteFormatted &operator=(const WriteFormatted &) { return *this; }; WriteFormatted &operator=(WriteFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteUnformatted { WriteUnformatted() {} WriteUnformatted(const WriteUnformatted &) {} WriteUnformatted(WriteUnformatted &&) {} WriteUnformatted &operator=(const WriteUnformatted &) { return *this; }; WriteUnformatted &operator=(WriteUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  CharBlock source;
  std::variant<Name, DefinedOperator, Assignment, ReadFormatted,
      ReadUnformatted, WriteFormatted, WriteUnformatted>
      u;
};



struct GenericStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> GenericStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; GenericStmt(GenericStmt &&) = default; GenericStmt &operator=(GenericStmt &&) = default; GenericStmt(const GenericStmt &) = delete; GenericStmt &operator=(const GenericStmt &) = delete; GenericStmt() = delete;
  std::tuple<std::optional<AccessSpec>, GenericSpec, std::list<Name>> t;
};


struct InterfaceStmt {
  template <typename A, typename = common::NoLvalue<A>> InterfaceStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceStmt(InterfaceStmt &&) = default; InterfaceStmt &operator=(InterfaceStmt &&) = default; InterfaceStmt(const InterfaceStmt &) = delete; InterfaceStmt &operator=(const InterfaceStmt &) = delete; InterfaceStmt() = delete;

  InterfaceStmt(Abstract x) : u{x} {}

  std::variant<std::optional<GenericSpec>, Abstract> u;
};



struct Only {
  template <typename A, typename = common::NoLvalue<A>> Only(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Only(Only &&) = default; Only &operator=(Only &&) = default; Only(const Only &) = delete; Only &operator=(const Only &) = delete; Only() = delete;
  std::variant<common::Indirection<GenericSpec>, Name, Rename> u;
};





struct UseStmt {
  UseStmt(UseStmt &&) = default; UseStmt &operator=(UseStmt &&) = default; UseStmt(const UseStmt &) = delete; UseStmt &operator=(const UseStmt &) = delete; UseStmt() = delete;
  enum class ModuleNature { Intrinsic, Non_Intrinsic }; [[maybe_unused]] static constexpr std::size_t ModuleNature_enumSize{ ::Fortran::common::CountEnumNames("Intrinsic, Non_Intrinsic")}; [[maybe_unused]] static inline std::size_t EnumToInt(ModuleNature e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(ModuleNature e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ModuleNature_enumSize>("Intrinsic, Non_Intrinsic")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachModuleNature(std::function<void(ModuleNature)> f) { for (std::size_t i{0}; i < ModuleNature_enumSize; ++i) { f(static_cast<ModuleNature>(i)); } }
  template <typename A>
  UseStmt(std::optional<ModuleNature> &&nat, Name &&n, std::list<A> &&x)
      : nature(std::move(nat)), moduleName(std::move(n)), u(std::move(x)) {}
  std::optional<ModuleNature> nature;
  Name moduleName;
  std::variant<std::list<Rename>, std::list<Only>> u;
};




struct ProcAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ProcAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcAttrSpec(ProcAttrSpec &&) = default; ProcAttrSpec &operator=(ProcAttrSpec &&) = default; ProcAttrSpec(const ProcAttrSpec &) = delete; ProcAttrSpec &operator=(const ProcAttrSpec &) = delete; ProcAttrSpec() = delete;
  std::variant<AccessSpec, LanguageBindingSpec, IntentSpec, Optional, Pointer,
      Protected, Save>
      u;
};




struct ProcedureDeclarationStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureDeclarationStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureDeclarationStmt(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt &operator=(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt &operator=(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt() = delete;
  std::tuple<std::optional<ProcInterface>, std::list<ProcAttrSpec>,
      std::list<ProcDecl>>
      t;
};






struct PrefixSpec {
  template <typename A, typename = common::NoLvalue<A>> PrefixSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PrefixSpec(PrefixSpec &&) = default; PrefixSpec &operator=(PrefixSpec &&) = default; PrefixSpec(const PrefixSpec &) = delete; PrefixSpec &operator=(const PrefixSpec &) = delete; PrefixSpec() = delete;
  struct Elemental { Elemental() {} Elemental(const Elemental &) {} Elemental(Elemental &&) {} Elemental &operator=(const Elemental &) { return *this; }; Elemental &operator=(Elemental &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Impure { Impure() {} Impure(const Impure &) {} Impure(Impure &&) {} Impure &operator=(const Impure &) { return *this; }; Impure &operator=(Impure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Module { Module() {} Module(const Module &) {} Module(Module &&) {} Module &operator=(const Module &) { return *this; }; Module &operator=(Module &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Non_Recursive { Non_Recursive() {} Non_Recursive(const Non_Recursive &) {} Non_Recursive(Non_Recursive &&) {} Non_Recursive &operator=(const Non_Recursive &) { return *this; }; Non_Recursive &operator=(Non_Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Pure { Pure() {} Pure(const Pure &) {} Pure(Pure &&) {} Pure &operator=(const Pure &) { return *this; }; Pure &operator=(Pure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Recursive { Recursive() {} Recursive(const Recursive &) {} Recursive(Recursive &&) {} Recursive &operator=(const Recursive &) { return *this; }; Recursive &operator=(Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Attributes { Attributes(Attributes &&) = default; Attributes &operator=(Attributes &&) = default; Attributes(const Attributes &) = delete; Attributes &operator=(const Attributes &) = delete; Attributes() = delete; Attributes(std::list<common::CUDASubprogramAttrs> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<common::CUDASubprogramAttrs> v; };
  struct Launch_Bounds { Launch_Bounds(Launch_Bounds &&) = default; Launch_Bounds &operator=(Launch_Bounds &&) = default; Launch_Bounds(const Launch_Bounds &) = delete; Launch_Bounds &operator=(const Launch_Bounds &) = delete; Launch_Bounds() = delete; Launch_Bounds(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  struct Cluster_Dims { Cluster_Dims(Cluster_Dims &&) = default; Cluster_Dims &operator=(Cluster_Dims &&) = default; Cluster_Dims(const Cluster_Dims &) = delete; Cluster_Dims &operator=(const Cluster_Dims &) = delete; Cluster_Dims() = delete; Cluster_Dims(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  std::variant<DeclarationTypeSpec, Elemental, Impure, Module, Non_Recursive,
      Pure, Recursive, Attributes, Launch_Bounds, Cluster_Dims>
      u;
};




struct Suffix {
  Suffix(Suffix &&) = default; Suffix &operator=(Suffix &&) = default; Suffix(const Suffix &) = delete; Suffix &operator=(const Suffix &) = delete; Suffix() = delete;
  Suffix(LanguageBindingSpec &&lbs, std::optional<Name> &&rn)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  Suffix(Name &&rn, std::optional<LanguageBindingSpec> &&lbs)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  std::optional<LanguageBindingSpec> binding;
  std::optional<Name> resultName;
};





struct FunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionStmt(FunctionStmt &&) = default; FunctionStmt &operator=(FunctionStmt &&) = default; FunctionStmt(const FunctionStmt &) = delete; FunctionStmt &operator=(const FunctionStmt &) = delete; FunctionStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<Name>,
      std::optional<Suffix>>
      t;
};


struct EndFunctionStmt { EndFunctionStmt(EndFunctionStmt &&) = default; EndFunctionStmt &operator=(EndFunctionStmt &&) = default; EndFunctionStmt(const EndFunctionStmt &) = delete; EndFunctionStmt &operator=(const EndFunctionStmt &) = delete; EndFunctionStmt() = delete; EndFunctionStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct DummyArg {
  template <typename A, typename = common::NoLvalue<A>> DummyArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DummyArg(DummyArg &&) = default; DummyArg &operator=(DummyArg &&) = default; DummyArg(const DummyArg &) = delete; DummyArg &operator=(const DummyArg &) = delete; DummyArg() = delete;
  std::variant<Name, Star> u;
};




struct SubroutineStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineStmt(SubroutineStmt &&) = default; SubroutineStmt &operator=(SubroutineStmt &&) = default; SubroutineStmt(const SubroutineStmt &) = delete; SubroutineStmt &operator=(const SubroutineStmt &) = delete; SubroutineStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<DummyArg>,
      std::optional<LanguageBindingSpec>>
      t;
};


struct EndSubroutineStmt { EndSubroutineStmt(EndSubroutineStmt &&) = default; EndSubroutineStmt &operator=(EndSubroutineStmt &&) = default; EndSubroutineStmt(const EndSubroutineStmt &) = delete; EndSubroutineStmt &operator=(const EndSubroutineStmt &) = delete; EndSubroutineStmt() = delete; EndSubroutineStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct InterfaceBody {
  template <typename A, typename = common::NoLvalue<A>> InterfaceBody(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceBody(InterfaceBody &&) = default; InterfaceBody &operator=(InterfaceBody &&) = default; InterfaceBody(const InterfaceBody &) = delete; InterfaceBody &operator=(const InterfaceBody &) = delete; InterfaceBody() = delete;
  struct Function {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Function(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Function(Function &&) = default; Function &operator=(Function &&) = default; Function(const Function &) = delete; Function &operator=(const Function &) = delete; Function() = delete;
    std::tuple<Statement<FunctionStmt>, common::Indirection<SpecificationPart>,
        Statement<EndFunctionStmt>>
        t;
  };
  struct Subroutine {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Subroutine(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Subroutine(Subroutine &&) = default; Subroutine &operator=(Subroutine &&) = default; Subroutine(const Subroutine &) = delete; Subroutine &operator=(const Subroutine &) = delete; Subroutine() = delete;
    std::tuple<Statement<SubroutineStmt>,
        common::Indirection<SpecificationPart>, Statement<EndSubroutineStmt>>
        t;
  };
  std::variant<Function, Subroutine> u;
};


struct ProcedureStmt {
  enum class Kind { ModuleProcedure, Procedure }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("ModuleProcedure, Procedure")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("ModuleProcedure, Procedure")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureStmt(ProcedureStmt &&) = default; ProcedureStmt &operator=(ProcedureStmt &&) = default; ProcedureStmt(const ProcedureStmt &) = delete; ProcedureStmt &operator=(const ProcedureStmt &) = delete; ProcedureStmt() = delete;
  std::tuple<Kind, std::list<Name>> t;
};


struct InterfaceSpecification {
  template <typename A, typename = common::NoLvalue<A>> InterfaceSpecification(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceSpecification(InterfaceSpecification &&) = default; InterfaceSpecification &operator=(InterfaceSpecification &&) = default; InterfaceSpecification(const InterfaceSpecification &) = delete; InterfaceSpecification &operator=(const InterfaceSpecification &) = delete; InterfaceSpecification() = delete;
  std::variant<InterfaceBody, Statement<ProcedureStmt>> u;
};


struct EndInterfaceStmt { EndInterfaceStmt(EndInterfaceStmt &&) = default; EndInterfaceStmt &operator=(EndInterfaceStmt &&) = default; EndInterfaceStmt(const EndInterfaceStmt &) = delete; EndInterfaceStmt &operator=(const EndInterfaceStmt &) = delete; EndInterfaceStmt() = delete; EndInterfaceStmt(std::optional<GenericSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<GenericSpec> v; };



struct InterfaceBlock {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InterfaceBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InterfaceBlock(InterfaceBlock &&) = default; InterfaceBlock &operator=(InterfaceBlock &&) = default; InterfaceBlock(const InterfaceBlock &) = delete; InterfaceBlock &operator=(const InterfaceBlock &) = delete; InterfaceBlock() = delete;
  std::tuple<Statement<InterfaceStmt>, std::list<InterfaceSpecification>,
      Statement<EndInterfaceStmt>>
      t;
};


struct ExternalStmt { ExternalStmt(ExternalStmt &&) = default; ExternalStmt &operator=(ExternalStmt &&) = default; ExternalStmt(const ExternalStmt &) = delete; ExternalStmt &operator=(const ExternalStmt &) = delete; ExternalStmt() = delete; ExternalStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };


struct IntrinsicStmt { IntrinsicStmt(IntrinsicStmt &&) = default; IntrinsicStmt &operator=(IntrinsicStmt &&) = default; IntrinsicStmt(const IntrinsicStmt &) = delete; IntrinsicStmt &operator=(const IntrinsicStmt &) = delete; IntrinsicStmt() = delete; IntrinsicStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct ProcedureDesignator {
  template <typename A, typename = common::NoLvalue<A>> ProcedureDesignator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcedureDesignator(ProcedureDesignator &&) = default; ProcedureDesignator &operator=(ProcedureDesignator &&) = default; ProcedureDesignator(const ProcedureDesignator &) = delete; ProcedureDesignator &operator=(const ProcedureDesignator &) = delete; ProcedureDesignator() = delete;
  std::variant<Name, ProcComponentRef> u;
};


struct AltReturnSpec { AltReturnSpec(AltReturnSpec &&) = default; AltReturnSpec &operator=(AltReturnSpec &&) = default; AltReturnSpec(const AltReturnSpec &) = delete; AltReturnSpec &operator=(const AltReturnSpec &) = delete; AltReturnSpec() = delete; AltReturnSpec(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };




struct ActualArg {
  struct PercentRef { PercentRef(PercentRef &&) = default; PercentRef &operator=(PercentRef &&) = default; PercentRef(const PercentRef &) = delete; PercentRef &operator=(const PercentRef &) = delete; PercentRef() = delete; PercentRef(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };
  struct PercentVal { PercentVal(PercentVal &&) = default; PercentVal &operator=(PercentVal &&) = default; PercentVal(const PercentVal &) = delete; PercentVal &operator=(const PercentVal &) = delete; PercentVal() = delete; PercentVal(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };
  template <typename A, typename = common::NoLvalue<A>> ActualArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ActualArg(ActualArg &&) = default; ActualArg &operator=(ActualArg &&) = default; ActualArg(const ActualArg &) = delete; ActualArg &operator=(const ActualArg &) = delete; ActualArg() = delete;
  ActualArg(Expr &&x) : u{common::Indirection<Expr>(std::move(x))} {}
  std::variant<common::Indirection<Expr>, AltReturnSpec, PercentRef, PercentVal>
      u;
};


struct ActualArgSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ActualArgSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ActualArgSpec(ActualArgSpec &&) = default; ActualArgSpec &operator=(ActualArgSpec &&) = default; ActualArgSpec(const ActualArgSpec &) = delete; ActualArgSpec &operator=(const ActualArgSpec &) = delete; ActualArgSpec() = delete;
  std::tuple<std::optional<Keyword>, ActualArg> t;
};



struct Call {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Call(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Call(Call &&) = default; Call &operator=(Call &&) = default; Call(const Call &) = delete; Call &operator=(const Call &) = delete; Call() = delete;
  std::tuple<ProcedureDesignator, std::list<ActualArgSpec>> t;
};

struct FunctionReference {
  FunctionReference(FunctionReference &&) = default; FunctionReference &operator=(FunctionReference &&) = default; FunctionReference(const FunctionReference &) = delete; FunctionReference &operator=(const FunctionReference &) = delete; FunctionReference() = delete; FunctionReference(Call &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Call v;
  CharBlock source;
  Designator ConvertToArrayElementRef();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
};





struct CallStmt {
  CallStmt(CallStmt &&) = default; CallStmt &operator=(CallStmt &&) = default; CallStmt(const CallStmt &) = delete; CallStmt &operator=(const CallStmt &) = delete; CallStmt() = delete;
  struct StarOrExpr { StarOrExpr(StarOrExpr &&) = default; StarOrExpr &operator=(StarOrExpr &&) = default; StarOrExpr(const StarOrExpr &) = delete; StarOrExpr &operator=(const StarOrExpr &) = delete; StarOrExpr() = delete; StarOrExpr(std::optional<ScalarExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarExpr> v; };
  struct Chevrons {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Chevrons(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Chevrons(Chevrons &&) = default; Chevrons &operator=(Chevrons &&) = default; Chevrons(const Chevrons &) = delete; Chevrons &operator=(const Chevrons &) = delete; Chevrons() = delete;
    std::tuple<StarOrExpr, ScalarExpr, std::optional<ScalarIntExpr>,
        std::optional<ScalarIntExpr>>
        t;
  };
  explicit CallStmt(ProcedureDesignator &&pd, std::optional<Chevrons> &&ch,
      std::list<ActualArgSpec> &&args)
      : call{std::move(pd), std::move(args)}, chevrons{std::move(ch)} {}
  Call call;
  std::optional<Chevrons> chevrons;
  CharBlock source;
  mutable common::ForwardOwningPointer<evaluate::ProcedureRef>
      typedCall;
};




struct FunctionSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionSubprogram(FunctionSubprogram &&) = default; FunctionSubprogram &operator=(FunctionSubprogram &&) = default; FunctionSubprogram(const FunctionSubprogram &) = delete; FunctionSubprogram &operator=(const FunctionSubprogram &) = delete; FunctionSubprogram() = delete;
  std::tuple<Statement<FunctionStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndFunctionStmt>>
      t;
};




struct SubroutineSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineSubprogram(SubroutineSubprogram &&) = default; SubroutineSubprogram &operator=(SubroutineSubprogram &&) = default; SubroutineSubprogram(const SubroutineSubprogram &) = delete; SubroutineSubprogram &operator=(const SubroutineSubprogram &) = delete; SubroutineSubprogram() = delete;
  std::tuple<Statement<SubroutineStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndSubroutineStmt>>
      t;
};


struct MpSubprogramStmt { MpSubprogramStmt(MpSubprogramStmt &&) = default; MpSubprogramStmt &operator=(MpSubprogramStmt &&) = default; MpSubprogramStmt(const MpSubprogramStmt &) = delete; MpSubprogramStmt &operator=(const MpSubprogramStmt &) = delete; MpSubprogramStmt() = delete; MpSubprogramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndMpSubprogramStmt { EndMpSubprogramStmt(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt &operator=(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt &operator=(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt() = delete; EndMpSubprogramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct SeparateModuleSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SeparateModuleSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SeparateModuleSubprogram(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram &operator=(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram &operator=(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram() = delete;
  std::tuple<Statement<MpSubprogramStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndMpSubprogramStmt>>
      t;
};


struct EntryStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EntryStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EntryStmt(EntryStmt &&) = default; EntryStmt &operator=(EntryStmt &&) = default; EntryStmt(const EntryStmt &) = delete; EntryStmt &operator=(const EntryStmt &) = delete; EntryStmt() = delete;
  std::tuple<Name, std::list<DummyArg>, std::optional<Suffix>> t;
};


struct ReturnStmt { ReturnStmt(ReturnStmt &&) = default; ReturnStmt &operator=(ReturnStmt &&) = default; ReturnStmt(const ReturnStmt &) = delete; ReturnStmt &operator=(const ReturnStmt &) = delete; ReturnStmt() = delete; ReturnStmt(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };



struct StmtFunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StmtFunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StmtFunctionStmt(StmtFunctionStmt &&) = default; StmtFunctionStmt &operator=(StmtFunctionStmt &&) = default; StmtFunctionStmt(const StmtFunctionStmt &) = delete; StmtFunctionStmt &operator=(const StmtFunctionStmt &) = delete; StmtFunctionStmt() = delete;
  std::tuple<Name, std::list<Name>, Scalar<Expr>> t;
  Statement<ActionStmt> ConvertToAssignment();
};
# 3358 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct CompilerDirective {
  template <typename A, typename = common::NoLvalue<A>> CompilerDirective(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CompilerDirective(CompilerDirective &&) = default; CompilerDirective &operator=(CompilerDirective &&) = default; CompilerDirective(const CompilerDirective &) = delete; CompilerDirective &operator=(const CompilerDirective &) = delete; CompilerDirective() = delete;
  struct IgnoreTKR {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IgnoreTKR(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IgnoreTKR(IgnoreTKR &&) = default; IgnoreTKR &operator=(IgnoreTKR &&) = default; IgnoreTKR(const IgnoreTKR &) = delete; IgnoreTKR &operator=(const IgnoreTKR &) = delete; IgnoreTKR() = delete;
    std::tuple<std::optional<std::list<const char *>>, Name> t;
  };
  struct LoopCount {
    LoopCount(LoopCount &&) = default; LoopCount &operator=(LoopCount &&) = default; LoopCount(const LoopCount &) = delete; LoopCount &operator=(const LoopCount &) = delete; LoopCount() = delete; LoopCount(std::list<std::uint64_t> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<std::uint64_t> v;
  };
  struct AssumeAligned {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> AssumeAligned(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssumeAligned(AssumeAligned &&) = default; AssumeAligned &operator=(AssumeAligned &&) = default; AssumeAligned(const AssumeAligned &) = delete; AssumeAligned &operator=(const AssumeAligned &) = delete; AssumeAligned() = delete;
    std::tuple<common::Indirection<Designator>, uint64_t> t;
  };
  struct VectorAlways { VectorAlways() {} VectorAlways(const VectorAlways &) {} VectorAlways(VectorAlways &&) {} VectorAlways &operator=(const VectorAlways &) { return *this; }; VectorAlways &operator=(VectorAlways &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct NameValue {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> NameValue(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NameValue(NameValue &&) = default; NameValue &operator=(NameValue &&) = default; NameValue(const NameValue &) = delete; NameValue &operator=(const NameValue &) = delete; NameValue() = delete;
    std::tuple<Name, std::optional<std::uint64_t>> t;
  };
  struct Unroll {
    Unroll(Unroll &&) = default; Unroll &operator=(Unroll &&) = default; Unroll(const Unroll &) = delete; Unroll &operator=(const Unroll &) = delete; Unroll() = delete; Unroll(std::optional<std::uint64_t> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<std::uint64_t> v;
  };
  struct UnrollAndJam {
    UnrollAndJam(UnrollAndJam &&) = default; UnrollAndJam &operator=(UnrollAndJam &&) = default; UnrollAndJam(const UnrollAndJam &) = delete; UnrollAndJam &operator=(const UnrollAndJam &) = delete; UnrollAndJam() = delete; UnrollAndJam(std::optional<std::uint64_t> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<std::uint64_t> v;
  };
  struct NoVector { NoVector() {} NoVector(const NoVector &) {} NoVector(NoVector &&) {} NoVector &operator=(const NoVector &) { return *this; }; NoVector &operator=(NoVector &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct NoUnroll { NoUnroll() {} NoUnroll(const NoUnroll &) {} NoUnroll(NoUnroll &&) {} NoUnroll &operator=(const NoUnroll &) { return *this; }; NoUnroll &operator=(NoUnroll &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct NoUnrollAndJam { NoUnrollAndJam() {} NoUnrollAndJam(const NoUnrollAndJam &) {} NoUnrollAndJam(NoUnrollAndJam &&) {} NoUnrollAndJam &operator=(const NoUnrollAndJam &) { return *this; }; NoUnrollAndJam &operator=(NoUnrollAndJam &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Unrecognized { Unrecognized() {} Unrecognized(const Unrecognized &) {} Unrecognized(Unrecognized &&) {} Unrecognized &operator=(const Unrecognized &) { return *this; }; Unrecognized &operator=(Unrecognized &&) { return *this; }; using EmptyTrait = std::true_type; };
  CharBlock source;
  std::variant<std::list<IgnoreTKR>, LoopCount, std::list<AssumeAligned>,
      VectorAlways, std::list<NameValue>, Unroll, UnrollAndJam, Unrecognized,
      NoVector, NoUnroll, NoUnrollAndJam>
      u;
};


struct CUDAAttributesStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUDAAttributesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUDAAttributesStmt(CUDAAttributesStmt &&) = default; CUDAAttributesStmt &operator=(CUDAAttributesStmt &&) = default; CUDAAttributesStmt(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt &operator=(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt() = delete;
  std::tuple<common::CUDADataAttr, std::list<Name>> t;
};


struct BasedPointer {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BasedPointer(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BasedPointer(BasedPointer &&) = default; BasedPointer &operator=(BasedPointer &&) = default; BasedPointer(const BasedPointer &) = delete; BasedPointer &operator=(const BasedPointer &) = delete; BasedPointer() = delete;
  std::tuple<ObjectName, ObjectName, std::optional<ArraySpec>> t;
};
struct BasedPointerStmt { BasedPointerStmt(BasedPointerStmt &&) = default; BasedPointerStmt &operator=(BasedPointerStmt &&) = default; BasedPointerStmt(const BasedPointerStmt &) = delete; BasedPointerStmt &operator=(const BasedPointerStmt &) = delete; BasedPointerStmt() = delete; BasedPointerStmt(std::list<BasedPointer> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<BasedPointer> v; };

struct Union;
struct StructureDef;

struct StructureField {
  template <typename A, typename = common::NoLvalue<A>> StructureField(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StructureField(StructureField &&) = default; StructureField &operator=(StructureField &&) = default; StructureField(const StructureField &) = delete; StructureField &operator=(const StructureField &) = delete; StructureField() = delete;
  std::variant<Statement<DataComponentDefStmt>,
      common::Indirection<StructureDef>, common::Indirection<Union>>
      u;
};

struct Map {
  struct MapStmt { MapStmt() {} MapStmt(const MapStmt &) {} MapStmt(MapStmt &&) {} MapStmt &operator=(const MapStmt &) { return *this; }; MapStmt &operator=(MapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndMapStmt { EndMapStmt() {} EndMapStmt(const EndMapStmt &) {} EndMapStmt(EndMapStmt &&) {} EndMapStmt &operator=(const EndMapStmt &) { return *this; }; EndMapStmt &operator=(EndMapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Map(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete;
  std::tuple<Statement<MapStmt>, std::list<StructureField>,
      Statement<EndMapStmt>>
      t;
};

struct Union {
  struct UnionStmt { UnionStmt() {} UnionStmt(const UnionStmt &) {} UnionStmt(UnionStmt &&) {} UnionStmt &operator=(const UnionStmt &) { return *this; }; UnionStmt &operator=(UnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndUnionStmt { EndUnionStmt() {} EndUnionStmt(const EndUnionStmt &) {} EndUnionStmt(EndUnionStmt &&) {} EndUnionStmt &operator=(const EndUnionStmt &) { return *this; }; EndUnionStmt &operator=(EndUnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Union(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Union(Union &&) = default; Union &operator=(Union &&) = default; Union(const Union &) = delete; Union &operator=(const Union &) = delete; Union() = delete;
  std::tuple<Statement<UnionStmt>, std::list<Map>, Statement<EndUnionStmt>> t;
};

struct StructureStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureStmt(StructureStmt &&) = default; StructureStmt &operator=(StructureStmt &&) = default; StructureStmt(const StructureStmt &) = delete; StructureStmt &operator=(const StructureStmt &) = delete; StructureStmt() = delete;
  std::tuple<std::optional<Name>, std::list<EntityDecl>> t;
};

struct StructureDef {
  struct EndStructureStmt { EndStructureStmt() {} EndStructureStmt(const EndStructureStmt &) {} EndStructureStmt(EndStructureStmt &&) {} EndStructureStmt &operator=(const EndStructureStmt &) { return *this; }; EndStructureStmt &operator=(EndStructureStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureDef(StructureDef &&) = default; StructureDef &operator=(StructureDef &&) = default; StructureDef(const StructureDef &) = delete; StructureDef &operator=(const StructureDef &) = delete; StructureDef() = delete;
  std::tuple<Statement<StructureStmt>, std::list<StructureField>,
      Statement<EndStructureStmt>>
      t;
};



struct OldParameterStmt { OldParameterStmt(OldParameterStmt &&) = default; OldParameterStmt &operator=(OldParameterStmt &&) = default; OldParameterStmt(const OldParameterStmt &) = delete; OldParameterStmt &operator=(const OldParameterStmt &) = delete; OldParameterStmt() = delete; OldParameterStmt(std::list<NamedConstantDef> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<NamedConstantDef> v; };


struct ArithmeticIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ArithmeticIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ArithmeticIfStmt(ArithmeticIfStmt &&) = default; ArithmeticIfStmt &operator=(ArithmeticIfStmt &&) = default; ArithmeticIfStmt(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt &operator=(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt() = delete;
  std::tuple<Expr, Label, Label, Label> t;
};

struct AssignStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignStmt(AssignStmt &&) = default; AssignStmt &operator=(AssignStmt &&) = default; AssignStmt(const AssignStmt &) = delete; AssignStmt &operator=(const AssignStmt &) = delete; AssignStmt() = delete;
  std::tuple<Label, Name> t;
};

struct AssignedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignedGotoStmt(AssignedGotoStmt &&) = default; AssignedGotoStmt &operator=(AssignedGotoStmt &&) = default; AssignedGotoStmt(const AssignedGotoStmt &) = delete; AssignedGotoStmt &operator=(const AssignedGotoStmt &) = delete; AssignedGotoStmt() = delete;
  std::tuple<Name, std::list<Label>> t;
};

struct PauseStmt { PauseStmt(PauseStmt &&) = default; PauseStmt &operator=(PauseStmt &&) = default; PauseStmt(const PauseStmt &) = delete; PauseStmt &operator=(const PauseStmt &) = delete; PauseStmt() = delete; PauseStmt(std::optional<StopCode> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<StopCode> v; };
# 3483 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpClause;
struct OmpDirectiveSpecification;

struct OmpDirectiveName {

  constexpr OmpDirectiveName() = default;
  constexpr OmpDirectiveName(const OmpDirectiveName &) = default;
  constexpr OmpDirectiveName(llvm::omp::Directive x) : v(x) {}



  OmpDirectiveName(const Verbatim &name);
  using WrapperTrait = std::true_type;

  bool IsExecutionPart() const;

  CharBlock source;
  llvm::omp::Directive v{llvm::omp::Directive::OMPD_unknown};
};





struct OmpObject {
  template <typename A, typename = common::NoLvalue<A>> OmpObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpObject(OmpObject &&) = default; OmpObject &operator=(OmpObject &&) = default; OmpObject(const OmpObject &) = delete; OmpObject &operator=(const OmpObject &) = delete; OmpObject() = delete;
  std::variant<Designator, Name> u;
};

struct OmpObjectList { OmpObjectList(OmpObjectList &&) = default; OmpObjectList &operator=(OmpObjectList &&) = default; OmpObjectList(const OmpObjectList &) = delete; OmpObjectList &operator=(const OmpObjectList &) = delete; OmpObjectList() = delete; OmpObjectList(std::list<OmpObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpObject> v; };
# 3521 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpReductionIdentifier {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionIdentifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionIdentifier(OmpReductionIdentifier &&) = default; OmpReductionIdentifier &operator=(OmpReductionIdentifier &&) = default; OmpReductionIdentifier(const OmpReductionIdentifier &) = delete; OmpReductionIdentifier &operator=(const OmpReductionIdentifier &) = delete; OmpReductionIdentifier() = delete;
  std::variant<DefinedOperator, ProcedureDesignator> u;
};






struct OmpReductionCombiner {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionCombiner(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionCombiner(OmpReductionCombiner &&) = default; OmpReductionCombiner &operator=(OmpReductionCombiner &&) = default; OmpReductionCombiner(const OmpReductionCombiner &) = delete; OmpReductionCombiner &operator=(const OmpReductionCombiner &) = delete; OmpReductionCombiner() = delete;
  std::variant<AssignmentStmt, FunctionReference> u;
};

inline namespace arguments {
struct OmpTypeSpecifier {
  template <typename A, typename = common::NoLvalue<A>> OmpTypeSpecifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpTypeSpecifier(OmpTypeSpecifier &&) = default; OmpTypeSpecifier &operator=(OmpTypeSpecifier &&) = default; OmpTypeSpecifier(const OmpTypeSpecifier &) = delete; OmpTypeSpecifier &operator=(const OmpTypeSpecifier &) = delete; OmpTypeSpecifier() = delete;
  std::variant<TypeSpec, DeclarationTypeSpec> u;
};

struct OmpTypeNameList { OmpTypeNameList(OmpTypeNameList &&) = default; OmpTypeNameList &operator=(OmpTypeNameList &&) = default; OmpTypeNameList(const OmpTypeNameList &) = delete; OmpTypeNameList &operator=(const OmpTypeNameList &) = delete; OmpTypeNameList() = delete; OmpTypeNameList(std::list<OmpTypeSpecifier> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpTypeSpecifier> v; };

struct OmpLocator {
  template <typename A, typename = common::NoLvalue<A>> OmpLocator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpLocator(OmpLocator &&) = default; OmpLocator &operator=(OmpLocator &&) = default; OmpLocator(const OmpLocator &) = delete; OmpLocator &operator=(const OmpLocator &) = delete; OmpLocator() = delete;
  std::variant<OmpObject, FunctionReference> u;
};

struct OmpLocatorList { OmpLocatorList(OmpLocatorList &&) = default; OmpLocatorList &operator=(OmpLocatorList &&) = default; OmpLocatorList(const OmpLocatorList &) = delete; OmpLocatorList &operator=(const OmpLocatorList &) = delete; OmpLocatorList() = delete; OmpLocatorList(std::list<OmpLocator> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpLocator> v; };






struct OmpMapperSpecifier {

  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapperSpecifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapperSpecifier(OmpMapperSpecifier &&) = default; OmpMapperSpecifier &operator=(OmpMapperSpecifier &&) = default; OmpMapperSpecifier(const OmpMapperSpecifier &) = delete; OmpMapperSpecifier &operator=(const OmpMapperSpecifier &) = delete; OmpMapperSpecifier() = delete;
  std::tuple<std::string, TypeSpec, Name> t;
};
# 3569 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpReductionSpecifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpReductionSpecifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpReductionSpecifier(OmpReductionSpecifier &&) = default; OmpReductionSpecifier &operator=(OmpReductionSpecifier &&) = default; OmpReductionSpecifier(const OmpReductionSpecifier &) = delete; OmpReductionSpecifier &operator=(const OmpReductionSpecifier &) = delete; OmpReductionSpecifier() = delete;
  std::tuple<OmpReductionIdentifier, OmpTypeNameList,
      std::optional<OmpReductionCombiner>>
      t;
};

struct OmpArgument {
  CharBlock source;
  template <typename A, typename = common::NoLvalue<A>> OmpArgument(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpArgument(OmpArgument &&) = default; OmpArgument &operator=(OmpArgument &&) = default; OmpArgument(const OmpArgument &) = delete; OmpArgument &operator=(const OmpArgument &) = delete; OmpArgument() = delete;
  std::variant<OmpLocator,
      OmpMapperSpecifier, OmpReductionSpecifier>
      u;
};

struct OmpArgumentList {
  OmpArgumentList(OmpArgumentList &&) = default; OmpArgumentList &operator=(OmpArgumentList &&) = default; OmpArgumentList(const OmpArgumentList &) = delete; OmpArgumentList &operator=(const OmpArgumentList &) = delete; OmpArgumentList() = delete; OmpArgumentList(std::list<OmpArgument> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpArgument> v;
  CharBlock source;
};
}

inline namespace traits {
# 3605 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpTraitPropertyName {
  CharBlock source;
  OmpTraitPropertyName(OmpTraitPropertyName &&) = default; OmpTraitPropertyName &operator=(OmpTraitPropertyName &&) = default; OmpTraitPropertyName(const OmpTraitPropertyName &) = delete; OmpTraitPropertyName &operator=(const OmpTraitPropertyName &) = delete; OmpTraitPropertyName() = delete; OmpTraitPropertyName(std::string &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::string v;
};



struct OmpTraitScore {
  CharBlock source;
  OmpTraitScore(OmpTraitScore &&) = default; OmpTraitScore &operator=(OmpTraitScore &&) = default; OmpTraitScore(const OmpTraitScore &) = delete; OmpTraitScore &operator=(const OmpTraitScore &) = delete; OmpTraitScore() = delete; OmpTraitScore(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};






struct OmpTraitPropertyExtension {
  CharBlock source;
  template <typename A, typename = common::NoLvalue<A>> OmpTraitPropertyExtension(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpTraitPropertyExtension(OmpTraitPropertyExtension &&) = default; OmpTraitPropertyExtension &operator=(OmpTraitPropertyExtension &&) = default; OmpTraitPropertyExtension(const OmpTraitPropertyExtension &) = delete; OmpTraitPropertyExtension &operator=(const OmpTraitPropertyExtension &) = delete; OmpTraitPropertyExtension() = delete;
  struct Complex {
    CharBlock source;
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Complex(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Complex(Complex &&) = default; Complex &operator=(Complex &&) = default; Complex(const Complex &) = delete; Complex &operator=(const Complex &) = delete; Complex() = delete;
    std::tuple<OmpTraitPropertyName,
        std::list<common::Indirection<OmpTraitPropertyExtension>>>
        t;
  };

  std::variant<OmpTraitPropertyName, ScalarExpr, Complex> u;
};
# 3646 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpTraitProperty {
  CharBlock source;
  template <typename A, typename = common::NoLvalue<A>> OmpTraitProperty(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpTraitProperty(OmpTraitProperty &&) = default; OmpTraitProperty &operator=(OmpTraitProperty &&) = default; OmpTraitProperty(const OmpTraitProperty &) = delete; OmpTraitProperty &operator=(const OmpTraitProperty &) = delete; OmpTraitProperty() = delete;
  std::variant<OmpTraitPropertyName, common::Indirection<OmpClause>,
      ScalarExpr,
      OmpTraitPropertyExtension>
      u;
};
# 3673 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpTraitSelectorName {
  std::string ToString() const;
  CharBlock source;
  template <typename A, typename = common::NoLvalue<A>> OmpTraitSelectorName(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpTraitSelectorName(OmpTraitSelectorName &&) = default; OmpTraitSelectorName &operator=(OmpTraitSelectorName &&) = default; OmpTraitSelectorName(const OmpTraitSelectorName &) = delete; OmpTraitSelectorName &operator=(const OmpTraitSelectorName &) = delete; OmpTraitSelectorName() = delete;
  enum class Value { Arch, Atomic_Default_Mem_Order, Condition, Device_Num, Extension, Isa, Kind, Requires, Simd, Uid, Vendor }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Arch, Atomic_Default_Mem_Order, Condition, Device_Num, Extension, Isa, Kind, Requires, Simd, Uid, Vendor")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Arch, Atomic_Default_Mem_Order, Condition, Device_Num, Extension, Isa, Kind, Requires, Simd, Uid, Vendor")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }

  std::variant<Value, llvm::omp::Directive, std::string> u;
};




struct OmpTraitSelector {
  CharBlock source;
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpTraitSelector(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpTraitSelector(OmpTraitSelector &&) = default; OmpTraitSelector &operator=(OmpTraitSelector &&) = default; OmpTraitSelector(const OmpTraitSelector &) = delete; OmpTraitSelector &operator=(const OmpTraitSelector &) = delete; OmpTraitSelector() = delete;
  struct Properties {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Properties(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Properties(Properties &&) = default; Properties &operator=(Properties &&) = default; Properties(const Properties &) = delete; Properties &operator=(const Properties &) = delete; Properties() = delete;
    std::tuple<std::optional<OmpTraitScore>, std::list<OmpTraitProperty>> t;
  };
  std::tuple<OmpTraitSelectorName, std::optional<Properties>> t;
};




struct OmpTraitSetSelectorName {
  std::string ToString() const;
  CharBlock source;
  enum class Value { Construct, Device, Implementation, Target_Device, User }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Construct, Device, Implementation, Target_Device, User")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Construct, Device, Implementation, Target_Device, User")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpTraitSetSelectorName(OmpTraitSetSelectorName &&) = default; OmpTraitSetSelectorName &operator=(OmpTraitSetSelectorName &&) = default; OmpTraitSetSelectorName(const OmpTraitSetSelectorName &) = delete; OmpTraitSetSelectorName &operator=(const OmpTraitSetSelectorName &) = delete; OmpTraitSetSelectorName() = delete; OmpTraitSetSelectorName(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};



struct OmpTraitSetSelector {
  CharBlock source;
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpTraitSetSelector(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpTraitSetSelector(OmpTraitSetSelector &&) = default; OmpTraitSetSelector &operator=(OmpTraitSetSelector &&) = default; OmpTraitSetSelector(const OmpTraitSetSelector &) = delete; OmpTraitSetSelector &operator=(const OmpTraitSetSelector &) = delete; OmpTraitSetSelector() = delete;
  std::tuple<OmpTraitSetSelectorName, std::list<OmpTraitSelector>> t;
};



struct OmpContextSelectorSpecification {
  CharBlock source;
  OmpContextSelectorSpecification(OmpContextSelectorSpecification &&) = default; OmpContextSelectorSpecification &operator=(OmpContextSelectorSpecification &&) = default; OmpContextSelectorSpecification(const OmpContextSelectorSpecification &) = delete; OmpContextSelectorSpecification &operator=(const OmpContextSelectorSpecification &) = delete; OmpContextSelectorSpecification() = delete; OmpContextSelectorSpecification(std::list<OmpTraitSetSelector> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpTraitSetSelector> v;

};
}
# 3732 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
inline namespace modifier {
# 3743 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpAlignment {
  OmpAlignment(OmpAlignment &&) = default; OmpAlignment &operator=(OmpAlignment &&) = default; OmpAlignment(const OmpAlignment &) = delete; OmpAlignment &operator=(const OmpAlignment &) = delete; OmpAlignment() = delete; OmpAlignment(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};





struct OmpAlignModifier {
  OmpAlignModifier(OmpAlignModifier &&) = default; OmpAlignModifier &operator=(OmpAlignModifier &&) = default; OmpAlignModifier(const OmpAlignModifier &) = delete; OmpAlignModifier &operator=(const OmpAlignModifier &) = delete; OmpAlignModifier() = delete; OmpAlignModifier(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};





struct OmpAllocatorSimpleModifier {
  OmpAllocatorSimpleModifier(OmpAllocatorSimpleModifier &&) = default; OmpAllocatorSimpleModifier &operator=(OmpAllocatorSimpleModifier &&) = default; OmpAllocatorSimpleModifier(const OmpAllocatorSimpleModifier &) = delete; OmpAllocatorSimpleModifier &operator=(const OmpAllocatorSimpleModifier &) = delete; OmpAllocatorSimpleModifier() = delete; OmpAllocatorSimpleModifier(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};





struct OmpAllocatorComplexModifier {
  OmpAllocatorComplexModifier(OmpAllocatorComplexModifier &&) = default; OmpAllocatorComplexModifier &operator=(OmpAllocatorComplexModifier &&) = default; OmpAllocatorComplexModifier(const OmpAllocatorComplexModifier &) = delete; OmpAllocatorComplexModifier &operator=(const OmpAllocatorComplexModifier &) = delete; OmpAllocatorComplexModifier() = delete; OmpAllocatorComplexModifier(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};
# 3779 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpAlwaysModifier {
  enum class Value { Always }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Always")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Always")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpAlwaysModifier(OmpAlwaysModifier &&) = default; OmpAlwaysModifier &operator=(OmpAlwaysModifier &&) = default; OmpAlwaysModifier(const OmpAlwaysModifier &) = delete; OmpAlwaysModifier &operator=(const OmpAlwaysModifier &) = delete; OmpAlwaysModifier() = delete; OmpAlwaysModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};






struct OmpAutomapModifier {
  enum class Value { Automap }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Automap")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Automap")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpAutomapModifier(OmpAutomapModifier &&) = default; OmpAutomapModifier &operator=(OmpAutomapModifier &&) = default; OmpAutomapModifier(const OmpAutomapModifier &) = delete; OmpAutomapModifier &operator=(const OmpAutomapModifier &) = delete; OmpAutomapModifier() = delete; OmpAutomapModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};







struct OmpChunkModifier {
  enum class Value { Simd }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Simd")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Simd")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpChunkModifier(OmpChunkModifier &&) = default; OmpChunkModifier &operator=(OmpChunkModifier &&) = default; OmpChunkModifier(const OmpChunkModifier &) = delete; OmpChunkModifier &operator=(const OmpChunkModifier &) = delete; OmpChunkModifier() = delete; OmpChunkModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3813 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpCloseModifier {
  enum class Value { Close }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Close")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Close")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpCloseModifier(OmpCloseModifier &&) = default; OmpCloseModifier &operator=(OmpCloseModifier &&) = default; OmpCloseModifier(const OmpCloseModifier &) = delete; OmpCloseModifier &operator=(const OmpCloseModifier &) = delete; OmpCloseModifier() = delete; OmpCloseModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3825 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDeleteModifier {
  enum class Value { Delete }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Delete")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Delete")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpDeleteModifier(OmpDeleteModifier &&) = default; OmpDeleteModifier &operator=(OmpDeleteModifier &&) = default; OmpDeleteModifier(const OmpDeleteModifier &) = delete; OmpDeleteModifier &operator=(const OmpDeleteModifier &) = delete; OmpDeleteModifier() = delete; OmpDeleteModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3846 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDependenceType {
  enum class Value { Sink, Source }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Sink, Source")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Sink, Source")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpDependenceType(OmpDependenceType &&) = default; OmpDependenceType &operator=(OmpDependenceType &&) = default; OmpDependenceType(const OmpDependenceType &) = delete; OmpDependenceType &operator=(const OmpDependenceType &) = delete; OmpDependenceType() = delete; OmpDependenceType(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpDeviceModifier {
  enum class Value { Ancestor, Device_Num }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Ancestor, Device_Num")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Ancestor, Device_Num")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpDeviceModifier(OmpDeviceModifier &&) = default; OmpDeviceModifier &operator=(OmpDeviceModifier &&) = default; OmpDeviceModifier(const OmpDeviceModifier &) = delete; OmpDeviceModifier &operator=(const OmpDeviceModifier &) = delete; OmpDeviceModifier() = delete; OmpDeviceModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3873 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDirectiveNameModifier : public OmpDirectiveName {
  OmpDirectiveNameModifier(OmpDirectiveNameModifier &&) = default; OmpDirectiveNameModifier &operator=(OmpDirectiveNameModifier &&) = default; OmpDirectiveNameModifier(const OmpDirectiveNameModifier &) = delete; OmpDirectiveNameModifier &operator=(const OmpDirectiveNameModifier &) = delete; OmpDirectiveNameModifier() = delete; using OmpDirectiveName::OmpDirectiveName; OmpDirectiveNameModifier(OmpDirectiveName &&base) : OmpDirectiveName(std::move(base)) {} using WrapperTrait = std::true_type;

};
# 3888 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpExpectation {
  enum class Value { Present }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Present")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Present")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpExpectation(OmpExpectation &&) = default; OmpExpectation &operator=(OmpExpectation &&) = default; OmpExpectation(const OmpExpectation &) = delete; OmpExpectation &operator=(const OmpExpectation &) = delete; OmpExpectation() = delete; OmpExpectation(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpInteropRuntimeIdentifier {
  template <typename A, typename = common::NoLvalue<A>> OmpInteropRuntimeIdentifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpInteropRuntimeIdentifier(OmpInteropRuntimeIdentifier &&) = default; OmpInteropRuntimeIdentifier &operator=(OmpInteropRuntimeIdentifier &&) = default; OmpInteropRuntimeIdentifier(const OmpInteropRuntimeIdentifier &) = delete; OmpInteropRuntimeIdentifier &operator=(const OmpInteropRuntimeIdentifier &) = delete; OmpInteropRuntimeIdentifier() = delete;
  std::variant<CharLiteralConstant, ScalarIntConstantExpr> u;
};





struct OmpInteropPreference {
  OmpInteropPreference(OmpInteropPreference &&) = default; OmpInteropPreference &operator=(OmpInteropPreference &&) = default; OmpInteropPreference(const OmpInteropPreference &) = delete; OmpInteropPreference &operator=(const OmpInteropPreference &) = delete; OmpInteropPreference() = delete; OmpInteropPreference(std::list<OmpInteropRuntimeIdentifier> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpInteropRuntimeIdentifier> v;

};





struct OmpInteropType {
  enum class Value { Target, TargetSync }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Target, TargetSync")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Target, TargetSync")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpInteropType(OmpInteropType &&) = default; OmpInteropType &operator=(OmpInteropType &&) = default; OmpInteropType(const OmpInteropType &) = delete; OmpInteropType &operator=(const OmpInteropType &) = delete; OmpInteropType() = delete; OmpInteropType(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3927 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpIteratorSpecifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIteratorSpecifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIteratorSpecifier(OmpIteratorSpecifier &&) = default; OmpIteratorSpecifier &operator=(OmpIteratorSpecifier &&) = default; OmpIteratorSpecifier(const OmpIteratorSpecifier &) = delete; OmpIteratorSpecifier &operator=(const OmpIteratorSpecifier &) = delete; OmpIteratorSpecifier() = delete;
  CharBlock source;
  std::tuple<TypeDeclarationStmt, SubscriptTriplet> t;
};





struct OmpIterator {
  OmpIterator(OmpIterator &&) = default; OmpIterator &operator=(OmpIterator &&) = default; OmpIterator(const OmpIterator &) = delete; OmpIterator &operator=(const OmpIterator &) = delete; OmpIterator() = delete; OmpIterator(std::list<OmpIteratorSpecifier> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpIteratorSpecifier> v;
};





struct OmpLastprivateModifier {
  enum class Value { Conditional }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Conditional")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Conditional")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpLastprivateModifier(OmpLastprivateModifier &&) = default; OmpLastprivateModifier &operator=(OmpLastprivateModifier &&) = default; OmpLastprivateModifier(const OmpLastprivateModifier &) = delete; OmpLastprivateModifier &operator=(const OmpLastprivateModifier &) = delete; OmpLastprivateModifier() = delete; OmpLastprivateModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpLinearModifier {
  enum class Value { Ref, Uval, Val }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Ref, Uval, Val")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Ref, Uval, Val")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpLinearModifier(OmpLinearModifier &&) = default; OmpLinearModifier &operator=(OmpLinearModifier &&) = default; OmpLinearModifier(const OmpLinearModifier &) = delete; OmpLinearModifier &operator=(const OmpLinearModifier &) = delete; OmpLinearModifier() = delete; OmpLinearModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpMapper {
  OmpMapper(OmpMapper &&) = default; OmpMapper &operator=(OmpMapper &&) = default; OmpMapper(const OmpMapper &) = delete; OmpMapper &operator=(const OmpMapper &) = delete; OmpMapper() = delete; OmpMapper(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v;
};
# 3976 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpMapType {
  enum class Value { Alloc, Delete, From, Release, Storage, To, Tofrom }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Alloc, Delete, From, Release, Storage, To, Tofrom")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Alloc, Delete, From, Release, Storage, To, Tofrom")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpMapType(OmpMapType &&) = default; OmpMapType &operator=(OmpMapType &&) = default; OmpMapType(const OmpMapType &) = delete; OmpMapType &operator=(const OmpMapType &) = delete; OmpMapType() = delete; OmpMapType(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 3989 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpMapTypeModifier {
  enum class Value { Always, Close, Present, Ompx_Hold }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Always, Close, Present, Ompx_Hold")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Always, Close, Present, Ompx_Hold")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpMapTypeModifier(OmpMapTypeModifier &&) = default; OmpMapTypeModifier &operator=(OmpMapTypeModifier &&) = default; OmpMapTypeModifier(const OmpMapTypeModifier &) = delete; OmpMapTypeModifier &operator=(const OmpMapTypeModifier &) = delete; OmpMapTypeModifier() = delete; OmpMapTypeModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 4004 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpOrderingModifier {
  enum class Value { Monotonic, Nonmonotonic, Simd }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Monotonic, Nonmonotonic, Simd")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Monotonic, Nonmonotonic, Simd")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpOrderingModifier(OmpOrderingModifier &&) = default; OmpOrderingModifier &operator=(OmpOrderingModifier &&) = default; OmpOrderingModifier(const OmpOrderingModifier &) = delete; OmpOrderingModifier &operator=(const OmpOrderingModifier &) = delete; OmpOrderingModifier() = delete; OmpOrderingModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpOrderModifier {
  enum class Value { Reproducible, Unconstrained }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Reproducible, Unconstrained")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Reproducible, Unconstrained")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpOrderModifier(OmpOrderModifier &&) = default; OmpOrderModifier &operator=(OmpOrderModifier &&) = default; OmpOrderModifier(const OmpOrderModifier &) = delete; OmpOrderModifier &operator=(const OmpOrderModifier &) = delete; OmpOrderModifier() = delete; OmpOrderModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpPrescriptiveness {
  enum class Value { Strict }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Strict")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Strict")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpPrescriptiveness(OmpPrescriptiveness &&) = default; OmpPrescriptiveness &operator=(OmpPrescriptiveness &&) = default; OmpPrescriptiveness(const OmpPrescriptiveness &) = delete; OmpPrescriptiveness &operator=(const OmpPrescriptiveness &) = delete; OmpPrescriptiveness() = delete; OmpPrescriptiveness(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 4035 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpPresentModifier {
  enum class Value { Present }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Present")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Present")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpPresentModifier(OmpPresentModifier &&) = default; OmpPresentModifier &operator=(OmpPresentModifier &&) = default; OmpPresentModifier(const OmpPresentModifier &) = delete; OmpPresentModifier &operator=(const OmpPresentModifier &) = delete; OmpPresentModifier() = delete; OmpPresentModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpReductionModifier {
  enum class Value { Default, Inscan, Task }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Default, Inscan, Task")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Default, Inscan, Task")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } };
  OmpReductionModifier(OmpReductionModifier &&) = default; OmpReductionModifier &operator=(OmpReductionModifier &&) = default; OmpReductionModifier(const OmpReductionModifier &) = delete; OmpReductionModifier &operator=(const OmpReductionModifier &) = delete; OmpReductionModifier() = delete; OmpReductionModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};






struct OmpRefModifier {
  enum class Value { Ref_Ptee, Ref_Ptr, Ref_Ptr_Ptee }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Ref_Ptee, Ref_Ptr, Ref_Ptr_Ptee")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Ref_Ptee, Ref_Ptr, Ref_Ptr_Ptee")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpRefModifier(OmpRefModifier &&) = default; OmpRefModifier &operator=(OmpRefModifier &&) = default; OmpRefModifier(const OmpRefModifier &) = delete; OmpRefModifier &operator=(const OmpRefModifier &) = delete; OmpRefModifier() = delete; OmpRefModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};






struct OmpSelfModifier {
  enum class Value { Self }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Self")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Self")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpSelfModifier(OmpSelfModifier &&) = default; OmpSelfModifier &operator=(OmpSelfModifier &&) = default; OmpSelfModifier(const OmpSelfModifier &) = delete; OmpSelfModifier &operator=(const OmpSelfModifier &) = delete; OmpSelfModifier() = delete; OmpSelfModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};





struct OmpStepComplexModifier {
  OmpStepComplexModifier(OmpStepComplexModifier &&) = default; OmpStepComplexModifier &operator=(OmpStepComplexModifier &&) = default; OmpStepComplexModifier(const OmpStepComplexModifier &) = delete; OmpStepComplexModifier &operator=(const OmpStepComplexModifier &) = delete; OmpStepComplexModifier() = delete; OmpStepComplexModifier(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};





struct OmpStepSimpleModifier {
  OmpStepSimpleModifier(OmpStepSimpleModifier &&) = default; OmpStepSimpleModifier &operator=(OmpStepSimpleModifier &&) = default; OmpStepSimpleModifier(const OmpStepSimpleModifier &) = delete; OmpStepSimpleModifier &operator=(const OmpStepSimpleModifier &) = delete; OmpStepSimpleModifier() = delete; OmpStepSimpleModifier(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};







struct OmpTaskDependenceType {
  enum class Value { In, Out, Inout, Inoutset, Mutexinoutset, Depobj }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("In, Out, Inout, Inoutset, Mutexinoutset, Depobj")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("In, Out, Inout, Inoutset, Mutexinoutset, Depobj")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpTaskDependenceType(OmpTaskDependenceType &&) = default; OmpTaskDependenceType &operator=(OmpTaskDependenceType &&) = default; OmpTaskDependenceType(const OmpTaskDependenceType &) = delete; OmpTaskDependenceType &operator=(const OmpTaskDependenceType &) = delete; OmpTaskDependenceType() = delete; OmpTaskDependenceType(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};







struct OmpVariableCategory {
  enum class Value { Aggregate, All, Allocatable, Pointer, Scalar }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Aggregate, All, Allocatable, Pointer, Scalar")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Aggregate, All, Allocatable, Pointer, Scalar")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpVariableCategory(OmpVariableCategory &&) = default; OmpVariableCategory &operator=(OmpVariableCategory &&) = default; OmpVariableCategory(const OmpVariableCategory &) = delete; OmpVariableCategory &operator=(const OmpVariableCategory &) = delete; OmpVariableCategory() = delete; OmpVariableCategory(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};
# 4115 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpxHoldModifier {
  enum class Value { Ompx_Hold }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Ompx_Hold")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Ompx_Hold")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
  OmpxHoldModifier(OmpxHoldModifier &&) = default; OmpxHoldModifier &operator=(OmpxHoldModifier &&) = default; OmpxHoldModifier(const OmpxHoldModifier &) = delete; OmpxHoldModifier &operator=(const OmpxHoldModifier &) = delete; OmpxHoldModifier() = delete; OmpxHoldModifier(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
};


using OmpContextSelector = traits::OmpContextSelectorSpecification;
}



using OmpDirectiveList = std::list<llvm::omp::Directive>;





struct OmpAbsentClause {
  OmpAbsentClause(OmpAbsentClause &&) = default; OmpAbsentClause &operator=(OmpAbsentClause &&) = default; OmpAbsentClause(const OmpAbsentClause &) = delete; OmpAbsentClause &operator=(const OmpAbsentClause &) = delete; OmpAbsentClause() = delete; OmpAbsentClause(OmpDirectiveList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveList v;
};

struct OmpAdjustArgsClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAdjustArgsClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAdjustArgsClause(OmpAdjustArgsClause &&) = default; OmpAdjustArgsClause &operator=(OmpAdjustArgsClause &&) = default; OmpAdjustArgsClause(const OmpAdjustArgsClause &) = delete; OmpAdjustArgsClause &operator=(const OmpAdjustArgsClause &) = delete; OmpAdjustArgsClause() = delete;
  struct OmpAdjustOp {
    enum class Value { Nothing, Need_Device_Ptr }; [[maybe_unused]] static constexpr std::size_t Value_enumSize{ ::Fortran::common::CountEnumNames("Nothing, Need_Device_Ptr")}; [[maybe_unused]] static inline std::size_t EnumToInt(Value e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Value e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Value_enumSize>("Nothing, Need_Device_Ptr")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachValue(std::function<void(Value)> f) { for (std::size_t i{0}; i < Value_enumSize; ++i) { f(static_cast<Value>(i)); } }
    OmpAdjustOp(OmpAdjustOp &&) = default; OmpAdjustOp &operator=(OmpAdjustOp &&) = default; OmpAdjustOp(const OmpAdjustOp &) = delete; OmpAdjustOp &operator=(const OmpAdjustOp &) = delete; OmpAdjustOp() = delete; OmpAdjustOp(Value &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Value v;
  };
  std::tuple<OmpAdjustOp, OmpObjectList> t;
};







struct OmpAffinityClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAffinityClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAffinityClause(OmpAffinityClause &&) = default; OmpAffinityClause &operator=(OmpAffinityClause &&) = default; OmpAffinityClause(const OmpAffinityClause &) = delete; OmpAffinityClause &operator=(const OmpAffinityClause &) = delete; OmpAffinityClause() = delete;
  struct Modifier { using Variant = std::variant<OmpIterator>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};


struct OmpAlignClause {
  OmpAlignClause(OmpAlignClause &&) = default; OmpAlignClause &operator=(OmpAlignClause &&) = default; OmpAlignClause(const OmpAlignClause &) = delete; OmpAlignClause &operator=(const OmpAlignClause &) = delete; OmpAlignClause() = delete; OmpAlignClause(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v;
};





struct OmpAlignedClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAlignedClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAlignedClause(OmpAlignedClause &&) = default; OmpAlignedClause &operator=(OmpAlignedClause &&) = default; OmpAlignedClause(const OmpAlignedClause &) = delete; OmpAlignedClause &operator=(const OmpAlignedClause &) = delete; OmpAlignedClause() = delete;
  struct Modifier { using Variant = std::variant<OmpAlignment>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<OmpObjectList, std::optional<std::list<Modifier>>> t;
};
# 4181 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpAllocateClause {
  struct Modifier { using Variant = std::variant<OmpAlignModifier, OmpAllocatorSimpleModifier, OmpAllocatorComplexModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };

  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAllocateClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAllocateClause(OmpAllocateClause &&) = default; OmpAllocateClause &operator=(OmpAllocateClause &&) = default; OmpAllocateClause(const OmpAllocateClause &) = delete; OmpAllocateClause &operator=(const OmpAllocateClause &) = delete; OmpAllocateClause() = delete;
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};

struct OmpAppendArgsClause {
  struct OmpAppendOp {
    OmpAppendOp(OmpAppendOp &&) = default; OmpAppendOp &operator=(OmpAppendOp &&) = default; OmpAppendOp(const OmpAppendOp &) = delete; OmpAppendOp &operator=(const OmpAppendOp &) = delete; OmpAppendOp() = delete; OmpAppendOp(std::list<OmpInteropType> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpInteropType> v;
  };
  OmpAppendArgsClause(OmpAppendArgsClause &&) = default; OmpAppendArgsClause &operator=(OmpAppendArgsClause &&) = default; OmpAppendArgsClause(const OmpAppendArgsClause &) = delete; OmpAppendArgsClause &operator=(const OmpAppendArgsClause &) = delete; OmpAppendArgsClause() = delete; OmpAppendArgsClause(std::list<OmpAppendOp> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpAppendOp> v;
};



struct OmpAtClause {
  enum class ActionTime { Compilation, Execution }; [[maybe_unused]] static constexpr std::size_t ActionTime_enumSize{ ::Fortran::common::CountEnumNames("Compilation, Execution")}; [[maybe_unused]] static inline std::size_t EnumToInt(ActionTime e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(ActionTime e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ActionTime_enumSize>("Compilation, Execution")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachActionTime(std::function<void(ActionTime)> f) { for (std::size_t i{0}; i < ActionTime_enumSize; ++i) { f(static_cast<ActionTime>(i)); } };
  OmpAtClause(OmpAtClause &&) = default; OmpAtClause &operator=(OmpAtClause &&) = default; OmpAtClause(const OmpAtClause &) = delete; OmpAtClause &operator=(const OmpAtClause &) = delete; OmpAtClause() = delete; OmpAtClause(ActionTime &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ActionTime v;
};
# 4209 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpAtomicDefaultMemOrderClause {
  using MemoryOrder = common::OmpMemoryOrderType;
  OmpAtomicDefaultMemOrderClause(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause &operator=(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause &operator=(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause() = delete; OmpAtomicDefaultMemOrderClause(MemoryOrder &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; MemoryOrder v;
};







struct OmpBindClause {
  enum class Binding { Parallel, Teams, Thread }; [[maybe_unused]] static constexpr std::size_t Binding_enumSize{ ::Fortran::common::CountEnumNames("Parallel, Teams, Thread")}; [[maybe_unused]] static inline std::size_t EnumToInt(Binding e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Binding e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Binding_enumSize>("Parallel, Teams, Thread")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachBinding(std::function<void(Binding)> f) { for (std::size_t i{0}; i < Binding_enumSize; ++i) { f(static_cast<Binding>(i)); } }
  OmpBindClause(OmpBindClause &&) = default; OmpBindClause &operator=(OmpBindClause &&) = default; OmpBindClause(const OmpBindClause &) = delete; OmpBindClause &operator=(const OmpBindClause &) = delete; OmpBindClause() = delete; OmpBindClause(Binding &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Binding v;
};


struct OmpCancellationConstructTypeClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpCancellationConstructTypeClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpCancellationConstructTypeClause(OmpCancellationConstructTypeClause &&) = default; OmpCancellationConstructTypeClause &operator=(OmpCancellationConstructTypeClause &&) = default; OmpCancellationConstructTypeClause(const OmpCancellationConstructTypeClause &) = delete; OmpCancellationConstructTypeClause &operator=(const OmpCancellationConstructTypeClause &) = delete; OmpCancellationConstructTypeClause() = delete;
  std::tuple<OmpDirectiveName, std::optional<ScalarLogicalExpr>> t;
};





struct OmpContainsClause {
  OmpContainsClause(OmpContainsClause &&) = default; OmpContainsClause &operator=(OmpContainsClause &&) = default; OmpContainsClause(const OmpContainsClause &) = delete; OmpContainsClause &operator=(const OmpContainsClause &) = delete; OmpContainsClause() = delete; OmpContainsClause(OmpDirectiveList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveList v;
};
# 4252 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDefaultClause {
  enum class DataSharingAttribute { Private, Firstprivate, Shared, None }; [[maybe_unused]] static constexpr std::size_t DataSharingAttribute_enumSize{ ::Fortran::common::CountEnumNames("Private, Firstprivate, Shared, None")}; [[maybe_unused]] static inline std::size_t EnumToInt(DataSharingAttribute e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(DataSharingAttribute e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DataSharingAttribute_enumSize>("Private, Firstprivate, Shared, None")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachDataSharingAttribute(std::function<void(DataSharingAttribute)> f) { for (std::size_t i{0}; i < DataSharingAttribute_enumSize; ++i) { f(static_cast<DataSharingAttribute>(i)); } }
  template <typename A, typename = common::NoLvalue<A>> OmpDefaultClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDefaultClause(OmpDefaultClause &&) = default; OmpDefaultClause &operator=(OmpDefaultClause &&) = default; OmpDefaultClause(const OmpDefaultClause &) = delete; OmpDefaultClause &operator=(const OmpDefaultClause &) = delete; OmpDefaultClause() = delete;
  std::variant<DataSharingAttribute,
      common::Indirection<OmpDirectiveSpecification>>
      u;
};
# 4270 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDefaultmapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDefaultmapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDefaultmapClause(OmpDefaultmapClause &&) = default; OmpDefaultmapClause &operator=(OmpDefaultmapClause &&) = default; OmpDefaultmapClause(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause &operator=(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause() = delete;
  enum class ImplicitBehavior { Alloc, To, From, Tofrom, Firstprivate, None, Default, Present }; [[maybe_unused]] static constexpr std::size_t ImplicitBehavior_enumSize{ ::Fortran::common::CountEnumNames("Alloc, To, From, Tofrom, Firstprivate, None, Default, Present")}; [[maybe_unused]] static inline std::size_t EnumToInt(ImplicitBehavior e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(ImplicitBehavior e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImplicitBehavior_enumSize>("Alloc, To, From, Tofrom, Firstprivate, None, Default, Present")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachImplicitBehavior(std::function<void(ImplicitBehavior)> f) { for (std::size_t i{0}; i < ImplicitBehavior_enumSize; ++i) { f(static_cast<ImplicitBehavior>(i)); } }

  struct Modifier { using Variant = std::variant<OmpVariableCategory>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<ImplicitBehavior, std::optional<std::list<Modifier>>> t;
};





struct OmpIterationOffset {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIterationOffset(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIterationOffset(OmpIterationOffset &&) = default; OmpIterationOffset &operator=(OmpIterationOffset &&) = default; OmpIterationOffset(const OmpIterationOffset &) = delete; OmpIterationOffset &operator=(const OmpIterationOffset &) = delete; OmpIterationOffset() = delete;
  std::tuple<DefinedOperator, ScalarIntConstantExpr> t;
};





struct OmpIteration {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIteration(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIteration(OmpIteration &&) = default; OmpIteration &operator=(OmpIteration &&) = default; OmpIteration(const OmpIteration &) = delete; OmpIteration &operator=(const OmpIteration &) = delete; OmpIteration() = delete;
  std::tuple<Name, std::optional<OmpIterationOffset>> t;
};





struct OmpIterationVector { OmpIterationVector(OmpIterationVector &&) = default; OmpIterationVector &operator=(OmpIterationVector &&) = default; OmpIterationVector(const OmpIterationVector &) = delete; OmpIterationVector &operator=(const OmpIterationVector &) = delete; OmpIterationVector() = delete; OmpIterationVector(std::list<OmpIteration> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpIteration> v; };






struct OmpDoacross {
  OmpDependenceType::Value GetDepType() const;

  struct Sink { Sink(Sink &&) = default; Sink &operator=(Sink &&) = default; Sink(const Sink &) = delete; Sink &operator=(const Sink &) = delete; Sink() = delete; Sink(OmpIterationVector &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpIterationVector v; };
  struct Source { Source() {} Source(const Source &) {} Source(Source &&) {} Source &operator=(const Source &) { return *this; }; Source &operator=(Source &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename A, typename = common::NoLvalue<A>> OmpDoacross(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDoacross(OmpDoacross &&) = default; OmpDoacross &operator=(OmpDoacross &&) = default; OmpDoacross(const OmpDoacross &) = delete; OmpDoacross &operator=(const OmpDoacross &) = delete; OmpDoacross() = delete;
  std::variant<Sink, Source> u;
};
# 4325 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpDependClause {
  template <typename A, typename = common::NoLvalue<A>> OmpDependClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDependClause(OmpDependClause &&) = default; OmpDependClause &operator=(OmpDependClause &&) = default; OmpDependClause(const OmpDependClause &) = delete; OmpDependClause &operator=(const OmpDependClause &) = delete; OmpDependClause() = delete;
  struct TaskDep {
    OmpTaskDependenceType::Value GetTaskDepType() const;
    template <typename... Ts, typename = common::NoLvalue<Ts...>> TaskDep(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TaskDep(TaskDep &&) = default; TaskDep &operator=(TaskDep &&) = default; TaskDep(const TaskDep &) = delete; TaskDep &operator=(const TaskDep &) = delete; TaskDep() = delete;
    struct Modifier { using Variant = std::variant<OmpIterator, OmpTaskDependenceType>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
    std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
  };
  std::variant<TaskDep, OmpDoacross> u;
};





struct OmpDoacrossClause { OmpDoacrossClause(OmpDoacrossClause &&) = default; OmpDoacrossClause &operator=(OmpDoacrossClause &&) = default; OmpDoacrossClause(const OmpDoacrossClause &) = delete; OmpDoacrossClause &operator=(const OmpDoacrossClause &) = delete; OmpDoacrossClause() = delete; OmpDoacrossClause(OmpDoacross &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDoacross v; };






struct OmpDestroyClause { OmpDestroyClause(OmpDestroyClause &&) = default; OmpDestroyClause &operator=(OmpDestroyClause &&) = default; OmpDestroyClause(const OmpDestroyClause &) = delete; OmpDestroyClause &operator=(const OmpDestroyClause &) = delete; OmpDestroyClause() = delete; OmpDestroyClause(OmpObject &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObject v; };





struct OmpDetachClause {
  OmpDetachClause(OmpDetachClause &&) = default; OmpDetachClause &operator=(OmpDetachClause &&) = default; OmpDetachClause(const OmpDetachClause &) = delete; OmpDetachClause &operator=(const OmpDetachClause &) = delete; OmpDetachClause() = delete; OmpDetachClause(OmpObject &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObject v;
};







struct OmpDeviceClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDeviceClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDeviceClause(OmpDeviceClause &&) = default; OmpDeviceClause &operator=(OmpDeviceClause &&) = default; OmpDeviceClause(const OmpDeviceClause &) = delete; OmpDeviceClause &operator=(const OmpDeviceClause &) = delete; OmpDeviceClause() = delete;
  struct Modifier { using Variant = std::variant<OmpDeviceModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, ScalarIntExpr> t;
};





struct OmpDeviceTypeClause {
  enum class DeviceTypeDescription { Any, Host, Nohost }; [[maybe_unused]] static constexpr std::size_t DeviceTypeDescription_enumSize{ ::Fortran::common::CountEnumNames("Any, Host, Nohost")}; [[maybe_unused]] static inline std::size_t EnumToInt(DeviceTypeDescription e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(DeviceTypeDescription e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DeviceTypeDescription_enumSize>("Any, Host, Nohost")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachDeviceTypeDescription(std::function<void(DeviceTypeDescription)> f) { for (std::size_t i{0}; i < DeviceTypeDescription_enumSize; ++i) { f(static_cast<DeviceTypeDescription>(i)); } }
  OmpDeviceTypeClause(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause &operator=(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause &operator=(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause() = delete; OmpDeviceTypeClause(DeviceTypeDescription &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; DeviceTypeDescription v;
};






struct OmpEnterClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEnterClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEnterClause(OmpEnterClause &&) = default; OmpEnterClause &operator=(OmpEnterClause &&) = default; OmpEnterClause(const OmpEnterClause &) = delete; OmpEnterClause &operator=(const OmpEnterClause &) = delete; OmpEnterClause() = delete;
  struct Modifier { using Variant = std::variant<OmpAutomapModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};



struct OmpFailClause {
  using MemoryOrder = common::OmpMemoryOrderType;
  OmpFailClause(OmpFailClause &&) = default; OmpFailClause &operator=(OmpFailClause &&) = default; OmpFailClause(const OmpFailClause &) = delete; OmpFailClause &operator=(const OmpFailClause &) = delete; OmpFailClause() = delete; OmpFailClause(MemoryOrder &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; MemoryOrder v;
};
# 4404 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpFromClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpFromClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpFromClause(OmpFromClause &&) = default; OmpFromClause &operator=(OmpFromClause &&) = default; OmpFromClause(const OmpFromClause &) = delete; OmpFromClause &operator=(const OmpFromClause &) = delete; OmpFromClause() = delete;
  struct Modifier { using Variant = std::variant<OmpExpectation, OmpIterator, OmpMapper>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList, bool> t;
};






struct OmpGrainsizeClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpGrainsizeClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpGrainsizeClause(OmpGrainsizeClause &&) = default; OmpGrainsizeClause &operator=(OmpGrainsizeClause &&) = default; OmpGrainsizeClause(const OmpGrainsizeClause &) = delete; OmpGrainsizeClause &operator=(const OmpGrainsizeClause &) = delete; OmpGrainsizeClause() = delete;
  struct Modifier { using Variant = std::variant<OmpPrescriptiveness>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, ScalarIntExpr> t;
};


struct OmpHintClause {
  OmpHintClause(OmpHintClause &&) = default; OmpHintClause &operator=(OmpHintClause &&) = default; OmpHintClause(const OmpHintClause &) = delete; OmpHintClause &operator=(const OmpHintClause &) = delete; OmpHintClause() = delete; OmpHintClause(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v;
};





struct OmpHoldsClause {
  OmpHoldsClause(OmpHoldsClause &&) = default; OmpHoldsClause &operator=(OmpHoldsClause &&) = default; OmpHoldsClause(const OmpHoldsClause &) = delete; OmpHoldsClause &operator=(const OmpHoldsClause &) = delete; OmpHoldsClause() = delete; OmpHoldsClause(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v;
};


struct OmpIndirectClause {
  OmpIndirectClause(OmpIndirectClause &&) = default; OmpIndirectClause &operator=(OmpIndirectClause &&) = default; OmpIndirectClause(const OmpIndirectClause &) = delete; OmpIndirectClause &operator=(const OmpIndirectClause &) = delete; OmpIndirectClause() = delete; OmpIndirectClause(std::optional<ScalarLogicalExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarLogicalExpr> v;

};







struct OmpIfClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIfClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIfClause(OmpIfClause &&) = default; OmpIfClause &operator=(OmpIfClause &&) = default; OmpIfClause(const OmpIfClause &) = delete; OmpIfClause &operator=(const OmpIfClause &) = delete; OmpIfClause() = delete;
  struct Modifier { using Variant = std::variant<OmpDirectiveNameModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, ScalarLogicalExpr> t;
};





struct OmpInReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpInReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpInReductionClause(OmpInReductionClause &&) = default; OmpInReductionClause &operator=(OmpInReductionClause &&) = default; OmpInReductionClause(const OmpInReductionClause &) = delete; OmpInReductionClause &operator=(const OmpInReductionClause &) = delete; OmpInReductionClause() = delete;
  struct Modifier { using Variant = std::variant<OmpReductionIdentifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};



struct OmpInitializerProc {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpInitializerProc(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpInitializerProc(OmpInitializerProc &&) = default; OmpInitializerProc &operator=(OmpInitializerProc &&) = default; OmpInitializerProc(const OmpInitializerProc &) = delete; OmpInitializerProc &operator=(const OmpInitializerProc &) = delete; OmpInitializerProc() = delete;
  std::tuple<ProcedureDesignator, std::list<ActualArgSpec>> t;
};

struct OmpInitializerClause {
  template <typename A, typename = common::NoLvalue<A>> OmpInitializerClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpInitializerClause(OmpInitializerClause &&) = default; OmpInitializerClause &operator=(OmpInitializerClause &&) = default; OmpInitializerClause(const OmpInitializerClause &) = delete; OmpInitializerClause &operator=(const OmpInitializerClause &) = delete; OmpInitializerClause() = delete;
  std::variant<OmpInitializerProc, AssignmentStmt> u;
};






struct OmpLastprivateClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpLastprivateClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpLastprivateClause(OmpLastprivateClause &&) = default; OmpLastprivateClause &operator=(OmpLastprivateClause &&) = default; OmpLastprivateClause(const OmpLastprivateClause &) = delete; OmpLastprivateClause &operator=(const OmpLastprivateClause &) = delete; OmpLastprivateClause() = delete;
  struct Modifier { using Variant = std::variant<OmpLastprivateModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};
# 4494 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpLinearClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpLinearClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpLinearClause(OmpLinearClause &&) = default; OmpLinearClause &operator=(OmpLinearClause &&) = default; OmpLinearClause(const OmpLinearClause &) = delete; OmpLinearClause &operator=(const OmpLinearClause &) = delete; OmpLinearClause() = delete;
  struct Modifier { using Variant = std::variant<OmpLinearModifier, OmpStepSimpleModifier, OmpStepComplexModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };

  std::tuple<OmpObjectList, std::optional<std::list<Modifier>>, bool> t;
};
# 4520 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpMapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapClause(OmpMapClause &&) = default; OmpMapClause &operator=(OmpMapClause &&) = default; OmpMapClause(const OmpMapClause &) = delete; OmpMapClause &operator=(const OmpMapClause &) = delete; OmpMapClause() = delete;
  struct Modifier { using Variant = std::variant<OmpAlwaysModifier, OmpCloseModifier, OmpDeleteModifier, OmpMapTypeModifier, OmpPresentModifier, OmpRefModifier, OmpSelfModifier, OmpMapper, OmpIterator, OmpMapType, OmpxHoldModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };


  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList, bool> t;
};





struct OmpMatchClause {

  OmpMatchClause(OmpMatchClause &&) = default; OmpMatchClause &operator=(OmpMatchClause &&) = default; OmpMatchClause(const OmpMatchClause &) = delete; OmpMatchClause &operator=(const OmpMatchClause &) = delete; OmpMatchClause() = delete; OmpMatchClause(traits::OmpContextSelectorSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; traits::OmpContextSelectorSpecification v;

};




struct OmpMessageClause {
  OmpMessageClause(OmpMessageClause &&) = default; OmpMessageClause &operator=(OmpMessageClause &&) = default; OmpMessageClause(const OmpMessageClause &) = delete; OmpMessageClause &operator=(const OmpMessageClause &) = delete; OmpMessageClause() = delete; OmpMessageClause(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v;
};




struct OmpNoOpenMPClause { OmpNoOpenMPClause() {} OmpNoOpenMPClause(const OmpNoOpenMPClause &) {} OmpNoOpenMPClause(OmpNoOpenMPClause &&) {} OmpNoOpenMPClause &operator=(const OmpNoOpenMPClause &) { return *this; }; OmpNoOpenMPClause &operator=(OmpNoOpenMPClause &&) { return *this; }; using EmptyTrait = std::true_type; };




struct OmpNoOpenMPRoutinesClause { OmpNoOpenMPRoutinesClause() {} OmpNoOpenMPRoutinesClause(const OmpNoOpenMPRoutinesClause &) {} OmpNoOpenMPRoutinesClause(OmpNoOpenMPRoutinesClause &&) {} OmpNoOpenMPRoutinesClause &operator=(const OmpNoOpenMPRoutinesClause &) { return *this; }; OmpNoOpenMPRoutinesClause &operator=(OmpNoOpenMPRoutinesClause &&) { return *this; }; using EmptyTrait = std::true_type; };




struct OmpNoParallelismClause { OmpNoParallelismClause() {} OmpNoParallelismClause(const OmpNoParallelismClause &) {} OmpNoParallelismClause(OmpNoParallelismClause &&) {} OmpNoParallelismClause &operator=(const OmpNoParallelismClause &) { return *this; }; OmpNoParallelismClause &operator=(OmpNoParallelismClause &&) { return *this; }; using EmptyTrait = std::true_type; };






struct OmpNumTasksClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpNumTasksClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpNumTasksClause(OmpNumTasksClause &&) = default; OmpNumTasksClause &operator=(OmpNumTasksClause &&) = default; OmpNumTasksClause(const OmpNumTasksClause &) = delete; OmpNumTasksClause &operator=(const OmpNumTasksClause &) = delete; OmpNumTasksClause() = delete;
  struct Modifier { using Variant = std::variant<OmpPrescriptiveness>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, ScalarIntExpr> t;
};






struct OmpOrderClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpOrderClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpOrderClause(OmpOrderClause &&) = default; OmpOrderClause &operator=(OmpOrderClause &&) = default; OmpOrderClause(const OmpOrderClause &) = delete; OmpOrderClause &operator=(const OmpOrderClause &) = delete; OmpOrderClause() = delete;
  enum class Ordering { Concurrent }; [[maybe_unused]] static constexpr std::size_t Ordering_enumSize{ ::Fortran::common::CountEnumNames("Concurrent")}; [[maybe_unused]] static inline std::size_t EnumToInt(Ordering e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Ordering e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Ordering_enumSize>("Concurrent")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachOrdering(std::function<void(Ordering)> f) { for (std::size_t i{0}; i < Ordering_enumSize; ++i) { f(static_cast<Ordering>(i)); } }
  struct Modifier { using Variant = std::variant<OmpOrderModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, Ordering> t;
};







struct OmpOtherwiseClause {
  OmpOtherwiseClause(OmpOtherwiseClause &&) = default; OmpOtherwiseClause &operator=(OmpOtherwiseClause &&) = default; OmpOtherwiseClause(const OmpOtherwiseClause &) = delete; OmpOtherwiseClause &operator=(const OmpOtherwiseClause &) = delete; OmpOtherwiseClause() = delete; OmpOtherwiseClause(std::optional<common::Indirection<OmpDirectiveSpecification>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<common::Indirection<OmpDirectiveSpecification>> v;

};
# 4601 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpProcBindClause {
  enum class AffinityPolicy { Close, Master, Spread, Primary }; [[maybe_unused]] static constexpr std::size_t AffinityPolicy_enumSize{ ::Fortran::common::CountEnumNames("Close, Master, Spread, Primary")}; [[maybe_unused]] static inline std::size_t EnumToInt(AffinityPolicy e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(AffinityPolicy e) { static const constexpr auto names{ ::Fortran::common::EnumNames<AffinityPolicy_enumSize>("Close, Master, Spread, Primary")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachAffinityPolicy(std::function<void(AffinityPolicy)> f) { for (std::size_t i{0}; i < AffinityPolicy_enumSize; ++i) { f(static_cast<AffinityPolicy>(i)); } }
  OmpProcBindClause(OmpProcBindClause &&) = default; OmpProcBindClause &operator=(OmpProcBindClause &&) = default; OmpProcBindClause(const OmpProcBindClause &) = delete; OmpProcBindClause &operator=(const OmpProcBindClause &) = delete; OmpProcBindClause() = delete; OmpProcBindClause(AffinityPolicy &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AffinityPolicy v;
};







struct OmpReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpReductionClause(OmpReductionClause &&) = default; OmpReductionClause &operator=(OmpReductionClause &&) = default; OmpReductionClause(const OmpReductionClause &) = delete; OmpReductionClause &operator=(const OmpReductionClause &) = delete; OmpReductionClause() = delete;
  struct Modifier { using Variant = std::variant<OmpReductionModifier, OmpReductionIdentifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};
# 4626 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpScheduleClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpScheduleClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpScheduleClause(OmpScheduleClause &&) = default; OmpScheduleClause &operator=(OmpScheduleClause &&) = default; OmpScheduleClause(const OmpScheduleClause &) = delete; OmpScheduleClause &operator=(const OmpScheduleClause &) = delete; OmpScheduleClause() = delete;
  enum class Kind { Static, Dynamic, Guided, Auto, Runtime }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Static, Dynamic, Guided, Auto, Runtime")}; [[maybe_unused]] static inline std::size_t EnumToInt(Kind e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Static, Dynamic, Guided, Auto, Runtime")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachKind(std::function<void(Kind)> f) { for (std::size_t i{0}; i < Kind_enumSize; ++i) { f(static_cast<Kind>(i)); } }
  struct Modifier { using Variant = std::variant<OmpOrderingModifier, OmpChunkModifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, Kind, std::optional<ScalarIntExpr>> t;
};




struct OmpSeverityClause {
  enum class Severity { Fatal, Warning }; [[maybe_unused]] static constexpr std::size_t Severity_enumSize{ ::Fortran::common::CountEnumNames("Fatal, Warning")}; [[maybe_unused]] static inline std::size_t EnumToInt(Severity e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Severity e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Severity_enumSize>("Fatal, Warning")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachSeverity(std::function<void(Severity)> f) { for (std::size_t i{0}; i < Severity_enumSize; ++i) { f(static_cast<Severity>(i)); } };
  OmpSeverityClause(OmpSeverityClause &&) = default; OmpSeverityClause &operator=(OmpSeverityClause &&) = default; OmpSeverityClause(const OmpSeverityClause &) = delete; OmpSeverityClause &operator=(const OmpSeverityClause &) = delete; OmpSeverityClause() = delete; OmpSeverityClause(Severity &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Severity v;
};





struct OmpTaskReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpTaskReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpTaskReductionClause(OmpTaskReductionClause &&) = default; OmpTaskReductionClause &operator=(OmpTaskReductionClause &&) = default; OmpTaskReductionClause(const OmpTaskReductionClause &) = delete; OmpTaskReductionClause &operator=(const OmpTaskReductionClause &) = delete; OmpTaskReductionClause() = delete;
  struct Modifier { using Variant = std::variant<OmpReductionIdentifier>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList> t;
};
# 4661 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpToClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpToClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpToClause(OmpToClause &&) = default; OmpToClause &operator=(OmpToClause &&) = default; OmpToClause(const OmpToClause &) = delete; OmpToClause &operator=(const OmpToClause &) = delete; OmpToClause() = delete;
  struct Modifier { using Variant = std::variant<OmpExpectation, OmpIterator, OmpMapper>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObjectList, bool> t;
};
# 4678 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpUpdateClause {
  template <typename A, typename = common::NoLvalue<A>> OmpUpdateClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpUpdateClause(OmpUpdateClause &&) = default; OmpUpdateClause &operator=(OmpUpdateClause &&) = default; OmpUpdateClause(const OmpUpdateClause &) = delete; OmpUpdateClause &operator=(const OmpUpdateClause &) = delete; OmpUpdateClause() = delete;

  std::variant<OmpDependenceType, OmpTaskDependenceType> u;
};






struct OmpWhenClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpWhenClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpWhenClause(OmpWhenClause &&) = default; OmpWhenClause &operator=(OmpWhenClause &&) = default; OmpWhenClause(const OmpWhenClause &) = delete; OmpWhenClause &operator=(const OmpWhenClause &) = delete; OmpWhenClause() = delete;
  struct Modifier { using Variant = std::variant<OmpContextSelector>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>,
      std::optional<common::Indirection<OmpDirectiveSpecification>>>
      t;
};
# 4705 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OmpInitClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpInitClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpInitClause(OmpInitClause &&) = default; OmpInitClause &operator=(OmpInitClause &&) = default; OmpInitClause(const OmpInitClause &) = delete; OmpInitClause &operator=(const OmpInitClause &) = delete; OmpInitClause() = delete;
  struct Modifier { using Variant = std::variant<OmpInteropPreference, OmpInteropType>; template <typename A, typename = common::NoLvalue<A>> Modifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Modifier(Modifier &&) = default; Modifier &operator=(Modifier &&) = default; Modifier(const Modifier &) = delete; Modifier &operator=(const Modifier &) = delete; Modifier() = delete; CharBlock source; Variant u; };
  std::tuple<std::optional<std::list<Modifier>>, OmpObject> t;
};




struct OmpUseClause { OmpUseClause(OmpUseClause &&) = default; OmpUseClause &operator=(OmpUseClause &&) = default; OmpUseClause(const OmpUseClause &) = delete; OmpUseClause &operator=(const OmpUseClause &) = delete; OmpUseClause() = delete; OmpUseClause(OmpObject &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObject v; };


struct OmpClause {
  template <typename A, typename = common::NoLvalue<A>> OmpClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpClause(OmpClause &&) = default; OmpClause &operator=(OmpClause &&) = default; OmpClause(const OmpClause &) = delete; OmpClause &operator=(const OmpClause &) = delete; OmpClause() = delete;
  llvm::omp::Clause Id() const;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3805 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
struct Absent { Absent(Absent &&) = default; Absent &operator=(Absent &&) = default; Absent(const Absent &) = delete; Absent &operator=(const Absent &) = delete; Absent() = delete; Absent(OmpAbsentClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAbsentClause v; };
struct AcqRel { AcqRel() {} AcqRel(const AcqRel &) {} AcqRel(AcqRel &&) {} AcqRel &operator=(const AcqRel &) { return *this; }; AcqRel &operator=(AcqRel &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Acquire { Acquire() {} Acquire(const Acquire &) {} Acquire(Acquire &&) {} Acquire &operator=(const Acquire &) { return *this; }; Acquire &operator=(Acquire &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AdjustArgs { AdjustArgs(AdjustArgs &&) = default; AdjustArgs &operator=(AdjustArgs &&) = default; AdjustArgs(const AdjustArgs &) = delete; AdjustArgs &operator=(const AdjustArgs &) = delete; AdjustArgs() = delete; AdjustArgs(OmpAdjustArgsClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAdjustArgsClause v; };
struct Affinity { Affinity(Affinity &&) = default; Affinity &operator=(Affinity &&) = default; Affinity(const Affinity &) = delete; Affinity &operator=(const Affinity &) = delete; Affinity() = delete; Affinity(OmpAffinityClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAffinityClause v; };
struct Align { Align(Align &&) = default; Align &operator=(Align &&) = default; Align(const Align &) = delete; Align &operator=(const Align &) = delete; Align() = delete; Align(OmpAlignClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAlignClause v; };
struct Aligned { Aligned(Aligned &&) = default; Aligned &operator=(Aligned &&) = default; Aligned(const Aligned &) = delete; Aligned &operator=(const Aligned &) = delete; Aligned() = delete; Aligned(OmpAlignedClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAlignedClause v; };
struct Allocate { Allocate(Allocate &&) = default; Allocate &operator=(Allocate &&) = default; Allocate(const Allocate &) = delete; Allocate &operator=(const Allocate &) = delete; Allocate() = delete; Allocate(OmpAllocateClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAllocateClause v; };
struct Allocator { Allocator(Allocator &&) = default; Allocator &operator=(Allocator &&) = default; Allocator(const Allocator &) = delete; Allocator &operator=(const Allocator &) = delete; Allocator() = delete; Allocator(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct AppendArgs { AppendArgs(AppendArgs &&) = default; AppendArgs &operator=(AppendArgs &&) = default; AppendArgs(const AppendArgs &) = delete; AppendArgs &operator=(const AppendArgs &) = delete; AppendArgs() = delete; AppendArgs(OmpAppendArgsClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAppendArgsClause v; };
struct At { At(At &&) = default; At &operator=(At &&) = default; At(const At &) = delete; At &operator=(const At &) = delete; At() = delete; At(OmpAtClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAtClause v; };
struct AtomicDefaultMemOrder { AtomicDefaultMemOrder(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder &operator=(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder &operator=(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder() = delete; AtomicDefaultMemOrder(OmpAtomicDefaultMemOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAtomicDefaultMemOrderClause v; };
struct Bind { Bind(Bind &&) = default; Bind &operator=(Bind &&) = default; Bind(const Bind &) = delete; Bind &operator=(const Bind &) = delete; Bind() = delete; Bind(OmpBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpBindClause v; };
struct CancellationConstructType { CancellationConstructType(CancellationConstructType &&) = default; CancellationConstructType &operator=(CancellationConstructType &&) = default; CancellationConstructType(const CancellationConstructType &) = delete; CancellationConstructType &operator=(const CancellationConstructType &) = delete; CancellationConstructType() = delete; CancellationConstructType(OmpCancellationConstructTypeClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpCancellationConstructTypeClause v; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Compare { Compare() {} Compare(const Compare &) {} Compare(Compare &&) {} Compare &operator=(const Compare &) { return *this; }; Compare &operator=(Compare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Contains { Contains(Contains &&) = default; Contains &operator=(Contains &&) = default; Contains(const Contains &) = delete; Contains &operator=(const Contains &) = delete; Contains() = delete; Contains(OmpContainsClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpContainsClause v; };
struct Copyprivate { Copyprivate(Copyprivate &&) = default; Copyprivate &operator=(Copyprivate &&) = default; Copyprivate(const Copyprivate &) = delete; Copyprivate &operator=(const Copyprivate &) = delete; Copyprivate() = delete; Copyprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(OmpDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultClause v; };
struct Defaultmap { Defaultmap(Defaultmap &&) = default; Defaultmap &operator=(Defaultmap &&) = default; Defaultmap(const Defaultmap &) = delete; Defaultmap &operator=(const Defaultmap &) = delete; Defaultmap() = delete; Defaultmap(OmpDefaultmapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultmapClause v; };
struct Depend { Depend(Depend &&) = default; Depend &operator=(Depend &&) = default; Depend(const Depend &) = delete; Depend &operator=(const Depend &) = delete; Depend() = delete; Depend(OmpDependClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDependClause v; };
struct Depobj { Depobj() {} Depobj(const Depobj &) {} Depobj(Depobj &&) {} Depobj &operator=(const Depobj &) { return *this; }; Depobj &operator=(Depobj &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Destroy { Destroy(Destroy &&) = default; Destroy &operator=(Destroy &&) = default; Destroy(const Destroy &) = delete; Destroy &operator=(const Destroy &) = delete; Destroy() = delete; Destroy(std::optional<OmpDestroyClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<OmpDestroyClause> v; };
struct Detach { Detach(Detach &&) = default; Detach &operator=(Detach &&) = default; Detach(const Detach &) = delete; Detach &operator=(const Detach &) = delete; Detach() = delete; Detach(OmpDetachClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDetachClause v; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(OmpDeviceClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceClause v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(OmpDeviceTypeClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceTypeClause v; };
struct DistSchedule { DistSchedule(DistSchedule &&) = default; DistSchedule &operator=(DistSchedule &&) = default; DistSchedule(const DistSchedule &) = delete; DistSchedule &operator=(const DistSchedule &) = delete; DistSchedule() = delete; DistSchedule(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Doacross { Doacross(Doacross &&) = default; Doacross &operator=(Doacross &&) = default; Doacross(const Doacross &) = delete; Doacross &operator=(const Doacross &) = delete; Doacross() = delete; Doacross(OmpDoacrossClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDoacrossClause v; };
struct DynamicAllocators { DynamicAllocators() {} DynamicAllocators(const DynamicAllocators &) {} DynamicAllocators(DynamicAllocators &&) {} DynamicAllocators &operator=(const DynamicAllocators &) { return *this; }; DynamicAllocators &operator=(DynamicAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Enter { Enter(Enter &&) = default; Enter &operator=(Enter &&) = default; Enter(const Enter &) = delete; Enter &operator=(const Enter &) = delete; Enter() = delete; Enter(OmpEnterClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpEnterClause v; };
struct Exclusive { Exclusive(Exclusive &&) = default; Exclusive &operator=(Exclusive &&) = default; Exclusive(const Exclusive &) = delete; Exclusive &operator=(const Exclusive &) = delete; Exclusive() = delete; Exclusive(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Fail { Fail(Fail &&) = default; Fail &operator=(Fail &&) = default; Fail(const Fail &) = delete; Fail &operator=(const Fail &) = delete; Fail() = delete; Fail(OmpFailClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpFailClause v; };
struct Filter { Filter(Filter &&) = default; Filter &operator=(Filter &&) = default; Filter(const Filter &) = delete; Filter &operator=(const Filter &) = delete; Filter() = delete; Filter(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Final { Final(Final &&) = default; Final &operator=(Final &&) = default; Final(const Final &) = delete; Final &operator=(const Final &) = delete; Final() = delete; Final(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Flush { Flush() {} Flush(const Flush &) {} Flush(Flush &&) {} Flush &operator=(const Flush &) { return *this; }; Flush &operator=(Flush &&) { return *this; }; using EmptyTrait = std::true_type; };
struct From { From(From &&) = default; From &operator=(From &&) = default; From(const From &) = delete; From &operator=(const From &) = delete; From() = delete; From(OmpFromClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpFromClause v; };
struct Full { Full() {} Full(const Full &) {} Full(Full &&) {} Full &operator=(const Full &) { return *this; }; Full &operator=(Full &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Grainsize { Grainsize(Grainsize &&) = default; Grainsize &operator=(Grainsize &&) = default; Grainsize(const Grainsize &) = delete; Grainsize &operator=(const Grainsize &) = delete; Grainsize() = delete; Grainsize(OmpGrainsizeClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpGrainsizeClause v; };
struct HasDeviceAddr { HasDeviceAddr(HasDeviceAddr &&) = default; HasDeviceAddr &operator=(HasDeviceAddr &&) = default; HasDeviceAddr(const HasDeviceAddr &) = delete; HasDeviceAddr &operator=(const HasDeviceAddr &) = delete; HasDeviceAddr() = delete; HasDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Hint { Hint(Hint &&) = default; Hint &operator=(Hint &&) = default; Hint(const Hint &) = delete; Hint &operator=(const Hint &) = delete; Hint() = delete; Hint(OmpHintClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpHintClause v; };
struct Holds { Holds(Holds &&) = default; Holds &operator=(Holds &&) = default; Holds(const Holds &) = delete; Holds &operator=(const Holds &) = delete; Holds() = delete; Holds(OmpHoldsClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpHoldsClause v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(OmpIfClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpIfClause v; };
struct InReduction { InReduction(InReduction &&) = default; InReduction &operator=(InReduction &&) = default; InReduction(const InReduction &) = delete; InReduction &operator=(const InReduction &) = delete; InReduction() = delete; InReduction(OmpInReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpInReductionClause v; };
struct Inbranch { Inbranch() {} Inbranch(const Inbranch &) {} Inbranch(Inbranch &&) {} Inbranch &operator=(const Inbranch &) { return *this; }; Inbranch &operator=(Inbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Inclusive { Inclusive(Inclusive &&) = default; Inclusive &operator=(Inclusive &&) = default; Inclusive(const Inclusive &) = delete; Inclusive &operator=(const Inclusive &) = delete; Inclusive() = delete; Inclusive(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Indirect { Indirect(Indirect &&) = default; Indirect &operator=(Indirect &&) = default; Indirect(const Indirect &) = delete; Indirect &operator=(const Indirect &) = delete; Indirect() = delete; Indirect(OmpIndirectClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpIndirectClause v; };
struct Init { Init(Init &&) = default; Init &operator=(Init &&) = default; Init(const Init &) = delete; Init &operator=(const Init &) = delete; Init() = delete; Init(OmpInitClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpInitClause v; };
struct Initializer { Initializer(Initializer &&) = default; Initializer &operator=(Initializer &&) = default; Initializer(const Initializer &) = delete; Initializer &operator=(const Initializer &) = delete; Initializer() = delete; Initializer(OmpInitializerClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpInitializerClause v; };
struct IsDevicePtr { IsDevicePtr(IsDevicePtr &&) = default; IsDevicePtr &operator=(IsDevicePtr &&) = default; IsDevicePtr(const IsDevicePtr &) = delete; IsDevicePtr &operator=(const IsDevicePtr &) = delete; IsDevicePtr() = delete; IsDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Lastprivate { Lastprivate(Lastprivate &&) = default; Lastprivate &operator=(Lastprivate &&) = default; Lastprivate(const Lastprivate &) = delete; Lastprivate &operator=(const Lastprivate &) = delete; Lastprivate() = delete; Lastprivate(OmpLastprivateClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpLastprivateClause v; };
struct Linear { Linear(Linear &&) = default; Linear &operator=(Linear &&) = default; Linear(const Linear &) = delete; Linear &operator=(const Linear &) = delete; Linear() = delete; Linear(OmpLinearClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpLinearClause v; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Map { Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete; Map(OmpMapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpMapClause v; };
struct Match { Match(Match &&) = default; Match &operator=(Match &&) = default; Match(const Match &) = delete; Match &operator=(const Match &) = delete; Match() = delete; Match(OmpMatchClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpMatchClause v; };
struct MemoryOrder { MemoryOrder() {} MemoryOrder(const MemoryOrder &) {} MemoryOrder(MemoryOrder &&) {} MemoryOrder &operator=(const MemoryOrder &) { return *this; }; MemoryOrder &operator=(MemoryOrder &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Mergeable { Mergeable() {} Mergeable(const Mergeable &) {} Mergeable(Mergeable &&) {} Mergeable &operator=(const Mergeable &) { return *this; }; Mergeable &operator=(Mergeable &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Message { Message(Message &&) = default; Message &operator=(Message &&) = default; Message(const Message &) = delete; Message &operator=(const Message &) = delete; Message() = delete; Message(OmpMessageClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpMessageClause v; };
struct Nogroup { Nogroup() {} Nogroup(const Nogroup &) {} Nogroup(Nogroup &&) {} Nogroup &operator=(const Nogroup &) { return *this; }; Nogroup &operator=(Nogroup &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NoOpenmp { NoOpenmp() {} NoOpenmp(const NoOpenmp &) {} NoOpenmp(NoOpenmp &&) {} NoOpenmp &operator=(const NoOpenmp &) { return *this; }; NoOpenmp &operator=(NoOpenmp &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NoOpenmpConstructs { NoOpenmpConstructs() {} NoOpenmpConstructs(const NoOpenmpConstructs &) {} NoOpenmpConstructs(NoOpenmpConstructs &&) {} NoOpenmpConstructs &operator=(const NoOpenmpConstructs &) { return *this; }; NoOpenmpConstructs &operator=(NoOpenmpConstructs &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NoOpenmpRoutines { NoOpenmpRoutines() {} NoOpenmpRoutines(const NoOpenmpRoutines &) {} NoOpenmpRoutines(NoOpenmpRoutines &&) {} NoOpenmpRoutines &operator=(const NoOpenmpRoutines &) { return *this; }; NoOpenmpRoutines &operator=(NoOpenmpRoutines &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NoParallelism { NoParallelism() {} NoParallelism(const NoParallelism &) {} NoParallelism(NoParallelism &&) {} NoParallelism &operator=(const NoParallelism &) { return *this; }; NoParallelism &operator=(NoParallelism &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nowait { Nowait() {} Nowait(const Nowait &) {} Nowait(Nowait &&) {} Nowait &operator=(const Nowait &) { return *this; }; Nowait &operator=(Nowait &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nocontext { Nocontext(Nocontext &&) = default; Nocontext &operator=(Nocontext &&) = default; Nocontext(const Nocontext &) = delete; Nocontext &operator=(const Nocontext &) = delete; Nocontext() = delete; Nocontext(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Nontemporal { Nontemporal(Nontemporal &&) = default; Nontemporal &operator=(Nontemporal &&) = default; Nontemporal(const Nontemporal &) = delete; Nontemporal &operator=(const Nontemporal &) = delete; Nontemporal() = delete; Nontemporal(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Notinbranch { Notinbranch() {} Notinbranch(const Notinbranch &) {} Notinbranch(Notinbranch &&) {} Notinbranch &operator=(const Notinbranch &) { return *this; }; Notinbranch &operator=(Notinbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Novariants { Novariants(Novariants &&) = default; Novariants &operator=(Novariants &&) = default; Novariants(const Novariants &) = delete; Novariants &operator=(const Novariants &) = delete; Novariants() = delete; Novariants(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct NumTasks { NumTasks(NumTasks &&) = default; NumTasks &operator=(NumTasks &&) = default; NumTasks(const NumTasks &) = delete; NumTasks &operator=(const NumTasks &) = delete; NumTasks() = delete; NumTasks(OmpNumTasksClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpNumTasksClause v; };
struct NumTeams { NumTeams(NumTeams &&) = default; NumTeams &operator=(NumTeams &&) = default; NumTeams(const NumTeams &) = delete; NumTeams &operator=(const NumTeams &) = delete; NumTeams() = delete; NumTeams(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct NumThreads { NumThreads(NumThreads &&) = default; NumThreads &operator=(NumThreads &&) = default; NumThreads(const NumThreads &) = delete; NumThreads &operator=(const NumThreads &) = delete; NumThreads() = delete; NumThreads(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct OmpxAttribute { OmpxAttribute() {} OmpxAttribute(const OmpxAttribute &) {} OmpxAttribute(OmpxAttribute &&) {} OmpxAttribute &operator=(const OmpxAttribute &) { return *this; }; OmpxAttribute &operator=(OmpxAttribute &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OmpxBare { OmpxBare() {} OmpxBare(const OmpxBare &) {} OmpxBare(OmpxBare &&) {} OmpxBare &operator=(const OmpxBare &) { return *this; }; OmpxBare &operator=(OmpxBare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OmpxDynCgroupMem { OmpxDynCgroupMem(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem &operator=(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem &operator=(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem() = delete; OmpxDynCgroupMem(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Order { Order(Order &&) = default; Order &operator=(Order &&) = default; Order(const Order &) = delete; Order &operator=(const Order &) = delete; Order() = delete; Order(OmpOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpOrderClause v; };
struct Ordered { Ordered(Ordered &&) = default; Ordered &operator=(Ordered &&) = default; Ordered(const Ordered &) = delete; Ordered &operator=(const Ordered &) = delete; Ordered() = delete; Ordered(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Otherwise { Otherwise(Otherwise &&) = default; Otherwise &operator=(Otherwise &&) = default; Otherwise(const Otherwise &) = delete; Otherwise &operator=(const Otherwise &) = delete; Otherwise() = delete; Otherwise(std::optional<OmpOtherwiseClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<OmpOtherwiseClause> v; };
struct Partial { Partial(Partial &&) = default; Partial &operator=(Partial &&) = default; Partial(const Partial &) = delete; Partial &operator=(const Partial &) = delete; Partial() = delete; Partial(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Permutation { Permutation(Permutation &&) = default; Permutation &operator=(Permutation &&) = default; Permutation(const Permutation &) = delete; Permutation &operator=(const Permutation &) = delete; Permutation() = delete; Permutation(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct Priority { Priority(Priority &&) = default; Priority &operator=(Priority &&) = default; Priority(const Priority &) = delete; Priority &operator=(const Priority &) = delete; Priority() = delete; Priority(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct ProcBind { ProcBind(ProcBind &&) = default; ProcBind &operator=(ProcBind &&) = default; ProcBind(const ProcBind &) = delete; ProcBind &operator=(const ProcBind &) = delete; ProcBind() = delete; ProcBind(OmpProcBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpProcBindClause v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(OmpReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpReductionClause v; };
struct Relaxed { Relaxed() {} Relaxed(const Relaxed &) {} Relaxed(Relaxed &&) {} Relaxed &operator=(const Relaxed &) { return *this; }; Relaxed &operator=(Relaxed &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Release { Release() {} Release(const Release &) {} Release(Release &&) {} Release &operator=(const Release &) { return *this; }; Release &operator=(Release &&) { return *this; }; using EmptyTrait = std::true_type; };
struct ReverseOffload { ReverseOffload() {} ReverseOffload(const ReverseOffload &) {} ReverseOffload(ReverseOffload &&) {} ReverseOffload &operator=(const ReverseOffload &) { return *this; }; ReverseOffload &operator=(ReverseOffload &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Safelen { Safelen(Safelen &&) = default; Safelen &operator=(Safelen &&) = default; Safelen(const Safelen &) = delete; Safelen &operator=(const Safelen &) = delete; Safelen() = delete; Safelen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Schedule { Schedule(Schedule &&) = default; Schedule &operator=(Schedule &&) = default; Schedule(const Schedule &) = delete; Schedule &operator=(const Schedule &) = delete; Schedule() = delete; Schedule(OmpScheduleClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleClause v; };
struct SelfMaps { SelfMaps() {} SelfMaps(const SelfMaps &) {} SelfMaps(SelfMaps &&) {} SelfMaps &operator=(const SelfMaps &) { return *this; }; SelfMaps &operator=(SelfMaps &&) { return *this; }; using EmptyTrait = std::true_type; };
struct SeqCst { SeqCst() {} SeqCst(const SeqCst &) {} SeqCst(SeqCst &&) {} SeqCst &operator=(const SeqCst &) { return *this; }; SeqCst &operator=(SeqCst &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Severity { Severity(Severity &&) = default; Severity &operator=(Severity &&) = default; Severity(const Severity &) = delete; Severity &operator=(const Severity &) = delete; Severity() = delete; Severity(OmpSeverityClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpSeverityClause v; };
struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Simd { Simd() {} Simd(const Simd &) {} Simd(Simd &&) {} Simd &operator=(const Simd &) { return *this; }; Simd &operator=(Simd &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Simdlen { Simdlen(Simdlen &&) = default; Simdlen &operator=(Simdlen &&) = default; Simdlen(const Simdlen &) = delete; Simdlen &operator=(const Simdlen &) = delete; Simdlen() = delete; Simdlen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Sizes { Sizes(Sizes &&) = default; Sizes &operator=(Sizes &&) = default; Sizes(const Sizes &) = delete; Sizes &operator=(const Sizes &) = delete; Sizes() = delete; Sizes(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct TaskReduction { TaskReduction(TaskReduction &&) = default; TaskReduction &operator=(TaskReduction &&) = default; TaskReduction(const TaskReduction &) = delete; TaskReduction &operator=(const TaskReduction &) = delete; TaskReduction() = delete; TaskReduction(OmpTaskReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpTaskReductionClause v; };
struct ThreadLimit { ThreadLimit(ThreadLimit &&) = default; ThreadLimit &operator=(ThreadLimit &&) = default; ThreadLimit(const ThreadLimit &) = delete; ThreadLimit &operator=(const ThreadLimit &) = delete; ThreadLimit() = delete; ThreadLimit(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Threadprivate { Threadprivate() {} Threadprivate(const Threadprivate &) {} Threadprivate(Threadprivate &&) {} Threadprivate &operator=(const Threadprivate &) { return *this; }; Threadprivate &operator=(Threadprivate &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Threads { Threads() {} Threads(const Threads &) {} Threads(Threads &&) {} Threads &operator=(const Threads &) { return *this; }; Threads &operator=(Threads &&) { return *this; }; using EmptyTrait = std::true_type; };
struct To { To(To &&) = default; To &operator=(To &&) = default; To(const To &) = delete; To &operator=(const To &) = delete; To() = delete; To(OmpToClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpToClause v; };
struct UnifiedAddress { UnifiedAddress() {} UnifiedAddress(const UnifiedAddress &) {} UnifiedAddress(UnifiedAddress &&) {} UnifiedAddress &operator=(const UnifiedAddress &) { return *this; }; UnifiedAddress &operator=(UnifiedAddress &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UnifiedSharedMemory { UnifiedSharedMemory() {} UnifiedSharedMemory(const UnifiedSharedMemory &) {} UnifiedSharedMemory(UnifiedSharedMemory &&) {} UnifiedSharedMemory &operator=(const UnifiedSharedMemory &) { return *this; }; UnifiedSharedMemory &operator=(UnifiedSharedMemory &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Uniform { Uniform(Uniform &&) = default; Uniform &operator=(Uniform &&) = default; Uniform(const Uniform &) = delete; Uniform &operator=(const Uniform &) = delete; Uniform() = delete; Uniform(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Untied { Untied() {} Untied(const Untied &) {} Untied(Untied &&) {} Untied &operator=(const Untied &) { return *this; }; Untied &operator=(Untied &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Update { Update(Update &&) = default; Update &operator=(Update &&) = default; Update(const Update &) = delete; Update &operator=(const Update &) = delete; Update() = delete; Update(std::optional<OmpUpdateClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<OmpUpdateClause> v; };
struct Use { Use(Use &&) = default; Use &operator=(Use &&) = default; Use(const Use &) = delete; Use &operator=(const Use &) = delete; Use() = delete; Use(OmpUseClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpUseClause v; };
struct UseDeviceAddr { UseDeviceAddr(UseDeviceAddr &&) = default; UseDeviceAddr &operator=(UseDeviceAddr &&) = default; UseDeviceAddr(const UseDeviceAddr &) = delete; UseDeviceAddr &operator=(const UseDeviceAddr &) = delete; UseDeviceAddr() = delete; UseDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UseDevicePtr { UseDevicePtr(UseDevicePtr &&) = default; UseDevicePtr &operator=(UseDevicePtr &&) = default; UseDevicePtr(const UseDevicePtr &) = delete; UseDevicePtr &operator=(const UseDevicePtr &) = delete; UseDevicePtr() = delete; UseDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UsesAllocators { UsesAllocators() {} UsesAllocators(const UsesAllocators &) {} UsesAllocators(UsesAllocators &&) {} UsesAllocators &operator=(const UsesAllocators &) { return *this; }; UsesAllocators &operator=(UsesAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Weak { Weak() {} Weak(const Weak &) {} Weak(Weak &&) {} Weak &operator=(const Weak &) { return *this; }; Weak &operator=(Weak &&) { return *this; }; using EmptyTrait = std::true_type; };
struct When { When(When &&) = default; When &operator=(When &&) = default; When(const When &) = delete; When &operator=(const When &) = delete; When() = delete; When(OmpWhenClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpWhenClause v; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 4723 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3927 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
Absent
, AcqRel
, Acquire
, AdjustArgs
, Affinity
, Align
, Aligned
, Allocate
, Allocator
, AppendArgs
, At
, AtomicDefaultMemOrder
, Bind
, CancellationConstructType
, Capture
, Collapse
, Compare
, Contains
, Copyprivate
, Copyin
, Default
, Defaultmap
, Depend
, Depobj
, Destroy
, Detach
, Device
, DeviceType
, DistSchedule
, Doacross
, DynamicAllocators
, Enter
, Exclusive
, Fail
, Filter
, Final
, Firstprivate
, Flush
, From
, Full
, Grainsize
, HasDeviceAddr
, Hint
, Holds
, If
, InReduction
, Inbranch
, Inclusive
, Indirect
, Init
, Initializer
, IsDevicePtr
, Lastprivate
, Linear
, Link
, Map
, Match
, MemoryOrder
, Mergeable
, Message
, Nogroup
, NoOpenmp
, NoOpenmpConstructs
, NoOpenmpRoutines
, NoParallelism
, Nowait
, Nocontext
, Nontemporal
, Notinbranch
, Novariants
, NumTasks
, NumTeams
, NumThreads
, OmpxAttribute
, OmpxBare
, OmpxDynCgroupMem
, Order
, Ordered
, Otherwise
, Partial
, Permutation
, Priority
, Private
, ProcBind
, Read
, Reduction
, Relaxed
, Release
, ReverseOffload
, Safelen
, Schedule
, SelfMaps
, SeqCst
, Severity
, Shared
, Simd
, Simdlen
, Sizes
, TaskReduction
, ThreadLimit
, Threadprivate
, Threads
, To
, UnifiedAddress
, UnifiedSharedMemory
, Uniform
, Unknown
, Untied
, Update
, Use
, UseDeviceAddr
, UseDevicePtr
, UsesAllocators
, Weak
, When
, Write
# 4729 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct OmpClauseList {
  OmpClauseList(OmpClauseList &&) = default; OmpClauseList &operator=(OmpClauseList &&) = default; OmpClauseList(const OmpClauseList &) = delete; OmpClauseList &operator=(const OmpClauseList &) = delete; OmpClauseList() = delete; OmpClauseList(std::list<OmpClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpClause> v;
  CharBlock source;
};



struct OmpDirectiveSpecification {
  enum class Flags { None, DeprecatedSyntax }; [[maybe_unused]] static constexpr std::size_t Flags_enumSize{ ::Fortran::common::CountEnumNames("None, DeprecatedSyntax")}; [[maybe_unused]] static inline std::size_t EnumToInt(Flags e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Flags e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Flags_enumSize>("None, DeprecatedSyntax")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachFlags(std::function<void(Flags)> f) { for (std::size_t i{0}; i < Flags_enumSize; ++i) { f(static_cast<Flags>(i)); } };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDirectiveSpecification(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDirectiveSpecification(OmpDirectiveSpecification &&) = default; OmpDirectiveSpecification &operator=(OmpDirectiveSpecification &&) = default; OmpDirectiveSpecification(const OmpDirectiveSpecification &) = delete; OmpDirectiveSpecification &operator=(const OmpDirectiveSpecification &) = delete; OmpDirectiveSpecification() = delete;
  const OmpDirectiveName &DirName() const {
    return std::get<OmpDirectiveName>(t);
  }
  llvm::omp::Directive DirId() const {
    return DirName().v;
  }
  const OmpArgumentList &Arguments() const;
  const OmpClauseList &Clauses() const;

  CharBlock source;
  std::tuple<OmpDirectiveName, std::optional<OmpArgumentList>,
      std::optional<OmpClauseList>, Flags>
      t;
};





struct OmpBeginDirective : public OmpDirectiveSpecification {
  using OmpDirectiveSpecification::OmpDirectiveSpecification; OmpBeginDirective(OmpDirectiveSpecification &&b) : OmpDirectiveSpecification(std::move(b)) {} using TupleTrait = std::true_type; OmpBeginDirective(OmpBeginDirective &&) = default; OmpBeginDirective &operator=(OmpBeginDirective &&) = default; OmpBeginDirective(const OmpBeginDirective &) = delete; OmpBeginDirective &operator=(const OmpBeginDirective &) = delete; OmpBeginDirective() = delete;

};

struct OmpEndDirective : public OmpDirectiveSpecification {
  using OmpDirectiveSpecification::OmpDirectiveSpecification; OmpEndDirective(OmpDirectiveSpecification &&b) : OmpDirectiveSpecification(std::move(b)) {} using TupleTrait = std::true_type; OmpEndDirective(OmpEndDirective &&) = default; OmpEndDirective &operator=(OmpEndDirective &&) = default; OmpEndDirective(const OmpEndDirective &) = delete; OmpEndDirective &operator=(const OmpEndDirective &) = delete; OmpEndDirective() = delete;
};


struct OmpBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBlockConstruct(OmpBlockConstruct &&) = default; OmpBlockConstruct &operator=(OmpBlockConstruct &&) = default; OmpBlockConstruct(const OmpBlockConstruct &) = delete; OmpBlockConstruct &operator=(const OmpBlockConstruct &) = delete; OmpBlockConstruct() = delete;
  const OmpBeginDirective &BeginDir() const {
    return std::get<OmpBeginDirective>(t);
  }
  const std::optional<OmpEndDirective> &EndDir() const {
    return std::get<std::optional<OmpEndDirective>>(t);
  }

  CharBlock source;
  std::tuple<OmpBeginDirective, Block, std::optional<OmpEndDirective>> t;
};

struct OmpMetadirectiveDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMetadirectiveDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMetadirectiveDirective(OmpMetadirectiveDirective &&) = default; OmpMetadirectiveDirective &operator=(OmpMetadirectiveDirective &&) = default; OmpMetadirectiveDirective(const OmpMetadirectiveDirective &) = delete; OmpMetadirectiveDirective &operator=(const OmpMetadirectiveDirective &) = delete; OmpMetadirectiveDirective() = delete;
  std::tuple<Verbatim, OmpClauseList> t;
  CharBlock source;
};





struct OmpNothingDirective {
  using EmptyTrait = std::true_type;
  OmpNothingDirective(OmpNothingDirective &&) = default; OmpNothingDirective &operator=(OmpNothingDirective &&) = default; OmpNothingDirective(const OmpNothingDirective &) = delete; OmpNothingDirective &operator=(const OmpNothingDirective &) = delete;
  CharBlock source;
};



struct OmpErrorDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpErrorDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpErrorDirective(OmpErrorDirective &&) = default; OmpErrorDirective &operator=(OmpErrorDirective &&) = default; OmpErrorDirective(const OmpErrorDirective &) = delete; OmpErrorDirective &operator=(const OmpErrorDirective &) = delete; OmpErrorDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList> t;
};

struct OpenMPUtilityConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPUtilityConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPUtilityConstruct(OpenMPUtilityConstruct &&) = default; OpenMPUtilityConstruct &operator=(OpenMPUtilityConstruct &&) = default; OpenMPUtilityConstruct(const OpenMPUtilityConstruct &) = delete; OpenMPUtilityConstruct &operator=(const OpenMPUtilityConstruct &) = delete; OpenMPUtilityConstruct() = delete;
  CharBlock source;
  std::variant<OmpErrorDirective, OmpNothingDirective> u;
};






struct OpenMPDeclarativeAssumes {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclarativeAssumes(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclarativeAssumes(OpenMPDeclarativeAssumes &&) = default; OpenMPDeclarativeAssumes &operator=(OpenMPDeclarativeAssumes &&) = default; OpenMPDeclarativeAssumes(const OpenMPDeclarativeAssumes &) = delete; OpenMPDeclarativeAssumes &operator=(const OpenMPDeclarativeAssumes &) = delete; OpenMPDeclarativeAssumes() = delete;
  std::tuple<Verbatim, OmpClauseList> t;
  CharBlock source;
};

struct OmpAssumeDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAssumeDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAssumeDirective(OmpAssumeDirective &&) = default; OmpAssumeDirective &operator=(OmpAssumeDirective &&) = default; OmpAssumeDirective(const OmpAssumeDirective &) = delete; OmpAssumeDirective &operator=(const OmpAssumeDirective &) = delete; OmpAssumeDirective() = delete;
  std::tuple<Verbatim, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndAssumeDirective {
  OmpEndAssumeDirective(OmpEndAssumeDirective &&) = default; OmpEndAssumeDirective &operator=(OmpEndAssumeDirective &&) = default; OmpEndAssumeDirective(const OmpEndAssumeDirective &) = delete; OmpEndAssumeDirective &operator=(const OmpEndAssumeDirective &) = delete; OmpEndAssumeDirective() = delete; OmpEndAssumeDirective(Verbatim &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Verbatim v;
  CharBlock source;
};
# 4844 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OpenMPAssumeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPAssumeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPAssumeConstruct(OpenMPAssumeConstruct &&) = default; OpenMPAssumeConstruct &operator=(OpenMPAssumeConstruct &&) = default; OpenMPAssumeConstruct(const OpenMPAssumeConstruct &) = delete; OpenMPAssumeConstruct &operator=(const OpenMPAssumeConstruct &) = delete; OpenMPAssumeConstruct() = delete;
  std::tuple<OmpAssumeDirective, Block, std::optional<OmpEndAssumeDirective>> t;
  CharBlock source;
};



struct OmpSectionsDirective {
  OmpSectionsDirective(OmpSectionsDirective &&) = default; OmpSectionsDirective &operator=(OmpSectionsDirective &&) = default; OmpSectionsDirective(const OmpSectionsDirective &) = delete; OmpSectionsDirective &operator=(const OmpSectionsDirective &) = delete; OmpSectionsDirective() = delete; OmpSectionsDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};

struct OmpBeginSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginSectionsDirective(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective &operator=(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective &operator=(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};
struct OmpEndSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndSectionsDirective(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective &operator=(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective &operator=(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};






struct OpenMPSectionConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSectionConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSectionConstruct(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct &operator=(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct &operator=(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct() = delete;
  std::tuple<std::optional<OmpDirectiveSpecification>, Block> t;
  CharBlock source;
};

struct OpenMPSectionsConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSectionsConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSectionsConstruct(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct &operator=(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct &operator=(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct() = delete;
  CharBlock source;


  std::tuple<OmpBeginSectionsDirective, std::list<OpenMPConstruct>,
      OmpEndSectionsDirective>
      t;
};

struct OmpDeclareVariantDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDeclareVariantDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDeclareVariantDirective(OmpDeclareVariantDirective &&) = default; OmpDeclareVariantDirective &operator=(OmpDeclareVariantDirective &&) = default; OmpDeclareVariantDirective(const OmpDeclareVariantDirective &) = delete; OmpDeclareVariantDirective &operator=(const OmpDeclareVariantDirective &) = delete; OmpDeclareVariantDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, Name, OmpClauseList> t;
};




struct OmpDeclareTargetWithList {
  OmpDeclareTargetWithList(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList &operator=(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList &operator=(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList() = delete; OmpDeclareTargetWithList(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v;
  CharBlock source;
};

struct OmpDeclareTargetWithClause {
  OmpDeclareTargetWithClause(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause &operator=(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause &operator=(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause() = delete; OmpDeclareTargetWithClause(OmpClauseList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpClauseList v;
  CharBlock source;
};

struct OmpDeclareTargetSpecifier {
  template <typename A, typename = common::NoLvalue<A>> OmpDeclareTargetSpecifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDeclareTargetSpecifier(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier &operator=(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier &operator=(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier() = delete;
  std::variant<OmpDeclareTargetWithList, OmpDeclareTargetWithClause> u;
};

struct OpenMPDeclareTargetConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareTargetConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareTargetConstruct(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct &operator=(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct &operator=(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpDeclareTargetSpecifier> t;
};



struct OpenMPDeclareMapperConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareMapperConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareMapperConstruct(OpenMPDeclareMapperConstruct &&) = default; OpenMPDeclareMapperConstruct &operator=(OpenMPDeclareMapperConstruct &&) = default; OpenMPDeclareMapperConstruct(const OpenMPDeclareMapperConstruct &) = delete; OpenMPDeclareMapperConstruct &operator=(const OpenMPDeclareMapperConstruct &) = delete; OpenMPDeclareMapperConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpMapperSpecifier, OmpClauseList> t;
};




struct OpenMPDeclareReductionConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareReductionConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareReductionConstruct(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct &operator=(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct &operator=(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, common::Indirection<OmpReductionSpecifier>,
      std::optional<OmpClauseList>>
      t;
};



struct OpenMPDeclareSimdConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareSimdConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareSimdConstruct(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct &operator=(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct &operator=(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};


struct OpenMPRequiresConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPRequiresConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPRequiresConstruct(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct &operator=(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct &operator=(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList> t;
};


struct OpenMPThreadprivate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPThreadprivate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPThreadprivate(OpenMPThreadprivate &&) = default; OpenMPThreadprivate &operator=(OpenMPThreadprivate &&) = default; OpenMPThreadprivate(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate &operator=(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList> t;
};


struct OpenMPDeclarativeAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclarativeAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclarativeAllocate(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate &operator=(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate &operator=(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList, OmpClauseList> t;
};

struct OpenMPDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPDeclarativeConstruct(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct &operator=(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct &operator=(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPDeclarativeAllocate, OpenMPDeclarativeAssumes,
      OpenMPDeclareMapperConstruct, OpenMPDeclareReductionConstruct,
      OpenMPDeclareSimdConstruct, OpenMPDeclareTargetConstruct,
      OmpDeclareVariantDirective, OpenMPThreadprivate, OpenMPRequiresConstruct,
      OpenMPUtilityConstruct, OmpMetadirectiveDirective>
      u;
};


struct OmpCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpCriticalDirective(OmpCriticalDirective &&) = default; OmpCriticalDirective &operator=(OmpCriticalDirective &&) = default; OmpCriticalDirective(const OmpCriticalDirective &) = delete; OmpCriticalDirective &operator=(const OmpCriticalDirective &) = delete; OmpCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};
struct OmpEndCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndCriticalDirective(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective &operator=(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective &operator=(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>> t;
};

struct OpenMPCriticalConstruct : public OmpBlockConstruct {
  using OmpBlockConstruct::OmpBlockConstruct; OpenMPCriticalConstruct(OmpBlockConstruct &&b) : OmpBlockConstruct(std::move(b)) {} using TupleTrait = std::true_type; OpenMPCriticalConstruct(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct &operator=(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct &operator=(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct() = delete;
};





struct OpenMPExecutableAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPExecutableAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPExecutableAllocate(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate &operator=(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate &operator=(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<OmpObjectList>, OmpClauseList,
      std::optional<std::list<OpenMPDeclarativeAllocate>>,
      Statement<AllocateStmt>>
      t;
};







struct OpenMPAllocatorsConstruct : public OmpBlockConstruct {
  using OmpBlockConstruct::OmpBlockConstruct; OpenMPAllocatorsConstruct(OmpBlockConstruct &&b) : OmpBlockConstruct(std::move(b)) {} using TupleTrait = std::true_type; OpenMPAllocatorsConstruct(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct &operator=(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct &operator=(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct() = delete;

};

struct OpenMPAtomicConstruct : public OmpBlockConstruct {
  llvm::omp::Clause GetKind() const;
  bool IsCapture() const;
  bool IsCompare() const;
  using OmpBlockConstruct::OmpBlockConstruct; OpenMPAtomicConstruct(OmpBlockConstruct &&b) : OmpBlockConstruct(std::move(b)) {} using TupleTrait = std::true_type; OpenMPAtomicConstruct(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct &operator=(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct &operator=(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct() = delete;



  struct Analysis {
    static constexpr int None = 0;
    static constexpr int Read = 1;
    static constexpr int Write = 2;
    static constexpr int Update = Read | Write;
    static constexpr int Action = 3;
    static constexpr int IfTrue = 4;
    static constexpr int IfFalse = 8;
    static constexpr int Condition = 12;

    struct Op {
      int what;
      AssignmentStmt::TypedAssignment assign;
    };
    TypedExpr atom, cond;
    Op op0, op1;
  };

  mutable Analysis analysis;
};


struct OmpLoopDirective {
  OmpLoopDirective(OmpLoopDirective &&) = default; OmpLoopDirective &operator=(OmpLoopDirective &&) = default; OmpLoopDirective(const OmpLoopDirective &) = delete; OmpLoopDirective &operator=(const OmpLoopDirective &) = delete; OmpLoopDirective() = delete; OmpLoopDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};


struct OpenMPCancellationPointConstruct {
  OpenMPCancellationPointConstruct(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct &operator=(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct &operator=(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct() = delete; OpenMPCancellationPointConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;

  CharBlock source;
};


struct OpenMPCancelConstruct {
  OpenMPCancelConstruct(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct &operator=(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct &operator=(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct() = delete; OpenMPCancelConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;
  CharBlock source;
};







struct OpenMPDepobjConstruct {
  OpenMPDepobjConstruct(OpenMPDepobjConstruct &&) = default; OpenMPDepobjConstruct &operator=(OpenMPDepobjConstruct &&) = default; OpenMPDepobjConstruct(const OpenMPDepobjConstruct &) = delete; OpenMPDepobjConstruct &operator=(const OpenMPDepobjConstruct &) = delete; OpenMPDepobjConstruct() = delete; OpenMPDepobjConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;
  CharBlock source;
};
# 5086 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OpenMPDispatchConstruct : public OmpBlockConstruct {
  using OmpBlockConstruct::OmpBlockConstruct; OpenMPDispatchConstruct(OmpBlockConstruct &&b) : OmpBlockConstruct(std::move(b)) {} using TupleTrait = std::true_type; OpenMPDispatchConstruct(OpenMPDispatchConstruct &&) = default; OpenMPDispatchConstruct &operator=(OpenMPDispatchConstruct &&) = default; OpenMPDispatchConstruct(const OpenMPDispatchConstruct &) = delete; OpenMPDispatchConstruct &operator=(const OpenMPDispatchConstruct &) = delete; OpenMPDispatchConstruct() = delete;
};
# 5102 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OpenMPFlushConstruct {
  OpenMPFlushConstruct(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct &operator=(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct &operator=(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct() = delete; OpenMPFlushConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;
  CharBlock source;
};




struct OpenMPInteropConstruct {
  OpenMPInteropConstruct(OpenMPInteropConstruct &&) = default; OpenMPInteropConstruct &operator=(OpenMPInteropConstruct &&) = default; OpenMPInteropConstruct(const OpenMPInteropConstruct &) = delete; OpenMPInteropConstruct &operator=(const OpenMPInteropConstruct &) = delete; OpenMPInteropConstruct() = delete; OpenMPInteropConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;
  CharBlock source;
};

struct OpenMPSimpleStandaloneConstruct {
  OpenMPSimpleStandaloneConstruct(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct &operator=(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct &operator=(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct() = delete; OpenMPSimpleStandaloneConstruct(OmpDirectiveSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveSpecification v;

  CharBlock source;
};

struct OpenMPStandaloneConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPStandaloneConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPStandaloneConstruct(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct &operator=(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct &operator=(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPSimpleStandaloneConstruct, OpenMPFlushConstruct,
      OpenMPCancelConstruct, OpenMPCancellationPointConstruct,
      OpenMPDepobjConstruct, OmpMetadirectiveDirective, OpenMPInteropConstruct>
      u;
};

struct OmpBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginLoopDirective(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective &operator=(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective &operator=(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndLoopDirective(OmpEndLoopDirective &&) = default; OmpEndLoopDirective &operator=(OmpEndLoopDirective &&) = default; OmpEndLoopDirective(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective &operator=(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OpenMPBlockConstruct : public OmpBlockConstruct {
  using OmpBlockConstruct::OmpBlockConstruct; OpenMPBlockConstruct(OmpBlockConstruct &&b) : OmpBlockConstruct(std::move(b)) {} using TupleTrait = std::true_type; OpenMPBlockConstruct(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct &operator=(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct &operator=(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct() = delete;
};


using NestedConstruct =
    std::variant<DoConstruct, common::Indirection<OpenMPLoopConstruct>>;
struct OpenMPLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPLoopConstruct(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct &operator=(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct &operator=(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct() = delete;
  OpenMPLoopConstruct(OmpBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<OmpBeginLoopDirective, std::optional<NestedConstruct>,
      std::optional<OmpEndLoopDirective>>
      t;
};



struct OpenMPExecDirective {
  OpenMPExecDirective(OpenMPExecDirective &&) = default; OpenMPExecDirective &operator=(OpenMPExecDirective &&) = default; OpenMPExecDirective(const OpenMPExecDirective &) = delete; OpenMPExecDirective &operator=(const OpenMPExecDirective &) = delete; OpenMPExecDirective() = delete; OpenMPExecDirective(OmpDirectiveName &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDirectiveName v;
  CharBlock source;
};

struct OpenMPConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPConstruct(OpenMPConstruct &&) = default; OpenMPConstruct &operator=(OpenMPConstruct &&) = default; OpenMPConstruct(const OpenMPConstruct &) = delete; OpenMPConstruct &operator=(const OpenMPConstruct &) = delete; OpenMPConstruct() = delete;
  std::variant<OpenMPStandaloneConstruct, OpenMPSectionsConstruct,
      OpenMPSectionConstruct, OpenMPLoopConstruct, OpenMPBlockConstruct,
      OpenMPAtomicConstruct, OpenMPDeclarativeAllocate, OpenMPDispatchConstruct,
      OpenMPUtilityConstruct, OpenMPExecutableAllocate,
      OpenMPAllocatorsConstruct, OpenMPAssumeConstruct, OpenMPCriticalConstruct>
      u;
};



struct AccObject {
  template <typename A, typename = common::NoLvalue<A>> AccObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccObject(AccObject &&) = default; AccObject &operator=(AccObject &&) = default; AccObject(const AccObject &) = delete; AccObject &operator=(const AccObject &) = delete; AccObject() = delete;
  std::variant<Designator, Name> u;
};

struct AccObjectList { AccObjectList(AccObjectList &&) = default; AccObjectList &operator=(AccObjectList &&) = default; AccObjectList(const AccObjectList &) = delete; AccObjectList &operator=(const AccObjectList &) = delete; AccObjectList() = delete; AccObjectList(std::list<AccObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccObject> v; };


struct AccBlockDirective {
  AccBlockDirective(AccBlockDirective &&) = default; AccBlockDirective &operator=(AccBlockDirective &&) = default; AccBlockDirective(const AccBlockDirective &) = delete; AccBlockDirective &operator=(const AccBlockDirective &) = delete; AccBlockDirective() = delete; AccBlockDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccLoopDirective {
  AccLoopDirective(AccLoopDirective &&) = default; AccLoopDirective &operator=(AccLoopDirective &&) = default; AccLoopDirective(const AccLoopDirective &) = delete; AccLoopDirective &operator=(const AccLoopDirective &) = delete; AccLoopDirective() = delete; AccLoopDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccStandaloneDirective {
  AccStandaloneDirective(AccStandaloneDirective &&) = default; AccStandaloneDirective &operator=(AccStandaloneDirective &&) = default; AccStandaloneDirective(const AccStandaloneDirective &) = delete; AccStandaloneDirective &operator=(const AccStandaloneDirective &) = delete; AccStandaloneDirective() = delete; AccStandaloneDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccCombinedDirective {
  AccCombinedDirective(AccCombinedDirective &&) = default; AccCombinedDirective &operator=(AccCombinedDirective &&) = default; AccCombinedDirective(const AccCombinedDirective &) = delete; AccCombinedDirective &operator=(const AccCombinedDirective &) = delete; AccCombinedDirective() = delete; AccCombinedDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccDeclarativeDirective {
  AccDeclarativeDirective(AccDeclarativeDirective &&) = default; AccDeclarativeDirective &operator=(AccDeclarativeDirective &&) = default; AccDeclarativeDirective(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective &operator=(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective() = delete; AccDeclarativeDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccBindClause {
  template <typename A, typename = common::NoLvalue<A>> AccBindClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccBindClause(AccBindClause &&) = default; AccBindClause &operator=(AccBindClause &&) = default; AccBindClause(const AccBindClause &) = delete; AccBindClause &operator=(const AccBindClause &) = delete; AccBindClause() = delete;
  std::variant<Name, ScalarDefaultCharExpr> u;
  CharBlock source;
};

struct AccDefaultClause {
  AccDefaultClause(AccDefaultClause &&) = default; AccDefaultClause &operator=(AccDefaultClause &&) = default; AccDefaultClause(const AccDefaultClause &) = delete; AccDefaultClause &operator=(const AccDefaultClause &) = delete; AccDefaultClause() = delete; AccDefaultClause(llvm::acc::DefaultValue &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::DefaultValue v;
  CharBlock source;
};

struct AccDataModifier {
  enum class Modifier { ReadOnly, Zero }; [[maybe_unused]] static constexpr std::size_t Modifier_enumSize{ ::Fortran::common::CountEnumNames("ReadOnly, Zero")}; [[maybe_unused]] static inline std::size_t EnumToInt(Modifier e) { return static_cast<std::size_t>(e); } [[maybe_unused]] static inline std::string_view EnumToString(Modifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Modifier_enumSize>("ReadOnly, Zero")}; return names[static_cast<std::size_t>(e)]; } [[maybe_unused]] inline void ForEachModifier(std::function<void(Modifier)> f) { for (std::size_t i{0}; i < Modifier_enumSize; ++i) { f(static_cast<Modifier>(i)); } }
  AccDataModifier(AccDataModifier &&) = default; AccDataModifier &operator=(AccDataModifier &&) = default; AccDataModifier(const AccDataModifier &) = delete; AccDataModifier &operator=(const AccDataModifier &) = delete; AccDataModifier() = delete; AccDataModifier(Modifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Modifier v;
  CharBlock source;
};

struct AccObjectListWithModifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithModifier(AccObjectListWithModifier &&) = default; AccObjectListWithModifier &operator=(AccObjectListWithModifier &&) = default; AccObjectListWithModifier(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier &operator=(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier() = delete;
  std::tuple<std::optional<AccDataModifier>, AccObjectList> t;
};

struct AccObjectListWithReduction {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithReduction(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithReduction(AccObjectListWithReduction &&) = default; AccObjectListWithReduction &operator=(AccObjectListWithReduction &&) = default; AccObjectListWithReduction(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction &operator=(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction() = delete;
  std::tuple<ReductionOperator, AccObjectList> t;
};

struct AccWaitArgument {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccWaitArgument(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccWaitArgument(AccWaitArgument &&) = default; AccWaitArgument &operator=(AccWaitArgument &&) = default; AccWaitArgument(const AccWaitArgument &) = delete; AccWaitArgument &operator=(const AccWaitArgument &) = delete; AccWaitArgument() = delete;
  std::tuple<std::optional<ScalarIntExpr>, std::list<ScalarIntExpr>> t;
};

struct AccDeviceTypeExpr {
  AccDeviceTypeExpr(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr &operator=(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr &operator=(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr() = delete; AccDeviceTypeExpr(Fortran::common::OpenACCDeviceType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Fortran::common::OpenACCDeviceType v;

  CharBlock source;
};

struct AccDeviceTypeExprList {
  AccDeviceTypeExprList(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList &operator=(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList &operator=(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList() = delete; AccDeviceTypeExprList(std::list<AccDeviceTypeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccDeviceTypeExpr> v;

};

struct AccTileExpr {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccTileExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccTileExpr(AccTileExpr &&) = default; AccTileExpr &operator=(AccTileExpr &&) = default; AccTileExpr(const AccTileExpr &) = delete; AccTileExpr &operator=(const AccTileExpr &) = delete; AccTileExpr() = delete;
  CharBlock source;
  std::tuple<std::optional<ScalarIntConstantExpr>> t;
};

struct AccTileExprList {
  AccTileExprList(AccTileExprList &&) = default; AccTileExprList &operator=(AccTileExprList &&) = default; AccTileExprList(const AccTileExprList &) = delete; AccTileExprList &operator=(const AccTileExprList &) = delete; AccTileExprList() = delete; AccTileExprList(std::list<AccTileExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccTileExpr> v;
};

struct AccSizeExpr {
  AccSizeExpr(AccSizeExpr &&) = default; AccSizeExpr &operator=(AccSizeExpr &&) = default; AccSizeExpr(const AccSizeExpr &) = delete; AccSizeExpr &operator=(const AccSizeExpr &) = delete; AccSizeExpr() = delete; AccSizeExpr(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v;
};

struct AccSizeExprList {
  AccSizeExprList(AccSizeExprList &&) = default; AccSizeExprList &operator=(AccSizeExprList &&) = default; AccSizeExprList(const AccSizeExprList &) = delete; AccSizeExprList &operator=(const AccSizeExprList &) = delete; AccSizeExprList() = delete; AccSizeExprList(std::list<AccSizeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccSizeExpr> v;
};

struct AccSelfClause {
  template <typename A, typename = common::NoLvalue<A>> AccSelfClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccSelfClause(AccSelfClause &&) = default; AccSelfClause &operator=(AccSelfClause &&) = default; AccSelfClause(const AccSelfClause &) = delete; AccSelfClause &operator=(const AccSelfClause &) = delete; AccSelfClause() = delete;
  std::variant<std::optional<ScalarLogicalExpr>, AccObjectList> u;
  CharBlock source;
};


struct AccGangArg {
  template <typename A, typename = common::NoLvalue<A>> AccGangArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccGangArg(AccGangArg &&) = default; AccGangArg &operator=(AccGangArg &&) = default; AccGangArg(const AccGangArg &) = delete; AccGangArg &operator=(const AccGangArg &) = delete; AccGangArg() = delete;
  struct Num { Num(Num &&) = default; Num &operator=(Num &&) = default; Num(const Num &) = delete; Num &operator=(const Num &) = delete; Num() = delete; Num(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Dim { Dim(Dim &&) = default; Dim &operator=(Dim &&) = default; Dim(const Dim &) = delete; Dim &operator=(const Dim &) = delete; Dim() = delete; Dim(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Static { Static(Static &&) = default; Static &operator=(Static &&) = default; Static(const Static &) = delete; Static &operator=(const Static &) = delete; Static() = delete; Static(AccSizeExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccSizeExpr v; };
  std::variant<Num, Dim, Static> u;
  CharBlock source;
};

struct AccGangArgList {
  AccGangArgList(AccGangArgList &&) = default; AccGangArgList &operator=(AccGangArgList &&) = default; AccGangArgList(const AccGangArgList &) = delete; AccGangArgList &operator=(const AccGangArgList &) = delete; AccGangArgList() = delete; AccGangArgList(std::list<AccGangArg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccGangArg> v;
};

struct AccCollapseArg {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccCollapseArg(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccCollapseArg(AccCollapseArg &&) = default; AccCollapseArg &operator=(AccCollapseArg &&) = default; AccCollapseArg(const AccCollapseArg &) = delete; AccCollapseArg &operator=(const AccCollapseArg &) = delete; AccCollapseArg() = delete;
  std::tuple<bool, ScalarIntConstantExpr> t;
};

struct AccClause {
  template <typename A, typename = common::NoLvalue<A>> AccClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccClause(AccClause &&) = default; AccClause &operator=(AccClause &&) = default; AccClause(const AccClause &) = delete; AccClause &operator=(const AccClause &) = delete; AccClause() = delete;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 702 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
struct Async { Async(Async &&) = default; Async &operator=(Async &&) = default; Async(const Async &) = delete; Async &operator=(const Async &) = delete; Async() = delete; Async(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Attach { Attach(Attach &&) = default; Attach &operator=(Attach &&) = default; Attach(const Attach &) = delete; Attach &operator=(const Attach &) = delete; Attach() = delete; Attach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Auto { Auto() {} Auto(const Auto &) {} Auto(Auto &&) {} Auto &operator=(const Auto &) { return *this; }; Auto &operator=(Auto &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Bind { Bind(Bind &&) = default; Bind &operator=(Bind &&) = default; Bind(const Bind &) = delete; Bind &operator=(const Bind &) = delete; Bind() = delete; Bind(AccBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBindClause v; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(AccCollapseArg &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCollapseArg v; };
struct Copy { Copy(Copy &&) = default; Copy &operator=(Copy &&) = default; Copy(const Copy &) = delete; Copy &operator=(const Copy &) = delete; Copy() = delete; Copy(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Copyout { Copyout(Copyout &&) = default; Copyout &operator=(Copyout &&) = default; Copyout(const Copyout &) = delete; Copyout &operator=(const Copyout &) = delete; Copyout() = delete; Copyout(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Create { Create(Create &&) = default; Create &operator=(Create &&) = default; Create(const Create &) = delete; Create &operator=(const Create &) = delete; Create() = delete; Create(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(AccDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDefaultClause v; };
struct DefaultAsync { DefaultAsync(DefaultAsync &&) = default; DefaultAsync &operator=(DefaultAsync &&) = default; DefaultAsync(const DefaultAsync &) = delete; DefaultAsync &operator=(const DefaultAsync &) = delete; DefaultAsync() = delete; DefaultAsync(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Delete { Delete(Delete &&) = default; Delete &operator=(Delete &&) = default; Delete(const Delete &) = delete; Delete &operator=(const Delete &) = delete; Delete() = delete; Delete(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Detach { Detach(Detach &&) = default; Detach &operator=(Detach &&) = default; Detach(const Detach &) = delete; Detach &operator=(const Detach &) = delete; Detach() = delete; Detach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceNum { DeviceNum(DeviceNum &&) = default; DeviceNum &operator=(DeviceNum &&) = default; DeviceNum(const DeviceNum &) = delete; DeviceNum &operator=(const DeviceNum &) = delete; DeviceNum() = delete; DeviceNum(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Deviceptr { Deviceptr(Deviceptr &&) = default; Deviceptr &operator=(Deviceptr &&) = default; Deviceptr(const Deviceptr &) = delete; Deviceptr &operator=(const Deviceptr &) = delete; Deviceptr() = delete; Deviceptr(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceResident { DeviceResident(DeviceResident &&) = default; DeviceResident &operator=(DeviceResident &&) = default; DeviceResident(const DeviceResident &) = delete; DeviceResident &operator=(const DeviceResident &) = delete; DeviceResident() = delete; DeviceResident(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(AccDeviceTypeExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDeviceTypeExprList v; };
struct Finalize { Finalize() {} Finalize(const Finalize &) {} Finalize(Finalize &&) {} Finalize &operator=(const Finalize &) { return *this; }; Finalize &operator=(Finalize &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Gang { Gang(Gang &&) = default; Gang &operator=(Gang &&) = default; Gang(const Gang &) = delete; Gang &operator=(const Gang &) = delete; Gang() = delete; Gang(std::optional<AccGangArgList> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccGangArgList> v; };
struct Host { Host(Host &&) = default; Host &operator=(Host &&) = default; Host(const Host &) = delete; Host &operator=(const Host &) = delete; Host() = delete; Host(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(ScalarExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarExpr v; };
struct IfPresent { IfPresent() {} IfPresent(const IfPresent &) {} IfPresent(IfPresent &&) {} IfPresent &operator=(const IfPresent &) { return *this; }; IfPresent &operator=(IfPresent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Independent { Independent() {} Independent(const Independent &) {} Independent(Independent &&) {} Independent &operator=(const Independent &) { return *this; }; Independent &operator=(Independent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct NoCreate { NoCreate(NoCreate &&) = default; NoCreate &operator=(NoCreate &&) = default; NoCreate(const NoCreate &) = delete; NoCreate &operator=(const NoCreate &) = delete; NoCreate() = delete; NoCreate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Nohost { Nohost() {} Nohost(const Nohost &) {} Nohost(Nohost &&) {} Nohost &operator=(const Nohost &) { return *this; }; Nohost &operator=(Nohost &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NumGangs { NumGangs(NumGangs &&) = default; NumGangs &operator=(NumGangs &&) = default; NumGangs(const NumGangs &) = delete; NumGangs &operator=(const NumGangs &) = delete; NumGangs() = delete; NumGangs(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct NumWorkers { NumWorkers(NumWorkers &&) = default; NumWorkers &operator=(NumWorkers &&) = default; NumWorkers(const NumWorkers &) = delete; NumWorkers &operator=(const NumWorkers &) = delete; NumWorkers() = delete; NumWorkers(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Present { Present(Present &&) = default; Present &operator=(Present &&) = default; Present(const Present &) = delete; Present &operator=(const Present &) = delete; Present() = delete; Present(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(AccObjectListWithReduction &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithReduction v; };
struct Self { Self(Self &&) = default; Self &operator=(Self &&) = default; Self(const Self &) = delete; Self &operator=(const Self &) = delete; Self() = delete; Self(std::optional<AccSelfClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccSelfClause> v; };
struct Seq { Seq() {} Seq(const Seq &) {} Seq(Seq &&) {} Seq &operator=(const Seq &) { return *this; }; Seq &operator=(Seq &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Shortloop { Shortloop() {} Shortloop(const Shortloop &) {} Shortloop(Shortloop &&) {} Shortloop &operator=(const Shortloop &) { return *this; }; Shortloop &operator=(Shortloop &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Tile { Tile(Tile &&) = default; Tile &operator=(Tile &&) = default; Tile(const Tile &) = delete; Tile &operator=(const Tile &) = delete; Tile() = delete; Tile(AccTileExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccTileExprList v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UseDevice { UseDevice(UseDevice &&) = default; UseDevice &operator=(UseDevice &&) = default; UseDevice(const UseDevice &) = delete; UseDevice &operator=(const UseDevice &) = delete; UseDevice() = delete; UseDevice(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Vector { Vector(Vector &&) = default; Vector &operator=(Vector &&) = default; Vector(const Vector &) = delete; Vector &operator=(const Vector &) = delete; Vector() = delete; Vector(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct VectorLength { VectorLength(VectorLength &&) = default; VectorLength &operator=(VectorLength &&) = default; VectorLength(const VectorLength &) = delete; VectorLength &operator=(const VectorLength &) = delete; VectorLength() = delete; VectorLength(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Wait { Wait(Wait &&) = default; Wait &operator=(Wait &&) = default; Wait(const Wait &) = delete; Wait &operator=(const Wait &) = delete; Wait() = delete; Wait(std::optional<AccWaitArgument> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccWaitArgument> v; };
struct Worker { Worker(Worker &&) = default; Worker &operator=(Worker &&) = default; Worker(const Worker &) = delete; Worker &operator=(const Worker &) = delete; Worker() = delete; Worker(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 5303 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 754 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
Async
, Attach
, Auto
, Bind
, Capture
, Collapse
, Copy
, Copyin
, Copyout
, Create
, Default
, DefaultAsync
, Delete
, Detach
, Device
, DeviceNum
, Deviceptr
, DeviceResident
, DeviceType
, Finalize
, Firstprivate
, Gang
, Host
, If
, IfPresent
, Independent
, Link
, NoCreate
, Nohost
, NumGangs
, NumWorkers
, Present
, Private
, Read
, Reduction
, Self
, Seq
, Shortloop
, Tile
, Unknown
, UseDevice
, Vector
, VectorLength
, Wait
, Worker
, Write
# 5309 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct AccClauseList {
  AccClauseList(AccClauseList &&) = default; AccClauseList &operator=(AccClauseList &&) = default; AccClauseList(const AccClauseList &) = delete; AccClauseList &operator=(const AccClauseList &) = delete; AccClauseList() = delete; AccClauseList(std::list<AccClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccClause> v;
  CharBlock source;
};

struct OpenACCRoutineConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCRoutineConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCRoutineConstruct(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct &operator=(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct &operator=(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, AccClauseList> t;
};

struct OpenACCCacheConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCacheConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCacheConstruct(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct &operator=(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct &operator=(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, AccObjectListWithModifier> t;
};

struct OpenACCWaitConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCWaitConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCWaitConstruct(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct &operator=(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct &operator=(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<AccWaitArgument>, AccClauseList> t;
};

struct AccBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginLoopDirective(AccBeginLoopDirective &&) = default; AccBeginLoopDirective &operator=(AccBeginLoopDirective &&) = default; AccBeginLoopDirective(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective &operator=(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective() = delete;
  std::tuple<AccLoopDirective, AccClauseList> t;
  CharBlock source;
};

struct AccBeginBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginBlockDirective(AccBeginBlockDirective &&) = default; AccBeginBlockDirective &operator=(AccBeginBlockDirective &&) = default; AccBeginBlockDirective(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective &operator=(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective() = delete;
  CharBlock source;
  std::tuple<AccBlockDirective, AccClauseList> t;
};

struct AccEndBlockDirective {
  CharBlock source;
  AccEndBlockDirective(AccEndBlockDirective &&) = default; AccEndBlockDirective &operator=(AccEndBlockDirective &&) = default; AccEndBlockDirective(const AccEndBlockDirective &) = delete; AccEndBlockDirective &operator=(const AccEndBlockDirective &) = delete; AccEndBlockDirective() = delete; AccEndBlockDirective(AccBlockDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBlockDirective v;
};


struct AccEndAtomic { AccEndAtomic() {} AccEndAtomic(const AccEndAtomic &) {} AccEndAtomic(AccEndAtomic &&) {} AccEndAtomic &operator=(const AccEndAtomic &) { return *this; }; AccEndAtomic &operator=(AccEndAtomic &&) { return *this; }; using EmptyTrait = std::true_type; };


struct AccAtomicRead {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicRead(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicRead(AccAtomicRead &&) = default; AccAtomicRead &operator=(AccAtomicRead &&) = default; AccAtomicRead(const AccAtomicRead &) = delete; AccAtomicRead &operator=(const AccAtomicRead &) = delete; AccAtomicRead() = delete;
  std::tuple<Verbatim, AccClauseList, Statement<AssignmentStmt>,
      std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicWrite {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicWrite(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicWrite(AccAtomicWrite &&) = default; AccAtomicWrite &operator=(AccAtomicWrite &&) = default; AccAtomicWrite(const AccAtomicWrite &) = delete; AccAtomicWrite &operator=(const AccAtomicWrite &) = delete; AccAtomicWrite() = delete;
  std::tuple<Verbatim, AccClauseList, Statement<AssignmentStmt>,
      std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicUpdate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicUpdate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicUpdate(AccAtomicUpdate &&) = default; AccAtomicUpdate &operator=(AccAtomicUpdate &&) = default; AccAtomicUpdate(const AccAtomicUpdate &) = delete; AccAtomicUpdate &operator=(const AccAtomicUpdate &) = delete; AccAtomicUpdate() = delete;
  std::tuple<std::optional<Verbatim>, AccClauseList, Statement<AssignmentStmt>,
      std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicCapture {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicCapture(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicCapture(AccAtomicCapture &&) = default; AccAtomicCapture &operator=(AccAtomicCapture &&) = default; AccAtomicCapture(const AccAtomicCapture &) = delete; AccAtomicCapture &operator=(const AccAtomicCapture &) = delete; AccAtomicCapture() = delete;
  struct Stmt1 { Stmt1(Stmt1 &&) = default; Stmt1 &operator=(Stmt1 &&) = default; Stmt1(const Stmt1 &) = delete; Stmt1 &operator=(const Stmt1 &) = delete; Stmt1() = delete; Stmt1(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  struct Stmt2 { Stmt2(Stmt2 &&) = default; Stmt2 &operator=(Stmt2 &&) = default; Stmt2(const Stmt2 &) = delete; Stmt2 &operator=(const Stmt2 &) = delete; Stmt2() = delete; Stmt2(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  std::tuple<Verbatim, AccClauseList, Stmt1, Stmt2, AccEndAtomic> t;
};

struct OpenACCAtomicConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCAtomicConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCAtomicConstruct(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct &operator=(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct &operator=(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct() = delete;
  std::variant<AccAtomicRead, AccAtomicWrite, AccAtomicCapture, AccAtomicUpdate>
      u;
  CharBlock source;
};

struct OpenACCBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCBlockConstruct(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct &operator=(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct &operator=(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct() = delete;
  std::tuple<AccBeginBlockDirective, Block, AccEndBlockDirective> t;
};

struct OpenACCStandaloneDeclarativeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneDeclarativeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneDeclarativeConstruct(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct &operator=(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct &operator=(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct() = delete;
  CharBlock source;
  std::tuple<AccDeclarativeDirective, AccClauseList> t;
};

struct AccBeginCombinedDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginCombinedDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginCombinedDirective(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective &operator=(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective &operator=(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective() = delete;
  CharBlock source;
  std::tuple<AccCombinedDirective, AccClauseList> t;
};

struct AccEndCombinedDirective {
  AccEndCombinedDirective(AccEndCombinedDirective &&) = default; AccEndCombinedDirective &operator=(AccEndCombinedDirective &&) = default; AccEndCombinedDirective(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective &operator=(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective() = delete; AccEndCombinedDirective(AccCombinedDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCombinedDirective v;
  CharBlock source;
};

struct OpenACCCombinedConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCombinedConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCombinedConstruct(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct &operator=(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct &operator=(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct() = delete;
  CharBlock source;
  OpenACCCombinedConstruct(AccBeginCombinedDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginCombinedDirective, std::optional<DoConstruct>,
      std::optional<AccEndCombinedDirective>>
      t;
};

struct OpenACCDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCDeclarativeConstruct(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct &operator=(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct &operator=(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenACCStandaloneDeclarativeConstruct, OpenACCRoutineConstruct>
      u;
};


struct AccEndLoop { AccEndLoop() {} AccEndLoop(const AccEndLoop &) {} AccEndLoop(AccEndLoop &&) {} AccEndLoop &operator=(const AccEndLoop &) { return *this; }; AccEndLoop &operator=(AccEndLoop &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OpenACCLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCLoopConstruct(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct &operator=(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct &operator=(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct() = delete;
  OpenACCLoopConstruct(AccBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginLoopDirective, std::optional<DoConstruct>,
      std::optional<AccEndLoop>>
      t;
};

struct OpenACCEndConstruct {
  OpenACCEndConstruct(OpenACCEndConstruct &&) = default; OpenACCEndConstruct &operator=(OpenACCEndConstruct &&) = default; OpenACCEndConstruct(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct &operator=(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct() = delete; OpenACCEndConstruct(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct OpenACCStandaloneConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneConstruct(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct &operator=(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct &operator=(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct() = delete;
  CharBlock source;
  std::tuple<AccStandaloneDirective, AccClauseList> t;
};

struct OpenACCConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCConstruct(OpenACCConstruct &&) = default; OpenACCConstruct &operator=(OpenACCConstruct &&) = default; OpenACCConstruct(const OpenACCConstruct &) = delete; OpenACCConstruct &operator=(const OpenACCConstruct &) = delete; OpenACCConstruct() = delete;
  std::variant<OpenACCBlockConstruct, OpenACCCombinedConstruct,
      OpenACCLoopConstruct, OpenACCStandaloneConstruct, OpenACCCacheConstruct,
      OpenACCWaitConstruct, OpenACCAtomicConstruct, OpenACCEndConstruct>
      u;
};
# 5476 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct CUFReduction {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUFReduction(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUFReduction(CUFReduction &&) = default; CUFReduction &operator=(CUFReduction &&) = default; CUFReduction(const CUFReduction &) = delete; CUFReduction &operator=(const CUFReduction &) = delete; CUFReduction() = delete;
  using Operator = ReductionOperator;
  std::tuple<Operator, std::list<Scalar<Variable>>> t;
};

struct CUFKernelDoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUFKernelDoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUFKernelDoConstruct(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct &operator=(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct &operator=(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct() = delete;
  struct StarOrExpr { StarOrExpr(StarOrExpr &&) = default; StarOrExpr &operator=(StarOrExpr &&) = default; StarOrExpr(const StarOrExpr &) = delete; StarOrExpr &operator=(const StarOrExpr &) = delete; StarOrExpr() = delete; StarOrExpr(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
  struct LaunchConfiguration {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> LaunchConfiguration(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LaunchConfiguration(LaunchConfiguration &&) = default; LaunchConfiguration &operator=(LaunchConfiguration &&) = default; LaunchConfiguration(const LaunchConfiguration &) = delete; LaunchConfiguration &operator=(const LaunchConfiguration &) = delete; LaunchConfiguration() = delete;
    std::tuple<std::list<StarOrExpr>, std::list<StarOrExpr>,
        std::optional<ScalarIntExpr>>
        t;
  };
  struct Directive {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Directive(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Directive(Directive &&) = default; Directive &operator=(Directive &&) = default; Directive(const Directive &) = delete; Directive &operator=(const Directive &) = delete; Directive() = delete;
    CharBlock source;
    std::tuple<std::optional<ScalarIntConstantExpr>,
        std::optional<LaunchConfiguration>, std::list<CUFReduction>>
        t;
  };
  std::tuple<Directive, std::optional<DoConstruct>> t;
};

}
