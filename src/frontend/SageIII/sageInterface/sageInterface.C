#include "rose.h"
#include "sage3.h"
#include "sageInterface.h"
// DQ (10/14/2006): Added supporting help functions
#include "rewrite.h"
// Liao 1/24/2008 : need access to scope stack sometimes
#include "sageBuilder.h"

#include <sstream>
#include <iostream>

typedef std::set<SgLabelStatement*> SgLabelStatementPtrSet;

// DQ (12/31/2005): This is OK if not declared in a header file
using namespace std;
using namespace SageBuilder;


 int SageInterface::gensym_counter=0;
 
// DQ: 09/23/03
// We require a global function for getting the string associated 
// with the definition of a variant (which is a global enum).
string getVariantName ( VariantT v )
   {
     ROSE_ASSERT( int(v) < int(V_SgNumVariants));

  // This code is far simpler (if the function is static)

  // DQ (4/8/2004): Modified code to use new global list of sage 
  // class names (simpler this way)
  // return string(SgTreeTraversal<int,int>::get_variantName(v));
     extern const char* roseGlobalVariantNameList[];
     return string(roseGlobalVariantNameList[v]);
   }


SgNamespaceDefinitionStatement*
SageInterface::enclosingNamespaceScope( SgDeclarationStatement* declaration )
   {
  // DQ (11/4/2007): This function is used in the markTemplateInstantiationsForOutput.C

  // This function returns the namespace associated with any declaration.
  // If the declaration is nested inside of other scopes this function 
  // iterates through these scopes to get the the first namespace.
  // This is important for details of template handling, namely making sure 
  // that the template specializations (generated by ROSE) are put into the
  // correct location (namespace) since stricted rules in gnu now enforce 
  // these details.  If the declaration is not in a namespace as computed 
  // in the chain of scopes then this function returns NULL.

     ROSE_ASSERT(declaration != NULL);
     SgScopeStatement* tempScope = declaration->get_scope();

  // Loop back to the first namespace or stop at global scope (stop on either a namespace or the global scope)
     while ( isSgNamespaceDefinitionStatement(tempScope) == NULL && isSgGlobal(tempScope) == NULL )
        {
          tempScope = tempScope->get_scope();
          ROSE_ASSERT(tempScope != NULL);
#if 0
          printf ("Iterating back through scopes: tempScope = %p = %s = %s \n",tempScope,tempScope->class_name().c_str(),SageInterface::get_name(tempScope).c_str());
#endif
        }

     SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(tempScope);
     return namespaceScope;
   }


SgDeclarationStatement* 
SageInterface::getNonInstantiatonDeclarationForClass ( SgTemplateInstantiationMemberFunctionDecl* memberFunctionInstantiation )
   {
  // DQ (11/4/2007): This function is used in the markTemplateInstantiationsForOutput.C
  // DQ (11/4/2007): Get the associated declaration that will be in the original source code, 
  // if it is part of a template instantiation then get the original template declaration.

     SgDeclarationStatement* parentDeclaration = NULL;

     SgClassDefinition* classDefinition = memberFunctionInstantiation->get_class_scope();
     ROSE_ASSERT(classDefinition != NULL);

     SgTemplateDeclaration* templateDeclaration = memberFunctionInstantiation->get_templateDeclaration();
     ROSE_ASSERT(templateDeclaration != NULL);

  // If it is a template instatiation, then we have to find the temple declaration (not the template instantiation declaration), else we want the class declaration.
     SgTemplateInstantiationDefn* templateInstatiationClassDefinition = isSgTemplateInstantiationDefn(classDefinition);
     if (templateInstatiationClassDefinition != NULL)
        {
       // This is the case of a template member function in a templated class (see test2005_172.C).
          SgTemplateInstantiationDefn* parentTemplateInstantiationDefinition = isSgTemplateInstantiationDefn(templateDeclaration->get_scope());
          ROSE_ASSERT(parentTemplateInstantiationDefinition != NULL);
          SgTemplateInstantiationDecl* parentTemplateInstantiationDeclaration = isSgTemplateInstantiationDecl(parentTemplateInstantiationDefinition->get_declaration());
          ROSE_ASSERT(parentTemplateInstantiationDeclaration != NULL);

          parentDeclaration = parentTemplateInstantiationDeclaration->get_templateDeclaration();
          ROSE_ASSERT(parentDeclaration != NULL);
        }
       else
        {
       // This is the case of a template member function in a class definition (see test2005_168.C).
          parentDeclaration = classDefinition->get_declaration();
          ROSE_ASSERT(parentDeclaration != NULL);
        }

      return parentDeclaration;
   }

// DQ (11/4/2007): This looks for a forward temple member function declaration of matching name exists in the specified scope.
bool
SageInterface::isPrototypeInScope ( SgScopeStatement* scope, SgFunctionDeclaration* functionDeclaration, SgDeclarationStatement* startingAtDeclaration )
   {
  // DQ (11/3/2007): Look for an existing previously inserted (or existing) template member function declaration and only add one if we can't find it.

     bool foundExistingPrototype = false;

     ROSE_ASSERT(scope != NULL);
     ROSE_ASSERT(functionDeclaration != NULL);
     ROSE_ASSERT(startingAtDeclaration != NULL);

  // These are the scopes for which get_declarationList() is properly defined.
     ROSE_ASSERT(scope->containsOnlyDeclarations() == true);

  // Note that this is only defined for certain scopes, but we only want it for THOSE scopes
     SgDeclarationStatementPtrList & declarationList = scope->getDeclarationList();

  // This is a simple way to restrict the evaluation (still linear, but jumps to initial position to start search).
     SgDeclarationStatementPtrList::iterator startingLocation = find(declarationList.begin(),declarationList.end(),startingAtDeclaration);

     if (startingLocation != declarationList.end())
        {
#if 0
          printf ("startingLocation = %p = %s = %s \n",*startingLocation,(*startingLocation)->class_name().c_str(),SageInterface::get_name(*startingLocation).c_str());
#endif
       // printf ("Found the startingLocation is the global scope, now check if we need to add a new declaration \n");
          SgDeclarationStatementPtrList::iterator i = startingLocation;
          SgScopeStatement* targetScope = functionDeclaration->get_scope();
          SgName targetName = functionDeclaration->get_name();

          while (i != declarationList.end())
             {
            // printf ("i = %p = %s = %s \n",*i,(*i)->class_name().c_str(),SageInterface::get_name(*i).c_str());

            // Look for a prototype like what we want to insert, if we find it then we don't need to add a second one!
               SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(*i);
               if (templateMemberFunction != NULL)
                  {
                 // Check the name and the scope
                 // if (memberFunctionInstantiation->get_scope() == templateMemberFunction->get_scope())
                    if (targetScope == templateMemberFunction->get_scope())
                       {
                      // printf ("Testing member function = %s against member function = %s \n",memberFunctionInstantiation->get_name().str(),templateMemberFunction->get_name().str());
                      // if (memberFunctionInstantiation->get_name() == templateMemberFunction->get_name())
                         if (targetName == templateMemberFunction->get_name())
                            {
                           // Don't count the defining declaration which may be at the end of the global scope.
                              if (templateMemberFunction->isForward() == true)
                                 {
                                   foundExistingPrototype = true;

                                // Exit the loop (optimization)
                                   break;
                                 }
                            }
                       }
                  }

               i++;
             }
        }

     return foundExistingPrototype;
   }

bool
SageInterface::isAncestor (SgNode* node1, SgNode* node2)   
{
  ROSE_ASSERT(node1&&node2);
  SgNode* curnode= node2;
  if (node1==node2)
    return false;
  do {
      curnode= curnode->get_parent();
  } while( (curnode!=NULL)&&(curnode!=node1));

  if (curnode==node1)
   return true;
  else 
    return false;
}

std::vector<SgNode*>
SageInterface::astIntersection ( SgNode* original, SgNode* copy, SgCopyHelp* help )
   {
     std::vector<SgNode*> intersectionSet;

  // Collect all the IR nodes for the original AST
     std::vector<SgNode*> AST_original = NodeQuery::querySubTree (original,V_SgNode);
     std::vector<SgNode*> AST_copy     = NodeQuery::querySubTree (copy,V_SgNode);

     int AST_original_size = AST_original.size();
     int AST_copy_size     = AST_copy.size();

     printf ("Original AST size         = %d \n",AST_original_size);
     printf ("Copy of original AST size = %d \n",AST_copy_size);

     int differenceInSizes = AST_original_size - AST_copy_size;
     if (differenceInSizes == 0)
        {
          printf ("Copied AST is the SAME size as the original (size = %d) \n",AST_original_size);
        }
       else
        {
          printf ("Copied AST and the original are DIFFERENT sizes (original size = %d copyied size = %d) \n",AST_original_size,AST_copy_size);
        }

  // Compute the intersection (reference in the copy that point to the origal AST).
  // std::set<SgNode*> AST_set_original = AST_original;
     std::set<SgNode*> AST_set_original;
     for (int i = 0; i < AST_original_size; i++)
        {
          AST_set_original.insert(AST_original[i]);
        }

     std::set<SgNode*> AST_set_copy;
     for (int i = 0; i < AST_copy_size; i++)
        {
          AST_set_copy.insert(AST_copy[i]);
        }

     int size = AST_original_size;
     std::vector<SgNode*> intersectionList(size);

  // Is there a better way to do this? Build scratch space and then use the different between begin() and end to build another vector.
     std::vector<SgNode*>::iterator end = set_intersection(AST_set_original.begin(),AST_set_original.end(),AST_set_copy.begin(),AST_set_copy.end(),intersectionList.begin());

  // Build a new vector from the relevant elements of the intersectionList scratch space.
     std::vector<SgNode*> meaningIntersectionList = std::vector<SgNode*>(intersectionList.begin(),end);
     std::vector<SgNode*> deleteList;
     for (int i = 0; i < (int)meaningIntersectionList.size(); i++)
        {
       // printf ("     (before removing types) meaningIntersectionList[%d] = %p = %s \n",i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]->class_name().c_str() : "NULL");
          if (meaningIntersectionList[i] != NULL && isSgType(meaningIntersectionList[i]) != NULL)
             {
               deleteList.push_back(meaningIntersectionList[i]);
             }
        }

  // Remove the types since they are allowed to be shared...
     printf ("Remove the types that are allowed to be shared: deleteList.size() = %ld \n",(long)deleteList.size());
     for (std::vector<SgNode*>::iterator i = deleteList.begin(); i != deleteList.end(); i++)
        {
          meaningIntersectionList.erase(find(meaningIntersectionList.begin(),meaningIntersectionList.end(),*i));
        }

     printf ("After removing the types there are meaningIntersectionList.size() = %ld \n",(long)meaningIntersectionList.size());
     for (int i = 0; i < (int)meaningIntersectionList.size(); i++)
        {
       // printf ("     meaningIntersectionList[%d] = %p = %s \n",i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]->class_name().c_str() : "NULL");
          printf ("     meaningIntersectionList[%d] = %p = %s = %s \n",i,meaningIntersectionList[i],meaningIntersectionList[i]->class_name().c_str(),get_name(meaningIntersectionList[i]).c_str());
        }

     int unmatchedIRnodes = 0;
     if (help != NULL)
        {
          std::vector<SgNode*> tmp_AST_original; // = AST_original;
          std::vector<SgNode*> tmp_AST_copy; //     = AST_copy;

          int AST_original_size = AST_original.size();
          for (int j = 0; j < AST_original_size; j++)
             {
               if (AST_original[j] != NULL && isSgType(AST_original[j]) == NULL)
                  {
                    tmp_AST_original.push_back(AST_original[j]);
                  }
             }

          int AST_copy_size = AST_copy.size();
          for (int j = 0; j < AST_copy_size; j++)
             {
               if (AST_copy[j] != NULL && isSgType(AST_copy[j]) == NULL)
                  {
                    tmp_AST_copy.push_back(AST_copy[j]);
                  }
             }

          std::vector<SgNode*> deleteList_original;
          std::vector<SgNode*> deleteList_copy;
          for (int j = 0; j < (int)tmp_AST_original.size(); j++)
             {
            // printf ("     (before removing types) meaningIntersectionList[%d] = %p = %s \n",i,meaningIntersectionList[i],(meaningIntersectionList[i] != NULL) ? meaningIntersectionList[i]->class_name().c_str() : "NULL");
               SgCopyHelp::copiedNodeMapTypeIterator i = help->get_copiedNodeMap().find(tmp_AST_original[j]);
            // printf ("SgCopyHelp::copiedNodeMapTypeIterator i != help->get_copiedNodeMap().end() = %s \n",i != help->get_copiedNodeMap().end() ? "true" : "false");
               if (i != help->get_copiedNodeMap().end())
                  {
                 // Matched up an original IR node with it's copy
                    SgNode* associated_node_copy = i->second;
                    ROSE_ASSERT(associated_node_copy != NULL);
                    deleteList_original.push_back(tmp_AST_original[j]);
                    deleteList_copy.push_back(associated_node_copy);
#if 0
                 // printf ("Original IR node = %p = %s copy = %p \n",tmp_AST_original[j],tmp_AST_original[j]->class_name().c_str(),associated_node_copy);
                    SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(tmp_AST_original[j]);
                    SgTemplateInstantiationMemberFunctionDecl* templateMemberFunction_copy = isSgTemplateInstantiationMemberFunctionDecl(associated_node_copy);
                    if (templateMemberFunction != NULL)
                       {
                         printf ("In SageInterface::astIntersection(): Found a SgTemplateInstantiationMemberFunctionDecl = %p copy = %p \n",templateMemberFunction,associated_node_copy);
                      // templateMemberFunction->get_startOfConstruct()->display("original: debug");
                      // templateMemberFunction_copy->get_startOfConstruct()->display("copy: debug");
                       }
#endif
                  }
             }

          int deleteList_original_size = deleteList_original.size();
          for (int j = 0; j < deleteList_original_size; j++)
             {
            // tmp_AST_original.erase(find(tmp_AST_original.begin(),tmp_AST_original.end(),deleteList_original[j]));
               std::vector<SgNode*>::iterator k = find(tmp_AST_original.begin(),tmp_AST_original.end(),deleteList_original[j]);
               if (k != tmp_AST_original.end())
                  {
                    tmp_AST_original.erase(k);
                  }
             }

          printf ("IR nodes different between the original AST and the copy of the AST = %zu \n",tmp_AST_original.size());
          for (int j = 0; j < (int)tmp_AST_original.size(); j++)
             {
               printf ("non matched IR node = %p = %s = %s \n",tmp_AST_original[j],tmp_AST_original[j]->class_name().c_str(),get_name(tmp_AST_original[j]).c_str());
            // tmp_AST_original[j]->get_startOfConstruct()->display("debug");
             }

          unmatchedIRnodes = (int)tmp_AST_original.size();
        }

  // DQ (11/2/2007): Make this an error now!
     if (differenceInSizes != 0)
        {
          SgProject* originalProject = isSgProject(original);
          if (originalProject != NULL)
             {
               printf ("In %s Copied AST and the original are DIFFERENT sizes (original size = %d copyied size = %d) IR nodes different = %d \n",
                    (*originalProject)[0]->get_sourceFileNameWithoutPath().c_str(),AST_original_size,AST_copy_size,unmatchedIRnodes);
             }

          if (unmatchedIRnodes > 0)
             {
               printf ("Make this an error under stricter testing \n");
               ROSE_ASSERT(false);
             }
        }

     return intersectionSet;
   }

// AJ (10/21/2004): Added support for changing the symbol name associated with an SgInitializedName
// by updating the symbol table
int
SageInterface::set_name ( SgInitializedName *initializedNameNode, SgName new_name )
   {
  // find the appropriate symbol table, delete the symbol 
  // with the old name and add a symbol with the new name.
     ROSE_ASSERT(initializedNameNode != NULL);

  // SgNode * node = this;

#if 0
  // DQ (12/9/2004): This should likely call the get_scope function (which is more robust than traversing 
  // parents, there is a reason why we are forced to include the scope explicitly on some IR nodes, 
  // see test2004_133.C for details).
     while((node!=NULL) && ( isSgScopeStatement(node)==NULL))
          node = node->get_parent();

     ROSE_ASSERT(node!=NULL);

     SgScopeStatement * scope_stmt = isSgScopeStatement(node);
#else
     SgScopeStatement *scope_stmt = initializedNameNode->get_scope();
#endif

     ROSE_ASSERT(scope_stmt != NULL);
     ROSE_ASSERT(scope_stmt->get_symbol_table() != NULL);
     ROSE_ASSERT(scope_stmt->get_symbol_table()->get_table() != NULL);

     SgDeclarationStatement * parent_declaration = initializedNameNode->get_declaration();

     ROSE_ASSERT(parent_declaration != NULL);

  // Find the symbols associated with p_name 
     std::pair<SgSymbolTable::hash_iterator,SgSymbolTable::hash_iterator> pair_it = 
          scope_stmt->get_symbol_table()->get_table()->equal_range(initializedNameNode->get_name());

     SgSymbolTable::hash_iterator found_it=scope_stmt->get_symbol_table()->get_table()->end();

     for(SgSymbolTable::hash_iterator it = pair_it.first; it != pair_it.second; ++it)
        {
          switch(parent_declaration->variantT())
             {
               case V_SgVariableDeclaration:
                  {
                    if (isSgVariableSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgClassDeclaration:
                  {
                    if (isSgClassSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgFunctionDeclaration:
                  {
                    if (isSgFunctionSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               default:
                  {
                  }
             };
        }

  // there is no Variable,Class or Function symbol associated with p_name 
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: There is no Variable,Class or Function symbol associated with p_name \n");
          return 0;
        }

     SgSymbol * associated_symbol = (*found_it).second;

  // erase the name from there
     scope_stmt->get_symbol_table()->get_table()->erase(found_it);

  // insert the new_name in the symbol table
     found_it = scope_stmt->get_symbol_table()->get_table()->insert(pair<SgName,SgSymbol*> ( new_name,associated_symbol));

  // if insertion failed
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: insertion of new symbol failed \n");
          return 0;
        }

  // Set the p_name to the new_name
     printf ("Reset initializedNameNode->get_name() = %s to new_name = %s \n",initializedNameNode->get_name().str(),new_name.str());
  // p_name = new_name;
     initializedNameNode->set_name(new_name);

  // Invalidate the p_iterator, p_no_name and p_name data members in the Symbol table

     return 1;
   }

string
SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive )
   {
     string name = "undefined_name";

     ROSE_ASSERT(directive != NULL);

     name = directive->class_name();

#if 0
  // I don't think we need this code now!
     switch (directive->variantT())
        {
       // Separate out these cases...
          case V_SgIncludeDirectiveStatement:
          case V_SgDefineDirectiveStatement:
          case V_SgUndefDirectiveStatement:
          case V_SgIfdefDirectiveStatement:
          case V_SgIfndefDirectiveStatement:
          case V_SgDeadIfDirectiveStatement:
          case V_SgIfDirectiveStatement:
          case V_SgElseDirectiveStatement:
          case V_SgElseifDirectiveStatement:
          case V_SgLineDirectiveStatement:
          case V_SgWarningDirectiveStatement:
          case V_SgErrorDirectiveStatement:
          case V_SgEmptyDirectiveStatement:
             {
               name = directive->class_name();
               break;
             }

       // case ClinkageDeclarationStatement:
          case V_SgClinkageStartStatement:
          case V_SgClinkageEndStatement:
             {
               name = directive->class_name();
               break;
             }

          case V_SgFortranIncludeLine:
             {
               name = directive->class_name();
               break;
             }

          default:
            // name = "default name (default case reached: not handled)";
               printf ("Warning: default case reached in SageInterface::get_name ( const SgC_PreprocessorDirectiveStatement* directive ), directive = %p = %s \n",
                    directive,directive->class_name().c_str());
               ROSE_ASSERT(false);

               name = "directive_default_name_case_reached_not_handled";
               break;
        }
#endif

     return name;
   }

string
SageInterface::get_name ( const SgDeclarationStatement* declaration )
   {
     string name = "undefined_name";

     ROSE_ASSERT(declaration != NULL);

  // DQ (11/23/2008): Handle the case of a Cpp directive...
     const SgC_PreprocessorDirectiveStatement* directive = isSgC_PreprocessorDirectiveStatement(declaration);
     if (directive != NULL)
        {
          return SageInterface::get_name (directive);
        }

     switch (declaration->variantT())
        {
          case V_SgTemplateDeclaration:
               name = isSgTemplateDeclaration(declaration)->get_name().str();
               break;

       // DQ (2/10/2007): Use the get_templateName() instead of combining this with the case V_SgClassDeclaration
          case V_SgTemplateInstantiationDecl:
               name = isSgTemplateInstantiationDecl(declaration)->get_templateName().str();
               break;

          case V_SgClassDeclaration:
          case V_SgDerivedTypeStatement:
               name = isSgClassDeclaration(declaration)->get_name().str();
               break;

          case V_SgEnumDeclaration:
               name = isSgEnumDeclaration(declaration)->get_name().str();
               break;

          case V_SgTypedefDeclaration:
               name = isSgTypedefDeclaration(declaration)->get_name().str();
               break;

          case V_SgFunctionDeclaration:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgMemberFunctionDeclaration:
          case V_SgTemplateInstantiationFunctionDecl:
          case V_SgTemplateInstantiationMemberFunctionDecl:
               name = isSgFunctionDeclaration(declaration)->get_name().str();
               break;

          case V_SgNamespaceDeclarationStatement:
               name = isSgNamespaceDeclarationStatement(declaration)->get_name().str();
               break;

       // DQ (2/12/2006): Added support to get name of SgFunctionParameterList
          case V_SgFunctionParameterList:
             {
            // Parents should be set prior to calling these functions (if not we might have to implement that case)
               ROSE_ASSERT(declaration->get_parent() != NULL);
               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declaration->get_parent());
               ROSE_ASSERT(functionDeclaration != NULL);
               name = get_name(functionDeclaration);
               name += "_parameter_list_";
               break;
             }

       // DQ (3/8/2006): Implemented case for variable declaration (forgot this case)
          case V_SgVariableDeclaration:
             {
            // DQ (2/11/2007): Modified to return names that can be used as variables (required
            // because we use this mechanism to generate names for unnamed structs and enums).
               name = "_variable_declaration_";
               const SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(declaration);
               ROSE_ASSERT(variableDeclaration != NULL);
               SgInitializedNamePtrList::const_iterator i = variableDeclaration->get_variables().begin();

            // Make sure that we have at least one variable in the list
               ROSE_ASSERT(i != variableDeclaration->get_variables().end());
               do {
                 // name += string(" ") + string((*i)->get_name().str());
                    name += string((*i)->get_name().str());
                    i++;
                  }
               while (i != variableDeclaration->get_variables().end());
               break;
             }


       // DQ (3/8/2006): Implemented case for variable declaration (forgot this case)
          case V_SgVariableDefinition:
             {
            // DQ (2/11/2007): Modified to return names that can be used as variables (required
            // because we use this mechanism to generate names for unnamed structs and enums).
               name = "_variable_definition_";
               const SgVariableDefinition* variableDefinition = isSgVariableDefinition(declaration);
               ROSE_ASSERT(variableDefinition != NULL);

            // define this in terms of the associated SgInitializedName
               ROSE_ASSERT(variableDefinition->get_vardefn() != NULL);
               name += get_name(variableDefinition->get_vardefn());
               break;
             }

       // DQ (3/17/2006): Implemented case for pragma declaration (forgot this case)
          case V_SgPragmaDeclaration:
             {
               name = "_pragma_declaration_";
               const SgPragmaDeclaration* pragmaDeclaration = isSgPragmaDeclaration(declaration);
               ROSE_ASSERT(pragmaDeclaration != NULL);
               ROSE_ASSERT(pragmaDeclaration->get_pragma() != NULL);
               name += get_name(pragmaDeclaration->get_pragma());
               break;
             }

       // DQ (4/15/2007): Implemented case for using directive statement (forgot this case)
          case V_SgUsingDirectiveStatement:
             {
               name = "_using_directive_statement_";
               const SgUsingDirectiveStatement* usingDeclaration = isSgUsingDirectiveStatement(declaration);
               ROSE_ASSERT(usingDeclaration != NULL);
               ROSE_ASSERT(usingDeclaration->get_namespaceDeclaration() != NULL);
               name += get_name(usingDeclaration->get_namespaceDeclaration());
               break;
             }

       // DQ (6/20/2007): Added new case!
          case V_SgNamespaceAliasDeclarationStatement:
             {
               name = "_namespace_alias_directive_statement_";
               const SgNamespaceAliasDeclarationStatement* namespaceAliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);
               ROSE_ASSERT(namespaceAliasDeclaration != NULL);
               ROSE_ASSERT(namespaceAliasDeclaration->get_name().is_null() == false);
               name += namespaceAliasDeclaration->get_name();
               break;
             }

       // DQ (6/20/2007): Added new case!
          case V_SgUsingDeclarationStatement:
             {
               name = "_using_declaration_statement_";
               const SgUsingDeclarationStatement* usingDeclaration = isSgUsingDeclarationStatement(declaration);
               ROSE_ASSERT(usingDeclaration != NULL);
               if (usingDeclaration->get_declaration() != NULL)
                  {
                    name += get_name(usingDeclaration->get_declaration());
                  }
                 else
                  {
                    ROSE_ASSERT(usingDeclaration->get_initializedName() != NULL);
                    name += get_name(usingDeclaration->get_initializedName());
                  }
               break;
             }

       // DQ (6/20/2007): Added new case!
          case V_SgTemplateInstantiationDirectiveStatement:
             {
               name = "_template_instantiation_directive_statement_";
               ROSE_ASSERT(declaration != NULL);
               const SgTemplateInstantiationDirectiveStatement* templateInstantiationDirective = isSgTemplateInstantiationDirectiveStatement(declaration);
               ROSE_ASSERT(templateInstantiationDirective != NULL);
               ROSE_ASSERT(templateInstantiationDirective->get_declaration() != NULL);
               printf ("declaration->get_declaration() = %p = %s \n",templateInstantiationDirective->get_declaration(),templateInstantiationDirective->get_declaration()->class_name().c_str());
               name += get_name(templateInstantiationDirective->get_declaration());
               break;
             }

          case V_SgCtorInitializerList:
             {
               name = "_ctor_list_";
               const SgCtorInitializerList* ctorDeclaration = isSgCtorInitializerList(declaration);
               ROSE_ASSERT(ctorDeclaration != NULL);
               ROSE_ASSERT(ctorDeclaration->get_parent() != NULL);
               name += get_name(ctorDeclaration->get_parent());
               break;
             }

       // DQ (8/9/2007): Added case for SgAsmStmt
          case V_SgAsmStmt:
             {
               name = "_asm_stmt_";
               const SgAsmStmt* asmStatement = isSgAsmStmt(declaration);
               ROSE_ASSERT(asmStatement != NULL);
               ROSE_ASSERT(asmStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgAsmStmt*>(asmStatement));
               break;
             }

       // DQ (8/22/2007): Added case for SgImplicitStatement
          case V_SgImplicitStatement:
             {
               name = "_fortran_implicit_";
               const SgImplicitStatement* implicitStatement = isSgImplicitStatement(declaration);
               ROSE_ASSERT(implicitStatement != NULL);
               ROSE_ASSERT(implicitStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgImplicitStatement*>(implicitStatement));
               break;
             }

       // DQ (8/22/2007): Added case for SgNamelistStatement
          case V_SgNamelistStatement:
             {
               name = "_fortran_namelist_";
               const SgNamelistStatement* namelistStatement = isSgNamelistStatement(declaration);
               ROSE_ASSERT(namelistStatement != NULL);
               ROSE_ASSERT(namelistStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgNamelistStatement*>(namelistStatement));
               break;
             }

       // DQ (11/21/2007): Added case for SgEquivalenceStatement
          case V_SgEquivalenceStatement:
             {
               name = "_fortran_equivalence_";
               const SgEquivalenceStatement* equivalenceStatement = isSgEquivalenceStatement(declaration);
               ROSE_ASSERT(equivalenceStatement != NULL);
               ROSE_ASSERT(equivalenceStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgEquivalenceStatement*>(equivalenceStatement));
               break;
             }


       // DQ (11/21/2007): Added case for SgCommonBlock
          case V_SgCommonBlock:
             {
               name = "_fortran_common_block_";
               const SgCommonBlock* commonBlockStatement = isSgCommonBlock(declaration);
               ROSE_ASSERT(commonBlockStatement != NULL);
               ROSE_ASSERT(commonBlockStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgCommonBlock*>(commonBlockStatement));
               break;
             }

       // DQ (11/21/2007): Added case for SgImportStatement
          case V_SgImportStatement:
             {
               name = "_fortran_import_stmt_";
               const SgImportStatement* importStatement = isSgImportStatement(declaration);
               ROSE_ASSERT(importStatement != NULL);
               ROSE_ASSERT(importStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgImportStatement*>(importStatement));
               break;
             }

       // DQ (11/21/2007): Added case for SgFormatStatement
          case V_SgFormatStatement:
             {
               name = "_fortran_format_stmt_";
               const SgFormatStatement* formatStatement = isSgFormatStatement(declaration);
               ROSE_ASSERT(formatStatement != NULL);
               ROSE_ASSERT(formatStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgFormatStatement*>(formatStatement));
               break;
             }

       // DQ (12/27/2007): Added case for SgModuleStatement
          case V_SgModuleStatement:
             {
               name = "_fortran_module_stmt_";
               const SgModuleStatement* moduleStatement = isSgModuleStatement(declaration);
               ROSE_ASSERT(moduleStatement != NULL);
               ROSE_ASSERT(moduleStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgModuleStatement*>(moduleStatement));
               break;
             }

       // DQ (12/27/2007): Added case for SgUseStatement
          case V_SgUseStatement:
             {
               name = "_fortran_use_stmt_";
               const SgUseStatement* useStatement = isSgUseStatement(declaration);
               ROSE_ASSERT(useStatement != NULL);
               ROSE_ASSERT(useStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgUseStatement*>(useStatement));
               break;
             }

       // DQ (12/28/2007): Added case for SgContainsStatement
          case V_SgContainsStatement:
             {
               name = "_fortran_contains_stmt_";
               const SgContainsStatement* containsStatement = isSgContainsStatement(declaration);
               ROSE_ASSERT(containsStatement != NULL);
               ROSE_ASSERT(containsStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgContainsStatement*>(containsStatement));
               break;
             }

       // DQ (1/20/2008): Added case for SgEntryStatement
          case V_SgEntryStatement:
             {
               name = "_fortran_entry_stmt_";
               const SgEntryStatement* entryStatement = isSgEntryStatement(declaration);
               ROSE_ASSERT(entryStatement != NULL);
               ROSE_ASSERT(entryStatement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgEntryStatement*>(entryStatement));
               break;
             }

       // DQ (1/23/2008): Added case for SgAttributeSpecificationStatement
          case V_SgAttributeSpecificationStatement:
             {
               name = "_fortran_attribute_specification_stmt_";
               const SgAttributeSpecificationStatement* statement = isSgAttributeSpecificationStatement(declaration);
               ROSE_ASSERT(statement != NULL);
               ROSE_ASSERT(statement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgAttributeSpecificationStatement*>(statement));
               break;
             }

           case V_SgInterfaceStatement:
             {
               name = "_fortran_interface_stmt_";
               const SgInterfaceStatement* statement = isSgInterfaceStatement(declaration);
               ROSE_ASSERT(statement != NULL);
               ROSE_ASSERT(statement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgInterfaceStatement*>(statement));
               break;
             }

           case V_SgFortranIncludeLine:
             {
               name = "_fortran_include_line_stmt_";
               const SgFortranIncludeLine* statement = isSgFortranIncludeLine(declaration);
               ROSE_ASSERT(statement != NULL);
               ROSE_ASSERT(statement->get_parent() != NULL);
               name += StringUtility::numberToString(const_cast<SgFortranIncludeLine*>(statement));
               break;
             }

       // Note that the case for SgVariableDeclaration is not implemented
          default:
            // name = "default name (default case reached: not handled)";
               printf ("Warning: default case reached in SageInterface::get_name ( const SgDeclarationStatement* declaration ), declaration = %p = %s \n",
                    declaration,declaration->class_name().c_str());
               ROSE_ASSERT(false);

               name = "default_name_case_reached_not_handled";
               break;
        }

     return name;
   }

string
SageInterface::get_name ( const SgScopeStatement* scope )
   {
     string name = "undefined_name";

     ROSE_ASSERT(scope != NULL);

     switch (scope->variantT())
        {
          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
               name = get_name(isSgClassDefinition(scope)->get_declaration());
               break;

          case V_SgFunctionDefinition:
               name = get_name(isSgFunctionDefinition(scope)->get_declaration());
               break;

          case V_SgNamespaceDefinitionStatement:
               name = get_name(isSgNamespaceDefinitionStatement(scope)->get_namespaceDeclaration());
               break;

       // DQ (11/30/2007): Added more fortran suport.
          case V_SgAssociateStatement:

          case V_SgBasicBlock:
          case V_SgCatchOptionStmt:
          case V_SgDoWhileStmt:
          case V_SgForStatement:
          case V_SgGlobal:
          case V_SgIfStmt:
          case V_SgSwitchStatement:
          case V_SgWhileStmt:
          case V_SgFortranDo:
          case V_SgForAllStatement:
               name = StringUtility::numberToString(const_cast<SgScopeStatement*>(scope));
               break;

          default: 
               printf ("Error: undefined scope in SageInterface::get_name(): node = %s \n",scope->class_name().c_str());
               ROSE_ASSERT(false);
               break;
        }

     return name;
   }

string
SageInterface::get_name ( const SgStatement* stmt )
   {
     string name = "undefined_name";

     ROSE_ASSERT(stmt != NULL);

     const SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
     if (declaration != NULL)
        {
          name = get_name(declaration);
        }
       else
        {
          const SgScopeStatement* scope = isSgScopeStatement(stmt);
          if (scope != NULL)
             {
               name = get_name(scope);
             }
            else
             {
#if 0
            // DQ (9/5/2005): I think this is good enough for the more general case
               name = stmt->class_name();
#else
            // DQ (10/25/2007): This is better since it names the SgLabelStatement case
               switch (stmt->variantT())
                  {
#if 0
                    case V_SgBreakStmt:
                    case V_SgCaseOptionStmt:
                    case V_SgCatchStatementSeq:
                    case V_SgClinkageStartStatement:
                    case V_SgContinueStmt:
                    case V_SgDefaultOptionStmt:
                    case V_SgExprStmt:
                    case V_SgForInitStmt:
                    case V_SgFunctionTypeTable:
                    case V_SgGotoStatement:
                    case V_SgReturnStmt:
                    case V_SgSpawnStmt:
                    case V_SgTryStmt:
                         name = stmt->class_name();
                         break;
#endif
                    case V_SgLabelStatement:
                       {
                         const SgLabelStatement* labelStatement = isSgLabelStatement(stmt);
                         name = labelStatement->get_label().str();
                         break;
                       }

                    default:
                       {
                      // printf ("Default reached in switch \n");
                      // name = "default name";
                         name = stmt->class_name();
                         break;
                       }
                  }
#endif
             }
        }

     return name;
   }

string
SageInterface::get_name ( const SgSupport* node )
   {
  // This function is useful for debugging
  // This is the most general case of a function to return a name for an IR node.
     ROSE_ASSERT(node != NULL);

     string name = "undefined_name";

     ROSE_ASSERT(node != NULL);

     switch (node->variantT())
        {
          case V_SgInitializedName:
             {
               const SgInitializedName* initializedName = isSgInitializedName(node);
               if (initializedName != NULL)
                  {
                    name = initializedName->get_name().str();
                  }
               break;
             }
#if 1
       // DQ (3/17/2006): Implemented case for pragma declaration (forgot this case)
          case V_SgPragma:
             {
               name = "_pragma_string_";
               const SgPragma* pragma = isSgPragma(node);
               ROSE_ASSERT(pragma != NULL);
               name += pragma->get_pragma();
               break;
             }
#endif

       // DQ (5/31/2007): Implemented case for SgProject
          case V_SgProject:
             {
               name = "_project_";
               break;
             }

       // DQ (5/31/2007): Implemented case for SgFile
       // case V_SgFile:
          case V_SgSourceFile:
          case V_SgBinaryFile:
             {
               name = "_file_";
               break;
             }

       // DQ (5/31/2007): Implemented case for SgSymbolTable
          case V_SgSymbolTable:
             {
               name = "_symbol_table_";
               break;
             }

       // DQ (5/31/2007): Implemented case for SgStorageModifier
          case V_SgStorageModifier:
             {
               name = "_storage_modifier_";
               break;
             }


       // DQ (5/31/2007): Implemented case for Sg_File_Info
          case V_Sg_File_Info:
             {
               name = "_file_info_";
               break;
             }

       // DQ (8/7/2007): Implemented case for SgTemplateArgument
          case V_SgTemplateArgument:
             {
               name = "_template_argument_";
               const SgTemplateArgument* templateArgument = isSgTemplateArgument(node);
               ROSE_ASSERT(templateArgument != NULL);
               switch(templateArgument->get_argumentType())
                  {
                    case SgTemplateArgument::type_argument:
                       {
                         SgType* t = templateArgument->get_type();
                         ROSE_ASSERT(t != NULL);
                         name += get_name(t);
                         break;
                       }

                    case SgTemplateArgument::nontype_argument:
                       {
                         SgExpression* t = templateArgument->get_expression();
                         ROSE_ASSERT(t != NULL);
                         name += get_name(t);
                         break;
                       }

                    case SgTemplateArgument::template_template_argument:
                       {
                         SgTemplateDeclaration* t = templateArgument->get_templateDeclaration();
                         ROSE_ASSERT(t != NULL);
                         name += get_name(t);
                         break;
                       }

                    default:
                       {
                         printf ("Error: default case reached in switch on templateArgument->get_argumentType() \n");
                         ROSE_ASSERT(false);
                       }
                  }
               break;
             }


       // DQ (8/7/2007): Implemented case for SgTemplateArgument
          case V_SgTypeModifier:
             {
               const SgTypeModifier* typeModifier = isSgTypeModifier(node);
               ROSE_ASSERT(typeModifier != NULL);
               name = "_type_modifier_" + typeModifier->displayString();
               break;
             }

       // DQ (11/19/2007): Implemented case for SgNameGroup
          case V_SgNameGroup:
             {
               const SgNameGroup* nameGroup = isSgNameGroup(node);
               ROSE_ASSERT(nameGroup != NULL);
               name = "_name_group_" + nameGroup->get_group_name();
               break;
             }

       // DQ (11/20/2007): Implemented case for Fortran data statement support
          case V_SgDataStatementGroup:
             {
               const SgDataStatementGroup* dataGroup = isSgDataStatementGroup(node);
               ROSE_ASSERT(dataGroup != NULL);
               name = "_data_statement_group_";
               break;
             }

       // DQ (11/20/2007): Implemented case for Fortran data statement support
          case V_SgDataStatementObject:
             {
               const SgDataStatementObject* dataObject = isSgDataStatementObject(node);
               ROSE_ASSERT(dataObject != NULL);
               name = "_data_statement_object_";
               break;
             }

       // DQ (11/20/2007): Implemented case for Fortran data statement support
          case V_SgDataStatementValue:
             {
               const SgDataStatementValue* dataValue = isSgDataStatementValue(node);
               ROSE_ASSERT(dataValue != NULL);
               name = "_data_statement_value_";
               break;
             }

       // DQ (11/19/2007): Implemented case for SgCommonBlock
          case V_SgCommonBlockObject:
             {
               const SgCommonBlockObject* commonBlockObject = isSgCommonBlockObject(node);
               ROSE_ASSERT(commonBlockObject != NULL);
               name = "_common_block_object_" + commonBlockObject->get_block_name();
               break;
             }

       // DQ (12/23/2007): Added support for repeat_specification
          case V_SgFormatItem:
             {
               const SgFormatItem* formatItem = isSgFormatItem(node);
               ROSE_ASSERT(formatItem != NULL);
               name = "_format_item_";
               break;
             }

       // DQ (12/23/2007): Added support for repeat_specification
          case V_SgFormatItemList:
             {
               const SgFormatItemList* formatItemList = isSgFormatItemList(node);
               ROSE_ASSERT(formatItemList != NULL);
               name = "_format_item_list_";
               break;
             }

       // DQ (12/23/2007): Added support for repeat_specification
          case V_SgRenamePair:
             {
               const SgRenamePair* renamePair = isSgRenamePair(node);
               ROSE_ASSERT(renamePair != NULL);
               name = renamePair->get_local_name() + "__" + renamePair->get_use_name() + "_rename_pair_";
               break;
             }

          default:
             {
               printf ("Default reached in switch for SgSupport IR node = %s \n",node->class_name().c_str());
               name = "default name";
            // ROSE_ASSERT(false);
               break;
             }
        }

     return name;
   }


string
SageInterface::get_name ( const SgSymbol* symbol )
   {
  // This function is useful for debugging
  // This is the most general case of a function to return a name for an IR node.
     ROSE_ASSERT(symbol != NULL);

     string aliasSymbolPrefix = "";
     if (isSgAliasSymbol(symbol) != NULL)
        {
          aliasSymbolPrefix = "_ALIAS";
        }

  // This is a call to the "get_name()" virtual function
     return symbol->get_name() + aliasSymbolPrefix + "_symbol_";
   }

string
SageInterface::get_name ( const SgType* type )
   {
  // This function is useful for debugging
  // This is the most general case of a function to return a name for an IR node.
     ROSE_ASSERT(type != NULL);

     string returnName;

     const SgNamedType* namedType = isSgNamedType(type);
     if (namedType != NULL)
        {
          returnName = "named_type_";
          returnName = namedType->get_name().getString();
        }
       else
        {
          switch(type->variantT())
             {
               case V_SgPointerType:
                  {
                    const SgPointerType* pointerType = isSgPointerType(type);
                    returnName = "pointer_to_";
                    returnName += get_name(pointerType->get_base_type());
                    break;
                  }

               case V_SgReferenceType:
                  {
                    const SgReferenceType* referenceType = isSgReferenceType(type);
                    returnName = "reference_to_";
                    returnName += get_name(referenceType->get_base_type());
                    break;
                  }

               case V_SgArrayType:
                  {
                    const SgArrayType* arrayType = isSgArrayType(type);
                    returnName = "array_of_";
                    returnName += get_name(arrayType->get_base_type());
                    break;
                  }

               case V_SgModifierType:
                  {
                    const SgModifierType* modifierType = isSgModifierType(type);
                    returnName = get_name(&(modifierType->get_typeModifier()));
                    returnName += get_name(modifierType->get_base_type());
                    break;
                  }

               default:
                  {
                    returnName = type->class_name();
                  }
             }
        }

     return returnName;
   }

string
SageInterface::get_name ( const SgExpression* expr )
   {
     string name = "undefined_name";

  // ROSE_ASSERT(expr != NULL);
     switch(expr->variantT())
        {
          case V_SgVarRefExp:
             {
               const SgVarRefExp* varRef = isSgVarRefExp(expr);
               name = "var_ref_of_";
               name += varRef->get_symbol()->get_name();
               break;
             }

          case V_SgPntrArrRefExp:
             {
               const SgPntrArrRefExp* arrayRef = isSgPntrArrRefExp(expr);
               name = "array_ref_of_";
               name += get_name(arrayRef->get_lhs_operand());
               name += "_at_";
               name += get_name(arrayRef->get_rhs_operand());
               break;
             }

          case V_SgFunctionCallExp:
             {
               const SgFunctionCallExp* functionCall = isSgFunctionCallExp(expr);
               name = "function_call_";
               name += get_name(functionCall->get_function());
               break;
             }

          case V_SgFunctionRefExp:
             {
               const SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(expr);
               name = "function_ref_";
               name += functionRefExp->get_symbol()->get_name();
               break;
             }

          case V_SgIntVal:
             {
               const SgIntVal* valueExp = isSgIntVal(expr);
               name = "integer_value_exp_";
               name += StringUtility::numberToString(valueExp->get_value());
               break;
             }

          case V_SgStringVal:
             {
               const SgStringVal* valueExp = isSgStringVal(expr);
               name = "string_value_exp_";
               name += valueExp->get_value();
               break;
             }

          case V_SgSubscriptExpression:
             {
               const SgSubscriptExpression* subscriptExpression = isSgSubscriptExpression(expr);
               name = "subscript_exp_";
            // name += StringUtility::numberToString(subscriptExpression->get_lowerBound());
               name += get_name(subscriptExpression->get_lowerBound());
               name += "_";
            // name += StringUtility::numberToString(subscriptExpression->get_upperBound());
               name += get_name(subscriptExpression->get_upperBound());
               name += "_";
            // name += StringUtility::numberToString(subscriptExpression->get_stride());
               name += get_name(subscriptExpression->get_stride());
               break;
             }

          case V_SgNullExpression:
             {
               name = "null_expression";
               break;
             }

          default:
             {
            // Nothing to do for other IR nodes
             }
        }

     return name;
   }

string
SageInterface::get_name ( const SgLocatedNodeSupport* node )
   {
  // This function is useful for debugging
  // This is the most general case of a function to return a name for an IR node.
     ROSE_ASSERT(node != NULL);

     string returnName;

     switch(node->variantT())
        {
          case V_SgRenamePair:
             {
               const SgRenamePair* n = isSgRenamePair(node);
               returnName = "rename_pair_";
               returnName += n->get_local_name().str();
               returnName += "_from_";
               returnName += n->get_use_name().str();
               break;
             }
#if 0
          case V_SgInterfaceBody:
             {
               const SgInterfaceBody* n = isSgInterfaceBody(node);
               returnName = "interface_body";
               break;
             }
#endif
          default:
             {
               returnName = node->class_name();
             }
        }

     return returnName;
   }

string
SageInterface::get_name ( const SgNode* node )
   {
  // This function is useful fro debugging
  // This is the most general case of a function to return a name for an IR node.
  // Later this function will handle expressions, etc.

     string name = "undefined_name";

     ROSE_ASSERT(node != NULL);

     const SgLocatedNode* locatedNode = isSgLocatedNode(node);
     if (locatedNode != NULL)
        {
          const SgStatement* statement = isSgStatement(node);
          if (statement != NULL)
             {
               name = get_name(statement);
             }
            else
             {
               const SgExpression* expression = isSgExpression(node);
               if (expression != NULL)
                  {
                    name = get_name(expression);
                  }
                 else
                  {
                    const SgLocatedNodeSupport* locatedNodeSupport = isSgLocatedNodeSupport(node);
                    if (locatedNodeSupport != NULL)
                       {
                         name = get_name(locatedNodeSupport);
                       }
                      else
                       {
                         const SgToken* token = isSgToken(node);
                         if (token != NULL)
                            {
                              name = get_name(token);
                            }
                           else
                            {
                              printf ("Unknown SgLocatedNode = %p = %s \n",node,node->class_name().c_str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
             }
        }
       else
        {
          const SgSupport* supportNode = isSgSupport(node);
          if (supportNode != NULL)
             {
               name = get_name(supportNode);
             }
            else
             {
            // DQ (9/21/2005): I think this is good enough for the more general case (for now)
               const SgSymbol* symbol = isSgSymbol(node);
               if (symbol != NULL)
                  {
                    name = get_name(symbol);
                  }
                 else
                  {
                 // DQ (8/7/2007): Added support to get names of types (usefult for SgNamedType objects).
                    const SgType* type = isSgType(node);
                    if (type != NULL)
                       {
                         name = get_name(type);
                       }
                      else
                       {
                         name = node->class_name();
                       }
                  }
             }
        }

     return name;
   }

SgMemberFunctionDeclaration*
SageInterface::getDefaultConstructor( SgClassDeclaration* classDeclaration )
   {
     SgMemberFunctionDeclaration* defaultConstructor = NULL;

     ROSE_ASSERT(classDeclaration != NULL);
     SgDeclarationStatement* definingDeclaration = classDeclaration->get_definingDeclaration();
     ROSE_ASSERT(definingDeclaration != NULL);
     SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclaration);

  // Note that not all class declarations have to have a defining declaration (e.g. "~int()" 
  // would be associated with a class declaration but no definition would exist).
     if (definingClassDeclaration != NULL)
        {
          SgClassDefinition* classDefinition = definingClassDeclaration->get_definition();
          ROSE_ASSERT(classDefinition != NULL);

          SgDeclarationStatementPtrList::iterator i = classDefinition->get_members().begin();
          while ( i != classDefinition->get_members().end() )
             {
            // Check the parent pointer to make sure it is properly set
               ROSE_ASSERT( (*i)->get_parent() != NULL);
               ROSE_ASSERT( (*i)->get_parent() == classDefinition);

               SgMemberFunctionDeclaration* memberFunction = isSgMemberFunctionDeclaration(*i);
               if (memberFunction != NULL)
                  {
                 // printf ("memberFunction = %p = %s \n",memberFunction,memberFunction->get_name().str());
                    if ( memberFunction->get_specialFunctionModifier().isConstructor() == true )
                       defaultConstructor = memberFunction;
                  }

            // iterate through the class members
               i++;
             }
        }

  // This should be true for the specific case that we are currently debugging!
  // ROSE_ASSERT(defaultConstructor != NULL);

     return defaultConstructor;
   }

SgMemberFunctionDeclaration*
SageInterface::getDefaultDestructor( SgClassDeclaration* classDeclaration )
   {
     SgMemberFunctionDeclaration* defaultDestructor = NULL;

     ROSE_ASSERT(classDeclaration != NULL);
     SgDeclarationStatement* definingDeclaration = classDeclaration->get_definingDeclaration();
     if (definingDeclaration != NULL)
        {
          ROSE_ASSERT(definingDeclaration != NULL);
          SgClassDeclaration* definingClassDeclaration = isSgClassDeclaration(definingDeclaration);

       // Note that not all class declarations have to have a defining declaration (e.g. "~int()" 
       // would be associated with a class declaration but no definition would exist).
          if (definingClassDeclaration != NULL)
             {
               SgClassDefinition* classDefinition = definingClassDeclaration->get_definition();
               ROSE_ASSERT(classDefinition != NULL);

               SgDeclarationStatementPtrList::iterator i = classDefinition->get_members().begin();
               while ( i != classDefinition->get_members().end() )
                  {
                 // Check the parent pointer to make sure it is properly set
                    ROSE_ASSERT( (*i)->get_parent() != NULL);

                 // DQ (11/1/2005): Note that a template instantiation can have a parent which is the 
                 // variable which forced it's instantiation.  Since it does not really exist in the 
                 // source code explicitly (it is compiler generated) this is as reasonable as anything else.
                 // if ( (*i)->get_parent() != classDefinition && isSgVariableDeclaration((*i)->get_parent()) == NULL)
                    if ( (*i)->get_parent() != classDefinition )
                       {
                         printf ("Error: (*i)->get_parent() = %p = %s \n",(*i)->get_parent(),(*i)->get_parent()->class_name().c_str());
                         printf ("(*i) = %p = %s = %s \n",*i,(*i)->class_name().c_str(),(*i)->unparseToString().c_str());
                         (*i)->get_file_info()->display("Called from SageInterface::getDefaultDestructor: debug");
                       }
                    ROSE_ASSERT( (*i)->get_parent() == classDefinition);
                 // ROSE_ASSERT( (*i)->get_parent() == classDefinition || isSgVariableDeclaration((*i)->get_parent()) != NULL);

                    SgMemberFunctionDeclaration* memberFunction = isSgMemberFunctionDeclaration(*i);
                    if (memberFunction != NULL)
                       {
                      // printf ("memberFunction = %p = %s \n",memberFunction,memberFunction->get_name().str());
                         if ( memberFunction->get_specialFunctionModifier().isDestructor() == true )
                            defaultDestructor = memberFunction;
                       }

                 // iterate through the class members
                    i++;
                  }
             }
        }

  // This should be true for the specific case that we are currently debugging!
  // ROSE_ASSERT(defaultDestructor != NULL);

     return defaultDestructor;
   }


void
SageInterface::outputGlobalFunctionTypeSymbolTable()
   {
  // DQ (6/27/2005): This function outputs the global table of function type symbols
  // it is built during the EDG/Sage translation phase, and it built initially with 
  // the EDG names of all instantiated templates.  At a later phase (incomplete at 
  // the moment) the AST fixup rebuilds the table to use the modified template names
  // (that is mangled names built from the modified template names used in Sage III).

  // DQ (1/31/2006): Modified to build all types in the memory pools
  // extern SgFunctionTypeTable Sgfunc_type_table;
  // Sgfunc_type_table.print_functypetable();
     ROSE_ASSERT(SgNode::get_globalFunctionTypeTable() != NULL);
     SgNode::get_globalFunctionTypeTable()->print_functypetable();
   }

void
SageInterface::outputLocalSymbolTables ( SgNode* node )
   {
  // This simplifies how the traversal is called!
     OutputLocalSymbolTables astTraversal;

  // I think the default should be preorder so that the interfaces would be more uniform
     astTraversal.traverse(node,preorder);
   }

void
SageInterface::OutputLocalSymbolTables::visit ( SgNode* node )
   {
  // DQ (6/27/2005): Output the local symbol table from each scope.
  // printf ("node = %s \n",node->sage_class_name());

     SgScopeStatement* scope = isSgScopeStatement(node);
     if (scope != NULL)
        {
          SgSymbolTable* symbolTable = scope->get_symbol_table();
          ROSE_ASSERT(symbolTable != NULL);

          printf ("Symbol Table from %p = %s at: \n",scope,scope->sage_class_name());
          scope->get_file_info()->display("Symbol Table Location (Called from SageInterface::OutputLocalSymbolTables::visit())");
          symbolTable->print("Called from SageInterface::OutputLocalSymbolTables::visit()");
        }
   }

#if 0
// DQ (8/28/2005): This is already a member function of the SgFunctionDeclaration 
// (so that it can handle template functions and member functions)

// DQ (8/27/2005): 
bool
SageInterface::isTemplateMemberFunction( SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration )
   {
  // This function determines if the member function is associated with a template  
  // or just a template class (where it is a normal non-template member function).

     bool result = false;

     result = memberFunctionDeclaration->isTemplateFunction();

     return result;
   }
#endif

// DQ (8/27/2005): 
bool
SageInterface::templateDefinitionIsInClass( SgTemplateInstantiationMemberFunctionDecl* memberFunctionDeclaration )
   {
  // This function determines if the template declaration associated withthis member function instantiation is 
  // defined in the class or outside of the class.

     bool result = false;

#if 0
  // Check if this is a template or non-template member function
     if (isTemplateMemberFunction(memberFunctionDeclaration) == true)
        {
          SgTemplateDeclaration* templateDeclaration = memberFunctionDeclaration->get_templateDeclaration();
          printf ("templateDeclaration = %p parent of templateDeclaration = %p \n",templateDeclaration,templateDeclaration->get_parent());

       // SgTemplateInstantiationDecl* classTemplateInstantiation = memberFunctionDeclaration->get_class_scope()->get_declaration();
          SgClassDeclaration* classDeclaration = memberFunctionDeclaration->get_class_scope()->get_declaration();
          ROSE_ASSERT(classDeclaration != NULL);
          SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(classDeclaration);

          if (classTemplateInstantiation != NULL)
             {
               SgTemplateDeclaration* classTemplateDeclaration = classTemplateInstantiation->get_templateDeclaration();
               if (classTemplateDeclaration != NULL && classTemplateDeclaration != templateDeclaration)
                  {
                    result = true;
                  }
             }
        }
#endif

  // Alternative approach
     SgTemplateDeclaration* templateDeclaration = memberFunctionDeclaration->get_templateDeclaration();
     printf ("In templateDefinitionIsInClass(): templateDeclaration = %p parent of templateDeclaration = %p = %s \n",templateDeclaration,
          templateDeclaration->get_parent(),templateDeclaration->get_parent()->class_name().c_str());

     SgScopeStatement* parentScope = isSgScopeStatement(templateDeclaration->get_parent());
     if (isSgClassDefinition(parentScope) != NULL)
        {
          result = true;
        }

     return result;
   }

SgDeclarationStatement*
generateUniqueDeclaration ( SgDeclarationStatement* declaration )
   {
  // DQ (10/11/2007): This is no longer used.
     printf ("Error: This is no longer used. \n");
     ROSE_ASSERT(false);

  // Get the defining or first non-defining declaration so that we can use it as a key to know 
  // when we have found the same function. So we don't count a redundant forward declaration 
  // found outside of the class as matching the first non-defining declaration or the defining 
  // declaration in the class by mistake. All declarations share the same firstNondefining 
  // declaration and defining declaration so either could be a key declaration, but there are 
  // times when either one of then (but not both) can be NULL (function defined withouth forward 
  // declaration or not defined at all).
     SgDeclarationStatement* firstNondefiningDeclaration = declaration->get_firstNondefiningDeclaration();
     SgDeclarationStatement* definingDeclaration         = declaration->get_definingDeclaration();
     SgDeclarationStatement* keyDeclaration = NULL;
     if (firstNondefiningDeclaration != NULL)
          keyDeclaration = firstNondefiningDeclaration;
       else
          keyDeclaration = definingDeclaration;
     ROSE_ASSERT(keyDeclaration != NULL);

     return keyDeclaration;
   }

// DQ (8/28/2005):
bool
SageInterface::isOverloaded ( SgFunctionDeclaration* functionDeclaration )
   {
  // This function looks for any other function that might overload the input function.
  // for member functions we only look in the scope where the member function is defined.
  // for non-member functions we look only in the scope where the function is declared.

  // Note that there are scenarios where this approach of searching only these locations 
  // might not catch an overloaded function.
  //     * member functions:
  //         - overloaded functions might be declared in base classes
  //     * non-member functions:
  //         - function declarations might be friend functions in classes
  //         - functions might be declared in differen namespace definitions 
  //              (SgNamespaceDefinitionStatement), since a namespace in re-entrant
  //              and can have many namespace declarations and definitions.

  // bool result = false;
     int counter = 0;

     SgMemberFunctionDeclaration* memberFunctionDeclaration = isSgMemberFunctionDeclaration(functionDeclaration);
     if (memberFunctionDeclaration != NULL)
        {
       // This is a member function declaration

       // DQ (10/11/2007): Fix this to NOT use the generateUniqueDeclaration() function.
       // Generate a key to use for comparision (avoids false positives)
       // SgMemberFunctionDeclaration* keyDeclaration = isSgMemberFunctionDeclaration(generateUniqueDeclaration(functionDeclaration));
       // ROSE_ASSERT(keyDeclaration != NULL);

       // Get the class definition
          SgClassDefinition* classDefinition = 
               isSgClassDefinition(memberFunctionDeclaration->get_scope());
          ROSE_ASSERT(classDefinition != NULL);

       // Get the class declaration associated with the class definition
          SgClassDeclaration* classDeclaration = isSgClassDeclaration(classDefinition->get_declaration());
          ROSE_ASSERT(classDeclaration != NULL);

       // Get the list of member declarations in the class
          SgDeclarationStatementPtrList & memberList = classDefinition->get_members();
#if 0
       // DQ (10/11/2007): Fix this function better by checking for more than one member function declaration in the class definition.
          printf ("   memberList.size() = %zu \n",memberList.size());
#endif
          for (SgDeclarationStatementPtrList::iterator i = memberList.begin(); i != memberList.end(); i++)
             {
#if 0
               printf ("   counter = %d declaration = %p = %s \n",counter,*i,(*i)->class_name().c_str());
#endif
               SgMemberFunctionDeclaration* tempMemberFunction = isSgMemberFunctionDeclaration(*i);
               SgTemplateDeclaration* tempTemplateDeclaration  = isSgTemplateDeclaration(*i);

            // Member functions could be overloaded
               if (tempMemberFunction != NULL)
                  {
#if 0
                 // DQ (10/11/2007): This is a problem for where s member function prototype from outside the class is checked to be an ovverloaded function.
                 // Check using the key declaration
                    if ( keyDeclaration == generateUniqueDeclaration(tempMemberFunction) )
                       {
#if 0
                         printf ("Skipping the case of keyDeclaration == generateUniqueDeclaration(tempMemberFunction) = %p \n",keyDeclaration);
#endif
                         continue;
                       }
#endif
                    ROSE_ASSERT(tempMemberFunction->get_name() != "");
#if 0
                    printf ("      tempMemberFunction = (name) %s = (qualified) %s \n",
                              tempMemberFunction->get_name().str(),
                              tempMemberFunction->get_qualified_name().str());
#endif
                    if (tempMemberFunction->get_name() == memberFunctionDeclaration->get_name())
                       {
#if 0
                         printf ("      Found a matching overloaded member function! \n");
#endif
                      // result = true;
                         counter++;
                       }
                  }
                 else
                  {
                 // Or templates could be overloaded, but nothing else.
                    if (tempTemplateDeclaration != NULL)
                       {
                      // If this is a template declaration, it could be a template 
                      // declaration for an overloaded member function of the same name.
#if 0
                      // printf ("keyDeclaration->get_name() = %s \n",keyDeclaration->get_name().str());
                         printf ("tempTemplateDeclaration->get_name() = %s \n",tempTemplateDeclaration->get_name().str());
#endif
                      // if (keyDeclaration->get_name() == tempTemplateDeclaration->get_name())
                         if (memberFunctionDeclaration->get_name() == tempTemplateDeclaration->get_name())
                            {
#if 0
                              printf ("      Found a matching overloaded member function! \n");
#endif
                           // result = true;
                              counter++;
                            }
                       }
                      else
                       {
                       // DQ (10/12/2007): Could friend functions defined in a class be overloaded?  Need to check this!
                          if (functionDeclaration->variantT() == V_SgFunctionDeclaration)
                             {
                               printf ("In SageInterface::isOverloaded(): could friend functions be overloaded in a class? \n");
                             }
                       }
                  }

            // If we have detected two, so we have an overloaded function.
               if (counter > 1)
                    break;
             }
        }
       else
        {
       // This is a non-member function declaration
          printf ("In SageInterface::isOverloaded(): case of non-member function not yet implemented! \n");
          ROSE_ASSERT(false);
        }

  // DQ (10/11/2007): Fixup to use the counter and consider more than 1 function with the same name an overloaded member function.
  // This might be a problem for friend functions, so test this separately.
  // return result;
     return (counter > 1);
   }




SgTemplateInstantiationMemberFunctionDecl* 
SageInterface::buildForwardFunctionDeclaration ( SgTemplateInstantiationMemberFunctionDecl* memberFunctionInstantiation )
   {
  // DQ (9/6/2005): This function builds a copy of the input function for the
  // construction of a forward declaration of the function. Required in the
  // instantiated functions definition is to be output as a specialization by ROSE.
  // Since the shallow copy mechanism will cause IR nodes to be shared, we have 
  // to fix it up with deep copies of the parameter list and the CtorInitializerList.

     ROSE_ASSERT(memberFunctionInstantiation != NULL);

#if 0
    printf ("buildForwardFunctionDeclaration: Member function = %p = %s = definition = %p \n",
          memberFunctionInstantiation,
          memberFunctionInstantiation->get_name().str(),
          memberFunctionInstantiation->get_definition());
    memberFunctionInstantiation->get_file_info()->display("memberFunctionInstantiation: debug");
#endif

  // This is a better implementation using a derived class from SgCopyHelp to control the 
  // copying process (skipping the copy of any function definition).  This is a variable 
  // declaration with an explicitly declared class type.
     class NondefiningFunctionDeclarationCopyType : public SgCopyHelp
        {
       // DQ (9/26/2005): This class demonstrates the use of the copy mechanism 
       // within Sage III (originally designed and implemented by Qing Yi).
       // One problem with it is that there is no context information permitted.

          public:
               virtual SgNode *copyAst(const SgNode *n)
                  {
                 // If still NULL after switch then make the copy
                    SgNode* returnValue = NULL;

                    switch(n->variantT())
                       {
                      // DQ (10/21/2007): Now that s bug is fixed in the SgDeclarationStatement::fixupCopy() 
                      // member function, I think we might not need this case.

                      // Don't copy the associated non-defining declaration when building a function prototype!
                         case V_SgFunctionDeclaration:
                         case V_SgMemberFunctionDeclaration:
                         case V_SgTemplateInstantiationFunctionDecl:
                         case V_SgTemplateInstantiationMemberFunctionDecl:
                            {
                           // printf ("Skip copying an associated non-defining declaration if it is present \n");
                              const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(n);
                              ROSE_ASSERT(functionDeclaration != NULL);
                              if (functionDeclaration == functionDeclaration->get_definingDeclaration())
                                 {
                                // This is the defining declaration (make a shallow copy)
                                // printf ("In NondefiningFunctionDeclarationCopyType::copyAst(): This is the DEFINING declaration! \n");
                                // return const_cast<SgNode *>(n);
                                   returnValue = const_cast<SgNode *>(n);
                                 }
                                else
                                 {
                                // This is the non-defining declaration where we want to make a deep copy.
                                // printf ("In NondefiningFunctionDeclarationCopyType::copyAst(): This is the NONDEFINING declaration! \n");
                                 }

                              break;
                            }

                      // Don't copy the function definitions (roughly the body of the function)
                         case V_SgFunctionDefinition:
                            {
                              printf ("Skip copying the function definition if it is present \n");
                           // return const_cast<SgNode *>(n);
                              returnValue = const_cast<SgNode *>(n);
                              break;
                            }

                         default:
                            {
                           // Nothing to do here
                              break;
                            }
                       }

                 // return n->copy(*this);

                 // If not set at this point then make the copy!
                    if (returnValue == NULL)
                         returnValue = n->copy(*this);

                    ROSE_ASSERT(returnValue != NULL);
                    return returnValue;
                  }
        } 
#ifdef USE_ROSE // workaround for bug 322
        ;
#else        
        nondefiningFunctionDeclarationCopy;
#endif        

  // DQ (10/20/2007): The more accurate copy mechanism now builds us a defining declaration to go with the non-defining declaration!
  // This is because we have to remove the pointers from non-defining declaration to the definition (which should be pointed to ONLY by the defining declaration!
  // delete copyOfMemberFunction->get_definingDeclaration();
     if (memberFunctionInstantiation->get_definition() != NULL)
        {
          printf ("\n\nNEED TO REMOVE POINTERS IN THE NON-DEFINING DECLARATION TO THE SgClassDefinition objects. \n");
          ROSE_ASSERT(false);

       // If we see the assertion above fail then we might want to use this code:
          ROSE_ASSERT( memberFunctionInstantiation != memberFunctionInstantiation->get_definingDeclaration() );
          memberFunctionInstantiation->set_definition(NULL);
        }
#ifdef USE_ROSE
     SgNode* copyOfMemberFunctionNode = memberFunctionInstantiation->copy(NondefiningFunctionDeclarationCopyType);
#else     
     SgNode* copyOfMemberFunctionNode = memberFunctionInstantiation->copy(nondefiningFunctionDeclarationCopy);
#endif     
     SgTemplateInstantiationMemberFunctionDecl* copyOfMemberFunction = static_cast<SgTemplateInstantiationMemberFunctionDecl*>(copyOfMemberFunctionNode);

  // printf ("\n\nHOW DO WE KNOW WHEN TO NOT COPY THE DEFINING DECLARATION SO THAT WE CAN JUST BUILD A FUNCTION PROTOTYPE! \n");
  // ROSE_ASSERT(false);

#if 0
     printf ("copyOfMemberFunction->get_firstNondefiningDeclaration() = %p \n",copyOfMemberFunction->get_firstNondefiningDeclaration());
#endif
  // DQ (10/11/2007): The copy function sets the firstNondefiningDeclaration to itself if in the original declaration it had the 
  // firstNondefiningDeclaration set to itself, this is incorrect in the case where we only make a copy of function declaration, 
  // and causes the symbol table tests for get_declaration_associated_with_symbol() to fail because it uses the 
  // firstNondefiningDeclaration which is not the one associated with the symbol in the parent scope. So reset the 
  // firstNondefiningDeclaration in the copy of the member function.
     copyOfMemberFunction->set_firstNondefiningDeclaration(memberFunctionInstantiation->get_firstNondefiningDeclaration());

#if 0
     printf ("memberFunctionInstantiation->get_firstNondefiningDeclaration() = %p \n",memberFunctionInstantiation->get_firstNondefiningDeclaration());

     printf ("copyOfMemberFunction->isForward()        = %s \n",copyOfMemberFunction->isForward() ? "true" : "false");
     printf ("memberFunctionInstantiation->isForward() = %s \n",memberFunctionInstantiation->isForward() ? "true" : "false");
#endif
#if 0
     printf ("memberFunctionInstantiation->isSpecialization()        = %s \n",memberFunctionInstantiation->isSpecialization() ? "true" : "false");
     printf ("copyOfMemberFunctionNode = %p = %s = %s memberFunctionInstantiation->isSpecialization() = %s \n",
          copyOfMemberFunction,copyOfMemberFunction->class_name().c_str(),SageInterface::get_name(copyOfMemberFunction).c_str(),copyOfMemberFunction->isSpecialization() ? "true" : "false");
     copyOfMemberFunction->get_file_info()->display("copyOfMemberFunction: debug");
#endif

  // Make sure that we have the same number of arguments on the copy that we build
     ROSE_ASSERT(memberFunctionInstantiation->get_args().size() == copyOfMemberFunction->get_args().size());

  // DQ (11/5/2007): Additional tests
     ROSE_ASSERT(memberFunctionInstantiation->get_startOfConstruct()->isOutputInCodeGeneration() == copyOfMemberFunction->get_startOfConstruct()->isOutputInCodeGeneration());
     ROSE_ASSERT(memberFunctionInstantiation->get_startOfConstruct()->isCompilerGenerated() == copyOfMemberFunction->get_startOfConstruct()->isCompilerGenerated());

     ROSE_ASSERT(copyOfMemberFunction != NULL);
     return copyOfMemberFunction;
   }


void
supportForBaseTypeDefiningDeclaration ( SgSymbolTable* symbolTable, SgDeclarationStatement* declarationForType )
   {
  // DQ (10/14/2007): Supporting function for 

     ROSE_ASSERT(declarationForType != NULL);

#if 1
  // DQ (11/7/2007): Added more cases...
     switch(declarationForType->variantT())
        {
          case V_SgClassDeclaration:
             {
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(declarationForType);
               SgSymbol* symbol = new SgClassSymbol(classDeclaration);
               ROSE_ASSERT(symbol != NULL);
               SgName name = classDeclaration->get_name();
               symbolTable->insert(name,symbol);
               break;
             }

          case V_SgEnumDeclaration:
             {
               SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(declarationForType);
               SgSymbol* symbol = new SgEnumSymbol(enumDeclaration);
               ROSE_ASSERT(symbol != NULL);
               SgName name = enumDeclaration->get_name();
               symbolTable->insert(name,symbol);
               break;
             }

          case V_SgFunctionDeclaration:
             {
               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(declarationForType);
               SgSymbol* symbol = new SgFunctionSymbol(functionDeclaration);
               ROSE_ASSERT(symbol != NULL);
               SgName name = functionDeclaration->get_name();
               symbolTable->insert(name,symbol);
               break;
             }

          case V_SgMemberFunctionDeclaration:
             {
               SgMemberFunctionDeclaration* functionDeclaration = isSgMemberFunctionDeclaration(declarationForType);
               SgSymbol* symbol = new SgMemberFunctionSymbol(functionDeclaration);
               ROSE_ASSERT(symbol != NULL);
               SgName name = functionDeclaration->get_name();
               symbolTable->insert(name,symbol);
               break;
             }

          default:
             {
               printf ("Default reached in evaluation of typedef inner definition = %p = %s and building a symbol for it for the symbol table \n",declarationForType,declarationForType->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }
#else
  // Build a SgClassDeclaration, SgEnumDeclaration
     SgClassDeclaration* classDeclaration = isSgClassDeclaration(declarationForType);
     if (classDeclaration != NULL)
        {
          SgSymbol* symbol = new SgClassSymbol(classDeclaration);
          ROSE_ASSERT(symbol != NULL);
          SgName name = classDeclaration->get_name();
          symbolTable->insert(name,symbol);
        }
       else
        {
          SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(declarationForType);
          if (enumDeclaration != NULL)
             {
               SgSymbol* symbol = new SgEnumSymbol(enumDeclaration);
               ROSE_ASSERT(symbol != NULL);
               SgName name = enumDeclaration->get_name();
               symbolTable->insert(name,symbol);
             }
            else
             {
               printf ("Error: variableDeclarationContainsBaseTypeDefiningDeclaration == true, but is a %s \n",declarationForType->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }
#endif
   }


void
supportForVariableLists ( SgScopeStatement* scope, SgSymbolTable* symbolTable, SgInitializedNamePtrList & variableList )
   {
  // DQ (11/1/2007): Added supporting function to refactor code.
     SgInitializedNamePtrList::iterator i = variableList.begin();
     while (i != variableList.end())
        {
          SgInitializedName* variable = *i;
          ROSE_ASSERT(variable != NULL);
          if (variable->get_scope() == scope)
             {
            // printf ("Scopes match, OK! \n");
             }
            else
             {
               printf ("WARNING: Scopes do NOT match! variable = %p = %s (could this be a static variable, or has the symbol table been setup before the scopes have been set?) \n",variable,variable->get_name().str());
             }

          SgSymbol* symbol = new SgVariableSymbol(variable);
          ROSE_ASSERT(symbol != NULL);
          SgName name = variable->get_name();
          symbolTable->insert(name,symbol);

          i++;
        }
   }

void
supportForVariableDeclarations ( SgScopeStatement* scope, SgSymbolTable* symbolTable, SgVariableDeclaration* variableDeclaration )
   {
  // DQ (10/24/2007): Added supporting function to refactor code.
     SgInitializedNamePtrList & variableList = variableDeclaration->get_variables();
#if 1
     supportForVariableLists(scope,symbolTable,variableList);
#else
     SgInitializedNamePtrList::iterator i = variableList.begin();
     while ( i != variableList.end() )
        {
          SgInitializedName* variable = *i;
          ROSE_ASSERT(variable != NULL);

       // DQ (10/20/2007): static data members declared outside the class scope don't generate symbols.
       // if (variable->get_prev_decl_item() != NULL)
          if (variable->get_scope() == scope)
             {
               SgSymbol* symbol = new SgVariableSymbol(variable);
               ROSE_ASSERT(symbol != NULL);

            // printf ("In SageInterface::rebuildSymbolTable() variable = %p building a new SgVariableSymbol = %p \n",variable,symbol);

               SgName name = variable->get_name();
               symbolTable->insert(name,symbol);
             }
            else
             {
            // I think there is nothing to do in this case
            // printf ("In SageInterface::rebuildSymbolTable() This variable has a scope inconsistant with the symbol table: variable->get_scope() = %p scope = %p \n",variable->get_scope(),scope);
             }

          i++;
        }
#endif

  // DQ (10/13/2007): Need to look into variable declarations to see if there are defining declaration 
  // that also force symbols to be built in the current scope!
  // ROSE_ASSERT(derivedDeclaration->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == false);
     if (variableDeclaration->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)
        {
       // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.
          ROSE_ASSERT(symbolTable != NULL);
          ROSE_ASSERT(variableDeclaration->get_baseTypeDefiningDeclaration() != NULL);
          supportForBaseTypeDefiningDeclaration ( symbolTable, variableDeclaration->get_baseTypeDefiningDeclaration() );
        }
   }



void
supportForLabelStatements ( SgScopeStatement* scope, SgSymbolTable* symbolTable )
   {
  // Update the symbol table in SgFunctionDefinition with all the labels in the function.

     std::vector<SgNode*> labelList = NodeQuery::querySubTree (scope,V_SgLabelStatement);

     int numberOfLabels = labelList.size();
     for (int i=0; i < numberOfLabels; i++)
        {
          SgLabelStatement* labelStatement = isSgLabelStatement(labelList[i]);

          ROSE_ASSERT(labelStatement->get_scope() == scope);

          SgSymbol* symbol = new SgLabelSymbol(labelStatement);
          ROSE_ASSERT(symbol != NULL);

       // printf ("In SageInterface::rebuildSymbolTable() labelStatement = %p building a new SgLabelSymbol = %p \n",labelStatement,symbol);

          SgName name = labelStatement->get_name();
          symbolTable->insert(name,symbol);
        }
   }


void
SageInterface::rebuildSymbolTable ( SgScopeStatement* scope )
{
  // This function is called from the implementation of the copy member functions.

  ROSE_ASSERT(scope != NULL);
  // printf ("In SageInterface::rebuildSymbolTable(): Symbol Table from %p = %s \n",scope,scope->sage_class_name());

  SgSymbolTable* symbolTable = scope->get_symbol_table();

  if (symbolTable != NULL)
  {
    // This must be an empty symbol table!
    if (symbolTable->size() != 0)
    {
      printf ("symbolTable->size() = %d \n",symbolTable->size());
    }
    ROSE_ASSERT(symbolTable->size() == 0);
#if 0
    printf ("Symbol Table from %p = %s of size = %zu \n",scope,scope->sage_class_name(),symbolTable->size());
    symbolTable->print("Called from SageInterface::rebuildSymbolTable()");
#endif
  }
  else
  {
#if 0
    printf ("In SageInterface::rebuildSymbolTable(): No symbol table found \n");
#endif
    ROSE_ASSERT(symbolTable == NULL);

    // DQ (10/8/2007): Build a new symbol table if there was not already one built.
    symbolTable = new SgSymbolTable();

    ROSE_ASSERT(symbolTable != NULL);
    ROSE_ASSERT(symbolTable->get_table() != NULL);

    // DQ (2/16/2006): Set this parent directly (now tested)
    symbolTable->set_parent(scope);
    ROSE_ASSERT(symbolTable->get_parent() != NULL);

    scope->set_symbol_table(symbolTable);
  }

  // DQ (10/8/2007): If there is already a symbol table then don't over write it. This fixes copies generated with more than one symbol table.
  ROSE_ASSERT(scope->get_symbol_table() != NULL);
  ROSE_ASSERT(scope->get_symbol_table()->get_table() != NULL);

  // This implements SgScopeStatement specific details (e.g function declarations have parameters and their declaration causes variable 
  // symbols to be placed into the SgFunctionDefinition scope (but only for defining declarations).
  switch(scope->variantT())
  {
    case V_SgForStatement:
      {
        // These scopes have their symbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).
        // printf ("Symbol tables could contain symbols outside of the inclosed body scope = %p = %s \n",scope,scope->class_name().c_str());

        SgForStatement* forStatement = isSgForStatement(scope);

        SgStatementPtrList::iterator i = forStatement->get_init_stmt().begin();

        // printf ("i != forStatement->get_init_stmt().end() = %s \n",i != forStatement->get_init_stmt().end() ? "true" : "false");

        while (i != forStatement->get_init_stmt().end())
        {
          // printf ("For statement initialization list: *i = %p = %s \n",*i,(*i)->class_name().c_str());
          SgVariableDeclaration* variableDeclarationInitializer = isSgVariableDeclaration(*i);
          if (variableDeclarationInitializer != NULL)
          {
            // There is a variable declaration in the conditional, it needs to be added to the symbol table.
            // printf ("There is a variable declaration in the for statement initializer, it needs to be added to the symbol table scope = %p = %s \n",scope,scope->class_name().c_str());
            // ROSE_ASSERT(false);
            supportForVariableDeclarations ( scope, symbolTable, variableDeclarationInitializer );
          }

          i++;
        }

        SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(forStatement->get_test());
        if (variableDeclarationCondition != NULL)
        {
          // There is a variable declaration in the conditional, it needs to be added to the symbol table.
          // printf ("There is a variable declaration in the for statement test, it needs to be added to the symbol table scope = %p = %s \n",scope,scope->class_name().c_str());
          // ROSE_ASSERT(false);
          supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );
        }
        return;
        break;
      }

    case V_SgFunctionDefinition:
      {
        // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).
        // printf ("Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n",scope,scope->class_name().c_str());

        // DQ (10/8/2007): If this is a SgFunctionDefinition, then include the parameters in the SgFunctionDeclaration.
        SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(scope);
        if (functionDefinition != NULL)
        {
          SgFunctionDeclaration* functionDeclaration = functionDefinition->get_declaration();
          // printf ("In SageInterface::rebuildSymbolTable(): functionDefinition = %p functionDeclaration = %p \n",functionDefinition,functionDeclaration);

          // DQ (10/8/2007): It turns out that this is always NULL, because the parent of the functionDeclaration has not yet been set in the copy mechanism!
          if (functionDeclaration != NULL)
          {
            ROSE_ASSERT(functionDeclaration->isForward() == false);
            SgInitializedNamePtrList & argumentList = functionDeclaration->get_args();
            supportForVariableLists(scope,symbolTable,argumentList);
          }
          else
          {
            // This happend in the copy function because the function definition is copied from the SgFunctionDeclaration 
            // and only after the copy is made is the parent of the definition set to be the function declaration.  Thus 
            // the get_declaration() member function returns NULL.
            // printf ("There is no function declaration associated with this function definition! \n");
            // ROSE_ASSERT(functionDeclaration->isForward() == true);
          }
        }

        // DQ (10/25/2007): Label symbols are now places into the SgFunctionDefinition (they have to be collected from the function).
        supportForLabelStatements(scope,symbolTable);

        return;
        break;
      }

    case V_SgIfStmt:
      {
        // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).
        // printf ("Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n",scope,scope->class_name().c_str());

        SgIfStmt* ifStatement = isSgIfStmt(scope);
        SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(ifStatement->get_conditional());
        if (variableDeclarationCondition != NULL)
        {
          // There is a variable declaration in the conditional, it needs to be added to the symbol table.
          // printf ("There is a variable declaration in the conditional, it needs to be added to the symbol table \n");
          // ROSE_ASSERT(false);
          supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );
        }
        return;
        break;
      }

    case V_SgSwitchStatement:
      {
        // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).
        // printf ("Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n",scope,scope->class_name().c_str());

        SgSwitchStatement* switchStatement = isSgSwitchStatement(scope);
        SgVariableDeclaration* variableDeclarationSelector = isSgVariableDeclaration(switchStatement->get_item_selector());
        if (variableDeclarationSelector != NULL)
        {
          // There is a variable declaration in the conditional, it needs to be added to the symbol table.
          // printf ("There is a variable declaration in the item selector of the switch statement, it needs to be added to the symbol table \n");

          supportForVariableDeclarations ( scope, symbolTable, variableDeclarationSelector );
        }
        return;
        break;
      }

    case V_SgWhileStmt:
      {
        // These scopes have their sysmbols split between the attached symbol table and the symbol tables in the SgBasicBlock data member(s).
        // commented out like for others, otherwise show up each time a While is being copied. Liao, 1/31/2008
        //   printf ("Symbol tables could contain symbols outside of the enclosed body scope = %p = %s \n",scope,scope->class_name().c_str());

        SgWhileStmt* whileStatement = isSgWhileStmt(scope);
        SgVariableDeclaration* variableDeclarationCondition = isSgVariableDeclaration(whileStatement->get_condition());
        if (variableDeclarationCondition != NULL)
        {
          // There is a variable declaration in the conditional, it needs to be added to the symbol table.
          // printf ("There is a variable declaration in the while statement condition, it needs to be added to the symbol table \n");
          // ROSE_ASSERT(false);

          supportForVariableDeclarations ( scope, symbolTable, variableDeclarationCondition );
        }
        return;
        break;
      }

    case V_SgCatchOptionStmt:
    case V_SgDoWhileStmt:
      {
        // These scopes contain a SgBasicBlock as a data member and the scope is held there.
        // printf ("Symbol tables can must be computed by the enclosed body scope = %p = %s \n",scope,scope->class_name().c_str());
        return;
        break;
      }

    case V_SgBasicBlock:
    case V_SgClassDefinition:
    case V_SgTemplateInstantiationDefn:
    case V_SgGlobal:
    case V_SgNamespaceDefinitionStatement:
    case V_SgFortranDo: //Liao 12/19/2008, My understanding is that Fortran do loop header does not introduce new symbols like  a C/C++ for loop does
      {
        // printf ("Used the list of statements/declarations that are held deirectly by this scope \n");
        break;
      }

    default:
      {
        printf ("Default reached in SageInterface::rebuildSymbolTable() scope = %p = %s \n",scope,scope->class_name().c_str());
        ROSE_ASSERT(false);
        break;
      }
  }

  // Generate a copy of the statement list (this is simpler than handling the cases of a 
  // declaration list and a statement list separately for the scopes that contain one or the other.
  SgStatementPtrList statementList = scope->generateStatementList();

  // Loop through the statements and for each declaration build a symbol and add it to the symbol table
  for (SgStatementPtrList::iterator i = statementList.begin(); i != statementList.end(); i++)
  {
    // At some point we should move this mechanism in to a factory patterns for SgSymbol

    // printf ("Iterating through the declaration in this scope ... %p = %s = %s \n",*i,(*i)->class_name().c_str(),get_name(*i).c_str());

    SgDeclarationStatement* declaration = isSgDeclarationStatement(*i);
    if (declaration != NULL)
    {
      // DQ (11/7/2007): Where there can be multiple declaration (e.g. function declarations with prototypes) only use one of them.
      bool useThisDeclaration = (declaration->get_firstNondefiningDeclaration() == declaration) || 
        ( (declaration->get_firstNondefiningDeclaration() == NULL) && (declaration->get_definingDeclaration() == declaration) );

      list<SgSymbol*> symbolList;
      switch(declaration->variantT())
      {
        case V_SgTemplateInstantiationMemberFunctionDecl:
          {
            SgTemplateInstantiationMemberFunctionDecl* derivedDeclaration = isSgTemplateInstantiationMemberFunctionDecl(declaration);
#if 1
            // DQ (11/6/2007): Don't build a symbol for the defining declaration defined in another scope and put the resulting symbol into the wrong scope
            if (scope == derivedDeclaration->get_scope())
            {
              SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);
              ROSE_ASSERT(symbol != NULL);

              // printf ("SgTemplateInstantiationMemberFunctionDecl: scope = %p derivedDeclaration = %p = %s inserting a symbol = %p \n",scope,derivedDeclaration,get_name(derivedDeclaration).c_str(),symbol);

              SgName name = derivedDeclaration->get_name();
              symbolTable->insert(name,symbol);
            }
            else
            {
              // printf ("SgTemplateInstantiationMemberFunctionDecl: scope = %p derivedDeclaration = %p = %s didn't match the scope \n",scope,derivedDeclaration,get_name(derivedDeclaration).c_str());

              // These IR nodes might only exist as a template declaration and thus not be structureally present in their scope.
              // So we would never traverse them in the correct scope and so never build sysmbols for them and add the symbols 
              // to the correct symbol table.  This is a fundamental problem.  So we have to try to add these sorts of symbols
              // to the scope were they belong.
              SgScopeStatement* derivedDeclarationScope = derivedDeclaration->get_scope();
              ROSE_ASSERT(derivedDeclarationScope != NULL);

              // If this is a copy then it would be nice to make sure that the scope has been properly set.
              // Check this by looking for the associated template declaration in the scope.
              SgTemplateDeclaration* templateDeclaration = derivedDeclaration->get_templateDeclaration();
              ROSE_ASSERT(templateDeclaration != NULL);
              SgTemplateSymbol* templateSymbol = derivedDeclarationScope->lookup_template_symbol(templateDeclaration->get_name());
              if (templateSymbol != NULL)
              {
                // The symbol is not present, so we have to build one and add it.
#if 0
                printf ("Building a symbol for derivedDeclaration = %p = %s to an alternative symbol table in derivedDeclarationScope = %p \n",
                    derivedDeclaration,get_name(derivedDeclaration).c_str(),derivedDeclarationScope);
#endif
                SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);
                ROSE_ASSERT(symbol != NULL);
                SgName name = derivedDeclaration->get_name();
                derivedDeclarationScope->insert_symbol(name,symbol);
              }
              else
              {
                // printf ("The symbol was already present in the derivedDeclarationScope = %p \n",derivedDeclarationScope);
              }
            }
#else
            SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            break;
          }

        case V_SgMemberFunctionDeclaration:
          {
#if 1
            SgMemberFunctionDeclaration* derivedDeclaration = isSgMemberFunctionDeclaration(declaration);

            // DQ (11/6/2007): Don't build a symbol for the defining declaration defined in another scope and put the resulting symbol into the wrong scope
            if (scope == derivedDeclaration->get_scope())
            {
              SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);
              ROSE_ASSERT(symbol != NULL);
              SgName name = derivedDeclaration->get_name();
              symbolTable->insert(name,symbol);
            }
            else
            {
              // This happens when a defining declaration is located outside of the class where it is associated.
              // printf ("SgMemberFunctionDeclaration: scope = %p derivedDeclaration = %p = %s didn't match the scope \n",scope,derivedDeclaration,get_name(derivedDeclaration).c_str());
            }
#else
            SgMemberFunctionDeclaration* derivedDeclaration = isSgMemberFunctionDeclaration(declaration);
            SgSymbol* symbol = new SgMemberFunctionSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            // symbolList.push_back(symbol);
            // ROSE_ASSERT(symbolList.empty() == false);
            break;
          }

        case V_SgTemplateInstantiationFunctionDecl:
          {
            SgTemplateInstantiationFunctionDecl* derivedDeclaration = isSgTemplateInstantiationFunctionDecl(declaration);
#if 1
            // DQ (10/21/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)
            // if (derivedDeclaration->get_declarationModifier().isFriend() == false)
            if (scope == derivedDeclaration->get_scope())
            {
              SgSymbol* symbol = new SgFunctionSymbol(derivedDeclaration);
              ROSE_ASSERT(symbol != NULL);
              SgName name = derivedDeclaration->get_name();
              symbolTable->insert(name,symbol);
            }
            else
            {
              if (derivedDeclaration->get_declarationModifier().isFriend() == false)
              {
#if PRINT_DEVELOPER_WARNINGS
                printf ("Shouldn't this be a friend declaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
#endif
              }
            }
#else
            SgSymbol* symbol = new SgFunctionSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            break;
          }

        case V_SgFunctionDeclaration:
          {
            SgFunctionDeclaration* derivedDeclaration = isSgFunctionDeclaration(declaration);

            // DQ (10/20/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)
            // if (derivedDeclaration->get_declarationModifier().isFriend() == false)

            if (useThisDeclaration == true)
            {
              if (scope == derivedDeclaration->get_scope())
              {
                SgSymbol* symbol = new SgFunctionSymbol(derivedDeclaration);
                ROSE_ASSERT(symbol != NULL);
                SgName name = derivedDeclaration->get_name();
                symbolTable->insert(name,symbol);
              }
              else
              {
                if (derivedDeclaration->get_declarationModifier().isFriend() == false)
                {
#if PRINT_DEVELOPER_WARNINGS
                  printf ("Shouldn't this be a friend declaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
#endif
                }
              }
            }
            break;
          }

        case V_SgVariableDeclaration:
          {
            SgVariableDeclaration* derivedDeclaration = isSgVariableDeclaration(declaration);
            SgInitializedNamePtrList & variableList = derivedDeclaration->get_variables();
            SgInitializedNamePtrList::iterator i = variableList.begin();
            while ( i != variableList.end() )
            {
              SgInitializedName* variable = *i;
              ROSE_ASSERT(variable != NULL);

              // DQ (10/20/2007): static data members declared outside the class scope don't generate symbols.
              // if (variable->get_prev_decl_item() != NULL)
              if (variable->get_scope() == scope)
              {
                SgSymbol* symbol = new SgVariableSymbol(variable);
                ROSE_ASSERT(symbol != NULL);

                // printf ("In SageInterface::rebuildSymbolTable() variable = %p building a new SgVariableSymbol = %p \n",variable,symbol);

                SgName name = variable->get_name();
                symbolTable->insert(name,symbol);
              }
              else
              {
                // I think there is nothing to do in this case
                // printf ("In SageInterface::rebuildSymbolTable() This variable has a scope inconsistant with the symbol table: variable->get_scope() = %p scope = %p \n",variable->get_scope(),scope);
              }

              i++;
            }

            // DQ (10/13/2007): Need to look into variable declarations to see if there are defining declaration 
            // that also force symbols to be built in the current scope!
            // ROSE_ASSERT(derivedDeclaration->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == false);
            if (derivedDeclaration->get_variableDeclarationContainsBaseTypeDefiningDeclaration() == true)
            {
              // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.
              ROSE_ASSERT(symbolTable != NULL);
              ROSE_ASSERT(derivedDeclaration->get_baseTypeDefiningDeclaration() != NULL);
              supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration->get_baseTypeDefiningDeclaration() );
            }

            // ROSE_ASSERT(symbolList.empty() == false);
            break;
          }

        case V_SgTemplateInstantiationDecl:
          {
            SgTemplateInstantiationDecl* derivedDeclaration = isSgTemplateInstantiationDecl(declaration);
#if 1
            // printf ("case SgTemplateInstantiationDecl: derivedDeclaration name = %s derivedDeclaration->get_declarationModifier().isFriend() = %s \n",
            //      derivedDeclaration->get_name().str(),derivedDeclaration->get_declarationModifier().isFriend() ? "true" : "false");

            // if (derivedDeclaration->get_declarationModifier().isFriend() == false)
            if (scope == derivedDeclaration->get_scope())
            {
              SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);
              // printf ("Inserting SgClassSymbol = %p into scope = %p = %s \n",symbol,scope,scope->class_name().c_str());
              ROSE_ASSERT(symbol != NULL);
              SgName name = derivedDeclaration->get_name();
#if 0
              // DQ (10/21/2007): The scopes should match
              if (scope != derivedDeclaration->get_scope())
              {
                printf ("Error: scopes don't match for derivedDeclaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
              }
              ROSE_ASSERT(scope == derivedDeclaration->get_scope());
#endif
              symbolTable->insert(name,symbol);
            }
            else
            {
              // printf ("SgTemplateInstantiationDecl: scope = %p derivedDeclaration = %p = %s didn't match the scope \n",scope,derivedDeclaration,get_name(derivedDeclaration).c_str());

              if (derivedDeclaration->get_declarationModifier().isFriend() == false)
              {
#if PRINT_DEVELOPER_WARNINGS
                printf ("Shouldn't this be a friend declaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
#endif
              }
            }
#else
            SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            break;
          }

        case V_SgClassDeclaration:
          {
            SgClassDeclaration* derivedDeclaration = isSgClassDeclaration(declaration);
#if 1
            // printf ("case SgClassDeclaration: derivedDeclaration name = %s derivedDeclaration->get_declarationModifier().isFriend() = %s \n",
            //      derivedDeclaration->get_name().str(),derivedDeclaration->get_declarationModifier().isFriend() ? "true" : "false");
            // if (derivedDeclaration->get_declarationModifier().isFriend() == false)
            if (scope == derivedDeclaration->get_scope())
            {
              SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);
              ROSE_ASSERT(symbol != NULL);
              SgName name = derivedDeclaration->get_name();
              symbolTable->insert(name,symbol);
            }
            else
            {
              if (derivedDeclaration->get_declarationModifier().isFriend() == false)
              {
#if PRINT_DEVELOPER_WARNINGS
                printf ("Shouldn't this be a friend declaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
#endif
              }
            }
#else
            SgSymbol* symbol = new SgClassSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            break;
          }

        case V_SgEnumDeclaration:
          {
            SgEnumDeclaration* derivedDeclaration = isSgEnumDeclaration(declaration);
            ROSE_ASSERT(derivedDeclaration != NULL);
            SgSymbol* symbol = new SgEnumSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);

            // DQ (10/18/2007): Fixed construction of symbol tabel to include enum fields.
            SgInitializedNamePtrList & enumFieldList = derivedDeclaration->get_enumerators();
            SgInitializedNamePtrList::iterator i     = enumFieldList.begin();

            // Iterate over enum fields and add each one to the symbol table.
            while (i != enumFieldList.end())
            {
              SgSymbol* enum_field_symbol = new SgEnumFieldSymbol(*i);
              ROSE_ASSERT(enum_field_symbol != NULL);
              SgName enum_field_name = (*i)->get_name();
              symbolTable->insert(enum_field_name,enum_field_symbol);

              i++;
            }

            break;
          }

        case V_SgTypedefDeclaration:
          {
            SgTypedefDeclaration* derivedDeclaration = isSgTypedefDeclaration(declaration);
            SgSymbol* symbol = new SgTypedefSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);

            // DQ (10/13/2007): Need to look into typedefs to see if there are defining declaration 
            // that also force symbols to be built in the current scope!
            // ROSE_ASSERT(derivedDeclaration->get_typedefBaseTypeContainsDefiningDeclaration() == false);
            if (derivedDeclaration->get_typedefBaseTypeContainsDefiningDeclaration() == true)
            {
              // Build a SgClassDeclaration, SgEnumDeclaration associated symbol and add it to the symbol table.
              ROSE_ASSERT(symbolTable != NULL);
              ROSE_ASSERT(derivedDeclaration->get_baseTypeDefiningDeclaration() != NULL);
              supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration->get_baseTypeDefiningDeclaration() );
            }
            else
            {
              // DQ (11/7/2007): If the typedef has a definition (e.g. function pointer) then build a symbol.
              SgDeclarationStatement* declaration = derivedDeclaration->get_declaration();
              if (declaration != NULL)
              {
                supportForBaseTypeDefiningDeclaration ( symbolTable, derivedDeclaration->get_declaration() );
              }
            }                         

            break;
          }

        case V_SgTemplateDeclaration:
          {
            SgTemplateDeclaration* derivedDeclaration = isSgTemplateDeclaration(declaration);
#if 1
            // DQ (10/21/2007): If this is a friend function in a class then we have to skip insertion of the symbol into this scope (this symbol table)
#if 0
            printf ("case V_SgTemplateDeclaration: derivedDeclaration               = %p \n",derivedDeclaration);
            printf ("case V_SgTemplateDeclaration: derivedDeclaration->get_declarationModifier().isFriend() = %s \n",derivedDeclaration->get_declarationModifier().isFriend() ? "true" : "false");
            printf ("case V_SgTemplateDeclaration: derivedDeclaration->get_name()   = %s \n",derivedDeclaration->get_name().str());
            printf ("case V_SgTemplateDeclaration: derivedDeclaration->get_string() = %s \n",derivedDeclaration->get_string().str());
#endif
            // if (derivedDeclaration->get_declarationModifier().isFriend() == false)
            if (scope == derivedDeclaration->get_scope())
            {
              // printf ("Building symbol for SgTemplateDeclaration: derivedDeclaration = %p for symbol table in scope = %p \n",derivedDeclaration,scope);
              SgSymbol* symbol = new SgTemplateSymbol(derivedDeclaration);
              ROSE_ASSERT(symbol != NULL);
              SgName name = derivedDeclaration->get_name();
              symbolTable->insert(name,symbol);
            }
            else
            {
              if (derivedDeclaration->get_declarationModifier().isFriend() == false)
              {
#if PRINT_DEVELOPER_WARNINGS
                printf ("Shouldn't this be a friend declaration = %p = %s \n",derivedDeclaration,derivedDeclaration->class_name().c_str());
#endif
              }
            }
#else
            SgTemplateDeclaration* derivedDeclaration = isSgTemplateDeclaration(declaration);
            SgSymbol* symbol = new SgTemplateSymbol(derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
#endif
            break;
          }

          // Does this cause a symbol to be built?  Seems that it should, 
          // unless we always reference the non-aliased symbol (reuse it)!
        case V_SgNamespaceAliasDeclarationStatement:
          {
            SgNamespaceAliasDeclarationStatement* aliasDeclaration = isSgNamespaceAliasDeclarationStatement(declaration);
            ROSE_ASSERT(aliasDeclaration != NULL);
            ROSE_ASSERT(aliasDeclaration->get_namespaceDeclaration() != NULL);

            SgNamespaceDeclarationStatement* derivedDeclaration = isSgNamespaceDeclarationStatement(aliasDeclaration->get_namespaceDeclaration());
            ROSE_ASSERT(derivedDeclaration != NULL);

            // The constructor for the SgNamespaceSymbol is disturbingly different from the rest of the constructors.
            SgSymbol* symbol = new SgNamespaceSymbol(derivedDeclaration->get_name(),derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
            // symbolList.push_back(symbol);
            // ROSE_ASSERT(symbolList.empty() == false);
            break;
          }

          // Does this cause a symbol to be built?  Seems that it should, 
          // unless we always reference the non-aliased symbol (reuse it)!
        case V_SgNamespaceDeclarationStatement:
          {
            SgNamespaceDeclarationStatement* derivedDeclaration = isSgNamespaceDeclarationStatement(declaration);
            ROSE_ASSERT(derivedDeclaration != NULL);

            // The constructor for the SgNamespaceSymbol is disturbingly different from the rest of the constructors.
            SgSymbol* symbol = new SgNamespaceSymbol(derivedDeclaration->get_name(),derivedDeclaration);
            ROSE_ASSERT(symbol != NULL);
            SgName name = derivedDeclaration->get_name();
            symbolTable->insert(name,symbol);
            // symbolList.push_back(symbol);
            // ROSE_ASSERT(symbolList.empty() == false);
            break;
          }

        case V_SgUsingDirectiveStatement:
        case V_SgPragmaDeclaration:
        case V_SgTemplateInstantiationDirectiveStatement:
        case V_SgUsingDeclarationStatement:
          {
            // DQ (10/22/2005): Not sure if we have to worry about this declaration's appearance in the symbol table!
#if 0
            printf ("This declaration is ignored in rebuilding symbol table %p = %s = %s \n",*i,(*i)->class_name().c_str(),get_name(*i).c_str());
#endif
            break;
          }

        case V_SgAsmStmt:
          {
            // DQ (8/13/2006): This is not really a declaration (I think).  This will be fixed later.
#if 0
            printf ("An ASM statement (SgAsmStmt) declaration is not really a declaration %p = %s = %s \n",*i,(*i)->class_name().c_str(),get_name(*i).c_str());
#endif
            break;
          }

          // Cases where declations are not used or referenced and so symbols are not required!
        case V_SgVariableDefinition:

        case V_SgFunctionParameterList:
        case V_SgCtorInitializerList:

          // These are not referenced so they don't need a symbol!
          {
            printf ("Special cases not handled %p = %s = %s \n",*i,(*i)->class_name().c_str(),get_name(*i).c_str());
            ROSE_ASSERT(false);
            break;
          }

        default:
          {
            printf ("Default reached in rebuildSymbolTable \n");
            ROSE_ASSERT(false);
          }
      }

      ROSE_ASSERT(symbolTable != NULL);
      ROSE_ASSERT(symbolTable->get_table() != NULL);
    }
    // printf ("DONE: Iterating through the declaration in this scope ... %p = %s = %s \n",*i,(*i)->class_name().c_str(),get_name(*i).c_str());

  }

  ROSE_ASSERT(symbolTable != NULL);
  ROSE_ASSERT(symbolTable->get_table() != NULL);

#if 0
  printf ("Symbol Table from %p = %s at: \n",scope,scope->sage_class_name());
  scope->get_file_info()->display("Symbol Table Location");
  symbolTable->print("Called from SageInterface::rebuildSymbolTable()");
#endif
}



std::vector<SgFile*>
SageInterface::generateFileList()
   {
  // This function uses a memory pool traversal specific to the SgFile IR nodes
     class FileTraversal : public ROSE_VisitTraversal
        {
          public:
               vector<SgFile*> fileList;
               void visit ( SgNode* node)
                  {
                    SgFile* file = isSgFile(node);
                    ROSE_ASSERT(file != NULL);
                    if (file != NULL)
                       {
                         fileList.push_back(file);
                       }
                  };

              virtual ~FileTraversal() {}
        };

     FileTraversal fileTraversal;

  // traverse just the SgFile nodes (both the SgSourceFile and SgBinaryFile IR nodes)!
  // SgFile::visitRepresentativeNode(fileTraversal);
     SgSourceFile::visitRepresentativeNode(fileTraversal);
     SgBinaryFile::visitRepresentativeNode(fileTraversal);

  // This would alternatively traverse all IR nodes in thememory pool!
  // fileTraversal.traverseMemoryPool();

     ROSE_ASSERT(fileTraversal.fileList.empty() == false);
     return fileTraversal.fileList;
   }


SgFunctionDeclaration* SageInterface::getDeclarationOfNamedFunction(SgExpression* func) {
  if (isSgFunctionRefExp(func)) {
    return isSgFunctionRefExp(func)->get_symbol()->get_declaration();
  } else if (isSgDotExp(func) || isSgArrowExp(func)) {
    SgExpression* func2 = isSgBinaryOp(func)->get_rhs_operand();
    ROSE_ASSERT (isSgMemberFunctionRefExp(func2));
    return isSgMemberFunctionRefExp(func2)->get_symbol()->get_declaration();
  } else return 0;
}

SgExpression* SageInterface::forallMaskExpression(SgForAllStatement* stmt) {
  SgExprListExp* el = stmt->get_forall_header();
  const SgExpressionPtrList& ls = el->get_expressions();
  if (ls.empty()) return 0;
  if (isSgAssignOp(ls.back())) return 0;
  return ls.back();
}

bool
SageInterface::is_C_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_C_only() == true)
               returnValue = true;
        }

     return returnValue;
   }
bool
SageInterface::is_OpenMP_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_openmp() == true)
               returnValue = true;
        }

     return returnValue;
   }

bool
SageInterface::is_UPC_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_UPC_only() == true)
               returnValue = true;
        }

     return returnValue;
   }

// true if any of upc_threads is set to >0 via command line: -rose:upc_threads n 
bool
SageInterface::is_UPC_dynamic_threads()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_upc_threads() > 0)
               returnValue = true;
        }

     return returnValue;
   }



bool
SageInterface::is_C99_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_C99_only() == true)
               returnValue = true;
        }

     return returnValue;
   }

bool
SageInterface::is_Cxx_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
       // DQ (8/19/2007): Make sure this is not a Fortran code!
       // if (fileList[i]->get_C99_only() == false && fileList[i]->get_C_only() == false)
       // if (fileList[i]->get_Fortran_only() == false && fileList[i]->get_C99_only() == false && fileList[i]->get_C_only() == false && fileList[i]->get_binary_only() == false)
          if (fileList[i]->get_Cxx_only() == true)
             {
            // ROSE_ASSERT(fileList[i]->get_Cxx_only() == true);
               ROSE_ASSERT(fileList[i]->get_Fortran_only() == false && fileList[i]->get_C99_only() == false && fileList[i]->get_C_only() == false && fileList[i]->get_binary_only() == false);

               returnValue = true;
             }
        }

     return returnValue;
   }

bool
SageInterface::is_Fortran_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_Fortran_only() == true)
               returnValue = true;
        }

     return returnValue;
   }


bool
SageInterface::is_binary_executable()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_binary_only() == true)
               returnValue = true;
        }

     return returnValue;
   }

bool
SageInterface::is_PHP_language()
   {
     bool returnValue = false;

     vector<SgFile*> fileList = generateFileList();

     int size = (int)fileList.size();
     for (int i = 0; i < size; i++)
        {
          if (fileList[i]->get_PHP_only() == true)
               returnValue = true;
        }

     return returnValue;
   }

bool SageInterface::is_mixed_C_and_Cxx_language()
   {
     return is_C_language() && is_Cxx_language();
   }

bool SageInterface::is_mixed_Fortran_and_C_language()
   {
     return is_Fortran_language() && is_C_language();
   }

bool SageInterface::is_mixed_Fortran_and_Cxx_language()
   {
     return is_Fortran_language() && is_Cxx_language();
   }

bool SageInterface::is_mixed_Fortran_and_C_and_Cxx_language()
   {
     return is_Fortran_language() && is_C_language() && is_Cxx_language();
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
void
SageInterface::clearScopeNumbers( SgFunctionDefinition* functionDefinition )
   {
     ROSE_ASSERT(functionDefinition != NULL);
     std::map<SgNode*,int> & scopeMap = functionDefinition->get_scope_number_list();

  // Clear the cache of stored (scope,integer) pairs
     scopeMap.erase(scopeMap.begin(),scopeMap.end());

     ROSE_ASSERT(scopeMap.empty() == true);
     ROSE_ASSERT(functionDefinition->get_scope_number_list().empty() == true);
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
void
SageInterface::resetScopeNumbers( SgFunctionDefinition* functionDefinition )
   {
     ROSE_ASSERT(functionDefinition != NULL);
  // std::map<SgNode*,int> & scopeMap = functionDefinition->get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);
     ROSE_ASSERT(functionDefinition->get_scope_number_list().empty() == true);

  // Preorder traversal to uniquely label the scopes (SgScopeStatements)
     class ScopeNumberingTraversal : public AstSimpleProcessing
        {
          public:
               ScopeNumberingTraversal() : count (0), storedFunctionDefinition(NULL) {}
               void visit (SgNode* node)
                  {
                    SgScopeStatement* scope = isSgScopeStatement (node);
                    if (scope != NULL)
                       {
                      // Set the function definition
                         SgFunctionDefinition* testFunctionDefinition = isSgFunctionDefinition(scope);
                         if (testFunctionDefinition != NULL && storedFunctionDefinition == NULL)
                            {
                              ROSE_ASSERT(storedFunctionDefinition == NULL);
                              storedFunctionDefinition = testFunctionDefinition;
                            }

                      // This should now be set (since the root of each traversal is a SgFunctionDefinition).
                         ROSE_ASSERT(storedFunctionDefinition != NULL);

                         count++;

                         std::map<SgNode*,int> & scopeMap = storedFunctionDefinition->get_scope_number_list();
                         scopeMap.insert(pair<SgNode*,int>(scope,count));
#if 0
                         string functionName = storedFunctionDefinition->get_declaration()->get_name().str();
                         printf ("In function = %s insert scope = %p = %s with count = %d into local map (size = %d) \n",
                              functionName.c_str(),scope,scope->class_name().c_str(),count,scopeMap.size());
#endif
                       }
                  }

          private:
               int count; // running total of scopes found in the input function
               SgFunctionDefinition* storedFunctionDefinition;
        };

    // Now buid the traveral object and call the traversal (preorder) on the function definition.
       ScopeNumberingTraversal traversal;
       traversal.traverse(functionDefinition, preorder);
   }


#if 0
// DQ (6/26/2007): These are removed and the support is added to SgNode to support a single mangled name cache.
// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
void
SageInterface::clearMangledNameCache( SgGlobal* globalScope )
   {
     ROSE_ASSERT(globalScope != NULL);
     std::map<SgNode*,std::string> & mangledNameCache = globalScope->get_mangledNameCache();

  // Clear the cache of stored (scope,integer) pairs
     mangledNameCache.erase(mangledNameCache.begin(),mangledNameCache.end());

     ROSE_ASSERT(mangledNameCache.empty() == true);
     ROSE_ASSERT(globalScope->get_mangledNameCache().empty() == true);
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique 
// labels for scopes in a function (as required for name mangling).
void
SageInterface::resetMangledNameCache( SgGlobal* globalScope )
   {
     ROSE_ASSERT(globalScope != NULL);
     ROSE_ASSERT(globalScope->get_mangledNameCache().empty() == true);

  // Preorder traversal to uniquely label the scopes (SgScopeStatements)
     class MangledNameTraversal : public AstSimpleProcessing
        {
          public:
               MangledNameTraversal() : storedGlobalScope(NULL) {}
               void visit (SgNode* node)
                  {
                    SgFunctionDeclaration* mangleableNode = isSgFunctionDeclaration(node);
                    if ( (mangleableNode != NULL) || (isSgGlobal(node) != NULL) )
                       {
                      // Set the global scope
                         SgGlobal* testGlobalScope = isSgGlobal(mangleableNode);
                         if (testGlobalScope != NULL && storedGlobalScope == NULL)
                            {
                              ROSE_ASSERT(storedGlobalScope == NULL);
                              storedGlobalScope = testGlobalScope;
                            }

                      // This should now be set (since the root of each traversal is a SgFunctionDefinition).
                         ROSE_ASSERT(storedGlobalScope != NULL);

                         string mangledName = mangleableNode->get_mangled_name();
                      // printf ("mangledName = %s \n",mangledName.c_str());

                         std::map<SgNode*,std::string> & mangledNameCache = storedGlobalScope->get_mangledNameCache();
                         mangledNameCache.insert(pair<SgNode*,std::string>(mangleableNode,mangledName));
#if 0
                         string nodeName = get_name(mangleableNode);
                         printf ("At node = %p = %s = %s in local map (size = %d) \n",
                              mangleableNode,mangleableNode->class_name().c_str(),nodeName.c_str(),mangledNameCache.size());
#endif
                       }
                  }

          private:
               SgGlobal* storedGlobalScope;
        };

    // Now buid the traveral object and call the traversal (preorder) on the function definition.
       MangledNameTraversal traversal;
       traversal.traverse(globalScope, preorder);
   }
#endif


string
SageInterface::getMangledNameFromCache( SgNode* astNode )
   {
  // The TransformationSupport is not defined yet (I forget the 
  // details but I recall that there is a reason why this is this way).
  // SgGlobal* globalScope = TransformationSupport::getGlobalScope(astNode);
#if 0
     SgGlobal* globalScope = isSgGlobal(astNode);

     if (globalScope == NULL && isSgFile(astNode) != NULL)
        {
          globalScope = isSgFile(astNode)->get_globalScope();
          ROSE_ASSERT(globalScope != NULL);
        }

     if (globalScope == NULL && isSgProject(astNode) != NULL)
        {
       // Check to make sure that the SgFile can be uniquely determined
          ROSE_ASSERT( isSgProject(astNode)->get_fileList()->size() == 1 );
          globalScope = isSgProject(astNode)->get_fileList()->operator[](0)->get_globalScope();
          ROSE_ASSERT(globalScope != NULL);
        }

     SgNode* temp = astNode;
     while (temp->get_parent() != NULL && globalScope == NULL)
        {
          temp = temp->get_parent();
          globalScope = isSgGlobal(temp);
        }
     ROSE_ASSERT(globalScope != NULL);
#endif
     
  // std::map<SgNode*,std::string> & mangledNameCache = globalScope->get_mangledNameCache();
     std::map<SgNode*,std::string> & mangledNameCache = SgNode::get_globalMangledNameMap();

  // Build an iterator
     std::map<SgNode*,std::string>::iterator i = mangledNameCache.find(astNode);

     string mangledName;
     if (i != mangledNameCache.end())
        {
       // get the precomputed mangled name!
       // printf ("Mangled name IS found in cache (node = %p = %s) \n",astNode,astNode->class_name().c_str());
          mangledName = i->second;
        }
       else
        {
       // mangled name not found in cache!
       // printf ("Mangled name NOT found in cache (node = %p = %s) \n",astNode,astNode->class_name().c_str());
        }

     return mangledName;
   }

std::string
SageInterface::addMangledNameToCache( SgNode* astNode, const std::string & oldMangledName)
   {
#if 0
     SgGlobal* globalScope = isSgGlobal(astNode);

     if (globalScope == NULL && isSgFile(astNode) != NULL)
        {
          globalScope = isSgFile(astNode)->get_globalScope();
          ROSE_ASSERT(globalScope != NULL);
        }

     if (globalScope == NULL && isSgProject(astNode) != NULL)
        {
       // Check to make sure that the SgFile can be uniquely determined
          ROSE_ASSERT( isSgProject(astNode)->get_fileList()->size() == 1 );
          globalScope = isSgProject(astNode)->get_fileList()->operator[](0)->get_globalScope();
          ROSE_ASSERT(globalScope != NULL);
        }

     SgNode* temp = astNode;
     while (temp->get_parent() != NULL && globalScope == NULL)
        {
          temp = temp->get_parent();
          globalScope = isSgGlobal(temp);
        }
     ROSE_ASSERT(globalScope != NULL);
#endif
     
  // std::map<SgNode*,std::string> & mangledNameCache = globalScope->get_mangledNameCache();
  // std::map<std::string, int> & shortMangledNameCache = globalScope->get_shortMangledNameCache();
     std::map<SgNode*,std::string> & mangledNameCache   = SgNode::get_globalMangledNameMap();
     std::map<std::string, int> & shortMangledNameCache = SgNode::get_shortMangledNameCache();

     std::string mangledName;

#define USE_SHORT_MANGLED_NAMES 1
#if USE_SHORT_MANGLED_NAMES
  // This bound was 40 previously!
     if (oldMangledName.size() > 40) {
       std::map<std::string, int>::const_iterator shortMNIter = shortMangledNameCache.find(oldMangledName);
       int idNumber = (int)shortMangledNameCache.size();
       if (shortMNIter != shortMangledNameCache.end()) {
         idNumber = shortMNIter->second;
       } else {
         shortMangledNameCache.insert(std::pair<std::string, int>(oldMangledName, idNumber));
       }

       std::ostringstream mn;
       mn << 'L' << idNumber << 'R';
       mangledName = mn.str();
     } else {
       mangledName = oldMangledName;
     }
#else
     mangledName = oldMangledName;
#endif

  // DQ (6/26/2007): Output information useful for understanding Jeremiah's shortended name merge caching.
  // std::cerr << "Changed MN " << oldMangledName << " to " << mangledName << std::endl;

  // printf ("Updating mangled name cache for node = %p = %s with mangledName = %s \n",astNode,astNode->class_name().c_str(),mangledName.c_str());
     mangledNameCache.insert(pair<SgNode*,string>(astNode,mangledName));
     return mangledName;
   }


bool
SageInterface::declarationPreceedsDefinition ( SgDeclarationStatement* nonDefiningDeclaration, SgDeclarationStatement* definingDeclaration )
   {
  // This function is used in the unparser, but might be more generally useful.  Since it is
  // related to general AST tests, I have put it here.  It might be alternatively put in the
  // src/backend/unparser or related utility directory.

  // Preorder traversal to test the order of declaration of non-defining vs. defining class 
  // declarations in the preorder traversal of the AST.
     class DeclarationOrderTraversal : public AstSimpleProcessing
        {
          public:
               DeclarationOrderTraversal( SgDeclarationStatement* nonDefiningDeclaration, SgDeclarationStatement* definingDeclaration )
                  : storedNondefiningDeclaration(nonDefiningDeclaration),
                    storedDefiningDeclaration(definingDeclaration)
                  {
                    storedDeclarationFound                            = false;
                    nonDefiningDeclarationPreceedsDefiningDeclaration = false;
                  }

               void visit (SgNode* node)
                  {
                    ROSE_ASSERT(storedNondefiningDeclaration != NULL);
                    ROSE_ASSERT(storedDefiningDeclaration != NULL);
                    ROSE_ASSERT(storedNondefiningDeclaration != storedDefiningDeclaration);
                 // ROSE_ASSERT(storedNondefiningDeclaration->get_definingDeclaration() == storedDefiningDeclaration);

                 // Even though we only care about the SgClassDeclaration IR nodes we have to traverse them 
                 // in the AST in the order defined by the traversal (order of apprearance in the AST).  We 
                 // also can't just search the declarations of a single scope (since the nondefining declaration 
                 // can appear in a different scope than the defining declaration).
                    SgDeclarationStatement* declaration = isSgDeclarationStatement(node);
                    if ( declaration != NULL )
                       {
                      // if (classDeclaration == storedNondefiningDeclaration && neitherStoredDeclarationFound == true)
                         if (storedDeclarationFound == false)
                            {
                              if (declaration == storedDefiningDeclaration)
                                 {
                                   storedDeclarationFound = true;
                                   nonDefiningDeclarationPreceedsDefiningDeclaration = false;
                                 }
                              if (declaration == storedNondefiningDeclaration)
                                 {
                                   storedDeclarationFound = true;
                                   nonDefiningDeclarationPreceedsDefiningDeclaration = true;                                   
                                 }
                            }
                       }
                  }

          public:
               bool storedDeclarationFound;
               bool nonDefiningDeclarationPreceedsDefiningDeclaration;

          private:
               SgDeclarationStatement* storedNondefiningDeclaration;
               SgDeclarationStatement* storedDefiningDeclaration;
        };

     ROSE_ASSERT(nonDefiningDeclaration != NULL);
#if 0
     printf ("In SageInterface::declarationPreceedsDefinition(): \n");
     printf ("     nondefiningDeclaration                            = %p = %s \n",nonDefiningDeclaration,nonDefiningDeclaration->class_name().c_str());
     nonDefiningDeclaration->get_file_info()->display("nonDefiningDeclaration");
     printf ("     nondefiningDeclaration->get_definingDeclaration() = %p \n",nonDefiningDeclaration->get_definingDeclaration());
     printf ("     definingDeclaration                               = %p = %s \n",definingDeclaration,definingDeclaration->class_name().c_str());
     definingDeclaration->get_file_info()->display("definingDeclaration");
     printf ("************************************************************* \n");
#endif

#if 0
  // The nonDefiningDeclaration can be a different type of declaration than the definingDeclaration
     if (nonDefiningDeclaration->get_definingDeclaration() != definingDeclaration)
        {
          printf ("In SageInterface::declarationPreceedsDefinition() (warning): \n");
          printf ("     nondefiningDeclaration                            = %p \n",nonDefiningDeclaration);
          printf ("     nondefiningDeclaration->get_definingDeclaration() = %p \n",nonDefiningDeclaration->get_definingDeclaration());
          printf ("     definingDeclaration                               = %p \n",definingDeclaration);
        }
#endif

  // define trival case of classNonDefiningDeclaration == classDefiningDeclaration to be false.
     bool returnResult = false;
     if (nonDefiningDeclaration != definingDeclaration)
        {
       // Get the global scope from a traversal back (up) through the AST.
          SgGlobal* globalScope = TransformationSupport::getGlobalScope(definingDeclaration);
          ROSE_ASSERT(globalScope != NULL);

       // Now buid the traveral object and call the traversal (preorder) on the function definition.
          DeclarationOrderTraversal traversal (nonDefiningDeclaration,definingDeclaration);

#if 0
          traversal.traverse(globalScope, preorder);
#else
       // DQ (5/29/2007): To avoid order n^2 complexity in unparsing we turn off the name qualification for now.
          printf ("Skipping traversal within SageInterface::declarationPreceedsDefinition() \n");
          traversal.storedDeclarationFound = true;
          traversal.nonDefiningDeclarationPreceedsDefiningDeclaration = false;
#endif

       // I hope that we have found the input nondefining or defining declaration, if not let it be an error 
       // for now.  There may however be good reasons why we might miss them (hidden island problem, or 
       // nondefining declarations that are not in the traversal).

          if (traversal.storedDeclarationFound == false)
             {
#if 0
               printf ("In SageInterface::declarationPreceedsDefinition(): warning, nonDefiningDeclaration not found in the AST \n");
               nonDefiningDeclaration->get_file_info()->display("nonDefiningDeclaration");
               definingDeclaration->get_file_info()->display("definingDeclaration");
               printf ("---------------------------------------------------- \n\n");
#endif
            // Set this error case to return true so that we will not assume incorrectly 
            // that the classNonDefiningDeclaration apears after the classDefiningDeclaration.
               returnResult = true;
             }
            else
             {
               returnResult = traversal.nonDefiningDeclarationPreceedsDefiningDeclaration;
             }

       // ROSE_ASSERT(traversal.storedDeclarationFound == true);
        }
#if 0
     printf ("returnResult = %s \n",returnResult ? "true" : "false");
     printf ("************************************************************* \n\n");
#endif
     return returnResult;
   }


bool
SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope ( SgFunctionCallExp* functionCall )
   {
  // This function is used in the unparser, but might be more generally useful.  Since it is
  // related to general AST tests, I have put it here.  It might be alternatively put in the
  // src/backend/unparser or related utility directory.

  // Preorder traversal to test the order of declaration of non-defining vs. defining class 
  // declarations in the preorder traversal of the AST.
     class DeclarationOrderTraversal : public AstSimpleProcessing
        {
          public:
               DeclarationOrderTraversal( SgFunctionCallExp* functionCall )
                  : storedFunctionCall(functionCall)
                  {
                    ROSE_ASSERT(functionCall != NULL);
                    ROSE_ASSERT(functionCall->get_function() != NULL);
                    SgExpression* functionExpression = functionCall->get_function();

                    switch (functionExpression->variantT())
                       {
                      // these are the acceptable cases
                         case V_SgDotExp:
                         case V_SgDotStarOp:
                         case V_SgArrowExp:
                         case V_SgArrowStarOp:
                         case V_SgPointerDerefExp:
                            {
                           // These are the acceptable cases, but not handled yet.
                              printf ("These are the acceptable cases, but not handled yet... \n");
                              ROSE_ASSERT(false);
                              break;
                            }

                         case V_SgFunctionRefExp:
                            {
                              SgFunctionRefExp* functionRefExp = isSgFunctionRefExp(functionExpression);
                              ROSE_ASSERT(functionRefExp != NULL);
                              SgFunctionSymbol* functionSymbol = functionRefExp->get_symbol();
                              ROSE_ASSERT(functionSymbol != NULL);

                           // Make sure that the function has a valid declaration
                              ROSE_ASSERT(functionSymbol->get_declaration() != NULL);
                              storedFunctionDeclaration = functionSymbol->get_declaration();
                              break;
                            }

                         case V_SgMemberFunctionRefExp:
                            {
                              SgMemberFunctionRefExp* memberFunctionRefExp = isSgMemberFunctionRefExp(functionExpression);
                              ROSE_ASSERT(memberFunctionRefExp != NULL);
                              SgMemberFunctionSymbol* memberFunctionSymbol = memberFunctionRefExp->get_symbol();
                              ROSE_ASSERT(memberFunctionSymbol != NULL);

                              storedFunctionDeclaration = memberFunctionSymbol->get_declaration();

                              printf ("V_SgMemberFunctionRefExp case not handled yet... \n");
                              ROSE_ASSERT(false);
                            }

                         default:
                            {
                              printf ("default reached in SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() functionExpression = %s \n",
                                   functionExpression->class_name().c_str());
                              ROSE_ASSERT(false);
                            }
                       }
                 // ROSE_ASSERT(functionCall->get_declaration() != NULL);
                 // ROSE_ASSERT(functionCall->get_function()->get_firstNondefiningDeclaration() != NULL);
                 // storedFunctionDeclaration = functionCall->get_declaration()->get_firstNondefiningDeclaration();
                    ROSE_ASSERT(storedFunctionDeclaration != NULL);

                    storedFunctionCallFound                                       = false;
                    functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;
                  }

               void visit (SgNode* node)
                  {
                    ROSE_ASSERT(storedFunctionCall != NULL);
                    ROSE_ASSERT(storedFunctionDeclaration != NULL);
                 // ROSE_ASSERT(storedFunctionCall != storedFunctionDeclaration);

                    if (storedFunctionCallFound == false)
                       {
                         SgFunctionCallExp* functionCall = isSgFunctionCallExp(node);
                         if ( functionCall != NULL )
                            {
                              if (functionCall == storedFunctionCall)
                                 {
                                   storedFunctionCallFound = true;

                                // A declaration for the function in a scope where the function could be defined 
                                // (and a scope associated with it) has not been found so the function call 
                                // preceeds such a declaration (if it even exists).
                                   functionCallExpressionPreceedsDeclarationWhichAssociatesScope = true;
                                 }
                            }

                         SgDeclarationStatement* declaration = isSgDeclarationStatement(node);
                         ROSE_ASSERT(storedFunctionDeclaration != NULL);

                      // Note that all firstNondefiningDeclaration are set to the same declaration (for all associated declarations).
                      // Need to check the result of get_firstNondefiningDeclaration() since this will be the same for all declarations 
                      // of the same function and thus can be used to match that we have an associated declaration for the same function.
                      // if ( declaration != NULL && declaration->get_firstNondefiningDeclaration() == storedFunctionDeclaration)
                         if ( declaration != NULL && declaration->get_firstNondefiningDeclaration() == storedFunctionDeclaration->get_firstNondefiningDeclaration())
                            {
                           // Test if this is a declaration is a scope where the existance of the forward 
                           // declaration will define the scope fo the function declaration.
                           // if (declaration->get_scope()->supportsDefiningFunctionDeclaration() == true)
                              SgScopeStatement* parentScopeOfDeclaration = isSgScopeStatement(declaration->get_parent());
                              if (parentScopeOfDeclaration != NULL && parentScopeOfDeclaration->supportsDefiningFunctionDeclaration() == true)
                                 {
                                // We are done so we can skip further testing
                                   storedFunctionCallFound = true;

                                // We have found a declaration which will associated the scope of a function declaration 
                                // (so all function calls after this point can be qualified (and might have to be).
                                   functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;
#if 0
                                   printf ("Found a declaration which preceeds the function \n");
                                   declaration->get_file_info()->display("Found a declaration which preceeds the function: declaration");
                                   storedFunctionCall->get_file_info()->display("Found a declaration which preceeds the function: storedFunctionCall");
                                   storedFunctionDeclaration->get_file_info()->display("Found a declaration which preceeds the function: storedFunctionDeclaration");
#endif
                                 }
                                else
                                 {
                                // Error checking!
                                   if (parentScopeOfDeclaration == NULL)
                                      {
                                     // This might be a function declaration (non-defining) used in a type or buried deeply in some sort of declaration!
                                        printf ("Strange case of parentScopeOfDeclaration == NULL in SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() \n");
                                        printf ("declaration->get_parent() = %s \n",declaration->get_parent()->class_name().c_str());
                                        declaration->get_file_info()->display("case of parentScopeOfDeclaration == NULL");
                                        ROSE_ASSERT(false);
                                      }
                                 }
                            }
                       }
                  }

          public:
               bool storedFunctionCallFound;
               bool functionCallExpressionPreceedsDeclarationWhichAssociatesScope;

          private:
               SgFunctionCallExp* storedFunctionCall;
               SgDeclarationStatement* storedFunctionDeclaration;
        };

     ROSE_ASSERT(functionCall != NULL);
#if 0
     printf ("In SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope(): \n");
     printf ("     storedFunctionCall                           = %p = %s \n",functionCall,functionCall->class_name().c_str());
     functionCall->get_file_info()->display("storedFunctionCall");
     printf ("     storedFunctionCall->get_function() = %p = %s \n",functionCall->get_function(),functionCall->get_function()->class_name().c_str());
     printf ("************************************************************* \n");
#endif

  // define trival case of classNonDefiningDeclaration == classDefiningDeclaration to be false.
     bool returnResult = false;

  // Get the global scope from a traversal back (up) through the AST.
     SgGlobal* globalScope = TransformationSupport::getGlobalScope(functionCall);
     ROSE_ASSERT(globalScope != NULL);

  // Now buid the traveral object and call the traversal (preorder) on the function definition.
     DeclarationOrderTraversal traversal (functionCall);

#if 0
     traversal.traverse(globalScope, preorder);
#else
  // DQ (5/29/2007): To avoid order n^2 complexity in unparsing we turn off the name qualification for now.
     printf ("Skipping traversal within SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope() \n");
     traversal.storedFunctionCallFound = true;
     traversal.functionCallExpressionPreceedsDeclarationWhichAssociatesScope = false;
#endif

  // I hope that we have found the input nondefining or defining declaration, if not let it be an error 
  // for now.  There may however be good reasons why we might miss them (hidden island problem, or 
  // nondefining declarations that are not in the traversal).

     if (traversal.storedFunctionCallFound == false)
        {
#if 0
          printf ("In SageInterface::functionCallExpressionPreceedsDeclarationWhichAssociatesScope(): warning, storedFunctionCall not found in the AST \n");
          functionCall->get_file_info()->display("functionCall");
          printf ("---------------------------------------------------- \n\n");
#endif
       // Set this error case to return true so that we will not assume incorrectly 
       // that the function call is used after a declaration that associated the scope 
       // with the function.  This still causes the global name qualifier to be omitted.
          returnResult = true;
        }
       else
        {
          returnResult = traversal.functionCallExpressionPreceedsDeclarationWhichAssociatesScope;
        }

  // I hope that this is nearly always be true!
     ROSE_ASSERT(traversal.storedFunctionCallFound == true);
#if 0
     printf ("returnResult = %s \n",returnResult ? "true" : "false");
     printf ("************************************************************* \n\n");
#endif
     return returnResult;
   }


string
SageInterface::generateProjectName( const SgProject* project, bool supressSuffix )
   {
  // This function generates a string to use as a unique project name for
  // a collection of files.  The last file will include it's suffix so that
  // we generate proper names that cummunicate the source language.
  // Also also allows the single file case to be consistant with the previous
  // version of names generated for "DOT" files in the tutorial.

  // DQ (9/6/2008): Introduced optional parameter to supresse the suffix in the 
  // generation of the project name so that we can support more complex name 
  // construction as required for the generation of names for the whole AST 
  // graphs which append an additional suffix to avoid filename collision.

     ROSE_ASSERT(project != NULL);
     string projectName;

  // DQ (9/2/2008): Removed the redundant function getFileNames().
  // Rose_STL_Container<string> fileList = project->get_sourceFileNameList();
     Rose_STL_Container<string> fileList = project->getAbsolutePathFileNames();

     Rose_STL_Container<string>::iterator i = fileList.begin();

  // Handle the case of an empty list (e.g. for link lines).
     if ( fileList.empty() == true ) 
        {
          return "empty_file_list";
        }

     do {
          string filename = *i;

       // printf ("In SageInterface::generateProjectName(): absolute filename = %s \n",filename.c_str());

       // string filenameWithoutSuffix       = StringUtility::stripFileSuffixFromFileName(filename);

          if (i != fileList.begin())
               projectName += "--";

          i++;

          string filenameWithoutSuffix;
          if ( i != fileList.end() || supressSuffix == true )
               filenameWithoutSuffix = StringUtility::stripFileSuffixFromFileName(filename);
            else
               filenameWithoutSuffix = filename;

          string filenameWithoutPathOrSuffix = StringUtility::stripPathFromFileName(filenameWithoutSuffix);

       // printf ("filenameWithoutSuffix       = %s \n",filenameWithoutSuffix.c_str());
       // printf ("filenameWithoutPathOrSuffix = %s \n",filenameWithoutPathOrSuffix.c_str());

          filename = filenameWithoutPathOrSuffix;

          unsigned long int n = 0;
          while (n < filename.size())
             {
               if (filename[n] == '/')
                    filename[n] = '_';
               n++;
             }

       // printf ("In SageInterface:generateProjectName(): modified absolute filename = %s \n",filename.c_str());

          projectName += filename;

       // printf ("In SageInterface:generateProjectName(): evolving projectName = %s \n",projectName.c_str());
        }
     while (i != fileList.end());

  // printf ("In SageInterface:generateProjectName(): projectName = %s \n",projectName.c_str());

     return projectName;
   }

SgFunctionSymbol*
SageInterface::lookupFunctionSymbolInParentScopes(const SgName & functionName, SgScopeStatement* currentScope )
   {
  // DQ (11/24/2007): This function can return NULL.  It returns NULL when the function symbol is not found.
  // This can happen when a function is referenced before it it defined (no prototype mechanism in Fortran is required).

  // enable default search from top of StackScope, Liao, 1/24/2008
     SgFunctionSymbol* functionSymbol = NULL;
     if (currentScope == NULL)
          currentScope = SageBuilder::topScopeStack();
     ROSE_ASSERT(currentScope != NULL);

     SgScopeStatement* tempScope = currentScope;
     while ((functionSymbol == NULL) && (tempScope != NULL))
        {
          functionSymbol = tempScope->lookup_function_symbol(functionName);

          if (tempScope->get_parent()!=NULL) // avoid calling get_scope when parent is not set in middle of translation
               tempScope = isSgGlobal(tempScope) ? NULL : tempScope->get_scope();
            else
               tempScope = NULL;
        }
     return functionSymbol;
   }


void
SageInterface::addTextForUnparser ( SgNode* astNode, string s, AstUnparseAttribute::RelativePositionType inputlocation )
   {
     printf ("addText(): using new attribute interface (s = %s) \n",s.c_str());

     if (isSgType(astNode) != NULL)
        {
          printf ("Error: the mechanism to add text to be unparsed at IR nodes is not intended to operate on SgType IR nodes (since they are shared) \n");
          ROSE_ASSERT(false);
        }

     if (astNode->attributeExists(AstUnparseAttribute::markerName) == true)
        {
          AstUnparseAttribute* code = dynamic_cast<AstUnparseAttribute*>(astNode->getAttribute(AstUnparseAttribute::markerName));
          ROSE_ASSERT(code != NULL);

          code->addString(s,inputlocation);
        }
       else
        {
          AstUnparseAttribute* code = new AstUnparseAttribute(s,AstUnparseAttribute::e_before);
          ROSE_ASSERT(code != NULL);
          astNode->addNewAttribute(AstUnparseAttribute::markerName,code);
        }
   }






SgType* SageInterface::lookupNamedTypeInParentScopes(const std::string& type_name, SgScopeStatement* scope/*=NULL*/)
{
  if (scope== NULL)
          scope= SageBuilder::topScopeStack();
  SgSymbol* symbol = lookupSymbolInParentScopes (type_name,scope);
  if (symbol==NULL) return NULL;
  else return symbol->get_type();
}

SgFunctionSymbol *SageInterface::lookupFunctionSymbolInParentScopes (const SgName &functionName,
                                                        const SgType* t,
                                                        SgScopeStatement *currentScope)
                                                        //SgScopeStatement *currentScope=NULL)
{
     SgFunctionSymbol* functionSymbol = NULL;
  if (currentScope == NULL)
    currentScope = SageBuilder::topScopeStack();   
   ROSE_ASSERT(currentScope != NULL);
      SgScopeStatement* tempScope = currentScope;
     while (functionSymbol == NULL && tempScope != NULL)
        {

          functionSymbol = tempScope->lookup_function_symbol(functionName,t);
        if (tempScope->get_parent()!=NULL) // avoid calling get_scope when parent is not set
           tempScope = isSgGlobal(tempScope) ? NULL : tempScope->get_scope();
         else tempScope = NULL;
   }
     return functionSymbol;
}

// Liao, 1/22/2008
// SgScopeStatement* SgStatement::get_scope
// SgScopeStatement* SgStatement::get_scope() assumes all parent pointers are set, which is
// not always true during translation. 
SgSymbol *SageInterface:: lookupSymbolInParentScopes (const SgName &  name,
                                                        SgScopeStatement *cscope)
{
  SgSymbol* symbol = NULL;
 if (cscope == NULL)
    cscope = SageBuilder::topScopeStack(); 
  ROSE_ASSERT(cscope);

  while ((cscope!=NULL)&&(symbol==NULL))
  {
    symbol = cscope->lookup_symbol(name);
    //debug
   // cscope->print_symboltable("debug sageInterface.C L3749...");
   if (cscope->get_parent()!=NULL) // avoid calling get_scope when parent is not set
    cscope = isSgGlobal(cscope) ? NULL : cscope->get_scope();
    else 
      cscope = NULL;
  }

  if (symbol==NULL)
  {
//    printf ("Warning: could not locate the specified name %s in any outer symbol table \n"e,
//	name.str());
  //  ROSE_ASSERT(false); 
  }
  return symbol;
}

SgVariableSymbol * 
SageInterface::lookupVariableSymbolInParentScopes (const SgName &  name,
                                                        SgScopeStatement *cscope)
{
  SgVariableSymbol* result = NULL; 
  SgSymbol* symbol=lookupSymbolInParentScopes(name,cscope);
  if (symbol!=NULL) 
    result = isSgVariableSymbol(symbol);
  return result;  
}

void
SageInterface::setSourcePosition( SgLocatedNode* locatedNode )
   {
  // DQ (1/24/2009): It might be thst this function is only called from the Fortran support.

  // This function sets the source position to be marked as not 
  // available (since we often don't have token information)
  // These nodes WILL be unparsed in the conde generation phase.

  // The SgLocatedNode has both a startOfConstruct and endOfConstruct source position.
     ROSE_ASSERT(locatedNode != NULL);

  // Check the endOfConstruct forst since it is most likely NULL (helpful in debugging)
     ROSE_ASSERT(locatedNode->get_endOfConstruct()   == NULL);
     ROSE_ASSERT(locatedNode->get_startOfConstruct() == NULL);

     Sg_File_Info* start_fileInfo = Sg_File_Info::generateDefaultFileInfo();
     Sg_File_Info* end_fileInfo   = Sg_File_Info::generateDefaultFileInfo();

     start_fileInfo->setSourcePositionUnavailableInFrontend();
     end_fileInfo->setSourcePositionUnavailableInFrontend();

  // This is required for the unparser to output the code from the AST.
     start_fileInfo->setOutputInCodeGeneration();
     end_fileInfo->setOutputInCodeGeneration();

     locatedNode->set_startOfConstruct(start_fileInfo);
     locatedNode->set_endOfConstruct  (end_fileInfo);

     locatedNode->get_startOfConstruct()->set_parent(locatedNode);
     locatedNode->get_endOfConstruct  ()->set_parent(locatedNode);
   }

void
SageInterface::setOneSourcePositionForTransformation(SgNode *node)
   {
  // DQ (1/24/2009): I think this should be renamed to be "setSourcePositionAsTransformation(SgNode *node)"
  // The logic should be make more independent of if (locatedNode->get_startOfConstruct() == NULL)
  // Since that make understanding where the function is applied too complex.  
  // If (locatedNode->get_startOfConstruct() != NULL), then we should just make that Sg_File_Info as 
  // a transforamtion directly, this function misses that step.

     ROSE_ASSERT(node != NULL);

     SgLocatedNode*     locatedNode = isSgLocatedNode(node);
     SgExpression*      expression  = isSgExpression(node);
     SgInitializedName* initName    = isSgInitializedName(node);
     SgPragma*          pragma      = isSgPragma(node); // missed this one!! Liao, 1/30/2008
     SgGlobal*          global      = isSgGlobal(node); // SgGlobal should have NULL endOfConstruct()

  // if ((locatedNode) && (locatedNode->get_endOfConstruct() == NULL))
     if ( (locatedNode != NULL) && (locatedNode->get_startOfConstruct() == NULL) )
        {
          locatedNode->set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());
          locatedNode->get_startOfConstruct()->set_parent(locatedNode);

          if (global==NULL)
             {  
               locatedNode->set_endOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());
               locatedNode->get_endOfConstruct  ()->set_parent(locatedNode); 
             }

       // Only SgExpression IR nodes have a 3rd source position data structure.
          if (expression!=NULL)
             {
               expression->set_operatorPosition(Sg_File_Info::generateDefaultFileInfoForTransformationNode());
               expression->get_operatorPosition()->set_parent(expression);
             }
        }
       else
        {
          if ( (initName != NULL) && (initName->get_startOfConstruct() == NULL) )
             {
           //  no endOfConstruct for SgInitializedName
               initName->set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());   
               initName->get_startOfConstruct()->set_parent(initName);
             }
            else 
             {
               if ( (pragma != NULL) && (pragma->get_startOfConstruct() == NULL) )
                  {
                    pragma->set_startOfConstruct(Sg_File_Info::generateDefaultFileInfoForTransformationNode());
                    pragma->get_startOfConstruct()->set_parent(pragma);
                  }
             }
        }
   }


void
SageInterface::setOneSourcePositionNull(SgNode *node)
   {
  // DQ (1/24/2009): I think this should be renamed to be "setSourcePositionToNULL(SgNode *node)"
  // However, if this is doen then the logic should be that it asserts that: (locatedNode->get_startOfConstruct() == NULL)
  // so that we know when we are leaking memory.  Similarly, we should assert that:
  // (locatedNode->get_endOfConstruct() == NULL).
  // But then this function just asserts that everything is already NULL and is less about setting them to NULL.
  // If (locatedNode->get_startOfConstruct() != NULL), should we delete the existing Sg_File_Info object?
  // This function misses that step.

     ROSE_ASSERT(node != NULL);

     SgLocatedNode *    locatedNode = isSgLocatedNode(node);
     SgExpression*      expression  = isSgExpression(node);
     SgInitializedName* initName    = isSgInitializedName(node);
     SgPragma*          pragma      = isSgPragma(node); // missed this one!! Liao, 1/30/2008
     SgGlobal*          global      = isSgGlobal(node); // SgGlobal should have NULL endOfConstruct()

  // DQ (1/24/2009): If the point is to set the source position to NULL pointers, 
  // why do we only handle the case when (get_startOfConstruct() == NULL) 
  // (i.e. when the start source postion is already NULL).

  // if ((locatedNode) && (locatedNode->get_endOfConstruct() == NULL))
     if ( (locatedNode != NULL) && (locatedNode->get_startOfConstruct() == NULL) )
        {
          locatedNode->set_startOfConstruct(NULL);

       // Note that SgGlobal should have NULL endOfConstruct()
          if (global == NULL)
             {
               locatedNode->set_endOfConstruct(NULL);
             }

       // Only SgExpression IR nodes have a 3rd source position data structure.
          if (expression != NULL)
             {
               expression->set_operatorPosition(NULL);
             }
        }
       else
        {
          if ( (initName != NULL) && (initName->get_startOfConstruct() == NULL) )
             { //  no endOfConstruct for SgInitializedName
               initName->set_startOfConstruct(NULL);   
             }
            else
             {
               if ( (pragma != NULL) && (pragma->get_startOfConstruct() == NULL) )
                  {
                    pragma->set_startOfConstruct(NULL);
                  }
             }
        }
   }


// DQ (1/24/2009): Could we change the name to be "setSourcePositionAtRootAndAllChildrenAsTransformation(SgNode *root)"
void
SageInterface::setSourcePositionForTransformation(SgNode *root)
   {
     Rose_STL_Container <SgNode*> nodeList= NodeQuery::querySubTree(root,V_SgNode);
     for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i!=nodeList.end(); i++ )
        {
          setOneSourcePositionForTransformation(*i);   
        }
   }


void
SageInterface::setSourcePositionForTransformation_memoryPool()
   {
  // DQ (1/24/2009): This seems like a very dangerous function to have, is it required!

     VariantVector vv(V_SgNode);
     Rose_STL_Container<SgNode*> nodeList = NodeQuery::queryMemoryPool(vv);
     for (Rose_STL_Container<SgNode *>::iterator i = nodeList.begin(); i != nodeList.end(); i++ )
        {
          setOneSourcePositionForTransformation(*i);
        }
   }


SgGlobal * SageInterface::getFirstGlobalScope(SgProject *project)
   {
  // Liao, 1/9/2008, get the first global scope from current project
  // mostly used to prepare for AST construction under the global scope
     ROSE_ASSERT(project != NULL);

  // DQ (1/24/2009): Added a check to make sure STL list is non-empty.
     ROSE_ASSERT(project->get_fileList().empty() == false);

  // SgGlobal* global = project->get_file(0).get_root();
     SgSourceFile* file = isSgSourceFile(project->get_fileList()[0]);
     SgGlobal* global = file->get_globalScope();

#if 0
     SgFilePtrListPtr fileList = project->get_fileList();
     SgFilePtrList::const_iterator i= fileList->begin();

     SgGlobal* global = (*i)->get_globalScope();
#endif
     ROSE_ASSERT(global != NULL);

     return global;
   }

// Liao, 1/10/2008, get the last stmt from the scope
// two cases 
//      SgScopeStatement::getDeclarationList
//      SgScopeStatement::getStatementList()
SgStatement* SageInterface::getLastStatement(SgScopeStatement *scope)
{
  ROSE_ASSERT(scope);
  SgStatement* stmt=NULL;

  if (scope->containsOnlyDeclarations())
  {
    SgDeclarationStatementPtrList declList = scope->getDeclarationList();
    if (declList.size()>0) 
       stmt = isSgStatement(declList.back());
  }
  else 
  {
    SgStatementPtrList stmtList = scope->getStatementList();
    if (stmtList.size()>0)
      stmt = stmtList.back();
  }
  return stmt; 
}

SgStatement* SageInterface::getFirstStatement(SgScopeStatement *scope, bool includingCompilerGenerated/*=false*/)
{
  ROSE_ASSERT(scope);
  SgStatement* stmt=NULL;

  if (scope->containsOnlyDeclarations())
    {
   // DQ Note: Do we really need to make a copy of the list just to return a pointer to the first entry?
      SgDeclarationStatementPtrList declList = scope->getDeclarationList();
      if (includingCompilerGenerated)
      {  
       // DQ Note: (declList.empty() == false) is a much faster test  O(1) than (declList.size() > 0), which is O(n).
          if (declList.size()>0)
             stmt = isSgStatement(declList.front());
      } else
      { //skip compiler-generated declarations
        SgDeclarationStatementPtrList::iterator i=declList.begin();
        while (i!=declList.end())
        {  //isCompilerGenerated(),isOutputInCodeGeneration(),etc. are not good enough, 
           //some content from headers included are not marked as compiler-generated
           //
           // cout<<(*i)->unparseToString()<<endl;
           // ((*i)->get_file_info())->display("debug.......");
           Sg_File_Info * fileInfo = (*i)->get_file_info();
          // include transformation-generated  statements, but not the hidden ones
        // Note: isOutputInCodeGeneration is not default to true for original statements from user code
         if ((fileInfo->isSameFile(scope->get_file_info()))||
              (fileInfo->isTransformation()&& fileInfo->isOutputInCodeGeneration())
            )
            {  
              stmt=*i;
              break;
            } else
            {
              i++;
              continue;
            }
        }
      }
    }
  else
  {
 // DQ Note: Do we really need to make a copy of the list just to return a pointer to the first entry?
    SgStatementPtrList stmtList = scope->getStatementList();
   if (includingCompilerGenerated)
    {
   // DQ Note: (stmtList.empty() == false) is a much faster test  O(1) than (stmtList.size() > 0), which is O(n).
      if (stmtList.size()>0)
      stmt = stmtList.front();
    } else
    { //skip compiler-generated declarations
      SgStatementPtrList::iterator i=stmtList.begin();
      while (i!=stmtList.end())
      {  //isCompilerGenerated(),isOutputInCodeGeneration(),etc. are not good enough, 
         //some content from headers included are not marked as compiler-generated
         //
         // cout<<(*i)->unparseToString()<<endl;
         // ((*i)->get_file_info())->display("debug.......");
         Sg_File_Info * fileInfo = (*i)->get_file_info();
        // include transformation-generated  statements, but not the hidden ones
        // Note: isOutputInCodeGeneration is not default to true for original statements from user code
         if ( (fileInfo->isSameFile(scope->get_file_info()))||
              (fileInfo->isTransformation()&& fileInfo->isOutputInCodeGeneration())
            )
          {  
            stmt=*i;
            break;
          } else
          {
            i++;
            continue;
          }
      }
    }

  }
  return stmt; 

}

  SgFunctionDeclaration* SageInterface::findFirstDefiningFunctionDecl(SgScopeStatement* scope)
  {
    ROSE_ASSERT(scope);
    SgFunctionDeclaration* result = NULL;
    if (scope->containsOnlyDeclarations())
    {
      SgDeclarationStatementPtrList declList = scope->getDeclarationList();
      SgDeclarationStatementPtrList::iterator i=declList.begin();
      while (i!=declList.end())
      {
        Sg_File_Info * fileInfo = (*i)->get_file_info();

       if ((fileInfo->isSameFile(scope->get_file_info()))||
          (fileInfo->isTransformation()&& fileInfo->isOutputInCodeGeneration())
        )
        { 
          SgFunctionDeclaration* func = isSgFunctionDeclaration(*i);
          if (func)
          {
            if (func->get_definingDeclaration ()==func)
            {
            //cout<<"debug, first defining func decl is:"<<(*i)->unparseToString()<<endl;
            result=func;
            break;
            }
          } 
        }  
        i++;
      }//end while
    } else
    {
      SgStatementPtrList stmtList = scope->getStatementList();
      SgStatementPtrList::iterator i=stmtList.begin();
      while (i!=stmtList.end())
      {
        Sg_File_Info * fileInfo = (*i)->get_file_info();
        if ( (fileInfo->isSameFile(scope->get_file_info()))||
             (fileInfo->isTransformation()&& fileInfo->isOutputInCodeGeneration())
            )
         {  
          SgFunctionDeclaration* func = isSgFunctionDeclaration(*i);
          if (func)
          {
            if (func->get_definingDeclaration ()==func)
            {
            //cout<<"debug, first defining func decl is:"<<(*i)->unparseToString()<<endl;
            result=func;
            break;
            }// if defining
          } // if func 
         }// if fileInof
        i++;
      }//while
    } // end if
    return result;
  }


bool SageInterface::isMain(const SgNode* n)
{
 bool result = false;
 if (isSgFunctionDeclaration(n) &&
     isSgGlobal(isSgStatement(n)->get_scope())&&
     isSgFunctionDeclaration(n)->get_name() == "main") 
   result = true;

   return result;
}

// Originally from ompTranslator.C
// DQ (1/6/2007): The correct qualified name for "main" is "::main", at least in C++.
// however for C is should be "main".  Our name qualification is not language specific,
// however, for C is makes no sense to as for the qualified name, so the name we
// want to search for could be language specific.  The test code test2007_07.C
// demonstrates that the function "main" can exist in both classes (as member functions)
// and in namespaces (as more meaningfully qualified names).  Because of this C++
// would have to qualify the global main function as "::main", I think. 

// Revised by Jeremiah,
// Added check to see if the scope is global: Liao

//TODO: Fortran language specific implementation
SgFunctionDeclaration* SageInterface::findMain(SgNode* n) {
  if (!n) return 0;   
  if (isMain(n)) 
  {
    return isSgFunctionDeclaration(n);
  }
  vector<SgNode*> children = n->get_traversalSuccessorContainer();
  for (vector<SgNode*>::const_iterator i = children.begin(); 
  i != children.end(); ++i) {

    SgFunctionDeclaration* mainDecl = findMain(*i);
    if (mainDecl) 
      return mainDecl;
  }
  return 0;
}


SgNode * SageInterface::deepCopyNode (const SgNode* n)
{
  SgTreeCopy g_treeCopy; // should use a copy object each time of usage!
  return n ? n->copy (g_treeCopy) : 0;
}

// by Jeremiah
// Return bool for C++ code, and int for C code
SgType* SageInterface::getBoolType(SgNode* n) {
  bool isC = TransformationSupport::getSourceFile(n)->get_outputLanguage() == SgFile::e_C_output_language;
  if (isC) {
    return SgTypeInt::createType();
  } else {
    return SgTypeBool::createType();
  }
}

#if 1
// Change continue statements in a given block of code to gotos to a label
void SageInterface::changeContinuesToGotos(SgStatement* stmt, SgLabelStatement* label)
   {
     std::vector<SgContinueStmt*> continues = SageInterface::findContinueStmts(stmt);
     for (std::vector<SgContinueStmt*>::iterator i = continues.begin(); i != continues.end(); ++i)
        {
          SgGotoStatement* gotoStatement = SageBuilder::buildGotoStatement(label);
       // printf ("Building gotoStatement #1 = %p \n",gotoStatement);
          LowLevelRewrite::replace(*i, make_unit_list( gotoStatement ) );
        }
   }

// Add a step statement to the end of a loop body
// Add a new label to the end of the loop, with the step statement after
// it; then change all continue statements in the old loop body into
// jumps to the label
//
// For example:
// while (a < 5) {if (a < -3) continue;} (adding "a++" to end) becomes
// while (a < 5) {if (a < -3) goto label; label: a++;}
void SageInterface::addStepToLoopBody(SgScopeStatement* loopStmt, SgStatement* step) {
  using namespace SageBuilder;
  SgScopeStatement* proc = SageInterface::getEnclosingProcedure(loopStmt);
  SgStatement* old_body = SageInterface::getLoopBody(loopStmt);
  SgBasicBlock* new_body = buildBasicBlock();
// printf ("Building IR node #13: new SgBasicBlock = %p \n",new_body);
  SgName labelname = "rose_label__";
  labelname << ++gensym_counter;
  SgLabelStatement* labelstmt = buildLabelStatement(labelname,
buildBasicBlock(), proc);
  changeContinuesToGotos(old_body, labelstmt);
  appendStatement(old_body, new_body);
  appendStatement(labelstmt, new_body);
  appendStatement(step, new_body);
  SageInterface::setLoopBody(loopStmt, new_body);
}


void SageInterface::moveForStatementIncrementIntoBody(SgForStatement* f) {
  if (isSgNullExpression(f->get_increment())) return;
  SgExprStatement* incrStmt = SageBuilder::buildExprStatement(f->get_increment());
  f->get_increment()->set_parent(incrStmt);
  SageInterface::addStepToLoopBody(f, incrStmt);
  SgNullExpression* ne = SageBuilder::buildNullExpression();
  f->set_increment(ne);
  ne->set_parent(f);
}

void SageInterface::convertForToWhile(SgForStatement* f) {
  moveForStatementIncrementIntoBody(f);
  SgBasicBlock* bb = SageBuilder::buildBasicBlock();
  SgForInitStatement* inits = f->get_for_init_stmt();
  SgStatementPtrList& bbStmts = bb->get_statements();
  SgStatementPtrList& initStmts = inits->get_init_stmt();
  bbStmts = initStmts;
  for (size_t i = 0; i < bbStmts.size(); ++i) {
    bbStmts[i]->set_parent(bb);
  }
  bool testIsNull =
    isSgExprStatement(f->get_test()) &&
    isSgNullExpression(isSgExprStatement(f->get_test())->get_expression());
  SgStatement* test =
    testIsNull ?
    SageBuilder::buildExprStatement(
        SageBuilder::buildBoolValExp(true)) :
    f->get_test();
  SgWhileStmt* ws = SageBuilder::buildWhileStmt(
      test,
      f->get_loop_body());
  appendStatement(ws, bb);
  isSgStatement(f->get_parent())->replace_statement(f, bb);
}

void SageInterface::convertAllForsToWhiles(SgNode* top) {
  Rose_STL_Container<SgNode*> fors = NodeQuery::querySubTree(top,
V_SgForStatement);
  for (size_t i = 0; i < fors.size(); ++i) {
    convertForToWhile(isSgForStatement(fors[i]));
  }
}

  vector<SgGotoStatement*> SageInterface::findGotoStmts(SgStatement* scope, SgLabelStatement* l) {
 // DQ (9/25/2007): Moved from std::list to std::vector uniformally in ROSE.
 // But we still need the copy since the return type is IR node specific.
    Rose_STL_Container<SgNode*> allGotos = NodeQuery::querySubTree(scope, V_SgGotoStatement);

    vector<SgGotoStatement*> result;
    for (Rose_STL_Container<SgNode*>::const_iterator i = allGotos.begin(); i != allGotos.end(); ++i) {
      if (isSgGotoStatement(*i)->get_label() == l) {
	result.push_back(isSgGotoStatement(*i));
      }
    }
    return result;
  }


  vector<SgReturnStmt*> SageInterface::findReturnStmts(SgStatement* scope) {
 // DQ (9/25/2007): Moved from std::list to std::vector uniformally in ROSE. 
 // But we still need the copy since the return type is IR node specific.
    Rose_STL_Container<SgNode*> returns = NodeQuery::querySubTree(scope, V_SgReturnStmt);

    vector<SgReturnStmt*> result;
    for (Rose_STL_Container<SgNode*>::const_iterator i = returns.begin(); i != returns.end(); ++i) {
      result.push_back(isSgReturnStmt(*i));
    }
    return result;
  }


static  void getSwitchCasesHelper(SgStatement* top, vector<SgStatement*>& result) {
    ROSE_ASSERT (top);
    if (isSgSwitchStatement(top)) return; // Don't descend into nested switches
    if (isSgCaseOptionStmt(top) || isSgDefaultOptionStmt(top)) {
      result.push_back(top);
    }
    vector<SgNode*> children = top->get_traversalSuccessorContainer();
    for (unsigned int i = 0; i < children.size(); ++i) {
      if (isSgStatement(children[i])) {
	getSwitchCasesHelper(isSgStatement(children[i]), result);
      }
    }
  }

  vector<SgStatement*> SageInterface::getSwitchCases(SgSwitchStatement* sw) {
    vector<SgStatement*> result;
    getSwitchCasesHelper(sw->get_body(), result);
    return result;
  }


#endif

// from transformationSupport.C
SgScopeStatement*
SageInterface::getScope( const SgNode* astNode )
   {
  // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)

  const SgNode* parentNode = astNode;
  while ( (isSgScopeStatement(parentNode) == NULL) && (parentNode->get_parent() != NULL) )
        {
          parentNode = parentNode->get_parent();
        }

  // Check to see if we made it back to the root (current root is SgProject).
  // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).
     if ( isSgScopeStatement(parentNode) == NULL &&
          dynamic_cast<const SgType*>(parentNode) == NULL &&
          dynamic_cast<const SgSymbol*>(parentNode) == NULL )
        {
          printf ("Error: could not trace back to SgScopeStatement node \n");
          ROSE_ABORT();
        }
       else
        {
          if ( dynamic_cast<const SgType*>(parentNode) != NULL || dynamic_cast<const SgSymbol*>(parentNode) != NULL )
             {
               printf ("Error: can't locate an associated SgStatement from astNode = %p = %s parentNode = %p = %s \n",astNode,astNode->class_name().c_str(),parentNode,parentNode->class_name().c_str());
               return NULL;
             }
        }

  // Make sure we have a SgStatement node
     const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     //SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     ROSE_ASSERT (scopeStatement != NULL);

   // return scopeStatement;
       return const_cast<SgScopeStatement*>(scopeStatement);
   }


// from outliner, ASTtools
// ========================================================================

/*!
 *  \brief Return an existing variable symbol for the given
 *  initialized name.
 *
 *  This routine checks various scopes in trying to find a suitable
 *  variable symbol for the given initialized name.
 */
static
const SgVariableSymbol *
getVarSymFromName_const (const SgInitializedName* name)
{
  SgVariableSymbol* v_sym = 0;
  if (name)
    {
      SgScopeStatement* s = name->get_scope ();
      ROSE_ASSERT (s);
      v_sym = s->lookup_var_symbol (name->get_name ());

      if (!v_sym) // E.g., might be part of an 'extern' declaration.
        {
          // Try the declaration's scope.
          SgDeclarationStatement* decl = name->get_declaration ();
          ROSE_ASSERT (decl);

          SgScopeStatement* decl_scope = decl->get_scope ();
          if (decl_scope)
            v_sym = decl_scope->lookup_var_symbol (name->get_name ());

          if (!v_sym)
            cerr << "\t\t*** WARNING: Can't seem to find a symbol for '"
                 << name->get_name ().str ()
                 << "' ***" << endl;
        }
    }
  return v_sym;
}

#if 0
/*!
 *  \brief Return an existing variable symbol for the given
 *  initialized name.
 *
 *  This routine checks various scopes in trying to find a suitable
 *  variable symbol for the given initialized name.
 */
static
SgVariableSymbol *
getVarSymFromName (SgInitializedName* name)
{
  const SgVariableSymbol* v_sym = getVarSymFromName_const (name);
  return const_cast<SgVariableSymbol *> (v_sym);
}
#endif
/*!
 *  \brief Returns the SgVariableSymbol associated with an SgVarRefExp
 *  or SgInitializedName, or 0 if none.
 */
static
const SgVariableSymbol *
getVarSym_const (const SgNode* n)
{
  const SgVariableSymbol* v_sym = 0;
  switch (n->variantT ())
    {
    case V_SgVarRefExp:
      v_sym = isSgVarRefExp (n)->get_symbol ();
      break;
    case V_SgInitializedName:
      v_sym = getVarSymFromName_const (isSgInitializedName (n));
      break;
    default:
      break;
    }
  return v_sym;
}

#if 0
/*!
 *  \brief Returns the SgVariableSymbol associated with an SgVarRefExp
 *  or SgInitializedName, or 0 if none.
 */
static
SgVariableSymbol *
getVarSym (SgNode* n)
{
  const SgVariableSymbol* v_sym = getVarSym_const (n);
  return const_cast<SgVariableSymbol *> (v_sym);
}
#endif

static
const SgVariableSymbol *
getFirstVarSym_const (const SgVariableDeclaration* decl)
{
  if (!decl) return 0;
  const SgInitializedNamePtrList& names = decl->get_variables ();
  if (names.begin () != names.end ())
    {
      const SgInitializedName* name = *(names.begin ());
      return getVarSym_const (name);
    }
  else
    return 0;
}

SgVariableSymbol *
SageInterface::getFirstVarSym (SgVariableDeclaration* decl)
{
  const SgVariableSymbol* sym = getFirstVarSym_const (decl);
  return const_cast<SgVariableSymbol *> (sym);
}


SgInitializedName* 
SageInterface::getFirstInitializedName (SgVariableDeclaration* decl)
{
  ROSE_ASSERT(decl);
  SgInitializedNamePtrList& names = decl->get_variables ();
  if (names.begin () != names.end ())
    return *(names.begin ());
  else
    return NULL;
}


static void findBreakStmtsHelper(SgStatement* code, const std::string& fortranLabel, bool inOutermostBody, vector<SgBreakStmt*>& breakStmts) {
  if (isSgWhileStmt(code) || isSgDoWhileStmt(code) || isSgForStatement(code) || isSgSwitchStatement(code)) {
    if (fortranLabel == "") {
      // Outermost loop only
      return;
    } else {
      // Set this for query on children
      inOutermostBody = false;
    }
  }
  if (isSgBreakStmt(code)) {
    SgBreakStmt* bs = isSgBreakStmt(code);
    bool breakMatchesThisConstruct = false;
    if (bs->get_do_string_label() == "") {
      // Break matches closest construct
      breakMatchesThisConstruct = inOutermostBody;
    } else {
      breakMatchesThisConstruct = (fortranLabel == bs->get_do_string_label());
    }
    if (breakMatchesThisConstruct) {
      breakStmts.push_back(bs);
    }
    return;
  }
  vector<SgNode*> children = code->get_traversalSuccessorContainer();
  for (unsigned int i = 0; i < children.size(); ++i) {
    if (isSgStatement(children[i])) {
      findBreakStmtsHelper(isSgStatement(children[i]), fortranLabel, inOutermostBody, breakStmts);
    }
  }
}

vector<SgBreakStmt*> SageInterface::findBreakStmts(SgStatement* code, const std::string& fortranLabel) {
  // Run this on the body of a loop or switch, because it stops at any
  // construct which defines a new scope for break statements
  vector<SgBreakStmt*> result;
  findBreakStmtsHelper(code, fortranLabel, true, result);
  return result;
}


static void findContinueStmtsHelper(SgStatement* code, const std::string& fortranLabel, bool inOutermostBody, vector<SgContinueStmt*>& continueStmts) {
  if (isSgWhileStmt(code) || isSgDoWhileStmt(code) || isSgForStatement(code)) {
    if (fortranLabel == "") {
      // Outermost loop only
      return;
    } else {
      // Set this for query on children
      inOutermostBody = false;
    }
  }
  if (isSgContinueStmt(code)) {
    SgContinueStmt* cs = isSgContinueStmt(code);
    bool continueMatchesThisConstruct = false;
    if (cs->get_do_string_label() == "") {
      // Continue matches closest construct
      continueMatchesThisConstruct = inOutermostBody;
    } else {
      continueMatchesThisConstruct = (fortranLabel == cs->get_do_string_label());
    }
    if (continueMatchesThisConstruct) {
      continueStmts.push_back(cs);
    }
    return;
  }
  vector<SgNode*> children = code->get_traversalSuccessorContainer();
  for (unsigned int i = 0; i < children.size(); ++i) {
    if (isSgStatement(children[i])) {
      findContinueStmtsHelper(isSgStatement(children[i]), fortranLabel, inOutermostBody, continueStmts);
    }
  }
}

vector<SgContinueStmt*> SageInterface::findContinueStmts(SgStatement* code, const std::string& fortranLabel) {
  // Run this on the body of a loop, because it stops at any construct which
  // defines a new scope for continue statements
  vector<SgContinueStmt*> result;
  findContinueStmtsHelper(code, fortranLabel, true, result);
  return result;
}


// Get the initializer containing an expression if it is within an
// initializer.
//  from replaceExpressionWithStatement.C
SgInitializer* SageInterface::getInitializerOfExpression(SgExpression* n) {
  assert(n);
#if 0
  std::cout << "Starting getInitializerOfExpression on 0x" << std::hex << (int)n << ", which has type " << n->sage_class_name() << std::endl;
#endif
  while (!isSgInitializer(n)) {
    n = isSgExpression(n->get_parent());
#if 0
    std::cout << "Continuing getInitializerOfExpression on 0x" << std::hex << (int)n;
    if (n) std::cout << ", which has type " << n->sage_class_name();
    std::cout << std::endl;
#endif
    assert(n);
  }
  return isSgInitializer(n);
}

// Get all symbols used in a given expression
vector<SgVariableSymbol*> SageInterface::getSymbolsUsedInExpression(SgExpression* expr) {
 class GetSymbolsUsedInExpressionVisitor: public AstSimpleProcessing {
  public:
  std::vector<SgVariableSymbol*> symbols;

  virtual void visit(SgNode* n) {
    if (isSgVarRefExp(n))
      symbols.push_back(isSgVarRefExp(n)->get_symbol());
  }
 };

  GetSymbolsUsedInExpressionVisitor vis;
  vis.traverse(expr, preorder);
  return vis.symbols;
}

SgFunctionDefinition* SageInterface::getEnclosingProcedure(SgNode* n, bool includingSelf)
{
  return getEnclosingFunctionDefinition(n,includingSelf);
}

SgFunctionDefinition* SageInterface::getEnclosingFunctionDefinition(SgNode* n,bool includingSelf)
{
    SgFunctionDefinition* temp = getEnclosingNode<SgFunctionDefinition>(n,includingSelf);
  if (temp)
    return temp;
  else
    return NULL;
} 


SgFunctionDeclaration *
SageInterface::getEnclosingFunctionDeclaration (SgNode * astNode,bool includingSelf)
{
  SgNode* temp = getEnclosingNode<SgFunctionDeclaration>(astNode,includingSelf);
  if (temp)
    return isSgFunctionDeclaration(temp);
  else
    return NULL;
#if 0
  SgNode *astnode = astNode;
  ROSE_ASSERT (astNode != NULL);
  do
    {
      astnode = astnode->get_parent ();
    }
  while ((astnode != NULL) &&
	 (isSgFunctionDeclaration (astnode) == NULL) &&
	 (isSgMemberFunctionDeclaration (astnode) == NULL));
  if (astnode==NULL) return NULL;
  else return isSgFunctionDeclaration(astnode);
#endif 
}

 SgGlobal* SageInterface::getGlobalScope( const SgNode* astNode)
 {
   // should including itself in this case
    SgNode* temp = getEnclosingNode<SgGlobal>(astNode,true);
    if (temp)
      return isSgGlobal(temp);
    else 
      return NULL;
  }

  SgClassDefinition* 
  SageInterface::getEnclosingClassDefinition(SgNode* astNode, const bool includingSelf/* =false*/)
  {
    SgNode* temp = getEnclosingNode<SgClassDefinition>(astNode,includingSelf);
    if (temp)
      return isSgClassDefinition(temp);
    else 
      return NULL;
 }


SgFile * SageInterface::getEnclosingFileNode(SgNode* astNode)
{
    ROSE_ASSERT (astNode != NULL);

  // Make sure this is not a project node (since the SgFile exists below 
  // the project and could not be found by a traversal of the parent list)
     ROSE_ASSERT (isSgProject(astNode) == NULL);

     SgNode* parent = astNode;
     while ( (parent != NULL) && (isSgFile(parent) == NULL) )
        {
       // printf ("In getFileNameByTraversalBackToFileNode(): parent = %p = %s \n",parent,parent->class_name().c_str());
          parent = parent->get_parent();
        }
 if (!parent) 
   return NULL;
 else return isSgFile(parent);

}

SgStatement* SageInterface::getEnclosingStatement(SgNode* n) {
  while (n && !isSgStatement(n)) n = n->get_parent();
  return isSgStatement(n);
}

//! Remove a statement: TODO consider side effects for symbol tables
void SageInterface::removeStatement(SgStatement* stmt)
{
  ROSE_ASSERT(stmt);
  LowLevelRewrite::remove(stmt);
}

//! Deep delete a sub AST tree. It uses postorder traversal to delete each child node.
void SageInterface::deepDelete(SgNode* root)
{
   struct Visitor: public AstSimpleProcessing {
    virtual void visit(SgNode* n) {
        delete (n);
     }
    };
  Visitor().traverse(root, postorder);
}

//! Replace a statement with another
void SageInterface::replaceStatement(SgStatement* oldStmt, SgStatement* newStmt)
{
  ROSE_ASSERT(oldStmt);  
  ROSE_ASSERT(newStmt);  
  if (oldStmt == newStmt) return;
  SgStatement * p = isSgStatement(oldStmt->get_parent());
  ROSE_ASSERT(p);
  oldStmt->set_parent(p); // needed ?
  p->replace_statement(oldStmt,newStmt);
}

// This code is based on OpenMP translator's ASTtools::replaceVarRefExp() and astInling's replaceExpressionWithExpression()
// Motivation: It involves the parent node to replace a VarRefExp with a new node
// Used to replace shared variables with the dereference expression of their addresses
// e.g. to replace shared1 with (*__pp_shared1)

void SageInterface::replaceExpression(SgExpression* oldExp, SgExpression* newExp, bool keepOldExp/*=false*/)
{
  ROSE_ASSERT(oldExp);
  ROSE_ASSERT(newExp);
  if (oldExp==newExp) return;
  
  if (isSgVarRefExp(newExp))
    newExp->set_need_paren(true); // enclosing new expression with () to be safe

  SgNode* parent = oldExp->get_parent();
  ROSE_ASSERT(parent!=NULL);
  newExp->set_parent(parent);

  // set lvalue when necessary
  if (oldExp->get_lvalue() == true) newExp->set_lvalue(true);

  if (isSgExprStatement(parent)) {
    isSgExprStatement(parent)->set_expression(newExp);
    } 
  else if (isSgForStatement(parent)) {
    ROSE_ASSERT (isSgForStatement(parent)->get_increment() == oldExp);
    isSgForStatement(parent)->set_increment(newExp);
    // TODO: any other cases here??
  }
  else if (isSgReturnStmt(parent)) 
    isSgReturnStmt(parent)->set_expression(newExp);
  else  if (isSgBinaryOp(parent)!=NULL){
    if (oldExp==isSgBinaryOp(parent)->get_lhs_operand())
        {
          isSgBinaryOp(parent)->set_lhs_operand(newExp);
         }
     else if (oldExp==isSgBinaryOp(parent)->get_rhs_operand())
         {isSgBinaryOp(parent)->set_rhs_operand(newExp); }
     else
       ROSE_ASSERT(false);
   } else //unary parent
  if (isSgUnaryOp(parent)!=NULL){
      if (oldExp==isSgUnaryOp(parent)->get_operand_i())
           isSgUnaryOp(parent)->set_operand_i(newExp);
      else
        ROSE_ASSERT(false);
  }  else//SgConditionalExp
  if (isSgConditionalExp(parent)!=NULL){
     SgConditionalExp *expparent= isSgConditionalExp(parent);//get explicity type parent
     if (oldExp==expparent->get_conditional_exp()) expparent->set_conditional_exp(newExp);
     else if (oldExp==expparent->get_true_exp()) expparent->set_true_exp(newExp);
     else if (oldExp==expparent->get_false_exp()) expparent->set_false_exp(newExp);
     else
       ROSE_ASSERT(false);
  } else if (isSgExprListExp(parent)!=NULL)
  {
    SgExpressionPtrList & explist = isSgExprListExp(parent)->get_expressions();
    for (Rose_STL_Container<SgExpression*>::iterator i=explist.begin();i!=explist.end();i++)
      if (isSgExpression(*i)==oldExp) {
        isSgExprListExp(parent)->replace_expression(oldExp,newExp);
       // break; //replace the first occurrence only??
      }
  }
  else if (isSgExpression(parent)) {
    int worked = isSgExpression(parent)->replace_expression(oldExp, newExp);  
    // ROSE_DEPRECATED_FUNCTION
    ROSE_ASSERT (worked);
  }
 else{
  cout<<"SageInterface::replaceExpression(). Unhandled parent expression type of SageIII enum value: " <<parent->class_name()<<endl;
  ROSE_ASSERT(false);
  }

  if (!keepOldExp) 
  {
    deepDelete(oldExp); // avoid dangling node in memory pool
  }
  
} //replaceExpression()

#if 0 // move to header 
// Contributed by Jeremiah
//! Get all nodes with a certain variant, with an appropriate downcast. FIXME:
//! there needs to be a static method in each SgNode subclass that returns the
//! correct variant number.
template <typename NodeType>
std::vector<NodeType*> SageInterface::querySubTree(SgNode* top, VariantT variant) {

  Rose_STL_Container<SgNode*> nodes = NodeQuery::querySubTree(top,variant);
  std::vector<NodeType*> result(nodes.size(), NULL);
  int count = 0;
  for (Rose_STL_Container<SgNode*>::const_iterator i = nodes.begin();
       i != nodes.end(); ++i, ++count) {
    NodeType* node = dynamic_cast<NodeType*>(*i);
    ROSE_ASSERT (node);
    result[count] = node;
  }
  return result;
}
#endif

 SgStatement* SageInterface::getNextStatement(SgStatement * currentStmt)
{
// reuse the implementation in ROSE namespace from src/roseSupport/utility_functions.C
  return ROSE::getNextStatement(currentStmt);
}

  SgStatement* SageInterface::getPreviousStatement(SgStatement * currentStmt)
{
 
  return ROSE::getPreviousStatement(currentStmt);
}

bool SageInterface::isEqualToIntConst(SgExpression* e, int value) {
     return isSgIntVal(e) && isSgIntVal(e)->get_value() == value;
  }

 bool SageInterface::isSameFunction(SgFunctionDeclaration* func1, SgFunctionDeclaration* func2)
 {
   ROSE_ASSERT(func1&& func2);
   bool result = false; 
   if (func1 == func2)
     result = true;
   else  
    {
      if (is_C_language()||is_C99_language()||is_PHP_language())
      {
        if (func1->get_name() == func2->get_name())
          result = true;
      }
      else if (is_Cxx_language())
      {
         if (func1->get_qualified_name().getString() + 
            func1->get_mangled_name().getString() ==
            func2->get_qualified_name().getString() + 
            func2->get_mangled_name().getString()
            )
         result = true; 
      }
      else if (is_Fortran_language())
      {
        if (func1->get_name() == func2->get_name())
          result = true;
      }
      else
      {
        cout<<"Error: SageInterface::isSameFunction(): unhandled language"<<endl;
        ROSE_ASSERT(false);
      }

    } // not identical
  return result;  
 } // isSameFunction()

//-----------------------------------------------
// Remove original expression trees from expressions, so you can change
// the value and have it unparsed correctly.
void SageInterface::removeAllOriginalExpressionTrees(SgNode* top) {
  struct Visitor: public AstSimpleProcessing {
    virtual void visit(SgNode* n) {
      if (isSgValueExp(n)) {
        isSgValueExp(n)->set_originalExpressionTree(NULL);
      } else if (isSgCastExp(n)) {
        isSgCastExp(n)->set_originalExpressionTree(NULL);
      }
    }
  };
  Visitor().traverse(top, preorder);
}


SgSwitchStatement* SageInterface::findEnclosingSwitch(SgStatement* s) {
  while (s && !isSgSwitchStatement(s)) {
    s = isSgStatement(s->get_parent());
  }
  ROSE_ASSERT (s);
  return isSgSwitchStatement(s);
}

SgScopeStatement* SageInterface::findEnclosingLoop(SgStatement* s, const std::string& fortranLabel, bool stopOnSwitches) {
  for (; s; s = isSgStatement(s->get_parent())) {
    SgScopeStatement* sc = isSgScopeStatement(s);
    switch (s->variantT()) {
      case V_SgDoWhileStmt: return sc;
      case V_SgForStatement: return sc;
      case V_SgFortranDo:
      case V_SgFortranNonblockedDo: {
        if (fortranLabel.empty() ||
            fortranLabel == isSgFortranDo(sc)->get_string_label()) {
          return sc;
        }
        break;
      }
      case V_SgWhileStmt: {
        if (fortranLabel.empty() ||
            fortranLabel == isSgWhileStmt(sc)->get_string_label()) {
          return sc;
        }
        break;
      }
      case V_SgSwitchStatement: {
        if (stopOnSwitches) return sc;
        break;
      }
      default: continue;
    }
  }
  return NULL;
}

void SageInterface::removeJumpsToNextStatement(SgNode* top)
{
 class RemoveJumpsToNextStatementVisitor: public AstSimpleProcessing {
    public:
    virtual void visit(SgNode* n) {
      if (isSgBasicBlock(n)) {
        SgBasicBlock* bb = isSgBasicBlock(n);
        bool changes = true;
        while (changes) {
          changes = false;
          for (SgStatementPtrList::iterator i = bb->get_statements().begin();
               i != bb->get_statements().end(); ++i) {
            if (isSgGotoStatement(*i)) {
              SgGotoStatement* gs = isSgGotoStatement(*i);
              SgStatementPtrList::iterator inext = i;
              ++inext;
             if (inext == bb->get_statements().end())
                continue;
             if (!isSgLabelStatement(*inext))
                continue;
              SgLabelStatement* ls = isSgLabelStatement(*inext);
              if (gs->get_label() == ls) {
                changes = true;
                bb->get_statements().erase(i);
                break;
              }
            }
          }
        }
      }
    }
  };

  RemoveJumpsToNextStatementVisitor().traverse(top, postorder);

}

// special purpose remove for AST transformation/optimization from astInliner, don't use it otherwise. 
void SageInterface::myRemoveStatement(SgStatement* stmt) {
  // assert (LowLevelRewrite::isRemovableStatement(*i));
  SgStatement* parent = isSgStatement(stmt->get_parent());
  ROSE_ASSERT (parent);
  SgBasicBlock* bb = isSgBasicBlock(parent);
  SgForInitStatement* fis = isSgForInitStatement(parent);
  if (bb || fis) {
    ROSE_ASSERT (bb || fis);
    SgStatementPtrList& siblings =
      (bb ? bb->get_statements() : fis->get_init_stmt());
    SgStatementPtrList::iterator j =
      std::find(siblings.begin(), siblings.end(), stmt);
    ROSE_ASSERT (j != siblings.end());
    siblings.erase(j);
    // LowLevelRewrite::remove(*i);
  } else {
    parent->replace_statement(stmt, new SgNullStatement(TRANS_FILE));
  }
}


// Remove all unused labels in a section of code.
void SageInterface::removeUnusedLabels(SgNode* top) {

class FindUsedAndAllLabelsVisitor: public AstSimpleProcessing {
  SgLabelStatementPtrSet& used;
  SgLabelStatementPtrSet& all;

  public:
  FindUsedAndAllLabelsVisitor(SgLabelStatementPtrSet& used,
                              SgLabelStatementPtrSet& all):
    used(used), all(all) {}

  virtual void visit(SgNode* n) {
    if (isSgGotoStatement(n)) {
      used.insert(isSgGotoStatement(n)->get_label());
    }
    if (isSgLabelStatement(n)) {
      all.insert(isSgLabelStatement(n));
    }
  }
};

  SgLabelStatementPtrSet used;
  SgLabelStatementPtrSet unused;
  FindUsedAndAllLabelsVisitor(used, unused).traverse(top, preorder);
  for (SgLabelStatementPtrSet::iterator i = used.begin();
       i != used.end(); ++i) {
    assert (unused.find(*i) != unused.end());
    // std::cout << "Keeping used label " << (*i)->get_label().str() << std::endl;
    unused.erase(*i);
  }
  for (SgLabelStatementPtrSet::iterator i = unused.begin();
       i != unused.end(); ++i) {
    // std::cout << "Removing unused label " << (*i)->get_label().str() << std::endl;
    myRemoveStatement(*i);
  }
}


  SgStatement* SageInterface::getLoopBody(SgScopeStatement* loopStmt) {
    if (isSgWhileStmt(loopStmt)) return isSgWhileStmt(loopStmt)->get_body();
    if (isSgForStatement(loopStmt)) return isSgForStatement(loopStmt)->get_loop_body();
    if (isSgDoWhileStmt(loopStmt)) return isSgDoWhileStmt(loopStmt)->get_body();
    ROSE_ASSERT (!"Bad loop kind");
  }

  void SageInterface::setLoopBody(SgScopeStatement* loopStmt, SgStatement* body) {
    if (isSgWhileStmt(loopStmt)) {
      isSgWhileStmt(loopStmt)->set_body(body);
    } else if (isSgForStatement(loopStmt)) {
      isSgForStatement(loopStmt)->set_loop_body(body);
    } else if (isSgDoWhileStmt(loopStmt)) {
      isSgDoWhileStmt(loopStmt)->set_body(body);
    } else {
      ROSE_ASSERT (!"Bad loop kind");
    }
    body->set_parent(loopStmt);
  }

  SgStatement* SageInterface::getLoopCondition(SgScopeStatement* loopStmt) {
    if (isSgWhileStmt(loopStmt)) return isSgWhileStmt(loopStmt)->get_condition();
    if (isSgForStatement(loopStmt)) return isSgForStatement(loopStmt)->get_test();
    if (isSgDoWhileStmt(loopStmt)) return isSgDoWhileStmt(loopStmt)->get_condition();
    ROSE_ASSERT (!"Bad loop kind");
  }

  void SageInterface::setLoopCondition(SgScopeStatement* loopStmt, SgStatement* cond) {
    if (isSgWhileStmt(loopStmt)) {
      isSgWhileStmt(loopStmt)->set_condition(cond);
    } else if (isSgForStatement(loopStmt)) {
      isSgForStatement(loopStmt)->set_test(cond);
    } else if (isSgDoWhileStmt(loopStmt)) {
      isSgDoWhileStmt(loopStmt)->set_condition(cond);
    } else {
      ROSE_ASSERT (!"Bad loop kind");
    }
    cond->set_parent(loopStmt);
  }

//! Normalize a for loop, part of migrating Qing's loop handling into SageInterface
// NormalizeCPP.C  NormalizeLoopTraverse::ProcessLoop()
//bool SageInterface::forLoopNormalization(SgForStatement* loop)
//{
//  bool result=false;
//  ROSE_ASSERT(loop != NULL);
//  // Must only have one initialization statement
//  SgStatementPtrList &init = loop ->get_init_stmt();
//  if (init.size !=1)
//    return false;
//
//  return result;
//}

//! A helper function to strip off possible type casting operations for an expression
// usually useful when compare two expressions to see if they actually refer to the same variable
static SgExpression* SkipCasting (SgExpression* exp)
{
  SgCastExp* cast_exp = isSgCastExp(exp);
   if (cast_exp != NULL)
   {
      SgExpression* operand = cast_exp->get_operand();
      assert(operand != 0);
      return SkipCasting(operand);
   }
  else      
    return exp;
}

//! Based on AstInterface::IsFortranLoop() and ASTtools::getLoopIndexVar()
//TODO check the loop index is not being written in the loop body
bool SageInterface::isCanonicalForLoop(SgNode* loop,SgInitializedName** ivar/*=NULL*/, SgExpression** lb/*=NULL*/, SgExpression** ub/*=NULL*/, SgExpression** step/*=NULL*/, SgStatement** body/*=NULL*/)
{
  ROSE_ASSERT(loop != NULL);
  SgForStatement* fs = isSgForStatement(loop);
  if (fs == NULL)
    return false;
  // 1. Check initialization statement is something like i=xx;
  SgStatementPtrList & init = fs->get_init_stmt();
  if (init.size() !=1)
    return false;
  SgStatement* init1 = init.front();
  SgExpression* ivarast=NULL, *lbast=NULL, *ubast=NULL, *stepast=NULL;
  SgInitializedName* ivarname=NULL;  

  bool isCase1=false, isCase2=false;
  //consider C99 style: for (int i=0;...)
  if (isSgVariableDeclaration(init1))
   {
     SgVariableDeclaration* decl = isSgVariableDeclaration(init1);
     ivarname = decl->get_variables().front();
     ROSE_ASSERT(ivarname != NULL);
     SgInitializer * initor = ivarname->get_initializer(); 
     if (isSgAssignInitializer(initor))
     {
       lbast = isSgAssignInitializer(initor)->get_operand();
       isCase1 = true;
     }
   }// other regular case: for (i=0;..)
   else if (isAssignmentStatement(init1, &ivarast, &lbast))
   { 
     SgVarRefExp* var = isSgVarRefExp(SkipCasting(ivarast));
     if (var)
     {
       ivarname = var->get_symbol()->get_declaration();
       isCase2 = true;
     }
   }
   // Cannot be both true
   ROSE_ASSERT(!(isCase1&&isCase2));
   // if not either case is true
    if (!(isCase1||isCase2))
      return false;

  //Check loop index's type
  if (!isStrictIntegerType(ivarname->get_type()))
    return false;

  //2. Check test expression i [<=, >=, <, > ,!=] bound 
  SgBinaryOp* test = isSgBinaryOp(fs->get_test_expr());
  if (test == NULL)
    return false;
  switch (test->variantT()) {
    case V_SgLessOrEqualOp:
    case V_SgLessThanOp:
    case V_SgGreaterOrEqualOp:
    case V_SgGreaterThanOp:
    case V_SgNotEqualOp: // Do we really want to allow this != operator ?
      break;
    default:  
      return false;
  }
  // check the tested variable is the same as the loop index
  SgVarRefExp* testvar = isSgVarRefExp(SkipCasting(test->get_lhs_operand())); 
  if (testvar == NULL)
    return false;
  if (testvar->get_symbol() != ivarname->get_symbol_from_symbol_table ())  
    return false;
  //grab the upper bound
  ubast = test->get_rhs_operand();

  //3. Check the increment expression
  SgExpression* incr = fs->get_increment();
  SgVarRefExp* incr_var = NULL;
  switch (incr->variantT()) {
    case V_SgPlusAssignOp: //+=
    case V_SgMinusAssignOp://-=
      incr_var = isSgVarRefExp(SkipCasting(isSgBinaryOp(incr)->get_lhs_operand()));
      stepast = isSgBinaryOp(incr)->get_rhs_operand();
      break;
    case V_SgPlusPlusOp:   //++
    case V_SgMinusMinusOp:  //--
      incr_var = isSgVarRefExp(SkipCasting(isSgUnaryOp(incr)->get_operand()));
      stepast = buildIntVal(1); // will this dangling SgNode cause any problem?
      break;
    default:
      return false;
  }
  if (incr_var == NULL) 
    return false;
  if (incr_var->get_symbol() != ivarname->get_symbol_from_symbol_table ())
    return false;

  // return loop information if requested
  if (ivar != NULL)
    *ivar = ivarname;
  if (lb != NULL)
    *lb = lbast;
  if (ub != NULL)
    *ub = ubast;
  if (step != NULL)
    *step = stepast;
  if (body != NULL) {
    *body = fs->get_loop_body();
  }
  return true;
}


//! Check if a SgNode _s is an assignment statement (any of =,+=,-=,&=,/=, ^=, etc)
//!
//! Return the left hand, right hand expressions and if the left hand variable is also being read. This code is from AstInterface::IsAssignment()
bool SageInterface::isAssignmentStatement(SgNode* s, SgExpression** lhs/*=NULL*/, SgExpression** rhs/*=NULL*/, bool* readlhs/*=NULL*/)
{
  SgExprStatement *n = isSgExprStatement(s);
  SgExpression *exp = (n != 0)? n->get_expression() : isSgExpression(s);
  if (exp != 0) {
    switch (exp->variantT()) {
      case V_SgPlusAssignOp:
      case V_SgMinusAssignOp:
      case V_SgAndAssignOp:
      case V_SgIorAssignOp:
      case V_SgMultAssignOp:
      case V_SgDivAssignOp:
      case V_SgModAssignOp:
      case V_SgXorAssignOp:
      case V_SgAssignOp:
        {
          SgBinaryOp* s2 = isSgBinaryOp(exp);
          if (lhs != 0)
            *lhs = s2->get_lhs_operand();
          if (rhs != 0) {
            SgExpression* init = s2->get_rhs_operand();
            if ( init->variantT() == V_SgAssignInitializer) 
              init = isSgAssignInitializer(init)->get_operand();
            *rhs = init;
          }
          if (readlhs != 0)
            *readlhs = (exp->variantT() != V_SgAssignOp);
          return true;
        }
      default: 
         return false;
    }
  }
  return false;
}


  void SageInterface::removeConsecutiveLabels(SgNode* top) {
   Rose_STL_Container<SgNode*> gotos = NodeQuery::querySubTree(top,V_SgGotoStatement);
   for (size_t i = 0; i < gotos.size(); ++i) {
     SgGotoStatement* gs = isSgGotoStatement(gotos[i]);
     SgLabelStatement* ls = gs->get_label();
     SgBasicBlock* lsParent = isSgBasicBlock(ls->get_parent());
     if (!lsParent) continue;
     SgStatementPtrList& bbStatements = lsParent->get_statements();
     size_t j = std::find(bbStatements.begin(), bbStatements.end(), ls)
  - bbStatements.begin();
     ROSE_ASSERT (j != bbStatements.size());     while (j <
  bbStatements.size() - 1 && isSgLabelStatement(bbStatements[j + 1])) {
     ++j;
     }
     gs->set_label(isSgLabelStatement(bbStatements[j]));
   }
  }

namespace SageInterface { // A few internal helper classes

class AndOpGenerator: public StatementGenerator
   {
     SgAndOp* op;

     public:
          AndOpGenerator(SgAndOp* op): op(op) {}

          virtual SgStatement* generate(SgExpression* lhs)
             {
               SgTreeCopy treeCopy;
               SgExpression* lhsCopy = isSgExpression(lhs->copy(treeCopy));
               ROSE_ASSERT (lhsCopy);
               SgIfStmt* tree =
                 SageBuilder::buildIfStmt(
                     SageBuilder::buildExprStatement(op->get_lhs_operand()),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhs, op->get_rhs_operand())),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhsCopy, SageBuilder::buildBoolValExp(false))));
               return tree;
             }
   };

class OrOpGenerator: public StatementGenerator
   {
     SgOrOp* op;

     public:
          OrOpGenerator(SgOrOp* op): op(op) {}

          virtual SgStatement* generate(SgExpression* lhs)
             {
               SgTreeCopy treeCopy;
               SgExpression* lhsCopy = isSgExpression(lhs->copy(treeCopy));
               ROSE_ASSERT (lhsCopy);
               SgIfStmt* tree =
                 SageBuilder::buildIfStmt(
                     SageBuilder::buildExprStatement(op->get_lhs_operand()),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhs, SageBuilder::buildBoolValExp(true))),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhsCopy, op->get_rhs_operand())));
               return tree;
             }
   };

class ConditionalExpGenerator: public StatementGenerator
   {
     SgConditionalExp* op;

     public:
          ConditionalExpGenerator(SgConditionalExp* op): op(op) {}

          virtual SgStatement* generate(SgExpression* lhs)
             {
               SgTreeCopy treeCopy;
               SgExpression* lhsCopy = isSgExpression(lhs->copy(treeCopy));
               ROSE_ASSERT (lhsCopy);
               SgIfStmt* tree =
                 SageBuilder::buildIfStmt(
                     SageBuilder::buildExprStatement(op->get_conditional_exp()),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhs, op->get_true_exp())),
                     SageBuilder::buildBasicBlock(
                       SageBuilder::buildAssignStatement(lhsCopy, op->get_false_exp())));
               return tree;
             }
   };

} // end of namespace for the helper classes

   //! Merged from replaceExpressionWithStatement.C
    SgAssignInitializer* SageInterface::splitExpression(SgExpression* from, string newName/* ="" */) 
    {
    if (!SageInterface::isCopyConstructible(from->get_type())) {
      std::cerr << "Type " << from->get_type()->unparseToString() << " of expression " << from->unparseToString() << " is not copy constructible" << std::endl;
      ROSE_ASSERT (false);
    }

    assert (SageInterface::isCopyConstructible(from->get_type())); // How do we report errors?
    SgStatement* stmt = getStatementOfExpression(from);
    assert (stmt);
    if (!isSgForInitStatement(stmt->get_parent())) {
      SageInterface::ensureBasicBlockAsParent(stmt);
    }

    SgScopeStatement* parent = isSgScopeStatement(stmt->get_parent());
    // cout << "parent is a " << (parent ? parent->sage_class_name() : "NULL") << endl;
    if (!parent && isSgForInitStatement(stmt->get_parent()))
      parent = isSgScopeStatement(stmt->get_parent()->get_parent()->get_parent());
    assert (parent);
    // cout << "parent is a " << parent->sage_class_name() << endl;
    // cout << "parent is " << parent->unparseToString() << endl;
    // cout << "stmt is " << stmt->unparseToString() << endl;
    SgName varname = "rose_temp__";
    if (newName == "") {
      varname << ++SageInterface::gensym_counter;
    } else {
      varname = newName;
    }

    SgType* vartype = from->get_type();
    SgNode* fromparent = from->get_parent();
    vector<SgExpression*> ancestors;
    for (SgExpression *expr = from, *anc = isSgExpression(fromparent); anc != 0;
         expr = anc, anc = isSgExpression(anc->get_parent())) {
      if ((isSgAndOp(anc) && expr != isSgAndOp(anc)->get_lhs_operand()) ||
          (isSgOrOp(anc) && expr != isSgOrOp(anc)->get_lhs_operand()) ||
          (isSgConditionalExp(anc) && expr != isSgConditionalExp(anc)->get_conditional_exp()))
        ancestors.push_back(anc); // Closest first
    }
    // cout << "This expression to split has " << ancestors.size() << " ancestor(s)" << endl;
    for (vector<SgExpression*>::reverse_iterator ai = ancestors.rbegin(); ai != ancestors.rend(); ++ai)
    {
      StatementGenerator* gen;
      switch ((*ai)->variantT()) {
        case V_SgAndOp: 
           gen = new AndOpGenerator(isSgAndOp(*ai)); break;
        case V_SgOrOp:
           gen = new OrOpGenerator(isSgOrOp(*ai)); break;
        case V_SgConditionalExp:
           gen = new ConditionalExpGenerator(isSgConditionalExp(*ai)); break;
        default: assert (!"Should not happen");
      }
      replaceExpressionWithStatement(*ai, gen);
      delete gen;
    } // for
    if (ancestors.size() != 0) {
      return splitExpression(from); 
      // Need to recompute everything if there were ancestors
    }
    SgVariableDeclaration* vardecl = SageBuilder::buildVariableDeclaration(varname, vartype, NULL, parent);
    SgVariableSymbol* sym = SageInterface::getFirstVarSym(vardecl);
    ROSE_ASSERT (sym);
    SgInitializedName* initname = sym->get_declaration();
    ROSE_ASSERT (initname);
    SgVarRefExp* varref = SageBuilder::buildVarRefExp(sym);
    replaceExpressionWithExpression(from, varref);
    // std::cout << "Unparsed 3: " << fromparent->sage_class_name() << " --- " << fromparent->unparseToString() << endl;
    // cout << "From is a " << from->sage_class_name() << endl;
       SgAssignInitializer* ai = SageBuilder::buildAssignInitializer(from);
       initname->set_initializer(ai);
       ai->set_parent(initname);
    myStatementInsert(stmt, vardecl, true);
    // vardecl->set_parent(stmt->get_parent());
    // FixSgTree(vardecl);
    // FixSgTree(parent);
    return ai;
  } //splitExpression()

  //! This generalizes the normal splitExpression to allow loop tests and
  void SageInterface::splitExpressionIntoBasicBlock(SgExpression* expr) {
   struct SplitStatementGenerator: public StatementGenerator {
     SgExpression* expr;
     virtual SgStatement* generate(SgExpression* answer) {
       using namespace SageBuilder;
       return buildBasicBlock(buildAssignStatement(answer, expr));
     }
   };
   SplitStatementGenerator gen;
   gen.expr = expr;
   replaceExpressionWithStatement(expr, &gen);
  }
    
  void SageInterface::removeLabeledGotos(SgNode* top) {
   Rose_STL_Container<SgNode*> gotos = NodeQuery::querySubTree(top,
  V_SgGotoStatement);
   map<SgLabelStatement*, SgLabelStatement*> labelsToReplace;   for
  (size_t i = 0; i < gotos.size(); ++i) {
     SgGotoStatement* gs = isSgGotoStatement(gotos[i]);
     SgBasicBlock* gsParent = isSgBasicBlock(gs->get_parent());
     if (!gsParent) continue;
     SgStatementPtrList& bbStatements = gsParent->get_statements();
     size_t j = std::find(bbStatements.begin(), bbStatements.end(), gs)
  - bbStatements.begin();
     ROSE_ASSERT (j != bbStatements.size());
     if (j == 0) continue;
     if (isSgLabelStatement(bbStatements[j - 1])) {
       labelsToReplace[isSgLabelStatement(bbStatements[j - 1])] =
  gs->get_label();
     }
   }
   for (size_t i = 0; i < gotos.size(); ++i) {
     SgGotoStatement* gs = isSgGotoStatement(gotos[i]);
     SgLabelStatement* oldLabel = gs->get_label();
     while (labelsToReplace.find(oldLabel) != labelsToReplace.end()) {
       oldLabel = labelsToReplace[oldLabel];
     }
     gs->set_label(oldLabel);
   }
  }

  bool SageInterface::isConstantTrue(SgExpression* e) {
  switch (e->variantT()) {
    case V_SgBoolValExp: return isSgBoolValExp(e)->get_value() == true;
    case V_SgIntVal: return isSgIntVal(e)->get_value() != 0;
    case V_SgCastExp: return isConstantTrue(isSgCastExp(e)->get_operand());
    case V_SgNotOp: return isConstantFalse(isSgNotOp(e)->get_operand());
    case V_SgAddressOfOp: return true;
    default: return false;
  }
  }

  bool SageInterface::isConstantFalse(SgExpression* e) {
    switch (e->variantT()) {
      case V_SgBoolValExp: return isSgBoolValExp(e)->get_value() == false;
      case V_SgIntVal: return isSgIntVal(e)->get_value() == 0;
      case V_SgCastExp: return
  isConstantFalse(isSgCastExp(e)->get_operand());
      case V_SgNotOp: return isConstantTrue(isSgNotOp(e)->get_operand());
      default: return false;
    }
  }

  bool SageInterface::isCallToParticularFunction(SgFunctionDeclaration* decl,
  SgExpression* e) {
    SgFunctionCallExp* fc = isSgFunctionCallExp(e);
    if (!fc) return false;
    SgFunctionRefExp* fr = isSgFunctionRefExp(fc->get_function());
    return fr->get_symbol()->get_declaration() == decl;
  }

  bool SageInterface::isCallToParticularFunction(const std::string& qualifiedName, size_t
  arity, SgExpression* e) {
    SgFunctionCallExp* fc = isSgFunctionCallExp(e);
    if (!fc) return false;
    SgFunctionRefExp* fr = isSgFunctionRefExp(fc->get_function());
    string name =
  fr->get_symbol()->get_declaration()->get_qualified_name().getString();
    return (name == qualifiedName &&
  fc->get_args()->get_expressions().size() == arity);
  }

  SgExpression* SageInterface::copyExpression(SgExpression* e) 
  {
    return deepCopy(e);
  }

  SgStatement* SageInterface::copyStatement(SgStatement* s)
  {
    return deepCopy(s);
  }

  //----------------- add into AST tree --------------------
  void SageInterface::appendExpression(SgExprListExp *expList, SgExpression* exp)
  {
    ROSE_ASSERT(expList);
    ROSE_ASSERT(exp);
    expList->append_expression(exp);
    exp->set_parent(expList);
  }

  void SageInterface::appendExpressionList(SgExprListExp *expList, const std::vector<SgExpression*>& exp)
  {
    for (size_t i = 0; i < exp.size(); ++i)
      appendExpression(expList, exp[i]);
  }

  //TODO consider the difference between C++ and Fortran
  // fixup the scope of arguments,no symbols for nondefining function declaration's arguments
  void SageInterface::setParameterList(SgFunctionDeclaration * func,SgFunctionParameterList * paralist)
  {
    ROSE_ASSERT(func);
    ROSE_ASSERT(paralist);
  // Warning users if a paralist is being shared   
  if (paralist->get_parent() !=NULL) 
  {  
    cerr<<"Waring! Setting a used SgFunctionParameterList to function: "
    << (func->get_name()).getString()<<endl
    << " Sharing parameter lists can corrupt symbol tables!"<<endl
    << " Please use deepCopy() to get an exclusive parameter list for each function declaration!"<<endl;
//    ROSE_ASSERT(false);
  } 
  // Liao,2/5/2008  constructor of SgFunctionDeclaration will automatically generate SgFunctionParameterList, so be cautious when set new paralist!!
    if (func->get_parameterList() != NULL)
      if (func->get_parameterList() != paralist)
	 delete func->get_parameterList();
    func->set_parameterList(paralist);
    paralist->set_parent(func);

  }

static SgVariableSymbol * addArg(SgFunctionParameterList *paraList, SgInitializedName* initName,bool isPrepend)
{
  ROSE_ASSERT(paraList);
  ROSE_ASSERT(initName);
  if (isPrepend)
    paraList->prepend_arg(initName);
  else
    paraList->append_arg(initName);
  initName->set_parent(paraList);

  SgFunctionDeclaration* func_decl= isSgFunctionDeclaration(paraList->get_parent());
  SgScopeStatement* scope = NULL;
  if (func_decl)
  {
    if ((func_decl->get_definingDeclaration()) == func_decl )
    { //defining function declaration, set scope and symbol table
      SgFunctionDefinition* func_def = func_decl->get_definition();
      ROSE_ASSERT(func_def);
      scope = func_def;
    } // nondefining declaration, set scope only, currently set to decl's scope, TODO
    else  
      scope = func_decl->get_scope();
    //fix up declptr of the init name  
    initName->set_declptr(func_decl);  
  } //end if func_decl is available
  // ROSE_ASSERT (scope); -- scope may not be set because the function declaration may not have been inserted anywhere
  initName->set_scope(scope);
  if (scope) 
  {
    SgVariableSymbol* sym = new SgVariableSymbol(initName);
    scope->insert_symbol(initName->get_name(), sym);
    sym->set_parent(scope->get_symbol_table());
    return sym;
  } 
  else 
    return NULL;
}

SgVariableSymbol* SageInterface::appendArg(SgFunctionParameterList *paraList, SgInitializedName* initName)
{
  return addArg(paraList,initName,false);
}

SgVariableSymbol* SageInterface::prependArg(SgFunctionParameterList *paraList, SgInitializedName* initName)
{
  return addArg(paraList,initName,true);
}

void SageInterface::setPragma(SgPragmaDeclaration* decl, SgPragma *pragma)
{
  ROSE_ASSERT(decl);
  ROSE_ASSERT(pragma);
  if (decl->get_pragma()!=NULL) delete (decl->get_pragma());
  decl->set_pragma(pragma);
  pragma->set_parent(decl);
}

//! SageInterface::appendStatement()
//TODO should we ensureBasicBlockAsScope(scope) ? like ensureBasicBlockAsParent(targetStmt);
//It might be well legal to append the first and only statement in a scope!
  void SageInterface::appendStatement(SgStatement *stmt, SgScopeStatement* scope)
  {
   if (scope == NULL)
      scope = SageBuilder::topScopeStack();
    ROSE_ASSERT(stmt);
    ROSE_ASSERT(scope != NULL);

    #if 0
       //  case 3:
      // stmt may be copied from a variable declaration of another scope, symbol is missing
      //       after copying, no scope for the intialized name.
      // maybe a smarter copy mechnism can do this by itself.....
       // TODO move into a support function, useful for other statement insertion functions
      if (isSgVariableDeclaration(stmt))
      {
	SgInitializedNamePtrList namelist = isSgVariableDeclaration(stmt)->get_variables();
	SgInitializedNamePtrList::iterator i;
	for (i=namelist.begin(); i!=namelist.end(); i++)
	{
	  if ((*i)->get_scope() != scope) // this should indicate it comes right after copying
	 {
	   (*i)->set_scope(scope);
	   ROSE_ASSERT ((*i)->get_symbol_from_symbol_table() ==NULL); // no symbol yet
	 // patch symbol for the declartion copied
	   SgVariableSymbol*  symbol = new SgVariableSymbol(*i);
	    scope->insert_symbol((*i)->get_name(), symbol);
	 } // end if scope
	}// end for
      }
    #endif
    
    //catch-all for statement fixup 
   // Must fix it before insert it into the scope, 
    fixStatement(stmt,scope);

    //-----------------------
    // append the statement finally
    //scope->append_statement (stmt);
    scope->insertStatementInScope(stmt,false);
    stmt->set_parent(scope); // needed?

   // update the links after insertion!
    if (isSgFunctionDeclaration(stmt))
     updateDefiningNondefiningLinks(isSgFunctionDeclaration(stmt),scope);
  }

  void SageInterface::appendStatementList(const std::vector<SgStatement*>& stmts, SgScopeStatement* scope) {
    for (size_t i = 0; i < stmts.size(); ++i) {
      appendStatement(stmts[i], scope);
    }
  }
//!SageInterface::prependStatement()
  void SageInterface::prependStatement(SgStatement *stmt, SgScopeStatement* scope)
  {
   if (scope == NULL)
      scope = SageBuilder::topScopeStack();
    ROSE_ASSERT(scope != NULL);
    //TODO handle side effect like SageBuilder::appendStatement() does

   // Must fix it before insert it into the scope, 
   // otherwise assertions in insertStatementInScope() would fail
   fixStatement(stmt,scope); 

   scope->insertStatementInScope(stmt,true);
    // update the links after insertion!
   if (isSgFunctionDeclaration(stmt))
     updateDefiningNondefiningLinks(isSgFunctionDeclaration(stmt),scope);

  } //prependStatement()

  void SageInterface::prependStatementList(const std::vector<SgStatement*>& stmts, SgScopeStatement* scope) {
    for (size_t i = stmts.size(); i > 0; --i) {
      prependStatement(stmts[i - 1], scope);
    }
  }

  //TODO handle more side effect like SageBuilder::append_statement() does
  //Merge myStatementInsert()
  // insert  SageInterface::insertStatement()
  void SageInterface::insertStatement(SgStatement *targetStmt, SgStatement* newStmt, bool insertBefore)
  {

    ROSE_ASSERT(targetStmt &&newStmt);
    ROSE_ASSERT(targetStmt != newStmt); // should not share statement nodes!
    SgNode* parent = targetStmt->get_parent();
    if (parent==NULL)
    {
      cerr<<"Empty parent pointer for target statement. May be caused by the wrong order of target and new statements in insertStatement(targetStmt, newStmt)"<<endl;
      ROSE_ASSERT(parent);
    }

    // We now have single statement true/false body for IfStmt etc
    // However, IfStmt::insert_child() is ambiguous and not implemented
    // So we make SgBasicBlock out of the single statement and 
    // essentially call SgBasicBlock::insert_child() instead.
    // TODO: add test cases for If, variable, variable/struct inside if, etc 
    
    parent = ensureBasicBlockAsParent(targetStmt);
    // must get the new scope after ensureBasicBlockAsParent ()
    SgScopeStatement* scope= targetStmt->get_scope();
    ROSE_ASSERT(scope);

    newStmt->set_parent(targetStmt->get_parent());
    fixStatement(newStmt,scope);

    isSgStatement(parent)->insert_statement(targetStmt,newStmt,insertBefore);

    // update the links after insertion!
    if (isSgFunctionDeclaration(newStmt))
     updateDefiningNondefiningLinks(isSgFunctionDeclaration(newStmt),scope);
  }

  void SageInterface::insertStatementList(SgStatement *targetStmt, const std::vector<SgStatement*>& newStmts, bool insertBefore) {
    if (insertBefore) {
      for (size_t i = 0; i < newStmts.size(); ++i) {
        insertStatementBefore(targetStmt, newStmts[i]);
      }
    } else {
      for (size_t i = newStmts.size(); i > 0; --i) {
        insertStatementAfter(targetStmt, newStmts[i - 1]);
      }
    }
  }

  void SageInterface::insertStatementAfter(SgStatement *targetStmt, SgStatement* newStmt)
  {
    insertStatement(targetStmt,newStmt,false);
  }

  void SageInterface::insertStatementListAfter(SgStatement *targetStmt, const std::vector<SgStatement*>& newStmts)
  {
    insertStatementList(targetStmt,newStmts,false);
  }

  void SageInterface::insertStatementBefore(SgStatement *targetStmt, SgStatement* newStmt)
  {
    insertStatement(targetStmt,newStmt,true);
  }

  void SageInterface::insertStatementListBefore(SgStatement *targetStmt, const std::vector<SgStatement*>& newStmts)
  {
    insertStatementList(targetStmt,newStmts,true);
  }

  //a wrapper for set_expression(), set_operand(), set_operand_exp() etc
  // special concern for lvalue, parent, 
  // todo: warning overwritting existing operands
  void SageInterface::setOperand(SgExpression* target, SgExpression* operand)
  {
    ROSE_ASSERT(target);
    ROSE_ASSERT(operand);
    ROSE_ASSERT(target!=operand);
    switch (target->variantT()) 
    {
      case V_SgActualArgumentExpression:
        isSgActualArgumentExpression(target)->set_expression(operand);
        break;
      case V_SgAsmOp:
        isSgAsmOp(target)->set_expression(operand);
        break;
      case V_SgSizeOfOp:
        isSgSizeOfOp(target)->set_operand_expr(operand);
	break;
      case V_SgTypeIdOp:
        isSgTypeIdOp(target)->set_operand_expr(operand);
	break;
      case V_SgVarArgOp:
        isSgVarArgOp(target)->set_operand_expr(operand);
	break;
      case V_SgVarArgStartOneOperandOp:
        isSgVarArgStartOneOperandOp(target)->set_operand_expr(operand);
	break;
      default:
        if (isSgUnaryOp(target)!=NULL) isSgUnaryOp(target)->set_operand_i(operand);
	else 
	  { 
            cout<<"SageInterface::setOperand(): unhandled case for target expression of type "
	           <<target->class_name()<<endl; 
	    ROSE_ASSERT(false); 
	  }
    }// end switch
    operand->set_parent(target);
    markLhsValues(target);
  }

  // binary and SgVarArgCopyOp, SgVarArgStartOp
  void SageInterface::setLhsOperand(SgExpression* target, SgExpression* lhs)
  {
    ROSE_ASSERT(target);
    ROSE_ASSERT(lhs);
    ROSE_ASSERT(target!=lhs);
    bool hasrhs = false;

    SgVarArgCopyOp* varargcopy = isSgVarArgCopyOp(target);
    SgVarArgStartOp* varargstart = isSgVarArgStartOp(target);
    SgBinaryOp* binary = isSgBinaryOp(target);

    if (varargcopy!=NULL) 
    {  
      varargcopy->set_lhs_operand(lhs);
       if( varargcopy->get_rhs_operand()!=NULL) hasrhs= true;
    }
    else if(varargstart!=NULL) 
    {  
      varargstart->set_lhs_operand(lhs);
      if( varargstart->get_rhs_operand()!=NULL) hasrhs= true;
    }
    else if(binary!=NULL) 
    {  
      binary->set_lhs_operand(lhs);
      if( binary->get_rhs_operand()!=NULL) hasrhs= true;
    }
    else 
    {
      cout<<"SageInterface::setLhsOperand(): unhandled case for target expression of type "
                <<target->class_name()<<endl;
      ROSE_ASSERT(false);
    }
    lhs->set_parent(target);
// only when both lhs and rhs are available, can we set lvalue
// there is assertion(rhs!=NULL) in markLhsValues()
   if (hasrhs) 
      markLhsValues(target);
  }

  void SageInterface::setRhsOperand(SgExpression* target, SgExpression* rhs)
  {
    ROSE_ASSERT(target);
    ROSE_ASSERT(rhs);
    ROSE_ASSERT(target!=rhs);
    bool haslhs = false;

    SgVarArgCopyOp* varargcopy = isSgVarArgCopyOp(target);
    SgVarArgStartOp* varargstart = isSgVarArgStartOp(target);
    SgBinaryOp* binary = isSgBinaryOp(target);

    if (varargcopy!=NULL) 
    { 
       varargcopy->set_rhs_operand(rhs); 
       if( varargcopy->get_lhs_operand()!=NULL) haslhs= true;
    }
    else if(varargstart!=NULL) 
    {
      varargstart->set_rhs_operand(rhs);
      if( varargstart->get_lhs_operand()!=NULL) haslhs= true;
    }
    else if(binary!=NULL) 
    { 
      binary->set_rhs_operand(rhs);
      if( binary->get_lhs_operand()!=NULL) haslhs= true;
    }
    else
    {
      cout<<"SageInterface::setRhsOperand(): unhandled case for target expression of type "
                <<target->class_name()<<endl;
      ROSE_ASSERT(false);
    }
    rhs->set_parent(target);
// only when both lhs and rhs are available, can we set lvalue
   if (haslhs) 
      markLhsValues(target);
  }

//------------------------- AST repair----------------------------
//----------------------------------------------------------------
  void SageInterface::fixStructDeclaration(SgClassDeclaration* structDecl, SgScopeStatement* scope)
  {
    ROSE_ASSERT(structDecl);
    ROSE_ASSERT(scope);
    SgClassDeclaration* nondefdecl = isSgClassDeclaration(structDecl->get_firstNondefiningDeclaration());
    ROSE_ASSERT(nondefdecl);
    SgName name= structDecl->get_name();
    SgClassSymbol* mysymbol = scope->lookup_class_symbol(name);
    if (mysymbol==NULL) 
    {
      mysymbol = new SgClassSymbol(nondefdecl);
      ROSE_ASSERT(mysymbol);
      scope->insert_symbol(name, mysymbol);
      SgClassDeclaration* defdecl = isSgClassDeclaration(structDecl->get_definingDeclaration());
      ROSE_ASSERT(defdecl);
      defdecl->set_scope(scope);
      nondefdecl->set_scope(scope);

      defdecl->set_parent(scope);
      nondefdecl->set_parent(scope);
    }
  }
  void SageInterface::fixVariableDeclaration(SgVariableDeclaration* varDecl, SgScopeStatement* scope)
  {
    ROSE_ASSERT(varDecl);
    ROSE_ASSERT(scope);

    SgInitializedNamePtrList namelist = varDecl->get_variables();

    //avoid duplicated work
    if (namelist.size()>0) if (namelist[0]->get_scope()!=NULL) return;
    SgInitializedNamePtrList::iterator i;
    for (i=namelist.begin();i!=namelist.end();i++)
   {
      SgInitializedName *initName =*i;   
      ROSE_ASSERT(initName);   

      SgName name= initName->get_name();
      initName->set_scope(scope);
     // optional?
      varDecl->set_parent(scope);
      // symbol table
      SgVariableSymbol* varSymbol = scope->lookup_variable_symbol(name);
      if (varSymbol==NULL)
      {
	varSymbol = new SgVariableSymbol(initName);
	ROSE_ASSERT(varSymbol);   
	scope->insert_symbol(name, varSymbol);
      }
      else
      { // TODO consider prepend() and insert(), prev_decl_time is position dependent.
    //   cout<<"sageInterface.C:5130 debug: found a previous var declaration!!...."<<endl;     
	SgInitializedName* prev_decl = varSymbol->get_declaration();
	ROSE_ASSERT(prev_decl);
	initName->set_prev_decl_item(prev_decl);
      } //end if
    } //end for
  }

int SageInterface::fixVariableReferences(SgNode* root)
{
  ROSE_ASSERT(root);
  int counter=0;

  SgVarRefExp* varRef=NULL;
  Rose_STL_Container<SgNode*> reflist = NodeQuery::querySubTree(root, V_SgVarRefExp);
  for (Rose_STL_Container<SgNode*>::iterator i=reflist.begin();i!=reflist.end();i++)
  {
    varRef= isSgVarRefExp(*i);
    ROSE_ASSERT(varRef->get_symbol());
    SgInitializedName* initname= varRef->get_symbol()->get_declaration();
    if (initname->get_type()==SgTypeUnknown::createType())
      //    if ((initname->get_scope()==NULL) && (initname->get_type()==SgTypeUnknown::createType()))

    {
      SgName varName=initname->get_name();
      SgSymbol* realSymbol = lookupSymbolInParentScopes(varName,getScope(varRef));
      // should find a real symbol at this final fixing stage!
      if (realSymbol==NULL) 
      {
        cerr<<"Error: cannot find a symbol for "<<varName.getString()<<endl;
        ROSE_ASSERT(realSymbol);
      }
      // release placeholder initname and symbol
      ROSE_ASSERT(realSymbol!=(varRef->get_symbol()));

      delete initname; // TODO deleteTree(), release File_Info nodes etc.
      delete (varRef->get_symbol());

      varRef->set_symbol(isSgVariableSymbol(realSymbol));
      counter ++;
    }
  } // end for
  return counter;
}


//! fixup symbol table for SgLableStatement. Used Internally when the label is built without knowing its target scope. Both parameters cannot be NULL. 
/*
 * label statement has special scope: the closest function definition , not SgBasicBlock or others!
 */
void SageInterface::fixLabelStatement(SgLabelStatement* stmt, SgScopeStatement* scope)
{
   SgLabelStatement* label_stmt = isSgLabelStatement(stmt);
   ROSE_ASSERT(label_stmt); 
   SgName name = label_stmt->get_label();

   SgScopeStatement* label_scope = getEnclosingFunctionDefinition(scope,true);
   if (label_scope) //Should we assert this instead? No for bottom up AST building
    { 
     label_stmt->set_scope(label_scope);
     SgLabelSymbol* lsymbol = label_scope->lookup_label_symbol(name);
     if (!lsymbol)
      { 
        lsymbol= new SgLabelSymbol(label_stmt);
        ROSE_ASSERT(lsymbol);
        label_scope->insert_symbol(lsymbol->get_name(), lsymbol);
      }
    }// end label_scope   
} // fixLabelStatement()

//! A wrapper containing fixes (fixVariableDeclaration(),fixStructDeclaration(), fixLabelStatement(), etc) for all kinds statements.
void SageInterface::fixStatement(SgStatement* stmt, SgScopeStatement* scope)
{ 
  // fix symbol table
  if (isSgVariableDeclaration(stmt))
      fixVariableDeclaration(isSgVariableDeclaration(stmt), scope);
  if (isStructDeclaration(stmt))
      fixStructDeclaration(isSgClassDeclaration(stmt),scope);
  if (isSgLabelStatement(stmt)) 
      fixLabelStatement(isSgLabelStatement(stmt),scope);      

  // fix scope pointer for statements explicitly storing scope pointer 
  switch (stmt->variantT())
   {
     case V_SgEnumDeclaration: 
     case V_SgTemplateDeclaration:
     case V_SgTypedefDeclaration:
     case V_SgClassDeclaration:
     case V_SgFunctionDeclaration:
  //   case V_SgLabelStatement: 
  //   Label statement' scope is special, handled in fixLabelStatement()
      stmt->set_scope(scope);
      break;
    default:
      break;
   } // switch
  
} // fixStatement()

/*! Liao, 7/3/2008
 * Update a list of function declarations inside a scope according to a newly introduced one 
 *
 * Algorithm: 
 * iterate declaration list for the same functions
 * func is defining: 
 *       set_defining for all
 * func is nondefining: 
 *       is first ?  set_first_nondefining for all
 *       not the first ? set first nondefining for itself only
 */
void SageInterface::updateDefiningNondefiningLinks(SgFunctionDeclaration* func, SgScopeStatement* scope)
{
  ROSE_ASSERT(func&&scope);
  SgStatementPtrList stmtList, sameFuncList;
  //SgFunctionDeclaration* first_nondef = NULL;
  // Some annoying part of scope
  if (scope->containsOnlyDeclarations())
  {  
    SgDeclarationStatementPtrList declList = scope->getDeclarationList();
    SgDeclarationStatementPtrList::iterator i;
    for (i=declList.begin();i!=declList.end();i++)
      stmtList.push_back(*i);
  }
  else
    stmtList = scope->getStatementList();
  
  // Find the same function declaration list, including func itself
  SgStatementPtrList::iterator j;
  for (j=stmtList.begin();j!=stmtList.end();j++)
  {
    SgFunctionDeclaration* func_decl = isSgFunctionDeclaration(*j);
    if (func_decl)
    {
      if (isSameFunction(func_decl, func))
      {  
        // Assume all defining functions have definingdeclaration links set properly already!!
        //if ((first_nondef == NULL) && (func_decl->get_definingDeclaration() == NULL))
        //  first_nondef = func_decl; 
        sameFuncList.push_back(func_decl);
      }
    } // if (func_decl)
  } // for 
  
  if(func->get_definingDeclaration()==func)
  {
    for (j=sameFuncList.begin();j!=sameFuncList.end();j++)
      isSgFunctionDeclaration(*j)->set_definingDeclaration(func);
  }
  else if (func==isSgFunctionDeclaration(*(sameFuncList.begin()))) // is first_nondefining declaration
  { 
    for (j=sameFuncList.begin();j!=sameFuncList.end();j++)
      isSgFunctionDeclaration(*j)->set_firstNondefiningDeclaration(func);
  } else // is a following nondefining declaration, grab any other's first nondefining link then
  {
     func->set_firstNondefiningDeclaration(isSgFunctionDeclaration(*(sameFuncList.begin()))
                      ->get_firstNondefiningDeclaration());
  }// if
} // updateDefiningNondefiningLinks()

//---------------------------------------------------------------
PreprocessingInfo* SageInterface::attachComment(
           SgLocatedNode* target, const string& content,
           PreprocessingInfo::RelativePositionType  position /*=PreprocessingInfo::before*/,
           PreprocessingInfo::DirectiveType dtype /* PreprocessingInfo::CpreprocessorUnknownDeclaration */)
{
  ROSE_ASSERT(target); //dangling comment is not allowed

  PreprocessingInfo* result = NULL;
  PreprocessingInfo::DirectiveType mytype=dtype;
  string comment;

  // infer comment type from target's language
  if (mytype==0)
  {
    if (is_C_language()||is_C99_language ())
    {
       mytype = PreprocessingInfo::C_StyleComment;
       comment = "/* "+ content + " */";
    }
    else if (is_Cxx_language ())
    {
      mytype = PreprocessingInfo::CplusplusStyleComment;
      comment = "// "+ content;
    }
    else  // TODO :What about Fortran?
    {
      cout<<"Un-handled programming languages when building source comments.. "<<endl;
      ROSE_ASSERT(false);
    }
  }

  result = new PreprocessingInfo (mytype,comment, "transformation-generated", 0, 0, 0, position);
  ROSE_ASSERT(result);
  target->addToAttachedPreprocessingInfo(result);
  return result;
 }

  PreprocessingInfo* SageInterface::insertHeader(const string& filename, bool isSystemHeader /*=false*/, SgScopeStatement* scope /*=NULL*/)
  {
    bool successful = false;
    if (scope == NULL)
	scope = SageBuilder::topScopeStack();
    ROSE_ASSERT(scope);
    SgGlobal* globalScope = getGlobalScope(scope);
    ROSE_ASSERT(globalScope);

    PreprocessingInfo* result=NULL;
    string content;
    if (isSystemHeader)
      content = "#include <" + filename + "> \n";
    else
      content = "#include \"" + filename + "\" \n";

    SgDeclarationStatementPtrList & stmtList = globalScope->get_declarations ();
    if (stmtList.size()>0) // the source file is not empty
     { 
      for (SgDeclarationStatementPtrList::iterator j = stmtList.begin ();
	     j != stmtList.end (); j++)
      {
	    //must have this judgement, otherwise wrong file will be modified!
            //It could also be the transformation generated statements with #include attached
	if ( ((*j)->get_file_info ())->isSameFile(globalScope->get_file_info ())||
              ((*j)->get_file_info ())->isTransformation() 
           )
	 {
       result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration,
                content, "Transformation generated",0, 0, 0, PreprocessingInfo::before);
	   ROSE_ASSERT(result);
	   (*j)->addToAttachedPreprocessingInfo(result);
           successful = true;
	    break;
	  }
      }
     }
    else // empty file, attach it after SgGlobal,TODO it is not working for unknown reason!!
     {
       result = new PreprocessingInfo(PreprocessingInfo::CpreprocessorIncludeDeclaration,
                content, "Transformation generated",0, 0, 0, PreprocessingInfo::after);
       ROSE_ASSERT(result);
       globalScope->addToAttachedPreprocessingInfo(result);
       successful = true;
    }
    // must be inserted once somehow
    ROSE_ASSERT(successful==true);
    return result;
  }


//! Attach an arbitrary string to a located node. A workaround to insert irregular statements or vendor-specific attributes. We abuse CpreprocessorDefineDeclaration for this purpose.
PreprocessingInfo* SageInterface::attachArbitraryText(SgLocatedNode* target, 
                const std::string & text,
               PreprocessingInfo::RelativePositionType position/*=PreprocessingInfo::before*/)
{
    ROSE_ASSERT(target != NULL); //dangling #define xxx is not allowed in the ROSE AST
    PreprocessingInfo* result = NULL;
    PreprocessingInfo::DirectiveType mytype = PreprocessingInfo::CpreprocessorDefineDeclaration;
    result = new PreprocessingInfo (mytype,text, "transformation-generated", 0, 0, 0, position);
    ROSE_ASSERT(result);
    target->addToAttachedPreprocessingInfo(result);
    return result;
}



//! If the given statement contains any break statements in its body, add a
//! new label below the statement and change the breaks into gotos to that
//! new label.
void SageInterface::changeBreakStatementsToGotos(SgStatement* loopOrSwitch) {
  using namespace SageBuilder;
  SgStatement* body = NULL;
  if (isSgWhileStmt(loopOrSwitch) || isSgDoWhileStmt(loopOrSwitch) ||
      isSgForStatement(loopOrSwitch)) {
    body = SageInterface::getLoopBody(isSgScopeStatement(loopOrSwitch));
  } else if (isSgSwitchStatement(loopOrSwitch)) {
    body = isSgSwitchStatement(loopOrSwitch)->get_body();
  }
  ROSE_ASSERT (body);
  std::vector<SgBreakStmt*> breaks = SageInterface::findBreakStmts(body);
  if (!breaks.empty()) {
    static int breakLabelCounter = 0;
    SgLabelStatement* breakLabel =
      buildLabelStatement("breakLabel" +
StringUtility::numberToString(++breakLabelCounter),
                          buildBasicBlock(),
                          isSgScopeStatement(loopOrSwitch->get_parent()));
    insertStatement(loopOrSwitch, breakLabel, false);
    for (size_t j = 0; j < breaks.size(); ++j) {
      SgGotoStatement* newGoto = buildGotoStatement(breakLabel);

  isSgStatement(breaks[j]->get_parent())->replace_statement(breaks[j],
  newGoto);
	newGoto->set_parent(breaks[j]->get_parent());
      }
    }
  }

  bool SageInterface::isStructDeclaration(SgNode* node)
  {
    ROSE_ASSERT(node!=NULL);
    SgClassDeclaration *decl = isSgClassDeclaration(node);
    if (decl==NULL) 
      return false;
    else
       return (decl->get_class_type() == SgClassDeclaration::e_struct)? true:false;
  }

//----------------------------
// Sometimes, the preprocessing info attached to a declaration has to be
// moved 'up' if another declaration is inserted before it.
// This is a workaround for the broken LowLevelRewrite::insert() and the private
// LowLevelRewrite::reassociatePreprocessorDeclarations()
//
// input: 
//     *stmt_dst: the new inserted declaration 
//     *stmt_src: the existing declaration with preprocessing information
// tasks:
//     judge if stmt_src has propressingInfo with headers, ifdef, etc..
//     add them into stmt_dst
//     delete them from stmt_dst   
// More general usage: move preprocessingInfo of stmt_src to stmt_dst, should used before any
//           LoweLevel::remove(stmt_src)
void SageInterface::moveUpPreprocessingInfo(SgStatement * stmt_dst, SgStatement * stmt_src,
      PreprocessingInfo::RelativePositionType position/*=PreprocessingInfo::undef*/)
{
  ROSE_ASSERT(stmt_src != NULL);
  ROSE_ASSERT(stmt_dst != NULL);
  AttachedPreprocessingInfoType* infoList=stmt_src->getAttachedPreprocessingInfo();
  AttachedPreprocessingInfoType* infoToRemoveList = new AttachedPreprocessingInfoType();

  if (infoList == NULL) return;
  for (Rose_STL_Container<PreprocessingInfo*>::iterator i= (*infoList).begin(); 
      i!=(*infoList).end();i++)
  {
    PreprocessingInfo * info=dynamic_cast<PreprocessingInfo *> (*i);
    ROSE_ASSERT(info != NULL);

    if ( (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorIncludeDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorDefineDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorUndefDeclaration)||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfdefDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfndefDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorIfDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorElseDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorElifDeclaration )||
        (info->getTypeOfDirective()==PreprocessingInfo::C_StyleComment)||
        (info->getTypeOfDirective()==PreprocessingInfo::CpreprocessorEndifDeclaration )
       )
    { 
      if (position == PreprocessingInfo::undef) 
      {
        stmt_dst->addToAttachedPreprocessingInfo(info,PreprocessingInfo::after);
        (*infoToRemoveList).push_back(*i);
      } else if (info->getRelativePosition()==position)
      {
        stmt_dst->addToAttachedPreprocessingInfo(info,PreprocessingInfo::after);
        (*infoToRemoveList).push_back(*i);
      } // if position
    } // end if 
  }// end for

  // Remove the element from the list of comments at the current astNode
  AttachedPreprocessingInfoType::iterator j;
  for (j = (*infoToRemoveList).begin(); j != (*infoToRemoveList).end(); j++)
    infoList->erase( find(infoList->begin(),infoList->end(),*j) );
} // moveUpPreprocessingInfo()

SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfFor(SgForStatement* fs) 
{
  SgStatement* b = fs->get_loop_body();
  if (!isSgBasicBlock(b)) {
    b = SageBuilder::buildBasicBlock(b);
    fs->set_loop_body(b);
    b->set_parent(fs);
  }
  ROSE_ASSERT (isSgBasicBlock(b));
  return isSgBasicBlock(b);
}

  SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfWhile(SgWhileStmt* fs) {
    SgStatement* b = fs->get_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b);
      fs->set_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfDoWhile(SgDoWhileStmt* fs) {
    SgStatement* b = fs->get_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b);
      fs->set_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfSwitch(SgSwitchStatement* fs) {
    SgStatement* b = fs->get_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b);
      fs->set_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgBasicBlock* SageInterface::ensureBasicBlockAsTrueBodyOfIf(SgIfStmt* fs) {
    SgStatement* b = fs->get_true_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b);
      fs->set_true_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgBasicBlock* SageInterface::ensureBasicBlockAsFalseBodyOfIf(SgIfStmt* fs) {
    SgStatement* b = fs->get_false_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b); // This works if b is NULL as well (producing an empty block)
      fs->set_false_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgBasicBlock* SageInterface::ensureBasicBlockAsBodyOfCatch(SgCatchOptionStmt* fs) {
    SgStatement* b = fs->get_body();
    if (!isSgBasicBlock(b)) {
      b = SageBuilder::buildBasicBlock(b);
      fs->set_body(b);
      b->set_parent(fs);
    }
    ROSE_ASSERT (isSgBasicBlock(b));
    return isSgBasicBlock(b);
  }

  SgStatement* SageInterface::ensureBasicBlockAsParent(SgStatement* s) {
  //SgBasicBlock* ensureBasicBlockAsParent(SgStatement* s) {
    SgStatement* p = isSgStatement(s->get_parent());
    ROSE_ASSERT (p);
    switch (p->variantT()) {
      case V_SgBasicBlock: return isSgBasicBlock(p);
      case V_SgForStatement: {
        if (isSgForStatement(p)->get_loop_body() == s)
          return ensureBasicBlockAsBodyOfFor(isSgForStatement(p));
        else ROSE_ASSERT (false);
      }
      case V_SgWhileStmt: {
        if (isSgWhileStmt(p)->get_body() == s)
          return ensureBasicBlockAsBodyOfWhile(isSgWhileStmt(p));
        else ROSE_ASSERT (false);
      }
      case V_SgDoWhileStmt: {
        if (isSgDoWhileStmt(p)->get_body() == s)
          return ensureBasicBlockAsBodyOfDoWhile(isSgDoWhileStmt(p));
        else ROSE_ASSERT (false);
      }
      case V_SgSwitchStatement: {
        if (isSgSwitchStatement(p)->get_body() == s)
          return ensureBasicBlockAsBodyOfSwitch(isSgSwitchStatement(p));
        else ROSE_ASSERT (false);
      }
      case V_SgCatchOptionStmt: {
        if (isSgCatchOptionStmt(p)->get_body() == s)
          return ensureBasicBlockAsBodyOfCatch(isSgCatchOptionStmt(p));
        else ROSE_ASSERT (false);
      }
      case V_SgIfStmt: {
        if (isSgIfStmt(p)->get_true_body() == s)
          return ensureBasicBlockAsTrueBodyOfIf(isSgIfStmt(p));
        else if (isSgIfStmt(p)->get_false_body() == s)
          return ensureBasicBlockAsFalseBodyOfIf(isSgIfStmt(p));
        else ROSE_ASSERT (false);
      }
      default: {
        // Liao, 7/3/2008 We allow other conditions to fall through, 
        // they are legal parents with list of statements as children. 
        //cerr << "Unhandled parent block:"<< p->class_name() << endl;
        // ROSE_ASSERT (!"Bad parent in ensureBasicBlockAsParent");
       break;
      }
    }
    return p;
  }

  void SageInterface::changeAllLoopBodiesToBlocks(SgNode* top) {
    struct Visitor: public AstSimpleProcessing {
      virtual void visit(SgNode* n) {
        switch (n->variantT()) {
          case V_SgForStatement: {
            ensureBasicBlockAsBodyOfFor(isSgForStatement(n));
            break;
          }
          case V_SgWhileStmt: {
            ensureBasicBlockAsBodyOfWhile(isSgWhileStmt(n));
            break;
          }
          case V_SgDoWhileStmt: {
            ensureBasicBlockAsBodyOfDoWhile(isSgDoWhileStmt(n));
            break;
          }
          case V_SgIfStmt: {
            ensureBasicBlockAsTrueBodyOfIf(isSgIfStmt(n));
            ensureBasicBlockAsFalseBodyOfIf(isSgIfStmt(n));
            break;
          }
          case V_SgCatchOptionStmt: {
            ensureBasicBlockAsBodyOfCatch(isSgCatchOptionStmt(n));
            break;
          }
          default: break;
        }
      }
    };
    Visitor().traverse(top, postorder);
  }


// Replace a given expression with a list of statements produced by a
// generator.  The generator, when given a variable as input, must produce
// some code which leaves its result in the given variable.  The output
// from the generator is then inserted into the original program in such a
// way that whenever the expression had previously been evaluated, the
// statements produced by the generator are run instead and their result is
// used in place of the expression.
// Assumptions: not currently traversing from or the statement it is in
void
SageInterface::replaceExpressionWithStatement(SgExpression* from, StatementGenerator* to)
   {
  // DQ (3/11/2006): The problem here is that the test expression for a "for loop" (SgForStmt)
  // is assumed to be a SgExpression.  This was changed in Sage III as part of a bugfix and so 
  // the original assumptions upon which this function was based are not incorrect, hence the bug!
  // Note that a number of cases were changed when this fix was made to SageIII (see documentation 
  // for SgScopeStatement).

     SgStatement*           enclosingStatement      = getStatementOfExpression(from);
     SgExprStatement*       exprStatement           = isSgExprStatement(enclosingStatement);

     SgForStatement*        forStatement            = isSgForStatement(enclosingStatement);
     SgReturnStmt*          returnStatement         = isSgReturnStmt(enclosingStatement);
     SgVariableDeclaration* varDeclarationStatement = isSgVariableDeclaration(enclosingStatement);


  // DQ (3/11/2006): Bugfix for special cases of conditional that are either SgStatement or SgExpression IR nodes.

     ROSE_ASSERT (exprStatement || forStatement || returnStatement || varDeclarationStatement);

     if (varDeclarationStatement)
        {
          replaceSubexpressionWithStatement(from, to);
        }
       else
        {
          SgExpression* root = getRootOfExpression(from);
          ROSE_ASSERT (root);
       // printf ("root = %p \n",root);
             {
               if (forStatement && forStatement->get_increment() == root)
                  {
                 // printf ("Convert step of for statement \n");
                 // Convert step of for statement
                 // for (init; test; e) body; (where e contains from) becomes
                 // for (init; test; ) {
                 //   body (with "continue" changed to "goto label");
                 //   label: e;
                 // }
                 // std::cout << "Converting for step" << std::endl;
		    SgExprStatement* incrStmt = SageBuilder::buildExprStatement(forStatement->get_increment());
                    forStatement->get_increment()->set_parent(incrStmt);

                    SageInterface::addStepToLoopBody(forStatement, incrStmt);
		    SgNullExpression* ne = buildNullExpression();
                    forStatement->set_increment(ne);
                    ne->set_parent(forStatement);
                    replaceSubexpressionWithStatement(from, to);
                  }
                 else
                  {
                    SgStatement* enclosingStmtParent = isSgStatement(enclosingStatement->get_parent());
                    assert (enclosingStmtParent);
                    SgWhileStmt* whileStatement = isSgWhileStmt(enclosingStmtParent);
                    SgDoWhileStmt* doWhileStatement = isSgDoWhileStmt(enclosingStmtParent);
                    SgIfStmt* ifStatement = isSgIfStmt(enclosingStmtParent);
                    SgSwitchStatement* switchStatement = isSgSwitchStatement(enclosingStmtParent);
                    SgForStatement* enclosingForStatement = isSgForStatement(enclosingStmtParent);
                  if (enclosingForStatement && enclosingForStatement->get_test() == exprStatement)
                     {
                    // printf ("Found the test in the for loop \n");
                    // ROSE_ASSERT(false);

                    // Convert test of for statement:
                    // for (init; e; step) body; (where e contains from) becomes
                    // for (init; true; step) {
                    //   bool temp;
                    //   temp = e;
                    //   if (!temp) break;
                    //   body;
                    // }
                    // in which "temp = e;" is rewritten further
                    // std::cout << "Converting for test" << std::endl;
                       pushTestIntoBody(enclosingForStatement);
                       replaceSubexpressionWithStatement(from, to);
                     }
                  else if (whileStatement && whileStatement->get_condition() == exprStatement)
                     {
                    // printf ("Convert while statements \n");
                    // Convert while statement:
                    // while (e) body; (where e contains from) becomes
                    // while (true) {
                    //   bool temp;
                    //   temp = e;
                    //   if (!temp) break;
                    //   body;
                    // }
                    // in which "temp = e;" is rewritten further
                    // std::cout << "Converting while test" << std::endl;
                       pushTestIntoBody(whileStatement);
                    // FixSgTree(whileStatement);
                       replaceSubexpressionWithStatement(from, to);
                     } 
                  else if (doWhileStatement && doWhileStatement->get_condition() == exprStatement)
                    {
         // printf ("Convert do-while statements \n");
                   // Convert do-while statement:
                   // do body; while (e); (where e contains from) becomes
                   // {bool temp = true;
                   //  do {
                   //    body (with "continue" changed to "goto label";
                   //    label:
                   //    temp = e;} while (temp);}
                   // in which "temp = e;" is rewritten further
                   // std::cout << "Converting do-while test" << std::endl;
                      SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();
                   // printf ("Building IR node #14: new SgBasicBlock = %p \n",new_statement);
                      assert (doWhileStatement->get_parent());
                      new_statement->set_parent(doWhileStatement->get_parent());
                      myStatementInsert(doWhileStatement, new_statement, false);
                      SageInterface::myRemoveStatement(doWhileStatement);
                      SgName varname = "rose__temp"; // Does not need to be unique, but must not be used in user code anywhere
                      SgAssignInitializer* assignInitializer = buildAssignInitializer( 
                          buildBoolValExp(true)); 
                      //SageInterface::getBoolType(doWhileStatement));
                      SgVariableDeclaration* new_decl = buildVariableDeclaration(
                        varname, buildBoolType(), assignInitializer, new_statement);

                      SgInitializedName* initname = new_decl->get_variables().back();
                      initname->set_scope(new_statement);

         // DQ (12/14/2006): set the parent of the SgAssignInitializer to the variable (SgInitializedName).
            assignInitializer->set_parent(initname);

                      SgVariableSymbol* varsym = new SgVariableSymbol(initname);
                      new_statement->insert_symbol(varname, varsym);
                      varsym->set_parent(new_statement->get_symbol_table());
                      SageInterface::appendStatement(new_decl, new_statement);
                      SageInterface::appendStatement(doWhileStatement, new_statement);
                      assert (varsym);
                      SgCastExp* castExp1 = buildCastExp(root,buildBoolType());
		      SgVarRefExp* vr = buildVarRefExp(varsym);
                      vr->set_lvalue(true);

                      SgExprStatement* temp_setup = SageBuilder::buildAssignStatement(vr, castExp1);

                      SageInterface::addStepToLoopBody(doWhileStatement, temp_setup);
                      SgVarRefExp* varsymVr = buildVarRefExp(varsym);

                      SgExprStatement* condStmt = SageBuilder::buildExprStatement(varsymVr);
                      varsymVr->set_parent(condStmt);
                      doWhileStatement->set_condition(condStmt);
                      condStmt->set_parent(doWhileStatement);
                      replaceSubexpressionWithStatement(from, to);
                    }
                  else if (ifStatement && ifStatement->get_conditional() == exprStatement)
                    {
                      SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();
                   // printf ("Building IR node #15: new SgBasicBlock = %p \n",new_statement);
                      assert (ifStatement->get_parent());
                      new_statement->set_parent(ifStatement->get_parent());
                      myStatementInsert(ifStatement, new_statement, false);
                      SageInterface::myRemoveStatement(ifStatement);
                      SgName varname = "rose__temp"; // Does not need to be unique, but must not be used in user code anywhere
                      SgBoolValExp* trueVal = buildBoolValExp(true);

                      SgAssignInitializer* ai = buildAssignInitializer(trueVal);

                      SgVariableDeclaration* new_decl = buildVariableDeclaration(varname, 
                         buildBoolType(), ai,new_statement);
                      SgInitializedName* initname = new_decl->get_variables().back();
                      ai->set_parent(initname);
                      initname->set_scope(new_statement);
                      SgVariableSymbol* varsym = new SgVariableSymbol(initname);
                      new_statement->insert_symbol(varname, varsym);
                      varsym->set_parent(new_statement->get_symbol_table());
                      SageInterface::appendStatement(new_decl, new_statement);
                      ifStatement->set_parent(new_statement);
                      assert (varsym);

                                        SgCastExp* castExp2 = SageBuilder::buildCastExp(root, SageInterface::getBoolType(ifStatement));
		      SgVarRefExp* vr = buildVarRefExp(varsym);
                      vr->set_lvalue(true);
                      SgExprStatement* temp_setup = SageBuilder::buildAssignStatement(vr, castExp2 );
                      SageInterface::appendStatement(temp_setup, new_statement);
                      SageInterface::appendStatement(ifStatement, new_statement);
                      SgVarRefExp* vr2 = SageBuilder::buildVarRefExp(varsym);
                      SgExprStatement* es = SageBuilder::buildExprStatement(vr2);
                      ifStatement->set_conditional(es);
                      es->set_parent(ifStatement);
                      replaceSubexpressionWithStatement(from, to);
                    }
                  else if (switchStatement && switchStatement->get_item_selector() == exprStatement)
                    {
                      SgExpression* switchCond = exprStatement->get_expression();
                      ROSE_ASSERT (switchCond);
                      SgBasicBlock* new_statement = SageBuilder::buildBasicBlock();
                   // printf ("Building IR node #15: new SgBasicBlock = %p \n",new_statement);
                      assert (switchStatement->get_parent());
                      new_statement->set_parent(switchStatement->get_parent());
                      myStatementInsert(switchStatement, new_statement, false);
                      SageInterface::myRemoveStatement(switchStatement);
                      SgName varname = "rose__temp"; // Does not need to be unique, but must not be used in user code anywhere
                      switchCond->set_parent(NULL);
                      SgVariableDeclaration* new_decl = SageBuilder::buildVariableDeclaration(varname, switchCond->get_type(), SageBuilder::buildAssignInitializer(switchCond), new_statement);
                      SgVariableSymbol* varsym = SageInterface::getFirstVarSym(new_decl);
                      SageInterface::appendStatement(new_decl, new_statement);
                      switchStatement->set_parent(new_statement);
                      assert (varsym);

                   
                      SageInterface::appendStatement(switchStatement, new_statement);
                      SgVarRefExp* vr2 = SageBuilder::buildVarRefExp(varsym);
                      SgExprStatement* es = SageBuilder::buildExprStatement(vr2);
                      switchStatement->set_item_selector(es);
                      es->set_parent(switchStatement);
                      replaceSubexpressionWithStatement(from, to);
                    }
                  else
                    {
                      // printf ("Handles expression and return statements \n");
                      // Handles expression and return statements
                      // std::cout << "Converting other statement" << std::endl;
                      replaceSubexpressionWithStatement(from, to);
                    }
                  }
             }
        }

  // printf ("Leaving replaceExpressionWithStatement(from,to) \n");
   }

//! Replace a given expression with a list of statements produced by a
//! generator.  The generator, when given a variable as input, must produce
//! some code which leaves its result in the given variable.  The output
//! from the generator is then inserted into the original program in such a
//! way that whenever the expression had previously been evaluated, the
//! statements produced by the generator are run instead and their result is
//! used in place of the expression.
//! Assumptions: not currently traversing from or the statement it is in

// Similar to replaceExpressionWithStatement, but with more restrictions.
// Assumptions: from is not within the test of a loop or if
//              not currently traversing from or the statement it is in
void SageInterface::replaceSubexpressionWithStatement(SgExpression* from, StatementGenerator* to)
   {

     SgStatement* stmt = getStatementOfExpression(from);


     if (isSgExprStatement(stmt))
        {
          SgExpression* top = getRootOfExpression(from);


          if (top == from)
             {
               SgStatement* generated = to->generate(0);
               isSgStatement(stmt->get_parent())->replace_statement(stmt, generated);
               generated->set_parent(stmt->get_parent());
               return;
             }
            else
             {
               if (isSgAssignOp(top) && isSgAssignOp(top)->get_rhs_operand() == from)
                  {
                    SgAssignOp* t = isSgAssignOp(top);
                    SgStatement* generated = to->generate(t->get_lhs_operand());
                    isSgStatement(stmt->get_parent())->replace_statement(stmt, generated);
                    generated->set_parent(stmt->get_parent());
                    return;
                  }
                 else
                  {
                 // printf ("In replaceSubexpressionWithStatement(): Statement not generated \n");
                  }
             }
        }

  // cout << "1: " << getStatementOfExpression(from)->unparseToString() << endl;
     SgAssignInitializer* init = splitExpression(from);
  // cout << "2: " << getStatementOfExpression(from)->unparseToString() << endl;
     convertInitializerIntoAssignment(init);
  // cout << "3: " << getStatementOfExpression(from)->unparseToString() << endl;
  // cout << "3a: " << getStatementOfExpression(from)->get_parent()->unparseToString() << endl;
     SgExprStatement* new_stmt = isSgExprStatement(getStatementOfExpression(from));
     assert (new_stmt != NULL); // Should now have this form because of conversion
     replaceAssignmentStmtWithStatement(new_stmt, to);

  // printf ("In replaceSubexpressionWithStatement: new_stmt = %p = %s \n",new_stmt,new_stmt->class_name().c_str());
  // cout << "4: " << getStatementOfExpression(from)->get_parent()->unparseToString() << endl;
   }


  // Liao, 6/27/2008
  //Tasks
  //  find all return statements
  //  rewrite it to  temp = expression; return temp; if expression is not a single value.
  //  insert s right before 'return xxx;'
  int SageInterface::instrumentEndOfFunction(SgFunctionDeclaration * func, SgStatement* s) 
  {
    int result = 0;
    ROSE_ASSERT(func&&s);
    vector<SgReturnStmt* > stmts = findReturnStmts(func); 
    vector<SgReturnStmt*>::iterator i;
    for (i=stmts.begin();i!=stmts.end();i++)
    {
      SgReturnStmt* cur_stmt = isSgReturnStmt(*i); 
      ROSE_ASSERT(cur_stmt);
      SgExpression * exp = cur_stmt->get_expression();
      bool needRewrite = !(isSgValueExp(exp));
      if (needRewrite)
      { 
        splitExpression(exp);
      }
       // avoid reusing the statement
      if (result>=1 ) 
         s = copyStatement(s);
       insertStatementBefore(cur_stmt,s);
      result ++;
    } // for
    if (stmts.size()==0 ) // a function without any return at all, 
    {
      SgBasicBlock * body = func->get_definition()->get_body();
      if (body== NULL) 
       { 
         cout<<"In instrumentEndOfFunction(), found an empty function body.! "<<endl;
         ROSE_ASSERT(false);
       } 
      appendStatement(s,body);
      result ++;
    }  
    return result;  
  } // instrumentEndOfFunction

  bool SageInterface::isStatic(SgDeclarationStatement* stmt)
  {
    ROSE_ASSERT(stmt);
    return ((stmt->get_declarationModifier()).get_storageModifier()).isStatic();
  } // isStatic()

  //! Set a declaration as static 
  void SageInterface::setStatic(SgDeclarationStatement* stmt)
  {
    ROSE_ASSERT(stmt);
    return ((stmt->get_declarationModifier()).get_storageModifier()).setStatic();
  }

  bool SageInterface::isExtern(SgDeclarationStatement* stmt)
  {
    ROSE_ASSERT(stmt);
    return ((stmt->get_declarationModifier()).get_storageModifier()).isExtern();
  } // isExtern()

  
  //! Set a declaration as extern
  void SageInterface::setExtern(SgDeclarationStatement* stmt)
  {
    ROSE_ASSERT(stmt);
    return ((stmt->get_declarationModifier()).get_storageModifier()).setExtern();
  }


  unsigned long long SageInterface::getIntegerConstantValue(SgValueExp* expr) {
    switch (expr->variantT()) {
      case V_SgCharVal: return (long long)(isSgCharVal(expr)->get_value());
      case V_SgUnsignedCharVal: return isSgUnsignedCharVal(expr)->get_value();
      case V_SgShortVal: return (long long)(isSgShortVal(expr)->get_value());
      case V_SgUnsignedShortVal: return isSgUnsignedShortVal(expr)->get_value();
      case V_SgIntVal: return (long long)(isSgIntVal(expr)->get_value());
      case V_SgUnsignedIntVal: return isSgUnsignedIntVal(expr)->get_value();
      case V_SgLongIntVal: return (long long)(isSgLongIntVal(expr)->get_value());
      case V_SgUnsignedLongVal: return isSgUnsignedLongVal(expr)->get_value();
      case V_SgLongLongIntVal: return isSgLongLongIntVal(expr)->get_value();
      case V_SgUnsignedLongLongIntVal: return isSgUnsignedLongLongIntVal(expr)->get_value();
      default: ROSE_ASSERT (!"Bad kind in getIntegerConstantValue");
    }
  }


// tps : 28 Oct 2008 - support for finding the main interpretation
 SgAsmInterpretation* 
 SageInterface::getMainInterpretation(SgAsmFile* file) {
   SgAsmInterpretationPtrList& interps = file->get_interpretations();
   if (interps.size()==1)
     return interps[0];
   SgAsmInterpretation* mainInt=NULL;
   SgAsmInterpretationPtrList::iterator it = interps.begin();
   for (;it!=interps.end();++it) {
     mainInt = *it;
     SgAsmGenericHeader* header = mainInt->get_header();
     if (isSgAsmPEFileHeader(header))
       break;
   }
   ROSE_ASSERT(mainInt);
   return mainInt;
 }
