
// Put non-generated Aterm support code here.

// #include "rosePublicConfig.h"

// #include "aterm1.h"
// #include "aterm2.h"

#define LAZY_WRAPPING_MACRO false

namespace AtermSupport 
   {
  // DQ (10/5/2014): This is the part of the latest version of ATerm support (now generated by ROSETTA).
#if 0
     class AtermToNodeConverter 
        {
          public:
            // std::map<std::string, std::list<LinkUpdater*> > idUpdates;

            // map<string, SgNode*> targetLocations;
               std::map<std::string, SgScopeStatement*> translationScopeMap;
               std::map<std::string, SgType*> translationTypeMap;
               std::map<std::string, SgDeclarationStatement*> translationDeclarationMap;
               std::map<std::string, SgInitializedName*> translationInitializedNameMap;

               void updateScopeMap (std::string key, SgScopeStatement* scope);
               SgScopeStatement* lookupScope (std::string key);

               void updateDeclarationMap (std::string key, SgDeclarationStatement* scope);
               SgDeclarationStatement* lookupDeclaration (std::string key);

               void updateTypeMap (std::string key, SgType* scope);
               SgType* lookupType (std::string key);

               void updateInitializedNameMap (std::string key, SgInitializedName* scope);
               SgInitializedName* lookupInitializedName (std::string key);

               SgNode* convertAtermToNode(ATerm term);

          private:
               template <class TranslationMap, class TranslationMapElement>
               void updateMap_support (std::string key, TranslationMap & translationMap, TranslationMapElement* node);

               template <class TranslationMap, class TranslationMapElement>
               TranslationMapElement* lookupMap_support (std::string key, TranslationMap & tranlationMap);
        };
#else
     extern std::map<std::string, SgNode*> translationNodeMap;

     extern std::map<std::string, SgScopeStatement*> translationScopeMap;
     extern std::map<std::string, SgType*> translationTypeMap;
     extern std::map<std::string, SgDeclarationStatement*> translationDeclarationMap;
     extern std::map<std::string, SgInitializedName*> translationInitializedNameMap;
#endif

     void initializeTypeSystem();

     std::string aterm_type_name( ATerm term );

     std::string uniqueId(SgNode* n);

  // This supports generation of strings from addresses (mostly so that the SgAsm support will compile).
  // I don't think that Aterms have a data type for unsigned 64-bit integers.
     std::string uniqueId(uint64_t n);

  // This supports generation of strings from rose_rva_t (so that the SgAsm support will compile).
  // I don't think it is clear how to implement this function (but we can worry about the binary analysis 
  // use of Aterms later).
     std::string uniqueId(const rose_rva_t & n);

  // This supports generation of strings from registers (so that the SgAsm support will compile).
  // I don't think it is clear how to implement this function (but we can worry about the binary analysis 
  // use of Aterms later).
     std::string uniqueId(Rose::BinaryAnalysis::RegisterDescriptor);

     ATerm convertFileInfoToAterm(Sg_File_Info* fi);
     Sg_File_Info* getAtermFileInfo(ATerm term, std::string annotationName);

     ATerm convertVectorToAterm(const std::vector<ATerm>& v, int start, int len);

     template <typename Iter>
     ATerm convertRangeToAterm(Iter b, Iter e);

     template <typename Iter>
     ATerm convertSgNodeRangeToAterm(Iter b, Iter e);

     std::string getShortVariantName(VariantT var);

     ATerm getTraversalChildrenAsAterm(SgNode* n);

     ATerm convertNodeToAterm(SgNode* n);

     ATerm getAtermAnnotation(ATerm term, char* annotation_name );

  // Function for reading aterms and converting them to ROSE AST IR nodes.
     SgNode* generate_AST(ATerm & term);

  // Generate a list of aterms from the input aterm.
     std::vector<ATerm> getAtermList(ATerm ls);

     std::string getAtermStringAttribute(ATerm term, const std::string & annotationName );
     int getAtermIntegerAttribute(ATerm term, const std::string & annotationName );

  // DQ (10/8/2014): I don't think we need these (Aterm type system is not rich enough to justify these).
  // int getAtermEnumAttribute(ATerm term, const std::string & annotationName );
  // std::string getAtermNodeNameAttribute(ATerm term, const std::string & annotationName );

  // This function is special in that it accesses (internal) maps to lookup the SgNode 
  // using a sting that is saved as an annotation in the aterm and then as a key into the map.
  // Note that this should work where we see declarations before they are referenced, but 
  // will likely have to be fixed up after the translation where this rule is relaxed in C++
  // classes (which may refer to constructs before they are declared (and is always an issue)).
     SgNode* getAtermNodeAttribute(ATerm term, const std::string & annotationName );

     SgType* getAtermTypeNodeAttribute (ATerm term, const std::string & annotationName );
     SgScopeStatement* getAtermScopeNodeAttribute (ATerm term, const std::string & annotationName );

  // Not as clear how to implement this since it is difficult to inspect the class hierarhy in ROSETTA.
     SgDeclarationStatement* getAtermDeclarationNodeAttribute (ATerm term, const std::string & annotationName );

   }


#ifdef ROSE_USE_ROSE_ATERM_SUPPORT

template <typename Iter>
ATerm 
AtermSupport::convertRangeToAterm(Iter b, Iter e) 
   {
     ATermList ls = ATmakeList0();
     for (; b != e; ++b) 
        {
          ls = ATappend(ls, *b);
        }

     return ATmake("<term>", ls);
   }

template <typename Iter>
ATerm AtermSupport::convertSgNodeRangeToAterm(Iter b, Iter e) 
   {
     bool lazyWrapping = LAZY_WRAPPING_MACRO;

     ROSE_ASSERT(lazyWrapping == false);

     if ( (b != e) && (*b != NULL) )
        {
#if 0
          SgNode* parent = (*b)->get_parent();
          if (parent == NULL)
             {
               printf ("warning: parent == NULL: *b = %p = %s \n",*b,(*b)->class_name().c_str());
             }
#endif
       // ROSE_ASSERT(parent != NULL);
#if 0
          printf ("In AtermSupport::convertSgNodeRangeToAterm(): Building an ATerm list for (*b)->get_parent() = %p = %s \n",parent,(parent != NULL) ? parent->class_name().c_str() : "NULL");
#endif
        }
       else
        {
#if 0
          printf ("In AtermSupport::convertSgNodeRangeToAterm(): Building an empty list \n");
#endif
        }

     ATermList ls = ATmakeList0();
     for (; b != e; ++b) 
        {
          ATerm child_term = NULL;
          if (lazyWrapping == true)
             {
               child_term = ATmake("lazyWrap(<str>)","lazyWrap");
             }
            else
             {
#if 0
               printf ("In AtermSupport::convertSgNodeRangeToAterm(): Calling convertNodeToAterm() *b = %p = %s\n",*b,(*b != NULL) ? (*b)->class_name().c_str() : "NULL");
#endif
               child_term = convertNodeToAterm(*b);

#if 0
            // I think we are generating invalid aterms in some cases.
               int atermKind = ATgetType(child_term);
               printf ("In AtermSupport::convertSgNodeRangeToAterm(): child_term: atermKind = %d = %s \n",atermKind,aterm_type_name(child_term).c_str());
#endif
#if 0
               printf ("In AtermSupport::convertSgNodeRangeToAterm(): DONE: Calling convertNodeToAterm() *b = %p = %s \n",*b,(*b != NULL) ? (*b)->class_name().c_str() : "NULL");
#endif
#if 0
               cout << "In AtermSupport::convertSgNodeRangeToAterm(): DONE: output child_term: -> " << ATwriteToString(child_term) << endl;
#endif
             }

#if 0
          printf ("In AtermSupport::convertSgNodeRangeToAterm(): Calling ATappend() \n");
#endif
       // ls = ATappend(ls,convertNodeToAterm(*b));
          ls = ATappend(ls,child_term);

#if 0
       // I think we are generating invalid aterms in some cases.
          int atermKind = ATgetType(ls);
       // printf ("In AtermSupport::convertSgNodeRangeToAterm(): ATappend(): atermKind = %d = %s \n",atermKind,aterm_type_name(ls).c_str());
          printf ("In AtermSupport::convertSgNodeRangeToAterm(): ATappend(): atermKind = %d \n",atermKind);
#endif
#if 0
          printf ("In AtermSupport::convertSgNodeRangeToAterm(): DONE: Calling ATappend() \n");
#endif
        }

#if 0
     printf ("In AtermSupport::convertSgNodeRangeToAterm(): building aterm to return \n");
#endif

  // return ATmake("<term>", ls);
     ATerm returnTerm = ATmake("<term>", ls);

#if 0
  // I think we are generating invalid aterms in some cases.
     int atermKind = ATgetType(returnTerm);
     printf ("In AtermSupport::convertSgNodeRangeToAterm(): atermKind = %d = %s \n",atermKind,aterm_type_name(returnTerm).c_str());
#endif
#if 0
     printf ("In AtermSupport::convertSgNodeRangeToAterm(): returnTerm = %p ls = %p \n",returnTerm,ls);
#endif
#if 0
     cout << "AtermSupport::convertSgNodeRangeToAterm(): returning the aterm -> " << ATwriteToString(returnTerm) << endl;
#endif

     return returnTerm;
   }

// endif for ROSE_USE_ROSE_ATERM_SUPPORT
#endif

