//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                       D O   N O T   E D I T                                                      //
//------------------------------------------------------------------------------------------------------------------//
//                                                                                                                  //
// This file was generated automatically from Intel PDF documentation. Its purpose is to intialize the ROSE x86     //
// assembler with information about how to encode each x86 instruction.                                             //
//                                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "rose.h"

/* Generated by ./IntelAssemblyBuilder from 
 * x86-InstructionSetReference-AM.pdf 
 * x86-InstructionSetReference-NZ.pdf 
 * ExtraInstructions.txt */
void
AssemblerX86::initAssemblyRules()
{
    AssemblerX86::InsnDefn *defn = NULL;

    //------------------------------------------------------------------------------------------------------------------
    // The following definitions are from x86-InstructionSetReference-AM.pdf, version March 2009.
    //------------------------------------------------------------------------------------------------------------------


    //--- page 3-26 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 37             AAA            Invalid        Valid      ASCII adjust AL after addition.
    defn = new InsnDefn("aaa",    x86_aaa,     0x01, 0x37, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-28");
    define(defn);

    //--- page 3-28 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // D5 0A          AAD               Invalid        Valid      ASCII adjust AX before division.
    defn = new InsnDefn("aad",    x86_aad,     0x01, 0xd50a, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-28");
    define(defn);
    // D5 ib          (No mnemonic)     Invalid        Valid      Adjust AX before division to
    //                                                            number base imm8.
    defn = new InsnDefn("aad",    x86_aad,     0x01, 0xd5, od_ib);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-30");
    define(defn);

    //--- page 3-30 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // D4 0A          AAM              Invalid    Valid          ASCII adjust AX after multiply.
    defn = new InsnDefn("aam",    x86_aam,     0x01, 0xd40a, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-30");
    define(defn);
    // D4 ib          (No mnemonic)    Invalid    Valid          Adjust AX after multiply to number
    //                                                           base imm8.
    defn = new InsnDefn("aam",    x86_aam,     0x01, 0xd4, od_ib);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-32");
    define(defn);

    //--- page 3-32 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 3F             AAS            Invalid        Valid      ASCII adjust AL after subtraction.
    defn = new InsnDefn("aas",    x86_aas,     0x01, 0x3f, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);

    //--- page 3-34 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 14 ib              ADC AL, imm8     Valid    Valid      Add with carry imm8 to AL.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x14, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 15 iw              ADC AX, imm16 Valid       Valid      Add with carry imm16 to AX.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x15, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 15 id              ADC EAX,         Valid    Valid      Add with carry imm32 to EAX.
    //                    imm32
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x15, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX.W + 15 id      ADC RAX,         Valid    N.E.       Add with carry imm32 sign
    //                    imm32                                extended to 64-bits to RAX.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x15, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 80 /2 ib           ADC r/m8,        Valid    Valid      Add with carry imm8 to r/m8.
    //                    imm8
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x80, od_e2|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX + 80 /2 ib     ADC r/m8*,       Valid    N.E.       Add with carry imm8 to r/m8.
    //                    imm8
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x80, od_rex|od_e2|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 81 /2 iw           ADC r/m16,       Valid    Valid      Add with carry imm16 to r/m16.
    //                    imm16
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x81, od_e2|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 81 /2 id           ADC r/m32,       Valid    Valid      Add with CF imm32 to r/m32.
    //                    imm32
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x81, od_e2|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX.W + 81 /2 id   ADC r/m64,       Valid    N.E.       Add with CF imm32 sign
    //                    imm32                                extended to 64-bits to r/m64.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x81, od_rexw|od_e2|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 83 /2 ib           ADC r/m16,       Valid    Valid      Add with CF sign-extended
    //                    imm8                                 imm8 to r/m16.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x83, od_e2|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 83 /2 ib           ADC r/m32,       Valid    Valid      Add with CF sign-extended
    //                    imm8                                 imm8 into r/m32.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x83, od_e2|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX.W + 83 /2 ib   ADC r/m64,       Valid    N.E.       Add with CF sign-extended
    //                    imm8                                 imm8 into r/m64.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x83, od_rexw|od_e2|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 10 /r              ADC r/m8, r8     Valid    Valid      Add with carry byte register to
    //                                                         r/m8.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x10, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX + 10 /r        ADC r/m8*, r8*   Valid    N.E.       Add with carry byte register to
    //                                                         r/m64.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x10, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 11 /r              ADC r/m16, r16 Valid      Valid      Add with carry r16 to r/m16.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x11, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 11 /r              ADC r/m32, r32 Valid      Valid      Add with CF r32 to r/m32.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x11, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX.W + 11 /r      ADC r/m64, r64 Valid      N.E.       Add with CF r64 to r/m64.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x11, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 12 /r              ADC r8, r/m8     Valid    Valid      Add with carry r/m8 to byte
    //                                                         register.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x12, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // REX + 12 /r        ADC r8*, r/m8*   Valid    N.E.       Add with carry r/m64 to byte
    //                                                         register.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x12, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-34");
    define(defn);
    // 13 /r              ADC r16, r/m16 Valid      Valid      Add with carry r/m16 to r16.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x13, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-35");
    define(defn);
    //  13 /r               ADC r32, r/m32 Valid           Valid           Add with CF r/m32 to r32.
    defn = new InsnDefn("adc",    x86_adc,     0x03, 0x13, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-35");
    define(defn);
    //  REX.W + 13 /r       ADC r64, r/m64 Valid          N.E.             Add with CF r/m64 to r64.
    defn = new InsnDefn("adc",    x86_adc,     0x02, 0x13, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);

    //--- page 3-37 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  04 ib                ADD AL, imm8           Valid           Valid            Add imm8 to AL.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x04, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  05 iw                ADD AX, imm16          Valid           Valid            Add imm16 to AX.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x05, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  05 id                ADD EAX, imm32         Valid           Valid            Add imm32 to EAX.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x05, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX.W + 05 id        ADD RAX, imm32         Valid           N.E.             Add imm32 sign-
    //                                                                               extended to 64-bits
    //                                                                               to RAX.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x05, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  80 /0 ib             ADD r/m8, imm8         Valid           Valid            Add imm8 to r/m8.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x80, od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX + 80 /0 ib       ADD r/m8*, imm8        Valid           N.E.             Add sign-extended
    //                                                                               imm8 to r/m64.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x80, od_rex|od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  81 /0 iw             ADD r/m16, imm16       Valid           Valid            Add imm16 to r/m16.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x81, od_e0|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  81 /0 id             ADD r/m32, imm32       Valid           Valid            Add imm32 to r/m32.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x81, od_e0|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX.W + 81 /0 id     ADD r/m64, imm32       Valid           N.E.             Add imm32 sign-
    //                                                                               extended to 64-bits
    //                                                                               to r/m64.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x81, od_rexw|od_e0|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  83 /0 ib             ADD r/m16, imm8        Valid           Valid            Add sign-extended
    //                                                                               imm8 to r/m16.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x83, od_e0|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  83 /0 ib             ADD r/m32, imm8        Valid           Valid            Add sign-extended
    //                                                                               imm8 to r/m32.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x83, od_e0|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX.W + 83 /0 ib     ADD r/m64, imm8        Valid           N.E.             Add sign-extended
    //                                                                               imm8 to r/m64.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x83, od_rexw|od_e0|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  00 /r                ADD r/m8, r8           Valid           Valid            Add r8 to r/m8.
    //                                  *    *
    defn = new InsnDefn("add",    x86_add,     0x03, 0x00, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX + 00 /r          ADD r/m8 , r8          Valid           N.E.             Add r8 to r/m8.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x00, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  01 /r                ADD r/m16, r16         Valid           Valid            Add r16 to r/m16.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x01, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  01 /r                ADD r/m32, r32         Valid           Valid            Add r32 to r/m32.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x01, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX.W + 01 /r        ADD r/m64, r64         Valid           N.E.             Add r64 to r/m64.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x01, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  02 /r                ADD r8, r/m8           Valid           Valid            Add r/m8 to r8.
    //                              *        *
    defn = new InsnDefn("add",    x86_add,     0x03, 0x02, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX + 02 /r          ADD r8 , r/m8          Valid           N.E.             Add r/m8 to r8.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x02, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  03 /r                ADD r16, r/m16         Valid           Valid            Add r/m16 to r16.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x03, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  03 /r                ADD r32, r/m32         Valid           Valid            Add r/m32 to r32.
    defn = new InsnDefn("add",    x86_add,     0x03, 0x03, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-37");
    define(defn);
    //  REX.W + 03 /r        ADD r64, r/m64         Valid           N.E.             Add r/m64 to r64.
    defn = new InsnDefn("add",    x86_add,     0x02, 0x03, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-40");
    define(defn);

    //--- page 3-40 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 66 0F 58 /r    ADDPD xmm1,      Valid      Valid          Add packed double-precision floating-
    //                xmm2/m128                                  point values from xmm2/m128 to
    //                                                           xmm1.
    defn = new InsnDefn("addpd",  x86_addpd,   0x03, 0x660f58, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-43");
    define(defn);

    //--- page 3-43 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F 58 /r      ADDPS xmm1, xmm2/m128           Valid      Valid        Add packed single-precision
    //                                                                        floating-point values from
    //                                                                        xmm2/m128 to xmm1.
    defn = new InsnDefn("addps",  x86_addps,   0x03, 0x0f58, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-46");
    define(defn);

    //--- page 3-46 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // F2 0F 58 /r    ADDSD xmm1, xmm2/m64        Valid     Valid            Add the low double-
    //                                                                       precision floating-point
    //                                                                       value from xmm2/m64 to
    //                                                                       xmm1.
    defn = new InsnDefn("addsd",  x86_addsd,   0x03, 0xf20f58, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-49");
    define(defn);

    //--- page 3-49 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  F3 0F 58 /r      ADDSS xmm1, xmm2/m32            Valid    Valid         Add the low single-
    //                                                                          precision floating-point
    //                                                                          value from xmm2/m32 to
    //                                                                          xmm1.
    defn = new InsnDefn("addss",  x86_addss,   0x03, 0xf30f58, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-52");
    define(defn);

    //--- page 3-52 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 66 0F D0 /r    ADDSUBPD xmm1, xmm2/m128      Valid       Valid          Add/subtract
    //                                                                         double-precision
    //                                                                         floating-point values
    //                                                                         from xmm2/m128
    //                                                                         to xmm1.
    defn = new InsnDefn("addsubpd", x86_addsubpd, 0x03, 0x660fd0, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-56");
    define(defn);

    //--- page 3-56 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // F2 0F D0 /r    ADDSUBPS xmm1, xmm2/m128             Valid     Valid                Add/subtract single-
    //                                                                                    precision floating-
    //                                                                                    point values from
    //                                                                                    xmm2/m128 to
    //                                                                                    xmm1.
    defn = new InsnDefn("addsubps", x86_addsubps, 0x03, 0xf20fd0, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);

    //--- page 3-60 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 24 ib            AND AL, imm8           Valid         Valid         AL AND imm8.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x24, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 25 iw            AND AX, imm16          Valid         Valid         AX AND imm16.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x25, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 25 id            AND EAX, imm32         Valid         Valid         EAX AND imm32.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x25, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX.W + 25 id    AND RAX, imm32         Valid         N.E.          RAX AND imm32 sign-
    //                                                                     extended to 64-bits.
    defn = new InsnDefn("and",    x86_and,     0x02, 0x25, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 80 /4 ib         AND r/m8, imm8         Valid         Valid         r/m8 AND imm8.
    //                              *
    defn = new InsnDefn("and",    x86_and,     0x03, 0x80, od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX + 80 /4 ib   AND r/m8 , imm8        Valid         N.E.          r/m64 AND imm8 (sign-
    //                                                                     extended).
    defn = new InsnDefn("and",    x86_and,     0x02, 0x80, od_rex|od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 81 /4 iw         AND r/m16, imm16       Valid         Valid         r/m16 AND imm16.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x81, od_e4|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 81 /4 id         AND r/m32, imm32       Valid         Valid         r/m32 AND imm32.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x81, od_e4|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX.W + 81 /4    AND r/m64, imm32       Valid         N.E.          r/m64 AND imm32 sign
    // id                                                                  extended to 64-bits.
    defn = new InsnDefn("and",    x86_and,     0x02, 0x81, od_rexw|od_e4|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 83 /4 ib         AND r/m16, imm8        Valid         Valid         r/m16 AND imm8 (sign-
    //                                                                     extended).
    defn = new InsnDefn("and",    x86_and,     0x03, 0x83, od_e4|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 83 /4 ib         AND r/m32, imm8        Valid         Valid         r/m32 AND imm8 (sign-
    //                                                                     extended).
    defn = new InsnDefn("and",    x86_and,     0x03, 0x83, od_e4|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX.W + 83 /4    AND r/m64, imm8        Valid         N.E.          r/m64 AND imm8 (sign-
    // ib                                                                  extended).
    defn = new InsnDefn("and",    x86_and,     0x02, 0x83, od_rexw|od_e4|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 20 /r            AND r/m8, r8           Valid         Valid         r/m8 AND r8.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x20, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX + 20 /r      AND r/m8*, r8*         Valid         N.E.          r/m64 AND r8 (sign-
    //                                                                     extended).
    defn = new InsnDefn("and",    x86_and,     0x02, 0x20, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 21 /r            AND r/m16, r16         Valid         Valid         r/m16 AND r16.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x21, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 21 /r            AND r/m32, r32         Valid         Valid         r/m32 AND r32.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x21, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX.W + 21 /r    AND r/m64, r64         Valid         N.E.          r/m64 AND r32.
    defn = new InsnDefn("and",    x86_and,     0x02, 0x21, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 22 /r            AND r8, r/m8           Valid         Valid         r8 AND r/m8.
    //                          *       *
    defn = new InsnDefn("and",    x86_and,     0x03, 0x22, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX + 22 /r      AND r8 , r/m8          Valid         N.E.          r/m64 AND r8 (sign-
    //                                                                     extended).
    defn = new InsnDefn("and",    x86_and,     0x02, 0x22, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 23 /r            AND r16, r/m16         Valid         Valid         r16 AND r/m16.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x23, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // 23 /r            AND r32, r/m32         Valid         Valid         r32 AND r/m32.
    defn = new InsnDefn("and",    x86_and,     0x03, 0x23, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-60");
    define(defn);
    // REX.W + 23 /r    AND r64, r/m64         Valid         N.E.          r64 AND r/m64.
    defn = new InsnDefn("and",    x86_and,     0x02, 0x23, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-63");
    define(defn);

    //--- page 3-63 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  66 0F 54 /r ANDPD xmm1,            Valid      Valid          Bitwise logical AND of xmm2/m128 and
    //              xmm2/m128                                        xmm1.
    defn = new InsnDefn("andpd",  x86_andpd,   0x03, 0x660f54, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-65");
    define(defn);

    //--- page 3-65 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F 54 /r     ANDPS xmm1, xmm2/m128 Valid                Valid               Bitwise logical AND of
    //                                                                              xmm2/m128 and xmm1.
    defn = new InsnDefn("andps",  x86_andps,   0x03, 0x0f54, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-67");
    define(defn);

    //--- page 3-67 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  66 0F 55 /r     ANDNPD xmm1, xmm2/m128             Valid      Valid              Bitwise logical AND
    //                                                                                   NOT of xmm2/m128
    //                                                                                   and xmm1.
    defn = new InsnDefn("andnpd", x86_andnpd,  0x03, 0x660f55, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-69");
    define(defn);

    //--- page 3-69 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F 55 /r      ANDNPS xmm1, xmm2/m128 Valid                Valid          Bitwise logical AND NOT of
    //                                                                           xmm2/m128 and xmm1.
    defn = new InsnDefn("andnps", x86_andnps,  0x03, 0x0f55, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-71");
    define(defn);

    //--- page 3-71 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  63 /r          ARPL r/m16, r16       N. E.    Valid      Adjust RPL of r/m16 to not less
    //                                                           than RPL of r16.
    defn = new InsnDefn("arpl",   x86_arpl,    0x01, 0x63, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-73");
    define(defn);

    //--- page 3-73 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  66 0F 3A 0D      BLENDPD xmm1,   Valid            Valid        Select packed DP-FP values from
    //  /r ib            xmm2/m128, imm8                               xmm1 and xmm2/m128 from mask
    //                                                                 specified in imm8 and store the
    //                                                                 values into xmm1.
    defn = new InsnDefn("blendpd", x86_blendpd, 0x03, 0x660f3a0d, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-75");
    define(defn);

    //--- page 3-75 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  66 0F 3A 0C     BLENDPS xmm1,          Valid     Valid         Select packed single precision
    //  /r ib           xmm2/m128,                                     floating-point values from xmm1 and
    //                  imm8                                           xmm2/m128 from mask specified in
    //                                                                 imm8 and store the values into
    //                                                                 xmm1.
    defn = new InsnDefn("blendps", x86_blendps, 0x03, 0x660f3a0c, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-78");
    define(defn);

    //--- page 3-78 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 66 0F 38 15 BLENDVPD xmm1,     Valid           Valid         Select packed DP FP values
    // /r          xmm2/m128 , <XMM0>                               from xmm1 and xmm2 from
    //                                                              mask specified in XMM0 and
    //                                                              store the values in xmm1.
    defn = new InsnDefn("blendvpd", x86_blendvpd, 0x03, 0x660f3815, od_modrm, od_xmm, od_xmm_m128, od_XMM0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-81");
    define(defn);

    //--- page 3-81 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  66 0F 38      BLENDVPS xmm1,    Valid             Valid        Select packed single precision
    //  14 /r         xmm2/m128, <XMM0>                                floating-point values from xmm1
    //                                                                 and xmm2/m128 from mask
    //                                                                 specified in XMM0 and store the
    //                                                                 values into xmm1.
    defn = new InsnDefn("blendvps", x86_blendvps, 0x03, 0x660f3814, od_modrm, od_xmm, od_xmm_m128, od_XMM0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-84");
    define(defn);

    //--- page 3-84 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 62 /r          BOUND r16, m16&16     Invalid   Valid           Check if r16 (array index) is
    //                                                                within bounds specified by
    //                                                                m16&16.
    defn = new InsnDefn("bound",  x86_bound,   0x01, 0x62, od_modrm, od_r16, od_m16a16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-84");
    define(defn);
    // 62 /r          BOUND r32, m32&32     Invalid   Valid           Check if r32 (array index) is
    //                                                                within bounds specified by
    //                                                                m16&16.
    defn = new InsnDefn("bound",  x86_bound,   0x01, 0x62, od_modrm, od_r32, od_m32a32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-87");
    define(defn);

    //--- page 3-87 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F BC /r              BSF r16, r/m16   Valid    Valid          Bit scan forward on r/m16.
    defn = new InsnDefn("bsf",    x86_bsf,     0x03, 0x0fbc, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-87");
    define(defn);
    //  0F BC /r              BSF r32, r/m32   Valid    Valid          Bit scan forward on r/m32.
    defn = new InsnDefn("bsf",    x86_bsf,     0x03, 0x0fbc, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-87");
    define(defn);
    //  REX.W + 0F BC         BSF r64, r/m64   Valid    N.E.           Bit scan forward on r/m64.
    defn = new InsnDefn("bsf",    x86_bsf,     0x02, 0x0fbc, od_rexw, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-89");
    define(defn);

    //--- page 3-89 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F BD /r              BSR r16, r/m16   Valid    Valid         Bit scan reverse on r/m16.
    defn = new InsnDefn("bsr",    x86_bsr,     0x03, 0x0fbd, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-89");
    define(defn);
    //  0F BD /r              BSR r32, r/m32   Valid    Valid         Bit scan reverse on r/m32.
    defn = new InsnDefn("bsr",    x86_bsr,     0x03, 0x0fbd, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-89");
    define(defn);
    //  REX.W + 0F BD         BSR r64, r/m64   Valid    N.E.          Bit scan reverse on r/m64.
    defn = new InsnDefn("bsr",    x86_bsr,     0x02, 0x0fbd, od_rexw, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-91");
    define(defn);

    //--- page 3-91 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F C8+rd          BSWAP r32          Valid*     Valid      Reverses the byte order of a 32-
    //                                                             bit register.
    defn = new InsnDefn("bswap",  x86_bswap,   0x03, 0x0fc8, od_rd, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-91");
    define(defn);
    //  REX.W + 0F        BSWAP r64           Valid     N.E.       Reverses the byte order of a 64-
    //  C8+rd                                                      bit register.
    defn = new InsnDefn("bswap",  x86_bswap,   0x02, 0x0fc8, od_rexw|od_rd, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);

    //--- page 3-93 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F A3                     BT r/m16, r16      Valid    Valid          Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x03, 0x0fa3, od_none, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);
    //  0F A3                     BT r/m32, r32      Valid    Valid          Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x03, 0x0fa3, od_none, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);
    //  REX.W + 0F A3             BT r/m64, r64      Valid    N.E.           Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x02, 0x0fa3, od_rexw, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);
    //  0F BA /4 ib               BT r/m16, imm8     Valid    Valid          Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x03, 0x0fba, od_e4|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);
    //  0F BA /4 ib               BT r/m32, imm8     Valid    Valid          Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x03, 0x0fba, od_e4|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-93");
    define(defn);
    //  REX.W + 0F BA /4 ib       BT r/m64, imm8     Valid    N.E.           Store selected bit in CF
    //                                                                       flag.
    defn = new InsnDefn("bt",     x86_bt,      0x02, 0x0fba, od_rexw|od_e4|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);

    //--- page 3-96 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    // 0F BB                 BTC r/m16, r16     Valid    Valid          Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x03, 0x0fbb, od_none, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);
    // 0F BB                 BTC r/m32, r32     Valid    Valid          Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x03, 0x0fbb, od_none, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);
    // REX.W + 0F BB         BTC r/m64, r64     Valid    N.E.           Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x02, 0x0fbb, od_rexw, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);
    // 0F BA /7 ib           BTC r/m16, imm8    Valid    Valid          Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x03, 0x0fba, od_e7|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);
    // 0F BA /7 ib           BTC r/m32, imm8    Valid    Valid          Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x03, 0x0fba, od_e7|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-96");
    define(defn);
    // REX.W + 0F BA /7 ib   BTC r/m64, imm8    Valid    N.E.           Store selected bit in CF flag
    //                                                                  and complement.
    defn = new InsnDefn("btc",    x86_btc,     0x02, 0x0fba, od_rexw|od_e7|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);

    //--- page 3-99 of x86-InstructionSetReference-AM.pdf --------------------------------------------------------------
    //  0F B3                   BTR r/m16, r16   Valid     Valid          Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x03, 0x0fb3, od_none, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);
    //  0F B3                   BTR r/m32, r32   Valid     Valid          Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x03, 0x0fb3, od_none, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);
    //  REX.W + 0F B3           BTR r/m64, r64   Valid     N.E.           Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x02, 0x0fb3, od_rexw, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);
    //  0F BA /6 ib             BTR r/m16, imm8 Valid      Valid          Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x03, 0x0fba, od_e6|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);
    //  0F BA /6 ib             BTR r/m32, imm8 Valid      Valid          Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x03, 0x0fba, od_e6|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-99");
    define(defn);
    //  REX.W + 0F BA /6 ib     BTR r/m64, imm8 Valid      N.E.           Store selected bit in CF
    //                                                                    flag and clear.
    defn = new InsnDefn("btr",    x86_btr,     0x02, 0x0fba, od_rexw|od_e6|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);

    //--- page 3-102 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F AB                 BTS r/m16, r16      Valid       Valid        Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x03, 0x0fab, od_none, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);
    // 0F AB                 BTS r/m32, r32      Valid       Valid        Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x03, 0x0fab, od_none, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);
    // REX.W + 0F AB         BTS r/m64, r64      Valid       N.E.         Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x02, 0x0fab, od_rexw, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);
    // 0F BA /5 ib           BTS r/m16, imm8     Valid       Valid        Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x03, 0x0fba, od_e5|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);
    // 0F BA /5 ib           BTS r/m32, imm8     Valid       Valid        Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x03, 0x0fba, od_e5|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-102");
    define(defn);
    // REX.W + 0F BA /5 ib   BTS r/m64, imm8     Valid       N.E.         Store selected bit in CF
    //                                                                    flag and set.
    defn = new InsnDefn("bts",    x86_bts,     0x02, 0x0fba, od_rexw|od_e5|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);

    //--- page 3-105 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  E8 cw                CALL rel16    N.S.      Valid      Call near, relative, displacement
    //                                                          relative to next instruction.
    defn = new InsnDefn("call",   x86_call,    0x01, 0xe8, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  E8 cd                CALL rel32    Valid     Valid      Call near, relative, displacement
    //                                                          relative to next instruction. 32-bit
    //                                                          displacement sign extended to 64-bits
    //                                                          in 64-bit mode.
    defn = new InsnDefn("call",   x86_call,    0x03, 0xe8, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  FF /2                CALL r/m16    N.E.      Valid      Call near, absolute indirect, address
    //                                                          given in r/m16.
    defn = new InsnDefn("call",   x86_call,    0x01, 0xff, od_e2, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  FF /2                CALL r/m32    N.E.      Valid      Call near, absolute indirect, address
    //                                                          given in r/m32.
    defn = new InsnDefn("call",   x86_call,    0x01, 0xff, od_e2, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  FF /2                CALL r/m64    Valid     N.E.       Call near, absolute indirect, address
    //                                                          given in r/m64.
    defn = new InsnDefn("call",   x86_call,    0x02, 0xff, od_e2, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  9A cd                CALL          Invalid   Valid      Call far, absolute, address given in
    //                       ptr16:16                           operand.
    defn = new InsnDefn("call",   x86_farcall, 0x01, 0x9a, od_cd, od_ptr16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  9A cp                CALL          Invalid   Valid      Call far, absolute, address given in
    //                       ptr16:32                           operand.
    defn = new InsnDefn("call",   x86_farcall, 0x01, 0x9a, od_cp, od_ptr16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  FF /3                CALL m16:16 Valid       Valid      Call far, absolute indirect address given
    //                                                          in m16:16.
    //                                                          In 32-bit mode: if selector points to a
    //                                                          gate, then RIP = 32-bit zero extended
    //                                                          displacement taken from gate; else RIP
    //                                                          = zero extended 16-bit offset from far
    //                                                          pointer referenced in the instruction.
    defn = new InsnDefn("call",   x86_farcall, 0x03, 0xff, od_e3, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  FF /3                CALL m16:32 Valid       Valid      In 64-bit mode: If selector points to a
    //                                                          gate, then RIP = 64-bit displacement
    //                                                          taken from gate; else RIP = zero
    //                                                          extended 32-bit offset from far
    //                                                          pointer referenced in the instruction.
    defn = new InsnDefn("call",   x86_farcall, 0x03, 0xff, od_e3, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-105");
    define(defn);
    //  REX.W + FF /3        CALL m16:64 Valid       N.E.       In 64-bit mode: If selector points to a
    //                                                          gate, then RIP = 64-bit displacement
    //                                                          taken from gate; else RIP = 64-bit
    //                                                          offset from far pointer referenced in
    //                                                          the instruction.
    defn = new InsnDefn("call",   x86_farcall, 0x02, 0xff, od_rexw|od_e3, od_m16_64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-123");
    define(defn);

    //--- page 3-123 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  98             CBW             Valid        Valid              AX  sign-extend of AL.
    defn = new InsnDefn("cbw",    x86_cbw,     0x03, 0x98, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-123");
    define(defn);
    //  98             CWDE            Valid        Valid              EAX  sign-extend of AX.
    defn = new InsnDefn("cwde",   x86_cwde,    0x03, 0x98, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-123");
    define(defn);
    //  REX.W + 98     CDQE            Valid        N.E.               RAX  sign-extend of EAX.
    defn = new InsnDefn("cdqe",   x86_cdqe,    0x02, 0x98, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-124");
    define(defn);

    //--- page 3-124 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F8              CLC                Valid      Valid          Clear CF flag.
    defn = new InsnDefn("clc",    x86_clc,     0x03, 0xf8, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-125");
    define(defn);

    //--- page 3-125 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  FC               CLD                 Valid       Valid          Clear DF flag.
    defn = new InsnDefn("cld",    x86_cld,     0x03, 0xfc, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-126");
    define(defn);

    //--- page 3-126 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F AE /7        CLFLUSH m8       Valid       Valid               Flushes cache line
    //                                                                  containing m8.
    defn = new InsnDefn("clflush", x86_clflush, 0x03, 0x0fae, od_e7, od_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-128");
    define(defn);

    //--- page 3-128 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // FA              CLI                Valid          Valid         Clear interrupt flag; interrupts disabled
    //                                                                 when interrupt flag cleared.
    defn = new InsnDefn("cli",    x86_cli,     0x03, 0xfa, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-131");
    define(defn);

    //--- page 3-131 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 06           CLTS                  Valid       Valid             Clears TS flag in CR0.
    defn = new InsnDefn("clts",   x86_clts,    0x03, 0x0f06, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-133");
    define(defn);

    //--- page 3-133 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F5               CMC                     Valid       Valid         Complement CF flag.
    defn = new InsnDefn("cmc",    x86_cmc,     0x03, 0xf5, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);

    //--- page 3-134 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 47 /r           CMOVA r16, r/m16    Valid    Valid      Move if above (CF=0 and
    //                                                            ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x03, 0x0f47, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 47 /r           CMOVA r32, r/m32    Valid    Valid      Move if above (CF=0 and
    //                                                            ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x03, 0x0f47, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 47 /r   CMOVA r64, r/m64    Valid    N.E.       Move if above (CF=0 and
    //                                                            ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x02, 0x0f47, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 43 /r           CMOVAE r16, r/m16   Valid    Valid      Move if above or equal
    //                                                            (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 43 /r           CMOVAE r32, r/m32   Valid    Valid      Move if above or equal
    //                                                            (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 43 /r   CMOVAE r64, r/m64   Valid    N.E.       Move if above or equal
    //                                                            (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x02, 0x0f43, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 42 /r           CMOVB r16, r/m16    Valid    Valid      Move if below (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 42 /r           CMOVB r32, r/m32    Valid    Valid      Move if below (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 42 /r   CMOVB r64, r/m64    Valid    N.E.       Move if below (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x02, 0x0f42, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 46 /r           CMOVBE r16, r/m16   Valid    Valid      Move if below or equal
    //                                                            (CF=1 or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x03, 0x0f46, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 46 /r           CMOVBE r32, r/m32   Valid    Valid      Move if below or equal
    //                                                            (CF=1 or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x03, 0x0f46, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 46 /r   CMOVBE r64, r/m64   Valid    N.E.       Move if below or equal
    //                                                            (CF=1 or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x02, 0x0f46, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 42 /r           CMOVC r16, r/m16    Valid    Valid      Move if carry (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 42 /r           CMOVC r32, r/m32    Valid    Valid      Move if carry (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 42 /r   CMOVC r64, r/m64    Valid    N.E.       Move if carry (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x02, 0x0f42, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 44 /r           CMOVE r16, r/m16    Valid    Valid      Move if equal (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x03, 0x0f44, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 44 /r           CMOVE r32, r/m32    Valid    Valid      Move if equal (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x03, 0x0f44, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 44 /r   CMOVE r64, r/m64    Valid    N.E.       Move if equal (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x02, 0x0f44, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 4F /r           CMOVG r16, r/m16    Valid    Valid      Move if greater (ZF=0
    //                                                            and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x03, 0x0f4f, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 4F /r           CMOVG r32, r/m32    Valid    Valid      Move if greater (ZF=0
    //                                                            and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x03, 0x0f4f, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // REX.W + 0F 4F /r   CMOVG r64, r/m64    Valid    N.E.       Move if greater (ZF=0
    //                                                            and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x02, 0x0f4f, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-134");
    define(defn);
    // 0F 4D /r           CMOVGE r16, r/m16   Valid    Valid      Move if greater or equal
    //                                                            (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x03, 0x0f4d, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 4D /r            CMOVGE r32, r/m32    Valid    Valid           Move if greater or equal
    //                                                                    (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x03, 0x0f4d, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 4D /r    CMOVGE r64, r/m64    Valid    N.E.            Move if greater or equal
    //                                                                    (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x02, 0x0f4d, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 4C /r            CMOVL r16, r/m16     Valid    Valid           Move if less (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x03, 0x0f4c, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 4C /r            CMOVL r32, r/m32     Valid    Valid           Move if less (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x03, 0x0f4c, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 4C /r    CMOVL r64, r/m64     Valid    N.E.            Move if less (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x02, 0x0f4c, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 4E /r            CMOVLE r16, r/m16    Valid    Valid           Move if less or equal
    //                                                                    (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x03, 0x0f4e, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 4E /r            CMOVLE r32, r/m32    Valid    Valid           Move if less or equal
    //                                                                    (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x03, 0x0f4e, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 4E /r    CMOVLE r64, r/m64    Valid    N.E.            Move if less or equal
    //                                                                    (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x02, 0x0f4e, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 46 /r            CMOVNA r16, r/m16    Valid    Valid           Move if not above (CF=1
    //                                                                    or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x03, 0x0f46, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 46 /r            CMOVNA r32, r/m32    Valid    Valid           Move if not above (CF=1
    //                                                                    or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x03, 0x0f46, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 46 /r    CMOVNA r64, r/m64    Valid    N.E.            Move if not above (CF=1
    //                                                                    or ZF=1).
    defn = new InsnDefn("cmovbe", x86_cmovbe,  0x02, 0x0f46, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 42 /r            CMOVNAE r16, r/m16   Valid    Valid           Move if not above or
    //                                                                    equal (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 42 /r            CMOVNAE r32, r/m32   Valid    Valid           Move if not above or
    //                                                                    equal (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x03, 0x0f42, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 42 /r    CMOVNAE r64, r/m64   Valid    N.E.            Move if not above or
    //                                                                    equal (CF=1).
    defn = new InsnDefn("cmovb",  x86_cmovb,   0x02, 0x0f42, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 43 /r            CMOVNB r16, r/m16    Valid    Valid           Move if not below
    //                                                                    (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 43 /r            CMOVNB r32, r/m32    Valid    Valid           Move if not below
    //                                                                    (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 43 /r    CMOVNB r64, r/m64    Valid    N.E.            Move if not below
    //                                                                    (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x02, 0x0f43, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 47 /r            CMOVNBE r16, r/m16   Valid    Valid           Move if not below or
    //                                                                    equal (CF=0 and ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x03, 0x0f47, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  0F 47 /r            CMOVNBE r32, r/m32   Valid    Valid           Move if not below or
    //                                                                    equal (CF=0 and ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x03, 0x0f47, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-135");
    define(defn);
    //  REX.W + 0F 47 /r    CMOVNBE r64, r/m64   Valid    N.E.            Move if not below or
    //                                                                    equal (CF=0 and ZF=0).
    defn = new InsnDefn("cmova",  x86_cmova,   0x02, 0x0f47, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 43 /r           CMOVNC r16, r/m16    Valid    Valid      Move if not carry (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 43 /r           CMOVNC r32, r/m32    Valid    Valid      Move if not carry (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x03, 0x0f43, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 43 /r   CMOVNC r64, r/m64    Valid    N.E.       Move if not carry (CF=0).
    defn = new InsnDefn("cmovae", x86_cmovae,  0x02, 0x0f43, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 45 /r           CMOVNE r16, r/m16    Valid    Valid      Move if not equal (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x03, 0x0f45, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 45 /r           CMOVNE r32, r/m32    Valid    Valid      Move if not equal (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x03, 0x0f45, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 45 /r   CMOVNE r64, r/m64    Valid    N.E.       Move if not equal (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x02, 0x0f45, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4E /r           CMOVNG r16, r/m16    Valid    Valid      Move if not greater
    //                                                             (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x03, 0x0f4e, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4E /r           CMOVNG r32, r/m32    Valid    Valid      Move if not greater
    //                                                             (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x03, 0x0f4e, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 4E /r   CMOVNG r64, r/m64    Valid    N.E.       Move if not greater
    //                                                             (ZF=1 or SF OF).
    defn = new InsnDefn("cmovle", x86_cmovle,  0x02, 0x0f4e, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4C /r           CMOVNGE r16, r/m16   Valid    Valid      Move if not greater or
    //                                                             equal (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x03, 0x0f4c, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4C /r           CMOVNGE r32, r/m32   Valid    Valid      Move if not greater or
    //                                                             equal (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x03, 0x0f4c, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 4C /r   CMOVNGE r64, r/m64   Valid    N.E.       Move if not greater or
    //                                                             equal (SF OF).
    defn = new InsnDefn("cmovl",  x86_cmovl,   0x02, 0x0f4c, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4D /r           CMOVNL r16, r/m16    Valid    Valid      Move if not less (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x03, 0x0f4d, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4D /r           CMOVNL r32, r/m32    Valid    Valid      Move if not less (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x03, 0x0f4d, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 4D /r   CMOVNL r64, r/m64    Valid    N.E.       Move if not less (SF=OF).
    defn = new InsnDefn("cmovge", x86_cmovge,  0x02, 0x0f4d, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4F /r           CMOVNLE r16, r/m16   Valid    Valid      Move if not less or equal
    //                                                             (ZF=0 and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x03, 0x0f4f, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4F /r           CMOVNLE r32, r/m32   Valid    Valid      Move if not less or equal
    //                                                             (ZF=0 and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x03, 0x0f4f, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 4F /r   CMOVNLE r64, r/m64   Valid    N.E.       Move if not less or equal
    //                                                             (ZF=0 and SF=OF).
    defn = new InsnDefn("cmovg",  x86_cmovg,   0x02, 0x0f4f, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 41 /r           CMOVNO r16, r/m16    Valid    Valid      Move if not overflow
    //                                                             (OF=0).
    defn = new InsnDefn("cmovno", x86_cmovno,  0x03, 0x0f41, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 41 /r           CMOVNO r32, r/m32    Valid    Valid      Move if not overflow
    //                                                             (OF=0).
    defn = new InsnDefn("cmovno", x86_cmovno,  0x03, 0x0f41, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // REX.W + 0F 41 /r   CMOVNO r64, r/m64    Valid    N.E.       Move if not overflow
    //                                                             (OF=0).
    defn = new InsnDefn("cmovno", x86_cmovno,  0x02, 0x0f41, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4B /r           CMOVNP r16, r/m16    Valid    Valid      Move if not parity
    //                                                             (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x03, 0x0f4b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-136");
    define(defn);
    // 0F 4B /r           CMOVNP r32, r/m32    Valid    Valid      Move if not parity
    //                                                             (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x03, 0x0f4b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 4B /r    CMOVNP r64, r/m64   Valid    N.E.            Move if not parity
    //                                                                   (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x02, 0x0f4b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 49 /r            CMOVNS r16, r/m16   Valid    Valid           Move if not sign (SF=0).
    defn = new InsnDefn("cmovns", x86_cmovns,  0x03, 0x0f49, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 49 /r            CMOVNS r32, r/m32   Valid    Valid           Move if not sign (SF=0).
    defn = new InsnDefn("cmovns", x86_cmovns,  0x03, 0x0f49, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 49 /r    CMOVNS r64, r/m64   Valid    N.E.            Move if not sign (SF=0).
    defn = new InsnDefn("cmovns", x86_cmovns,  0x02, 0x0f49, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 45 /r            CMOVNZ r16, r/m16   Valid    Valid           Move if not zero (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x03, 0x0f45, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 45 /r            CMOVNZ r32, r/m32   Valid    Valid           Move if not zero (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x03, 0x0f45, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 45 /r    CMOVNZ r64, r/m64   Valid    N.E.            Move if not zero (ZF=0).
    defn = new InsnDefn("cmovne", x86_cmovne,  0x02, 0x0f45, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 40 /r            CMOVO r16, r/m16    Valid    Valid           Move if overflow (OF=0).
    defn = new InsnDefn("cmovo",  x86_cmovo,   0x03, 0x0f40, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 40 /r            CMOVO r32, r/m32    Valid    Valid           Move if overflow (OF=0).
    defn = new InsnDefn("cmovo",  x86_cmovo,   0x03, 0x0f40, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 40 /r    CMOVO r64, r/m64    Valid    N.E.            Move if overflow (OF=0).
    defn = new InsnDefn("cmovo",  x86_cmovo,   0x02, 0x0f40, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4A /r            CMOVP r16, r/m16    Valid    Valid           Move if parity (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x03, 0x0f4a, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4A /r            CMOVP r32, r/m32    Valid    Valid           Move if parity (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x03, 0x0f4a, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 4A /r    CMOVP r64, r/m64    Valid    N.E.            Move if parity (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x02, 0x0f4a, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4A /r            CMOVPE r16, r/m16   Valid    Valid           Move if parity even
    //                                                                   (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x03, 0x0f4a, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4A /r            CMOVPE r32, r/m32   Valid    Valid           Move if parity even
    //                                                                   (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x03, 0x0f4a, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 4A /r    CMOVPE r64, r/m64   Valid    N.E.            Move if parity even
    //                                                                   (PF=1).
    defn = new InsnDefn("cmovpe", x86_cmovpe,  0x02, 0x0f4a, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4B /r            CMOVPO r16, r/m16   Valid    Valid           Move if parity odd
    //                                                                   (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x03, 0x0f4b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 4B /r            CMOVPO r32, r/m32   Valid    Valid           Move if parity odd
    //                                                                   (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x03, 0x0f4b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 4B /r    CMOVPO r64, r/m64   Valid    N.E.            Move if parity odd
    //                                                                   (PF=0).
    defn = new InsnDefn("cmovpo", x86_cmovpo,  0x02, 0x0f4b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 48 /r            CMOVS r16, r/m16    Valid    Valid           Move if sign (SF=1).
    defn = new InsnDefn("cmovs",  x86_cmovs,   0x03, 0x0f48, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 48 /r            CMOVS r32, r/m32    Valid    Valid           Move if sign (SF=1).
    defn = new InsnDefn("cmovs",  x86_cmovs,   0x03, 0x0f48, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 48 /r    CMOVS r64, r/m64    Valid    N.E.            Move if sign (SF=1).
    defn = new InsnDefn("cmovs",  x86_cmovs,   0x02, 0x0f48, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 44 /r            CMOVZ r16, r/m16    Valid    Valid           Move if zero (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x03, 0x0f44, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  0F 44 /r            CMOVZ r32, r/m32    Valid    Valid           Move if zero (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x03, 0x0f44, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-137");
    define(defn);
    //  REX.W + 0F 44 /r    CMOVZ r64, r/m64    Valid    N.E.            Move if zero (ZF=1).
    defn = new InsnDefn("cmove",  x86_cmove,   0x02, 0x0f44, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);

    //--- page 3-141 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  3C ib               CMP AL, imm8        Valid          Valid          Compare imm8 with AL.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3c, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  3D iw               CMP AX, imm16       Valid          Valid          Compare imm16 with AX.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3d, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  3D id               CMP EAX, imm32 Valid               Valid          Compare imm32 with EAX.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3d, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX.W + 3D id       CMP RAX, imm32 Valid               N.E.           Compare imm32 sign-
    //                                                                        extended to 64-bits with
    //                                                                        RAX.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x3d, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  80 /7 ib            CMP r/m8, imm8      Valid          Valid          Compare imm8 with r/m8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x80, od_e7|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX + 80 /7 ib      CMP r/m8*, imm8 Valid              N.E.           Compare imm8 with r/m8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x80, od_rex|od_e7|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  81 /7 iw            CMP r/m16,          Valid          Valid          Compare imm16 with
    //                      imm16                                             r/m16.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x81, od_e7|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  81 /7 id            CMP r/m32,          Valid          Valid          Compare imm32 with
    //                      imm32                                             r/m32.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x81, od_e7|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX.W + 81 /7 id    CMP r/m64,          Valid          N.E.           Compare imm32 sign-
    //                      imm32                                             extended to 64-bits with
    //                                                                        r/m64.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x81, od_rexw|od_e7|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  83 /7 ib            CMP r/m16, imm8 Valid              Valid          Compare imm8 with r/m16.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x83, od_e7|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  83 /7 ib            CMP r/m32, imm8 Valid              Valid          Compare imm8 with r/m32.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x83, od_e7|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX.W + 83 /7 ib    CMP r/m64, imm8 Valid              N.E.           Compare imm8 with r/m64.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x83, od_rexw|od_e7|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  38 /r               CMP r/m8, r8        Valid          Valid          Compare r8 with r/m8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x38, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX + 38 /r         CMP r/m8*, r8*      Valid          N.E.           Compare r8 with r/m8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x38, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  39 /r               CMP r/m16, r16      Valid          Valid          Compare r16 with r/m16.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x39, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  39 /r               CMP r/m32, r32      Valid          Valid          Compare r32 with r/m32.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x39, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX.W + 39 /r       CMP r/m64,r64       Valid          N.E.           Compare r64 with r/m64.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x39, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  3A /r               CMP r8, r/m8        Valid          Valid          Compare r/m8 with r8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3a, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX + 3A /r         CMP r8*, r/m8*      Valid          N.E.           Compare r/m8 with r8.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x3a, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  3B /r               CMP r16, r/m16      Valid          Valid          Compare r/m16 with r16.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  3B /r               CMP r32, r/m32      Valid          Valid          Compare r/m32 with r32.
    defn = new InsnDefn("cmp",    x86_cmp,     0x03, 0x3b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-141");
    define(defn);
    //  REX.W + 3B /r       CMP r64, r/m64      Valid          N.E.           Compare r/m64 with r64.
    defn = new InsnDefn("cmp",    x86_cmp,     0x02, 0x3b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-144");
    define(defn);

    //--- page 3-144 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F C2 /r ib   CMPPD xmm1,               Valid       Valid           Compare packed double-
    //                  xmm2/m128, imm8                                       precision floating-point
    //                                                                        values in xmm2/m128 and
    //                                                                        xmm1 using imm8 as
    //                                                                        comparison predicate.
    defn = new InsnDefn("cmppd",  x86_cmppd,   0x03, 0x660fc2, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-149");
    define(defn);

    //--- page 3-149 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F C2 /r ib    CMPPS xmm1,               Valid         Valid          Compare packed single-
    //                 xmm2/m128, imm8                                        precision floating-point
    //                                                                        values in xmm2/mem and
    //                                                                        xmm1 using imm8 as
    //                                                                        comparison predicate.
    defn = new InsnDefn("cmpps",  x86_cmpps,   0x03, 0x0fc2, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-154");
    define(defn);

    //--- page 3-154 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // A6              CMPS m8, m8   Valid        Valid          For legacy mode, compare byte at
    //                                                           address DS:(E)SI with byte at
    //                                                           address ES:(E)DI; For 64-bit mode
    //                                                           compare byte at address (R|E)SI to
    //                                                           byte at address (R|E)DI. The status
    //                                                           flags are set accordingly.
    // See CMPSB, CMPSW, CMPSD, or CMPSQ instead.
    // defn = new InsnDefn("cmps",   x86_cmps,    0x03, 0xa6, od_none, od_m8, od_m8);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-154");
    // define(defn);
    // A7              CMPS m16, m16 Valid        Valid          For legacy mode, compare word at
    //                                                           address DS:(E)SI with word at
    //                                                           address ES:(E)DI; For 64-bit mode
    //                                                           compare word at address (R|E)SI
    //                                                           with word at address (R|E)DI. The
    //                                                           status flags are set accordingly.
    // See CMPSB, CMPSW, CMPSD, or CMPSQ instead.
    // defn = new InsnDefn("cmps",   x86_cmps,    0x03, 0xa7, od_none, od_m16, od_m16);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-154");
    // define(defn);
    // A7              CMPS m32, m32 Valid        Valid          For legacy mode, compare dword
    //                                                           at address DS:(E)SI at dword at
    //                                                           address ES:(E)DI; For 64-bit mode
    //                                                           compare dword at address (R|E)SI
    //                                                           at dword at address (R|E)DI. The
    //                                                           status flags are set accordingly.
    // See CMPSB, CMPSW, CMPSD, or CMPSQ instead.
    // defn = new InsnDefn("cmps",   x86_cmps,    0x03, 0xa7, od_none, od_m32, od_m32);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-154");
    // define(defn);
    // REX.W + A7      CMPS m64, m64 Valid        N.E.           Compares quadword at address
    //                                                           (R|E)SI with quadword at address
    //                                                           (R|E)DI and sets the status flags
    //                                                           accordingly.
    // See CMPSB, CMPSW, CMPSD, or CMPSQ instead.
    // defn = new InsnDefn("cmps",   x86_cmps,    0x02, 0xa7, od_rexw, od_m64, od_m64);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-154");
    // define(defn);
    // A6              CMPSB         Valid        Valid          For legacy mode, compare byte at
    //                                                           address DS:(E)SI with byte at
    //                                                           address ES:(E)DI; For 64-bit mode
    //                                                           compare byte at address (R|E)SI
    //                                                           with byte at address (R|E)DI. The
    //                                                           status flags are set accordingly.
    defn = new InsnDefn("cmpsb",  x86_cmpsb,   0x03, 0xa6, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-155");
    define(defn);
    //  A7            CMPSW           Valid       Valid       For legacy mode, compare word at
    //                                                        address DS:(E)SI with word at
    //                                                        address ES:(E)DI; For 64-bit mode
    //                                                        compare word at address (R|E)SI
    //                                                        with word at address (R|E)DI. The
    //                                                        status flags are set accordingly.
    defn = new InsnDefn("cmpsw",  x86_cmpsw,   0x03, 0xa7, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-155");
    define(defn);
    //  A7            CMPSD           Valid       Valid       For legacy mode, compare dword
    //                                                        at address DS:(E)SI with dword at
    //                                                        address ES:(E)DI; For 64-bit mode
    //                                                        compare dword at address (R|E)SI
    //                                                        with dword at address (R|E)DI. The
    //                                                        status flags are set accordingly.
    defn = new InsnDefn("cmpsd",  x86_cmpsd,   0x03, 0xa7, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-155");
    define(defn);
    //  REX.W + A7    CMPSQ           Valid       N.E.        Compares quadword at address
    //                                                        (R|E)SI with quadword at address
    //                                                        (R|E)DI and sets the status flags
    //                                                        accordingly.
    defn = new InsnDefn("cmpsq",  x86_cmpsq,   0x02, 0xa7, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-160");
    define(defn);

    //--- page 3-160 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F C2 /r ib   CMPSD xmm1,           Valid        Valid             Compare low double-
    //                  xmm2/m64, imm8                                       precision floating-point
    //                                                                       value in xmm2/m64 and
    //                                                                       xmm1 using imm8 as
    //                                                                       comparison predicate.
    defn = new InsnDefn("cmpsd",  x86_cmpsd,   0x03, 0xf20fc2, od_modrm|od_ib, od_xmm, od_xmm_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-164");
    define(defn);

    //--- page 3-164 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F C2 /r ib   CMPSS xmm1,     Valid           Valid             Compare low single-precision
    //                  xmm2/m32,                                         floating-point value in
    //                  imm8                                              xmm2/m32 and xmm1 using
    //                                                                    imm8 as comparison
    //                                                                    predicate.
    defn = new InsnDefn("cmpss",  x86_cmpss,   0x03, 0xf30fc2, od_modrm|od_ib, od_xmm, od_xmm_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-168");
    define(defn);

    //--- page 3-168 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F B0/r             CMPXCHG r/m8, r8 Valid             Valid*           Compare AL with r/m8. If
    //                                                                         equal, ZF is set and r8 is
    //                                                                         loaded into r/m8. Else, clear
    //                                                                         ZF and load r/m8 into AL.
    defn = new InsnDefn("cmpxchg", x86_cmpxchg, 0x03, 0x0fb0, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-168");
    define(defn);
    // REX + 0F B0/r       CMPXCHG              Valid         N.E.             Compare AL with r/m8. If
    //                     r/m8**,r8                                           equal, ZF is set and r8 is
    //                                                                         loaded into r/m8. Else, clear
    //                                                                         ZF and load r/m8 into AL.
    defn = new InsnDefn("cmpxchg", x86_cmpxchg, 0x02, 0x0fb0, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-168");
    define(defn);
    // 0F B1/r             CMPXCHG r/m16,       Valid         Valid*           Compare AX with r/m16. If
    //                     r16                                                 equal, ZF is set and r16 is
    //                                                                         loaded into r/m16. Else,
    //                                                                         clear ZF and load r/m16
    //                                                                         into AX.
    defn = new InsnDefn("cmpxchg", x86_cmpxchg, 0x03, 0x0fb1, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-168");
    define(defn);
    // 0F B1/r             CMPXCHG r/m32,       Valid         Valid*           Compare EAX with r/m32.
    //                     r32                                                 If equal, ZF is set and r32 is
    //                                                                         loaded into r/m32. Else,
    //                                                                         clear ZF and load r/m32
    //                                                                         into EAX.
    defn = new InsnDefn("cmpxchg", x86_cmpxchg, 0x03, 0x0fb1, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-168");
    define(defn);
    // REX.W + 0F B1/r     CMPXCHG r/m64,       Valid         N.E.             Compare RAX with r/m64.
    //                     r64                                                 If equal, ZF is set and r64 is
    //                                                                         loaded into r/m64. Else,
    //                                                                         clear ZF and load r/m64
    //                                                                         into RAX.
    defn = new InsnDefn("cmpxchg", x86_cmpxchg, 0x02, 0x0fb1, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-171");
    define(defn);

    //--- page 3-171 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F C7 /1            CMPXCHG8B m64         Valid         Valid*         Compare EDX:EAX with
    //                                                                         m64. If equal, set ZF and
    //                                                                         load ECX:EBX into m64.
    //                                                                         Else, clear ZF and load m64
    //                                                                         into EDX:EAX.
    defn = new InsnDefn("cmpxchg8b", x86_cmpxchg8b, 0x03, 0x0fc7, od_e1, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-171");
    define(defn);
    //  REX.W + 0F C7 /1    CMPXCHG16B            Valid         N.E.           Compare RDX:RAX with
    //  m128                m128                                               m128. If equal, set ZF and
    //                                                                         load RCX:RBX into m128.
    //                                                                         Else, clear ZF and load
    //                                                                         m128 into RDX:RAX.
    defn = new InsnDefn("cmpxchg16b", x86_cmpxchg16b, 0x02, 0x0fc7, od_rexw|od_e1, od_m128, od_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-174");
    define(defn);

    //--- page 3-174 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 2F /r COMISD xmm1,              Valid             Valid            Compare low double-
    //             xmm2/m64                                                     precision floating-point
    //                                                                          values in xmm1 and
    //                                                                          xmm2/mem64 and set the
    //                                                                          EFLAGS flags accordingly.
    defn = new InsnDefn("comisd", x86_comisd,  0x03, 0x660f2f, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-177");
    define(defn);

    //--- page 3-177 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 2F /r    COMISS xmm1,              Valid        Valid            Compare low single-precision
    //              xmm2/m32                                                floating-point values in xmm1 and
    //                                                                      xmm2/mem32 and set the EFLAGS
    //                                                                      flags accordingly.
    defn = new InsnDefn("comiss", x86_comiss,  0x03, 0x0f2f, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-180");
    define(defn);

    //--- page 3-180 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F A2           CPUID           Valid          Valid           Returns processor identification
    //                                                                and feature information to the
    //                                                                EAX, EBX, ECX, and EDX registers,
    //                                                                as determined by input entered in
    //                                                                EAX (in some cases, ECX as well).
    defn = new InsnDefn("cpuid",  x86_cpuid,   0x03, 0x0fa2, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);

    //--- page 3-214 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //   F2 0F 38 F0 /r         CRC32 r32, r/m8       Valid    Valid        Accumulate CRC32 on
    //                                                                      r/m8.
    defn = new InsnDefn("crc32",  x86_crc32,   0x03, 0xf20f38f0, od_modrm, od_r32, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);
    //   F2 REX 0F 38 F0 /r     CRC32 r32, r/m8*      Valid    N.E.         Accumulate CRC32 on
    //                                                                      r/m8.
    //                                                                      Accumulate CRC32 on
    defn = new InsnDefn("crc32",  x86_crc32,   0x02, 0xf20f38f0, od_rex|od_modrm, od_r32, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);
    //   F2 0F 38 F1 /r         CRC32 r32, r/m16      Valid    Valid
    //                                                                      r/m16.
    //                                                                      Accumulate CRC32 on
    defn = new InsnDefn("crc32",  x86_crc32,   0x03, 0xf20f38f1, od_modrm, od_r32, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);
    //   F2 0F 38 F1 /r         CRC32 r32, r/m32      Valid    Valid        r/m32.
    //                                                                      Accumulate CRC32 on
    defn = new InsnDefn("crc32",  x86_crc32,   0x03, 0xf20f38f1, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);
    //   F2 REX.W 0F 38 F0      CRC32 r64, r/m8       Valid    N.E.         r/m8.
    //   /r                                                                 Accumulate CRC32 on
    defn = new InsnDefn("crc32",  x86_crc32,   0x02, 0xf20f38f0, od_rexw|od_modrm, od_r64, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-214");
    define(defn);
    //   F2 REX.W 0F 38 F1      CRC32 r64, r/m64      Valid    N.E.         r/m64.
    //   /r
    defn = new InsnDefn("crc32",  x86_crc32,   0x02, 0xf20f38f1, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-218");
    define(defn);

    //--- page 3-218 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F E6        CVTDQ2PD xmm1,           Valid       Valid             Convert two packed signed
    //                 xmm2/m64                                               doubleword integers from
    //                                                                        xmm2/m128 to two packed
    //                                                                        double-precision floating-point
    //                                                                        values in xmm1.
    defn = new InsnDefn("cvtdq2pd", x86_cvtdq2pd, 0x03, 0xf30fe6, od_none, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-220");
    define(defn);

    //--- page 3-220 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 5B /r        CVTDQ2PS xmm1,             Valid        Valid            Convert four packed signed
    //                 xmm2/m128                                                doubleword integers from
    //                                                                          xmm2/m128 to four packed
    //                                                                          single-precision floating-
    //                                                                          point values in xmm1.
    defn = new InsnDefn("cvtdq2ps", x86_cvtdq2ps, 0x03, 0x0f5b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-223");
    define(defn);

    //--- page 3-223 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F E6     CVTPD2DQ xmm1,           Valid       Valid            Convert two packed double-
    //               xmm2/m128                                             precision floating-point values
    //                                                                     from xmm2/m128 to two
    //                                                                     packed signed doubleword
    //                                                                     integers in xmm1.
    defn = new InsnDefn("cvtpd2dq", x86_cvtpd2dq, 0x03, 0xf20fe6, od_none, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-226");
    define(defn);

    //--- page 3-226 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 2D /r     CVTPD2PI mm,           Valid            Valid            Convert two packed double-
    //                 xmm/m128                                                 precision floating-point
    //                                                                          values from xmm/m128 to
    //                                                                          two packed signed
    //                                                                          doubleword integers in mm.
    defn = new InsnDefn("cvtpd2pi", x86_cvtpd2pi, 0x03, 0x660f2d, od_modrm, od_mm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-229");
    define(defn);

    //--- page 3-229 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 5A /r     CVTPD2PS xmm1,         Valid      Valid           Convert two packed double-
    //                  xmm2/m128                                         precision floating-point values in
    //                                                                    xmm2/m128 to two packed single-
    //                                                                    precision floating-point values in
    //                                                                    xmm1.
    defn = new InsnDefn("cvtpd2ps", x86_cvtpd2ps, 0x03, 0x660f5a, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-232");
    define(defn);

    //--- page 3-232 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 2A /r     CVTPI2PD            Valid       Valid           Convert two packed signed
    //                 xmm,                                            doubleword integers from
    //                 mm/m64*                                         mm/mem64 to two packed double-
    //                                                                 precision floating-point values in
    //                                                                 xmm.
    defn = new InsnDefn("cvtpi2pd", x86_cvtpi2pd, 0x03, 0x660f2a, od_modrm, od_xmm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-235");
    define(defn);

    //--- page 3-235 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 2A /r      CVTPI2PS xmm,         Valid     Valid           Convert two signed doubleword
    //                mm/m64                                          integers from mm/m64 to two single-
    //                                                                precision floating-point values in xmm.
    defn = new InsnDefn("cvtpi2ps", x86_cvtpi2ps, 0x03, 0x0f2a, od_modrm, od_xmm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-238");
    define(defn);

    //--- page 3-238 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 5B /r      CVTPS2DQ xmm1,         Valid       Valid          Convert four packed single-precision
    //                  xmm2/m128                                         floating-point values from
    //                                                                    xmm2/m128 to four packed signed
    //                                                                    doubleword integers in xmm1.
    defn = new InsnDefn("cvtps2dq", x86_cvtps2dq, 0x03, 0x660f5b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-241");
    define(defn);

    //--- page 3-241 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 5A /r      CVTPS2PD xmm1,         Valid      Valid           Convert two packed single-precision
    //                xmm2/m64                                          floating-point values in xmm2/m64
    //                                                                  to two packed double-precision
    //                                                                  floating-point values in xmm1.
    defn = new InsnDefn("cvtps2pd", x86_cvtps2pd, 0x03, 0x0f5a, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-244");
    define(defn);

    //--- page 3-244 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 2D /r    CVTPS2PI mm,      Valid      Valid          Convert two packed single-precision
    //             xmm/m64                                     floating-point values from xmm/m64 to
    //                                                         two packed signed doubleword integers in
    //                                                         mm.
    defn = new InsnDefn("cvtps2pi", x86_cvtps2pi, 0x03, 0x0f2d, od_modrm, od_mm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-247");
    define(defn);

    //--- page 3-247 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 2D /r               CVTSD2SI r32,     Valid       Valid         Convert one double-precision
    //                            xmm/m64                                     floating-point value from
    //                                                                        xmm/m64 to one signed
    //                                                                        doubleword integer r32.
    defn = new InsnDefn("cvtsd2si", x86_cvtsd2si, 0x03, 0xf20f2d, od_modrm, od_r32, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-247");
    define(defn);
    //   F2 REX.W 0F 2D /r        CVTSD2SI r64,     Valid       N.E.          Convert one double-precision
    //                            xmm/m64                                     floating-point value from
    //                                                                        xmm/m64 to one signed
    //                                                                        quadword integer sign-
    //                                                                        extended into r64.
    defn = new InsnDefn("cvtsd2si", x86_cvtsd2si, 0x02, 0xf20f2d, od_rexw|od_modrm, od_r64, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-250");
    define(defn);

    //--- page 3-250 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F 5A /r     CVTSD2SS xmm1,        Valid     Valid          Convert one double-precision floating-
    //                 xmm2/m64                                       point value in xmm2/m64 to one
    //                                                                single-precision floating-point value in
    //                                                                xmm1.
    defn = new InsnDefn("cvtsd2ss", x86_cvtsd2ss, 0x03, 0xf20f5a, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-253");
    define(defn);

    //--- page 3-253 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 2A /r             CVTSI2SD xmm,        Valid    Valid          Convert one signed doubleword
    //                          r/m32                                        integer from r/m32 to one
    //                                                                       double-precision floating-point
    //                                                                       value in xmm.
    defn = new InsnDefn("cvtsi2sd", x86_cvtsi2sd, 0x03, 0xf20f2a, od_modrm, od_xmm, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-253");
    define(defn);
    //  F2 REX.W 0F 2A /r       CVTSI2SD xmm,        Valid    N.E.           Convert one signed quadword
    //                          r/m64                                        integer from r/m64 to one
    //                                                                       double-precision floating-point
    //                                                                       value in xmm.
    defn = new InsnDefn("cvtsi2sd", x86_cvtsi2sd, 0x02, 0xf20f2a, od_rexw|od_modrm, od_xmm, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-256");
    define(defn);

    //--- page 3-256 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 2A /r           CVTSI2SS        Valid      Valid          Convert one signed doubleword
    //                       xmm, r/m32                                integer from r/m32 to one single-
    //                                                                 precision floating-point value in
    //                                                                 xmm.
    defn = new InsnDefn("cvtsi2ss", x86_cvtsi2ss, 0x03, 0xf30f2a, od_modrm, od_xmm, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-256");
    define(defn);
    // F3 REX.W 0F 2A /r     CVTSI2SS        Valid      N.E.           Convert one signed quadword
    //                       xmm, r/m64                                integer from r/m64 to one single-
    //                                                                 precision floating-point value in
    //                                                                 xmm.
    defn = new InsnDefn("cvtsi2ss", x86_cvtsi2ss, 0x02, 0xf30f2a, od_rexw|od_modrm, od_xmm, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-259");
    define(defn);

    //--- page 3-259 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 5A /r     CVTSS2SD xmm1,          Valid     Valid          Convert one single-precision floating-
    //                  xmm2/m32                                         point value in xmm2/m32 to one
    //                                                                   double-precision floating-point value
    //                                                                   in xmm1.
    defn = new InsnDefn("cvtss2sd", x86_cvtss2sd, 0x03, 0xf30f5a, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-262");
    define(defn);

    //--- page 3-262 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 2D /r           CVTSS2SI r32,      Valid      Valid         Convert one single-precision
    //                       xmm/m32                                     floating-point value from
    //                                                                   xmm/m32 to one signed
    //                                                                   doubleword integer in r32.
    defn = new InsnDefn("cvtss2si", x86_cvtss2si, 0x03, 0xf30f2d, od_modrm, od_r32, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-262");
    define(defn);
    // F3 REX.W 0F 2D /r     CVTSS2SI r64,      Valid      N.E.          Convert one single-precision
    //                       xmm/m32                                     floating-point value from
    //                                                                   xmm/m32 to one signed
    //                                                                   quadword integer in r64.
    defn = new InsnDefn("cvtss2si", x86_cvtss2si, 0x02, 0xf30f2d, od_rexw|od_modrm, od_r64, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-265");
    define(defn);

    //--- page 3-265 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F E6      CVTTPD2DQ xmm1,         Valid      Valid           Convert two packed double-
    //                xmm2/m128                                          precision floating-point values
    //                                                                   from xmm2/m128 to two packed
    //                                                                   signed doubleword integers in
    //                                                                   xmm1 using truncation.
    defn = new InsnDefn("cvttpd2dq", x86_cvttpd2dq, 0x03, 0x660fe6, od_none, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-268");
    define(defn);

    //--- page 3-268 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 2C /r     CVTTPD2PI mm,     Valid      Valid          Convert two packer double-precision
    //                 xmm/m128                                    floating-point values from xmm/m128
    //                                                             to two packed signed doubleword
    //                                                             integers in mm using truncation.
    defn = new InsnDefn("cvttpd2pi", x86_cvttpd2pi, 0x03, 0x660f2c, od_modrm, od_mm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-271");
    define(defn);

    //--- page 3-271 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 5B /r   CVTTPS2DQ xmm1,          Valid      Valid          Convert four single-precision
    //                xmm2/m128                                          floating-point values from
    //                                                                   xmm2/m128 to four signed
    //                                                                   doubleword integers in xmm1 using
    //                                                                   truncation.
    defn = new InsnDefn("cvttps2dq", x86_cvttps2dq, 0x03, 0xf30f5b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-274");
    define(defn);

    //--- page 3-274 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 2C /r    CVTTPS2PI mm,        Valid      Valid         Convert two single-precision floating-
    //             xmm/m64                                       point values from xmm/m64 to two
    //                                                           signed doubleword signed integers in mm
    //                                                           using truncation.
    defn = new InsnDefn("cvttps2pi", x86_cvttps2pi, 0x03, 0x0f2c, od_modrm, od_mm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-277");
    define(defn);

    //--- page 3-277 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 2C /r              CVTTSD2SI r32, Valid          Valid          Convert one double-precision
    //                           xmm/m64                                      floating-point value from
    //                                                                        xmm/m64 to one signed
    //                                                                        doubleword integer in r32 using
    //                                                                        truncation.
    defn = new InsnDefn("cvttsd2si", x86_cvttsd2si, 0x03, 0xf20f2c, od_modrm, od_r32, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-277");
    define(defn);
    //  F2 REX.W 0F 2C /r        CVTTSD2SI r64, Valid          N.E.           Convert one double precision
    //                           xmm/m64                                      floating-point value from
    //                                                                        xmm/m64 to one
    //                                                                        signedquadword integer in r64
    //                                                                        using truncation.
    defn = new InsnDefn("cvttsd2si", x86_cvttsd2si, 0x02, 0xf20f2c, od_rexw|od_modrm, od_r64, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-280");
    define(defn);

    //--- page 3-280 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 2C /r           CVTTSS2SI r32,       Valid      Valid          Convert one single-precision
    //                       xmm/m32                                        floating-point value from
    //                                                                      xmm/m32 to one signed
    //                                                                      doubleword integer in r32
    //                                                                      using truncation.
    defn = new InsnDefn("cvttss2si", x86_cvttss2si, 0x03, 0xf30f2c, od_modrm, od_r32, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-280");
    define(defn);
    // F3 REX.W 0F 2C /r     CVTTSS2SI r64,       Valid      N.E.           Convert one single-precision
    //                       xmm/m32                                        floating-point value from
    //                                                                      xmm/m32 to one signed
    //                                                                      quadword integer in r64 using
    //                                                                      truncation.
    defn = new InsnDefn("cvttss2si", x86_cvttss2si, 0x02, 0xf30f2c, od_rexw|od_modrm, od_r64, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-283");
    define(defn);

    //--- page 3-283 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  99               CWD               Valid       Valid           DX:AX  sign-extend of AX.
    defn = new InsnDefn("cwd",    x86_cwd,     0x03, 0x99, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-283");
    define(defn);
    //  99               CDQ               Valid       Valid           EDX:EAX  sign-extend of EAX.
    defn = new InsnDefn("cdq",    x86_cdq,     0x03, 0x99, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-283");
    define(defn);
    //  REX.W + 99       CQO               Valid       N.E.            RDX:RAX sign-extend of RAX.
    defn = new InsnDefn("cqo",    x86_cqo,     0x02, 0x99, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-285");
    define(defn);

    //--- page 3-285 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  27              DAA                   Invalid   Valid         Decimal adjust AL after addition.
    defn = new InsnDefn("daa",    x86_daa,     0x01, 0x27, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-287");
    define(defn);

    //--- page 3-287 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  2F               DAS               Invalid   Valid            Decimal adjust AL after
    //                                                                subtraction.
    defn = new InsnDefn("das",    x86_das,     0x01, 0x2f, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);

    //--- page 3-289 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  FE /1               DEC r/m8           Valid       Valid           Decrement r/m8 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x03, 0xfe, od_e1, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  REX + FE /1         DEC r/m8*          Valid       N.E.            Decrement r/m8 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x02, 0xfe, od_rex|od_e1, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  FF /1               DEC r/m16          Valid       Valid           Decrement r/m16 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x03, 0xff, od_e1, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  FF /1               DEC r/m32          Valid       Valid           Decrement r/m32 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x03, 0xff, od_e1, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  REX.W + FF /1       DEC r/m64          Valid       N.E.            Decrement r/m64 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x02, 0xff, od_rexw|od_e1, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  48+rw               DEC r16            N.E.        Valid           Decrement r16 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x01, 0x48, od_rw, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-289");
    define(defn);
    //  48+rd               DEC r32            N.E.        Valid           Decrement r32 by 1.
    defn = new InsnDefn("dec",    x86_dec,     0x01, 0x48, od_rd, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-292");
    define(defn);

    //--- page 3-292 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F6 /6             DIV r/m8       Valid      Valid           Unsigned divide AX by r/m8, with
    //                                                             result stored in AL  Quotient, AH
    //                                                             Remainder.
    defn = new InsnDefn("div",    x86_div,     0x03, 0xf6, od_e6, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-292");
    define(defn);
    // REX + F6 /6       DIV r/m8*      Valid      N.E.            Unsigned divide AX by r/m8, with
    //                                                             result stored in AL  Quotient, AH
    //                                                             Remainder.
    defn = new InsnDefn("div",    x86_div,     0x02, 0xf6, od_rex|od_e6, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-292");
    define(defn);
    // F7 /6             DIV r/m16      Valid      Valid           Unsigned divide DX:AX by r/m16, with
    //                                                             result stored in AX  Quotient, DX
    //                                                             Remainder.
    defn = new InsnDefn("div",    x86_div,     0x03, 0xf7, od_e6, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-292");
    define(defn);
    // F7 /6             DIV r/m32      Valid      Valid           Unsigned divide EDX:EAX by r/m32,
    //                                                             with result stored in EAX  Quotient,
    //                                                             EDX  Remainder.
    defn = new InsnDefn("div",    x86_div,     0x03, 0xf7, od_e6, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-292");
    define(defn);
    // REX.W + F7 /6     DIV r/m64      Valid      N.E.            Unsigned divide RDX:RAX by r/m64,
    //                                                             with result stored in RAX  Quotient,
    //                                                             RDX  Remainder.
    defn = new InsnDefn("div",    x86_div,     0x02, 0xf7, od_rexw|od_e6, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-296");
    define(defn);

    //--- page 3-296 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 5E /r     DIVPD xmm1,      Valid      Valid        Divide packed double-precision floating-
    //                 xmm2/m128                                point values in xmm1 by packed double-
    //                                                          precision floating-point values
    //                                                          xmm2/m128.
    defn = new InsnDefn("divpd",  x86_divpd,   0x03, 0x660f5e, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-299");
    define(defn);

    //--- page 3-299 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 5E /r     DIVPS xmm1,         Valid       Valid          Divide packed single-precision floating-
    //               xmm2/m128                                      point values in xmm1 by packed single-
    //                                                              precision floating-point values
    //                                                              xmm2/m128.
    defn = new InsnDefn("divps",  x86_divps,   0x03, 0x0f5e, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-302");
    define(defn);

    //--- page 3-302 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F 5E /r     DIVSD xmm1,    Valid       Valid          Divide low double-precision floating-
    //                 xmm2/m64                                  point value n xmm1 by low double-
    //                                                           precision floating-point value in
    //                                                           xmm2/mem64.
    defn = new InsnDefn("divsd",  x86_divsd,   0x03, 0xf20f5e, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-305");
    define(defn);

    //--- page 3-305 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //   F3 0F 5E /r      DIVSS xmm1,         Valid       Valid     Divide low single-precision floating-
    //                    xmm2/m32                                  point value in xmm1 by low single-
    //                                                              precision floating-point value in
    //                                                              xmm2/m32.
    defn = new InsnDefn("divss",  x86_divss,   0x03, 0xf30f5e, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-308");
    define(defn);

    //--- page 3-308 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 3A    DPPD xmm1,        Valid    Valid         Selectively multiply packed DP floating-
    // 41 /r ib    xmm2/m128,                               point values from xmm1 with packed DP
    //             imm8                                     floating-point values from xmm2, add
    //                                                      and selectively store the packed DP
    //                                                      floating-point values to xmm1.
    defn = new InsnDefn("dppd",   x86_dppd,    0x03, 0x660f3a41, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-311");
    define(defn);

    //--- page 3-311 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 3A DPPS xmm1,                Valid     Valid         Selectively multiply packed SP floating-
    //  40 /r ib xmm2/m128,                                        point values from xmm1 with packed SP
    //           imm8                                              floating-point values from xmm2, add
    //                                                             and selectively store the packed SP
    //                                                             floating-point values or zero values to
    //                                                             xmm1.
    defn = new InsnDefn("dpps",   x86_dpps,    0x03, 0x660f3a40, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-315");
    define(defn);

    //--- page 3-315 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 77           EMMS             Valid    Valid       Set the x87 FPU tag word to empty.
    defn = new InsnDefn("emms",   x86_emms,    0x03, 0x0f77, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-317");
    define(defn);

    //--- page 3-317 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  C8 iw 00      ENTER imm16, 0         Valid       Valid      Create a stack frame for a
    //                                                              procedure.
    defn = new InsnDefn("enter",  x86_enter,   0x03, 0xc800, od_iw, od_imm16, od_0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-317");
    define(defn);
    //  C8 iw 01      ENTER imm16,1          Valid       Valid      Create a nested stack frame for a
    //                                                              procedure.
    defn = new InsnDefn("enter",  x86_enter,   0x03, 0xc801, od_iw, od_imm16, od_1);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-317");
    define(defn);
    //  C8 iw ib      ENTER imm16, imm8 Valid            Valid      Create a nested stack frame for a
    //                                                              procedure.
    defn = new InsnDefn("enter",  x86_enter,   0x03, 0xc8, od_iw|od_ib, od_imm16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-321");
    define(defn);

    //--- page 3-321 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 3A 17      EXTRACTPS reg/m32,         Valid     Valid       Extract a single-precision
    //  /r ib            xmm2, imm8                                       floating-point value from xmm2
    //                                                                    at the source offset specified by
    //                                                                    imm8 and store the result to reg
    //                                                                    or m32. The upper 32 bits of r64
    //                                                                    is zeroed if reg is r64.
    defn = new InsnDefn("extractps", x86_extractps, 0x03, 0x660f3a17, od_modrm|od_ib, od_r_m32, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-324");
    define(defn);

    //--- page 3-324 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 F0              F2XM1              Valid       Valid         Replace ST(0) with (2ST(0)  1).
    defn = new InsnDefn("f2xm1",  x86_f2xm1,   0x03, 0xd9f0, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-326");
    define(defn);

    //--- page 3-326 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 E1              FABS                  Valid    Valid      Replace ST with its absolute value.
    defn = new InsnDefn("fabs",   x86_fabs,    0x03, 0xd9e1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);

    //--- page 3-328 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D8 /0           FADD m32fp           Valid    Valid      Add m32fp to ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fadd",   x86_fadd,    0x03, 0xd8, od_e0, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DC /0           FADD m64fp           Valid    Valid      Add m64fp to ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fadd",   x86_fadd,    0x03, 0xdc, od_e0, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // D8 C0+i         FADD ST(0), ST(i)    Valid    Valid      Add ST(0) to ST(i) and store result in
    //                                                          ST(0).
    defn = new InsnDefn("fadd",   x86_fadd,    0x03, 0xd8c0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DC C0+i         FADD ST(i), ST(0)    Valid    Valid      Add ST(i) to ST(0) and store result in
    //                                                          ST(i).
    defn = new InsnDefn("fadd",   x86_fadd,    0x03, 0xdcc0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DE C0+i         FADDP ST(i), ST(0)   Valid    Valid      Add ST(0) to ST(i), store result in
    //                                                          ST(i), and pop the register stack.
    defn = new InsnDefn("faddp",  x86_faddp,   0x03, 0xdec0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DE C1           FADDP                Valid    Valid      Add ST(0) to ST(1), store result in
    //                                                          ST(1), and pop the register stack.
    defn = new InsnDefn("faddp",  x86_faddp,   0x03, 0xdec1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DA /0           FIADD m32int         Valid    Valid      Add m32int to ST(0) and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fiadd",  x86_fiadd,   0x03, 0xda, od_e0, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-328");
    define(defn);
    // DE /0           FIADD m16int         Valid    Valid      Add m16int to ST(0) and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fiadd",  x86_fiadd,   0x03, 0xde, od_e0, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-332");
    define(defn);

    //--- page 3-332 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DF /4           FBLD m80 dec     Valid    Valid       Convert BCD value to floating-point and
    //                                                       push onto the FPU stack.
    defn = new InsnDefn("fbld",   x86_fbld,    0x03, 0xdf, od_e4, od_m80, od_dec);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-334");
    define(defn);

    //--- page 3-334 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DF /6       FBSTP m80bcd         Valid     Valid          Store ST(0) in m80bcd and pop ST(0).
    defn = new InsnDefn("fbstp",  x86_fbstp,   0x03, 0xdf, od_e6, od_m80bcd);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-337");
    define(defn);

    //--- page 3-337 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 E0          FCHS               Valid    Valid      Complements sign of ST(0).
    defn = new InsnDefn("fchs",   x86_fchs,    0x03, 0xd9e0, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-339");
    define(defn);

    //--- page 3-339 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  9B DB E2       FCLEX           Valid     Valid          Clear floating-point exception flags after
    //                                                          checking for pending unmasked floating-
    //                                                          point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("fclex",  x86_fclex,   0x03, 0x9bdbe2, od_none);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-339");
    // define(defn);
    //  DB E2          FNCLEX*         Valid     Valid          Clear floating-point exception flags
    //                                                          without checking for pending unmasked
    //                                                          floating-point exceptions.
    defn = new InsnDefn("fnclex", x86_fnclex,  0x03, 0xdbe2, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);

    //--- page 3-341 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  DA C0+i       FCMOVB ST(0), ST(i)        Valid    Valid       Move if below (CF=1).
    defn = new InsnDefn("fcmovb", x86_fcmovb,  0x03, 0xdac0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DA C8+i       FCMOVE ST(0), ST(i)        Valid    Valid       Move if equal (ZF=1).
    defn = new InsnDefn("fcmove", x86_fcmove,  0x03, 0xdac8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DA D0+i       FCMOVBE ST(0), ST(i)       Valid    Valid       Move if below or equal (CF=1 or
    //                                                                ZF=1).
    defn = new InsnDefn("fcmovbe", x86_fcmovbe, 0x03, 0xdad0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DA D8+i       FCMOVU ST(0), ST(i)        Valid    Valid       Move if unordered (PF=1).
    defn = new InsnDefn("fcmovu", x86_fcmovu,  0x03, 0xdad8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DB C0+i       FCMOVNB ST(0), ST(i)       Valid    Valid       Move if not below (CF=0).
    defn = new InsnDefn("fcmovnb", x86_fcmovnb, 0x03, 0xdbc0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DB C8+i       FCMOVNE ST(0), ST(i)       Valid    Valid       Move if not equal (ZF=0).
    defn = new InsnDefn("fcmovne", x86_fcmovne, 0x03, 0xdbc8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DB D0+i       FCMOVNBE ST(0), ST(i)      Valid    Valid       Move if not below or equal (CF=0
    //                                                                and ZF=0).
    defn = new InsnDefn("fcmovnbe", x86_fcmovnbe, 0x03, 0xdbd0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-341");
    define(defn);
    //  DB D8+i       FCMOVNU ST(0), ST(i)       Valid    Valid       Move if not unordered (PF=0).
    defn = new InsnDefn("fcmovnu", x86_fcmovnu, 0x03, 0xdbd8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);

    //--- page 3-343 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D8 /2           FCOM m32fp               Valid        Valid      Compare ST(0) with m32fp.
    defn = new InsnDefn("fcom",   x86_fcom,    0x03, 0xd8, od_e2, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  DC /2           FCOM m64fp               Valid        Valid      Compare ST(0) with m64fp.
    defn = new InsnDefn("fcom",   x86_fcom,    0x03, 0xdc, od_e2, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  D8 D0+i         FCOM ST(i)               Valid        Valid      Compare ST(0) with ST(i).
    defn = new InsnDefn("fcom",   x86_fcom,    0x03, 0xd8d0, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  D8 D1           FCOM                     Valid        Valid      Compare ST(0) with ST(1).
    defn = new InsnDefn("fcom",   x86_fcom,    0x03, 0xd8d1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  D8 /3           FCOMP m32fp              Valid        Valid      Compare ST(0) with m32fp and
    //                                                                   pop register stack.
    defn = new InsnDefn("fcomp",  x86_fcomp,   0x03, 0xd8, od_e3, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  DC /3           FCOMP m64fp              Valid        Valid      Compare ST(0) with m64fp and
    //                                                                   pop register stack.
    defn = new InsnDefn("fcomp",  x86_fcomp,   0x03, 0xdc, od_e3, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  D8 D8+i         FCOMP ST(i)              Valid        Valid      Compare ST(0) with ST(i) and pop
    //                                                                   register stack.
    defn = new InsnDefn("fcomp",  x86_fcomp,   0x03, 0xd8d8, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  D8 D9           FCOMP                    Valid        Valid      Compare ST(0) with ST(1) and pop
    //                                                                   register stack.
    defn = new InsnDefn("fcomp",  x86_fcomp,   0x03, 0xd8d9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-343");
    define(defn);
    //  DE D9           FCOMPP                   Valid        Valid      Compare ST(0) with ST(1) and pop
    //                                                                   register stack twice.
    defn = new InsnDefn("fcompp", x86_fcompp,  0x03, 0xded9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-347");
    define(defn);

    //--- page 3-347 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  DB F0+i      FCOMI ST, ST(i)     Valid      Valid        Compare ST(0) with ST(i) and set status
    //                                                           flags accordingly.
    defn = new InsnDefn("fcomi",  x86_fcomi,   0x03, 0xdbf0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-347");
    define(defn);
    //  DF F0+i      FCOMIP ST, ST(i)    Valid      Valid        Compare ST(0) with ST(i), set status flags
    //                                                           accordingly, and pop register stack.
    defn = new InsnDefn("fcomip", x86_fcomip,  0x03, 0xdff0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-347");
    define(defn);
    //  DB E8+i      FUCOMI ST, ST(i)    Valid      Valid        Compare ST(0) with ST(i), check for
    //                                                           ordered values, and set status flags
    //                                                           accordingly.
    defn = new InsnDefn("fucomi", x86_fucomi,  0x03, 0xdbe8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-347");
    define(defn);
    //  DF E8+i      FUCOMIP ST, ST(i) Valid        Valid        Compare ST(0) with ST(i), check for
    //                                                           ordered values, set status flags
    //                                                           accordingly, and pop register stack.
    defn = new InsnDefn("fucomip", x86_fucomip, 0x03, 0xdfe8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-350");
    define(defn);

    //--- page 3-350 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 FF              FCOS           Valid    Valid            Replace ST(0) with its cosine.
    defn = new InsnDefn("fcos",   x86_fcos,    0x03, 0xd9ff, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-352");
    define(defn);

    //--- page 3-352 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 F6           FDECSTP         Valid        Valid         Decrement TOP field in FPU status
    //                                                            word.
    defn = new InsnDefn("fdecstp", x86_fdecstp, 0x03, 0xd9f6, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);

    //--- page 3-354 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D8 /6           FDIV m32fp           Valid    Valid      Divide ST(0) by m32fp and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fdiv",   x86_fdiv,    0x03, 0xd8, od_e6, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DC /6           FDIV m64fp           Valid    Valid      Divide ST(0) by m64fp and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fdiv",   x86_fdiv,    0x03, 0xdc, od_e6, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // D8 F0+i         FDIV ST(0), ST(i)    Valid    Valid      Divide ST(0) by ST(i) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fdiv",   x86_fdiv,    0x03, 0xd8f0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DC F8+i         FDIV ST(i), ST(0)    Valid    Valid      Divide ST(i) by ST(0) and store result
    //                                                          in ST(i).
    defn = new InsnDefn("fdiv",   x86_fdiv,    0x03, 0xdcf8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DE F8+i         FDIVP ST(i), ST(0)   Valid    Valid      Divide ST(i) by ST(0), store result in
    //                                                          ST(i), and pop the register stack.
    defn = new InsnDefn("fdivp",  x86_fdivp,   0x03, 0xdef8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DE F9           FDIVP                Valid    Valid      Divide ST(1) by ST(0), store result in
    //                                                          ST(1), and pop the register stack.
    defn = new InsnDefn("fdivp",  x86_fdivp,   0x03, 0xdef9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DA /6           FIDIV m32int         Valid    Valid      Divide ST(0) by m32int and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fidiv",  x86_fidiv,   0x03, 0xda, od_e6, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-354");
    define(defn);
    // DE /6           FIDIV m16int         Valid    Valid      Divide ST(0) by m64int and store
    //                                                          result in ST(0).
    defn = new InsnDefn("fidiv",  x86_fidiv,   0x03, 0xde, od_e6, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);

    //--- page 3-358 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D8 /7           FDIVR m32fp          Valid    Valid      Divide m32fp by ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fdivr",  x86_fdivr,   0x03, 0xd8, od_e7, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DC /7           FDIVR m64fp          Valid    Valid      Divide m64fp by ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fdivr",  x86_fdivr,   0x03, 0xdc, od_e7, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // D8 F8+i         FDIVR ST(0), ST(i)   Valid    Valid      Divide ST(i) by ST(0) and store result in
    //                                                          ST(0).
    defn = new InsnDefn("fdivr",  x86_fdivr,   0x03, 0xd8f8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DC F0+i         FDIVR ST(i), ST(0)   Valid    Valid      Divide ST(0) by ST(i) and store result in
    //                                                          ST(i).
    defn = new InsnDefn("fdivr",  x86_fdivr,   0x03, 0xdcf0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DE F0+i         FDIVRP ST(i), ST(0) Valid     Valid      Divide ST(0) by ST(i), store result in
    //                                                          ST(i), and pop the register stack.
    defn = new InsnDefn("fdivrp", x86_fdivrp,  0x03, 0xdef0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DE F1           FDIVRP               Valid    Valid      Divide ST(0) by ST(1), store result in
    //                                                          ST(1), and pop the register stack.
    defn = new InsnDefn("fdivrp", x86_fdivrp,  0x03, 0xdef1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DA /7           FIDIVR m32int        Valid    Valid      Divide m32int by ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fidivr", x86_fidivr,  0x03, 0xda, od_e7, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-358");
    define(defn);
    // DE /7           FIDIVR m16int        Valid    Valid      Divide m16int by ST(0) and store result
    //                                                          in ST(0).
    defn = new InsnDefn("fidivr", x86_fidivr,  0x03, 0xde, od_e7, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-362");
    define(defn);

    //--- page 3-362 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DD C0+i         FFREE ST(i)     Valid     Valid        Sets tag for ST(i) to empty.
    defn = new InsnDefn("ffree",  x86_ffree,   0x03, 0xddc0, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-363");
    define(defn);

    //--- page 3-363 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  DE /2          FICOM m16int         Valid    Valid      Compare ST(0) with m16int.
    defn = new InsnDefn("ficom",  x86_ficom,   0x03, 0xde, od_e2, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-363");
    define(defn);
    //  DA /2          FICOM m32int         Valid    Valid      Compare ST(0) with m32int.
    defn = new InsnDefn("ficom",  x86_ficom,   0x03, 0xda, od_e2, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-363");
    define(defn);
    //  DE /3          FICOMP m16int        Valid    Valid      Compare ST(0) with m16int and pop
    //                                                          stack register.
    defn = new InsnDefn("ficomp", x86_ficomp,  0x03, 0xde, od_e3, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-363");
    define(defn);
    //  DA /3          FICOMP m32int        Valid    Valid      Compare ST(0) with m32int and pop
    //                                                          stack register.
    defn = new InsnDefn("ficomp", x86_ficomp,  0x03, 0xda, od_e3, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-366");
    define(defn);

    //--- page 3-366 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DF /0           FILD m16int   Valid     Valid        Push m16int onto the FPU register
    //                                                      stack.
    defn = new InsnDefn("fild",   x86_fild,    0x03, 0xdf, od_e0, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-366");
    define(defn);
    // DB /0           FILD m32int   Valid     Valid        Push m32int onto the FPU register
    //                                                      stack.
    defn = new InsnDefn("fild",   x86_fild,    0x03, 0xdb, od_e0, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-366");
    define(defn);
    // DF /5           FILD m64int   Valid     Valid        Push m64int onto the FPU register
    //                                                      stack.
    defn = new InsnDefn("fild",   x86_fild,    0x03, 0xdf, od_e5, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-368");
    define(defn);

    //--- page 3-368 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 F7           FINCSTP       Valid     Valid          Increment the TOP field in the FPU
    //                                                        status register.
    defn = new InsnDefn("fincstp", x86_fincstp, 0x03, 0xd9f7, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-370");
    define(defn);

    //--- page 3-370 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 9B DB E3        FINIT         Valid     Valid           Initialize FPU after checking for pending
    //                                                         unmasked floating-point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("finit",  x86_finit,   0x03, 0x9bdbe3, od_none);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-370");
    // define(defn);
    // DB E3           FNINIT*       Valid     Valid           Initialize FPU without checking for
    //                                                         pending unmasked floating-point
    //                                                         exceptions.
    defn = new InsnDefn("fninit", x86_fninit,  0x03, 0xdbe3, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-372");
    define(defn);

    //--- page 3-372 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DF /2            FIST m16int       Valid       Valid         Store ST(0) in m16int.
    defn = new InsnDefn("fist",   x86_fist,    0x03, 0xdf, od_e2, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-372");
    define(defn);
    // DB /2            FIST m32int       Valid       Valid         Store ST(0) in m32int.
    defn = new InsnDefn("fist",   x86_fist,    0x03, 0xdb, od_e2, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-372");
    define(defn);
    // DF /3            FISTP m16int      Valid       Valid         Store ST(0) in m16int and pop
    //                                                              register stack.
    defn = new InsnDefn("fistp",  x86_fistp,   0x03, 0xdf, od_e3, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-372");
    define(defn);
    // DB /3            FISTP m32int      Valid       Valid         Store ST(0) in m32int and pop
    //                                                              register stack.
    defn = new InsnDefn("fistp",  x86_fistp,   0x03, 0xdb, od_e3, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-372");
    define(defn);
    // DF /7            FISTP m64int      Valid       Valid         Store ST(0) in m64int and pop
    //                                                              register stack.
    defn = new InsnDefn("fistp",  x86_fistp,   0x03, 0xdf, od_e7, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-376");
    define(defn);

    //--- page 3-376 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DF /1           FISTTP m16int      Valid          Valid          Store ST(0) in m16int with
    //                                                                  truncation.
    defn = new InsnDefn("fisttp", x86_fisttp,  0x03, 0xdf, od_e1, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-376");
    define(defn);
    // DB /1           FISTTP m32int      Valid          Valid          Store ST(0) in m32int with
    //                                                                  truncation.
    defn = new InsnDefn("fisttp", x86_fisttp,  0x03, 0xdb, od_e1, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-376");
    define(defn);
    // DD /1           FISTTP m64int      Valid          Valid          Store ST(0) in m64int with
    //                                                                  truncation.
    defn = new InsnDefn("fisttp", x86_fisttp,  0x03, 0xdd, od_e1, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-379");
    define(defn);

    //--- page 3-379 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 /0           FLD m32fp      Valid    Valid      Push m32fp onto the FPU register stack.
    defn = new InsnDefn("fld",    x86_fld,     0x03, 0xd9, od_e0, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-379");
    define(defn);
    //  DD /0           FLD m64fp      Valid    Valid      Push m64fp onto the FPU register stack.
    defn = new InsnDefn("fld",    x86_fld,     0x03, 0xdd, od_e0, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-379");
    define(defn);
    //  DB /5           FLD m80fp      Valid    Valid      Push m80fp onto the FPU register stack.
    defn = new InsnDefn("fld",    x86_fld,     0x03, 0xdb, od_e5, od_m80fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-379");
    define(defn);
    //  D9 C0+i         FLD ST(i)      Valid    Valid      Push ST(i) onto the FPU register stack.
    defn = new InsnDefn("fld",    x86_fld,     0x03, 0xd9c0, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);

    //--- page 3-382 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 E8           FLD1           Valid     Valid          Push +1.0 onto the FPU register stack.
    defn = new InsnDefn("fld1",   x86_fld1,    0x03, 0xd9e8, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 E9           FLDL2T         Valid     Valid          Push log210 onto the FPU register stack.
    defn = new InsnDefn("fldl2t", x86_fldl2t,  0x03, 0xd9e9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 EA           FLDL2E         Valid     Valid          Push log2e onto the FPU register stack.
    defn = new InsnDefn("fldl2e", x86_fldl2e,  0x03, 0xd9ea, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 EB           FLDPI          Valid     Valid          Push  onto the FPU register stack.
    defn = new InsnDefn("fldpi",  x86_fldpi,   0x03, 0xd9eb, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 EC           FLDLG2         Valid     Valid          Push log102 onto the FPU register stack.
    defn = new InsnDefn("fldlg2", x86_fldlg2,  0x03, 0xd9ec, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 ED           FLDLN2         Valid     Valid          Push loge2 onto the FPU register stack.
    defn = new InsnDefn("fldln2", x86_fldln2,  0x03, 0xd9ed, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-382");
    define(defn);
    // D9 EE           FLDZ           Valid     Valid          Push +0.0 onto the FPU register stack.
    defn = new InsnDefn("fldz",   x86_fldz,    0x03, 0xd9ee, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-384");
    define(defn);

    //--- page 3-384 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 /5             FLDCW m2byte     Valid    Valid      Load FPU control word from m2byte.
    defn = new InsnDefn("fldcw",  x86_fldcw,   0x03, 0xd9, od_e5, od_m2byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-386");
    define(defn);

    //--- page 3-386 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 /4           FLDENV m14/28byte   Valid    Valid          Load FPU environment from
    //                                                             m14byte or m28byte.
    defn = new InsnDefn("fldenv", x86_fldenv,  0x03, 0xd9, od_e4, od_m14_28byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);

    //--- page 3-389 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D8 /1        FMUL m32fp           Valid    Valid      Multiply ST(0) by m32fp and store
    //                                                        result in ST(0).
    defn = new InsnDefn("fmul",   x86_fmul,    0x03, 0xd8, od_e1, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DC /1        FMUL m64fp           Valid    Valid      Multiply ST(0) by m64fp and store
    //                                                        result in ST(0).
    defn = new InsnDefn("fmul",   x86_fmul,    0x03, 0xdc, od_e1, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  D8 C8+i      FMUL ST(0), ST(i)    Valid    Valid      Multiply ST(0) by ST(i) and store result
    //                                                        in ST(0).
    defn = new InsnDefn("fmul",   x86_fmul,    0x03, 0xd8c8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DC C8+i      FMUL ST(i), ST(0)    Valid    Valid      Multiply ST(i) by ST(0) and store result
    //                                                        in ST(i).
    defn = new InsnDefn("fmul",   x86_fmul,    0x03, 0xdcc8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DE C8+i      FMULP ST(i), ST(0)   Valid    Valid      Multiply ST(i) by ST(0), store result in
    //                                                        ST(i), and pop the register stack.
    defn = new InsnDefn("fmulp",  x86_fmulp,   0x03, 0xdec8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DE C9        FMULP                Valid    Valid      Multiply ST(1) by ST(0), store result in
    //                                                        ST(1), and pop the register stack.
    defn = new InsnDefn("fmulp",  x86_fmulp,   0x03, 0xdec9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DA /1        FIMUL m32int         Valid    Valid      Multiply ST(0) by m32int and store
    //                                                        result in ST(0).
    defn = new InsnDefn("fimul",  x86_fimul,   0x03, 0xda, od_e1, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-389");
    define(defn);
    //  DE /1        FIMUL m16int         Valid    Valid      Multiply ST(0) by m16int and store
    //                                                        result in ST(0).
    defn = new InsnDefn("fimul",  x86_fimul,   0x03, 0xde, od_e1, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-393");
    define(defn);

    //--- page 3-393 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 D0              FNOP          Valid    Valid       No operation is performed.
    defn = new InsnDefn("fnop",   x86_fnop,    0x03, 0xd9d0, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-394");
    define(defn);

    //--- page 3-394 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 F3       FPATAN        Valid     Valid         Replace ST(1) with arctan(ST(1)ST(0)) and pop
    //                                                   the register stack.
    defn = new InsnDefn("fpatan", x86_fpatan,  0x03, 0xd9f3, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-397");
    define(defn);

    //--- page 3-397 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 F8        FPREM              Valid          Valid             Replace ST(0) with the remainder obtained
    //                                                                   from dividing ST(0) by ST(1).
    defn = new InsnDefn("fprem",  x86_fprem,   0x03, 0xd9f8, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-400");
    define(defn);

    //--- page 3-400 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 F5           FPREM1             Valid          Valid           Replace ST(0) with the IEEE remainder
    //                                                                   obtained from dividing ST(0) by ST(1).
    defn = new InsnDefn("fprem1", x86_fprem1,  0x03, 0xd9f5, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-403");
    define(defn);

    //--- page 3-403 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 F2          FPTAN            Valid        Valid          Replace ST(0) with its tangent and
    //                                                              push 1 onto the FPU stack.
    defn = new InsnDefn("fptan",  x86_fptan,   0x03, 0xd9f2, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-406");
    define(defn);

    //--- page 3-406 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 FC           FRNDINT       Valid      Valid        Round ST(0) to an integer.
    defn = new InsnDefn("frndint", x86_frndint, 0x03, 0xd9fc, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-408");
    define(defn);

    //--- page 3-408 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DD /4           FRSTOR m94/108byte Valid        Valid       Load FPU state from
    //                                                             m94byte or m108byte.
    defn = new InsnDefn("frstor", x86_frstor,  0x03, 0xdd, od_e4, od_m94_108byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-411");
    define(defn);

    //--- page 3-411 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  9B DD /6    FSAVE m94/108byte         Valid      Valid        Store FPU state to m94byte or
    //                                                                m108byte after checking for
    //                                                                pending unmasked floating-
    //                                                                point exceptions. Then re-
    //                                                                initialize the FPU.
    // See WAIT instead.
    // defn = new InsnDefn("fsave",  x86_fsave,   0x03, 0x9bdd, od_e6, od_m94_108byte);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-411");
    // define(defn);
    //  DD /6       FNSAVE* m94/108byte       Valid      Valid        Store FPU environment to
    //                                                                m94byte or m108byte without
    //                                                                checking for pending unmasked
    //                                                                floating-point exceptions. Then
    //                                                                re-initialize the FPU.
    defn = new InsnDefn("fnsave", x86_fnsave,  0x03, 0xdd, od_e6, od_m94_108byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-415");
    define(defn);

    //--- page 3-415 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 FD            FSCALE         Valid        Valid            Scale ST(0) by ST(1).
    defn = new InsnDefn("fscale", x86_fscale,  0x03, 0xd9fd, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-417");
    define(defn);

    //--- page 3-417 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 FE          FSIN             Valid        Valid           Replace ST(0) with its sine.
    defn = new InsnDefn("fsin",   x86_fsin,    0x03, 0xd9fe, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-419");
    define(defn);

    //--- page 3-419 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 FB          FSINCOS        Valid      Valid           Compute the sine and cosine of ST(0);
    //                                                           replace ST(0) with the sine, and push the
    //                                                           cosine onto the register stack.
    defn = new InsnDefn("fsincos", x86_fsincos, 0x03, 0xd9fb, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-422");
    define(defn);

    //--- page 3-422 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 FA           FSQRT         Valid     Valid         Computes square root of ST(0) and stores
    //                                                       the result in ST(0).
    defn = new InsnDefn("fsqrt",  x86_fsqrt,   0x03, 0xd9fa, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);

    //--- page 3-424 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 /2           FST m32fp     Valid    Valid        Copy ST(0) to m32fp.
    defn = new InsnDefn("fst",    x86_fst,     0x03, 0xd9, od_e2, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // DD /2           FST m64fp     Valid    Valid        Copy ST(0) to m64fp.
    defn = new InsnDefn("fst",    x86_fst,     0x03, 0xdd, od_e2, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // DD D0+i         FST ST(i)     Valid    Valid        Copy ST(0) to ST(i).
    defn = new InsnDefn("fst",    x86_fst,     0x03, 0xddd0, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // D9 /3           FSTP m32fp    Valid    Valid        Copy ST(0) to m32fp and pop register
    //                                                     stack.
    defn = new InsnDefn("fstp",   x86_fstp,    0x03, 0xd9, od_e3, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // DD /3           FSTP m64fp    Valid    Valid        Copy ST(0) to m64fp and pop register
    //                                                     stack.
    defn = new InsnDefn("fstp",   x86_fstp,    0x03, 0xdd, od_e3, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // DB /7           FSTP m80fp    Valid    Valid        Copy ST(0) to m80fp and pop register
    //                                                     stack.
    defn = new InsnDefn("fstp",   x86_fstp,    0x03, 0xdb, od_e7, od_m80fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-424");
    define(defn);
    // DD D8+i         FSTP ST(i)    Valid    Valid        Copy ST(0) to ST(i) and pop register
    //                                                     stack.
    defn = new InsnDefn("fstp",   x86_fstp,    0x03, 0xddd8, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-427");
    define(defn);

    //--- page 3-427 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  9B D9 /7      FSTCW m2byte         Valid     Valid      Store FPU control word to m2byte
    //                                                          after checking for pending unmasked
    //                                                          floating-point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("fstcw",  x86_fstcw,   0x03, 0x9bd9, od_e7, od_m2byte);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-427");
    // define(defn);
    //  D9 /7         FNSTCW* m2byte       Valid     Valid      Store FPU control word to m2byte
    //                                                          without checking for pending
    //                                                          unmasked floating-point exceptions.
    defn = new InsnDefn("fnstcw", x86_fnstcw,  0x03, 0xd9, od_e7, od_m2byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-430");
    define(defn);

    //--- page 3-430 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 9B D9 /6        FSTENV m14/28byte Valid        Valid         Store FPU environment to m14byte
    //                                                              or m28byte after checking for
    //                                                              pending unmasked floating-point
    //                                                              exceptions. Then mask all floating-
    //                                                              point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("fstenv", x86_fstenv,  0x03, 0x9bd9, od_e6, od_m14_28byte);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-430");
    // define(defn);
    // D9 /6           FNSTENV*             Valid     Valid         Store FPU environment to m14byte
    //                 m14/28byte                                   or m28byte without checking for
    //                                                              pending unmasked floating-point
    //                                                              exceptions. Then mask all floating-
    //                                                              point exceptions.
    defn = new InsnDefn("fnstenv", x86_fnstenv, 0x03, 0xd9, od_e6, od_m14_28byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-433");
    define(defn);

    //--- page 3-433 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  9B DD /7      FSTSW m2byte          Valid        Valid        Store FPU status word at
    //                                                                m2byte after checking for
    //                                                                pending unmasked floating-
    //                                                                point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("fstsw",  x86_fstsw,   0x03, 0x9bdd, od_e7, od_m2byte);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-433");
    // define(defn);
    //  9B DF E0      FSTSW AX              Valid        Valid        Store FPU status word in AX
    //                                                                register after checking for
    //                                                                pending unmasked floating-
    //                                                                point exceptions.
    // See WAIT instead.
    // defn = new InsnDefn("fstsw",  x86_fstsw,   0x03, 0x9bdfe0, od_none, od_AX);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-433");
    // define(defn);
    //  DD /7         FNSTSW* m2byte        Valid        Valid        Store FPU status word at
    //                                                                m2byte without checking for
    //                                                                pending unmasked floating-
    //                                                                point exceptions.
    defn = new InsnDefn("fnstsw", x86_fnstsw,  0x03, 0xdd, od_e7, od_m2byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-433");
    define(defn);
    //  DF E0         FNSTSW* AX            Valid        Valid        Store FPU status word in AX
    //                                                                register without checking for
    //                                                                pending unmasked floating-
    //                                                                point exceptions.
    defn = new InsnDefn("fnstsw", x86_fnstsw,  0x03, 0xdfe0, od_none, od_AX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);

    //--- page 3-436 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D8 /4           FSUB m32fp           Valid    Valid        Subtract m32fp from ST(0)
    //                                                            and store result in ST(0).
    defn = new InsnDefn("fsub",   x86_fsub,    0x03, 0xd8, od_e4, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DC /4           FSUB m64fp           Valid    Valid        Subtract m64fp from ST(0)
    //                                                            and store result in ST(0).
    defn = new InsnDefn("fsub",   x86_fsub,    0x03, 0xdc, od_e4, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // D8 E0+i         FSUB ST(0), ST(i)    Valid    Valid        Subtract ST(i) from ST(0) and
    //                                                            store result in ST(0).
    defn = new InsnDefn("fsub",   x86_fsub,    0x03, 0xd8e0, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DC E8+i         FSUB ST(i), ST(0)    Valid    Valid        Subtract ST(0) from ST(i) and
    //                                                            store result in ST(i).
    defn = new InsnDefn("fsub",   x86_fsub,    0x03, 0xdce8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DE E8+i         FSUBP ST(i), ST(0)   Valid    Valid        Subtract ST(0) from ST(i),
    //                                                            store result in ST(i), and pop
    //                                                            register stack.
    defn = new InsnDefn("fsubp",  x86_fsubp,   0x03, 0xdee8, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DE E9           FSUBP                Valid    Valid        Subtract ST(0) from ST(1),
    //                                                            store result in ST(1), and pop
    //                                                            register stack.
    defn = new InsnDefn("fsubp",  x86_fsubp,   0x03, 0xdee9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DA /4           FISUB m32int         Valid    Valid        Subtract m32int from ST(0)
    //                                                            and store result in ST(0).
    defn = new InsnDefn("fisub",  x86_fisub,   0x03, 0xda, od_e4, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-436");
    define(defn);
    // DE /4           FISUB m16int         Valid    Valid        Subtract m16int from ST(0)
    //                                                            and store result in ST(0).
    defn = new InsnDefn("fisub",  x86_fisub,   0x03, 0xde, od_e4, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);

    //--- page 3-440 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D8 /5           FSUBR m32fp           Valid    Valid        Subtract ST(0) from m32fp and
    //                                                             store result in ST(0).
    defn = new InsnDefn("fsubr",  x86_fsubr,   0x03, 0xd8, od_e5, od_m32fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DC /5           FSUBR m64fp           Valid    Valid        Subtract ST(0) from m64fp and
    //                                                             store result in ST(0).
    defn = new InsnDefn("fsubr",  x86_fsubr,   0x03, 0xdc, od_e5, od_m64fp);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // D8 E8+i         FSUBR ST(0), ST(i)    Valid    Valid        Subtract ST(0) from ST(i) and
    //                                                             store result in ST(0).
    defn = new InsnDefn("fsubr",  x86_fsubr,   0x03, 0xd8e8, od_i, od_st0, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DC E0+i         FSUBR ST(i), ST(0)    Valid    Valid        Subtract ST(i) from ST(0)and
    //                                                             store result in ST(i).
    defn = new InsnDefn("fsubr",  x86_fsubr,   0x03, 0xdce0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DE E0+i         FSUBRP ST(i), ST(0)   Valid    Valid        Subtract ST(i) from ST(0), store
    //                                                             result in ST(i), and pop register
    //                                                             stack.
    defn = new InsnDefn("fsubrp", x86_fsubrp,  0x03, 0xdee0, od_i, od_sti, od_st0);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DE E1           FSUBRP                Valid    Valid        Subtract ST(1) from ST(0),
    //                                                             store result in ST(1), and pop
    //                                                             register stack.
    defn = new InsnDefn("fsubrp", x86_fsubrp,  0x03, 0xdee1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DA /5           FISUBR m32int         Valid    Valid        Subtract ST(0) from m32int and
    //                                                             store result in ST(0).
    defn = new InsnDefn("fisubr", x86_fisubr,  0x03, 0xda, od_e5, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-440");
    define(defn);
    // DE /5           FISUBR m16int         Valid    Valid        Subtract ST(0) from m16int and
    //                                                             store result in ST(0).
    defn = new InsnDefn("fisubr", x86_fisubr,  0x03, 0xde, od_e5, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-444");
    define(defn);

    //--- page 3-444 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // D9 E4              FTST             Valid      Valid          Compare ST(0) with 0.0.
    defn = new InsnDefn("ftst",   x86_ftst,    0x03, 0xd9e4, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-446");
    define(defn);

    //--- page 3-446 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // DD E0+i         FUCOM ST(i)     Valid          Valid          Compare ST(0) with ST(i).
    defn = new InsnDefn("fucom",  x86_fucom,   0x03, 0xdde0, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-446");
    define(defn);
    // DD E1           FUCOM           Valid          Valid          Compare ST(0) with ST(1).
    defn = new InsnDefn("fucom",  x86_fucom,   0x03, 0xdde1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-446");
    define(defn);
    // DD E8+i         FUCOMP ST(i)    Valid          Valid          Compare ST(0) with ST(i) and pop
    //                                                               register stack.
    defn = new InsnDefn("fucomp", x86_fucomp,  0x03, 0xdde8, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-446");
    define(defn);
    // DD E9           FUCOMP          Valid          Valid          Compare ST(0) with ST(1) and pop
    //                                                               register stack.
    defn = new InsnDefn("fucomp", x86_fucomp,  0x03, 0xdde9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-446");
    define(defn);
    // DA E9           FUCOMPP         Valid          Valid          Compare ST(0) with ST(1) and pop
    //                                                               register stack twice.
    defn = new InsnDefn("fucompp", x86_fucompp, 0x03, 0xdae9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-449");
    define(defn);

    //--- page 3-449 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //     D9 E5         FXAM             Valid          Valid       Classify value or number in ST(0).
    defn = new InsnDefn("fxam",   x86_fxam,    0x03, 0xd9e5, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-451");
    define(defn);

    //--- page 3-451 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 C8+i           FXCH ST(i)     Valid    Valid          Exchange the contents of ST(0) and
    //                                                           ST(i).
    defn = new InsnDefn("fxch",   x86_fxch,    0x03, 0xd9c8, od_i, od_sti);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-451");
    define(defn);
    //  D9 C9             FXCH           Valid    Valid          Exchange the contents of ST(0) and
    //                                                           ST(1).
    defn = new InsnDefn("fxch",   x86_fxch,    0x03, 0xd9c9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-453");
    define(defn);

    //--- page 3-453 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F AE /1   FXRSTOR m512byte       Valid     Valid      Restore the x87 FPU, MMX, XMM,
    //                                                         and MXCSR register state from
    //                                                         m512byte.
    defn = new InsnDefn("fxrstor", x86_fxrstor, 0x03, 0x0fae, od_e1, od_m512byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-456");
    define(defn);

    //--- page 3-456 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F AE /0        FXSAVE m512byte    Valid           Valid                Save the x87 FPU, MMX, XMM,
    //                                                                         and MXCSR register state to
    //                                                                         m512byte.
    defn = new InsnDefn("fxsave", x86_fxsave,  0x03, 0x0fae, od_e0, od_m512byte);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-467");
    define(defn);

    //--- page 3-467 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 F4          FXTRACT         Valid      Valid      Separate value in ST(0) into exponent and
    //                                                       significand, store exponent in ST(0), and
    //                                                       push the significand onto the register
    //                                                       stack.
    defn = new InsnDefn("fxtract", x86_fxtract, 0x03, 0xd9f4, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-469");
    define(defn);

    //--- page 3-469 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 F1         FYL2X            Valid           Valid             Replace ST(1) with (ST(1) log2ST(0))
    //                                                                   and pop the register stack.
    defn = new InsnDefn("fyl2x",  x86_fyl2x,   0x03, 0xd9f1, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-471");
    define(defn);

    //--- page 3-471 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  D9 F9           FYL2XP1         Valid           Valid               Replace ST(1) with ST(1) log2(ST(0) +
    //                                                                      1.0) and pop the register stack.
    defn = new InsnDefn("fyl2xp1", x86_fyl2xp1, 0x03, 0xd9f9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-473");
    define(defn);

    //--- page 3-473 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 7C /r    HADDPD xmm1,         Valid     Valid           Horizontal add packed double-
    //                 xmm2/m128                                      precision floating-point values
    //                                                                from xmm2/m128 to xmm1.
    defn = new InsnDefn("haddpd", x86_haddpd,  0x03, 0x660f7c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-477");
    define(defn);

    //--- page 3-477 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 7C /r    HADDPS xmm1,        Valid         Valid             Horizontal add packed single-
    //                 xmm2/m128                                           precision floating-point values from
    //                                                                     xmm2/m128 to xmm1.
    defn = new InsnDefn("haddps", x86_haddps,  0x03, 0xf20f7c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-481");
    define(defn);

    //--- page 3-481 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F4           HLT           Valid       Valid          Halt
    defn = new InsnDefn("hlt",    x86_hlt,     0x03, 0xf4, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-483");
    define(defn);

    //--- page 3-483 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 7D /r    HSUBPD xmm1,          Valid     Valid         Horizontal subtract packed double-
    //                 xmm2/m128                                     precision floating-point values from
    //                                                               xmm2/m128 to xmm1.
    defn = new InsnDefn("hsubpd", x86_hsubpd,  0x03, 0x660f7d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-487");
    define(defn);

    //--- page 3-487 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 7D /r     HSUBPS xmm1,        Valid    Valid      Horizontal subtract packed single-
    //                  xmm2/m128                               precision floating-point values from
    //                                                          xmm2/m128 to xmm1.
    defn = new InsnDefn("hsubps", x86_hsubps,  0x03, 0xf20f7d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-491");
    define(defn);

    //--- page 3-491 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F6 /7               IDIV r/m8     Valid      Valid          Signed divide AX by r/m8, with result
    //                                                              stored in: AL  Quotient, AH
    //                                                              Remainder.
    defn = new InsnDefn("idiv",   x86_idiv,    0x03, 0xf6, od_e7, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-491");
    define(defn);
    //  REX + F6 /7         IDIV r/m8*    Valid      N.E.           Signed divide AX by r/m8, with result
    //                                                              stored in AL  Quotient, AH
    //                                                              Remainder.
    defn = new InsnDefn("idiv",   x86_idiv,    0x02, 0xf6, od_rex|od_e7, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-491");
    define(defn);
    //  F7 /7               IDIV r/m16    Valid      Valid          Signed divide DX:AX by r/m16, with
    //                                                              result stored in AX  Quotient, DX
    //                                                              Remainder.
    defn = new InsnDefn("idiv",   x86_idiv,    0x03, 0xf7, od_e7, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-491");
    define(defn);
    //  F7 /7               IDIV r/m32    Valid      Valid          Signed divide EDX:EAX by r/m32, with
    //                                                              result stored in EAX  Quotient, EDX
    //                                                               Remainder.
    defn = new InsnDefn("idiv",   x86_idiv,    0x03, 0xf7, od_e7, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-491");
    define(defn);
    //  REX.W + F7 /7       IDIV r/m64    Valid      N.E.           Signed divide RDX:RAX by r/m64, with
    //                                                              result stored in RAX  Quotient, RDX
    //                                                               Remainder.
    defn = new InsnDefn("idiv",   x86_idiv,    0x02, 0xf7, od_rexw|od_e7, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);

    //--- page 3-495 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F6 /5                 IMUL r/m8*         Valid    Valid       AX AL  r/m byte.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0xf6, od_e5, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  F7 /5                 IMUL r/m16         Valid    Valid       DX:AX  AX  r/m word.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0xf7, od_e5, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  F7 /5                 IMUL r/m32         Valid    Valid       EDX:EAX  EAX  r/m32.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0xf7, od_e5, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  REX.W + F7 /5         IMUL r/m64         Valid    N.E.        RDX:RAX  RAX  r/m64.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0xf7, od_rexw|od_e5, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  0F AF /r              IMUL r16, r/m16    Valid    Valid       word register  word register
    //                                                                r/m16.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x0faf, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  0F AF /r              IMUL r32, r/m32    Valid    Valid       doubleword register
    //                                                                doubleword register  r/m32.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x0faf, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  REX.W + 0F AF /r      IMUL r64, r/m64    Valid    N.E.        Quadword register  Quadword
    //                                                                register  r/m64.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0x0faf, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  6B /r ib              IMUL r16, r/m16,   Valid    Valid       word register  r/m16  sign-
    //                        imm8                                    extended immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x6b, od_modrm|od_ib, od_r16, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  6B /r ib              IMUL r32, r/m32,   Valid    Valid       doubleword register  r/m32
    //                        imm8                                    sign-extended immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x6b, od_modrm|od_ib, od_r32, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  REX.W + 6B /r ib      IMUL r64, r/m64,   Valid    N.E.        Quadword register  r/m64
    //                        imm8                                    sign-extended immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0x6b, od_rexw|od_modrm|od_ib, od_r64, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  6B /r ib              IMUL r16, imm8     Valid    Valid       word register  word register
    //                                                                sign-extended immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x6b, od_modrm|od_ib, od_r16, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  6B /r ib              IMUL r32, imm8     Valid    Valid       doubleword register
    //                                                                doubleword register  sign-
    //                                                                extended immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x6b, od_modrm|od_ib, od_r32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  REX.W + 6B /r ib      IMUL r64, imm8     Valid    N.E.        Quadword register  Quadword
    //                                                                register  sign-extended
    //                                                                immediate byte.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0x6b, od_rexw|od_modrm|od_ib, od_r64, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  69 /r iw              IMUL r16, r/m16,   Valid    Valid       word register  r/m16
    //                        imm16                                   immediate word.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x69, od_modrm|od_iw, od_r16, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  69 /r id              IMUL r32, r/m32,   Valid    Valid       doubleword register  r/m32
    //                        imm32                                   immediate doubleword.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x69, od_modrm|od_id, od_r32, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  REX.W + 69 /r id      IMUL r64, r/m64,   Valid    N.E.        Quadword register  r/m64
    //                        imm32                                   immediate doubleword.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0x69, od_rexw|od_modrm|od_id, od_r64, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-495");
    define(defn);
    //  69 /r iw              IMUL r16, imm16    Valid    Valid       word register  r/m16
    //                                                                immediate word.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x69, od_modrm|od_iw, od_r16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-496");
    define(defn);
    // 69 /r id            IMUL r32, imm32     Valid      Valid         doubleword register  r/m32
    //                                                                  immediate doubleword.
    defn = new InsnDefn("imul",   x86_imul,    0x03, 0x69, od_modrm|od_id, od_r32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-496");
    define(defn);
    // REX.W + 69 /r id    IMUL r64, imm32     Valid      N.E.          Quadword register  r/m64
    //                                                                  immediate doubleword.
    defn = new InsnDefn("imul",   x86_imul,    0x02, 0x69, od_rexw|od_modrm|od_id, od_r64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);

    //--- page 3-500 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // E4 ib       IN AL, imm8     Valid      Valid         Input byte from imm8 I/O port address into
    //                                                      AL.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xe4, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);
    // E5 ib       IN AX, imm8     Valid      Valid         Input word from imm8 I/O port address into
    //                                                      AX.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xe5, od_ib, od_AX, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);
    // E5 ib       IN EAX, imm8    Valid      Valid         Input dword from imm8 I/O port address into
    //                                                      EAX.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xe5, od_ib, od_EAX, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);
    // EC          IN AL,DX        Valid      Valid         Input byte from I/O port in DX into AL.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xec, od_none, od_AL, od_DX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);
    // ED          IN AX,DX        Valid      Valid         Input word from I/O port in DX into AX.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xed, od_none, od_AX, od_DX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-500");
    define(defn);
    // ED          IN EAX,DX       Valid      Valid         Input doubleword from I/O port in DX into
    //                                                      EAX.
    defn = new InsnDefn("in",     x86_in,      0x03, 0xed, od_none, od_EAX, od_DX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);

    //--- page 3-502 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // FE /0              INC r/m8      Valid      Valid           Increment r/m byte by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x03, 0xfe, od_e0, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // REX + FE /0        INC r/m8*     Valid      N.E.            Increment r/m byte by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x02, 0xfe, od_rex|od_e0, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // FF /0              INC r/m16     Valid      Valid           Increment r/m word by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x03, 0xff, od_e0, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // FF /0              INC r/m32     Valid      Valid           Increment r/m doubleword by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x03, 0xff, od_e0, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // REX.W + FF /0      INC r/m64     Valid      N.E.            Increment r/m quadword by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x02, 0xff, od_rexw|od_e0, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // 40+ rw**           INC r16       N.E.       Valid           Increment word register by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x01, 0x40, od_rw, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-502");
    define(defn);
    // 40+ rd             INC r32       N.E.       Valid           Increment doubleword register by 1.
    defn = new InsnDefn("inc",    x86_inc,     0x01, 0x40, od_rd, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    define(defn);

    //--- page 3-505 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  6C              INS m8, DX       Valid        Valid      Input byte from I/O port specified in DX
    //                                                           into memory location specified in ES:(E)DI
    //                                                           or RDI.*
    // See INSB, INSW, or INSD instead.
    // defn = new InsnDefn("ins",    x86_ins,     0x03, 0x6c, od_none, od_m8, od_DX);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    // define(defn);
    //  6D              INS m16, DX      Valid        Valid      Input word from I/O port specified in DX
    //                                                           into memory location specified in ES:(E)DI
    //                                                           or RDI.1
    // See INSB, INSW, or INSD instead.
    // defn = new InsnDefn("ins",    x86_ins,     0x03, 0x6d, od_none, od_m16, od_DX);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    // define(defn);
    //  6D              INS m32, DX      Valid        Valid      Input doubleword from I/O port specified
    //                                                           in DX into memory location specified in
    //                                                           ES:(E)DI or RDI.1
    // See INSB, INSW, or INSD instead.
    // defn = new InsnDefn("ins",    x86_ins,     0x03, 0x6d, od_none, od_m32, od_DX);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    // define(defn);
    //  6C              INSB             Valid        Valid      Input byte from I/O port specified in DX
    //                                                           into memory location specified with
    //                                                           ES:(E)DI or RDI.1
    defn = new InsnDefn("insb",   x86_insb,    0x03, 0x6c, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    define(defn);
    //  6D              INSW             Valid        Valid      Input word from I/O port specified in DX
    //                                                           into memory location specified in ES:(E)DI
    //                                                           or RDI.1
    defn = new InsnDefn("insw",   x86_insw,    0x03, 0x6d, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-505");
    define(defn);
    //  6D              INSD             Valid        Valid      Input doubleword from I/O port specified
    //                                                           in DX into memory location specified in
    //                                                           ES:(E)DI or RDI.1
    defn = new InsnDefn("insd",   x86_insd,    0x03, 0x6d, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-509");
    define(defn);

    //--- page 3-509 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 3A       INSERTPS xmm1,        Valid    Valid         Insert a single precision floating-point
    //  21 /r ib       xmm2/m32,                                    value selected by imm8 from xmm2/m32
    //                 imm8                                         into xmm1 at the specified destination
    //                                                              element specified by imm8 and zero out
    //                                                              destination elements in xmm1 as indicated
    //                                                              in imm8.
    defn = new InsnDefn("insertps", x86_insertps, 0x03, 0x660f3a21, od_modrm|od_ib, od_xmm, od_xmm_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-512");
    define(defn);

    //--- page 3-512 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // CC              INT 3         Valid     Valid        Interrupt 3trap to debugger.
    defn = new InsnDefn("int3",   x86_int3,    0x03, 0xcc, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-512");
    define(defn);
    // CD ib           INT imm8      Valid     Valid        Interrupt vector number specified by
    //                                                      immediate byte.
    defn = new InsnDefn("int",    x86_int,     0x03, 0xcd, od_ib, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-512");
    define(defn);
    // CE              INTO          Invalid   Valid        Interrupt 4if overflow flag is 1.
    defn = new InsnDefn("into",   x86_into,    0x01, 0xce, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-527");
    define(defn);

    //--- page 3-527 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 08           INVD             Valid    Valid      Flush internal caches; initiate flushing of
    //                                                       external caches.
    defn = new InsnDefn("invd",   x86_invd,    0x03, 0x0f08, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-529");
    define(defn);

    //--- page 3-529 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 01/7       INVLPG m        Valid      Valid          Invalidate TLB Entry for page that
    //                                                          contains m.
    defn = new InsnDefn("invlpg", x86_invlpg,  0x03, 0x0f01, od_e7, od_m);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-531");
    define(defn);

    //--- page 3-531 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  CF              IRET          Valid    Valid         Interrupt return (16-bit operand
    //                                                       size).
    defn = new InsnDefn("iret",   x86_iret,    0x03, 0xcf, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-531");
    define(defn);
    //  CF              IRETD         Valid    Valid         Interrupt return (32-bit operand
    //                                                       size).
    defn = new InsnDefn("iret",   x86_iret,    0x03, 0xcf, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-531");
    define(defn);
    //  REX.W + CF      IRETQ         Valid    N.E.          Interrupt return (64-bit operand
    //                                                       size).
    defn = new InsnDefn("iret",   x86_iret,    0x02, 0xcf, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);

    //--- page 3-542 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 77 cb           JA rel8       Valid    Valid      Jump short if above (CF=0 and ZF=0).
    defn = new InsnDefn("ja",     x86_ja,      0x03, 0x77, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 73 cb           JAE rel8      Valid    Valid      Jump short if above or equal (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x73, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 72 cb           JB rel8       Valid    Valid      Jump short if below (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x72, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 76 cb           JBE rel8      Valid    Valid      Jump short if below or equal (CF=1 or
    //                                                   ZF=1).
    defn = new InsnDefn("jbe",    x86_jbe,     0x03, 0x76, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 72 cb           JC rel8       Valid    Valid      Jump short if carry (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x72, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // E3 cb           JCXZ rel8     N.E.     Valid      Jump short if CX register is 0.
    defn = new InsnDefn("jcxz",   x86_jcxz,    0x01, 0xe3, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // E3 cb           JECXZ rel8    Valid    Valid      Jump short if ECX register is 0.
    defn = new InsnDefn("jecxz",  x86_jecxz,   0x03, 0xe3, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // E3 cb           JRCXZ rel8    Valid    N.E.       Jump short if RCX register is 0.
    defn = new InsnDefn("jrcxz",  x86_jrcxz,   0x02, 0xe3, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 74 cb           JE rel8       Valid    Valid      Jump short if equal (ZF=1).
    defn = new InsnDefn("je",     x86_je,      0x03, 0x74, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7F cb           JG rel8       Valid    Valid      Jump short if greater (ZF=0 and SF=OF).
    defn = new InsnDefn("jg",     x86_jg,      0x03, 0x7f, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7D cb           JGE rel8      Valid    Valid      Jump short if greater or equal (SF=OF).
    defn = new InsnDefn("jge",    x86_jge,     0x03, 0x7d, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7C cb           JL rel8       Valid    Valid      Jump short if less (SF OF).
    defn = new InsnDefn("jl",     x86_jl,      0x03, 0x7c, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7E cb           JLE rel8      Valid    Valid      Jump short if less or equal (ZF=1 or SF
    //                                                   OF).
    defn = new InsnDefn("jle",    x86_jle,     0x03, 0x7e, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 76 cb           JNA rel8      Valid    Valid      Jump short if not above (CF=1 or ZF=1).
    defn = new InsnDefn("jbe",    x86_jbe,     0x03, 0x76, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 72 cb           JNAE rel8     Valid    Valid      Jump short if not above or equal (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x72, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 73 cb           JNB rel8      Valid    Valid      Jump short if not below (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x73, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 77 cb           JNBE rel8     Valid    Valid      Jump short if not below or equal (CF=0
    //                                                   and ZF=0).
    defn = new InsnDefn("ja",     x86_ja,      0x03, 0x77, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 73 cb           JNC rel8      Valid    Valid      Jump short if not carry (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x73, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 75 cb           JNE rel8      Valid    Valid      Jump short if not equal (ZF=0).
    defn = new InsnDefn("jne",    x86_jne,     0x03, 0x75, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7E cb           JNG rel8      Valid    Valid      Jump short if not greater (ZF=1 or SF
    //                                                   OF).
    defn = new InsnDefn("jle",    x86_jle,     0x03, 0x7e, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7C cb           JNGE rel8     Valid    Valid      Jump short if not greater or equal (SF
    //                                                   OF).
    defn = new InsnDefn("jl",     x86_jl,      0x03, 0x7c, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7D cb           JNL rel8      Valid    Valid      Jump short if not less (SF=OF).
    defn = new InsnDefn("jge",    x86_jge,     0x03, 0x7d, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7F cb           JNLE rel8     Valid    Valid      Jump short if not less or equal (ZF=0 and
    //                                                   SF=OF).
    defn = new InsnDefn("jg",     x86_jg,      0x03, 0x7f, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 71 cb           JNO rel8      Valid    Valid      Jump short if not overflow (OF=0).
    defn = new InsnDefn("jno",    x86_jno,     0x03, 0x71, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 7B cb           JNP rel8      Valid    Valid      Jump short if not parity (PF=0).
    defn = new InsnDefn("jpo",    x86_jpo,     0x03, 0x7b, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-542");
    define(defn);
    // 79 cb           JNS rel8      Valid    Valid      Jump short if not sign (SF=0).
    defn = new InsnDefn("jns",    x86_jns,     0x03, 0x79, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  75 cb            JNZ rel8      Valid    Valid      Jump short if not zero (ZF=0).
    defn = new InsnDefn("jne",    x86_jne,     0x03, 0x75, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  70 cb            JO rel8       Valid    Valid      Jump short if overflow (OF=1).
    defn = new InsnDefn("jo",     x86_jo,      0x03, 0x70, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  7A cb            JP rel8       Valid    Valid      Jump short if parity (PF=1).
    defn = new InsnDefn("jpe",    x86_jpe,     0x03, 0x7a, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  7A cb            JPE rel8      Valid    Valid      Jump short if parity even (PF=1).
    defn = new InsnDefn("jpe",    x86_jpe,     0x03, 0x7a, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  7B cb            JPO rel8      Valid    Valid      Jump short if parity odd (PF=0).
    defn = new InsnDefn("jpo",    x86_jpo,     0x03, 0x7b, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  78 cb            JS rel8       Valid    Valid      Jump short if sign (SF=1).
    defn = new InsnDefn("js",     x86_js,      0x03, 0x78, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  74 cb            JZ rel8       Valid    Valid      Jump short if zero (ZF  1).
    defn = new InsnDefn("je",     x86_je,      0x03, 0x74, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 87 cw         JA rel16      N.S.     Valid      Jump near if above (CF=0 and ZF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("ja",     x86_ja,      0x01, 0x0f87, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 87 cd         JA rel32      Valid    Valid      Jump near if above (CF=0 and ZF=0).
    defn = new InsnDefn("ja",     x86_ja,      0x03, 0x0f87, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 83 cw         JAE rel16     N.S.     Valid      Jump near if above or equal (CF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jae",    x86_jae,     0x01, 0x0f83, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 83 cd         JAE rel32     Valid    Valid      Jump near if above or equal (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x0f83, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 82 cw         JB rel16      N.S.     Valid      Jump near if below (CF=1). Not supported
    //                                                     in 64-bit mode.
    defn = new InsnDefn("jb",     x86_jb,      0x01, 0x0f82, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 82 cd         JB rel32      Valid    Valid      Jump near if below (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x0f82, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 86 cw         JBE rel16     N.S.     Valid      Jump near if below or equal (CF=1 or
    //                                                     ZF=1). Not supported in 64-bit mode.
    defn = new InsnDefn("jbe",    x86_jbe,     0x01, 0x0f86, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 86 cd         JBE rel32     Valid    Valid      Jump near if below or equal (CF=1 or
    //                                                     ZF=1).
    defn = new InsnDefn("jbe",    x86_jbe,     0x03, 0x0f86, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 82 cw         JC rel16      N.S.     Valid      Jump near if carry (CF=1). Not supported
    //                                                     in 64-bit mode.
    defn = new InsnDefn("jb",     x86_jb,      0x01, 0x0f82, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 82 cd         JC rel32      Valid    Valid      Jump near if carry (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x0f82, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 84 cw         JE rel16      N.S.     Valid      Jump near if equal (ZF=1). Not supported
    //                                                     in 64-bit mode.
    defn = new InsnDefn("je",     x86_je,      0x01, 0x0f84, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 84 cd         JE rel32      Valid    Valid      Jump near if equal (ZF=1).
    defn = new InsnDefn("je",     x86_je,      0x03, 0x0f84, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 84 cw         JZ rel16      N.S.     Valid      Jump near if 0 (ZF=1). Not supported in
    //                                                     64-bit mode.
    defn = new InsnDefn("je",     x86_je,      0x01, 0x0f84, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 84 cd         JZ rel32      Valid    Valid      Jump near if 0 (ZF=1).
    defn = new InsnDefn("je",     x86_je,      0x03, 0x0f84, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 8F cw         JG rel16      N.S.     Valid      Jump near if greater (ZF=0 and SF=OF).
    //                                                     Not supported in 64-bit mode.
    defn = new InsnDefn("jg",     x86_jg,      0x01, 0x0f8f, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 8F cd         JG rel32      Valid    Valid      Jump near if greater (ZF=0 and SF=OF).
    defn = new InsnDefn("jg",     x86_jg,      0x03, 0x0f8f, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 8D cw         JGE rel16     N.S.     Valid      Jump near if greater or equal (SF=OF).
    //                                                     Not supported in 64-bit mode.
    defn = new InsnDefn("jge",    x86_jge,     0x01, 0x0f8d, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-543");
    define(defn);
    //  0F 8D cd         JGE rel32     Valid    Valid      Jump near if greater or equal (SF=OF).
    defn = new InsnDefn("jge",    x86_jge,     0x03, 0x0f8d, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8C cw        JL rel16      N.S.     Valid      Jump near if less (SF OF). Not supported
    //                                                   in 64-bit mode.
    defn = new InsnDefn("jl",     x86_jl,      0x01, 0x0f8c, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8C cd        JL rel32      Valid    Valid      Jump near if less (SF OF).
    defn = new InsnDefn("jl",     x86_jl,      0x03, 0x0f8c, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8E cw        JLE rel16     N.S.     Valid      Jump near if less or equal (ZF=1 or SF
    //                                                   OF). Not supported in 64-bit mode.
    defn = new InsnDefn("jle",    x86_jle,     0x01, 0x0f8e, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8E cd        JLE rel32     Valid    Valid      Jump near if less or equal (ZF=1 or SF
    //                                                   OF).
    defn = new InsnDefn("jle",    x86_jle,     0x03, 0x0f8e, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 86 cw        JNA rel16     N.S.     Valid      Jump near if not above (CF=1 or ZF=1).
    //                                                   Not supported in 64-bit mode.
    defn = new InsnDefn("jbe",    x86_jbe,     0x01, 0x0f86, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 86 cd        JNA rel32     Valid    Valid      Jump near if not above (CF=1 or ZF=1).
    defn = new InsnDefn("jbe",    x86_jbe,     0x03, 0x0f86, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 82 cw        JNAE rel16    N.S.     Valid      Jump near if not above or equal (CF=1).
    //                                                   Not supported in 64-bit mode.
    defn = new InsnDefn("jb",     x86_jb,      0x01, 0x0f82, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 82 cd        JNAE rel32    Valid    Valid      Jump near if not above or equal (CF=1).
    defn = new InsnDefn("jb",     x86_jb,      0x03, 0x0f82, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 83 cw        JNB rel16     N.S.     Valid      Jump near if not below (CF=0). Not
    //                                                   supported in 64-bit mode.
    defn = new InsnDefn("jae",    x86_jae,     0x01, 0x0f83, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 83 cd        JNB rel32     Valid    Valid      Jump near if not below (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x0f83, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 87 cw        JNBE rel16    N.S.     Valid      Jump near if not below or equal (CF=0
    //                                                   and ZF=0). Not supported in 64-bit
    //                                                   mode.
    defn = new InsnDefn("ja",     x86_ja,      0x01, 0x0f87, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 87 cd        JNBE rel32    Valid    Valid      Jump near if not below or equal (CF=0
    //                                                   and ZF=0).
    defn = new InsnDefn("ja",     x86_ja,      0x03, 0x0f87, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 83 cw        JNC rel16     N.S.     Valid      Jump near if not carry (CF=0). Not
    //                                                   supported in 64-bit mode.
    defn = new InsnDefn("jae",    x86_jae,     0x01, 0x0f83, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 83 cd        JNC rel32     Valid    Valid      Jump near if not carry (CF=0).
    defn = new InsnDefn("jae",    x86_jae,     0x03, 0x0f83, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 85 cw        JNE rel16     N.S.     Valid      Jump near if not equal (ZF=0). Not
    //                                                   supported in 64-bit mode.
    defn = new InsnDefn("jne",    x86_jne,     0x01, 0x0f85, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 85 cd        JNE rel32     Valid    Valid      Jump near if not equal (ZF=0).
    defn = new InsnDefn("jne",    x86_jne,     0x03, 0x0f85, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8E cw        JNG rel16     N.S.     Valid      Jump near if not greater (ZF=1 or SF
    //                                                   OF). Not supported in 64-bit mode.
    defn = new InsnDefn("jle",    x86_jle,     0x01, 0x0f8e, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8E cd        JNG rel32     Valid    Valid      Jump near if not greater (ZF=1 or SF
    //                                                   OF).
    defn = new InsnDefn("jle",    x86_jle,     0x03, 0x0f8e, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-544");
    define(defn);
    // 0F 8C cw        JNGE rel16    N.S.     Valid      Jump near if not greater or equal (SF
    //                                                   OF). Not supported in 64-bit mode.
    defn = new InsnDefn("jl",     x86_jl,      0x01, 0x0f8c, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8C cd         JNGE rel32    Valid    Valid      Jump near if not greater or equal (SF
    //                                                     OF).
    defn = new InsnDefn("jl",     x86_jl,      0x03, 0x0f8c, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8D cw         JNL rel16     N.S.     Valid      Jump near if not less (SF=OF). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jge",    x86_jge,     0x01, 0x0f8d, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8D cd         JNL rel32     Valid    Valid      Jump near if not less (SF=OF).
    defn = new InsnDefn("jge",    x86_jge,     0x03, 0x0f8d, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8F cw         JNLE rel16    N.S.     Valid      Jump near if not less or equal (ZF=0 and
    //                                                     SF=OF). Not supported in 64-bit mode.
    defn = new InsnDefn("jg",     x86_jg,      0x01, 0x0f8f, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8F cd         JNLE rel32    Valid    Valid      Jump near if not less or equal (ZF=0 and
    //                                                     SF=OF).
    defn = new InsnDefn("jg",     x86_jg,      0x03, 0x0f8f, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 81 cw         JNO rel16     N.S.     Valid      Jump near if not overflow (OF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jno",    x86_jno,     0x01, 0x0f81, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 81 cd         JNO rel32     Valid    Valid      Jump near if not overflow (OF=0).
    defn = new InsnDefn("jno",    x86_jno,     0x03, 0x0f81, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8B cw         JNP rel16     N.S.     Valid      Jump near if not parity (PF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jpo",    x86_jpo,     0x01, 0x0f8b, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8B cd         JNP rel32     Valid    Valid      Jump near if not parity (PF=0).
    defn = new InsnDefn("jpo",    x86_jpo,     0x03, 0x0f8b, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 89 cw         JNS rel16     N.S.     Valid      Jump near if not sign (SF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jns",    x86_jns,     0x01, 0x0f89, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 89 cd         JNS rel32     Valid    Valid      Jump near if not sign (SF=0).
    defn = new InsnDefn("jns",    x86_jns,     0x03, 0x0f89, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 85 cw         JNZ rel16     N.S.     Valid      Jump near if not zero (ZF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jne",    x86_jne,     0x01, 0x0f85, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 85 cd         JNZ rel32     Valid    Valid      Jump near if not zero (ZF=0).
    defn = new InsnDefn("jne",    x86_jne,     0x03, 0x0f85, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 80 cw         JO rel16      N.S.     Valid      Jump near if overflow (OF=1). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jo",     x86_jo,      0x01, 0x0f80, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 80 cd         JO rel32      Valid    Valid      Jump near if overflow (OF=1).
    defn = new InsnDefn("jo",     x86_jo,      0x03, 0x0f80, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8A cw         JP rel16      N.S.     Valid      Jump near if parity (PF=1). Not supported
    //                                                     in 64-bit mode.
    defn = new InsnDefn("jpe",    x86_jpe,     0x01, 0x0f8a, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8A cd         JP rel32      Valid    Valid      Jump near if parity (PF=1).
    defn = new InsnDefn("jpe",    x86_jpe,     0x03, 0x0f8a, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8A cw         JPE rel16     N.S.     Valid      Jump near if parity even (PF=1). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jpe",    x86_jpe,     0x01, 0x0f8a, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8A cd         JPE rel32     Valid    Valid      Jump near if parity even (PF=1).
    defn = new InsnDefn("jpe",    x86_jpe,     0x03, 0x0f8a, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8B cw         JPO rel16     N.S.     Valid      Jump near if parity odd (PF=0). Not
    //                                                     supported in 64-bit mode.
    defn = new InsnDefn("jpo",    x86_jpo,     0x01, 0x0f8b, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 8B cd         JPO rel32     Valid    Valid      Jump near if parity odd (PF=0).
    defn = new InsnDefn("jpo",    x86_jpo,     0x03, 0x0f8b, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-545");
    define(defn);
    //  0F 88 cw         JS rel16      N.S.     Valid      Jump near if sign (SF=1). Not supported
    //                                                     in 64-bit mode.
    defn = new InsnDefn("js",     x86_js,      0x01, 0x0f88, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-546");
    define(defn);
    // 0F 88 cd        JS rel32      Valid     Valid        Jump near if sign (SF=1).
    defn = new InsnDefn("js",     x86_js,      0x03, 0x0f88, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-546");
    define(defn);
    // 0F 84 cw        JZ rel16      N.S.      Valid        Jump near if 0 (ZF=1). Not supported in
    //                                                      64-bit mode.
    defn = new InsnDefn("je",     x86_je,      0x01, 0x0f84, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-546");
    define(defn);
    // 0F 84 cd        JZ rel32      Valid     Valid        Jump near if 0 (ZF=1).
    defn = new InsnDefn("je",     x86_je,      0x03, 0x0f84, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);

    //--- page 3-549 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  EB cb     JMP rel8      Valid      Valid       Jump short, RIP = RIP + 8-bit displacement
    //                                                 sign extended to 64-bits
    defn = new InsnDefn("jmp",    x86_jmp,     0x03, 0xeb, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  E9 cw     JMP rel16     N.S.       Valid       Jump near, relative, displacement relative
    //                                                 to next instruction. Not supported in 64-bit
    //                                                 mode.
    defn = new InsnDefn("jmp",    x86_jmp,     0x01, 0xe9, od_cw, od_rel16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  E9 cd     JMP rel32     Valid      Valid       Jump near, relative, RIP = RIP + 32-bit
    //                                                 displacement sign extended to 64-bits
    defn = new InsnDefn("jmp",    x86_jmp,     0x03, 0xe9, od_cd, od_rel32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  FF /4     JMP r/m16     N.S.       Valid       Jump near, absolute indirect, address =
    //                                                 sign-extended r/m16. Not supported in 64-
    //                                                 bit mode.
    defn = new InsnDefn("jmp",    x86_jmp,     0x01, 0xff, od_e4, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  FF /4     JMP r/m32     N.S.       Valid       Jump near, absolute indirect, address =
    //                                                 sign-extended r/m32. Not supported in 64-
    //                                                 bit mode.
    defn = new InsnDefn("jmp",    x86_jmp,     0x01, 0xff, od_e4, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  FF /4     JMP r/m64     Valid      N.E.        Jump near, absolute indirect, RIP = 64-Bit
    //                                                 offset from register or memory
    defn = new InsnDefn("jmp",    x86_jmp,     0x02, 0xff, od_e4, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  EA cd     JMP ptr16:16 Inv.        Valid       Jump far, absolute, address given in
    //                                                 operand
    defn = new InsnDefn("jmp",    x86_farjmp,  0x01, 0xea, od_cd, od_ptr16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  EA cp     JMP ptr16:32 Inv.        Valid       Jump far, absolute, address given in
    //                                                 operand
    defn = new InsnDefn("jmp",    x86_farjmp,  0x01, 0xea, od_cp, od_ptr16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  FF /5     JMP m16:16    Valid      Valid       Jump far, absolute indirect, address given in
    //                                                 m16:16
    defn = new InsnDefn("jmp",    x86_farjmp,  0x03, 0xff, od_e5, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  FF /5     JMP m16:32    Valid      Valid       Jump far, absolute indirect, address given in
    //                                                 m16:32.
    defn = new InsnDefn("jmp",    x86_farjmp,  0x03, 0xff, od_e5, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-549");
    define(defn);
    //  REX.W +   JMP m16:64    Valid      N.E.        Jump far, absolute indirect, address given in
    //  FF /5                                          m16:64.
    defn = new InsnDefn("jmp",    x86_farjmp,  0x02, 0xff, od_rexw|od_e5, od_m16_64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-559");
    define(defn);

    //--- page 3-559 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  9F           LAHF           Invalid*     Valid            Load: AH  EFLAGS(SF:ZF:0:AF:0:PF:1:CF).
    defn = new InsnDefn("lahf",   x86_lahf,    0x01, 0x9f, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-561");
    define(defn);

    //--- page 3-561 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 02 /r     LAR r16, r16/m16      Valid            Valid            r16  r16/m16 masked by
    //                                                                       FF00H.
    defn = new InsnDefn("lar",    x86_lar,     0x03, 0x0f02, od_modrm, od_r16, od_r16_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-561");
    define(defn);
    //  0F 02 /r     LAR r32, r32/m161 Valid                Valid            r32  r32/m16 masked by
    //                                                                       00FxFF00H
    defn = new InsnDefn("lar",    x86_lar,     0x03, 0x0f02, od_modrm, od_r32, od_r32_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-561");
    define(defn);
    //  REX.W +      LAR r64, r32/m161 Valid                N.E.             r64 r32/m16 masked by
    //  0F 02 /r                                                             00FxFF00H and zero extended
    defn = new InsnDefn("lar",    x86_lar,     0x02, 0x0f02, od_rexw|od_modrm, od_r64, od_r32_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-565");
    define(defn);

    //--- page 3-565 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F F0 /r    LDDQU xmm1, mem         Valid    Valid        Load unaligned data from mem
    //                                                               and return double quadword in
    //                                                               xmm1.
    defn = new InsnDefn("lddqu",  x86_lddqu,   0x03, 0xf20ff0, od_modrm, od_xmm, od_m);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-568");
    define(defn);

    //--- page 3-568 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F,AE,/2    LDMXCSR m32       Valid        Valid      Load MXCSR register from m32.
    defn = new InsnDefn("ldmxcsr", x86_ldmxcsr, 0x03, 0x0fae, od_e2, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);

    //--- page 3-570 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // C5 /r            LDS             Invalid   Valid      Load DS:r16 with far pointer from
    //                  r16,m16:16                           memory.
    defn = new InsnDefn("lds",    x86_lds,     0x01, 0xc5, od_modrm, od_r16, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // C5 /r            LDS             Invalid   Valid      Load DS:r32 with far pointer from
    //                  r32,m16:32                           memory.
    defn = new InsnDefn("lds",    x86_lds,     0x01, 0xc5, od_modrm, od_r32, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B2 /r         LSS r16,m16:16 Valid      Valid      Load SS:r16 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lss",    x86_lss,     0x03, 0x0fb2, od_modrm, od_r16, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B2 /r         LSS r32,m16:32 Valid      Valid      Load SS:r32 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lss",    x86_lss,     0x03, 0x0fb2, od_modrm, od_r32, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // REX + 0F B2 /r   LSS r64,m16:64 Valid      N.E.       Load SS:r64 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lss",    x86_lss,     0x02, 0x0fb2, od_rex|od_modrm, od_r64, od_m16_64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // C4 /r            LES r16,m16:16 Invalid    Valid      Load ES:r16 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("les",    x86_les,     0x01, 0xc4, od_modrm, od_r16, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // C4 /r            LES r32,m16:32 Invalid    Valid      Load ES:r32 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("les",    x86_les,     0x01, 0xc4, od_modrm, od_r32, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B4 /r         LFS r16,m16:16 Valid      Valid      Load FS:r16 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lfs",    x86_lfs,     0x03, 0x0fb4, od_modrm, od_r16, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B4 /r         LFS r32,m16:32 Valid      Valid      Load FS:r32 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lfs",    x86_lfs,     0x03, 0x0fb4, od_modrm, od_r32, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // REX + 0F B4 /r   LFS r64,m16:64 Valid      N.E.       Load FS:r64 with far pointer from
    //                                                       memory.
    defn = new InsnDefn("lfs",    x86_lfs,     0x02, 0x0fb4, od_rex|od_modrm, od_r64, od_m16_64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B5 /r         LGS             Valid     Valid      Load GS:r16 with far pointer from
    //                  r16,m16:16                           memory.
    defn = new InsnDefn("lgs",    x86_lgs,     0x03, 0x0fb5, od_modrm, od_r16, od_m16_16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // 0F B5 /r         LGS             Valid     Valid      Load GS:r32 with far pointer from
    //                  r32,m16:32                           memory.
    defn = new InsnDefn("lgs",    x86_lgs,     0x03, 0x0fb5, od_modrm, od_r32, od_m16_32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-570");
    define(defn);
    // REX + 0F B5 /r   LGS             Valid     N.E.       Load GS:r64 with far pointer from
    //                  r64,m16:64                           memory.
    defn = new InsnDefn("lgs",    x86_lgs,     0x02, 0x0fb5, od_rex|od_modrm, od_r64, od_m16_64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-576");
    define(defn);

    //--- page 3-576 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 8D /r            LEA r16,m     Valid       Valid         Store effective address for m in register
    //                                                          r16.
    defn = new InsnDefn("lea",    x86_lea,     0x03, 0x8d, od_modrm, od_r16, od_m);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-576");
    define(defn);
    // 8D /r            LEA r32,m     Valid       Valid         Store effective address for m in register
    //                                                          r32.
    defn = new InsnDefn("lea",    x86_lea,     0x03, 0x8d, od_modrm, od_r32, od_m);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-576");
    define(defn);
    // REX.W + 8D /r    LEA r64,m     Valid       N.E.          Store effective address for m in register
    //                                                          r64.
    defn = new InsnDefn("lea",    x86_lea,     0x02, 0x8d, od_rexw|od_modrm, od_r64, od_m);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-579");
    define(defn);

    //--- page 3-579 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  C9            LEAVE              Valid    Valid      Set SP to BP, then pop BP.
    defn = new InsnDefn("leave",  x86_leave,   0x03, 0xc9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-579");
    define(defn);
    //  C9            LEAVE              N.E.     Valid      Set ESP to EBP, then pop EBP.
    defn = new InsnDefn("leave",  x86_leave,   0x01, 0xc9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-579");
    define(defn);
    //  C9            LEAVE              Valid    N.E.       Set RSP to RBP, then pop RBP.
    defn = new InsnDefn("leave",  x86_leave,   0x02, 0xc9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-581");
    define(defn);

    //--- page 3-581 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F AE /5     LFENCE        Valid       Valid           Serializes load operations.
    defn = new InsnDefn("lfence", x86_lfence,  0x03, 0x0fae, od_e5);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-582");
    define(defn);

    //--- page 3-582 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 01 /2        LGDT m16&32       N.E.         Valid             Load m into GDTR.
    defn = new InsnDefn("lgdt",   x86_lgdt,    0x01, 0x0f01, od_e2, od_m16a32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-582");
    define(defn);
    // 0F 01 /3        LIDT m16&32       N.E.         Valid             Load m into IDTR.
    defn = new InsnDefn("lidt",   x86_lidt,    0x01, 0x0f01, od_e3, od_m16a32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-582");
    define(defn);
    // 0F 01 /2        LGDT m16&64       Valid        N.E.              Load m into GDTR.
    defn = new InsnDefn("lgdt",   x86_lgdt,    0x02, 0x0f01, od_e2, od_m16a64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-582");
    define(defn);
    // 0F 01 /3        LIDT m16&64       Valid        N.E.              Load m into IDTR.
    defn = new InsnDefn("lidt",   x86_lidt,    0x02, 0x0f01, od_e3, od_m16a64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-585");
    define(defn);

    //--- page 3-585 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 00 /2        LLDT r/m16         Valid    Valid      Load segment selector r/m16 into
    //                                                         LDTR.
    defn = new InsnDefn("lldt",   x86_lldt,    0x03, 0x0f00, od_e2, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-588");
    define(defn);

    //--- page 3-588 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 01 /6        LMSW r/m16    Valid       Valid      Loads r/m16 in machine status word
    //                                                      of CR0.
    defn = new InsnDefn("lmsw",   x86_lmsw,    0x03, 0x0f01, od_e6, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-590");
    define(defn);

    //--- page 3-590 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F0              LOCK           Valid      Valid         Asserts LOCK# signal for duration of
    //                                                         the accompanying instruction.
    defn = new InsnDefn("lock",   x86_lock,    0x03, 0xf0, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    define(defn);

    //--- page 3-592 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // AC              LODS m8       Valid    Valid       For legacy mode, Load byte at address
    //                                                    DS:(E)SI into AL. For 64-bit mode load byte
    //                                                    at address (R)SI into AL.
    // See LODSB, LODSW, LODSD, or LODSQ instead.
    // defn = new InsnDefn("lods",   x86_lods,    0x03, 0xac, od_none, od_m8);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    // define(defn);
    // AD              LODS m16      Valid    Valid       For legacy mode, Load word at address
    //                                                    DS:(E)SI into AX. For 64-bit mode load
    //                                                    word at address (R)SI into AX.
    // See LODSB, LODSW, LODSD, or LODSQ instead.
    // defn = new InsnDefn("lods",   x86_lods,    0x03, 0xad, od_none, od_m16);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    // define(defn);
    // AD              LODS m32      Valid    Valid       For legacy mode, Load dword at address
    //                                                    DS:(E)SI into EAX. For 64-bit mode load
    //                                                    dword at address (R)SI into EAX.
    // See LODSB, LODSW, LODSD, or LODSQ instead.
    // defn = new InsnDefn("lods",   x86_lods,    0x03, 0xad, od_none, od_m32);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    // define(defn);
    // REX.W + AD      LODS m64      Valid    N.E.        Load qword at address (R)SI into RAX.
    // See LODSB, LODSW, LODSD, or LODSQ instead.
    // defn = new InsnDefn("lods",   x86_lods,    0x02, 0xad, od_rexw, od_m64);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    // define(defn);
    // AC              LODSB         Valid    Valid       For legacy mode, Load byte at address
    //                                                    DS:(E)SI into AL. For 64-bit mode load byte
    //                                                    at address (R)SI into AL.
    defn = new InsnDefn("lodsb",  x86_lodsb,   0x03, 0xac, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    define(defn);
    // AD              LODSW         Valid    Valid       For legacy mode, Load word at address
    //                                                    DS:(E)SI into AX. For 64-bit mode load
    //                                                    word at address (R)SI into AX.
    defn = new InsnDefn("lodsw",  x86_lodsw,   0x03, 0xad, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    define(defn);
    // AD              LODSD         Valid    Valid       For legacy mode, Load dword at address
    //                                                    DS:(E)SI into EAX. For 64-bit mode load
    //                                                    dword at address (R)SI into EAX.
    defn = new InsnDefn("lodsd",  x86_lodsd,   0x03, 0xad, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-592");
    define(defn);
    // REX.W + AD      LODSQ         Valid    N.E.        Load qword at address (R)SI into RAX.
    defn = new InsnDefn("lodsq",  x86_lodsq,   0x02, 0xad, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-596");
    define(defn);

    //--- page 3-596 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // E2 cb                LOOP rel8     Valid    Valid      Decrement count; jump short if count  0.
    defn = new InsnDefn("loop",   x86_loop,    0x03, 0xe2, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-596");
    define(defn);
    // E1 cb                LOOPE rel8    Valid    Valid      Decrement count; jump short if count  0
    //                                                        and ZF = 1.
    defn = new InsnDefn("loopz",  x86_loopz,   0x03, 0xe1, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-596");
    define(defn);
    // E0 cb                LOOPNE rel8 Valid      Valid      Decrement count; jump short if count  0
    //                                                        and ZF = 0.
    defn = new InsnDefn("loopnz", x86_loopnz,  0x03, 0xe0, od_cb, od_rel8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-599");
    define(defn);

    //--- page 3-599 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 03 /r             LSL r16, r16/m16     Valid        Valid          Load: r16  segment limit,
    //                                                                        selector r16/m16.
    defn = new InsnDefn("lsl",    x86_lsl,     0x03, 0x0f03, od_modrm, od_r16, od_r16_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-599");
    define(defn);
    //  0F 03 /r             LSL r32, r32/m16* Valid           Valid          Load: r32  segment limit,
    //                                                                        selector r32/m16.
    defn = new InsnDefn("lsl",    x86_lsl,     0x03, 0x0f03, od_modrm, od_r32, od_r32_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-599");
    define(defn);
    //  REX.W + 0F 03 /r     LSL r64, r32/m16* Valid           Valid          Load: r64  segment limit,
    //                                                                        selector r32/m16
    defn = new InsnDefn("lsl",    x86_lsl,     0x03, 0x0f03, od_rexw|od_modrm, od_r64, od_r32_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-603");
    define(defn);

    //--- page 3-603 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 00 /3        LTR r/m16        Valid        Valid               Load r/m16 into task register.
    defn = new InsnDefn("ltr",    x86_ltr,     0x03, 0x0f00, od_e3, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-606");
    define(defn);

    //--- page 3-606 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F F7 /r MASKMOVDQU        Valid    Valid       Selectively write bytes from xmm1 to
    //             xmm1, xmm2                             memory location using the byte mask in
    //                                                    xmm2. The default memory location is
    //                                                    specified by DS:EDI.
    // See MASKMOVQ with 0x66 prefix instead.
    // defn = new InsnDefn("maskmovdqu", x86_maskmovdqu, 0x03, 0x660ff7, od_modrm, od_xmm, od_xmm);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-609");
    // define(defn);

    //--- page 3-609 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F F7 /r   MASKMOVQ mm1,        Valid      Valid      Selectively write bytes from mm1 to
    //             mm2                                        memory location using the byte mask in
    //                                                        mm2. The default memory location is
    //                                                        specified by DS:EDI.
    defn = new InsnDefn("maskmovq", x86_maskmovq, 0x03, 0x0ff7, od_modrm, od_mm, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-612");
    define(defn);

    //--- page 3-612 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 5F /r     MAXPD xmm1,      Valid      Valid             Return the maximum double-
    //                 xmm2/m128                                     precision floating-point values
    //                                                               between xmm2/m128 and xmm1.
    defn = new InsnDefn("maxpd",  x86_maxpd,   0x03, 0x660f5f, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-615");
    define(defn);

    //--- page 3-615 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 5F /r     MAXPS xmm1,       Valid        Valid          Return the maximum single-precision
    //               xmm2/m128                                     floating-point values between
    //                                                             xmm2/m128 and xmm1.
    defn = new InsnDefn("maxps",  x86_maxps,   0x03, 0x0f5f, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-618");
    define(defn);

    //--- page 3-618 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F 5F /r     MAXSD xmm1,        Valid        Valid           Return the maximum scalar double-
    //                 xmm2/m64                                        precision floating-point value
    //                                                                 between xmm2/mem64 and xmm1.
    defn = new InsnDefn("maxsd",  x86_maxsd,   0x03, 0xf20f5f, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-621");
    define(defn);

    //--- page 3-621 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 5F /r MAXSS xmm1,             Valid       Valid              Return the maximum scalar single-
    //              xmm2/m32                                               precision floating-point value
    //                                                                     between xmm2/mem32 and
    //                                                                     xmm1.
    defn = new InsnDefn("maxss",  x86_maxss,   0x03, 0xf30f5f, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-624");
    define(defn);

    //--- page 3-624 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F AE /6        MFENCE        Valid      Valid         Serializes load and store operations.
    defn = new InsnDefn("mfence", x86_mfence,  0x03, 0x0fae, od_e6);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-625");
    define(defn);

    //--- page 3-625 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 5D /r     MINPD xmm1,        Valid       Valid                Return the minimum double-
    //                  xmm2/m128                                           precision floating-point values
    //                                                                      between xmm2/m128 and xmm1.
    defn = new InsnDefn("minpd",  x86_minpd,   0x03, 0x660f5d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-628");
    define(defn);

    //--- page 3-628 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 5D /r        MINPS xmm1,       Valid       Valid            Return the minimum single-precision
    //                 xmm2/m128                                      floating-point values between
    //                                                                xmm2/m128 and xmm1.
    defn = new InsnDefn("minps",  x86_minps,   0x03, 0x0f5d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-631");
    define(defn);

    //--- page 3-631 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 5D /r     MINSD xmm1,           Valid      Valid             Return the minimum scalar double-
    //                  xmm2/m64                                           precision floating-point value
    //                                                                     between xmm2/mem64 and xmm1.
    defn = new InsnDefn("minsd",  x86_minsd,   0x03, 0xf20f5d, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-634");
    define(defn);

    //--- page 3-634 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 5D /r     MINSS xmm1,        Valid      Valid             Return the minimum scalar single-
    //                 xmm2/m32                                        precision floating-point value
    //                                                                 between xmm2/mem32 and
    //                                                                 xmm1.
    defn = new InsnDefn("minss",  x86_minss,   0x03, 0xf30f5d, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-637");
    define(defn);

    //--- page 3-637 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 01 C8       MONITOR          Valid    Valid      Sets up a linear address range to be
    //                                                      monitored by hardware and activates
    //                                                      the monitor. The address range should
    //                                                      be a write-back memory caching type.
    //                                                      The address is DS:EAX (DS:RAX in 64-
    //                                                      bit mode).
    defn = new InsnDefn("monitor", x86_monitor, 0x03, 0x0f01c8, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);

    //--- page 3-640 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 88 /r             MOV r/m8,r8         Valid    Valid      Move r8 to r/m8.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x88, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX + 88 /r       MOV r/m8***,r8***   Valid    N.E.       Move r8 to r/m8.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x88, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 89 /r             MOV r/m16,r16       Valid    Valid      Move r16 to r/m16.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x89, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 89 /r             MOV r/m32,r32       Valid    Valid      Move r32 to r/m32.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x89, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + 89 /r     MOV r/m64,r64       Valid    N.E.       Move r64 to r/m64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x89, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 8A /r             MOV r8,r/m8         Valid    Valid      Move r/m8 to r8.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8a, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX + 8A /r       MOV r8***,r/m8***   Valid    N.E.       Move r/m8 to r8.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x8a, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 8B /r             MOV r16,r/m16       Valid    Valid      Move r/m16 to r16.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 8B /r             MOV r32,r/m32       Valid    Valid      Move r/m32 to r32.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + 8B /r     MOV r64,r/m64       Valid    N.E.       Move r/m64 to r64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x8b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 8C /r             MOV r/m16,Sreg**    Valid    Valid      Move segment register to
    //                                                           r/m16.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8c, od_modrm, od_r_m16, od_sreg);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + 8C /r     MOV r/m64,Sreg**    Valid    Valid      Move zero extended 16-
    //                                                           bit segment register to
    //                                                           r/m64.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8c, od_rexw|od_modrm, od_r_m64, od_sreg);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // 8E /r             MOV Sreg,r/m16**    Valid    Valid      Move r/m16 to segment
    //                                                           register.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8e, od_modrm, od_sreg, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + 8E /r     MOV Sreg,r/m64**    Valid    Valid      Move lower 16 bits of
    //                                                           r/m64 to segment
    //                                                           register.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0x8e, od_rexw|od_modrm, od_sreg, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // A0                MOV AL,moffs8*      Valid    Valid      Move byte at (seg:offset)
    //                                                           to AL.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa0, od_none, od_AL, od_moffs8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + A0        MOV AL,moffs8*      Valid    N.E.       Move byte at (offset) to
    //                                                           AL.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xa0, od_rexw, od_AL, od_moffs8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // A1                MOV AX,moffs16*     Valid    Valid      Move word at (seg:offset)
    //                                                           to AX.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa1, od_none, od_AX, od_moffs16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // A1                MOV EAX,moffs32*    Valid    Valid      Move doubleword at
    //                                                           (seg:offset) to EAX.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa1, od_none, od_EAX, od_moffs32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + A1        MOV RAX,moffs64*    Valid    N.E.       Move quadword at (offset)
    //                                                           to RAX.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xa1, od_rexw, od_RAX, od_moffs64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // A2                MOV moffs8,AL       Valid    Valid      Move AL to (seg:offset).
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa2, od_none, od_moffs8, od_AL);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // REX.W + A2        MOV moffs8***,AL    Valid    N.E.       Move AL to (offset).
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xa2, od_rexw, od_moffs8, od_AL);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-640");
    define(defn);
    // A3                MOV moffs16*,AX     Valid    Valid      Move AX to (seg:offset).
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa3, od_none, od_moffs16, od_AX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  A3                   MOV moffs32*,EAX       Valid        Valid           Move EAX to (seg:offset).
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xa3, od_none, od_moffs32, od_EAX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  REX.W + A3           MOV moffs64*,RAX       Valid        N.E.            Move RAX to (offset).
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xa3, od_rexw, od_moffs64, od_RAX);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  B0+ rb               MOV r8, imm8           Valid        Valid           Move imm8 to r8.
    //                                ***
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xb0, od_rb|od_ib, od_r8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  REX + B0+ rb         MOV r8     , imm8      Valid        N.E.            Move imm8 to r8.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xb0, od_rex|od_rb|od_ib, od_r8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  B8+ rw               MOV r16, imm16         Valid        Valid           Move imm16 to r16.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xb8, od_rw|od_iw, od_r16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  B8+ rd               MOV r32, imm32         Valid        Valid           Move imm32 to r32.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xb8, od_rd|od_id, od_r32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  REX.W + B8+ rd       MOV r64, imm64         Valid        N.E.            Move imm64 to r64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xb8, od_rexw|od_rd|od_io, od_r64, od_imm64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  C6 /0                MOV r/m8, imm8         Valid        Valid           Move imm8 to r/m8.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xc6, od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  REX + C6 /0          MOV r/m8***, imm8 Valid             N.E.            Move imm8 to r/m8.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xc6, od_rex|od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  C7 /0                MOV r/m16, imm16       Valid        Valid           Move imm16 to r/m16.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xc7, od_e0|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  C7 /0                MOV r/m32, imm32       Valid        Valid           Move imm32 to r/m32.
    defn = new InsnDefn("mov",    x86_mov,     0x03, 0xc7, od_e0|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-641");
    define(defn);
    //  REX.W + C7 /0        MOV r/m64, imm32       Valid        N.E.            Move imm32 sign
    //                                                                           extended to 64-bits to
    //                                                                           r/m64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0xc7, od_rexw|od_e0|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);

    //--- page 3-646 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 20/r               MOV r32, CR0       N.E.        Valid           Move control register to r32
    //                       CR7
    defn = new InsnDefn("mov",    x86_mov,     0x01, 0x0f20, od_modrm, od_r32, od_CR0, od_CR7);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);
    // 0F 20/r               MOV r64, CR0       Valid       N.E.            Move extended control
    //                       CR7                                             register to r64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f20, od_modrm, od_r64, od_CR0, od_CR7);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);
    // REX.R + 0F 20 /0      MOV r64, CR8        Valid       N.E.            Move extended CR8 to r64.1
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f20, od_rexr|od_e0, od_r64, od_CR8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);
    // 0F 22 /r              MOV CR0CR7,        N.E.        Valid           Move r32 to control register
    //                       r32
    defn = new InsnDefn("mov",    x86_mov,     0x01, 0x0f22, od_modrm, od_CR0CR7, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);
    // 0F 22 /r              MOV CR0CR7,        Valid       N.E.            Move r64 to extended control
    //                       r64                                             register.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f22, od_modrm, od_CR0CR7, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-646");
    define(defn);
    // REX.R + 0F 22 /0      MOV CR8, r64        Valid       N.E.            Move r64 to extended CR8.1
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f22, od_rexr|od_e0, od_CR8, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-649");
    define(defn);

    //--- page 3-649 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 21/r             MOV r32, DR0DR7      N.E.     Valid      Move debug register to r32
    defn = new InsnDefn("mov",    x86_mov,     0x01, 0x0f21, od_modrm, od_r32, od_DR0DR7);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-649");
    define(defn);
    //  0F 21/r             MOV r64, DR0DR7      Valid    N.E.       Move extended debug
    //                                                                register to r64.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f21, od_modrm, od_r64, od_DR0DR7);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-649");
    define(defn);
    //  0F 23 /r            MOV DR0DR7, r32      N.E.     Valid      Move r32 to debug register
    defn = new InsnDefn("mov",    x86_mov,     0x01, 0x0f23, od_modrm, od_DR0DR7, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-649");
    define(defn);
    //  0F 23 /r            MOV DR0DR7, r64      Valid    N.E.       Move r64 to extended debug
    //                                                                register.
    defn = new InsnDefn("mov",    x86_mov,     0x02, 0x0f23, od_modrm, od_DR0DR7, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-651");
    define(defn);

    //--- page 3-651 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 28 /r    MOVAPD xmm1,            Valid      Valid            Move packed double-precision
    //                 xmm2/m128                                           floating-point values from
    //                                                                     xmm2/m128 to xmm1.
    defn = new InsnDefn("movapd", x86_movapd,  0x03, 0x660f28, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-651");
    define(defn);
    //  66 0F 29 /r    MOVAPD                  Valid      Valid            Move packed double-precision
    //                 xmm2/m128, xmm1                                     floating-point values from xmm1 to
    //                                                                     xmm2/m128.
    defn = new InsnDefn("movapd", x86_movapd,  0x03, 0x660f29, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-654");
    define(defn);

    //--- page 3-654 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 28 /r    MOVAPS xmm1,          Valid      Valid          Move packed single-precision
    //             xmm2/m128                                       floating-point values from
    //                                                             xmm2/m128 to xmm1.
    defn = new InsnDefn("movaps", x86_movaps,  0x03, 0x0f28, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-654");
    define(defn);
    // 0F 29 /r    MOVAPS                Valid      Valid          Move packed single-precision
    //             xmm2/m128, xmm1                                 floating-point values from xmm1 to
    //                                                             xmm2/m128.
    defn = new InsnDefn("movaps", x86_movaps,  0x03, 0x0f29, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);

    //--- page 3-657 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 38 F0 /r         MOVBE r16, m16    Valid    Valid       Reverse byte order in m16
    //                                                             and move to r16
    defn = new InsnDefn("movbe",  x86_movbe,   0x03, 0x0f38f0, od_modrm, od_r16, od_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);
    //  0F 38 F0 /r         MOVBE r32, m32    Valid    Valid       Reverse byte order in m32
    //                                                             and move to r32
    defn = new InsnDefn("movbe",  x86_movbe,   0x03, 0x0f38f0, od_modrm, od_r32, od_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);
    //  REX.W + 0F 38 F0    MOVBE r64, m64    Valid    N.E.        Reverse byte order in m64
    //  /r                                                         and move to r64.
    defn = new InsnDefn("movbe",  x86_movbe,   0x02, 0x0f38f0, od_rexw|od_modrm, od_r64, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);
    //  0F 38 F1 /r         MOVBE m16, r16    Valid    Valid       Reverse byte order in r16 and
    //                                                             move to m16
    defn = new InsnDefn("movbe",  x86_movbe,   0x03, 0x0f38f1, od_modrm, od_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);
    //  0F 38 F1 /r         MOVBE m32, r32    Valid    Valid       Reverse byte order in r32 and
    //                                                             move to m32
    defn = new InsnDefn("movbe",  x86_movbe,   0x03, 0x0f38f1, od_modrm, od_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-657");
    define(defn);
    //  REX.W + 0F 38 F1    MOVBE m64, r64    Valid    N.E.        Reverse byte order in r64 and
    //  /r                                                         move to m64.
    defn = new InsnDefn("movbe",  x86_movbe,   0x02, 0x0f38f1, od_rexw|od_modrm, od_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);

    //--- page 3-660 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 6E /r             MOVD mm, r/m32 Valid        Valid        Move doubleword from
    //                                                               r/m32 to mm.
    defn = new InsnDefn("movd",   x86_movd,    0x03, 0x0f6e, od_modrm, od_mm, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // REX.W + 0F 6E /r     MOVQ mm, r/m64 Valid        N.E.         Move quadword from
    //                                                               r/m64 to mm.
    defn = new InsnDefn("movq",   x86_movq,    0x02, 0x0f6e, od_rexw|od_modrm, od_mm, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // 0F 7E /r             MOVD r/m32, mm Valid        Valid        Move doubleword from mm
    //                                                               to r/m32.
    defn = new InsnDefn("movd",   x86_movd,    0x03, 0x0f7e, od_modrm, od_r_m32, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // REX.W + 0F 7E /r     MOVQ r/m64, mm Valid        N.E.         Move quadword from mm
    //                                                               to r/m64.
    defn = new InsnDefn("movq",   x86_movq,    0x02, 0x0f7e, od_rexw|od_modrm, od_r_m64, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // 66 0F 6E /r          MOVD xmm,        Valid      Valid        Move doubleword from
    //                      r/m32                                    r/m32 to xmm.
    defn = new InsnDefn("movd",   x86_movd,    0x03, 0x660f6e, od_modrm, od_xmm, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // 66 REX.W 0F 6E /r    MOVQ xmm,        Valid      N.E.         Move quadword from
    //                      r/m64                                    r/m64 to xmm.
    defn = new InsnDefn("movq",   x86_movq,    0x02, 0x660f6e, od_rexw|od_modrm, od_xmm, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    // 66 0F 7E /r          MOVD r/m32,      Valid      Valid        Move doubleword from
    //                      xmm                                      xmm register to r/m32.
    defn = new InsnDefn("movd",   x86_movd,    0x03, 0x660f7e, od_modrm, od_r_m32, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-660");
    define(defn);
    //  66 REX.W 0F 7E /r   MOVQ r/m64,      Valid      N.E.         Move quadword from xmm
    //                      xmm                                      register to r/m64.
    defn = new InsnDefn("movq",   x86_movq,    0x02, 0x660f7e, od_rexw|od_modrm, od_r_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-664");
    define(defn);

    //--- page 3-664 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F 12 /r     MOVDDUP xmm1,         Valid   Valid          Move one double-precision floating-
    //                 xmm2/m64                                     point value from the lower 64-bit
    //                                                              operand in xmm2/m64 to xmm1 and
    //                                                              duplicate.
    defn = new InsnDefn("movddup", x86_movddup, 0x03, 0xf20f12, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-667");
    define(defn);

    //--- page 3-667 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 6F /r   MOVDQA xmm1,            Valid        Valid       Move aligned double quadword
    //                xmm2/m128                                        from xmm2/m128 to xmm1.
    defn = new InsnDefn("movdqa", x86_movdqa,  0x03, 0x660f6f, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-667");
    define(defn);
    //  66 0F 7F /r   MOVDQA xmm2/m128,       Valid        Valid       Move aligned double quadword
    //                xmm1                                             from xmm1 to xmm2/m128.
    defn = new InsnDefn("movdqa", x86_movdqa,  0x03, 0x660f7f, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-669");
    define(defn);

    //--- page 3-669 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 6F /r    MOVDQU xmm1,            Valid    Valid       Move unaligned double
    //                 xmm2/m128                                    quadword from xmm2/m128 to
    //                                                              xmm1.
    defn = new InsnDefn("movdqu", x86_movdqu,  0x03, 0xf30f6f, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-669");
    define(defn);
    //  F3 0F 7F /r    MOVDQU xmm2/m128, Valid          Valid       Move unaligned double
    //                 xmm1                                         quadword from xmm1 to
    //                                                              xmm2/m128.
    defn = new InsnDefn("movdqu", x86_movdqu,  0x03, 0xf30f7f, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-672");
    define(defn);

    //--- page 3-672 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F D6        MOVDQ2Q mm, xmm     Valid       Valid          Move low quadword from
    //                                                                xmm to mmx register.
    defn = new InsnDefn("movdq2q", x86_movdq2q, 0x03, 0xf20fd6, od_none, od_mm, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-674");
    define(defn);

    //--- page 3-674 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 12 /r        MOVHLPS xmm1, xmm2      Valid      Valid           Move two packed single-
    //                                                                    precision floating-point values
    //                                                                    from high quadword of xmm2 to
    //                                                                    low quadword of xmm1.
    defn = new InsnDefn("movhlps", x86_movhlps, 0x03, 0x0f12, od_modrm, od_xmm, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-676");
    define(defn);

    //--- page 3-676 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 16 /r MOVHPD xmm,        Valid       Valid          Move double-precision floating-point
    //             m64                                           value from m64 to high quadword of
    //                                                           xmm.
    defn = new InsnDefn("movhpd", x86_movhpd,  0x03, 0x660f16, od_modrm, od_xmm, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-676");
    define(defn);
    // 66 0F 17 /r MOVHPD m64,        Valid       Valid          Move double-precision floating-point
    //             xmm                                           value from high quadword of xmm to
    //                                                           m64.
    defn = new InsnDefn("movhpd", x86_movhpd,  0x03, 0x660f17, od_modrm, od_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-679");
    define(defn);

    //--- page 3-679 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 16 /r         MOVHPS xmm,         Valid     Valid            Move two packed single-precision
    //                   m64                                            floating-point values from m64 to
    //                                                                  high quadword of xmm.
    defn = new InsnDefn("movhps", x86_movhps,  0x03, 0x0f16, od_modrm, od_xmm, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-679");
    define(defn);
    //  0F 17 /r         MOVHPS m64,         Valid     Valid            Move two packed single-precision
    //                   xmm                                            floating-point values from high
    //                                                                  quadword of xmm to m64.
    defn = new InsnDefn("movhps", x86_movhps,  0x03, 0x0f17, od_modrm, od_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-682");
    define(defn);

    //--- page 3-682 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 16 /r    MOVLHPS xmm1,        Valid     Valid          Move two packed single-precision
    //             xmm2                                          floating-point values from low quadword
    //                                                           of xmm2 to high quadword of xmm1.
    defn = new InsnDefn("movlhps", x86_movlhps, 0x03, 0x0f16, od_modrm, od_xmm, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-684");
    define(defn);

    //--- page 3-684 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 12 /r MOVLPD xmm,        Valid      Valid         Move double-precision floating-point
    //             m64                                         value from m64 to low quadword of xmm
    //                                                         register.
    defn = new InsnDefn("movlpd", x86_movlpd,  0x03, 0x660f12, od_modrm, od_xmm, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-684");
    define(defn);
    // 66 0F 13 /r MOVLPD m64,        Valid      Valid         Move double-precision floating-point
    //             xmm                                         nvalue from low quadword of xmm
    //                                                         register to m64.
    defn = new InsnDefn("movlpd", x86_movlpd,  0x03, 0x660f13, od_modrm, od_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-686");
    define(defn);

    //--- page 3-686 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 12 /r    MOVLPS xmm,       Valid      Valid            Move two packed single-precision
    //             m64                                           floating-point values from m64 to low
    //                                                           quadword of xmm.
    defn = new InsnDefn("movlps", x86_movlps,  0x03, 0x0f12, od_modrm, od_xmm, od_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-686");
    define(defn);
    // 0F 13 /r    MOVLPS m64,       Valid      Valid            Move two packed single-precision
    //             xmm                                           floating-point values from low
    //                                                           quadword of xmm to m64.
    defn = new InsnDefn("movlps", x86_movlps,  0x03, 0x0f13, od_modrm, od_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-689");
    define(defn);

    //--- page 3-689 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 50 /r            MOVMSKPD reg,        Valid     Valid             Extract 2-bit sign mask
    //                         xmm                                              from xmm and store in reg.
    //                                                                          The upper bits of r32 or
    //                                                                          r64 are filled with zeros.
    defn = new InsnDefn("movmskpd", x86_movmskpd, 0x03, 0x660f50, od_modrm, od_reg, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-691");
    define(defn);

    //--- page 3-691 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 50 /r              MOVMSKPS reg,        Valid     Valid         Extract 4-bit sign mask from xmm
    //                        xmm                                          and store in reg. The upper bits of
    //                                                                     r32 or r64 are filled with zeros.
    defn = new InsnDefn("movmskps", x86_movmskps, 0x03, 0x0f50, od_modrm, od_reg, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-693");
    define(defn);

    //--- page 3-693 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 38     MOVNTDQA xmm1,          Valid     Valid       Move double quadword from m128
    //  2A /r        m128                                          to xmm using non-temporal hint if
    //                                                             WC memory type.
    defn = new InsnDefn("movntdqa", x86_movntdqa, 0x03, 0x660f382a, od_modrm, od_xmm, od_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-696");
    define(defn);

    //--- page 3-696 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F E7 /r     MOVNTDQ m128,    Valid       Valid          Move double quadword from xmm
    //                 xmm                                         to m128 using non-temporal hint.
    defn = new InsnDefn("movntdq", x86_movntdq, 0x03, 0x660fe7, od_modrm, od_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-699");
    define(defn);

    //--- page 3-699 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F C3 /r            MOVNTI m32, r32     Valid     Valid         Move doubleword from r32 to
    //                                                                  m32 using non-temporal hint.
    defn = new InsnDefn("movnti", x86_movnti,  0x03, 0x0fc3, od_modrm, od_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-699");
    define(defn);
    //  REX.W + 0F C3 /r    MOVNTI m64, r64     Valid     N.E.          Move quadword from r64 to
    //                                                                  m64 using non-temporal hint.
    defn = new InsnDefn("movnti", x86_movnti,  0x02, 0x0fc3, od_rexw|od_modrm, od_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-701");
    define(defn);

    //--- page 3-701 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 2B /r    MOVNTPD m128,          Valid      Valid          Move packed double-precision
    //                 xmm                                              floating-point values from xmm to
    //                                                                  m128 using non-temporal hint.
    defn = new InsnDefn("movntpd", x86_movntpd, 0x03, 0x660f2b, od_modrm, od_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-704");
    define(defn);

    //--- page 3-704 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 2B /r    MOVNTPS m128,         Valid      Valid           Move packed single-precision floating-
    //             xmm                                              point values from xmm to m128 using
    //                                                              non-temporal hint.
    defn = new InsnDefn("movntps", x86_movntps, 0x03, 0x0f2b, od_modrm, od_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-707");
    define(defn);

    //--- page 3-707 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F E7 /r    MOVNTQ m64,       Valid     Valid       Move quadword from mm to m64 using
    //              mm                                      non-temporal hint.
    defn = new InsnDefn("movntq", x86_movntq,  0x03, 0x0fe7, od_modrm, od_m64, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-710");
    define(defn);

    //--- page 3-710 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 6F /r    MOVQ mm, mm/m64           Valid       Valid         Move quadword from mm/m64
    //                                                                 to mm.
    defn = new InsnDefn("movq",   x86_movq,    0x03, 0x0f6f, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-710");
    define(defn);
    // 0F 7F /r    MOVQ mm/m64, mm           Valid       Valid         Move quadword from mm to
    //                                                                 mm/m64.
    defn = new InsnDefn("movq",   x86_movq,    0x03, 0x0f7f, od_modrm, od_mm_m64, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-710");
    define(defn);
    // F3 0F 7E    MOVQ xmm1, xmm2/m64 Valid             Valid         Move quadword from
    //                                                                 xmm2/mem64 to xmm1.
    defn = new InsnDefn("movq",   x86_movq,    0x03, 0xf30f7e, od_none, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-710");
    define(defn);
    // 66 0F D6    MOVQ xmm2/m64, xmm1 Valid             Valid         Move quadword from xmm1 to
    //                                                                 xmm2/mem64.
    defn = new InsnDefn("movq",   x86_movq,    0x03, 0x660fd6, od_none, od_xmm_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-713");
    define(defn);

    //--- page 3-713 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F D6   MOVQ2DQ xmm, mm       Valid     Valid           Move quadword from mmx to low
    //                                                             quadword of xmm.
    defn = new InsnDefn("movq2dq", x86_movq2dq, 0x03, 0xf30fd6, od_none, od_xmm, od_mm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    define(defn);

    //--- page 3-715 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //     A4           MOVS m8, m8     Valid     Valid       For legacy mode, Move byte from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move byte from address (R|E)SI
    //                                                        to (R|E)DI.
    // See MOVSB, MOVSW, MOVSD, or MOVSQ instead.
    // defn = new InsnDefn("movs",   x86_movs,    0x03, 0xa4, od_none, od_m8, od_m8);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    // define(defn);
    //     A5           MOVS m16, m16   Valid     Valid       For legacy mode, move word from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move word at address (R|E)SI to
    //                                                        (R|E)DI.
    // See MOVSB, MOVSW, MOVSD, or MOVSQ instead.
    // defn = new InsnDefn("movs",   x86_movs,    0x03, 0xa5, od_none, od_m16, od_m16);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    // define(defn);
    //     A5           MOVS m32, m32   Valid     Valid       For legacy mode, move dword from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move dword from address (R|E)SI
    //                                                        to (R|E)DI.
    // See MOVSB, MOVSW, MOVSD, or MOVSQ instead.
    // defn = new InsnDefn("movs",   x86_movs,    0x03, 0xa5, od_none, od_m32, od_m32);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    // define(defn);
    //     REX.W + A5   MOVS m64, m64   Valid     N.E.        Move qword from address (R|E)SI to
    //                                                        (R|E)DI.
    // See MOVSB, MOVSW, MOVSD, or MOVSQ instead.
    // defn = new InsnDefn("movs",   x86_movs,    0x02, 0xa5, od_rexw, od_m64, od_m64);
    // defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    // define(defn);
    //     A4           MOVSB           Valid     Valid       For legacy mode, Move byte from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move byte from address (R|E)SI
    //                                                        to (R|E)DI.
    defn = new InsnDefn("movsb",  x86_movsb,   0x03, 0xa4, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    define(defn);
    //     A5           MOVSW           Valid     Valid       For legacy mode, move word from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move word at address (R|E)SI to
    //                                                        (R|E)DI.
    defn = new InsnDefn("movsw",  x86_movsw,   0x03, 0xa5, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    define(defn);
    //     A5           MOVSD           Valid     Valid       For legacy mode, move dword from
    //                                                        address DS:(E)SI to ES:(E)DI. For 64-bit
    //                                                        mode move dword from address (R|E)SI
    //                                                        to (R|E)DI.
    defn = new InsnDefn("movsd",  x86_movsd,   0x03, 0xa5, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-715");
    define(defn);
    //     REX.W + A5   MOVSQ           Valid     N.E.        Move qword from address (R|E)SI to
    //                                                        (R|E)DI.
    defn = new InsnDefn("movsq",  x86_movsq,   0x02, 0xa5, od_rexw);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-720");
    define(defn);

    //--- page 3-720 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F2 0F 10 /r     MOVSD xmm1,        Valid     Valid           Move scalar double-precision
    //                 xmm2/m64                                     floating-point value from
    //                                                              xmm2/m64 to xmm1 register.
    defn = new InsnDefn("movsd",  x86_movsd_sse, 0x03, 0xf20f10, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-720");
    define(defn);
    // F2 0F 11 /r     MOVSD xmm2/m64, Valid        Valid           Move scalar double-precision
    //                 xmm1                                         floating-point value from xmm1
    //                                                              register to xmm2/m64.
    defn = new InsnDefn("movsd",  x86_movsd_sse, 0x03, 0xf20f11, od_modrm, od_xmm_m64, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-723");
    define(defn);

    //--- page 3-723 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 16 /r    MOVSHDUP xmm1,          Valid    Valid               Move two single-precision floating-
    //                 xmm2/m128                                            point values from the higher 32-bit
    //                                                                      operand of each qword in
    //                                                                      xmm2/m128 to xmm1 and
    //                                                                      duplicate each 32-bit operand to
    //                                                                      the lower 32-bits of each qword.
    defn = new InsnDefn("movshdup", x86_movshdup, 0x03, 0xf30f16, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-726");
    define(defn);

    //--- page 3-726 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 12 /r     MOVSLDUP xmm1,         Valid    Valid             Move two single-precision floating-point
    //                 xmm2/m128                                         values from the lower 32-bit operand of
    //                                                                   each qword in xmm2/m128 to xmm1
    //                                                                   and duplicate each 32-bit operand to
    //                                                                   the higher 32-bits of each qword.
    defn = new InsnDefn("movsldup", x86_movsldup, 0x03, 0xf30f12, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-729");
    define(defn);

    //--- page 3-729 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F3 0F 10 /r      MOVSS xmm1,            Valid      Valid      Move scalar single-precision
    //                   xmm2/m32                                     floating-point value from
    //                                                                xmm2/m32 to xmm1 register.
    defn = new InsnDefn("movss",  x86_movss,   0x03, 0xf30f10, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-729");
    define(defn);
    //  F3 0F 11 /r      MOVSS xmm2/m32, Valid             Valid      Move scalar single-precision
    //                   xmm                                          floating-point value from xmm1
    //                                                                register to xmm2/m32.
    defn = new InsnDefn("movss",  x86_movss,   0x03, 0xf30f11, od_modrm, od_xmm_m32, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);

    //--- page 3-732 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F BE /r             MOVSX r16, r/m8        Valid      Valid          Move byte to word with sign-
    //                                                                       extension.
    defn = new InsnDefn("movsx",  x86_movsx,   0x03, 0x0fbe, od_modrm, od_r16, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);
    // 0F BE /r             MOVSX r32, r/m8        Valid      Valid          Move byte to doubleword
    //                                                                       with sign-extension.
    defn = new InsnDefn("movsx",  x86_movsx,   0x03, 0x0fbe, od_modrm, od_r32, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);
    // REX + 0F BE /r       MOVSX r64, r/m8*       Valid      N.E.           Move byte to quadword with
    //                                                                       sign-extension.
    defn = new InsnDefn("movsx",  x86_movsx,   0x02, 0x0fbe, od_rex|od_modrm, od_r64, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);
    // 0F BF /r             MOVSX r32, r/m16       Valid      Valid          Move word to doubleword,
    //                                                                       with sign-extension.
    defn = new InsnDefn("movsx",  x86_movsx,   0x03, 0x0fbf, od_modrm, od_r32, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);
    // REX.W + 0F BF /r     MOVSX r64, r/m16       Valid      N.E.           Move word to quadword with
    //                                                                       sign-extension.
    defn = new InsnDefn("movsx",  x86_movsx,   0x02, 0x0fbf, od_rexw|od_modrm, od_r64, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-732");
    define(defn);
    // REX.W** + 63 /r      MOVSXD r64, r/m32 Valid           N.E.           Move doubleword to
    //                                                                       quadword with sign-
    //                                                                       extension.
    defn = new InsnDefn("movsxd", x86_movsxd,  0x02, 0x63, od_rexw|od_modrm, od_r64, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-734");
    define(defn);

    //--- page 3-734 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 10 /r     MOVUPD xmm1,        Valid      Valid          Move packed double-precision
    //                 xmm2/m128                                     floating-point values from
    //                                                               xmm2/m128 to xmm1.
    defn = new InsnDefn("movupd", x86_movupd,  0x03, 0x660f10, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-734");
    define(defn);
    // 66 0F 11 /r     MOVUPD              Valid      Valid          Move packed double-precision
    //                 xmm2/m128, xmm                                floating-point values from xmm1
    //                                                               to xmm2/m128.
    defn = new InsnDefn("movupd", x86_movupd,  0x03, 0x660f11, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-737");
    define(defn);

    //--- page 3-737 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 10 /r     MOVUPS xmm1,               Valid     Valid        Move packed single-precision
    //               xmm2/m128                                         floating-point values from
    //                                                                 xmm2/m128 to xmm1.
    defn = new InsnDefn("movups", x86_movups,  0x03, 0x0f10, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-737");
    define(defn);
    //  0F 11 /r     MOVUPS xmm2/m128,          Valid     Valid        Move packed single-precision
    //               xmm1                                              floating-point values from xmm1 to
    //                                                                 xmm2/m128.
    defn = new InsnDefn("movups", x86_movups,  0x03, 0x0f11, od_modrm, od_xmm_m128, od_xmm);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-740");
    define(defn);

    //--- page 3-740 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F B6 /r           MOVZX r16, r/m8        Valid     Valid          Move byte to word with zero-
    //                                                                    extension.
    defn = new InsnDefn("movzx",  x86_movzx,   0x03, 0x0fb6, od_modrm, od_r16, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-740");
    define(defn);
    // 0F B6 /r           MOVZX r32, r/m8        Valid     Valid          Move byte to doubleword,
    //                                                                    zero-extension.
    defn = new InsnDefn("movzx",  x86_movzx,   0x03, 0x0fb6, od_modrm, od_r32, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-740");
    define(defn);
    // REX.W + 0F B6 /r   MOVZX r64, r/m8*       Valid     N.E.           Move byte to quadword, zero-
    //                                                                    extension.
    defn = new InsnDefn("movzx",  x86_movzx,   0x02, 0x0fb6, od_rexw|od_modrm, od_r64, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-740");
    define(defn);
    // 0F B7 /r           MOVZX r32, r/m16       Valid     Valid          Move word to doubleword,
    //                                                                    zero-extension.
    defn = new InsnDefn("movzx",  x86_movzx,   0x03, 0x0fb7, od_modrm, od_r32, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-740");
    define(defn);
    // REX.W + 0F B7 /r   MOVZX r64, r/m16       Valid     N.E.           Move word to quadword, zero-
    //                                                                    extension.
    defn = new InsnDefn("movzx",  x86_movzx,   0x02, 0x0fb7, od_rexw|od_modrm, od_r64, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-742");
    define(defn);

    //--- page 3-742 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 66 0F 3A    MPSADBW       Valid   Valid      Sums absolute 8-bit integer difference of adjacent
    // 42 /r ib    xmm1,                            groups of 4 byte integers in xmm1 and
    //             xmm2/m128,                       xmm2/m128 and writes the results in xmm1.
    //                imm8                          Starting offsets within xmm1 and xmm2/m128
    //                                              are determined by imm8.
    defn = new InsnDefn("mpsadbw", x86_mpsadbw, 0x03, 0x660f3a42, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-746");
    define(defn);

    //--- page 3-746 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F6 /4            MUL r/m8        Valid      Valid           Unsigned multiply (AX  AL  r/m8).
    //                             *
    defn = new InsnDefn("mul",    x86_mul,     0x03, 0xf6, od_e4, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-746");
    define(defn);
    // REX + F6 /4      MUL r/m8        Valid      N.E.            Unsigned multiply (AX  AL  r/m8).
    defn = new InsnDefn("mul",    x86_mul,     0x02, 0xf6, od_rex|od_e4, od_r_m8);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-746");
    define(defn);
    // F7 /4            MUL r/m16       Valid      Valid           Unsigned multiply (DX:AX  AX
    //                                                             r/m16).
    defn = new InsnDefn("mul",    x86_mul,     0x03, 0xf7, od_e4, od_r_m16);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-746");
    define(defn);
    // F7 /4            MUL r/m32       Valid      Valid           Unsigned multiply (EDX:EAX  EAX
    //                                                             r/m32).
    defn = new InsnDefn("mul",    x86_mul,     0x03, 0xf7, od_e4, od_r_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-746");
    define(defn);
    // REX.W + F7 /4    MUL r/m64       Valid      N.E.            Unsigned multiply (RDX:RAX  RAX
    //                                                             r/m64.
    defn = new InsnDefn("mul",    x86_mul,     0x02, 0xf7, od_rexw|od_e4, od_r_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-749");
    define(defn);

    //--- page 3-749 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  66 0F 59 /r MULPD xmm1,              Valid     Valid          Multiply packed double-precision
    //              xmm2/m128                                         floating-point values in xmm2/m128 by
    //                                                                xmm1.
    defn = new InsnDefn("mulpd",  x86_mulpd,   0x03, 0x660f59, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-752");
    define(defn);

    //--- page 3-752 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // 0F 59 /r    MULPS xmm1,      Valid        Valid          Multiply packed single-precision
    //             xmm2/m128                                    floating-point values in xmm2/mem by
    //                                                          xmm1.
    defn = new InsnDefn("mulps",  x86_mulps,   0x03, 0x0f59, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-755");
    define(defn);

    //--- page 3-755 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  F2 0F 59 /r MULSD xmm1,               Valid      Valid        Multiply the low double-precision
    //              xmm2/m64                                          floating-point value in xmm2/mem64
    //                                                                by low double-precision floating-
    //                                                                point value in xmm1.
    defn = new InsnDefn("mulsd",  x86_mulsd,   0x03, 0xf20f59, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-758");
    define(defn);

    //--- page 3-758 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    // F3 0F 59 /r     MULSS xmm1,      Valid      Valid         Multiply the low single-precision floating-
    //                 xmm2/m32                                  point value in xmm2/mem by the low
    //                                                           single-precision floating-point value in
    //                                                           xmm1.
    defn = new InsnDefn("mulss",  x86_mulss,   0x03, 0xf30f59, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-761");
    define(defn);

    //--- page 3-761 of x86-InstructionSetReference-AM.pdf -------------------------------------------------------------
    //  0F 01 C9      MWAIT         Valid    Valid      A hint that allow the processor to stop
    //                                                  instruction execution and enter an
    //                                                  implementation-dependent optimized state
    //                                                  until occurrence of a class of events.
    defn = new InsnDefn("mwait",  x86_mwait,   0x03, 0x0f01c9, od_none);
    defn->set_location("x86-InstructionSetReference-AM.pdf, page 3-765");
    define(defn);

    //------------------------------------------------------------------------------------------------------------------
    // The following definitions are from x86-InstructionSetReference-NZ.pdf, version March 2009.
    //------------------------------------------------------------------------------------------------------------------


    //--- page 4-2 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    // F6 /3               NEG r/m8      Valid          Valid            Two's complement negate r/m8.
    defn = new InsnDefn("neg",    x86_neg,     0x03, 0xf6, od_e3, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-2");
    define(defn);
    // REX + F6 /3         NEG r/m8*     Valid          N.E.             Two's complement negate r/m8.
    defn = new InsnDefn("neg",    x86_neg,     0x02, 0xf6, od_rex|od_e3, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-2");
    define(defn);
    // F7 /3               NEG r/m16     Valid          Valid            Two's complement negate
    //                                                                   r/m16.
    defn = new InsnDefn("neg",    x86_neg,     0x03, 0xf7, od_e3, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-2");
    define(defn);
    // F7 /3               NEG r/m32     Valid          Valid            Two's complement negate
    //                                                                   r/m32.
    defn = new InsnDefn("neg",    x86_neg,     0x03, 0xf7, od_e3, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-2");
    define(defn);
    // REX.W + F7 /3       NEG r/m64     Valid          N.E.             Two's complement negate
    //                                                                   r/m64.
    defn = new InsnDefn("neg",    x86_neg,     0x02, 0xf7, od_rexw|od_e3, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-5");
    define(defn);

    //--- page 4-5 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    //  90              NOP           Valid      Valid           One byte no-operation instruction.
    defn = new InsnDefn("nop",    x86_nop,     0x03, 0x90, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-5");
    define(defn);
    //  0F 1F /0        NOP r/m16     Valid      Valid           Multi-byte no-operation instruction.
    defn = new InsnDefn("nop",    x86_nop,     0x03, 0x0f1f, od_e0, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-5");
    define(defn);
    //  0F 1F /0        NOP r/m32     Valid      Valid           Multi-byte no-operation instruction.
    defn = new InsnDefn("nop",    x86_nop,     0x03, 0x0f1f, od_e0, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-7");
    define(defn);

    //--- page 4-7 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    //  F6 /2            NOT r/m8       Valid         Valid           Reverse each bit of r/m8.
    defn = new InsnDefn("not",    x86_not,     0x03, 0xf6, od_e2, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-7");
    define(defn);
    //  REX + F6 /2      NOT r/m8*      Valid         N.E.            Reverse each bit of r/m8.
    defn = new InsnDefn("not",    x86_not,     0x02, 0xf6, od_rex|od_e2, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-7");
    define(defn);
    //  F7 /2            NOT r/m16      Valid         Valid           Reverse each bit of r/m16.
    defn = new InsnDefn("not",    x86_not,     0x03, 0xf7, od_e2, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-7");
    define(defn);
    //  F7 /2            NOT r/m32      Valid         Valid           Reverse each bit of r/m32.
    defn = new InsnDefn("not",    x86_not,     0x03, 0xf7, od_e2, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-7");
    define(defn);
    //  REX.W + F7 /2    NOT r/m64      Valid         N.E.            Reverse each bit of r/m64.
    defn = new InsnDefn("not",    x86_not,     0x02, 0xf7, od_rexw|od_e2, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);

    //--- page 4-9 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    //  0C ib                    OR AL, imm8       Valid        Valid            AL OR imm8.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0c, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  0D iw                    OR AX, imm16      Valid        Valid            AX OR imm16.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0d, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  0D id                    OR EAX, imm32     Valid        Valid            EAX OR imm32.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0d, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX.W + 0D id            OR RAX, imm32     Valid        N.E.             RAX OR imm32 (sign-
    //                                                                           extended).
    defn = new InsnDefn("or",     x86_or,      0x02, 0x0d, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  80 /1 ib                 OR r/m8, imm8     Valid        Valid            r/m8 OR imm8.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x80, od_e1|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX + 80 /1 ib           OR r/m8*, imm8    Valid        N.E.             r/m8 OR imm8.
    defn = new InsnDefn("or",     x86_or,      0x02, 0x80, od_rex|od_e1|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  81 /1 iw                 OR r/m16, imm16   Valid        Valid            r/m16 OR imm16.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x81, od_e1|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  81 /1 id                 OR r/m32, imm32   Valid        Valid            r/m32 OR imm32.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x81, od_e1|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX.W + 81 /1 id         OR r/m64, imm32   Valid        N.E.             r/m64 OR imm32 (sign-
    //                                                                           extended).
    defn = new InsnDefn("or",     x86_or,      0x02, 0x81, od_rexw|od_e1|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  83 /1 ib                 OR r/m16, imm8    Valid        Valid            r/m16 OR imm8 (sign-
    //                                                                           extended).
    defn = new InsnDefn("or",     x86_or,      0x03, 0x83, od_e1|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  83 /1 ib                 OR r/m32, imm8    Valid        Valid            r/m32 OR imm8 (sign-
    //                                                                           extended).
    defn = new InsnDefn("or",     x86_or,      0x03, 0x83, od_e1|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX.W + 83 /1 ib         OR r/m64, imm8    Valid        N.E.             r/m64 OR imm8 (sign-
    //                                                                           extended).
    defn = new InsnDefn("or",     x86_or,      0x02, 0x83, od_rexw|od_e1|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  08 /r                    OR r/m8, r8       Valid        Valid            r/m8 OR r8.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x08, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX + 08 /r              OR r/m8*, r8*     Valid        N.E.             r/m8 OR r8.
    defn = new InsnDefn("or",     x86_or,      0x02, 0x08, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  09 /r                    OR r/m16, r16     Valid        Valid            r/m16 OR r16.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x09, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  09 /r                    OR r/m32, r32     Valid        Valid            r/m32 OR r32.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x09, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX.W + 09 /r            OR r/m64, r64     Valid        N.E.             r/m64 OR r64.
    defn = new InsnDefn("or",     x86_or,      0x02, 0x09, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  0A /r                    OR r8, r/m8       Valid        Valid            r8 OR r/m8.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0a, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX + 0A /r              OR r8*, r/m8*     Valid        N.E.             r8 OR r/m8.
    defn = new InsnDefn("or",     x86_or,      0x02, 0x0a, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  0B /r                    OR r16, r/m16     Valid        Valid            r16 OR r/m16.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  0B /r                    OR r32, r/m32     Valid        Valid            r32 OR r/m32.
    defn = new InsnDefn("or",     x86_or,      0x03, 0x0b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-9");
    define(defn);
    //  REX.W + 0B /r            OR r64, r/m64     Valid        N.E.             r64 OR r/m64.
    defn = new InsnDefn("or",     x86_or,      0x02, 0x0b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-12");
    define(defn);

    //--- page 4-12 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 66 0F 56 /r    ORPD xmm1, xmm2/m128       Valid      Valid           Bitwise OR of xmm2/m128
    //                                                                      and xmm1.
    defn = new InsnDefn("orpd",   x86_orpd,    0x03, 0x660f56, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-14");
    define(defn);

    //--- page 4-14 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F 56 /r        ORPS xmm1, xmm2/m128        Valid        Valid             Bitwise OR of
    //                                                                            xmm2/m128 and
    //                                                                            xmm1.
    defn = new InsnDefn("orps",   x86_orps,    0x03, 0x0f56, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);

    //--- page 4-16 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // E6 ib            OUT imm8, AL        Valid       Valid      Output byte in AL to I/O port
    //                                                             address imm8.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xe6, od_ib, od_imm8, od_AL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);
    // E7 ib            OUT imm8, AX        Valid       Valid      Output word in AX to I/O port
    //                                                             address imm8.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xe7, od_ib, od_imm8, od_AX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);
    // E7 ib            OUT imm8, EAX       Valid       Valid      Output doubleword in EAX to I/O
    //                                                             port address imm8.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xe7, od_ib, od_imm8, od_EAX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);
    // EE               OUT DX, AL          Valid       Valid      Output byte in AL to I/O port
    //                                                             address in DX.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xee, od_none, od_DX, od_AL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);
    // EF               OUT DX, AX          Valid       Valid      Output word in AX to I/O port
    //                                                             address in DX.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xef, od_none, od_DX, od_AX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-16");
    define(defn);
    // EF               OUT DX, EAX         Valid       Valid      Output doubleword in EAX to I/O
    //                                                             port address in DX.
    defn = new InsnDefn("out",    x86_out,     0x03, 0xef, od_none, od_DX, od_EAX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);

    //--- page 4-18 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 6E                OUTS DX, m8        Valid           Valid          Output byte from memory
    //                                                                     location specified in DS:(E)SI or
    //                                                                     RSI to I/O port specified in DX**.
    defn = new InsnDefn("outs",   x86_outs,    0x03, 0x6e, od_none, od_DX, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);
    // 6F                OUTS DX, m16       Valid           Valid          Output word from memory
    //                                                                     location specified in DS:(E)SI or
    //                                                                     RSI to I/O port specified in DX**.
    defn = new InsnDefn("outs",   x86_outs,    0x03, 0x6f, od_none, od_DX, od_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);
    // 6F                OUTS DX, m32       Valid           Valid          Output doubleword from
    //                                                                     memory location specified in
    //                                                                     DS:(E)SI or RSI to I/O port
    //                                                                     specified in DX**.
    defn = new InsnDefn("outs",   x86_outs,    0x03, 0x6f, od_none, od_DX, od_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);
    // 6E                OUTSB              Valid           Valid          Output byte from memory
    //                                                                     location specified in DS:(E)SI or
    //                                                                     RSI to I/O port specified in DX**.
    defn = new InsnDefn("outsb",  x86_outsb,   0x03, 0x6e, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);
    // 6F                OUTSW              Valid           Valid          Output word from memory
    //                                                                     location specified in DS:(E)SI or
    //                                                                     RSI to I/O port specified in DX**.
    defn = new InsnDefn("outsw",  x86_outsw,   0x03, 0x6f, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-18");
    define(defn);
    // 6F                OUTSD              Valid           Valid          Output doubleword from
    //                                                                     memory location specified in
    //                                                                     DS:(E)SI or RSI to I/O port
    //                                                                     specified in DX**.
    defn = new InsnDefn("outsd",  x86_outsd,   0x03, 0x6f, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);

    //--- page 4-23 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 38 1C /r     PABSB mm1,          Valid       Valid      Compute the absolute value of
    //                  mm2/m64                                    bytes in mm2/m64 and store
    //                                                             UNSIGNED result in mm1.
    defn = new InsnDefn("pabsb",  x86_pabsb,   0x03, 0x0f381c, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);
    //  66 0F 38 1C /r PABSB xmm1,          Valid       Valid      Compute the absolute value of
    //                 xmm2/m128                                   bytes in xmm2/m128 and store
    //                                                             UNSIGNED result in xmm1.
    defn = new InsnDefn("pabsb",  x86_pabsb,   0x03, 0x660f381c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);
    //  0F 38 1D /r     PABSW mm1,          Valid       Valid      Compute the absolute value of 16-
    //                  mm2/m64                                    bit integers in mm2/m64 and store
    //                                                             UNSIGNED result in mm1.
    defn = new InsnDefn("pabsw",  x86_pabsw,   0x03, 0x0f381d, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);
    //  66 0F 38 1D /r PABSW xmm1,          Valid       Valid      Compute the absolute value of 16-
    //                 xmm2/m128                                   bit integers in xmm2/m128 and
    //                                                             store UNSIGNED result in xmm1.
    defn = new InsnDefn("pabsw",  x86_pabsw,   0x03, 0x660f381d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);
    //  0F 38 1E /r     PABSD mm1,          Valid       Valid      Compute the absolute value of 32-
    //                  mm2/m64                                    bit integers in mm2/m64 and store
    //                                                             UNSIGNED result in mm1.
    defn = new InsnDefn("pabsd",  x86_pabsd,   0x03, 0x0f381e, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-23");
    define(defn);
    //  66 0F 38 1E /r PABSD xmm1,          Valid       Valid      Compute the absolute value of 32-
    //                 xmm2/m128                                   bit integers in xmm2/m128 and
    //                                                             store UNSIGNED result in xmm1.
    defn = new InsnDefn("pabsd",  x86_pabsd,   0x03, 0x660f381e, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-27");
    define(defn);

    //--- page 4-27 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 63 /r       PACKSSWB mm1,          Valid              Valid            Converts 4 packed signed word
    //                 mm2/m64                                                    integers from mm1 and from
    //                                                                            mm2/m64 into 8 packed signed
    //                                                                            byte integers in mm1 using signed
    //                                                                            saturation.
    defn = new InsnDefn("packsswb", x86_packsswb, 0x03, 0x0f63, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-27");
    define(defn);
    //  66 0F 63 /r    PACKSSWB xmm1,         Valid              Valid            Converts 8 packed signed word
    //                 xmm2/m128                                                  integers from xmm1 and from
    //                                                                            xxm2/m128 into 16 packed signed
    //                                                                            byte integers in xxm1 using signed
    //                                                                            saturation.
    defn = new InsnDefn("packsswb", x86_packsswb, 0x03, 0x660f63, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-27");
    define(defn);
    //  0F 6B /r       PACKSSDW mm1,          Valid              Valid            Converts 2 packed signed
    //                 mm2/m64                                                    doubleword integers from mm1 and
    //                                                                            from mm2/m64 into 4 packed
    //                                                                            signed word integers in mm1 using
    //                                                                            signed saturation.
    defn = new InsnDefn("packssdw", x86_packssdw, 0x03, 0x0f6b, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-27");
    define(defn);
    //  66 0F 6B /r    PACKSSDW xmm1,         Valid              Valid            Converts 4 packed signed
    //                 xmm2/m128                                                  doubleword integers from xmm1
    //                                                                            and from xxm2/m128 into 8 packed
    //                                                                            signed word integers in xxm1 using
    //                                                                            signed saturation.
    defn = new InsnDefn("packssdw", x86_packssdw, 0x03, 0x660f6b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-32");
    define(defn);

    //--- page 4-32 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 66 0F    PACKUSDW xmm1,       Valid   Valid      Convert 4 packed signed doubleword integers
    // 38 2B /r xmm2/m128                               from xmm1 and 4 packed signed doubleword
    //                                                  integers from xmm2/m128 into 8 packed
    //                                                  unsigned word integers in xmm1 using
    //                                                  unsigned saturation.
    defn = new InsnDefn("packusdw", x86_packusdw, 0x03, 0x660f382b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-35");
    define(defn);

    //--- page 4-35 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 67 /r       PACKUSWB mm,         Valid    Valid      Converts 4 signed word integers
    //                 mm/m64                                   from mm and 4 signed word
    //                                                          integers from mm/m64 into 8
    //                                                          unsigned byte integers in mm using
    //                                                          unsigned saturation.
    defn = new InsnDefn("packuswb", x86_packuswb, 0x03, 0x0f67, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-35");
    define(defn);
    //  66 0F 67 /r    PACKUSWB xmm1,       Valid    Valid      Converts 8 signed word integers
    //                 xmm2/m128                                from xmm1 and 8 signed word
    //                                                          integers from xmm2/m128 into 16
    //                                                          unsigned byte integers in xmm1
    //                                                          using unsigned saturation.
    defn = new InsnDefn("packuswb", x86_packuswb, 0x03, 0x660f67, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);

    //--- page 4-39 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F FC /r      PADDB mm,         Valid    Valid      Add packed byte integers from
    //                mm/m64                                mm/m64 and mm.
    defn = new InsnDefn("paddb",  x86_paddb,   0x03, 0x0ffc, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);
    //  66 0F FC /r   PADDB xmm1,       Valid    Valid      Add packed byte integers from
    //                xmm2/m128                             xmm2/m128 and xmm1.
    defn = new InsnDefn("paddb",  x86_paddb,   0x03, 0x660ffc, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);
    //  0F FD /r      PADDW mm,         Valid    Valid      Add packed word integers from
    //                mm/m64                                mm/m64 and mm.
    defn = new InsnDefn("paddw",  x86_paddw,   0x03, 0x0ffd, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);
    //  66 0F FD /r   PADDW xmm1,       Valid    Valid      Add packed word integers from
    //                xmm2/m128                             xmm2/m128 and xmm1.
    defn = new InsnDefn("paddw",  x86_paddw,   0x03, 0x660ffd, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);
    //  0F FE /r      PADDD mm,         Valid    Valid      Add packed doubleword integers from
    //                mm/m64                                mm/m64 and mm.
    defn = new InsnDefn("paddd",  x86_paddd,   0x03, 0x0ffe, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-39");
    define(defn);
    //  66 0F FE /r   PADDD xmm1,       Valid    Valid      Add packed doubleword integers from
    //                xmm2/m128                             xmm2/m128 and xmm1.
    defn = new InsnDefn("paddd",  x86_paddd,   0x03, 0x660ffe, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-43");
    define(defn);

    //--- page 4-43 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F D4 /r      PADDQ mm1,            Valid      Valid        Add quadword integer
    //                mm2/m64                                       mm2/m64 to mm1.
    defn = new InsnDefn("paddq",  x86_paddq,   0x03, 0x0fd4, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-43");
    define(defn);
    //  66 0F D4 /r   PADDQ xmm1,           Valid      Valid        Add packed quadword integers
    //                xmm2/m128                                     xmm2/m128 to xmm1.
    defn = new InsnDefn("paddq",  x86_paddq,   0x03, 0x660fd4, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-46");
    define(defn);

    //--- page 4-46 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F EC /r       PADDSB mm,           Valid      Valid          Add packed signed byte integers
    //                mm/m64                                         from mm/m64 and mm and
    //                                                               saturate the results.
    defn = new InsnDefn("paddsb", x86_paddsb,  0x03, 0x0fec, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-46");
    define(defn);
    // 66 0F EC /r    PADDSB xmm1,         Valid      Valid          Add packed signed byte integers
    //                xmm2/m128                                      from xmm2/m128 and xmm1
    //                                                               saturate the results.
    defn = new InsnDefn("paddsb", x86_paddsb,  0x03, 0x660fec, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-46");
    define(defn);
    // 0F ED /r       PADDSW mm,           Valid      Valid          Add packed signed word integers
    //                mm/m64                                         from mm/m64 and mm and
    //                                                               saturate the results.
    defn = new InsnDefn("paddsw", x86_paddsw,  0x03, 0x0fed, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-46");
    define(defn);
    // 66 0F ED /r    PADDSW xmm1,         Valid      Valid          Add packed signed word integers
    //                xmm2/m128                                      from xmm2/m128 and xmm1
    //                                                               and saturate the results.
    defn = new InsnDefn("paddsw", x86_paddsw,  0x03, 0x660fed, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-50");
    define(defn);

    //--- page 4-50 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F DC /r       PADDUSB mm,             Valid     Valid        Add packed unsigned byte integers
    //                mm/m64                                         from mm/m64 and mm and
    //                                                               saturate the results.
    defn = new InsnDefn("paddusb", x86_paddusb, 0x03, 0x0fdc, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-50");
    define(defn);
    // 66 0F DC /r    PADDUSB xmm1,           Valid     Valid        Add packed unsigned byte integers
    //                xmm2/m128                                      from xmm2/m128 and xmm1
    //                                                               saturate the results.
    defn = new InsnDefn("paddusb", x86_paddusb, 0x03, 0x660fdc, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-50");
    define(defn);
    // 0F DD /r       PADDUSW mm,             Valid     Valid        Add packed unsigned word
    //                mm/m64                                         integers from mm/m64 and mm
    //                                                               and saturate the results.
    defn = new InsnDefn("paddusw", x86_paddusw, 0x03, 0x0fdd, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-50");
    define(defn);
    // 66 0F DD /r    PADDUSW xmm1,           Valid     Valid        Add packed unsigned word
    //                xmm2/m128                                      integers from xmm2/m128 to
    //                                                               xmm1 and saturate the results.
    defn = new InsnDefn("paddusw", x86_paddusw, 0x03, 0x660fdd, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-54");
    define(defn);

    //--- page 4-54 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F 3A 0F        PALIGNR mm1,        Valid     Valid         Concatenate destination and source
    //                 mm2/m64, imm8                               operands, extract byte-aligned
    //                                                             result shifted to the right by
    //                                                             constant value in imm8 into mm1.
    defn = new InsnDefn("palignr", x86_palignr, 0x03, 0x0f3a0f, od_ib, od_mm, od_mm_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-54");
    define(defn);
    // 66 0F 3A 0F     PALIGNR xmm1,       Valid     Valid         Concatenate destination and source
    //                 xmm2/m128,                                  operands, extract byte-aligned
    //                 imm8                                        result shifted to the right by
    //                                                             constant value in imm8 into xmm1
    defn = new InsnDefn("palignr", x86_palignr, 0x03, 0x660f3a0f, od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-57");
    define(defn);

    //--- page 4-57 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F DB /r       PAND mm, mm/m64           Valid    Valid         Bitwise AND mm/m64 and
    //                                                                  mm.
    defn = new InsnDefn("pand",   x86_pand,    0x03, 0x0fdb, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-57");
    define(defn);
    //  66 0F DB /r    PAND xmm1, xmm2/m128      Valid    Valid         Bitwise AND of
    //                                                                  xmm2/m128 and xmm1.
    defn = new InsnDefn("pand",   x86_pand,    0x03, 0x660fdb, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-60");
    define(defn);

    //--- page 4-60 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F DF /r       PANDN mm, mm/m64             Valid    Valid         Bitwise AND NOT of
    //                                                                    mm/m64 and mm.
    defn = new InsnDefn("pandn",  x86_pandn,   0x03, 0x0fdf, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-60");
    define(defn);
    // 66 0F DF /r    PANDN xmm1, xmm2/m128        Valid    Valid         Bitwise AND NOT of
    //                                                                    xmm2/m128 and
    //                                                                    xmm1.
    defn = new InsnDefn("pandn",  x86_pandn,   0x03, 0x660fdf, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-63");
    define(defn);

    //--- page 4-63 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  F3 90        PAUSE         Valid    Valid      Gives hint to processor that improves
    //                                                 performance of spin-wait loops.
    defn = new InsnDefn("pause",  x86_pause,   0x03, 0xf390, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-64");
    define(defn);

    //--- page 4-64 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F E0 /r        PAVGB mm1,        Valid      Valid         Average packed unsigned byte
    //                 mm2/m64                                    integers from mm2/m64 and mm1
    //                                                            with rounding.
    defn = new InsnDefn("pavgb",  x86_pavgb,   0x03, 0x0fe0, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-64");
    define(defn);
    // 66 0F E0, /r    PAVGB xmm1,       Valid      Valid         Average packed unsigned byte
    //                 xmm2/m128                                  integers from xmm2/m128 and xmm1
    //                                                            with rounding.
    defn = new InsnDefn("pavgb",  x86_pavgb,   0x03, 0x660fe0, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-64");
    define(defn);
    // 0F E3 /r        PAVGW mm1,        Valid      Valid         Average packed unsigned word
    //                 mm2/m64                                    integers from mm2/m64 and mm1
    //                                                            with rounding.
    defn = new InsnDefn("pavgw",  x86_pavgw,   0x03, 0x0fe3, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-64");
    define(defn);
    // 66 0F E3 /r     PAVGW xmm1,       Valid      Valid         Average packed unsigned word
    //                 xmm2/m128                                  integers from xmm2/m128 and xmm1
    //                                                            with rounding.
    defn = new InsnDefn("pavgw",  x86_pavgw,   0x03, 0x660fe3, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-68");
    define(defn);

    //--- page 4-68 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 66 0F 38 10 PBLENDVB xmm1,            Valid    Valid    Select byte values from xmm1 and
    // /r          xmm2/m128,                                  xmm2/m128 from mask specified in
    //             <XMM0>                                      the high bit of each byte in XMM0
    //                                                         and store the values into xmm1.
    defn = new InsnDefn("pblendvb", x86_pblendvb, 0x03, 0x660f3810, od_modrm, od_xmm, od_xmm_m128, od_XMM0);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-72");
    define(defn);

    //--- page 4-72 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 66 0F 3A       PBLENDW xmm1,   Valid         Valid      Select words from xmm1 and
    // 0E /r ib       xmm2/m128, imm8                          xmm2/m128 from mask specified in
    //                                                         imm8 and store the values into
    //                                                         xmm1.
    defn = new InsnDefn("pblendw", x86_pblendw, 0x03, 0x660f3a0e, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);

    //--- page 4-75 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 74 /r      PCMPEQB mm,            Valid      Valid          Compare packed bytes in
    //                mm/m64                                           mm/m64 and mm for equality.
    defn = new InsnDefn("pcmpeqb", x86_pcmpeqb, 0x03, 0x0f74, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);
    //  66 0F 74 /r   PCMPEQB xmm1,          Valid      Valid          Compare packed bytes in
    //                xmm2/m128                                        xmm2/m128 and xmm1 for
    //                                                                 equality.
    defn = new InsnDefn("pcmpeqb", x86_pcmpeqb, 0x03, 0x660f74, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);
    //  0F 75 /r      PCMPEQW mm,            Valid      Valid          Compare packed words in
    //                mm/m64                                           mm/m64 and mm for equality.
    defn = new InsnDefn("pcmpeqw", x86_pcmpeqw, 0x03, 0x0f75, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);
    //  66 0F 75 /r   PCMPEQW xmm1,          Valid      Valid          Compare packed words in
    //                xmm2/m128                                        xmm2/m128 and xmm1 for
    //                                                                 equality.
    defn = new InsnDefn("pcmpeqw", x86_pcmpeqw, 0x03, 0x660f75, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);
    //  0F 76 /r      PCMPEQD mm,            Valid      Valid          Compare packed doublewords in
    //                mm/m64                                           mm/m64 and mm for equality.
    defn = new InsnDefn("pcmpeqd", x86_pcmpeqd, 0x03, 0x0f76, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-75");
    define(defn);
    //  66 0F 76 /r   PCMPEQD xmm1,          Valid      Valid          Compare packed doublewords in
    //                xmm2/m128                                        xmm2/m128 and xmm1 for
    //                                                                 equality.
    defn = new InsnDefn("pcmpeqd", x86_pcmpeqd, 0x03, 0x660f76, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-79");
    define(defn);

    //--- page 4-79 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  66 0F 38     PCMPEQQ xmm1,         Valid       Valid      Compare packed qwords in
    //  29 /r        xmm2/m128                                    xmm2/m128 and xmm1 for
    //                                                            equality.
    defn = new InsnDefn("pcmpeqq", x86_pcmpeqq, 0x03, 0x660f3829, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-81");
    define(defn);

    //--- page 4-81 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //   66 0F 3A 61       PCMPESTRI           Valid      Valid           Perform a packed comparison of
    //   /r imm8           xmm1,                                          string data with explicit lengths,
    //                     xmm2/m128,                                     generating an index, and storing the
    //                     imm8                                           result in ECX.
    defn = new InsnDefn("pcmpestri", x86_pcmpestri, 0x03, 0x660f3a61, od_modrm, od_imm8, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-84");
    define(defn);

    //--- page 4-84 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  66 0F 3A 60    PCMPESTRM             Valid     Valid         Perform a packed comparison of
    //  /r imm8        xmm1,                                         string data with explicit lengths,
    //                 xmm2/m128,                                    generating a mask, and storing the
    //                 imm8                                          result in XMM0
    defn = new InsnDefn("pcmpestrm", x86_pcmpestrm, 0x03, 0x660f3a60, od_modrm, od_imm8, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-87");
    define(defn);

    //--- page 4-87 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //   66 0F 3A        PCMPISTRI xmm1,          Valid      Valid         Perform a packed comparison of
    //   63 /r imm8      xmm2/m128,                                        string data with implicit lengths,
    //                   imm8                                              generating an index, and storing
    //                                                                     the result in ECX.
    defn = new InsnDefn("pcmpistri", x86_pcmpistri, 0x03, 0x660f3a63, od_modrm, od_xmm, od_imm8, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-90");
    define(defn);

    //--- page 4-90 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  66 0F 3A         PCMPISTRM xmm1,     Valid     Valid         Perform a packed comparison of
    //  62 /r imm8       xmm2/m128, imm8                             string data with implicit lengths,
    //                                                               generating a mask, and storing
    //                                                               the result in XMM0.
    defn = new InsnDefn("pcmpistrm", x86_pcmpistrm, 0x03, 0x660f3a62, od_modrm, od_xmm, od_imm8, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);

    //--- page 4-93 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 64 /r       PCMPGTB mm,             Valid     Valid        Compare packed signed byte
    //                 mm/m64                                         integers in mm and mm/m64 for
    //                                                                greater than.
    defn = new InsnDefn("pcmpgtb", x86_pcmpgtb, 0x03, 0x0f64, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);
    //  66 0F 64 /r    PCMPGTB xmm1,           Valid     Valid        Compare packed signed byte
    //                 xmm2/m128                                      integers in xmm1 and
    //                                                                xmm2/m128 for greater than.
    defn = new InsnDefn("pcmpgtb", x86_pcmpgtb, 0x03, 0x660f64, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);
    //  0F 65 /r       PCMPGTW mm,             Valid     Valid        Compare packed signed word
    //                 mm/m64                                         integers in mm and mm/m64 for
    //                                                                greater than.
    defn = new InsnDefn("pcmpgtw", x86_pcmpgtw, 0x03, 0x0f65, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);
    //  66 0F 65 /r    PCMPGTW xmm1,           Valid     Valid        Compare packed signed word
    //                 xmm2/m128                                      integers in xmm1 and
    //                                                                xmm2/m128 for greater than.
    defn = new InsnDefn("pcmpgtw", x86_pcmpgtw, 0x03, 0x660f65, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);
    //  0F 66 /r       PCMPGTD mm,             Valid     Valid        Compare packed signed
    //                 mm/m64                                         doubleword integers in mm and
    //                                                                mm/m64 for greater than.
    defn = new InsnDefn("pcmpgtd", x86_pcmpgtd, 0x03, 0x0f66, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-93");
    define(defn);
    //  66 0F 66 /r    PCMPGTD xmm1,           Valid     Valid        Compare packed signed
    //                 xmm2/m128                                      doubleword integers in xmm1
    //                                                                and xmm2/m128 for greater
    //                                                                than.
    defn = new InsnDefn("pcmpgtd", x86_pcmpgtd, 0x03, 0x660f66, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-98");
    define(defn);

    //--- page 4-98 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  66 0F 38      PCMPGTQ           Valid      Valid         Compare packed qwords in
    //  37 /r         xmm1,xmm2/m128                             xmm2/m128 and xmm1 for greater
    //                                                           than.
    defn = new InsnDefn("pcmpgtq", x86_pcmpgtq, 0x03, 0x660f3837, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-100");
    define(defn);

    //--- page 4-100 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 3A 14     PEXTRB reg/m8,       Valid      Valid           Extract a byte integer value from
    // /r ib           xmm2, imm8                                      xmm2 at the source byte offset
    //                                                                 specified by imm8 into rreg or
    //                                                                 m8. The upper bits of r32 or r64
    //                                                                 are zeroed.
    defn = new InsnDefn("pextrb", x86_pextrb,  0x03, 0x660f3a14, od_modrm|od_ib, od_r_m8, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-100");
    define(defn);
    // 66 0F 3A 16     PEXTRD r/m32,        Valid      Valid           Extract a dword integer value
    // /r ib           xmm2, imm8                                      from xmm2 at the source dword
    //                                                                 offset specified by imm8 into
    //                                                                 r/m32.
    defn = new InsnDefn("pextrd", x86_pextrd,  0x03, 0x660f3a16, od_modrm|od_ib, od_r_m32, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-100");
    define(defn);
    // 66 REX.W 0F     PEXTRQ r/m64,        Valid      N. E.           Extract a qword integer value
    // 3A 16           xmm2, imm8                                      from xmm2 at the source qword
    // /r ib                                                           offset specified by imm8 into
    //                                                                 r/m64.
    defn = new InsnDefn("pextrq", x86_pextrq,  0x02, 0x660f3a16, od_rexw|od_modrm|od_ib, od_r_m64, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-103");
    define(defn);

    //--- page 4-103 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F C5 /r ib           PEXTRW reg, mm, Valid         Valid         Extract the word specified by
    //                        imm8                                        imm8 from mm and move it to
    //                                                                    reg, bits 15-0. The upper bits of
    //                                                                    r32 or r64 is zeroed.
    defn = new InsnDefn("pextrw", x86_pextrw,  0x03, 0x0fc5, od_modrm|od_ib, od_reg, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-103");
    define(defn);
    //  66 0F C5 /r ib        PEXTRW reg,        Valid      Valid         Extract the word specified by
    //                        xmm, imm8                                   imm8 from xmm and move it to
    //                                                                    reg, bits 15-0. The upper bits of
    //                                                                    r32 or r64 is zeroed.
    defn = new InsnDefn("pextrw", x86_pextrw,  0x03, 0x660fc5, od_modrm|od_ib, od_reg, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-103");
    define(defn);
    //  66 0F 3A 15           PEXTRW             Valid      Valid         Extract the word specified by
    //  /r ib                 reg/m16, xmm,                               imm8 from xmm and copy it to
    //                        imm8                                        lowest 16 bits of reg or m16.
    //                                                                    Zero-extend the result in the
    //                                                                    destination, r32 or r64.
    defn = new InsnDefn("pextrw", x86_pextrw,  0x03, 0x660f3a15, od_modrm|od_ib, od_r_m16, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-107");
    define(defn);

    //--- page 4-107 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 38 01 /r       PHADDW mm1,          Valid    Valid      Add 16-bit signed integers
    //                    mm2/m64                                  horizontally, pack to MM1.
    defn = new InsnDefn("phaddw", x86_phaddw,  0x03, 0x0f3801, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-107");
    define(defn);
    //  66 0F 38 01 /r    PHADDW xmm1,         Valid    Valid      Add 16-bit signed integers
    //                    xmm2/m128                                horizontally, pack to XMM1.
    defn = new InsnDefn("phaddw", x86_phaddw,  0x03, 0x660f3801, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-107");
    define(defn);
    //  0F 38 02 /r       PHADDD mm1,          Valid    Valid      Add 32-bit signed integers
    //                    mm2/m64                                  horizontally, pack to MM1.
    defn = new InsnDefn("phaddd", x86_phaddd,  0x03, 0x0f3802, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-107");
    define(defn);
    //  66 0F 38 02 /r    PHADDD xmm1,         Valid    Valid      Add 32-bit signed integers
    //                    xmm2/m128                                horizontally, pack to XMM1.
    defn = new InsnDefn("phaddd", x86_phaddd,  0x03, 0x660f3802, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-110");
    define(defn);

    //--- page 4-110 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 38 03 /r     PHADDSW mm1,      Valid     Valid         Add 16-bit signed integers
    //                 mm2/m64                                   horizontally, pack saturated integers
    //                                                           to MM1.
    defn = new InsnDefn("phaddsw", x86_phaddsw, 0x03, 0x0f3803, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-110");
    define(defn);
    // 66 0F 38 03 /r PHADDSW xmm1,      Valid     Valid         Add 16-bit signed integers
    //                xmm2/m128                                  horizontally, pack saturated integers
    //                                                           to XMM1.
    defn = new InsnDefn("phaddsw", x86_phaddsw, 0x03, 0x660f3803, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-113");
    define(defn);

    //--- page 4-113 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38     PHMINPOSUW xmm1,        Valid   Valid   Find the minimum unsigned word in
    //  41 /r        xmm2/m128                               xmm2/m128 and place its value in the
    //                                                       low word of xmm1 and its index in the
    //                                                       second-lowest word of xmm1.
    defn = new InsnDefn("phminposuw", x86_phminposuw, 0x03, 0x660f3841, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-116");
    define(defn);

    //--- page 4-116 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 38 05 /r             PHSUBW mm1,    Valid     Valid        Subtract 16-bit signed
    //                         mm2/m64                               integers horizontally, pack
    //                                                               to MM1.
    defn = new InsnDefn("phsubw", x86_phsubw,  0x03, 0x0f3805, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-116");
    define(defn);
    // 66 0F 38 05 /r          PHSUBW xmm1,   Valid     Valid        Subtract 16-bit signed
    //                         xmm2/m128                             integers horizontally, pack
    //                                                               to XMM1.
    defn = new InsnDefn("phsubw", x86_phsubw,  0x03, 0x660f3805, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-116");
    define(defn);
    // 0F 38 06 /r             PHSUBD mm1,    Valid     Valid        Subtract 32-bit signed
    //                         mm2/m64                               integers horizontally, pack
    //                                                               to MM1.
    defn = new InsnDefn("phsubd", x86_phsubd,  0x03, 0x0f3806, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-116");
    define(defn);
    // 66 0F 38 06 /r          PHSUBD xmm1,   Valid       Valid      Subtract 32-bit signed
    //                         xmm2/m128                             integers horizontally, pack
    //                                                               to XMM1.
    defn = new InsnDefn("phsubd", x86_phsubd,  0x03, 0x660f3806, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-119");
    define(defn);

    //--- page 4-119 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 38 07 /r                PHSUBSW mm1,       Valid    Valid         Subtract 16-bit signed
    //                             mm2/m64                                   integer horizontally, pack
    //                                                                       saturated integers to MM1.
    defn = new InsnDefn("phsubsw", x86_phsubsw, 0x03, 0x0f3807, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-119");
    define(defn);
    //  66 0F 38 07 /r             PHSUBSW            Valid    Valid         Subtract 16-bit signed
    //                             xmm1,                                     integer horizontally, pack
    //                             xmm2/m128                                 saturated integers to
    //                                                                       XMM1
    defn = new InsnDefn("phsubsw", x86_phsubsw, 0x03, 0x660f3807, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-122");
    define(defn);

    //--- page 4-122 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 3A        PINSRB xmm1,   Valid      Valid     Insert a byte integer value from r32/m8
    // 20 /r ib        r32/m8, imm8                        into xmm1 at the destination element in
    //                                                     xmm1 specified by imm8.
    defn = new InsnDefn("pinsrb", x86_pinsrb,  0x03, 0x660f3a20, od_modrm|od_ib, od_xmm, od_r32_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-122");
    define(defn);
    // 66 0F 3A        PINSRD xmm1,   Valid      Valid     Insert a dword integer value from r/m32
    // 22 /r ib        r/m32, imm8                         into the xmm1 at the destination
    //                                                     elements specified by imm8.
    defn = new InsnDefn("pinsrd", x86_pinsrd,  0x03, 0x660f3a22, od_modrm|od_ib, od_xmm, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-122");
    define(defn);
    // 66 REX.W    PINSRQ xmm1,       N. E.      Valid     Insert a qword integer value from r/m32
    // 0F 3A 22 /r r/m64, imm8                             into the xmm1 at the destination
    // ib                                                  elements specified by imm8.
    defn = new InsnDefn("pinsrq", x86_pinsrq,  0x01, 0x660f3a22, od_rexw|od_modrm|od_ib, od_xmm, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-125");
    define(defn);

    //--- page 4-125 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F C4 /r ib           PINSRW mm,       Valid      Valid         Insert the low word from
    //                        r32/m16, imm8                             r32 or from m16 into mm
    //                                                                  at the word position
    //                                                                  specified by imm8
    defn = new InsnDefn("pinsrw", x86_pinsrw,  0x03, 0x0fc4, od_modrm|od_ib, od_mm, od_r32_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-125");
    define(defn);
    //  66 0F C4 /r ib        PINSRW xmm,      Valid      Valid         Move the low word of r32
    //                        r32/m16, imm8                             or from m16 into xmm at
    //                                                                  the word position specified
    //                                                                  by imm8.
    defn = new InsnDefn("pinsrw", x86_pinsrw,  0x03, 0x660fc4, od_modrm|od_ib, od_xmm, od_r32_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-128");
    define(defn);

    //--- page 4-128 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 38 04 /r            PMADDUBSW           Valid       Valid          Multiply signed and
    //                        mm1, mm2/m64                                   unsigned bytes, add
    //                                                                       horizontal pair of signed
    //                                                                       words, pack saturated
    //                                                                       signed-words to MM1.
    defn = new InsnDefn("pmaddubsw", x86_pmaddubsw, 0x03, 0x0f3804, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-128");
    define(defn);
    // 66 0F 38 04 /r         PMADDUBSW           Valid       Valid          Multiply signed and
    //                        xmm1,                                          unsigned bytes, add
    //                        xmm2/m128                                      horizontal pair of signed
    //                                                                       words, pack saturated
    //                                                                       signed-words to XMM1.
    defn = new InsnDefn("pmaddubsw", x86_pmaddubsw, 0x03, 0x660f3804, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-131");
    define(defn);

    //--- page 4-131 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F F5 /r        PMADDWD mm,          Valid    Valid      Multiply the packed words in mm
    //                  mm/m64                                   by the packed words in mm/m64,
    //                                                           add adjacent doubleword results,
    //                                                           and store in mm.
    defn = new InsnDefn("pmaddwd", x86_pmaddwd, 0x03, 0x0ff5, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-131");
    define(defn);
    //  66 0F F5 /r     PMADDWD xmm1,        Valid    Valid      Multiply the packed word integers
    //                  xmm2/m128                                in xmm1 by the packed word
    //                                                           integers in xmm2/m128, add
    //                                                           adjacent doubleword results, and
    //                                                           store in xmm1.
    defn = new InsnDefn("pmaddwd", x86_pmaddwd, 0x03, 0x660ff5, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-135");
    define(defn);

    //--- page 4-135 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38     PMAXSB xmm1,         Valid     Valid      Compare packed signed byte integers
    //  3C /r        xmm2/m128                                 in xmm1 and xmm2/m128 and store
    //                                                         packed maximum values in xmm1.
    defn = new InsnDefn("pmaxsb", x86_pmaxsb,  0x03, 0x660f383c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-138");
    define(defn);

    //--- page 4-138 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38        PMAXSD xmm1,    Valid      Valid         Compare packed signed dword integers in
    // 3D /r           xmm2/m128                                xmm1 and xmm2/m128 and store
    //                                                          packed maximum values in xmm1.
    defn = new InsnDefn("pmaxsd", x86_pmaxsd,  0x03, 0x660f383d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-141");
    define(defn);

    //--- page 4-141 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F EE /r      PMAXSW mm1,         Valid        Valid      Compare signed word integers in
    //                mm2/m64                                     mm2/m64 and mm1 and return
    //                                                            maximum values.
    defn = new InsnDefn("pmaxsw", x86_pmaxsw,  0x03, 0x0fee, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-141");
    define(defn);
    //  66 0F EE /r   PMAXSW xmm1,        Valid        Valid      Compare signed word integers in
    //                xmm2/m128                                   xmm2/m128 and xmm1 and return
    //                                                            maximum values.
    defn = new InsnDefn("pmaxsw", x86_pmaxsw,  0x03, 0x660fee, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-144");
    define(defn);

    //--- page 4-144 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F DE /r        PMAXUB mm1,           Valid     Valid           Compare unsigned byte integers
    //                 mm2/m64                                         in mm2/m64 and mm1 and
    //                                                                 returns maximum values.
    defn = new InsnDefn("pmaxub", x86_pmaxub,  0x03, 0x0fde, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-144");
    define(defn);
    // 66 0F DE /r     PMAXUB xmm1,          Valid     Valid           Compare unsigned byte integers
    //                 xmm2/m128                                       in xmm2/m128 and xmm1 and
    //                                                                 returns maximum values.
    defn = new InsnDefn("pmaxub", x86_pmaxub,  0x03, 0x660fde, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-147");
    define(defn);

    //--- page 4-147 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38     PMAXUD xmm1,        Valid              Valid         Compare packed unsigned
    //  3F /r        xmm2/m128                                            dword integers in xmm1 and
    //                                                                    xmm2/m128 and store packed
    //                                                                    maximum values in xmm1.
    defn = new InsnDefn("pmaxud", x86_pmaxud,  0x03, 0x660f383f, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-150");
    define(defn);

    //--- page 4-150 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38        PMAXUW xmm1,     Valid       Valid      Compare packed unsigned word
    // 3E /r           xmm2/m128                               integers in xmm1 and xmm2/m128
    //                                                         and store packed maximum values in
    //                                                         xmm1.
    defn = new InsnDefn("pmaxuw", x86_pmaxuw,  0x03, 0x660f383e, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-153");
    define(defn);

    //--- page 4-153 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38 38      PMINSB xmm1,      Valid    Valid   Compare packed signed byte integers in
    //  /r               xmm2/m128                          xmm1 and xmm2/m128 and store packed
    //                                                      minimum values in xmm1.
    defn = new InsnDefn("pminsb", x86_pminsb,  0x03, 0x660f3838, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-156");
    define(defn);

    //--- page 4-156 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38 PMINSD xmm1,        Valid     Valid       Compare packed signed dword integers in
    // 39 /r    xmm2/m128                                 xmm1 and xmm2/m128 and store packed
    //                                                    minimum values in xmm1.
    defn = new InsnDefn("pminsd", x86_pminsd,  0x03, 0x660f3839, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-159");
    define(defn);

    //--- page 4-159 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F EA /r      PMINSW mm1,         Valid        Valid      Compare signed word integers in
    //                mm2/m64                                     mm2/m64 and mm1 and return
    //                                                            minimum values.
    defn = new InsnDefn("pminsw", x86_pminsw,  0x03, 0x0fea, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-159");
    define(defn);
    //  66 0F EA /r   PMINSW xmm1,        Valid        Valid      Compare signed word integers in
    //                xmm2/m128                                   xmm2/m128 and xmm1 and return
    //                                                            minimum values.
    defn = new InsnDefn("pminsw", x86_pminsw,  0x03, 0x660fea, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-162");
    define(defn);

    //--- page 4-162 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F DA /r         PMINUB mm1,        Valid      Valid         Compare unsigned byte integers in
    //                  mm2/m64                                     mm2/m64 and mm1 and returns
    //                                                              minimum values.
    defn = new InsnDefn("pminub", x86_pminub,  0x03, 0x0fda, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-162");
    define(defn);
    // 66 0F DA /r      PMINUB xmm1,       Valid      Valid         Compare unsigned byte integers in
    //                  xmm2/m128                                   xmm2/m128 and xmm1 and
    //                                                              returns minimum values.
    defn = new InsnDefn("pminub", x86_pminub,  0x03, 0x660fda, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-165");
    define(defn);

    //--- page 4-165 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38     PMINUD xmm1,         Valid    Valid       Compare packed unsigned dword
    //  3B /r        xmm2/m128                                 integers in xmm1 and xmm2/m128
    //                                                         and store packed minimum values in
    //                                                         xmm1.
    defn = new InsnDefn("pminud", x86_pminud,  0x03, 0x660f383b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-168");
    define(defn);

    //--- page 4-168 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38 3A PMINUW xmm1,          Valid      Valid         Compare packed unsigned word
    // /r          xmm2/m128                                      integers in xmm1 and xmm2/m128
    //                                                            and store packed minimum values in
    //                                                            xmm1.
    defn = new InsnDefn("pminuw", x86_pminuw,  0x03, 0x660f383a, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-171");
    define(defn);

    //--- page 4-171 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F D7 /r              PMOVMSKB         Valid      Valid        Move a byte mask of mm to
    //                        r32, mm                                  r32.
    defn = new InsnDefn("pmovmskb", x86_pmovmskb, 0x03, 0x0fd7, od_modrm, od_r32, od_mm);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-171");
    define(defn);
    //  REX.W + 0F D7 /r      PMOVMSKB         Valid      N.E.         Move a byte mask of mm to
    //                        r64, mm                                  the lower 32-bits of r64 and
    //                                                                 zero-fill the upper 32-bits.
    defn = new InsnDefn("pmovmskb", x86_pmovmskb, 0x02, 0x0fd7, od_rexw|od_modrm, od_r64, od_mm);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-171");
    define(defn);
    //  66 0F D7 /r           PMOVMSKB reg, Valid         Valid        Move a byte mask of xmm
    //                        xmm                                      to reg. The upper bits of r32
    //                                                                 or r64 are zeroed
    defn = new InsnDefn("pmovmskb", x86_pmovmskb, 0x03, 0x660fd7, od_modrm, od_reg, od_xmm);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);

    //--- page 4-174 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0f 38        PMOVSXBW xmm1,   Valid    Valid      Sign extend 8 packed signed 8-bit
    // 20 /r           xmm2/m64                             integers in the low 8 bytes of
    //                                                      xmm2/m64 to 8 packed signed 16-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxbw", x86_pmovsxbw, 0x03, 0x660f3820, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);
    // 66 0f 38        PMOVSXBD xmm1,   Valid    Valid      Sign extend 4 packed signed 8-bit
    // 21 /r           xmm2/m32                             integers in the low 4 bytes of
    //                                                      xmm2/m32 to 4 packed signed 32-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxbd", x86_pmovsxbd, 0x03, 0x660f3821, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);
    // 66 0f 38        PMOVSXBQ xmm1,   Valid    Valid      Sign extend 2 packed signed 8-bit
    // 22 /r           xmm2/m16                             integers in the low 2 bytes of
    //                                                      xmm2/m16 to 2 packed signed 64-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxbq", x86_pmovsxbq, 0x03, 0x660f3822, od_modrm, od_xmm, od_xmm_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);
    // 66 0f 38        PMOVSXWD xmm1,   Valid    Valid      Sign extend 4 packed signed 16-bit
    // 23 /r           xmm2/m64                             integers in the low 8 bytes of
    //                                                      xmm2/m64 to 4 packed signed 32-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxwd", x86_pmovsxwd, 0x03, 0x660f3823, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);
    // 66 0f 38        PMOVSXWQ xmm1,   Valid    Valid      Sign extend 2 packed signed 16-bit
    // 24 /r           xmm2/m32                             integers in the low 4 bytes of
    //                                                      xmm2/m32 to 2 packed signed 64-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxwq", x86_pmovsxwq, 0x03, 0x660f3824, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-174");
    define(defn);
    // 66 0f 38        PMOVSXDQ xmm1,   Valid    Valid      Sign extend 2 packed signed 32-bit
    // 25 /r           xmm2/m64                             integers in the low 8 bytes of
    //                                                      xmm2/m64 to 2 packed signed 64-
    //                                                      bit integers in xmm1.
    defn = new InsnDefn("pmovsxdq", x86_pmovsxdq, 0x03, 0x660f3825, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);

    //--- page 4-178 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0f 38 PMOVZXBW xmm1,       Valid    Valid      Zero extend 8 packed 8-bit integers in the
    // 30 /r    xmm2/m64                                 low 8 bytes of xmm2/m64 to 8 packed
    //                                                   16-bit integers in xmm1.
    defn = new InsnDefn("pmovzxbw", x86_pmovzxbw, 0x03, 0x660f3830, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);
    // 66 0f 38 PMOVZXBD xmm1,       Valid    Valid      Zero extend 4 packed 8-bit integers in the
    // 31 /r    xmm2/m32                                 low 4 bytes of xmm2/m32 to 4 packed
    //                                                   32-bit integers in xmm1.
    defn = new InsnDefn("pmovzxbd", x86_pmovzxbd, 0x03, 0x660f3831, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);
    // 66 0f 38 PMOVZXBQ xmm1,       Valid    Valid      Zero extend 2 packed 8-bit integers in the
    // 32 /r    xmm2/m16                                 low 2 bytes of xmm2/m16 to 2 packed
    //                                                   64-bit integers in xmm1.
    defn = new InsnDefn("pmovzxbq", x86_pmovzxbq, 0x03, 0x660f3832, od_modrm, od_xmm, od_xmm_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);
    // 66 0f 38 PMOVZXWD xmm1,       Valid    Valid      Zero extend 4 packed 16-bit integers in
    // 33 /r    xmm2/m64                                 the low 8 bytes of xmm2/m64 to 4
    //                                                   packed 32-bit integers in xmm1.
    defn = new InsnDefn("pmovzxwd", x86_pmovzxwd, 0x03, 0x660f3833, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);
    // 66 0f 38 PMOVZXWQ xmm1,       Valid    Valid      Zero extend 2 packed 16-bit integers in
    // 34 /r    xmm2/m32                                 the low 4 bytes of xmm2/m32 to 2
    //                                                   packed 64-bit integers in xmm1.
    defn = new InsnDefn("pmovzxwq", x86_pmovzxwq, 0x03, 0x660f3834, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-178");
    define(defn);
    // 66 0f 38 PMOVZXDQ xmm1,       Valid    Valid      Zero extend 2 packed 32-bit integers in
    // 35 /r    xmm2/m64                                 the low 8 bytes of xmm2/m64 to 2
    //                                                   packed 64-bit integers in xmm1.
    defn = new InsnDefn("pmovzxdq", x86_pmovzxdq, 0x03, 0x660f3835, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-182");
    define(defn);

    //--- page 4-182 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38        PMULDQ xmm1,    Valid      Valid        Multiply the packed signed dword
    // 28 /r           xmm2/m128                               integers in xmm1 and xmm2/m128 and
    //                                                         store the quadword product in xmm1.
    defn = new InsnDefn("pmuldq", x86_pmuldq,  0x03, 0x660f3828, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-184");
    define(defn);

    //--- page 4-184 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 38 0B /r              PMULHRSW          Valid      Valid          Multiply 16-bit signed
    //                          mm1, mm2/m64                                words, scale and round
    //                                                                      signed doublewords, pack
    //                                                                      high 16 bits to MM1.
    defn = new InsnDefn("pmulhrsw", x86_pmulhrsw, 0x03, 0x0f380b, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-184");
    define(defn);
    // 66 0F 38 0B /r           PMULHRSW          Valid      Valid          Multiply 16-bit signed
    //                          xmm1,                                       words, scale and round
    //                          xmm2/m128                                   signed doublewords, pack
    //                                                                      high 16 bits to XMM1.
    defn = new InsnDefn("pmulhrsw", x86_pmulhrsw, 0x03, 0x660f380b, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-187");
    define(defn);

    //--- page 4-187 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F E4 /r         PMULHUW mm1,          Valid         Valid           Multiply the packed unsigned
    //                   mm2/m64                                             word integers in mm1 register
    //                                                                       and mm2/m64, and store the
    //                                                                       high 16 bits of the results in
    //                                                                       mm1.
    defn = new InsnDefn("pmulhuw", x86_pmulhuw, 0x03, 0x0fe4, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-187");
    define(defn);
    //  66 0F E4 /r      PMULHUW xmm1,         Valid         Valid           Multiply the packed unsigned
    //                   xmm2/m128                                           word integers in xmm1 and
    //                                                                       xmm2/m128, and store the high
    //                                                                       16 bits of the results in xmm1.
    defn = new InsnDefn("pmulhuw", x86_pmulhuw, 0x03, 0x660fe4, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-191");
    define(defn);

    //--- page 4-191 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F E5 /r         PMULHW mm,            Valid      Valid       Multiply the packed signed word
    //                   mm/m64                                       integers in mm1 register and
    //                                                                mm2/m64, and store the high 16
    //                                                                bits of the results in mm1.
    defn = new InsnDefn("pmulhw", x86_pmulhw,  0x03, 0x0fe5, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-191");
    define(defn);
    //  66 0F E5 /r      PMULHW xmm1,          Valid      Valid       Multiply the packed signed word
    //                   xmm2/m128                                    integers in xmm1 and
    //                                                                xmm2/m128, and store the high 16
    //                                                                bits of the results in xmm1.
    defn = new InsnDefn("pmulhw", x86_pmulhw,  0x03, 0x660fe5, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-194");
    define(defn);

    //--- page 4-194 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 38 40 /r PMULLD xmm1,      Valid      Valid          Multiply the packed dword signed
    //                xmm2/m128                                   integers in xmm1 and xmm2/m128
    //                                                            and store the low 32 bits of each
    //                                                            product in xmm1.
    defn = new InsnDefn("pmulld", x86_pmulld,  0x03, 0x660f3840, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-196");
    define(defn);

    //--- page 4-196 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F D5 /r        PMULLW mm,         Valid            Valid              Multiply the packed signed word
    //                 mm/m64                                                 integers in mm1 register and
    //                                                                        mm2/m64, and store the low 16
    //                                                                        bits of the results in mm1.
    defn = new InsnDefn("pmullw", x86_pmullw,  0x03, 0x0fd5, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-196");
    define(defn);
    // 66 0F D5 /r     PMULLW xmm1,       Valid            Valid              Multiply the packed signed word
    //                 xmm2/m128                                              integers in xmm1 and xmm2/m128,
    //                                                                        and store the low 16 bits of the
    //                                                                        results in xmm1.
    defn = new InsnDefn("pmullw", x86_pmullw,  0x03, 0x660fd5, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-200");
    define(defn);

    //--- page 4-200 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F F4 /r        PMULUDQ mm1,       Valid     Valid         Multiply unsigned doubleword
    //                 mm2/m64                                    integer in mm1 by unsigned
    //                                                            doubleword integer in mm2/m64,
    //                                                            and store the quadword result in
    //                                                            mm1.
    defn = new InsnDefn("pmuludq", x86_pmuludq, 0x03, 0x0ff4, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-200");
    define(defn);
    // 66 0F F4 /r     PMULUDQ xmm1,      Valid     Valid         Multiply packed unsigned
    //                 xmm2/m128                                  doubleword integers in xmm1 by
    //                                                            packed unsigned doubleword
    //                                                            integers in xmm2/m128, and store
    //                                                            the quadword results in xmm1.
    defn = new InsnDefn("pmuludq", x86_pmuludq, 0x03, 0x660ff4, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);

    //--- page 4-203 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  8F /0            POP r/m16      Valid     Valid      Pop top of stack into m16; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x03, 0x8f, od_e0, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  8F /0            POP r/m32      N.E.      Valid      Pop top of stack into m32; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x8f, od_e0, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  8F /0            POP r/m64      Valid     N.E.       Pop top of stack into m64; increment stack
    //                                                       pointer. Cannot encode 32-bit operand size.
    defn = new InsnDefn("pop",    x86_pop,     0x02, 0x8f, od_e0, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  58+ rw           POP r16        Valid     Valid      Pop top of stack into r16; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x03, 0x58, od_rw, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  58+ rd           POP r32        N.E.      Valid      Pop top of stack into r32; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x58, od_rd, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  58+ rd           POP r64        Valid     N.E.       Pop top of stack into r64; increment stack
    //                                                       pointer. Cannot encode 32-bit operand size.
    defn = new InsnDefn("pop",    x86_pop,     0x02, 0x58, od_rd, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  1F               POP DS         Invalid   Valid      Pop top of stack into DS; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x1f, od_none, od_DS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  07               POP ES         Invalid   Valid      Pop top of stack into ES; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x07, od_none, od_ES);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  17               POP SS         Invalid   Valid      Pop top of stack into SS; increment stack
    //                                                       pointer.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x17, od_none, od_SS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A1            POP FS         Valid     Valid      Pop top of stack into FS; increment stack
    //                                                       pointer by 16 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x03, 0x0fa1, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A1            POP FS         N.E.      Valid      Pop top of stack into FS; increment stack
    //                                                       pointer by 32 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x0fa1, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A1            POP FS         Valid     N.E.       Pop top of stack into FS; increment stack
    //                                                       pointer by 64 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x02, 0x0fa1, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A9            POP GS         Valid     Valid      Pop top of stack into GS; increment stack
    //                                                       pointer by 16 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x03, 0x0fa9, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A9            POP GS         N.E.      Valid      Pop top of stack into GS; increment stack
    //                                                       pointer by 32 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x01, 0x0fa9, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-203");
    define(defn);
    //  0F A9            POP GS         Valid     N.E.       Pop top of stack into GS; increment stack
    //                                                       pointer by 64 bits.
    defn = new InsnDefn("pop",    x86_pop,     0x02, 0x0fa9, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-210");
    define(defn);

    //--- page 4-210 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 61              POPA               Invalid      Valid           Pop DI, SI, BP, BX, DX, CX, and AX.
    defn = new InsnDefn("popa",   x86_popa,    0x01, 0x61, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-210");
    define(defn);
    // 61              POPAD              Invalid      Valid           Pop EDI, ESI, EBP, EBX, EDX, ECX, and
    //                                                                 EAX.
    defn = new InsnDefn("popad",  x86_popad,   0x01, 0x61, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-212");
    define(defn);

    //--- page 4-212 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F3 0F B8 /r                POPCNT r16, r/m16     Valid           Valid         POPCNT on r/m16
    defn = new InsnDefn("popcnt", x86_popcnt,  0x03, 0xf30fb8, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-212");
    define(defn);
    //  F3 0F B8 /r                POPCNT r32, r/m32     Valid           Valid         POPCNT on r/m32
    defn = new InsnDefn("popcnt", x86_popcnt,  0x03, 0xf30fb8, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-212");
    define(defn);
    //  F3 REX.W 0F B8 /r          POPCNT r64, r/m64     Valid           N.E.          POPCNT on r/m64
    defn = new InsnDefn("popcnt", x86_popcnt,  0x02, 0xf30fb8, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-214");
    define(defn);

    //--- page 4-214 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 9D               POPF             Valid          Valid           Pop top of stack into lower 16 bits of
    //                                                                  EFLAGS.
    defn = new InsnDefn("popf",   x86_popf,    0x03, 0x9d, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-214");
    define(defn);
    // 9D               POPFD            N.E.           Valid           Pop top of stack into EFLAGS.
    defn = new InsnDefn("popfd",  x86_popfd,   0x01, 0x9d, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-214");
    define(defn);
    // REX.W + 9D       POPFQ            Valid          N.E.            Pop top of stack and zero-extend into
    //                                                                  RFLAGS.
    defn = new InsnDefn("popfq",  x86_popfq,   0x02, 0x9d, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-218");
    define(defn);

    //--- page 4-218 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F EB /r        POR mm, mm/m64      Valid    Valid        Bitwise OR of mm/m64 and mm.
    defn = new InsnDefn("por",    x86_por,     0x03, 0x0feb, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-218");
    define(defn);
    // 66 0F EB /r     POR xmm1,           Valid    Valid        Bitwise OR of xmm2/m128 and
    //                 xmm2/m128                                 xmm1.
    defn = new InsnDefn("por",    x86_por,     0x03, 0x660feb, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-221");
    define(defn);

    //--- page 4-221 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 18 /1     PREFETCHT0 m8           Valid    Valid      Move data from m8 closer to the
    //                                                           processor using T0 hint.
    defn = new InsnDefn("prefetcht0", x86_prefetcht0, 0x03, 0x0f18, od_e1, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-221");
    define(defn);
    //  0F 18 /2     PREFETCHT1 m8           Valid    Valid      Move data from m8 closer to the
    //                                                           processor using T1 hint.
    defn = new InsnDefn("prefetcht1", x86_prefetcht1, 0x03, 0x0f18, od_e2, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-221");
    define(defn);
    //  0F 18 /3     PREFETCHT2 m8           Valid    Valid      Move data from m8 closer to the
    //                                                           processor using T2 hint.
    defn = new InsnDefn("prefetcht2", x86_prefetcht2, 0x03, 0x0f18, od_e3, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-221");
    define(defn);
    //  0F 18 /0     PREFETCHNTA m8          Valid    Valid      Move data from m8 closer to the
    //                                                           processor using NTA hint.
    defn = new InsnDefn("prefetchnta", x86_prefetchnta, 0x03, 0x0f18, od_e0, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-223");
    define(defn);

    //--- page 4-223 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F F6 /r       PSADBW mm1,        Valid     Valid      Computes the absolute differences of
    //                 mm2/m64                                 the packed unsigned byte integers
    //                                                         from mm2 /m64 and mm1; differences
    //                                                         are then summed to produce an
    //                                                         unsigned word integer result.
    defn = new InsnDefn("psadbw", x86_psadbw,  0x03, 0x0ff6, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-223");
    define(defn);
    //  66 0F F6 /r    PSADBW xmm1,       Valid     Valid      Computes the absolute differences of
    //                 xmm2/m128                               the packed unsigned byte integers
    //                                                         from xmm2 /m128 and xmm1; the 8
    //                                                         low differences and 8 high differences
    //                                                         are then summed separately to
    //                                                         produce two unsigned word integer
    //                                                         results.
    defn = new InsnDefn("psadbw", x86_psadbw,  0x03, 0x660ff6, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-227");
    define(defn);

    //--- page 4-227 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 38 00 /r                PSHUFB mm1,        Valid       Valid            Shuffle bytes in mm1
    //                             mm2/m64                                         according to contents of
    //                                                                             mm2/m64.
    defn = new InsnDefn("pshufb", x86_pshufb,  0x03, 0x0f3800, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-227");
    define(defn);
    //  66 0F 38 00 /r             PSHUFB xmm1,       Valid       Valid            Shuffle bytes in xmm1
    //                             xmm2/m128                                       according to contents of
    //                                                                             xmm2/m128.
    defn = new InsnDefn("pshufb", x86_pshufb,  0x03, 0x660f3800, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-231");
    define(defn);

    //--- page 4-231 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 70 /r ib   PSHUFD xmm1,              Valid         Valid              Shuffle the doublewords in
    //                   xmm2/m128, imm8                                            xmm2/m128 based on the
    //                                                                              encoding in imm8 and store
    //                                                                              the result in xmm1.
    defn = new InsnDefn("pshufd", x86_pshufd,  0x03, 0x660f70, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-234");
    define(defn);

    //--- page 4-234 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // F3 0F 70 /r ib   PSHUFHW xmm1, xmm2/m128   Valid     Valid        Shuffle the high words in
    //                        imm8                                       xmm2/m128 based on the
    //                                                                   encoding in imm8 and store
    //                                                                   the result in xmm1.
    defn = new InsnDefn("pshufhw", x86_pshufhw, 0x03, 0xf30f70, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-237");
    define(defn);

    //--- page 4-237 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F2 0F 70 /r ib   PSHUFLW xmm1,         Valid     Valid        Shuffle the low words in
    //                   xmm2/m128, imm8                              xmm2/m128 based on the
    //                                                                encoding in imm8 and store the
    //                                                                result in xmm1.
    defn = new InsnDefn("pshuflw", x86_pshuflw, 0x03, 0xf20f70, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-240");
    define(defn);

    //--- page 4-240 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 70 /r ib     PSHUFW mm1,          Valid     Valid      Shuffle the words in mm2/m64
    //                 mm2/m64, imm8                             based on the encoding in imm8 and
    //                                                           store the result in mm1.
    defn = new InsnDefn("pshufw", x86_pshufw,  0x03, 0x0f70, od_modrm|od_ib, od_mm, od_mm_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);

    //--- page 4-242 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 38 08 /r     PSIGNB mm1,    Valid    Valid       Negate/zero/preserve packed byte
    //                 mm2/m64                             integers in mm1 depending on the
    //                                                     corresponding sign in mm2/m64
    defn = new InsnDefn("psignb", x86_psignb,  0x03, 0x0f3808, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);
    // 66 0F 38 08 /r PSIGNB xmm1, Valid       Valid       Negate/zero/preserve packed byte
    //                xmm2/m128                            integers in xmm1 depending on the
    //                                                     corresponding sign in xmm2/m128.
    defn = new InsnDefn("psignb", x86_psignb,  0x03, 0x660f3808, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);
    // 0F 38 09 /r     PSIGNW mm1,    Valid    Valid       Negate/zero/preserve packed word
    //                 mm2/m64                             integers in mm1 depending on the
    //                                                     corresponding sign in mm2/m128.
    defn = new InsnDefn("psignw", x86_psignw,  0x03, 0x0f3809, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);
    // 66 0F 38 09 /r PSIGNW xmm1, Valid       Valid       Negate/zero/preserve packed word
    //                xmm2/m128                            integers in xmm1 depending on the
    //                                                     corresponding sign in xmm2/m128.
    defn = new InsnDefn("psignw", x86_psignw,  0x03, 0x660f3809, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);
    // 0F 38 0A /r     PSIGND mm1,    Valid    Valid       Negate/zero/preserve packed
    //                 mm2/m64                             doubleword integers in mm1
    //                                                     depending on the corresponding sign
    //                                                     in mm2/m128.
    defn = new InsnDefn("psignd", x86_psignd,  0x03, 0x0f380a, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-242");
    define(defn);
    // 66 0F 38 0A /r PSIGND xmm1, Valid       Valid       Negate/zero/preserve packed
    //                xmm2/m128                            doubleword integers in xmm1
    //                                                     depending on the corresponding sign
    //                                                     in xmm2/m128.
    defn = new InsnDefn("psignd", x86_psignd,  0x03, 0x660f380a, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-247");
    define(defn);

    //--- page 4-247 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 73 /7 ib     PSLLDQ xmm1,        Valid     Valid      Shift xmm1 left by imm8 bytes
    //                     imm8                                     while shifting in 0s.
    defn = new InsnDefn("pslldq", x86_pslldq,  0x03, 0x660f73, od_e7|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);

    //--- page 4-249 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F F1 /r          PSLLW mm, mm/m64 Valid           Valid       Shift words in mm left mm/m64
    //                                                                 while shifting in 0s.
    defn = new InsnDefn("psllw",  x86_psllw,   0x03, 0x0ff1, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F F1 /r       PSLLW xmm1,             Valid    Valid       Shift words in xmm1 left by
    //                    xmm2/m128                                    xmm2/m128 while shifting in 0s.
    defn = new InsnDefn("psllw",  x86_psllw,   0x03, 0x660ff1, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  0F 71 /6 ib       PSLLW xmm1, imm8        Valid    Valid       Shift words in mm left by imm8
    //                                                                 while shifting in 0s.
    defn = new InsnDefn("psllw",  x86_psllw,   0x03, 0x0f71, od_e6|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F 71 /6 ib    PSLLW xmm1, imm8        Valid    Valid       Shift words in xmm1 left by
    //                                                                 imm8 while shifting in 0s.
    defn = new InsnDefn("psllw",  x86_psllw,   0x03, 0x660f71, od_e6|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  0F F2 /r          PSLLD mm, mm/m64        Valid    Valid       Shift doublewords in mm left by
    //                                                                 mm/m64 while shifting in 0s.
    defn = new InsnDefn("pslld",  x86_pslld,   0x03, 0x0ff2, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F F2 /r       PSLLD xmm1,             Valid    Valid       Shift doublewords in xmm1 left
    //                    xmm2/m128                                    by xmm2/m128 while shifting in
    //                                                                 0s.
    defn = new InsnDefn("pslld",  x86_pslld,   0x03, 0x660ff2, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  0F 72 /6 ib       PSLLD mm, imm8          Valid    Valid       Shift doublewords in mm left by
    //                                                                 imm8 while shifting in 0s.
    defn = new InsnDefn("pslld",  x86_pslld,   0x03, 0x0f72, od_e6|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F 72 /6 ib    PSLLD xmm1, imm8        Valid    Valid       Shift doublewords in xmm1 left
    //                                                                 by imm8 while shifting in 0s.
    defn = new InsnDefn("pslld",  x86_pslld,   0x03, 0x660f72, od_e6|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  0F F3 /r          PSLLQ mm, mm/m64        Valid    Valid       Shift quadword in mm left by
    //                                                                 mm/m64 while shifting in 0s.
    defn = new InsnDefn("psllq",  x86_psllq,   0x03, 0x0ff3, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F F3 /r       PSLLQ xmm1,             Valid    Valid       Shift quadwords in xmm1 left by
    //                    xmm2/m128                                    xmm2/m128 while shifting in 0s.
    defn = new InsnDefn("psllq",  x86_psllq,   0x03, 0x660ff3, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  0F 73 /6 ib       PSLLQ mm, imm8          Valid    Valid       Shift quadword in mm left by
    //                                                                 imm8 while shifting in 0s.
    defn = new InsnDefn("psllq",  x86_psllq,   0x03, 0x0f73, od_e6|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-249");
    define(defn);
    //  66 0F 73 /6 ib    PSLLQ xmm1, imm8        Valid    Valid       Shift quadwords in xmm1 left by
    //                                                                 imm8 while shifting in 0s.
    defn = new InsnDefn("psllq",  x86_psllq,   0x03, 0x660f73, od_e6|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);

    //--- page 4-254 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F E1 /r         PSRAW mm,        Valid    Valid         Shift words in mm right by
    //                  mm/m64                                  mm/m64 while shifting in sign
    //                                                          bits.
    defn = new InsnDefn("psraw",  x86_psraw,   0x03, 0x0fe1, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 66 0F E1 /r      PSRAW xmm1,      Valid    Valid         Shift words in xmm1 right by
    //                  xmm2/m128                               xmm2/m128 while shifting in sign
    //                                                          bits.
    defn = new InsnDefn("psraw",  x86_psraw,   0x03, 0x660fe1, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 0F 71 /4 ib      PSRAW mm, imm8 Valid      Valid         Shift words in mm right by imm8
    //                                                          while shifting in sign bits
    defn = new InsnDefn("psraw",  x86_psraw,   0x03, 0x0f71, od_e4|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 66 0F 71 /4 ib   PSRAW xmm1,      Valid    Valid         Shift words in xmm1 right by
    //                  imm8                                    imm8 while shifting in sign bits
    defn = new InsnDefn("psraw",  x86_psraw,   0x03, 0x660f71, od_e4|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 0F E2 /r         PSRAD mm,        Valid    Valid         Shift doublewords in mm right by
    //                  mm/m64                                  mm/m64 while shifting in sign
    //                                                          bits.
    defn = new InsnDefn("psrad",  x86_psrad,   0x03, 0x0fe2, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 66 0F E2 /r      PSRAD xmm1,      Valid    Valid         Shift doubleword in xmm1 right
    //                  xmm2/m128                               by xmm2 /m128 while shifting in
    //                                                          sign bits.
    defn = new InsnDefn("psrad",  x86_psrad,   0x03, 0x660fe2, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 0F 72 /4 ib      PSRAD mm, imm8 Valid      Valid         Shift doublewords in mm right by
    //                                                          imm8 while shifting in sign bits.
    defn = new InsnDefn("psrad",  x86_psrad,   0x03, 0x0f72, od_e4|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-254");
    define(defn);
    // 66 0F 72 /4 ib   PSRAD xmm1,      Valid    Valid         Shift doublewords in xmm1 right
    //                  imm8                                    by imm8 while shifting in sign bits.
    defn = new InsnDefn("psrad",  x86_psrad,   0x03, 0x660f72, od_e4|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-259");
    define(defn);

    //--- page 4-259 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 73 /3 ib    PSRLDQ xmm1,      Valid    Valid        Shift xmm1 right by imm8 while
    //                    imm8                                    shifting in 0s.
    defn = new InsnDefn("psrldq", x86_psrldq,  0x03, 0x660f73, od_e3|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);

    //--- page 4-261 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F D1 /r        PSRLW mm,          Valid       Valid      Shift words in mm right by amount
    //                  mm/m64                                    specified in mm/m64 while shifting in
    //                                                            0s.
    defn = new InsnDefn("psrlw",  x86_psrlw,   0x03, 0x0fd1, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F D1 /r     PSRLW xmm1,        Valid       Valid      Shift words in xmm1 right by amount
    //                  xmm2/m128                                 specified in xmm2/m128 while
    //                                                            shifting in 0s.
    defn = new InsnDefn("psrlw",  x86_psrlw,   0x03, 0x660fd1, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  0F 71 /2 ib     PSRLW mm,          Valid       Valid      Shift words in mm right by imm8 while
    //                  imm8                                      shifting in 0s.
    defn = new InsnDefn("psrlw",  x86_psrlw,   0x03, 0x0f71, od_e2|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F 71 /2 ib PSRLW xmm1,         Valid       Valid      Shift words in xmm1 right by imm8
    //                 imm8                                       while shifting in 0s.
    defn = new InsnDefn("psrlw",  x86_psrlw,   0x03, 0x660f71, od_e2|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  0F D2 /r        PSRLD mm,          Valid       Valid      Shift doublewords in mm right by
    //                  mm/m64                                    amount specified in mm/m64 while
    //                                                            shifting in 0s.
    defn = new InsnDefn("psrld",  x86_psrld,   0x03, 0x0fd2, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F D2 /r     PSRLD xmm1,        Valid       Valid      Shift doublewords in xmm1 right by
    //                  xmm2/m128                                 amount specified in xmm2 /m128
    //                                                            while shifting in 0s.
    defn = new InsnDefn("psrld",  x86_psrld,   0x03, 0x660fd2, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  0F 72 /2 ib     PSRLD mm,          Valid       Valid      Shift doublewords in mm right by
    //                  imm8                                      imm8 while shifting in 0s.
    defn = new InsnDefn("psrld",  x86_psrld,   0x03, 0x0f72, od_e2|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F 72 /2 ib PSRLD xmm1,         Valid       Valid      Shift doublewords in xmm1 right by
    //                 imm8                                       imm8 while shifting in 0s.
    defn = new InsnDefn("psrld",  x86_psrld,   0x03, 0x660f72, od_e2|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  0F D3 /r        PSRLQ mm,          Valid       Valid      Shift mm right by amount specified in
    //                  mm/m64                                    mm/m64 while shifting in 0s.
    defn = new InsnDefn("psrlq",  x86_psrlq,   0x03, 0x0fd3, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F D3 /r     PSRLQ xmm1,        Valid       Valid      Shift quadwords in xmm1 right by
    //                  xmm2/m128                                 amount specified in xmm2/m128
    //                                                            while shifting in 0s.
    defn = new InsnDefn("psrlq",  x86_psrlq,   0x03, 0x660fd3, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  0F 73 /2 ib     PSRLQ mm,          Valid       Valid      Shift mm right by imm8 while shifting
    //                  imm8                                      in 0s.
    defn = new InsnDefn("psrlq",  x86_psrlq,   0x03, 0x0f73, od_e2|od_ib, od_mm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-261");
    define(defn);
    //  66 0F 73 /2 ib PSRLQ xmm1,         Valid       Valid      Shift quadwords in xmm1 right by
    //                 imm8                                       imm8 while shifting in 0s.
    defn = new InsnDefn("psrlq",  x86_psrlq,   0x03, 0x660f73, od_e2|od_ib, od_xmm, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);

    //--- page 4-266 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F F8 /r        PSUBB mm,        Valid    Valid       Subtract packed byte integers in
    //                 mm/m64                                mm/m64 from packed byte integers in
    //                                                       mm.
    defn = new InsnDefn("psubb",  x86_psubb,   0x03, 0x0ff8, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);
    // 66 0F F8 /r     PSUBB xmm1,      Valid    Valid       Subtract packed byte integers in
    //                 xmm2/m128                             xmm2/m128 from packed byte
    //                                                       integers in xmm1.
    defn = new InsnDefn("psubb",  x86_psubb,   0x03, 0x660ff8, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);
    // 0F F9 /r        PSUBW mm,        Valid    Valid       Subtract packed word integers in
    //                 mm/m64                                mm/m64 from packed word integers in
    //                                                       mm.
    defn = new InsnDefn("psubw",  x86_psubw,   0x03, 0x0ff9, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);
    // 66 0F F9 /r     PSUBW xmm1,      Valid    Valid       Subtract packed word integers in
    //                 xmm2/m128                             xmm2/m128 from packed word
    //                                                       integers in xmm1.
    defn = new InsnDefn("psubw",  x86_psubw,   0x03, 0x660ff9, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);
    // 0F FA /r        PSUBD mm,        Valid    Valid       Subtract packed doubleword integers
    //                 mm/m64                                in mm/m64 from packed doubleword
    //                                                       integers in mm.
    defn = new InsnDefn("psubd",  x86_psubd,   0x03, 0x0ffa, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-266");
    define(defn);
    // 66 0F FA /r     PSUBD xmm1,      Valid    Valid       Subtract packed doubleword integers
    //                 xmm2/m128                             in xmm2/mem128 from packed
    //                                                       doubleword integers in xmm1.
    defn = new InsnDefn("psubd",  x86_psubd,   0x03, 0x660ffa, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-270");
    define(defn);

    //--- page 4-270 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F FB /r        PSUBQ mm1, mm2/m64        Valid    Valid         Subtract quadword integer
    //                                                                  in mm1 from mm2 /m64.
    defn = new InsnDefn("psubq",  x86_psubq,   0x03, 0x0ffb, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-270");
    define(defn);
    // 66 0F FB /r     PSUBQ xmm1, xmm2/m128 Valid        Valid         Subtract packed quadword
    //                                                                  integers in xmm1 from
    //                                                                  xmm2 /m128.
    defn = new InsnDefn("psubq",  x86_psubq,   0x03, 0x660ffb, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-273");
    define(defn);

    //--- page 4-273 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F E8 /r       PSUBSB mm,           Valid       Valid          Subtract signed packed bytes in
    //                 mm/m64                                          mm/m64 from signed packed bytes
    //                                                                 in mm and saturate results.
    defn = new InsnDefn("psubsb", x86_psubsb,  0x03, 0x0fe8, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-273");
    define(defn);
    //  66 0F E8 /r    PSUBSB xmm1,         Valid       Valid          Subtract packed signed byte
    //                 xmm2/m128                                       integers in xmm2/m128 from
    //                                                                 packed signed byte integers in
    //                                                                 xmm1 and saturate results.
    defn = new InsnDefn("psubsb", x86_psubsb,  0x03, 0x660fe8, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-273");
    define(defn);
    //  0F E9 /r       PSUBSW mm,           Valid       Valid          Subtract signed packed words in
    //                 mm/m64                                          mm/m64 from signed packed words
    //                                                                 in mm and saturate results.
    defn = new InsnDefn("psubsw", x86_psubsw,  0x03, 0x0fe9, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-273");
    define(defn);
    //  66 0F E9 /r    PSUBSW xmm1,         Valid       Valid          Subtract packed signed word
    //                 xmm2/m128                                       integers in xmm2/m128 from
    //                                                                 packed signed word integers in
    //                                                                 xmm1 and saturate results.
    defn = new InsnDefn("psubsw", x86_psubsw,  0x03, 0x660fe9, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-277");
    define(defn);

    //--- page 4-277 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F D8 /r        PSUBUSB mm,          Valid     Valid         Subtract unsigned packed bytes in
    //                  mm/m64                                       mm/m64 from unsigned packed
    //                                                               bytes in mm and saturate result.
    defn = new InsnDefn("psubusb", x86_psubusb, 0x03, 0x0fd8, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-277");
    define(defn);
    //  66 0F D8 /r     PSUBUSB xmm1,        Valid     Valid         Subtract packed unsigned byte
    //                  xmm2/m128                                    integers in xmm2/m128 from packed
    //                                                               unsigned byte integers in xmm1 and
    //                                                               saturate result.
    defn = new InsnDefn("psubusb", x86_psubusb, 0x03, 0x660fd8, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-277");
    define(defn);
    //  0F D9 /r        PSUBUSW mm,          Valid     Valid         Subtract unsigned packed words in
    //                  mm/m64                                       mm/m64 from unsigned packed
    //                                                               words in mm and saturate result.
    defn = new InsnDefn("psubusw", x86_psubusw, 0x03, 0x0fd9, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-277");
    define(defn);
    //  66 0F D9 /r     PSUBUSW xmm1,        Valid     Valid         Subtract packed unsigned word
    //                  xmm2/m128                                    integers in xmm2/m128 from packed
    //                                                               unsigned word integers in xmm1 and
    //                                                               saturate result.
    defn = new InsnDefn("psubusw", x86_psubusw, 0x03, 0x660fd9, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-281");
    define(defn);

    //--- page 4-281 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 38 17 /r PTEST xmm1,         Valid    Valid         Set ZF if xmm2/m128 AND xmm1
    //                 xmm2/m128                                  result is all 0s. Set CF if xmm2/m128
    //                                                            AND NOT xmm1 result is all 0s.
    defn = new InsnDefn("ptest",  x86_ptest,   0x03, 0x660f3817, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);

    //--- page 4-284 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 68 /r        PUNPCKHBW mm,        Valid     Valid       Unpack and interleave high-order
    //                 mm/m64                                     bytes from mm and mm/m64
    //                                                            into mm.
    defn = new InsnDefn("punpckhbw", x86_punpckhbw, 0x03, 0x0f68, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 66 0F 68 /r     PUNPCKHBW xmm1,      Valid     Valid       Unpack and interleave high-order
    //                 xmm2/m128                                  bytes from xmm1 and
    //                                                            xmm2/m128 into xmm1.
    defn = new InsnDefn("punpckhbw", x86_punpckhbw, 0x03, 0x660f68, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 0F 69 /r        PUNPCKHWD mm,        Valid     Valid       Unpack and interleave high-order
    //                 mm/m64                                     words from mm and mm/m64
    //                                                            into mm.
    defn = new InsnDefn("punpckhwd", x86_punpckhwd, 0x03, 0x0f69, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 66 0F 69 /r     PUNPCKHWD xmm1,      Valid     Valid       Unpack and interleave high-order
    //                 xmm2/m128                                  words from xmm1 and
    //                                                            xmm2/m128 into xmm1.
    defn = new InsnDefn("punpckhwd", x86_punpckhwd, 0x03, 0x660f69, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 0F 6A /r        PUNPCKHDQ mm,        Valid     Valid       Unpack and interleave high-order
    //                 mm/m64                                     doublewords from mm and
    //                                                            mm/m64 into mm.
    defn = new InsnDefn("punpckhdq", x86_punpckhdq, 0x03, 0x0f6a, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 66 0F 6A /r     PUNPCKHDQ xmm1,      Valid     Valid       Unpack and interleave high-order
    //                 xmm2/m128                                  doublewords from xmm1 and
    //                                                            xmm2/m128 into xmm1.
    defn = new InsnDefn("punpckhdq", x86_punpckhdq, 0x03, 0x660f6a, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-284");
    define(defn);
    // 66 0F 6D /r     PUNPCKHQDQ xmm1,     Valid     Valid       Unpack and interleave high-order
    //                 xmm2/m128                                  quadwords from xmm1 and
    //                                                            xmm2/m128 into xmm1.
    defn = new InsnDefn("punpckhqdq", x86_punpckhqdq, 0x03, 0x660f6d, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);

    //--- page 4-290 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 60 /r        PUNPCKLBW mm,          Valid    Valid       Interleave low-order bytes from
    //                 mm/m32                                      mm and mm/m32 into mm.
    defn = new InsnDefn("punpcklbw", x86_punpcklbw, 0x03, 0x0f60, od_modrm, od_mm, od_mm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 66 0F 60 /r     PUNPCKLBW xmm1,        Valid    Valid       Interleave low-order bytes from
    //                 xmm2/m128                                   xmm1 and xmm2/m128 into
    //                                                             xmm1.
    defn = new InsnDefn("punpcklbw", x86_punpcklbw, 0x03, 0x660f60, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 0F 61 /r        PUNPCKLWD mm,          Valid    Valid       Interleave low-order words from
    //                 mm/m32                                      mm and mm/m32 into mm.
    defn = new InsnDefn("punpcklwd", x86_punpcklwd, 0x03, 0x0f61, od_modrm, od_mm, od_mm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 66 0F 61 /r     PUNPCKLWD xmm1,        Valid    Valid       Interleave low-order words from
    //                 xmm2/m128                                   xmm1 and xmm2/m128 into
    //                                                             xmm1.
    defn = new InsnDefn("punpcklwd", x86_punpcklwd, 0x03, 0x660f61, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 0F 62 /r        PUNPCKLDQ mm,          Valid    Valid       Interleave low-order doublewords
    //                 mm/m32                                      from mm and mm/m32 into mm.
    defn = new InsnDefn("punpckldq", x86_punpckldq, 0x03, 0x0f62, od_modrm, od_mm, od_mm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 66 0F 62 /r     PUNPCKLDQ xmm1,        Valid    Valid       Interleave low-order doublewords
    //                 xmm2/m128                                   from xmm1 and xmm2/m128 into
    //                                                             xmm1.
    defn = new InsnDefn("punpckldq", x86_punpckldq, 0x03, 0x660f62, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-290");
    define(defn);
    // 66 0F 6C /r     PUNPCKLQDQ xmm1,       Valid    Valid       Interleave low-order quadword
    //                 xmm2/m128                                   from xmm1 and xmm2/m128 into
    //                                                             xmm1 register.
    defn = new InsnDefn("punpcklqdq", x86_punpcklqdq, 0x03, 0x660f6c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);

    //--- page 4-295 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  FF /6          PUSH r/m16        Valid       Valid      Push r/m16.
    defn = new InsnDefn("push",   x86_push,    0x03, 0xff, od_e6, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  FF /6          PUSH r/m32        N.E.        Valid      Push r/m32.
    defn = new InsnDefn("push",   x86_push,    0x01, 0xff, od_e6, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  FF /6          PUSH r/m64        Valid       N.E.       Push r/m64. Default operand size 64-
    //                                                          bits.
    defn = new InsnDefn("push",   x86_push,    0x02, 0xff, od_e6, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  50+rw          PUSH r16          Valid       Valid      Push r16.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x50, od_rw, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  50+rd          PUSH r32          N.E.        Valid      Push r32.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x50, od_rd, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  50+rd          PUSH r64          Valid       N.E.       Push r64. Default operand size
    //                                                          64-bits.
    defn = new InsnDefn("push",   x86_push,    0x02, 0x50, od_rd, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  6A             PUSH imm8         Valid       Valid      Push sign-extended imm8. Stack
    //                                                          pointer is incremented by the size of
    //                                                          stack pointer.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x6a, od_ib, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  68             PUSH imm16        Valid       Valid      Push sign-extended imm16. Stack
    //                                                          pointer is incremented by the size of
    //                                                          stack pointer.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x68, od_iw, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  68             PUSH imm32        Valid       Valid      Push sign-extended imm32. Stack
    //                                                          pointer is incremented by the size of
    //                                                          stack pointer.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x68, od_id, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0E             PUSH CS           Invalid     Valid      Push CS.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x0e, od_none, od_CS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  16             PUSH SS           Invalid     Valid      Push SS.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x16, od_none, od_SS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  1E             PUSH DS           Invalid     Valid      Push DS.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x1e, od_none, od_DS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  06             PUSH ES           Invalid     Valid      Push ES.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x06, od_none, od_ES);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0F A0          PUSH FS           Valid       Valid      Push FS and decrement stack pointer
    //                                                          by 16 bits.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x0fa0, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0F A0          PUSH FS           N.E.        Valid      Push FS and decrement stack pointer
    //                                                          by 32 bits.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x0fa0, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0F A0          PUSH FS           Valid       N.E.       Push FS. Default operand size 64-bits.
    //                                                          (66H override causes 16-bit
    //                                                          operation).
    defn = new InsnDefn("push",   x86_push,    0x02, 0x0fa0, od_none, od_FS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0F A8          PUSH GS           Valid       Valid      Push GS and decrement stack pointer
    //                                                          by 16 bits.
    defn = new InsnDefn("push",   x86_push,    0x03, 0x0fa8, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-295");
    define(defn);
    //  0F A8          PUSH GS           N.E.        Valid      Push GS and decrement stack pointer
    //                                                          by 32 bits.
    defn = new InsnDefn("push",   x86_push,    0x01, 0x0fa8, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-296");
    define(defn);
    // 0F A8           PUSH GS          Valid      N.E.           Push GS, default operand size 64-bits.
    //                                                            (66H override causes 16-bit
    //                                                            operation).
    defn = new InsnDefn("push",   x86_push,    0x02, 0x0fa8, od_none, od_GS);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-300");
    define(defn);

    //--- page 4-300 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  60             PUSHA         Invalid   Valid         Push AX, CX, DX, BX, original SP, BP, SI, and
    //                                                       DI.
    defn = new InsnDefn("pusha",  x86_pusha,   0x01, 0x60, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-300");
    define(defn);
    //  60             PUSHAD        Invalid   Valid         Push EAX, ECX, EDX, EBX, original ESP, EBP,
    //                                                       ESI, and EDI.
    defn = new InsnDefn("pushad", x86_pushad,  0x01, 0x60, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-303");
    define(defn);

    //--- page 4-303 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  9C              PUSHF             Valid      Valid      Push lower 16 bits of EFLAGS.
    defn = new InsnDefn("pushf",  x86_pushf,   0x03, 0x9c, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-303");
    define(defn);
    //  9C              PUSHFD            N.E.       Valid      Push EFLAGS.
    defn = new InsnDefn("pushfd", x86_pushfd,  0x01, 0x9c, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-303");
    define(defn);
    //  9C              PUSHFQ            Valid      N.E.       Push RFLAGS.
    defn = new InsnDefn("pushfq", x86_pushfq,  0x02, 0x9c, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-306");
    define(defn);

    //--- page 4-306 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F EF /r        PXOR mm, mm/m64             Valid     Valid        Bitwise XOR of
    //                                                                    mm/m64 and mm.
    defn = new InsnDefn("pxor",   x86_pxor,    0x03, 0x0fef, od_modrm, od_mm, od_mm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-306");
    define(defn);
    // 66 0F EF /r     PXOR xmm1, xmm2/m128        Valid    Valid         Bitwise XOR of
    //                                                                    xmm2/m128 and
    //                                                                    xmm1.
    defn = new InsnDefn("pxor",   x86_pxor,    0x03, 0x660fef, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);

    //--- page 4-309 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  D0 /2            RCL r/m8, 1     Valid    Valid      Rotate 9 bits (CF, r/m8) left once.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd0, od_e2, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX + D0 /2      RCL r/m8*, 1    Valid    N.E.       Rotate 9 bits (CF, r/m8) left once.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xd0, od_rex|od_e2, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D2 /2            RCL r/m8, CL    Valid    Valid      Rotate 9 bits (CF, r/m8) left CL times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd2, od_e2, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX + D2 /2      RCL r/m8*, CL   Valid    N.E.       Rotate 9 bits (CF, r/m8) left CL times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xd2, od_rex|od_e2, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  C0 /2 ib         RCL r/m8,       Valid    Valid      Rotate 9 bits (CF, r/m8) left imm8
    //                   imm8                                times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xc0, od_e2|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX + C0 /2 ib   RCL r/m8*,      Valid    N.E.       Rotate 9 bits (CF, r/m8) left imm8
    //                   imm8                                times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xc0, od_rex|od_e2|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D1 /2            RCL r/m16, 1    Valid    Valid      Rotate 17 bits (CF, r/m16) left once.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd1, od_e2, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D3 /2            RCL r/m16, CL   Valid    Valid      Rotate 17 bits (CF, r/m16) left CL
    //                                                       times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd3, od_e2, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  C1 /2 ib         RCL r/m16,      Valid    Valid      Rotate 17 bits (CF, r/m16) left imm8
    //                   imm8                                times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xc1, od_e2|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D1 /2            RCL r/m32, 1    Valid    Valid      Rotate 33 bits (CF, r/m32) left once.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd1, od_e2, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX.W + D1 /2    RCL r/m64, 1    Valid    N.E.       Rotate 65 bits (CF, r/m64) left once.
    //                                                       Uses a 6 bit count.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xd1, od_rexw|od_e2, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D3 /2            RCL r/m32, CL   Valid    Valid      Rotate 33 bits (CF, r/m32) left CL
    //                                                       times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xd3, od_e2, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX.W + D3 /2    RCL r/m64, CL   Valid    N.E.       Rotate 65 bits (CF, r/m64) left CL
    //                                                       times. Uses a 6 bit count.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xd3, od_rexw|od_e2, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  C1 /2 ib         RCL r/m32,      Valid    Valid      Rotate 33 bits (CF, r/m32) left imm8
    //                   imm8                                times.
    defn = new InsnDefn("rcl",    x86_rcl,     0x03, 0xc1, od_e2|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX.W + C1 /2    RCL r/m64,      Valid    N.E.       Rotate 65 bits (CF, r/m64) left imm8
    //  ib               imm8                                times. Uses a 6 bit count.
    defn = new InsnDefn("rcl",    x86_rcl,     0x02, 0xc1, od_rexw|od_e2|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D0 /3            RCR r/m8, 1     Valid    Valid      Rotate 9 bits (CF, r/m8) right once.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd0, od_e3, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX + D0 /3      RCR r/m8*, 1    Valid    N.E.       Rotate 9 bits (CF, r/m8) right once.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xd0, od_rex|od_e3, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  D2 /3            RCR r/m8, CL    Valid    Valid      Rotate 9 bits (CF, r/m8) right CL
    //                                                       times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd2, od_e3, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-309");
    define(defn);
    //  REX + D2 /3      RCR r/m8*, CL   Valid    N.E.       Rotate 9 bits (CF, r/m8) right CL
    //                                                       times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xd2, od_rex|od_e3, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // C0 /3 ib         RCR r/m8,       Valid    Valid      Rotate 9 bits (CF, r/m8) right imm8
    //                  imm8                                times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xc0, od_e3|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX + C0 /3 ib   RCR r/m8*,      Valid    N.E.       Rotate 9 bits (CF, r/m8) right imm8
    //                  imm8                                times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xc0, od_rex|od_e3|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D1 /3            RCR r/m16, 1    Valid    Valid      Rotate 17 bits (CF, r/m16) right once.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd1, od_e3, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D3 /3            RCR r/m16, CL   Valid    Valid      Rotate 17 bits (CF, r/m16) right CL
    //                                                      times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd3, od_e3, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // C1 /3 ib         RCR r/m16,      Valid    Valid      Rotate 17 bits (CF, r/m16) right imm8
    //                  imm8                                times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xc1, od_e3|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D1 /3            RCR r/m32, 1    Valid    Valid      Rotate 33 bits (CF, r/m32) right once.
    //                                                      Uses a 6 bit count.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd1, od_e3, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX.W + D1 /3    RCR r/m64, 1    Valid    N.E.       Rotate 65 bits (CF, r/m64) right once.
    //                                                      Uses a 6 bit count.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xd1, od_rexw|od_e3, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D3 /3            RCR r/m32, CL   Valid    Valid      Rotate 33 bits (CF, r/m32) right CL
    //                                                      times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xd3, od_e3, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX.W + D3 /3    RCR r/m64, CL   Valid    N.E.       Rotate 65 bits (CF, r/m64) right CL
    //                                                      times. Uses a 6 bit count.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xd3, od_rexw|od_e3, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // C1 /3 ib         RCR r/m32,      Valid    Valid      Rotate 33 bits (CF, r/m32) right imm8
    //                  imm8                                times.
    defn = new InsnDefn("rcr",    x86_rcr,     0x03, 0xc1, od_e3|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX.W + C1 /3    RCR r/m64,      Valid    N.E.       Rotate 65 bits (CF, r/m64) right imm8
    // ib               imm8                                times. Uses a 6 bit count.
    defn = new InsnDefn("rcr",    x86_rcr,     0x02, 0xc1, od_rexw|od_e3|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D0 /0            ROL r/m8, 1     Valid    Valid      Rotate 8 bits r/m8 left once.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd0, od_e0, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX + D0 /0      ROL r/m8*, 1    Valid    N.E.       Rotate 8 bits r/m8 left once
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xd0, od_rex|od_e0, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D2 /0            ROL r/m8, CL    Valid    Valid      Rotate 8 bits r/m8 left CL times.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd2, od_e0, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX + D2 /0      ROL r/m8*, CL   Valid    N.E.       Rotate 8 bits r/m8 left CL times.
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xd2, od_rex|od_e0, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // C0 /0 ib         ROL r/m8,       Valid    Valid      Rotate 8 bits r/m8 left imm8 times.
    //                  imm8
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xc0, od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // REX + C0 /0 ib   ROL r/m8*,      Valid    N.E.       Rotate 8 bits r/m8 left imm8 times.
    //                  imm8
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xc0, od_rex|od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D1 /0            ROL r/m16, 1    Valid    Valid      Rotate 16 bits r/m16 left once.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd1, od_e0, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D3 /0            ROL r/m16, CL   Valid    Valid      Rotate 16 bits r/m16 left CL times.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd3, od_e0, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // C1 /0 ib         ROL r/m16,      Valid    Valid      Rotate 16 bits r/m16 left imm8
    //                  imm8                                times.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xc1, od_e0|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-310");
    define(defn);
    // D1 /0            ROL r/m32, 1    Valid    Valid      Rotate 32 bits r/m32 left once.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd1, od_e0, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX.W + D1 /0    ROL r/m64, 1      Valid        N.E.         Rotate 64 bits r/m64 left once. Uses
    //                                                               a 6 bit count.
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xd1, od_rexw|od_e0, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D3 /0            ROL r/m32, CL     Valid        Valid        Rotate 32 bits r/m32 left CL times.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xd3, od_e0, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX.W + D3 /0    ROL r/m64, CL     Valid        N.E.         Rotate 64 bits r/m64 left CL times.
    //                                                               Uses a 6 bit count.
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xd3, od_rexw|od_e0, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  C1 /0 ib         ROL r/m32,        Valid        Valid        Rotate 32 bits r/m32 left imm8
    //                   imm8                                        times.
    defn = new InsnDefn("rol",    x86_rol,     0x03, 0xc1, od_e0|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  C1 /0 ib         ROL r/m64,        Valid        N.E.         Rotate 64 bits r/m64 left imm8
    //                   imm8                                        times. Uses a 6 bit count.
    defn = new InsnDefn("rol",    x86_rol,     0x02, 0xc1, od_e0|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D0 /1            ROR r/m8, 1       Valid        Valid        Rotate 8 bits r/m8 right once.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd0, od_e1, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX + D0 /1      ROR r/m8*, 1      Valid        N.E.         Rotate 8 bits r/m8 right once.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xd0, od_rex|od_e1, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D2 /1            ROR r/m8, CL      Valid        Valid        Rotate 8 bits r/m8 right CL times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd2, od_e1, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX + D2 /1      ROR r/m8*, CL     Valid        N.E.         Rotate 8 bits r/m8 right CL times.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xd2, od_rex|od_e1, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  C0 /1 ib         ROR r/m8,         Valid        Valid        Rotate 8 bits r/m16 right imm8
    //                   imm8                                        times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xc0, od_e1|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX + C0 /1 ib   ROR r/m8*,        Valid        N.E.         Rotate 8 bits r/m16 right imm8
    //                   imm8                                        times.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xc0, od_rex|od_e1|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D1 /1            ROR r/m16, 1      Valid        Valid        Rotate 16 bits r/m16 right once.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd1, od_e1, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D3 /1            ROR r/m16, CL     Valid        Valid        Rotate 16 bits r/m16 right CL times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd3, od_e1, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  C1 /1 ib         ROR r/m16,        Valid        Valid        Rotate 16 bits r/m16 right imm8
    //                   imm8                                        times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xc1, od_e1|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D1 /1            ROR r/m32, 1      Valid        Valid        Rotate 32 bits r/m32 right once.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd1, od_e1, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX.W + D1 /1    ROR r/m64, 1      Valid        N.E.         Rotate 64 bits r/m64 right once. Uses
    //                                                               a 6 bit count.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xd1, od_rexw|od_e1, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  D3 /1            ROR r/m32, CL     Valid        Valid        Rotate 32 bits r/m32 right CL times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xd3, od_e1, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX.W + D3 /1    ROR r/m64, CL     Valid        N.E.         Rotate 64 bits r/m64 right CL times.
    //                                                               Uses a 6 bit count.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xd3, od_rexw|od_e1, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  C1 /1 ib         ROR r/m32,        Valid        Valid        Rotate 32 bits r/m32 right imm8
    //                   imm8                                        times.
    defn = new InsnDefn("ror",    x86_ror,     0x03, 0xc1, od_e1|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-311");
    define(defn);
    //  REX.W + C1 /1    ROR r/m64,        Valid        N.E.         Rotate 64 bits r/m64 right imm8
    //  ib               imm8                                        times. Uses a 6 bit count.
    defn = new InsnDefn("ror",    x86_ror,     0x02, 0xc1, od_rexw|od_e1|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-316");
    define(defn);

    //--- page 4-316 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 53 /r        RCPPS xmm1,        Valid    Valid           Computes the approximate reciprocals
    //                 xmm2/m128                                   of the packed single-precision floating-
    //                                                             point values in xmm2/m128 and stores
    //                                                             the results in xmm1.
    defn = new InsnDefn("rcpps",  x86_rcpps,   0x03, 0x0f53, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-319");
    define(defn);

    //--- page 4-319 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F3 0F 53 RCPSS xmm1,               Valid        Valid         Computes the approximate reciprocal of
    //  /r       xmm2/m32                                             the scalar single-precision floating-point
    //                                                                value in xmm2/m32 and stores the result
    //                                                                in xmm1.
    defn = new InsnDefn("rcpss",  x86_rcpss,   0x03, 0xf30f53, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-322");
    define(defn);

    //--- page 4-322 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 32             RDMSR            Valid      Valid      Read MSR specified by ECX into
    //                                                          EDX:EAX.
    defn = new InsnDefn("rdmsr",  x86_rdmsr,   0x03, 0x0f32, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-324");
    define(defn);

    //--- page 4-324 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 33           RDPMC            Valid    Valid         Read performance-monitoring
    //                                                         counter specified by ECX into
    //                                                         EDX:EAX.
    defn = new InsnDefn("rdpmc",  x86_rdpmc,   0x03, 0x0f33, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-329");
    define(defn);

    //--- page 4-329 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 31            RDTSC             Valid       Valid              Read time-stamp counter into
    //                                                                    EDX:EAX.
    defn = new InsnDefn("rdtsc",  x86_rdtsc,   0x03, 0x0f31, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-331");
    define(defn);

    //--- page 4-331 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 01 F9          RDTSCP           Valid         Valid            Read 64-bit time-stamp counter
    //                                                                    and 32-bit IA32_TSC_AUX value
    //                                                                    into EDX:EAX and ECX.
    defn = new InsnDefn("rdtscp", x86_rdtscp,  0x03, 0x0f01f9, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);

    //--- page 4-333 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F3 6C              REP INS m8, DX       Valid      Valid        Input (E)CX bytes from port DX
    //                                                                  into ES:[(E)DI].
    defn = new InsnDefn("rep_insb", x86_rep_insb, 0x03, 0xf36c, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6C              REP INS m8, DX       Valid      N.E.         Input RCX bytes from port DX
    //                                                                  into [RDI].
    defn = new InsnDefn("rep_insb", x86_rep_insb, 0x02, 0xf36c, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6D              REP INS m16, DX      Valid      Valid        Input (E)CX words from port DX
    //                                                                  into ES:[(E)DI.]
    defn = new InsnDefn("rep_insw", x86_rep_insw, 0x03, 0xf36d, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6D              REP INS m32, DX      Valid      Valid        Input (E)CX doublewords from
    //                                                                  port DX into ES:[(E)DI].
    defn = new InsnDefn("rep_insd", x86_rep_insd, 0x03, 0xf36d, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6D              REP INS r/m32, DX    Valid      N.E.         Input RCX default size from port
    //                                                                  DX into [RDI].
    defn = new InsnDefn("rep_insd", x86_rep_insd, 0x02, 0xf36d, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 A4              REP MOVS m8, m8      Valid      Valid        Move (E)CX bytes from
    //                                                                  DS:[(E)SI] to ES:[(E)DI].
    defn = new InsnDefn("rep_movsb", x86_rep_movsb, 0x03, 0xf3a4, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 REX.W A4        REP MOVS m8, m8      Valid      N.E.         Move RCX bytes from [RSI] to
    //                                                                  [RDI].
    defn = new InsnDefn("rep_movsb", x86_rep_movsb, 0x02, 0xf3a4, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 A5              REP MOVS m16,        Valid      Valid        Move (E)CX words from
    //                     m16                                          DS:[(E)SI] to ES:[(E)DI].
    defn = new InsnDefn("rep_movsw", x86_rep_movsw, 0x03, 0xf3a5, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 A5              REP MOVS m32,        Valid      Valid        Move (E)CX doublewords from
    //                     m32                                          DS:[(E)SI] to ES:[(E)DI].
    defn = new InsnDefn("rep_movsd", x86_rep_movsd, 0x03, 0xf3a5, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 REX.W A5        REP MOVS m64,        Valid      N.E.         Move RCX quadwords from [RSI]
    //                     m64                                          to [RDI].
    defn = new InsnDefn("rep_movsq", x86_rep_movsq, 0x02, 0xf3a5, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6E              REP OUTS DX, r/m8 Valid         Valid        Output (E)CX bytes from
    //                                                                  DS:[(E)SI] to port DX.
    defn = new InsnDefn("rep_outsb", x86_rep_outsb, 0x03, 0xf36e, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 REX.W 6E        REP OUTS DX,         Valid      N.E.         Output RCX bytes from [RSI] to
    //                     r/m8*                                        port DX.
    defn = new InsnDefn("rep_outsb", x86_rep_outsb, 0x02, 0xf36e, od_rexw, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6F              REP OUTS DX,         Valid      Valid        Output (E)CX words from
    //                     r/m16                                        DS:[(E)SI] to port DX.
    defn = new InsnDefn("rep_outsw", x86_rep_outsw, 0x03, 0xf36f, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 6F              REP OUTS DX,         Valid      Valid        Output (E)CX doublewords from
    //                     r/m32                                        DS:[(E)SI] to port DX.
    defn = new InsnDefn("rep_outsd", x86_rep_outsd, 0x03, 0xf36f, od_none, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 REX.W 6F        REP OUTS DX,         Valid      N.E.         Output RCX default size from
    //                     r/m32                                        [RSI] to port DX.
    defn = new InsnDefn("rep_outsd", x86_rep_outsd, 0x02, 0xf36f, od_rexw, od_DX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 AC              REP LODS AL          Valid      Valid        Load (E)CX bytes from DS:[(E)SI]
    //                                                                  to AL.
    defn = new InsnDefn("rep_lodsb", x86_rep_lodsb, 0x03, 0xf3ac, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 REX.W AC        REP LODS AL          Valid      N.E.         Load RCX bytes from [RSI] to
    //                                                                  AL.
    defn = new InsnDefn("rep_lodsb", x86_rep_lodsb, 0x02, 0xf3ac, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-333");
    define(defn);
    //  F3 AD              REP LODS AX          Valid      Valid        Load (E)CX words from DS:[(E)SI]
    //                                                                  to AX.
    defn = new InsnDefn("rep_lodsw", x86_rep_lodsw, 0x03, 0xf3ad, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AD           REP LODS EAX      Valid     Valid         Load (E)CX doublewords from
    //                                                           DS:[(E)SI] to EAX.
    defn = new InsnDefn("rep_lodsd", x86_rep_lodsd, 0x03, 0xf3ad, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W AD     REP LODS RAX      Valid     N.E.          Load RCX quadwords from [RSI]
    //                                                           to RAX.
    defn = new InsnDefn("rep_lodsq", x86_rep_lodsq, 0x02, 0xf3ad, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AA           REP STOS m8       Valid     Valid         Fill (E)CX bytes at ES:[(E)DI] with
    //                                                           AL.
    defn = new InsnDefn("rep_stosb", x86_rep_stosb, 0x03, 0xf3aa, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W AA     REP STOS m8       Valid     N.E.          Fill RCX bytes at [RDI] with AL.
    defn = new InsnDefn("rep_stosb", x86_rep_stosb, 0x02, 0xf3aa, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AB           REP STOS m16      Valid     Valid         Fill (E)CX words at ES:[(E)DI]
    //                                                           with AX.
    defn = new InsnDefn("rep_stosw", x86_rep_stosw, 0x03, 0xf3ab, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AB           REP STOS m32      Valid     Valid         Fill (E)CX doublewords at
    //                                                           ES:[(E)DI] with EAX.
    defn = new InsnDefn("rep_stosd", x86_rep_stosd, 0x03, 0xf3ab, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W AB     REP STOS m64      Valid     N.E.          Fill RCX quadwords at [RDI] with
    //                                                           RAX.
    defn = new InsnDefn("rep_stosq", x86_rep_stosq, 0x02, 0xf3ab, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 A6           REPE CMPS m8, m8 Valid      Valid         Find nonmatching bytes in
    //                                                           ES:[(E)DI] and DS:[(E)SI].
    defn = new InsnDefn("repe_cmpsb", x86_repe_cmpsb, 0x03, 0xf3a6, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W A6     REPE CMPS m8, m8 Valid      N.E.          Find non-matching bytes in
    //                                                           [RDI] and [RSI].
    defn = new InsnDefn("repe_cmpsb", x86_repe_cmpsb, 0x02, 0xf3a6, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 A7           REPE CMPS m16,    Valid     Valid         Find nonmatching words in
    //                 m16                                       ES:[(E)DI] and DS:[(E)SI].
    defn = new InsnDefn("repe_cmpsw", x86_repe_cmpsw, 0x03, 0xf3a7, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 A7           REPE CMPS m32,    Valid     Valid         Find nonmatching doublewords
    //                 m32                                       in ES:[(E)DI] and DS:[(E)SI].
    defn = new InsnDefn("repe_cmpsd", x86_repe_cmpsd, 0x03, 0xf3a7, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W A7     REPE CMPS m64,    Valid     N.E.          Find non-matching quadwords
    //                 m64                                       in [RDI] and [RSI].
    defn = new InsnDefn("repe_cmpsq", x86_repe_cmpsq, 0x02, 0xf3a7, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AE           REPE SCAS m8      Valid     Valid         Find non-AL byte starting at
    //                                                           ES:[(E)DI].
    defn = new InsnDefn("repe_scasb", x86_repe_scasb, 0x03, 0xf3ae, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W AE     REPE SCAS m8      Valid     N.E.          Find non-AL byte starting at
    //                                                           [RDI].
    defn = new InsnDefn("repe_scasb", x86_repe_scasb, 0x02, 0xf3ae, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AF           REPE SCAS m16     Valid     Valid         Find non-AX word starting at
    //                                                           ES:[(E)DI].
    defn = new InsnDefn("repe_scasw", x86_repe_scasw, 0x03, 0xf3af, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 AF           REPE SCAS m32     Valid     Valid         Find non-EAX doubleword
    //                                                           starting at ES:[(E)DI].
    defn = new InsnDefn("repe_scasd", x86_repe_scasd, 0x03, 0xf3af, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F3 REX.W AF     REPE SCAS m64     Valid     N.E.          Find non-RAX quadword
    //                                                           starting at [RDI].
    defn = new InsnDefn("repe_scasq", x86_repe_scasq, 0x02, 0xf3af, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F2 A6           REPNE CMPS m8,    Valid     Valid         Find matching bytes in ES:[(E)DI]
    //                 m8                                        and DS:[(E)SI].
    defn = new InsnDefn("repne_cmpsb", x86_repne_cmpsb, 0x03, 0xf2a6, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-334");
    define(defn);
    // F2 REX.W A6     REPNE CMPS m8,    Valid     N.E.          Find matching bytes in [RDI] and
    //                 m8                                        [RSI].
    defn = new InsnDefn("repne_cmpsb", x86_repne_cmpsb, 0x02, 0xf2a6, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 A7              REPNE CMPS m16,       Valid      Valid          Find matching words in
    //                     m16                                             ES:[(E)DI] and DS:[(E)SI].
    defn = new InsnDefn("repne_cmpsw", x86_repne_cmpsw, 0x03, 0xf2a7, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 A7              REPNE CMPS m32,       Valid      Valid          Find matching doublewords in
    //                     m32                                             ES:[(E)DI] and DS:[(E)SI].
    defn = new InsnDefn("repne_cmpsd", x86_repne_cmpsd, 0x03, 0xf2a7, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 REX.W A7        REPNE CMPS m64,       Valid      N.E.           Find matching doublewords in
    //                     m64                                             [RDI] and [RSI].
    defn = new InsnDefn("repne_cmpsq", x86_repne_cmpsq, 0x02, 0xf2a7, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 AE              REPNE SCAS m8         Valid      Valid          Find AL, starting at ES:[(E)DI].
    defn = new InsnDefn("repne_scasb", x86_repne_scasb, 0x03, 0xf2ae, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 REX.W AE        REPNE SCAS m8         Valid      N.E.           Find AL, starting at [RDI].
    defn = new InsnDefn("repne_scasb", x86_repne_scasb, 0x02, 0xf2ae, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 AF              REPNE SCAS m16        Valid      Valid          Find AX, starting at ES:[(E)DI].
    defn = new InsnDefn("repne_scasw", x86_repne_scasw, 0x03, 0xf2af, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 AF              REPNE SCAS m32        Valid      Valid          Find EAX, starting at ES:[(E)DI].
    defn = new InsnDefn("repne_scasd", x86_repne_scasd, 0x03, 0xf2af, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-335");
    define(defn);
    //  F2 REX.W AF        REPNE SCAS m64        Valid      N.E.           Find RAX, starting at [RDI].
    defn = new InsnDefn("repne_scasq", x86_repne_scasq, 0x02, 0xf2af, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-338");
    define(defn);

    //--- page 4-338 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // C3              RET           Valid    Valid       Near return to calling procedure.
    defn = new InsnDefn("ret",    x86_ret,     0x03, 0xc3, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-338");
    define(defn);
    // CB              RET           Valid    Valid       Far return to calling procedure.
    defn = new InsnDefn("ret",    x86_retf,    0x03, 0xcb, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-338");
    define(defn);
    // C2 iw           RET imm16     Valid    Valid       Near return to calling procedure and pop
    //                                                    imm16 bytes from stack.
    defn = new InsnDefn("ret",    x86_ret,     0x03, 0xc2, od_iw, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-338");
    define(defn);
    // CA iw           RET imm16     Valid    Valid       Far return to calling procedure and pop
    //                                                    imm16 bytes from stack.
    defn = new InsnDefn("ret",    x86_retf,    0x03, 0xca, od_iw, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-350");
    define(defn);

    //--- page 4-350 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 3A        ROUNDPD xmm1,          Valid    Valid          Round packed double precision
    // 09 /r ib        xmm2/m128, imm8                                floating-point values in
    //                                                                xmm2/m128 and place the result in
    //                                                                xmm1. The rounding mode is
    //                                                                determined by imm8.
    defn = new InsnDefn("roundpd", x86_roundpd, 0x03, 0x660f3a09, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-354");
    define(defn);

    //--- page 4-354 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 3A 08     ROUNDPS xmm1,       Valid     Valid          Round packed single precision
    // /r ib           xmm2/m128, imm8                              floating-point values in
    //                                                              xmm2/m128 and place the result
    //                                                              in xmm1. The rounding mode is
    //                                                              determined by imm8.
    defn = new InsnDefn("roundps", x86_roundps, 0x03, 0x660f3a08, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-357");
    define(defn);

    //--- page 4-357 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 3A 0B      ROUNDSD xmm1, Valid              Valid        Round the low packed double
    //  /r ib            xmm2/m64, imm8                                precision floating-point value in
    //                                                                 xmm2/m64 and place the result in
    //                                                                 xmm1. The rounding mode is
    //                                                                 determined by imm8.
    defn = new InsnDefn("roundsd", x86_roundsd, 0x03, 0x660f3a0b, od_modrm|od_ib, od_xmm, od_xmm_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-360");
    define(defn);

    //--- page 4-360 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 3A 0A /r   ROUNDSS xmm1,          Valid     Valid           Round the low packed single
    // ib               xmm2/m32, imm8                                   precision floating-point value
    //                                                                   in xmm2/m32 and place the
    //                                                                   result in xmm1. The rounding
    //                                                                   mode is determined by imm8.
    defn = new InsnDefn("roundss", x86_roundss, 0x03, 0x660f3a0a, od_modrm|od_ib, od_xmm, od_xmm_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-363");
    define(defn);

    //--- page 4-363 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F AA             RSM           Invalid   Valid           Resume operation of interrupted
    //                                                            program.
    defn = new InsnDefn("rsm",    x86_rsm,     0x01, 0x0faa, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-365");
    define(defn);

    //--- page 4-365 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 52 /r      RSQRTPS xmm1,          Valid       Valid          Computes the approximate reciprocals
    //                xmm2/m128                                         of the square roots of the packed
    //                                                                  single-precision floating-point values
    //                                                                  in xmm2/m128 and stores the results
    //                                                                  in xmm1.
    defn = new InsnDefn("rsqrtps", x86_rsqrtps, 0x03, 0x0f52, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-368");
    define(defn);

    //--- page 4-368 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // F3 0F 52 /r RSQRTSS xmm1,           Valid      Valid          Computes the approximate reciprocal of
    //             xmm2/m32                                          the square root of the low single-
    //                                                               precision floating-point value in
    //                                                               xmm2/m32 and stores the results in
    //                                                               xmm1.
    defn = new InsnDefn("rsqrtss", x86_rsqrtss, 0x03, 0xf30f52, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-371");
    define(defn);

    //--- page 4-371 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  9E            SAHF            Invalid*      Valid         Loads SF, ZF, AF, PF, and CF from AH
    //                                                            into EFLAGS register.
    defn = new InsnDefn("sahf",   x86_sahf,    0x01, 0x9e, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);

    //--- page 4-373 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  D0 /4                  SAL r/m8, 1        Valid    Valid       Multiply r/m8 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd0, od_e4, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + D0 /4            SAL r/m8**, 1      Valid    N.E.        Multiply r/m8 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd0, od_rex|od_e4, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D2 /4                  SAL r/m8, CL       Valid    Valid       Multiply r/m8 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd2, od_e4, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + D2 /4            SAL r/m8**, CL     Valid    N.E.        Multiply r/m8 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd2, od_rex|od_e4, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  C0 /4 ib               SAL r/m8, imm8     Valid    Valid       Multiply r/m8 by 2, imm8
    //                                                                 times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc0, od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + C0 /4 ib         SAL r/m8**, imm8   Valid    N.E.        Multiply r/m8 by 2, imm8
    //                                                                 times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xc0, od_rex|od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D1 /4                  SAL r/m16, 1       Valid    Valid       Multiply r/m16 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd1, od_e4, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D3 /4                  SAL r/m16, CL      Valid    Valid       Multiply r/m16 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd3, od_e4, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  C1 /4 ib               SAL r/m16, imm8    Valid    Valid       Multiply r/m16 by 2, imm8
    //                                                                 times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc1, od_e4|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D1 /4                  SAL r/m32, 1       Valid    Valid       Multiply r/m32 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd1, od_e4, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX.W + D1 /4          SAL r/m64, 1       Valid    N.E.        Multiply r/m64 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd1, od_rexw|od_e4, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D3 /4                  SAL r/m32, CL      Valid    Valid       Multiply r/m32 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd3, od_e4, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX.W + D3 /4          SAL r/m64, CL      Valid    N.E.        Multiply r/m64 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd3, od_rexw|od_e4, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  C1 /4 ib               SAL r/m32, imm8    Valid    Valid       Multiply r/m32 by 2, imm8
    //                                                                 times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc1, od_e4|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX.W + C1 /4 ib       SAL r/m64, imm8    Valid    N.E.        Multiply r/m64 by 2, imm8
    //                                                                 times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xc1, od_rexw|od_e4|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D0 /7                  SAR r/m8, 1        Valid    Valid       Signed divide* r/m8 by 2,
    //                                                                 once.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd0, od_e7, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + D0 /7            SAR r/m8**, 1      Valid    N.E.        Signed divide* r/m8 by 2,
    //                                                                 once.
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xd0, od_rex|od_e7, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D2 /7                  SAR r/m8, CL       Valid    Valid       Signed divide* r/m8 by 2, CL
    //                                                                 times.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd2, od_e7, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + D2 /7            SAR r/m8**, CL     Valid    N.E.        Signed divide* r/m8 by 2, CL
    //                                                                 times.
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xd2, od_rex|od_e7, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  C0 /7 ib               SAR r/m8, imm8     Valid    Valid       Signed divide* r/m8 by 2,
    //                                                                 imm8 time.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xc0, od_e7|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  REX + C0 /7 ib         SAR r/m8**, imm8   Valid    N.E.        Signed divide* r/m8 by 2,
    //                                                                 imm8 times.
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xc0, od_rex|od_e7|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-373");
    define(defn);
    //  D1 /7                  SAR r/m16,1        Valid    Valid       Signed divide* r/m16 by 2,
    //                                                                 once.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd1, od_e7, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D3 /7              SAR r/m16, CL      Valid    Valid      Signed divide* r/m16 by 2, CL
    //                                                           times.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd3, od_e7, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // C1 /7 ib           SAR r/m16, imm8    Valid    Valid      Signed divide* r/m16 by 2,
    //                                                           imm8 times.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xc1, od_e7|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D1 /7              SAR r/m32, 1       Valid    Valid      Signed divide* r/m32 by 2,
    //                                                           once.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd1, od_e7, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + D1 /7      SAR r/m64, 1       Valid    N.E.       Signed divide* r/m64 by 2,
    //                                                           once.
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xd1, od_rexw|od_e7, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D3 /7              SAR r/m32, CL      Valid    Valid      Signed divide* r/m32 by 2, CL
    //                                                           times.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xd3, od_e7, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + D3 /7      SAR r/m64, CL      Valid    N.E.       Signed divide* r/m64 by 2, CL
    //                                                           times.
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xd3, od_rexw|od_e7, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // C1 /7 ib           SAR r/m32, imm8    Valid    Valid      Signed divide* r/m32 by 2,
    //                                                           imm8 times.
    defn = new InsnDefn("sar",    x86_sar,     0x03, 0xc1, od_e7|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + C1 /7 ib   SAR r/m64, imm8    Valid    N.E.       Signed divide* r/m64 by 2,
    //                                                           imm8 times
    defn = new InsnDefn("sar",    x86_sar,     0x02, 0xc1, od_rexw|od_e7|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D0 /4              SHL r/m8, 1        Valid    Valid      Multiply r/m8 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd0, od_e4, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX + D0 /4        SHL r/m8**, 1      Valid    N.E.       Multiply r/m8 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd0, od_rex|od_e4, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D2 /4              SHL r/m8, CL       Valid    Valid      Multiply r/m8 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd2, od_e4, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX + D2 /4        SHL r/m8**, CL     Valid    N.E.       Multiply r/m8 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd2, od_rex|od_e4, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // C0 /4 ib           SHL r/m8, imm8     Valid    Valid      Multiply r/m8 by 2, imm8
    //                                                           times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc0, od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX + C0 /4 ib     SHL r/m8**, imm8   Valid    N.E.       Multiply r/m8 by 2, imm8
    //                                                           times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xc0, od_rex|od_e4|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D1 /4              SHL r/m16,1        Valid    Valid      Multiply r/m16 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd1, od_e4, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D3 /4              SHL r/m16, CL      Valid    Valid      Multiply r/m16 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd3, od_e4, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // C1 /4 ib           SHL r/m16, imm8    Valid    Valid      Multiply r/m16 by 2, imm8
    //                                                           times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc1, od_e4|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D1 /4              SHL r/m32,1        Valid    Valid      Multiply r/m32 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd1, od_e4, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + D1 /4      SHL r/m64,1        Valid    N.E.       Multiply r/m64 by 2, once.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd1, od_rexw|od_e4, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // D3 /4              SHL r/m32, CL      Valid    Valid      Multiply r/m32 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xd3, od_e4, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + D3 /4      SHL r/m64, CL      Valid    N.E.       Multiply r/m64 by 2, CL times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xd3, od_rexw|od_e4, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // C1 /4 ib           SHL r/m32, imm8    Valid    Valid      Multiply r/m32 by 2, imm8
    //                                                           times.
    defn = new InsnDefn("shl",    x86_shl,     0x03, 0xc1, od_e4|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-374");
    define(defn);
    // REX.W + C1 /4 ib   SHL r/m64, imm8    Valid    N.E.       Multiply r/m64 by 2, imm8
    //                                                           times.
    defn = new InsnDefn("shl",    x86_shl,     0x02, 0xc1, od_rexw|od_e4|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D0 /5                  SHR r/m8,1          Valid       Valid          Unsigned divide r/m8 by 2,
    //                                                                        once.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd0, od_e5, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX + D0 /5            SHR r/m8**, 1       Valid       N.E.           Unsigned divide r/m8 by 2,
    //                                                                        once.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xd0, od_rex|od_e5, od_r_m8, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D2 /5                  SHR r/m8, CL        Valid       Valid          Unsigned divide r/m8 by 2, CL
    //                                                                        times.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd2, od_e5, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX + D2 /5            SHR r/m8**, CL      Valid       N.E.           Unsigned divide r/m8 by 2, CL
    //                                                                        times.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xd2, od_rex|od_e5, od_r_m8, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  C0 /5 ib               SHR r/m8, imm8      Valid       Valid          Unsigned divide r/m8 by 2,
    //                                                                        imm8 times.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xc0, od_e5|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX + C0 /5 ib         SHR r/m8**, imm8    Valid       N.E.           Unsigned divide r/m8 by 2,
    //                                                                        imm8 times.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xc0, od_rex|od_e5|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D1 /5                  SHR r/m16, 1        Valid       Valid          Unsigned divide r/m16 by 2,
    //                                                                        once.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd1, od_e5, od_r_m16, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D3 /5                  SHR r/m16, CL       Valid       Valid          Unsigned divide r/m16 by 2,
    //                                                                        CL times
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd3, od_e5, od_r_m16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  C1 /5 ib               SHR r/m16, imm8     Valid       Valid          Unsigned divide r/m16 by 2,
    //                                                                        imm8 times.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xc1, od_e5|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D1 /5                  SHR r/m32, 1        Valid       Valid          Unsigned divide r/m32 by 2,
    //                                                                        once.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd1, od_e5, od_r_m32, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX.W + D1 /5          SHR r/m64, 1        Valid       N.E.           Unsigned divide r/m64 by 2,
    //                                                                        once.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xd1, od_rexw|od_e5, od_r_m64, od_1);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  D3 /5                  SHR r/m32, CL       Valid       Valid          Unsigned divide r/m32 by 2,
    //                                                                        CL times.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xd3, od_e5, od_r_m32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX.W + D3 /5          SHR r/m64, CL       Valid       N.E.           Unsigned divide r/m64 by 2,
    //                                                                        CL times.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xd3, od_rexw|od_e5, od_r_m64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  C1 /5 ib               SHR r/m32, imm8     Valid       Valid          Unsigned divide r/m32 by 2,
    //                                                                        imm8 times.
    defn = new InsnDefn("shr",    x86_shr,     0x03, 0xc1, od_e5|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-375");
    define(defn);
    //  REX.W + C1 /5 ib       SHR r/m64, imm8     Valid       N.E.           Unsigned divide r/m64 by 2,
    //                                                                        imm8 times.
    defn = new InsnDefn("shr",    x86_shr,     0x02, 0xc1, od_rexw|od_e5|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);

    //--- page 4-380 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 1C ib              SBB AL, imm8      Valid    Valid          Subtract with borrow imm8
    //                                                              from AL.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1c, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 1D iw              SBB AX, imm16     Valid    Valid          Subtract with borrow imm16
    //                                                              from AX.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1d, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 1D id              SBB EAX, imm32    Valid    Valid          Subtract with borrow imm32
    //                                                              from EAX.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1d, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX.W + 1D id      SBB RAX, imm32    Valid    N.E.           Subtract with borrow sign-
    //                                                              extended imm.32 to 64-bits
    //                                                              from RAX.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x1d, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 80 /3 ib           SBB r/m8, imm8    Valid    Valid          Subtract with borrow imm8
    //                                                              from r/m8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x80, od_e3|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX + 80 /3 ib     SBB r/m8*, imm8   Valid    N.E.           Subtract with borrow imm8
    //                                                              from r/m8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x80, od_rex|od_e3|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 81 /3 iw           SBB r/m16, imm16 Valid     Valid          Subtract with borrow imm16
    //                                                              from r/m16.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x81, od_e3|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 81 /3 id           SBB r/m32, imm32 Valid     Valid          Subtract with borrow imm32
    //                                                              from r/m32.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x81, od_e3|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX.W + 81 /3 id   SBB r/m64, imm32 Valid     N.E.           Subtract with borrow sign-
    //                                                              extended imm32 to 64-bits
    //                                                              from r/m64.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x81, od_rexw|od_e3|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 83 /3 ib           SBB r/m16, imm8   Valid    Valid          Subtract with borrow sign-
    //                                                              extended imm8 from r/m16.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x83, od_e3|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 83 /3 ib           SBB r/m32, imm8   Valid    Valid          Subtract with borrow sign-
    //                                                              extended imm8 from r/m32.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x83, od_e3|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX.W + 83 /3 ib   SBB r/m64, imm8   Valid    N.E.           Subtract with borrow sign-
    //                                                              extended imm8 from r/m64.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x83, od_rexw|od_e3|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 18 /r              SBB r/m8, r8      Valid    Valid          Subtract with borrow r8
    //                                                              from r/m8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x18, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX + 18 /r        SBB r/m8*, r8     Valid    N.E.           Subtract with borrow r8
    //                                                              from r/m8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x18, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 19 /r              SBB r/m16, r16    Valid    Valid          Subtract with borrow r16
    //                                                              from r/m16.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x19, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // 19 /r              SBB r/m32, r32    Valid    Valid          Subtract with borrow r32
    //                                                              from r/m32.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x19, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-380");
    define(defn);
    // REX.W + 19 /r      SBB r/m64, r64    Valid    N.E.           Subtract with borrow r64
    //                                                              from r/m64.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x19, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-381");
    define(defn);
    //  1A /r                 SBB r8, r/m8         Valid       Valid          Subtract with borrow r/m8
    //                                                                        from r8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1a, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-381");
    define(defn);
    //  REX + 1A /r           SBB r8*, r/m8*       Valid       N.E.           Subtract with borrow r/m8
    //                                                                        from r8.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x1a, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-381");
    define(defn);
    //  1B /r                 SBB r16, r/m16       Valid       Valid          Subtract with borrow r/m16
    //                                                                        from r16.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-381");
    define(defn);
    //  1B /r                 SBB r32, r/m32       Valid       Valid          Subtract with borrow r/m32
    //                                                                        from r32.
    defn = new InsnDefn("sbb",    x86_sbb,     0x03, 0x1b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-381");
    define(defn);
    //  REX.W + 1B /r         SBB r64, r/m64       Valid       N.E.           Subtract with borrow r/m64
    //                                                                        from r64.
    defn = new InsnDefn("sbb",    x86_sbb,     0x02, 0x1b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    define(defn);

    //--- page 4-384 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // AE              SCAS m8          Valid       Valid          Compare AL with byte at ES:(E)DI or RDI,
    //                                                             then set status flags.*
    // See SCASB, SCASW, SCASD, or SCASQ instead.
    // defn = new InsnDefn("scas",   x86_scas,    0x03, 0xae, od_none, od_m8);
    // defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    // define(defn);
    // AF              SCAS m16         Valid       Valid          Compare AX with word at ES:(E)DI or
    //                                                             RDI, then set status flags.*
    // See SCASB, SCASW, SCASD, or SCASQ instead.
    // defn = new InsnDefn("scas",   x86_scas,    0x03, 0xaf, od_none, od_m16);
    // defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    // define(defn);
    // AF              SCAS m32         Valid       Valid          Compare EAX with doubleword at
    //                                                             ES(E)DI or RDI then set status flags.*
    // See SCASB, SCASW, SCASD, or SCASQ instead.
    // defn = new InsnDefn("scas",   x86_scas,    0x03, 0xaf, od_none, od_m32);
    // defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    // define(defn);
    // REX.W + AF      SCAS m64         Valid       N.E.           Compare RAX with quadword at RDI or
    //                                                             EDI then set status flags.
    // See SCASB, SCASW, SCASD, or SCASQ instead.
    // defn = new InsnDefn("scas",   x86_scas,    0x02, 0xaf, od_rexw, od_m64);
    // defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    // define(defn);
    // AE              SCASB            Valid       Valid          Compare AL with byte at ES:(E)DI or RDI
    //                                                             then set status flags.*
    defn = new InsnDefn("scasb",  x86_scasb,   0x03, 0xae, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    define(defn);
    // AF              SCASW            Valid       Valid          Compare AX with word at ES:(E)DI or RDI
    //                                                             then set status flags.*
    defn = new InsnDefn("scasw",  x86_scasw,   0x03, 0xaf, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    define(defn);
    // AF              SCASD            Valid       Valid          Compare EAX with doubleword at
    //                                                             ES:(E)DI or RDI then set status flags.*
    defn = new InsnDefn("scasd",  x86_scasd,   0x03, 0xaf, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-384");
    define(defn);
    // REX.W + AF      SCASQ            Valid       N.E.           Compare RAX with quadword at RDI or
    //                                                             EDI then set status flags.
    defn = new InsnDefn("scasq",  x86_scasq,   0x02, 0xaf, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);

    //--- page 4-389 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 97              SETA r/m8     Valid    Valid      Set byte if above (CF=0 and
    //                                                       ZF=0).
    defn = new InsnDefn("seta",   x86_seta,    0x03, 0x0f97, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 97        SETA r/m8*    Valid    N.E.       Set byte if above (CF=0 and
    //                                                       ZF=0).
    defn = new InsnDefn("seta",   x86_seta,    0x02, 0x0f97, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 93              SETAE r/m8    Valid    Valid      Set byte if above or equal (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x03, 0x0f93, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 93        SETAE r/m8*   Valid    N.E.       Set byte if above or equal (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x02, 0x0f93, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 92              SETB r/m8     Valid    Valid      Set byte if below (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x03, 0x0f92, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 92        SETB r/m8*    Valid    N.E.       Set byte if below (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x02, 0x0f92, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 96              SETBE r/m8    Valid    Valid      Set byte if below or equal (CF=1
    //                                                       or ZF=1).
    defn = new InsnDefn("setbe",  x86_setbe,   0x03, 0x0f96, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 96        SETBE r/m8*   Valid    N.E.       Set byte if below or equal (CF=1
    //                                                       or ZF=1).
    defn = new InsnDefn("setbe",  x86_setbe,   0x02, 0x0f96, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 92              SETC r/m8     Valid    Valid      Set byte if carry (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x03, 0x0f92, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 92        SETC r/m8*    Valid    N.E.       Set byte if carry (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x02, 0x0f92, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 94              SETE r/m8     Valid    Valid      Set byte if equal (ZF=1).
    defn = new InsnDefn("sete",   x86_sete,    0x03, 0x0f94, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 94        SETE r/m8*    Valid    N.E.       Set byte if equal (ZF=1).
    defn = new InsnDefn("sete",   x86_sete,    0x02, 0x0f94, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 9F              SETG r/m8     Valid    Valid      Set byte if greater (ZF=0 and
    //                                                       SF=OF).
    defn = new InsnDefn("setg",   x86_setg,    0x03, 0x0f9f, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 9F        SETG r/m8*    Valid    N.E.       Set byte if greater (ZF=0 and
    //                                                       SF=OF).
    defn = new InsnDefn("setg",   x86_setg,    0x02, 0x0f9f, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 9D              SETGE r/m8    Valid    Valid      Set byte if greater or equal
    //                                                       (SF=OF).
    defn = new InsnDefn("setge",  x86_setge,   0x03, 0x0f9d, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 9D        SETGE r/m8*   Valid    N.E.       Set byte if greater or equal
    //                                                       (SF=OF).
    defn = new InsnDefn("setge",  x86_setge,   0x02, 0x0f9d, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 9C              SETL r/m8     Valid    Valid      Set byte if less (SF OF).
    defn = new InsnDefn("setl",   x86_setl,    0x03, 0x0f9c, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 9C        SETL r/m8*    Valid    N.E.       Set byte if less (SF OF).
    defn = new InsnDefn("setl",   x86_setl,    0x02, 0x0f9c, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 9E              SETLE r/m8    Valid    Valid      Set byte if less or equal (ZF=1 or
    //                                                       SF OF).
    defn = new InsnDefn("setle",  x86_setle,   0x03, 0x0f9e, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 9E        SETLE r/m8*   Valid    N.E.       Set byte if less or equal (ZF=1 or
    //                                                       SF OF).
    defn = new InsnDefn("setle",  x86_setle,   0x02, 0x0f9e, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  0F 96              SETNA r/m8    Valid    Valid      Set byte if not above (CF=1 or
    //                                                       ZF=1).
    defn = new InsnDefn("setbe",  x86_setbe,   0x03, 0x0f96, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-389");
    define(defn);
    //  REX + 0F 96        SETNA r/m8*   Valid    N.E.       Set byte if not above (CF=1 or
    //                                                       ZF=1).
    defn = new InsnDefn("setbe",  x86_setbe,   0x02, 0x0f96, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 92           SETNAE r/m8      Valid    Valid      Set byte if not above or equal
    //                                                      (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x03, 0x0f92, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 92     SETNAE r/m8*     Valid    N.E.       Set byte if not above or equal
    //                                                      (CF=1).
    defn = new InsnDefn("setb",   x86_setb,    0x02, 0x0f92, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 93           SETNB r/m8       Valid    Valid      Set byte if not below (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x03, 0x0f93, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 93     SETNB r/m8*      Valid    N.E.       Set byte if not below (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x02, 0x0f93, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 97           SETNBE r/m8      Valid    Valid      Set byte if not below or equal
    //                                                      (CF=0 and ZF=0).
    defn = new InsnDefn("seta",   x86_seta,    0x03, 0x0f97, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 97     SETNBE r/m8*     Valid    N.E.       Set byte if not below or equal
    //                                                      (CF=0 and ZF=0).
    defn = new InsnDefn("seta",   x86_seta,    0x02, 0x0f97, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 93           SETNC r/m8       Valid    Valid      Set byte if not carry (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x03, 0x0f93, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 93     SETNC r/m8*      Valid    N.E.       Set byte if not carry (CF=0).
    defn = new InsnDefn("setae",  x86_setae,   0x02, 0x0f93, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 95           SETNE r/m8       Valid    Valid      Set byte if not equal (ZF=0).
    defn = new InsnDefn("setne",  x86_setne,   0x03, 0x0f95, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 95     SETNE r/m8*      Valid    N.E.       Set byte if not equal (ZF=0).
    defn = new InsnDefn("setne",  x86_setne,   0x02, 0x0f95, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 9E           SETNG r/m8       Valid    Valid      Set byte if not greater (ZF=1 or
    //                                                      SF OF)
    defn = new InsnDefn("setle",  x86_setle,   0x03, 0x0f9e, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 9E     SETNG r/m8*      Valid    N.E.       Set byte if not greater (ZF=1 or
    //                                                      SF OF).
    defn = new InsnDefn("setle",  x86_setle,   0x02, 0x0f9e, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 9C           SETNGE r/m8      Valid    Valid      Set byte if not greater or equal
    //                                                      (SF OF).
    defn = new InsnDefn("setl",   x86_setl,    0x03, 0x0f9c, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 9C     SETNGE r/m8*     Valid    N.E.       Set byte if not greater or equal
    //                                                      (SF OF).
    defn = new InsnDefn("setl",   x86_setl,    0x02, 0x0f9c, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 9D           SETNL r/m8       Valid    Valid      Set byte if not less (SF=OF).
    defn = new InsnDefn("setge",  x86_setge,   0x03, 0x0f9d, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 9D     SETNL r/m8*      Valid    N.E.       Set byte if not less (SF=OF).
    defn = new InsnDefn("setge",  x86_setge,   0x02, 0x0f9d, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 9F           SETNLE r/m8      Valid    Valid      Set byte if not less or equal (ZF=0
    //                                                      and SF=OF).
    defn = new InsnDefn("setg",   x86_setg,    0x03, 0x0f9f, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 9F     SETNLE r/m8*     Valid    N.E.       Set byte if not less or equal (ZF=0
    //                                                      and SF=OF).
    defn = new InsnDefn("setg",   x86_setg,    0x02, 0x0f9f, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 91           SETNO r/m8       Valid    Valid      Set byte if not overflow (OF=0).
    defn = new InsnDefn("setno",  x86_setno,   0x03, 0x0f91, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 91     SETNO r/m8*      Valid    N.E.       Set byte if not overflow (OF=0).
    defn = new InsnDefn("setno",  x86_setno,   0x02, 0x0f91, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 9B           SETNP r/m8       Valid    Valid      Set byte if not parity (PF=0).
    defn = new InsnDefn("setpo",  x86_setpo,   0x03, 0x0f9b, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 9B     SETNP r/m8*      Valid    N.E.       Set byte if not parity (PF=0).
    defn = new InsnDefn("setpo",  x86_setpo,   0x02, 0x0f9b, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 99           SETNS r/m8       Valid    Valid      Set byte if not sign (SF=0).
    defn = new InsnDefn("setns",  x86_setns,   0x03, 0x0f99, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // REX + 0F 99     SETNS r/m8*      Valid    N.E.       Set byte if not sign (SF=0).
    defn = new InsnDefn("setns",  x86_setns,   0x02, 0x0f99, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-390");
    define(defn);
    // 0F 95           SETNZ r/m8       Valid    Valid      Set byte if not zero (ZF=0).
    defn = new InsnDefn("setne",  x86_setne,   0x03, 0x0f95, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 95        SETNZ r/m8*        Valid       N.E.           Set byte if not zero (ZF=0).
    defn = new InsnDefn("setne",  x86_setne,   0x02, 0x0f95, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 90              SETO r/m8          Valid       Valid          Set byte if overflow (OF=1)
    defn = new InsnDefn("seto",   x86_seto,    0x03, 0x0f90, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 90        SETO r/m8*         Valid       N.E.           Set byte if overflow (OF=1).
    defn = new InsnDefn("seto",   x86_seto,    0x02, 0x0f90, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 9A              SETP r/m8          Valid       Valid          Set byte if parity (PF=1).
    defn = new InsnDefn("setpe",  x86_setpe,   0x03, 0x0f9a, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 9A        SETP r/m8*         Valid       N.E.           Set byte if parity (PF=1).
    defn = new InsnDefn("setpe",  x86_setpe,   0x02, 0x0f9a, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 9A              SETPE r/m8         Valid       Valid          Set byte if parity even (PF=1).
    defn = new InsnDefn("setpe",  x86_setpe,   0x03, 0x0f9a, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 9A        SETPE r/m8*        Valid       N.E.           Set byte if parity even (PF=1).
    defn = new InsnDefn("setpe",  x86_setpe,   0x02, 0x0f9a, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 9B              SETPO r/m8         Valid       Valid          Set byte if parity odd (PF=0).
    defn = new InsnDefn("setpo",  x86_setpo,   0x03, 0x0f9b, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 9B        SETPO r/m8*        Valid       N.E.           Set byte if parity odd (PF=0).
    defn = new InsnDefn("setpo",  x86_setpo,   0x02, 0x0f9b, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 98              SETS r/m8          Valid       Valid          Set byte if sign (SF=1).
    defn = new InsnDefn("sets",   x86_sets,    0x03, 0x0f98, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 98        SETS r/m8*         Valid       N.E.           Set byte if sign (SF=1).
    defn = new InsnDefn("sets",   x86_sets,    0x02, 0x0f98, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  0F 94              SETZ r/m8          Valid       Valid          Set byte if zero (ZF=1).
    defn = new InsnDefn("sete",   x86_sete,    0x03, 0x0f94, od_none, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-391");
    define(defn);
    //  REX + 0F 94        SETZ r/m8*         Valid       N.E.           Set byte if zero (ZF=1).
    defn = new InsnDefn("sete",   x86_sete,    0x02, 0x0f94, od_rex, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-394");
    define(defn);

    //--- page 4-394 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F AE /7    SFENCE         Valid        Valid         Serializes store operations.
    defn = new InsnDefn("sfence", x86_sfence,  0x03, 0x0fae, od_e7);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-395");
    define(defn);

    //--- page 4-395 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 01 /0           SGDT m                Valid     Valid        Store GDTR to m.
    defn = new InsnDefn("sgdt",   x86_sgdt,    0x03, 0x0f01, od_e0, od_m);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);

    //--- page 4-398 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F A4             SHLD r/m16, r16,     Valid         Valid         Shift r/m16 to left imm8
    //                   imm8                                             places while shifting bits
    //                                                                    from r16 in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x03, 0x0fa4, od_ib, od_r_m16, od_r16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);
    // 0F A5             SHLD r/m16, r16, CL Valid          Valid         Shift r/m16 to left CL places
    //                                                                    while shifting bits from r16
    //                                                                    in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x03, 0x0fa5, od_none, od_r_m16, od_r16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);
    // 0F A4             SHLD r/m32, r32,     Valid         Valid         Shift r/m32 to left imm8
    //                   imm8                                             places while shifting bits
    //                                                                    from r32 in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x03, 0x0fa4, od_ib, od_r_m32, od_r32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);
    // REX.W + 0F A4     SHLD r/m64, r64,     Valid         N.E.          Shift r/m64 to left imm8
    //                   imm8                                             places while shifting bits
    //                                                                    from r64 in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x02, 0x0fa4, od_rexw|od_ib, od_r_m64, od_r64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);
    // 0F A5             SHLD r/m32, r32, CL Valid          Valid         Shift r/m32 to left CL places
    //                                                                    while shifting bits from r32
    //                                                                    in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x03, 0x0fa5, od_none, od_r_m32, od_r32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-398");
    define(defn);
    // REX.W + 0F A5     SHLD r/m64, r64, CL Valid          N.E.          Shift r/m64 to left CL places
    //                                                                    while shifting bits from r64
    //                                                                    in from the right.
    defn = new InsnDefn("shld",   x86_shld,    0x02, 0x0fa5, od_rexw, od_r_m64, od_r64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);

    //--- page 4-401 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F AC               SHRD r/m16,    Valid        Valid        Shift r/m16 to right imm8 places
    //                      r16, imm8                                while shifting bits from r16 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x03, 0x0fac, od_ib, od_r_m16, od_r16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);
    //  0F AD               SHRD r/m16,    Valid        Valid        Shift r/m16 to right CL places
    //                      r16, CL                                  while shifting bits from r16 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x03, 0x0fad, od_none, od_r_m16, od_r16, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);
    //  0F AC               SHRD r/m32,    Valid        Valid        Shift r/m32 to right imm8 places
    //                      r32, imm8                                while shifting bits from r32 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x03, 0x0fac, od_ib, od_r_m32, od_r32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);
    //  REX.W + 0F AC       SHRD r/m64,    Valid        N.E.         Shift r/m64 to right imm8 places
    //                      r64, imm8                                while shifting bits from r64 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x02, 0x0fac, od_rexw|od_ib, od_r_m64, od_r64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);
    //  0F AD               SHRD r/m32,    Valid        Valid        Shift r/m32 to right CL places
    //                      r32, CL                                  while shifting bits from r32 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x03, 0x0fad, od_none, od_r_m32, od_r32, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-401");
    define(defn);
    //  REX.W + 0F AD       SHRD r/m64,    Valid        N.E.         Shift r/m64 to right CL places
    //                      r64, CL                                  while shifting bits from r64 in
    //                                                               from the left.
    defn = new InsnDefn("shrd",   x86_shrd,    0x02, 0x0fad, od_rexw, od_r_m64, od_r64, od_CL);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-404");
    define(defn);

    //--- page 4-404 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F C6 /r ib SHUFPD xmm1,              Valid    Valid          Shuffle packed double-precision
    //                xmm2/m128, imm8                                   floating-point values selected by
    //                                                                  imm8 from xmm1 and
    //                                                                  xmm2/m128 to xmm1.
    defn = new InsnDefn("shufpd", x86_shufpd,  0x03, 0x660fc6, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-407");
    define(defn);

    //--- page 4-407 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F C6 /r ib    SHUFPS xmm1,              Valid       Valid            Shuffle packed single-precision
    //                 xmm2/m128, imm8                                        floating-point values selected by
    //                                                                        imm8 from xmm1 and
    //                                                                        xmm1/m128 to xmm1.
    defn = new InsnDefn("shufps", x86_shufps,  0x03, 0x0fc6, od_modrm|od_ib, od_xmm, od_xmm_m128, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-410");
    define(defn);

    //--- page 4-410 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 01 /1           SIDT m              Valid         Valid           Store IDTR to m.
    defn = new InsnDefn("sidt",   x86_sidt,    0x03, 0x0f01, od_e1, od_m);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-413");
    define(defn);

    //--- page 4-413 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 00 /0        SLDT r/m16          Valid    Valid       Stores segment selector from LDTR
    //                                                           in r/m16.
    defn = new InsnDefn("sldt",   x86_sldt,    0x03, 0x0f00, od_e0, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-413");
    define(defn);
    //  REX.W + 0F      SLDT r64/m16        Valid    Valid       Stores segment selector from LDTR
    //  00 /0                                                    in r64/m16.
    defn = new InsnDefn("sldt",   x86_sldt,    0x03, 0x0f00, od_rexw|od_e0, od_r64_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-415");
    define(defn);

    //--- page 4-415 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 01 /4      SMSW r/m16        Valid    Valid      Store machine status word to r/m16.
    defn = new InsnDefn("smsw",   x86_smsw,    0x03, 0x0f01, od_e4, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-415");
    define(defn);
    //  0F 01 /4      SMSW r32/m16      Valid    Valid      Store machine status word in low-order
    //                                                      16 bits of r32/m16; high-order 16 bits
    //                                                      of r32 are undefined.
    defn = new InsnDefn("smsw",   x86_smsw,    0x03, 0x0f01, od_e4, od_r32_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-415");
    define(defn);
    //  REX.W + 0F    SMSW r64/m16      Valid    Valid      Store machine status word in low-order
    //  01 /4                                               16 bits of r64/m16; high-order 16 bits
    //                                                      of r32 are undefined.
    defn = new InsnDefn("smsw",   x86_smsw,    0x03, 0x0f01, od_rexw|od_e4, od_r64_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-418");
    define(defn);

    //--- page 4-418 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 51 /r SQRTPD xmm1,           Valid     Valid        Computes square roots of the
    //             xmm2/m128                                     packed double-precision floating-
    //                                                           point values in xmm2/m128 and
    //                                                           stores the results in xmm1.
    defn = new InsnDefn("sqrtpd", x86_sqrtpd,  0x03, 0x660f51, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-421");
    define(defn);

    //--- page 4-421 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 51 /r    SQRTPS xmm1,         Valid        Valid          Computes square roots of the packed
    //              xmm2/m128                                        single-precision floating-point values in
    //                                                               xmm2/m128 and stores the results in
    //                                                               xmm1.
    defn = new InsnDefn("sqrtps", x86_sqrtps,  0x03, 0x0f51, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-424");
    define(defn);

    //--- page 4-424 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // F2 0F 51 /r     SQRTSD xmm1,             Valid       Valid           Computes square root of the
    //                 xmm2/m64                                             low double-precision floating-
    //                                                                      point value in xmm2/m64 and
    //                                                                      stores the results in xmm1.
    defn = new InsnDefn("sqrtsd", x86_sqrtsd,  0x03, 0xf20f51, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-427");
    define(defn);

    //--- page 4-427 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F3 0F 51 /r    SQRTSS xmm1,            Valid       Valid          Computes square root of the low
    //                 xmm2/m32                                           single-precision floating-point value
    //                                                                    in xmm2/m32 and stores the
    //                                                                    results in xmm1.
    defn = new InsnDefn("sqrtss", x86_sqrtss,  0x03, 0xf30f51, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-430");
    define(defn);

    //--- page 4-430 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // F9               STC               Valid       Valid      Set CF flag.
    defn = new InsnDefn("stc",    x86_stc,     0x03, 0xf9, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-431");
    define(defn);

    //--- page 4-431 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  FD              STD                Valid       Valid      Set DF flag.
    defn = new InsnDefn("std",    x86_std,     0x03, 0xfd, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-432");
    define(defn);

    //--- page 4-432 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // FB                STI               Valid          Valid         Set interrupt flag; external, maskable
    //                                                                  interrupts enabled at the end of the
    //                                                                  next instruction.
    defn = new InsnDefn("sti",    x86_sti,     0x03, 0xfb, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-435");
    define(defn);

    //--- page 4-435 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F AE /3      STMXCSR m32       Valid     Valid      Store contents of MXCSR register to
    //                                                       m32.
    defn = new InsnDefn("stmxcsr", x86_stmxcsr, 0x03, 0x0fae, od_e3, od_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);

    //--- page 4-437 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  AA              STOS m8       Valid        Valid      For legacy mode, store AL at address
    //                                                        ES:(E)DI; For 64-bit mode store AL at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stos",   x86_stos,    0x03, 0xaa, od_none, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  AB              STOS m16      Valid        Valid      For legacy mode, store AX at address
    //                                                        ES:(E)DI; For 64-bit mode store AX at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stos",   x86_stos,    0x03, 0xab, od_none, od_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  AB              STOS m32      Valid        Valid      For legacy mode, store EAX at address
    //                                                        ES:(E)DI; For 64-bit mode store EAX at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stos",   x86_stos,    0x03, 0xab, od_none, od_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  REX.W + AB      STOS m64      Valid        N.E.       Store RAX at address RDI or EDI.
    defn = new InsnDefn("stos",   x86_stos,    0x02, 0xab, od_rexw, od_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  AA              STOSB         Valid        Valid      For legacy mode, store AL at address
    //                                                        ES:(E)DI; For 64-bit mode store AL at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stosb",  x86_stosb,   0x03, 0xaa, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  AB              STOSW         Valid        Valid      For legacy mode, store AX at address
    //                                                        ES:(E)DI; For 64-bit mode store AX at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stosw",  x86_stosw,   0x03, 0xab, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  AB              STOSD         Valid        Valid      For legacy mode, store EAX at address
    //                                                        ES:(E)DI; For 64-bit mode store EAX at
    //                                                        address RDI or EDI.
    defn = new InsnDefn("stosd",  x86_stosd,   0x03, 0xab, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-437");
    define(defn);
    //  REX.W + AB      STOSQ         Valid        N.E.       Store RAX at address RDI or EDI.
    defn = new InsnDefn("stosq",  x86_stosq,   0x02, 0xab, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-441");
    define(defn);

    //--- page 4-441 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 00 /1      STR r/m16            Valid     Valid        Stores segment selector from TR in
    //                                                            r/m16.
    defn = new InsnDefn("str",    x86_str,     0x03, 0x0f00, od_e1, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);

    //--- page 4-443 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  2C ib                SUB AL, imm8          Valid       Valid         Subtract imm8 from AL.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2c, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  2D iw                SUB AX, imm16         Valid       Valid         Subtract imm16 from AX.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2d, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  2D id                SUB EAX, imm32        Valid       Valid         Subtract imm32 from EAX.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2d, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX.W + 2D id        SUB RAX, imm32       Valid        N.E.          Subtract imm32 sign-
    //                                                                       extended to 64-bits from
    //                                                                       RAX.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x2d, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  80 /5 ib             SUB r/m8, imm8       Valid        Valid         Subtract imm8 from r/m8.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x80, od_e5|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX + 80 /5 ib       SUB r/m8*, imm8      Valid        N.E.          Subtract imm8 from r/m8.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x80, od_rex|od_e5|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  81 /5 iw             SUB r/m16, imm16 Valid            Valid         Subtract imm16 from r/m16.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x81, od_e5|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  81 /5 id             SUB r/m32, imm32 Valid            Valid         Subtract imm32 from r/m32.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x81, od_e5|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX.W + 81 /5 id     SUB r/m64, imm32 Valid            N.E.          Subtract imm32 sign-
    //                                                                       extended to 64-bits from
    //                                                                       r/m64.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x81, od_rexw|od_e5|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  83 /5 ib             SUB r/m16, imm8      Valid        Valid         Subtract sign-extended imm8
    //                                                                       from r/m16.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x83, od_e5|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  83 /5 ib             SUB r/m32, imm8      Valid        Valid         Subtract sign-extended imm8
    //                                                                       from r/m32.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x83, od_e5|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX.W + 83 /5 ib     SUB r/m64, imm8      Valid        N.E.          Subtract sign-extended imm8
    //                                                                       from r/m64.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x83, od_rexw|od_e5|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  28 /r                SUB r/m8, r8         Valid        Valid         Subtract r8 from r/m8.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x28, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX + 28 /r          SUB r/m8*, r8*       Valid        N.E.          Subtract r8 from r/m8.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x28, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  29 /r                SUB r/m16, r16       Valid        Valid         Subtract r16 from r/m16.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x29, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  29 /r                SUB r/m32, r32       Valid        Valid         Subtract r32 from r/m32.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x29, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX.W + 29 /r        SUB r/m64, r32       Valid        N.E.          Subtract r64 from r/m64.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x29, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  2A /r                SUB r8, r/m8         Valid        Valid         Subtract r/m8 from r8.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2a, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX + 2A /r          SUB r8*, r/m8*       Valid        N.E.          Subtract r/m8 from r8.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x2a, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  2B /r                SUB r16, r/m16       Valid        Valid         Subtract r/m16 from r16.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2b, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  2B /r                SUB r32, r/m32       Valid        Valid         Subtract r/m32 from r32.
    defn = new InsnDefn("sub",    x86_sub,     0x03, 0x2b, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-443");
    define(defn);
    //  REX.W + 2B /r        SUB r64, r/m64       Valid        N.E.          Subtract r/m64 from r64.
    defn = new InsnDefn("sub",    x86_sub,     0x02, 0x2b, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-446");
    define(defn);

    //--- page 4-446 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 5C /r     SUBPD xmm1,         Valid         Valid          Subtract packed double-precision
    //                 xmm2/m128                                        floating-point values in
    //                                                                  xmm2/m128 from xmm1.
    defn = new InsnDefn("subpd",  x86_subpd,   0x03, 0x660f5c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-449");
    define(defn);

    //--- page 4-449 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 5C /r     SUBPS xmm1              Valid       Valid        Subtract packed single-precision
    //               xmm2/m128                                        floating-point values in xmm2/mem
    //                                                                from xmm1.
    defn = new InsnDefn("subps",  x86_subps,   0x03, 0x0f5c, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-452");
    define(defn);

    //--- page 4-452 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // F2 0F 5C /r     SUBSD xmm1,        Valid         Valid           Subtracts the low double-
    //                 xmm2/m64                                         precision floating-point values in
    //                                                                  xmm2/mem64 from xmm1.
    defn = new InsnDefn("subsd",  x86_subsd,   0x03, 0xf20f5c, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-455");
    define(defn);

    //--- page 4-455 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  F3 0F 5C /r      SUBSS xmm1,             Valid       Valid      Subtract the lower single-precision
    //                   xmm2/m32                                       floating-point values in xmm2/m32
    //                                                                  from xmm1.
    defn = new InsnDefn("subss",  x86_subss,   0x03, 0xf30f5c, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-458");
    define(defn);

    //--- page 4-458 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 01 /7          SWAPGS         Valid    Invalid      Exchanges the current GS base register
    //                                                        value with the value contained in MSR
    //                                                        address C0000102H.
    defn = new InsnDefn("swapgs", x86_swapgs,  0x02, 0x0f01, od_e7);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-460");
    define(defn);

    //--- page 4-460 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 05            SYSCALL          Valid         Invalid       Fast call to privilege level 0
    //                                                               system procedures.
    defn = new InsnDefn("syscall", x86_syscall, 0x02, 0x0f05, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-462");
    define(defn);

    //--- page 4-462 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 34            SYSENTER        Valid    Valid      Fast call to privilege level 0 system
    //                                                      procedures.
    defn = new InsnDefn("sysenter", x86_sysenter, 0x03, 0x0f34, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-466");
    define(defn);

    //--- page 4-466 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 35           SYSEXIT       Valid    Valid      Fast return to privilege level 3 user code.
    defn = new InsnDefn("sysexit", x86_sysexit, 0x03, 0x0f35, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-466");
    define(defn);
    // REX.W + 0F SYSEXIT            Valid    Valid      Fast return to 64-bit mode privilege level 3
    // 35                                                user code.
    defn = new InsnDefn("sysexit", x86_sysexit, 0x03, 0x0f35, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-470");
    define(defn);

    //--- page 4-470 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 07           SYSRET        Valid        Invalid        Return from fast system call
    defn = new InsnDefn("sysret", x86_sysret,  0x02, 0x0f07, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);

    //--- page 4-472 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // A8 ib                TEST AL, imm8         Valid        Valid        AND imm8 with AL; set SF, ZF,
    //                                                                      PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xa8, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // A9 iw                TEST AX, imm16        Valid        Valid        AND imm16 with AX; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xa9, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // A9 id                TEST EAX, imm32       Valid        Valid        AND imm32 with EAX; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xa9, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // REX.W + A9 id        TEST RAX, imm32       Valid        N.E.         AND imm32 sign-extended to
    //                                                                      64-bits with RAX; set SF, ZF,
    //                                                                      PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x02, 0xa9, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // F6 /0 ib             TEST r/m8, imm8       Valid        Valid        AND imm8 with r/m8; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xf6, od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // REX + F6 /0 ib       TEST r/m8*, imm8      Valid        N.E.         AND imm8 with r/m8; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x02, 0xf6, od_rex|od_e0|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // F7 /0 iw             TEST r/m16,           Valid        Valid        AND imm16 with r/m16; set
    //                      imm16                                           SF, ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xf7, od_e0|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // F7 /0 id             TEST r/m32,           Valid        Valid        AND imm32 with r/m32; set
    //                      imm32                                           SF, ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0xf7, od_e0|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // REX.W + F7 /0 id     TEST r/m64,           Valid        N.E.         AND imm32 sign-extended to
    //                      imm32                                           64-bits with r/m64; set SF, ZF,
    //                                                                      PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x02, 0xf7, od_rexw|od_e0|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // 84 /r                TEST r/m8, r8         Valid        Valid        AND r8 with r/m8; set SF, ZF,
    //                                                                      PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0x84, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // REX + 84 /r          TEST r/m8*, r8*       Valid        N.E.         AND r8 with r/m8; set SF, ZF,
    //                                                                      PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x02, 0x84, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // 85 /r                TEST r/m16, r16       Valid        Valid        AND r16 with r/m16; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0x85, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // 85 /r                TEST r/m32, r32       Valid        Valid        AND r32 with r/m32; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x03, 0x85, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-472");
    define(defn);
    // REX.W + 85 /r        TEST r/m64, r64       Valid        N.E.         AND r64 with r/m64; set SF,
    //                                                                      ZF, PF according to result.
    defn = new InsnDefn("test",   x86_test,    0x02, 0x85, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-475");
    define(defn);

    //--- page 4-475 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  66 0F 2E /r    UCOMISD xmm1,        Valid       Valid          Compares (unordered) the low double-
    //                 xmm2/m64                                        precision floating-point values in
    //                                                                 xmm1 and xmm2/m64 and set the
    //                                                                 EFLAGS accordingly.
    defn = new InsnDefn("ucomisd", x86_ucomisd, 0x03, 0x660f2e, od_modrm, od_xmm, od_xmm_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-478");
    define(defn);

    //--- page 4-478 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 2E /r        UCOMISS xmm1,          Valid       Valid         Compare lower single-precision floating-
    //                 xmm2/m32                                         point value in xmm1 register with lower
    //                                                                  single-precision floating-point value in
    //                                                                  xmm2/mem and set the status flags
    //                                                                  accordingly.
    defn = new InsnDefn("ucomiss", x86_ucomiss, 0x03, 0x0f2e, od_modrm, od_xmm, od_xmm_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-481");
    define(defn);

    //--- page 4-481 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 0B           UD2               Valid         Valid        Raise invalid opcode exception.
    defn = new InsnDefn("ud2",    x86_ud2,     0x03, 0x0f0b, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-482");
    define(defn);

    //--- page 4-482 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 15 /r     UNPCKHPD xmm1,        Valid        Valid         Unpacks and Interleaves double-
    //                 xmm2/m128                                        precision floating-point values
    //                                                                  from high quadwords of xmm1
    //                                                                  and xmm2/m128.
    defn = new InsnDefn("unpckhpd", x86_unpckhpd, 0x03, 0x660f15, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-485");
    define(defn);

    //--- page 4-485 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 15 /r          UNPCKHPS xmm1,         Valid        Valid           Unpacks and Interleaves single-
    //                    xmm2/m128                                           precision floating-point values
    //                                                                        from high quadwords of xmm1
    //                                                                        and xmm2/mem into xmm1.
    defn = new InsnDefn("unpckhps", x86_unpckhps, 0x03, 0x0f15, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-488");
    define(defn);

    //--- page 4-488 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 14 /r     UNPCKLPD xmm1,        Valid       Valid        Unpacks and Interleaves double-
    //                 xmm2/m128                                      precision floating-point values from
    //                                                                low quadwords of xmm1 and
    //                                                                xmm2/m128.
    defn = new InsnDefn("unpcklpd", x86_unpcklpd, 0x03, 0x660f14, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-491");
    define(defn);

    //--- page 4-491 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 14 /r     UNPCKLPS xmm1,          Valid         Valid        Unpacks and Interleaves single-
    //               xmm2/m128                                          precision floating-point values from
    //                                                                  low quadwords of xmm1 and
    //                                                                  xmm2/mem into xmm1.
    defn = new InsnDefn("unpcklps", x86_unpcklps, 0x03, 0x0f14, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-494");
    define(defn);

    //--- page 4-494 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 00 /4        VERR r/m16       Valid      Valid          Set ZF=1 if segment specified with
    //                                                            r/m16 can be read.
    defn = new InsnDefn("verr",   x86_verr,    0x03, 0x0f00, od_e4, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-494");
    define(defn);
    // 0F 00 /5        VERW r/m16       Valid      Valid          Set ZF=1 if segment specified with
    //                                                            r/m16 can be written.
    defn = new InsnDefn("verw",   x86_verw,    0x03, 0x0f00, od_e5, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-497");
    define(defn);

    //--- page 4-497 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  9B           WAIT           Valid        Valid       Check pending unmasked floating-
    //                                                       point exceptions.
    defn = new InsnDefn("wait",   x86_wait,    0x03, 0x9b, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-497");
    define(defn);
    //  9B           FWAIT          Valid        Valid       Check pending unmasked floating-
    //                                                       point exceptions.
    defn = new InsnDefn("fwait",  x86_fwait,   0x03, 0x9b, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-499");
    define(defn);

    //--- page 4-499 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 09             WBINVD          Valid    Valid       Write back and flush Internal caches;
    //                                                         initiate writing-back and flushing of
    //                                                         external caches.
    defn = new InsnDefn("wbinvd", x86_wbinvd,  0x03, 0x0f09, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-501");
    define(defn);

    //--- page 4-501 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 30               WRMSR          Valid    Valid      Write the value in EDX:EAX to MSR
    //                                                         specified by ECX.
    defn = new InsnDefn("wrmsr",  x86_wrmsr,   0x03, 0x0f30, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-503");
    define(defn);

    //--- page 4-503 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F C0 /r             XADD r/m8, r8       Valid          Valid          Exchange r8 and r/m8; load
    //                                                                         sum into r/m8.
    defn = new InsnDefn("xadd",   x86_xadd,    0x03, 0x0fc0, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-503");
    define(defn);
    //  REX + 0F C0 /r       XADD r/m8*, r8*     Valid          N.E.           Exchange r8 and r/m8; load
    //                                                                         sum into r/m8.
    defn = new InsnDefn("xadd",   x86_xadd,    0x02, 0x0fc0, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-503");
    define(defn);
    //  0F C1 /r             XADD r/m16, r16     Valid          Valid          Exchange r16 and r/m16;
    //                                                                         load sum into r/m16.
    defn = new InsnDefn("xadd",   x86_xadd,    0x03, 0x0fc1, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-503");
    define(defn);
    //  0F C1 /r             XADD r/m32, r32     Valid          Valid          Exchange r32 and r/m32;
    //                                                                         load sum into r/m32.
    defn = new InsnDefn("xadd",   x86_xadd,    0x03, 0x0fc1, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-503");
    define(defn);
    //  REX.W + 0F C1 /r     XADD r/m64, r64     Valid          N.E.           Exchange r64 and r/m64;
    //                                                                         load sum into r/m64.
    defn = new InsnDefn("xadd",   x86_xadd,    0x02, 0x0fc1, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);

    //--- page 4-506 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 90+rw             XCHG AX, r16           Valid       Valid        Exchange r16 with AX.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x90, od_rw, od_AX, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 90+rw             XCHG r16, AX           Valid       Valid        Exchange AX with r16.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x90, od_rw, od_r16, od_AX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 90+rd             XCHG EAX, r32          Valid       Valid        Exchange r32 with EAX.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x90, od_rd, od_EAX, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX.W + 90+rd     XCHG RAX, r64          Valid       N.E.         Exchange r64 with RAX.
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x90, od_rexw|od_rd, od_RAX, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 90+rd             XCHG r32, EAX          Valid       Valid        Exchange EAX with r32.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x90, od_rd, od_r32, od_EAX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX.W + 90+rd     XCHG r64, RAX          Valid       N.E.         Exchange RAX with r64.
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x90, od_rexw|od_rd, od_r64, od_RAX);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 86 /r             XCHG r/m8, r8          Valid       Valid        Exchange r8 (byte register) with
    //                                                                   byte from r/m8.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x86, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX + 86 /r       XCHG r/m8*, r8*        Valid       N.E.         Exchange r8 (byte register) with
    //                                                                   byte from r/m8.
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x86, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 86 /r             XCHG r8, r/m8          Valid       Valid        Exchange byte from r/m8 with
    //                                                                   r8 (byte register).
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x86, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX + 86 /r       XCHG r8*, r/m8*        Valid       N.E.         Exchange byte from r/m8 with
    //                                                                   r8 (byte register).
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x86, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 87 /r             XCHG r/m16, r16        Valid       Valid        Exchange r16 with word from
    //                                                                   r/m16.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x87, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 87 /r             XCHG r16, r/m16        Valid       Valid        Exchange word from r/m16 with
    //                                                                   r16.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x87, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 87 /r             XCHG r/m32, r32        Valid       Valid        Exchange r32 with doubleword
    //                                                                   from r/m32.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x87, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX.W + 87 /r     XCHG r/m64, r64       Valid        N.E.         Exchange r64 with quadword
    //                                                                   from r/m64.
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x87, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // 87 /r             XCHG r32, r/m32        Valid       Valid        Exchange doubleword from
    //                                                                   r/m32 with r32.
    defn = new InsnDefn("xchg",   x86_xchg,    0x03, 0x87, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-506");
    define(defn);
    // REX.W + 87 /r     XCHG r64, r/m64       Valid        N.E.         Exchange quadword from r/m64
    //                                                                   with r64.
    defn = new InsnDefn("xchg",   x86_xchg,    0x02, 0x87, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-509");
    define(defn);

    //--- page 4-509 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 01 D0      XGETBV                 Valid      Valid            Reads an XCR specified by ECX
    //                                                                   into EDX:EAX.
    defn = new InsnDefn("xgetbv", x86_xgetbv,  0x03, 0x0f01d0, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-511");
    define(defn);

    //--- page 4-511 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  D7                XLAT m8        Valid       Valid      Set AL to memory byte DS:[(E)BX +
    //                                                          unsigned AL].
    defn = new InsnDefn("xlatb",  x86_xlatb,   0x03, 0xd7, od_none, od_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-511");
    define(defn);
    //  D7                XLATB          Valid       Valid      Set AL to memory byte DS:[(E)BX +
    //                                                          unsigned AL].
    defn = new InsnDefn("xlatb",  x86_xlatb,   0x03, 0xd7, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-511");
    define(defn);
    //  REX.W + D7        XLATB          Valid       N.E.       Set AL to memory byte [RBX +
    //                                                          unsigned AL].
    defn = new InsnDefn("xlatb",  x86_xlatb,   0x02, 0xd7, od_rexw);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);

    //--- page 4-513 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  34 ib                 XOR AL, imm8          Valid        Valid         AL XOR imm8.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x34, od_ib, od_AL, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  35 iw                 XOR AX, imm16         Valid        Valid         AX XOR imm16.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x35, od_iw, od_AX, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  35 id                 XOR EAX, imm32        Valid        Valid         EAX XOR imm32.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x35, od_id, od_EAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX.W + 35 id         XOR RAX, imm32        Valid        N.E.          RAX XOR imm32 (sign-
    //                                                                         extended).
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x35, od_rexw|od_id, od_RAX, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  80 /6 ib              XOR r/m8, imm8        Valid        Valid         r/m8 XOR imm8.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x80, od_e6|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX + 80 /6 ib        XOR r/m8*, imm8       Valid        N.E.          r/m8 XOR imm8.
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x80, od_rex|od_e6|od_ib, od_r_m8, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  81 /6 iw              XOR r/m16, imm16      Valid        Valid         r/m16 XOR imm16.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x81, od_e6|od_iw, od_r_m16, od_imm16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  81 /6 id              XOR r/m32, imm32      Valid        Valid         r/m32 XOR imm32.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x81, od_e6|od_id, od_r_m32, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX.W + 81 /6 id      XOR r/m64, imm32      Valid        N.E.          r/m64 XOR imm32 (sign-
    //                                                                         extended).
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x81, od_rexw|od_e6|od_id, od_r_m64, od_imm32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  83 /6 ib              XOR r/m16, imm8       Valid        Valid         r/m16 XOR imm8 (sign-
    //                                                                         extended).
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x83, od_e6|od_ib, od_r_m16, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  83 /6 ib              XOR r/m32, imm8       Valid        Valid         r/m32 XOR imm8 (sign-
    //                                                                         extended).
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x83, od_e6|od_ib, od_r_m32, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX.W + 83 /6 ib      XOR r/m64, imm8       Valid        N.E.          r/m64 XOR imm8 (sign-
    //                                                                         extended).
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x83, od_rexw|od_e6|od_ib, od_r_m64, od_imm8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  30 /r                 XOR r/m8, r8          Valid        Valid         r/m8 XOR r8.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x30, od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX + 30 /r           XOR r/m8*, r8*        Valid        N.E.          r/m8 XOR r8.
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x30, od_rex|od_modrm, od_r_m8, od_r8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  31 /r                 XOR r/m16, r16        Valid        Valid         r/m16 XOR r16.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x31, od_modrm, od_r_m16, od_r16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  31 /r                 XOR r/m32, r32        Valid        Valid         r/m32 XOR r32.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x31, od_modrm, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX.W + 31 /r         XOR r/m64, r64        Valid        N.E.          r/m64 XOR r64.
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x31, od_rexw|od_modrm, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  32 /r                 XOR r8, r/m8          Valid        Valid         r8 XOR r/m8.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x32, od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX + 32 /r           XOR r8*, r/m8*        Valid        N.E.          r8 XOR r/m8.
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x32, od_rex|od_modrm, od_r8, od_r_m8);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  33 /r                 XOR r16, r/m16        Valid        Valid         r16 XOR r/m16.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x33, od_modrm, od_r16, od_r_m16);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  33 /r                 XOR r32, r/m32        Valid        Valid         r32 XOR r/m32.
    defn = new InsnDefn("xor",    x86_xor,     0x03, 0x33, od_modrm, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-513");
    define(defn);
    //  REX.W + 33 /r         XOR r64, r/m64        Valid        N.E.          r64 XOR r/m64.
    defn = new InsnDefn("xor",    x86_xor,     0x02, 0x33, od_rexw|od_modrm, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-516");
    define(defn);

    //--- page 4-516 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 66 0F 57 /r     XORPD xmm1, xmm2/m128       Valid       Valid           Bitwise exclusive-OR of
    //                                                                         xmm2/m128 and xmm1.
    defn = new InsnDefn("xorpd",  x86_xorpd,   0x03, 0x660f57, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-518");
    define(defn);

    //--- page 4-518 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    // 0F 57 /r        XORPS xmm1, xmm2/m128 Valid            Valid           Bitwise exclusive-OR of
    //                                                                        xmm2/m128 and xmm1.
    defn = new InsnDefn("xorps",  x86_xorps,   0x03, 0x0f57, od_modrm, od_xmm, od_xmm_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-520");
    define(defn);

    //--- page 4-520 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //     0F AE /5      XRSTOR mem         Valid          Valid           Restore processor extended
    //                                                                     states from memory. The
    //                                                                     states are specified by
    //                                                                     EDX:EAX
    defn = new InsnDefn("xrstor", x86_xrstor,  0x03, 0x0fae, od_e5, od_m);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-525");
    define(defn);

    //--- page 4-525 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F AE /4      XSAVE mem               Valid    Valid        Save processor extended
    //                                                              states to memory. The states
    //                                                              are specified by EDX:EAX
    defn = new InsnDefn("xsave",  x86_xsave,   0x03, 0x0fae, od_e4, od_m);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 4-529");
    define(defn);

    //--- page 4-529 of x86-InstructionSetReference-NZ.pdf -------------------------------------------------------------
    //  0F 01 D1      XSETBV                  Valid      Valid             Write the value in EDX:EAX to
    //                                                                     the XCR specified by ECX.
    defn = new InsnDefn("xsetbv", x86_xsetbv,  0x03, 0x0f01d1, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-4");
    define(defn);

    //--- page 5-4 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    // 66 0F 38 80      INVEPT r64, m128        Invalidates EPT-derived entries in the TLBs and
    //                                          paging-structure caches (in 64-bit mode)
    defn = new InsnDefn("invept", x86_invept,  0x02, 0x660f3880, od_none, od_r64, od_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-4");
    define(defn);
    // 66 0F 38 80      INVEPT r32, m128        Invalidates EPT-derived entries in the TLBs and
    //                                          paging-structure caches (outside 64-bit mode)
    defn = new InsnDefn("invept", x86_invept,  0x02, 0x660f3880, od_none, od_r32, od_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-7");
    define(defn);

    //--- page 5-7 of x86-InstructionSetReference-NZ.pdf ---------------------------------------------------------------
    //  66 0F 38 81         INVVPID r64, m128           Invalidates entries in the TLBs and paging-structure
    //                                                  caches based on VPID (in 64-bit mode)
    defn = new InsnDefn("invvpid", x86_invvpid, 0x02, 0x660f3881, od_none, od_r64, od_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-7");
    define(defn);
    //  66 0F 38 81         INVVPID r32, m128           Invalidates entries in the TLBs and paging-structure
    //                                                  caches based on VPID (outside 64-bit mode)
    defn = new InsnDefn("invvpid", x86_invvpid, 0x02, 0x660f3881, od_none, od_r32, od_m128);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-11");
    define(defn);

    //--- page 5-11 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 01 C1           VMCALL          Call to VM monitor by causing VM exit.
    defn = new InsnDefn("vmcall", x86_vmcall,  0x02, 0x0f01c1, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-13");
    define(defn);

    //--- page 5-13 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  66 0F C7 /6         VMCLEAR m64           Copy VMCS data to VMCS region in memory.
    defn = new InsnDefn("vmclear", x86_vmclear, 0x02, 0x660fc7, od_e6, od_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-16");
    define(defn);

    //--- page 5-16 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F 01 C2           VMLAUNCH        Launch virtual machine managed by current VMCS.
    defn = new InsnDefn("vmlaunch", x86_vmlaunch, 0x02, 0x0f01c2, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-16");
    define(defn);
    // 0F 01 C3           VMRESUME        Resume virtual machine managed by current VMCS.
    defn = new InsnDefn("vmresume", x86_vmresume, 0x02, 0x0f01c3, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-19");
    define(defn);

    //--- page 5-19 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F C7 /6            VMPTRLD m64            Loads the current VMCS pointer from memory.
    defn = new InsnDefn("vmptrld", x86_vmptrld, 0x02, 0x0fc7, od_e6, od_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-22");
    define(defn);

    //--- page 5-22 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F C7 /7            VMPTRST m64      Stores the current VMCS pointer into memory.
    defn = new InsnDefn("vmptrst", x86_vmptrst, 0x02, 0x0fc7, od_e7, od_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-24");
    define(defn);

    //--- page 5-24 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    // 0F 78             VMREAD r/m64, r64      Reads a specified VMCS field (in 64-bit mode).
    defn = new InsnDefn("vmread", x86_vmread,  0x02, 0x0f78, od_none, od_r_m64, od_r64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-24");
    define(defn);
    // 0F 78             VMREAD r/m32, r32       Reads a specified VMCS field (outside 64-bit mode).
    defn = new InsnDefn("vmread", x86_vmread,  0x02, 0x0f78, od_none, od_r_m32, od_r32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-27");
    define(defn);

    //--- page 5-27 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 79               VMWRITE r64, r/m64           Writes a specified VMCS field (in 64-bit mode)
    defn = new InsnDefn("vmwrite", x86_vmwrite, 0x02, 0x0f79, od_none, od_r64, od_r_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-27");
    define(defn);
    //  0F 79               VMWRITE r32, r/m32           Writes a specified VMCS field (outside 64-bit mode)
    defn = new InsnDefn("vmwrite", x86_vmwrite, 0x02, 0x0f79, od_none, od_r32, od_r_m32);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-29");
    define(defn);

    //--- page 5-29 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  0F 01 C4           VMXOFF          Leaves VMX operation.
    defn = new InsnDefn("vmxoff", x86_vmxoff,  0x02, 0x0f01c4, od_none);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-31");
    define(defn);

    //--- page 5-31 of x86-InstructionSetReference-NZ.pdf --------------------------------------------------------------
    //  F3 0F C7 /6        VMXON m64                  Enter VMX root operation.
    defn = new InsnDefn("vmxon",  x86_vmxon,   0x02, 0xf30fc7, od_e6, od_m64);
    defn->set_location("x86-InstructionSetReference-NZ.pdf, page 5-37");
    define(defn);

    //------------------------------------------------------------------------------------------------------------------
    // The following definitions are from ExtraInstructions.txt, modified 15 Jul 2009
    //------------------------------------------------------------------------------------------------------------------


    //--- page 1 of ExtraInstructions.txt ------------------------------------------------------------------------------
    // 0F 01 C4                 VMOFF              Valid Invalid  VMX Instruction; ModR/M=0304 (0xc4)
    defn = new InsnDefn("vmoff",  x86_vmoff,   0x02, 0x0f01c4, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 D8                 VMRUN              Valid Invalid  VMX Instruction; ModR/M=0330 (0xd8)
    defn = new InsnDefn("vmrun",  x86_vmrun,   0x02, 0x0f01d8, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 D9                 VMMCALL            Valid Invalid  VMX Instruction; ModR/M=0331 (0xd9)
    defn = new InsnDefn("vmmcall", x86_vmmcall, 0x02, 0x0f01d9, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DA                 VMLOAD             Valid Invalid  VMX Instruction; ModR/M=0332 (0xda)
    defn = new InsnDefn("vmload", x86_vmload,  0x02, 0x0f01da, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DB                 VMSAVE             Valid Invalid  VMX Instruction; ModR/M=0333 (0xdb)
    defn = new InsnDefn("vmsave", x86_vmsave,  0x02, 0x0f01db, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DC                 STGI               Valid Invalid  VMX Instruction; ModR/M=0334 (0xdc)
    defn = new InsnDefn("stgi",   x86_stgi,    0x02, 0x0f01dc, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DD                 CLGI               Valid Invalid  VMX Instruction; ModR/M=0335 (0xdd)
    defn = new InsnDefn("clgi",   x86_clgi,    0x02, 0x0f01dd, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DE                 SKINIT             Valid Invalid  VMX Instruction; ModR/M=0336 (0xde)
    defn = new InsnDefn("skinit", x86_skinit,  0x02, 0x0f01de, od_none);
    defn->set_location("ExtraInstructions.txt, page 1");
    define(defn);
    // 0F 01 DF                 INVLPGA            Valid Invalid  VMX Instruction; ModR/M=0337 (0xdf)
    defn = new InsnDefn("invlpga", x86_invlpga, 0x02, 0x0f01df, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);

    //--- page 2 of ExtraInstructions.txt ------------------------------------------------------------------------------
    // 0F 0F 0C                 PI2FW              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pi2fw",  x86_pi2fw,   0x00, 0x0f0f0c, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 0D                 PI2FD              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pi2fd",  x86_pi2fd,   0x00, 0x0f0f0d, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 1C                 PF2IW              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pf2iw",  x86_pf2iw,   0x00, 0x0f0f1c, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 1D                 PF2ID              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pf2id",  x86_pf2id,   0x00, 0x0f0f1d, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 8A                 PFNACC             Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfnacc", x86_pfnacc,  0x00, 0x0f0f8a, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 8E                 PFPNACC            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfpnacc", x86_pfpnacc, 0x00, 0x0f0f8e, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 90                 PFCMPGE            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfcmpge", x86_pfcmpge, 0x00, 0x0f0f90, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 94                 PFMIN              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfmin",  x86_pfmin,   0x00, 0x0f0f94, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 96                 PFRCP              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfrcp",  x86_pfrcp,   0x00, 0x0f0f96, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 97                 PFRSQRT            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfrsqrt", x86_pfrsqrt, 0x00, 0x0f0f97, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 9A                 PFSUB              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfsub",  x86_pfsub,   0x00, 0x0f0f9a, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F 9E                 PFADD              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfadd",  x86_pfadd,   0x00, 0x0f0f9e, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F A0                 PFCMPGT            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfcmpgt", x86_pfcmpgt, 0x00, 0x0f0fa0, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F A4                 PFMAX              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfmax",  x86_pfmax,   0x00, 0x0f0fa4, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F A6                 PFRCPIT1           Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfrcpit1", x86_pfrcpit1, 0x00, 0x0f0fa6, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F A7                 PFRSQIT1           Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfrsqit1", x86_pfrsqit1, 0x00, 0x0f0fa7, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F AA                 PFSUBR             Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfsubr", x86_pfsubr,  0x00, 0x0f0faa, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F AE                 PFACC              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfacc",  x86_pfacc,   0x00, 0x0f0fae, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F B0                 PFCMPEQ            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfcmpeq", x86_pfcmpeq, 0x00, 0x0f0fb0, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F B4                 PFMUL              Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfmul",  x86_pfmul,   0x00, 0x0f0fb4, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F B6                 PFRCPIT2           Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pfrcpit2", x86_pfrcpit2, 0x00, 0x0f0fb6, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F B7                 PMULHRW            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pmulhrw", x86_pmulhrw, 0x00, 0x0f0fb7, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F BB                 PSWAPD             Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pswapd", x86_pswapd,  0x00, 0x0f0fbb, od_none);
    defn->set_location("ExtraInstructions.txt, page 2");
    define(defn);
    // 0F 0F BF                 PAVGUSB            Invalid Invalid  AMD 3DNow!
    defn = new InsnDefn("pavgusb", x86_pavgusb, 0x00, 0x0f0fbf, od_none);
    defn->set_location("ExtraInstructions.txt, page 3");
    define(defn);

    //--- page 3 of ExtraInstructions.txt ------------------------------------------------------------------------------
    // F3 0F BD /r              LZCNT r16, r/m16   Valid   Valid    Alias for REPE BSR
    defn = new InsnDefn("lzcnt",  x86_lzcnt,   0x03, 0xf30fbd, od_modrm, od_r16, od_r_m16);
    defn->set_location("ExtraInstructions.txt, page 3");
    define(defn);
    // F3 0F BD /r              LZCNT r32, r/m32   Valid   Valid    Alias for REPE BSR
    defn = new InsnDefn("lzcnt",  x86_lzcnt,   0x03, 0xf30fbd, od_modrm, od_r32, od_r_m32);
    defn->set_location("ExtraInstructions.txt, page 3");
    define(defn);
    // F3 REX.W + 0F BD         LZCNT r64, r/m64   Valid   N.E.     Alias for REPE BSR
    defn = new InsnDefn("lzcnt",  x86_lzcnt,   0x02, 0xf30fbd, od_rexw, od_r64, od_r_m64);
    defn->set_location("ExtraInstructions.txt, page 4");
    define(defn);

    //--- page 4 of ExtraInstructions.txt ------------------------------------------------------------------------------
    // F2 0F 2B /r              MOVNTSD m128       Valid   Valid    Alias for REPNE MOVNTPS
    defn = new InsnDefn("movntsd", x86_movntsd, 0x03, 0xf20f2b, od_modrm, od_m128);
    defn->set_location("ExtraInstructions.txt, page 4");
    define(defn);
    // F3 0F 2B /r              MOVNTSS m128       Valid   Valid    Alias for REPE MOVNTPS
    defn = new InsnDefn("movntss", x86_movntss, 0x03, 0xf30f2b, od_modrm, od_m128);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);

    //--- page 5 of ExtraInstructions.txt ------------------------------------------------------------------------------
    // 0F 0D /1                 PREFETCHW          Invalid Invalid  Not documented
    defn = new InsnDefn("prefetchw", x86_prefetchw, 0x00, 0x0f0d, od_e1);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 0D /3                 PREFETCHW          Invalid Invalid  Not documented
    defn = new InsnDefn("prefetchw", x86_prefetchw, 0x00, 0x0f0d, od_e3);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 0E                    FEMMS              Invalid Invalid  Undocumented by Intel or OIR
    defn = new InsnDefn("femms",  x86_femms,   0x00, 0x0f0e, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 18                    PREFETCH           Invalid Invalid  See PREFETCH(0|1|2|NTA) instead
    defn = new InsnDefn("prefetch", x86_prefetch, 0x00, 0x0f18, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 37                    GETSEC             Valid   Invalid  Safer mode extensions. See Intel Instruction Set Reference, section 6
    defn = new InsnDefn("getsec", x86_getsec,  0x02, 0x0f37, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 73 /4                 PSRAQ r/m64 imm8   Invalid Invalid  Not documented; ModR/M=034x
    defn = new InsnDefn("psraq",  x86_psraq,   0x00, 0x0f73, od_e4|od_ib, od_r_m64, od_imm8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // F2 0F 78                 INSERTQ imm8 imm8  Invalid Invalid  Undocumented by Intel or OIR
    defn = new InsnDefn("insertq", x86_insertq, 0x00, 0xf20f78, od_none, od_imm8, od_imm8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 66 0F 79 /0              EXTRQ imm8 imm8    Invalid Invalid  Undocumented by Intel or OIR
    defn = new InsnDefn("extrq",  x86_extrq,   0x00, 0x660f79, od_e0, od_imm8, od_imm8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 66 90 NOP    Valid   Valid    2-byte form of no-operation
    defn = new InsnDefn("nop",    x86_nop,     0x03, 0x6690, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F 99                    SETNS r/m8         Invalid Invalid  Set byte condition not signed
    defn = new InsnDefn("setns",  x86_setns,   0x00, 0x0f99, od_none, od_r_m8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // REX + 0F 99              SETNS r/m8         Invalid N.E.     Set byte condition not signed
    defn = new InsnDefn("setns",  x86_setns,   0x00, 0x0f99, od_rex, od_r_m8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // 0F B8 /r                 JMPE               Invalid Invalid  Used to enter IA64 mode on Itanium architecture
    defn = new InsnDefn("jmpe",   x86_jmpe,    0x00, 0x0fb8, od_modrm);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // REX.W + 0F BE /r         MOVSX r64, r/m8    Valid   Invalid  Intel docs have wrong REX byte
    defn = new InsnDefn("movsx",  x86_movsx,   0x02, 0x0fbe, od_rexw|od_modrm, od_r64, od_r_m8);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // D6                       SALC               Invalid Invalid  Not documented
    defn = new InsnDefn("salc",   x86_salc,    0x00, 0xd6, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
    // F1                       INT1               Invalid Invalid  Undocumented by Intel
    defn = new InsnDefn("int1",   x86_int1,    0x00, 0xf1, od_none);
    defn->set_location("ExtraInstructions.txt, page 5");
    define(defn);
}

std::string
AssemblerX86::to_str(X86InstructionKind kind)
{
    switch (kind) {
        case x86_aaa:             return "aaa";             break;
        case x86_aad:             return "aad";             break;
        case x86_aam:             return "aam";             break;
        case x86_aas:             return "aas";             break;
        case x86_adc:             return "adc";             break;
        case x86_add:             return "add";             break;
        case x86_addpd:           return "addpd";           break;
        case x86_addps:           return "addps";           break;
        case x86_addsd:           return "addsd";           break;
        case x86_addss:           return "addss";           break;
        case x86_addsubpd:        return "addsubpd";        break;
        case x86_addsubps:        return "addsubps";        break;
        case x86_and:             return "and";             break;
        case x86_andnpd:          return "andnpd";          break;
        case x86_andnps:          return "andnps";          break;
        case x86_andpd:           return "andpd";           break;
        case x86_andps:           return "andps";           break;
        case x86_arpl:            return "arpl";            break;
        case x86_blendpd:         return "blendpd";         break;
        case x86_blendps:         return "blendps";         break;
        case x86_blendvpd:        return "blendvpd";        break;
        case x86_blendvps:        return "blendvps";        break;
        case x86_bound:           return "bound";           break;
        case x86_bsf:             return "bsf";             break;
        case x86_bsr:             return "bsr";             break;
        case x86_bswap:           return "bswap";           break;
        case x86_bt:              return "bt";              break;
        case x86_btc:             return "btc";             break;
        case x86_btr:             return "btr";             break;
        case x86_bts:             return "bts";             break;
        case x86_call:            return "call";            break;
        case x86_cbw:             return "cbw";             break;
        case x86_cdq:             return "cdq";             break;
        case x86_cdqe:            return "cdqe";            break;
        case x86_clc:             return "clc";             break;
        case x86_cld:             return "cld";             break;
        case x86_clflush:         return "clflush";         break;
        case x86_clgi:            return "clgi";            break;
        case x86_cli:             return "cli";             break;
        case x86_clts:            return "clts";            break;
        case x86_cmc:             return "cmc";             break;
        case x86_cmova:           return "cmova";           break;
        case x86_cmovae:          return "cmovae";          break;
        case x86_cmovb:           return "cmovb";           break;
        case x86_cmovbe:          return "cmovbe";          break;
        case x86_cmove:           return "cmove";           break;
        case x86_cmovg:           return "cmovg";           break;
        case x86_cmovge:          return "cmovge";          break;
        case x86_cmovl:           return "cmovl";           break;
        case x86_cmovle:          return "cmovle";          break;
        case x86_cmovne:          return "cmovne";          break;
        case x86_cmovno:          return "cmovno";          break;
        case x86_cmovns:          return "cmovns";          break;
        case x86_cmovo:           return "cmovo";           break;
        case x86_cmovpe:          return "cmovpe";          break;
        case x86_cmovpo:          return "cmovpo";          break;
        case x86_cmovs:           return "cmovs";           break;
        case x86_cmp:             return "cmp";             break;
        case x86_cmppd:           return "cmppd";           break;
        case x86_cmpps:           return "cmpps";           break;
        case x86_cmpsb:           return "cmpsb";           break;
        case x86_cmpsd:           return "cmpsd";           break;
        case x86_cmpsq:           return "cmpsq";           break;
        case x86_cmpss:           return "cmpss";           break;
        case x86_cmpsw:           return "cmpsw";           break;
        case x86_cmpxchg:         return "cmpxchg";         break;
        case x86_cmpxchg16b:      return "cmpxchg16b";      break;
        case x86_cmpxchg8b:       return "cmpxchg8b";       break;
        case x86_comisd:          return "comisd";          break;
        case x86_comiss:          return "comiss";          break;
        case x86_cpuid:           return "cpuid";           break;
        case x86_cqo:             return "cqo";             break;
        case x86_crc32:           return "crc32";           break;
        case x86_cvtdq2pd:        return "cvtdq2pd";        break;
        case x86_cvtdq2ps:        return "cvtdq2ps";        break;
        case x86_cvtpd2dq:        return "cvtpd2dq";        break;
        case x86_cvtpd2pi:        return "cvtpd2pi";        break;
        case x86_cvtpd2ps:        return "cvtpd2ps";        break;
        case x86_cvtpi2pd:        return "cvtpi2pd";        break;
        case x86_cvtpi2ps:        return "cvtpi2ps";        break;
        case x86_cvtps2dq:        return "cvtps2dq";        break;
        case x86_cvtps2pd:        return "cvtps2pd";        break;
        case x86_cvtps2pi:        return "cvtps2pi";        break;
        case x86_cvtsd2si:        return "cvtsd2si";        break;
        case x86_cvtsd2ss:        return "cvtsd2ss";        break;
        case x86_cvtsi2sd:        return "cvtsi2sd";        break;
        case x86_cvtsi2ss:        return "cvtsi2ss";        break;
        case x86_cvtss2sd:        return "cvtss2sd";        break;
        case x86_cvtss2si:        return "cvtss2si";        break;
        case x86_cvttpd2dq:       return "cvttpd2dq";       break;
        case x86_cvttpd2pi:       return "cvttpd2pi";       break;
        case x86_cvttps2dq:       return "cvttps2dq";       break;
        case x86_cvttps2pi:       return "cvttps2pi";       break;
        case x86_cvttsd2si:       return "cvttsd2si";       break;
        case x86_cvttss2si:       return "cvttss2si";       break;
        case x86_cwd:             return "cwd";             break;
        case x86_cwde:            return "cwde";            break;
        case x86_daa:             return "daa";             break;
        case x86_das:             return "das";             break;
        case x86_dec:             return "dec";             break;
        case x86_div:             return "div";             break;
        case x86_divpd:           return "divpd";           break;
        case x86_divps:           return "divps";           break;
        case x86_divsd:           return "divsd";           break;
        case x86_divss:           return "divss";           break;
        case x86_dppd:            return "dppd";            break;
        case x86_dpps:            return "dpps";            break;
        case x86_emms:            return "emms";            break;
        case x86_enter:           return "enter";           break;
        case x86_extractps:       return "extractps";       break;
        case x86_extrq:           return "extrq";           break;
        case x86_f2xm1:           return "f2xm1";           break;
        case x86_fabs:            return "fabs";            break;
        case x86_fadd:            return "fadd";            break;
        case x86_faddp:           return "faddp";           break;
        case x86_farcall:         return "farcall";         break;
        case x86_farjmp:          return "farjmp";          break;
        case x86_fbld:            return "fbld";            break;
        case x86_fbstp:           return "fbstp";           break;
        case x86_fchs:            return "fchs";            break;
        case x86_fcmovb:          return "fcmovb";          break;
        case x86_fcmovbe:         return "fcmovbe";         break;
        case x86_fcmove:          return "fcmove";          break;
        case x86_fcmovnb:         return "fcmovnb";         break;
        case x86_fcmovnbe:        return "fcmovnbe";        break;
        case x86_fcmovne:         return "fcmovne";         break;
        case x86_fcmovnu:         return "fcmovnu";         break;
        case x86_fcmovu:          return "fcmovu";          break;
        case x86_fcom:            return "fcom";            break;
        case x86_fcomi:           return "fcomi";           break;
        case x86_fcomip:          return "fcomip";          break;
        case x86_fcomp:           return "fcomp";           break;
        case x86_fcompp:          return "fcompp";          break;
        case x86_fcos:            return "fcos";            break;
        case x86_fdecstp:         return "fdecstp";         break;
        case x86_fdiv:            return "fdiv";            break;
        case x86_fdivp:           return "fdivp";           break;
        case x86_fdivr:           return "fdivr";           break;
        case x86_fdivrp:          return "fdivrp";          break;
        case x86_femms:           return "femms";           break;
        case x86_ffree:           return "ffree";           break;
        case x86_fiadd:           return "fiadd";           break;
        case x86_ficom:           return "ficom";           break;
        case x86_ficomp:          return "ficomp";          break;
        case x86_fidiv:           return "fidiv";           break;
        case x86_fidivr:          return "fidivr";          break;
        case x86_fild:            return "fild";            break;
        case x86_fimul:           return "fimul";           break;
        case x86_fincstp:         return "fincstp";         break;
        case x86_fist:            return "fist";            break;
        case x86_fistp:           return "fistp";           break;
        case x86_fisttp:          return "fisttp";          break;
        case x86_fisub:           return "fisub";           break;
        case x86_fisubr:          return "fisubr";          break;
        case x86_fld:             return "fld";             break;
        case x86_fld1:            return "fld1";            break;
        case x86_fldcw:           return "fldcw";           break;
        case x86_fldenv:          return "fldenv";          break;
        case x86_fldl2e:          return "fldl2e";          break;
        case x86_fldl2t:          return "fldl2t";          break;
        case x86_fldlg2:          return "fldlg2";          break;
        case x86_fldln2:          return "fldln2";          break;
        case x86_fldpi:           return "fldpi";           break;
        case x86_fldz:            return "fldz";            break;
        case x86_fmul:            return "fmul";            break;
        case x86_fmulp:           return "fmulp";           break;
        case x86_fnclex:          return "fnclex";          break;
        case x86_fninit:          return "fninit";          break;
        case x86_fnop:            return "fnop";            break;
        case x86_fnsave:          return "fnsave";          break;
        case x86_fnstcw:          return "fnstcw";          break;
        case x86_fnstenv:         return "fnstenv";         break;
        case x86_fnstsw:          return "fnstsw";          break;
        case x86_fpatan:          return "fpatan";          break;
        case x86_fprem:           return "fprem";           break;
        case x86_fprem1:          return "fprem1";          break;
        case x86_fptan:           return "fptan";           break;
        case x86_frndint:         return "frndint";         break;
        case x86_frstor:          return "frstor";          break;
        case x86_fscale:          return "fscale";          break;
        case x86_fsin:            return "fsin";            break;
        case x86_fsincos:         return "fsincos";         break;
        case x86_fsqrt:           return "fsqrt";           break;
        case x86_fst:             return "fst";             break;
        case x86_fstp:            return "fstp";            break;
        case x86_fsub:            return "fsub";            break;
        case x86_fsubp:           return "fsubp";           break;
        case x86_fsubr:           return "fsubr";           break;
        case x86_fsubrp:          return "fsubrp";          break;
        case x86_ftst:            return "ftst";            break;
        case x86_fucom:           return "fucom";           break;
        case x86_fucomi:          return "fucomi";          break;
        case x86_fucomip:         return "fucomip";         break;
        case x86_fucomp:          return "fucomp";          break;
        case x86_fucompp:         return "fucompp";         break;
        case x86_fwait:           return "fwait";           break;
        case x86_fxam:            return "fxam";            break;
        case x86_fxch:            return "fxch";            break;
        case x86_fxrstor:         return "fxrstor";         break;
        case x86_fxsave:          return "fxsave";          break;
        case x86_fxtract:         return "fxtract";         break;
        case x86_fyl2x:           return "fyl2x";           break;
        case x86_fyl2xp1:         return "fyl2xp1";         break;
        case x86_getsec:          return "getsec";          break;
        case x86_haddpd:          return "haddpd";          break;
        case x86_haddps:          return "haddps";          break;
        case x86_hlt:             return "hlt";             break;
        case x86_hsubpd:          return "hsubpd";          break;
        case x86_hsubps:          return "hsubps";          break;
        case x86_idiv:            return "idiv";            break;
        case x86_imul:            return "imul";            break;
        case x86_in:              return "in";              break;
        case x86_inc:             return "inc";             break;
        case x86_insb:            return "insb";            break;
        case x86_insd:            return "insd";            break;
        case x86_insertps:        return "insertps";        break;
        case x86_insertq:         return "insertq";         break;
        case x86_insw:            return "insw";            break;
        case x86_int:             return "int";             break;
        case x86_int1:            return "int1";            break;
        case x86_int3:            return "int3";            break;
        case x86_into:            return "into";            break;
        case x86_invd:            return "invd";            break;
        case x86_invept:          return "invept";          break;
        case x86_invlpg:          return "invlpg";          break;
        case x86_invlpga:         return "invlpga";         break;
        case x86_invvpid:         return "invvpid";         break;
        case x86_iret:            return "iret";            break;
        case x86_ja:              return "ja";              break;
        case x86_jae:             return "jae";             break;
        case x86_jb:              return "jb";              break;
        case x86_jbe:             return "jbe";             break;
        case x86_jcxz:            return "jcxz";            break;
        case x86_je:              return "je";              break;
        case x86_jecxz:           return "jecxz";           break;
        case x86_jg:              return "jg";              break;
        case x86_jge:             return "jge";             break;
        case x86_jl:              return "jl";              break;
        case x86_jle:             return "jle";             break;
        case x86_jmp:             return "jmp";             break;
        case x86_jmpe:            return "jmpe";            break;
        case x86_jne:             return "jne";             break;
        case x86_jno:             return "jno";             break;
        case x86_jns:             return "jns";             break;
        case x86_jo:              return "jo";              break;
        case x86_jpe:             return "jpe";             break;
        case x86_jpo:             return "jpo";             break;
        case x86_jrcxz:           return "jrcxz";           break;
        case x86_js:              return "js";              break;
        case x86_lahf:            return "lahf";            break;
        case x86_lar:             return "lar";             break;
        case x86_lddqu:           return "lddqu";           break;
        case x86_ldmxcsr:         return "ldmxcsr";         break;
        case x86_lds:             return "lds";             break;
        case x86_lea:             return "lea";             break;
        case x86_leave:           return "leave";           break;
        case x86_les:             return "les";             break;
        case x86_lfence:          return "lfence";          break;
        case x86_lfs:             return "lfs";             break;
        case x86_lgdt:            return "lgdt";            break;
        case x86_lgs:             return "lgs";             break;
        case x86_lidt:            return "lidt";            break;
        case x86_lldt:            return "lldt";            break;
        case x86_lmsw:            return "lmsw";            break;
        case x86_lock:            return "lock";            break;
        case x86_lodsb:           return "lodsb";           break;
        case x86_lodsd:           return "lodsd";           break;
        case x86_lodsq:           return "lodsq";           break;
        case x86_lodsw:           return "lodsw";           break;
        case x86_loop:            return "loop";            break;
        case x86_loopnz:          return "loopnz";          break;
        case x86_loopz:           return "loopz";           break;
        case x86_lsl:             return "lsl";             break;
        case x86_lss:             return "lss";             break;
        case x86_ltr:             return "ltr";             break;
        case x86_lzcnt:           return "lzcnt";           break;
        case x86_maskmovq:        return "maskmovq";        break;
        case x86_maxpd:           return "maxpd";           break;
        case x86_maxps:           return "maxps";           break;
        case x86_maxsd:           return "maxsd";           break;
        case x86_maxss:           return "maxss";           break;
        case x86_mfence:          return "mfence";          break;
        case x86_minpd:           return "minpd";           break;
        case x86_minps:           return "minps";           break;
        case x86_minsd:           return "minsd";           break;
        case x86_minss:           return "minss";           break;
        case x86_monitor:         return "monitor";         break;
        case x86_mov:             return "mov";             break;
        case x86_movapd:          return "movapd";          break;
        case x86_movaps:          return "movaps";          break;
        case x86_movbe:           return "movbe";           break;
        case x86_movd:            return "movd";            break;
        case x86_movddup:         return "movddup";         break;
        case x86_movdq2q:         return "movdq2q";         break;
        case x86_movdqa:          return "movdqa";          break;
        case x86_movdqu:          return "movdqu";          break;
        case x86_movhlps:         return "movhlps";         break;
        case x86_movhpd:          return "movhpd";          break;
        case x86_movhps:          return "movhps";          break;
        case x86_movlhps:         return "movlhps";         break;
        case x86_movlpd:          return "movlpd";          break;
        case x86_movlps:          return "movlps";          break;
        case x86_movmskpd:        return "movmskpd";        break;
        case x86_movmskps:        return "movmskps";        break;
        case x86_movntdq:         return "movntdq";         break;
        case x86_movntdqa:        return "movntdqa";        break;
        case x86_movnti:          return "movnti";          break;
        case x86_movntpd:         return "movntpd";         break;
        case x86_movntps:         return "movntps";         break;
        case x86_movntq:          return "movntq";          break;
        case x86_movntsd:         return "movntsd";         break;
        case x86_movntss:         return "movntss";         break;
        case x86_movq:            return "movq";            break;
        case x86_movq2dq:         return "movq2dq";         break;
        case x86_movsb:           return "movsb";           break;
        case x86_movsd:           return "movsd";           break;
        case x86_movsd_sse:       return "movsd_sse";       break;
        case x86_movshdup:        return "movshdup";        break;
        case x86_movsldup:        return "movsldup";        break;
        case x86_movsq:           return "movsq";           break;
        case x86_movss:           return "movss";           break;
        case x86_movsw:           return "movsw";           break;
        case x86_movsx:           return "movsx";           break;
        case x86_movsxd:          return "movsxd";          break;
        case x86_movupd:          return "movupd";          break;
        case x86_movups:          return "movups";          break;
        case x86_movzx:           return "movzx";           break;
        case x86_mpsadbw:         return "mpsadbw";         break;
        case x86_mul:             return "mul";             break;
        case x86_mulpd:           return "mulpd";           break;
        case x86_mulps:           return "mulps";           break;
        case x86_mulsd:           return "mulsd";           break;
        case x86_mulss:           return "mulss";           break;
        case x86_mwait:           return "mwait";           break;
        case x86_neg:             return "neg";             break;
        case x86_nop:             return "nop";             break;
        case x86_not:             return "not";             break;
        case x86_or:              return "or";              break;
        case x86_orpd:            return "orpd";            break;
        case x86_orps:            return "orps";            break;
        case x86_out:             return "out";             break;
        case x86_outs:            return "outs";            break;
        case x86_outsb:           return "outsb";           break;
        case x86_outsd:           return "outsd";           break;
        case x86_outsw:           return "outsw";           break;
        case x86_pabsb:           return "pabsb";           break;
        case x86_pabsd:           return "pabsd";           break;
        case x86_pabsw:           return "pabsw";           break;
        case x86_packssdw:        return "packssdw";        break;
        case x86_packsswb:        return "packsswb";        break;
        case x86_packusdw:        return "packusdw";        break;
        case x86_packuswb:        return "packuswb";        break;
        case x86_paddb:           return "paddb";           break;
        case x86_paddd:           return "paddd";           break;
        case x86_paddq:           return "paddq";           break;
        case x86_paddsb:          return "paddsb";          break;
        case x86_paddsw:          return "paddsw";          break;
        case x86_paddusb:         return "paddusb";         break;
        case x86_paddusw:         return "paddusw";         break;
        case x86_paddw:           return "paddw";           break;
        case x86_palignr:         return "palignr";         break;
        case x86_pand:            return "pand";            break;
        case x86_pandn:           return "pandn";           break;
        case x86_pause:           return "pause";           break;
        case x86_pavgb:           return "pavgb";           break;
        case x86_pavgusb:         return "pavgusb";         break;
        case x86_pavgw:           return "pavgw";           break;
        case x86_pblendvb:        return "pblendvb";        break;
        case x86_pblendw:         return "pblendw";         break;
        case x86_pcmpeqb:         return "pcmpeqb";         break;
        case x86_pcmpeqd:         return "pcmpeqd";         break;
        case x86_pcmpeqq:         return "pcmpeqq";         break;
        case x86_pcmpeqw:         return "pcmpeqw";         break;
        case x86_pcmpestri:       return "pcmpestri";       break;
        case x86_pcmpestrm:       return "pcmpestrm";       break;
        case x86_pcmpgtb:         return "pcmpgtb";         break;
        case x86_pcmpgtd:         return "pcmpgtd";         break;
        case x86_pcmpgtq:         return "pcmpgtq";         break;
        case x86_pcmpgtw:         return "pcmpgtw";         break;
        case x86_pcmpistri:       return "pcmpistri";       break;
        case x86_pcmpistrm:       return "pcmpistrm";       break;
        case x86_pextrb:          return "pextrb";          break;
        case x86_pextrd:          return "pextrd";          break;
        case x86_pextrq:          return "pextrq";          break;
        case x86_pextrw:          return "pextrw";          break;
        case x86_pf2id:           return "pf2id";           break;
        case x86_pf2iw:           return "pf2iw";           break;
        case x86_pfacc:           return "pfacc";           break;
        case x86_pfadd:           return "pfadd";           break;
        case x86_pfcmpeq:         return "pfcmpeq";         break;
        case x86_pfcmpge:         return "pfcmpge";         break;
        case x86_pfcmpgt:         return "pfcmpgt";         break;
        case x86_pfmax:           return "pfmax";           break;
        case x86_pfmin:           return "pfmin";           break;
        case x86_pfmul:           return "pfmul";           break;
        case x86_pfnacc:          return "pfnacc";          break;
        case x86_pfpnacc:         return "pfpnacc";         break;
        case x86_pfrcp:           return "pfrcp";           break;
        case x86_pfrcpit1:        return "pfrcpit1";        break;
        case x86_pfrcpit2:        return "pfrcpit2";        break;
        case x86_pfrsqit1:        return "pfrsqit1";        break;
        case x86_pfrsqrt:         return "pfrsqrt";         break;
        case x86_pfsub:           return "pfsub";           break;
        case x86_pfsubr:          return "pfsubr";          break;
        case x86_phaddd:          return "phaddd";          break;
        case x86_phaddsw:         return "phaddsw";         break;
        case x86_phaddw:          return "phaddw";          break;
        case x86_phminposuw:      return "phminposuw";      break;
        case x86_phsubd:          return "phsubd";          break;
        case x86_phsubsw:         return "phsubsw";         break;
        case x86_phsubw:          return "phsubw";          break;
        case x86_pi2fd:           return "pi2fd";           break;
        case x86_pi2fw:           return "pi2fw";           break;
        case x86_pinsrb:          return "pinsrb";          break;
        case x86_pinsrd:          return "pinsrd";          break;
        case x86_pinsrq:          return "pinsrq";          break;
        case x86_pinsrw:          return "pinsrw";          break;
        case x86_pmaddubsw:       return "pmaddubsw";       break;
        case x86_pmaddwd:         return "pmaddwd";         break;
        case x86_pmaxsb:          return "pmaxsb";          break;
        case x86_pmaxsd:          return "pmaxsd";          break;
        case x86_pmaxsw:          return "pmaxsw";          break;
        case x86_pmaxub:          return "pmaxub";          break;
        case x86_pmaxud:          return "pmaxud";          break;
        case x86_pmaxuw:          return "pmaxuw";          break;
        case x86_pminsb:          return "pminsb";          break;
        case x86_pminsd:          return "pminsd";          break;
        case x86_pminsw:          return "pminsw";          break;
        case x86_pminub:          return "pminub";          break;
        case x86_pminud:          return "pminud";          break;
        case x86_pminuw:          return "pminuw";          break;
        case x86_pmovmskb:        return "pmovmskb";        break;
        case x86_pmovsxbd:        return "pmovsxbd";        break;
        case x86_pmovsxbq:        return "pmovsxbq";        break;
        case x86_pmovsxbw:        return "pmovsxbw";        break;
        case x86_pmovsxdq:        return "pmovsxdq";        break;
        case x86_pmovsxwd:        return "pmovsxwd";        break;
        case x86_pmovsxwq:        return "pmovsxwq";        break;
        case x86_pmovzxbd:        return "pmovzxbd";        break;
        case x86_pmovzxbq:        return "pmovzxbq";        break;
        case x86_pmovzxbw:        return "pmovzxbw";        break;
        case x86_pmovzxdq:        return "pmovzxdq";        break;
        case x86_pmovzxwd:        return "pmovzxwd";        break;
        case x86_pmovzxwq:        return "pmovzxwq";        break;
        case x86_pmuldq:          return "pmuldq";          break;
        case x86_pmulhrsw:        return "pmulhrsw";        break;
        case x86_pmulhrw:         return "pmulhrw";         break;
        case x86_pmulhuw:         return "pmulhuw";         break;
        case x86_pmulhw:          return "pmulhw";          break;
        case x86_pmulld:          return "pmulld";          break;
        case x86_pmullw:          return "pmullw";          break;
        case x86_pmuludq:         return "pmuludq";         break;
        case x86_pop:             return "pop";             break;
        case x86_popa:            return "popa";            break;
        case x86_popad:           return "popad";           break;
        case x86_popcnt:          return "popcnt";          break;
        case x86_popf:            return "popf";            break;
        case x86_popfd:           return "popfd";           break;
        case x86_popfq:           return "popfq";           break;
        case x86_por:             return "por";             break;
        case x86_prefetch:        return "prefetch";        break;
        case x86_prefetchnta:     return "prefetchnta";     break;
        case x86_prefetcht0:      return "prefetcht0";      break;
        case x86_prefetcht1:      return "prefetcht1";      break;
        case x86_prefetcht2:      return "prefetcht2";      break;
        case x86_prefetchw:       return "prefetchw";       break;
        case x86_psadbw:          return "psadbw";          break;
        case x86_pshufb:          return "pshufb";          break;
        case x86_pshufd:          return "pshufd";          break;
        case x86_pshufhw:         return "pshufhw";         break;
        case x86_pshuflw:         return "pshuflw";         break;
        case x86_pshufw:          return "pshufw";          break;
        case x86_psignb:          return "psignb";          break;
        case x86_psignd:          return "psignd";          break;
        case x86_psignw:          return "psignw";          break;
        case x86_pslld:           return "pslld";           break;
        case x86_pslldq:          return "pslldq";          break;
        case x86_psllq:           return "psllq";           break;
        case x86_psllw:           return "psllw";           break;
        case x86_psrad:           return "psrad";           break;
        case x86_psraq:           return "psraq";           break;
        case x86_psraw:           return "psraw";           break;
        case x86_psrld:           return "psrld";           break;
        case x86_psrldq:          return "psrldq";          break;
        case x86_psrlq:           return "psrlq";           break;
        case x86_psrlw:           return "psrlw";           break;
        case x86_psubb:           return "psubb";           break;
        case x86_psubd:           return "psubd";           break;
        case x86_psubq:           return "psubq";           break;
        case x86_psubsb:          return "psubsb";          break;
        case x86_psubsw:          return "psubsw";          break;
        case x86_psubusb:         return "psubusb";         break;
        case x86_psubusw:         return "psubusw";         break;
        case x86_psubw:           return "psubw";           break;
        case x86_pswapd:          return "pswapd";          break;
        case x86_ptest:           return "ptest";           break;
        case x86_punpckhbw:       return "punpckhbw";       break;
        case x86_punpckhdq:       return "punpckhdq";       break;
        case x86_punpckhqdq:      return "punpckhqdq";      break;
        case x86_punpckhwd:       return "punpckhwd";       break;
        case x86_punpcklbw:       return "punpcklbw";       break;
        case x86_punpckldq:       return "punpckldq";       break;
        case x86_punpcklqdq:      return "punpcklqdq";      break;
        case x86_punpcklwd:       return "punpcklwd";       break;
        case x86_push:            return "push";            break;
        case x86_pusha:           return "pusha";           break;
        case x86_pushad:          return "pushad";          break;
        case x86_pushf:           return "pushf";           break;
        case x86_pushfd:          return "pushfd";          break;
        case x86_pushfq:          return "pushfq";          break;
        case x86_pxor:            return "pxor";            break;
        case x86_rcl:             return "rcl";             break;
        case x86_rcpps:           return "rcpps";           break;
        case x86_rcpss:           return "rcpss";           break;
        case x86_rcr:             return "rcr";             break;
        case x86_rdmsr:           return "rdmsr";           break;
        case x86_rdpmc:           return "rdpmc";           break;
        case x86_rdtsc:           return "rdtsc";           break;
        case x86_rdtscp:          return "rdtscp";          break;
        case x86_rep_insb:        return "rep_insb";        break;
        case x86_rep_insd:        return "rep_insd";        break;
        case x86_rep_insw:        return "rep_insw";        break;
        case x86_rep_lodsb:       return "rep_lodsb";       break;
        case x86_rep_lodsd:       return "rep_lodsd";       break;
        case x86_rep_lodsq:       return "rep_lodsq";       break;
        case x86_rep_lodsw:       return "rep_lodsw";       break;
        case x86_rep_movsb:       return "rep_movsb";       break;
        case x86_rep_movsd:       return "rep_movsd";       break;
        case x86_rep_movsq:       return "rep_movsq";       break;
        case x86_rep_movsw:       return "rep_movsw";       break;
        case x86_rep_outsb:       return "rep_outsb";       break;
        case x86_rep_outsd:       return "rep_outsd";       break;
        case x86_rep_outsw:       return "rep_outsw";       break;
        case x86_rep_stosb:       return "rep_stosb";       break;
        case x86_rep_stosd:       return "rep_stosd";       break;
        case x86_rep_stosq:       return "rep_stosq";       break;
        case x86_rep_stosw:       return "rep_stosw";       break;
        case x86_repe_cmpsb:      return "repe_cmpsb";      break;
        case x86_repe_cmpsd:      return "repe_cmpsd";      break;
        case x86_repe_cmpsq:      return "repe_cmpsq";      break;
        case x86_repe_cmpsw:      return "repe_cmpsw";      break;
        case x86_repe_scasb:      return "repe_scasb";      break;
        case x86_repe_scasd:      return "repe_scasd";      break;
        case x86_repe_scasq:      return "repe_scasq";      break;
        case x86_repe_scasw:      return "repe_scasw";      break;
        case x86_repne_cmpsb:     return "repne_cmpsb";     break;
        case x86_repne_cmpsd:     return "repne_cmpsd";     break;
        case x86_repne_cmpsq:     return "repne_cmpsq";     break;
        case x86_repne_cmpsw:     return "repne_cmpsw";     break;
        case x86_repne_scasb:     return "repne_scasb";     break;
        case x86_repne_scasd:     return "repne_scasd";     break;
        case x86_repne_scasq:     return "repne_scasq";     break;
        case x86_repne_scasw:     return "repne_scasw";     break;
        case x86_ret:             return "ret";             break;
        case x86_retf:            return "retf";            break;
        case x86_rol:             return "rol";             break;
        case x86_ror:             return "ror";             break;
        case x86_roundpd:         return "roundpd";         break;
        case x86_roundps:         return "roundps";         break;
        case x86_roundsd:         return "roundsd";         break;
        case x86_roundss:         return "roundss";         break;
        case x86_rsm:             return "rsm";             break;
        case x86_rsqrtps:         return "rsqrtps";         break;
        case x86_rsqrtss:         return "rsqrtss";         break;
        case x86_sahf:            return "sahf";            break;
        case x86_salc:            return "salc";            break;
        case x86_sar:             return "sar";             break;
        case x86_sbb:             return "sbb";             break;
        case x86_scasb:           return "scasb";           break;
        case x86_scasd:           return "scasd";           break;
        case x86_scasq:           return "scasq";           break;
        case x86_scasw:           return "scasw";           break;
        case x86_seta:            return "seta";            break;
        case x86_setae:           return "setae";           break;
        case x86_setb:            return "setb";            break;
        case x86_setbe:           return "setbe";           break;
        case x86_sete:            return "sete";            break;
        case x86_setg:            return "setg";            break;
        case x86_setge:           return "setge";           break;
        case x86_setl:            return "setl";            break;
        case x86_setle:           return "setle";           break;
        case x86_setne:           return "setne";           break;
        case x86_setno:           return "setno";           break;
        case x86_setns:           return "setns";           break;
        case x86_seto:            return "seto";            break;
        case x86_setpe:           return "setpe";           break;
        case x86_setpo:           return "setpo";           break;
        case x86_sets:            return "sets";            break;
        case x86_sfence:          return "sfence";          break;
        case x86_sgdt:            return "sgdt";            break;
        case x86_shl:             return "shl";             break;
        case x86_shld:            return "shld";            break;
        case x86_shr:             return "shr";             break;
        case x86_shrd:            return "shrd";            break;
        case x86_shufpd:          return "shufpd";          break;
        case x86_shufps:          return "shufps";          break;
        case x86_sidt:            return "sidt";            break;
        case x86_skinit:          return "skinit";          break;
        case x86_sldt:            return "sldt";            break;
        case x86_smsw:            return "smsw";            break;
        case x86_sqrtpd:          return "sqrtpd";          break;
        case x86_sqrtps:          return "sqrtps";          break;
        case x86_sqrtsd:          return "sqrtsd";          break;
        case x86_sqrtss:          return "sqrtss";          break;
        case x86_stc:             return "stc";             break;
        case x86_std:             return "std";             break;
        case x86_stgi:            return "stgi";            break;
        case x86_sti:             return "sti";             break;
        case x86_stmxcsr:         return "stmxcsr";         break;
        case x86_stos:            return "stos";            break;
        case x86_stosb:           return "stosb";           break;
        case x86_stosd:           return "stosd";           break;
        case x86_stosq:           return "stosq";           break;
        case x86_stosw:           return "stosw";           break;
        case x86_str:             return "str";             break;
        case x86_sub:             return "sub";             break;
        case x86_subpd:           return "subpd";           break;
        case x86_subps:           return "subps";           break;
        case x86_subsd:           return "subsd";           break;
        case x86_subss:           return "subss";           break;
        case x86_swapgs:          return "swapgs";          break;
        case x86_syscall:         return "syscall";         break;
        case x86_sysenter:        return "sysenter";        break;
        case x86_sysexit:         return "sysexit";         break;
        case x86_sysret:          return "sysret";          break;
        case x86_test:            return "test";            break;
        case x86_ucomisd:         return "ucomisd";         break;
        case x86_ucomiss:         return "ucomiss";         break;
        case x86_ud2:             return "ud2";             break;
        case x86_unpckhpd:        return "unpckhpd";        break;
        case x86_unpckhps:        return "unpckhps";        break;
        case x86_unpcklpd:        return "unpcklpd";        break;
        case x86_unpcklps:        return "unpcklps";        break;
        case x86_verr:            return "verr";            break;
        case x86_verw:            return "verw";            break;
        case x86_vmcall:          return "vmcall";          break;
        case x86_vmclear:         return "vmclear";         break;
        case x86_vmlaunch:        return "vmlaunch";        break;
        case x86_vmload:          return "vmload";          break;
        case x86_vmmcall:         return "vmmcall";         break;
        case x86_vmoff:           return "vmoff";           break;
        case x86_vmptrld:         return "vmptrld";         break;
        case x86_vmptrst:         return "vmptrst";         break;
        case x86_vmread:          return "vmread";          break;
        case x86_vmresume:        return "vmresume";        break;
        case x86_vmrun:           return "vmrun";           break;
        case x86_vmsave:          return "vmsave";          break;
        case x86_vmwrite:         return "vmwrite";         break;
        case x86_vmxoff:          return "vmxoff";          break;
        case x86_vmxon:           return "vmxon";           break;
        case x86_wait:            return "wait";            break;
        case x86_wbinvd:          return "wbinvd";          break;
        case x86_wrmsr:           return "wrmsr";           break;
        case x86_xadd:            return "xadd";            break;
        case x86_xchg:            return "xchg";            break;
        case x86_xgetbv:          return "xgetbv";          break;
        case x86_xlatb:           return "xlatb";           break;
        case x86_xor:             return "xor";             break;
        case x86_xorpd:           return "xorpd";           break;
        case x86_xorps:           return "xorps";           break;
        case x86_xrstor:          return "xrstor";          break;
        case x86_xsave:           return "xsave";           break;
        case x86_xsetbv:          return "xsetbv";          break;
        default: abort(); //should not happen since this is machine generated!
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                       D O   N O T   E D I T                                                      //
//------------------------------------------------------------------------------------------------------------------//
//                                                                                                                  //
// This file was generated automatically from Intel PDF documentation. Its purpose is to intialize the ROSE x86     //
// assembler with information about how to encode each x86 instruction.                                             //
//                                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
