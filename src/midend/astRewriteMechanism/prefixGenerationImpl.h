#ifndef AST_REWRITE_PREFIX_GENERATION_C
#define AST_REWRITE_PREFIX_GENERATION_C

#include "rewrite.h"

template <class ASTNodeCollection>
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
PrefixSuffixGenerationTraversal ( bool inputGenerateIncludeDirectives )
   : generateIncludeDirectives(inputGenerateIncludeDirectives)
   {
  // Variable to help us recognise when we change scopes during the reverse traversal
     previousScope = nullptr;

  // Keep track of the number of #if and #endif so that they match up 
  // (force them to match up by adding a trailing #endif if required).
     openingIfCounter    = 0;
     closingEndifCounter = 0;
   }

template <class ASTNodeCollection>
typename MidLevelRewrite<ASTNodeCollection>::PrefixInheritedAttribute
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
evaluateInheritedAttribute (
     SgNode* astNode,
     typename MidLevelRewrite<ASTNodeCollection>::PrefixInheritedAttribute inputInheritedAttribute )
   {
  // This function is called for each node in the AST that would be generated by the reverse traversal
  // The work is divided into two parts:
  //    1) Adding the current statment to the current scope
  //       a) only prefix relavant statements are added
  //          * declarations
  //          * comments and preprocessor directives are collected from all statements
  //       b) only statements from the current file are collected unless (generateIncludeDirectives == true)
  //    2) The setup of the scope
  //       a) leaving the current scope alone
  //       b) pushing a new scope onto the stack of scopes

#undef PRINT_DEBUGGING_INFO

#ifdef _MSC_VER
#define PRINT_DEBUGGING_INFO 0
#else
#define PRINT_DEBUGGING_INFO false
#endif

     ASSERT_not_null(previousScope);

  // Setup the current scope
     SgStatement* currentStatement = isSgStatement(astNode);
     if (currentStatement != nullptr)
        {
       // The global scope is unconditionally pushed onto the stack of scopes so don't do it here.
       // A few other scope statements don't generate "{}" parings (generally because the basic 
       // block contained within them generates the "{}" and only one pair is required.
          if ( isSgFunctionParameterList(currentStatement) == nullptr &&
               isSgCatchOptionStmt(currentStatement) == nullptr &&
               isSgGlobal(currentStatement) == nullptr )
             {
            // Skip the SgFunctionParameterList statement since unparsing
            // the function declaration will generate parameter list

               std::string targetFilename      = Rose::getFileNameByTraversalBackToFileNode(currentStatement);

            // DQ (7/19/2005):
            // Within: "int y; switch(x){case 0:{y++;break;}default:{y++;break;}}"
            // Note that processing of "y++;" requires construction of declaration of "int y;" in the prefix, 
            // but we must handle the case where the declaration of "int y;" is a part of a previous 
            // transformation, so file equality is an insufficent test for inclusion of declarations 
            // within the prefix. Since the previous transformation marked the startement as a transformation
            // the filename returned is incorrect.
               std::string declarationFilename;
               if (currentStatement->get_file_info()->isTransformation() == true)
                  {
                    declarationFilename = targetFilename;
                  }
                 else
                  {
                    declarationFilename = currentStatement->get_file_info()->get_filename();
                  }

            // Check if the current statment is located in the current file
               if ( generateIncludeDirectives == false || declarationFilename == targetFilename )
                  {
#if PRINT_DEBUGGING_INFO
                    printf ("Found a statement important to the prefix mechanism currentScope.size() = %" PRIuPTR " \n",currentScope.size());
#endif

                    bool qualifiedScopeStatement =
                         isSgScopeStatement(currentStatement) != nullptr &&
                         isSgFunctionDefinition(currentStatement) == nullptr;
                    bool basicBlockPartOfFunctionDefinition =
                         isSgBasicBlock(currentStatement) != nullptr &&
                         isSgFunctionDefinition(currentStatement->get_scope()) != nullptr;
                    bool basicBlockPartOfSwitchStatement =
                         isSgBasicBlock(currentStatement) != nullptr &&
                         isSgSwitchStatement(currentStatement->get_scope()) != nullptr;

                    bool basicBlockPartOfForStatement =
                         isSgBasicBlock(currentStatement) != nullptr &&
                         isSgForStatement(currentStatement->get_parent()) != nullptr;

                    bool qualifiedOtherStatement = (isSgFunctionDeclaration(currentStatement) != nullptr) ||
                                                   (isSgClassDeclaration(currentStatement)    != nullptr) ||
                                                   (isSgCaseOptionStmt(currentStatement)      != nullptr) ||
                                                   (isSgDefaultOptionStmt(currentStatement)   != nullptr);

                    bool qualifiedStatement = 
                         !basicBlockPartOfFunctionDefinition &&
                         !basicBlockPartOfSwitchStatement &&
                      // DQ (8/8/2005): Added case to eliminate redundent scopes for for loops
                         !basicBlockPartOfForStatement &&
                         (qualifiedScopeStatement || qualifiedOtherStatement);

                    SgScopeStatement* currentStatementScope  = isSgScopeStatement(currentStatement->get_scope());
                    ASSERT_not_null(currentStatementScope);
                    ASSERT_not_null(previousScope);

                    bool isInNestedScope = false;
                    SgScopeStatement* tempScope = currentStatementScope;
#if PRINT_DEBUGGING_INFO
                    printf ("Initial tempScope = %s \n",tempScope->sage_class_name());
#endif
                    while (tempScope != nullptr && tempScope->variantT() != V_SgGlobal && tempScope != previousScope)
                       {
                         tempScope = tempScope->get_scope();
#if PRINT_DEBUGGING_INFO
                         printf ("New tempScope = %s \n",tempScope->sage_class_name());
#endif
                       }
#if PRINT_DEBUGGING_INFO
                    printf ("Final tempScope = %s previousScope = %s \n",tempScope->sage_class_name(),previousScope->sage_class_name());
#endif
                    if (tempScope != previousScope)
                       {
#if PRINT_DEBUGGING_INFO
                         printf ("Setting isInNestedScope = true \n");
#endif
                         isInNestedScope = true;
                       }

#if PRINT_DEBUGGING_INFO
                    printf ("previousScope = %p previousScope = %s previousScope = %s \n",
                         previousScope,previousScope->sage_class_name(),previousScope->unparseToString().c_str());
                    printf ("currentStatementScope = %p currentStatementScope = %s currentStatementScope = %s \n",
                         currentStatementScope,currentStatementScope->sage_class_name(),currentStatementScope->unparseToString().c_str());

                    printf ("isInNestedScope                    = %s \n",isInNestedScope ? "true" : "false");
                    printf ("qualifiedScopeStatement            = %s \n",qualifiedScopeStatement ? "true" : "false");
                    printf ("basicBlockPartOfFunctionDefinition = %s \n",basicBlockPartOfFunctionDefinition ? "true" : "false");
                    printf ("basicBlockPartOfSwitchStatement    = %s \n",basicBlockPartOfSwitchStatement ? "true" : "false");
                    printf ("qualifiedOtherStatement            = %s \n",qualifiedOtherStatement ? "true" : "false");
                    printf ("qualifiedStatement                 = %s \n",qualifiedStatement      ? "true" : "false");
#endif
                    if ( /* (currentScope.size() >= 0) && */ (qualifiedStatement == true) && (isInNestedScope == true) )
                       {
#if PRINT_DEBUGGING_INFO
                         printf ("$$$$$ Push a new scope! currentStatement = %s currentStatement = %s stackOfScopes.size() = %" PRIuPTR " currentScope.size() = %" PRIuPTR " $$$$$ \n",
                              currentStatementScope->sage_class_name(),
                              currentStatement->unparseToString().c_str(),
                              stackOfScopes.size(),currentScope.size());
                         display(currentScope,"Push Current scope: BEFORE");
#endif

                         stackOfScopes.push(currentScope);

#if PRINT_DEBUGGING_INFO
                         printf ("View the stackOfScopes! stackOfScopes.size() = %" PRIuPTR " \n",stackOfScopes.size());
                         display(stackOfScopes,"Push Current scope: AFTER");
#endif
                      // Empty the current scope stack so that it can be used
                      // to accumulate new statements for the next scope.
                         currentScope.erase(currentScope.begin(),currentScope.end());
                         ASSERT_require(currentScope.size() == 0);

                      // reset the previousStatement pointer used to recognize when the scopes are changed
                         previousScope = currentStatement->get_scope();
                       }
#if PRINT_DEBUGGING_INFO
                      else
                       {
                         printf ("$$$$$$$$$$$$$$$$  Skipped pushing current scope  $$$$$$$$$$$$$$$$ \n");
                       }
#endif
                    bool isCaseOrDefaultOptionStatement = (isSgCaseOptionStmt(currentStatement) != nullptr) ||
                                                          (isSgDefaultOptionStmt(currentStatement) != nullptr);
                    bool includeInPrefix = (isInNestedScope) || isCaseOrDefaultOptionStatement;
                    DeclarationOrCommentListElement listElement (currentStatement,includeInPrefix);

#if PRINT_DEBUGGING_INFO
                    printf ("isCaseOrDefaultOptionStatement = %s \n",isCaseOrDefaultOptionStatement ? "true" : "false");
                    printf ("includeInPrefix                = %s \n",includeInPrefix ? "true" : "false");
                    listElement.display("Element being pushed onto current scope");
#endif
                    if (listElement.isValidDeclarationOrCommentListElement() == true)
                       {
                         currentScope.push_front(listElement);
#if PRINT_DEBUGGING_INFO
                         printf ("Pushed statement onto the currentScope: currentScope.size() = %d [%s] \n",
                              currentScope.size(),currentStatement->unparseToString().c_str());
#endif
                       }
#if PRINT_DEBUGGING_INFO
                      else
                       {
                         printf ("Skipped push of current statement onto current scope currentScope.size() = %d [%s] \n",
                              currentScope.size(),currentStatement->unparseToString().c_str());
                       }
#endif
                  }
#if PRINT_DEBUGGING_INFO
                 else
                  {
                    printf ("Not an important statement to prefix: generateIncludeDirectives == true && declarationFilename != targetFilename \n");
                  }
#endif
             }
#if PRINT_DEBUGGING_INFO
            else
             {
               printf ("Skipping addition of this statement to the current scope (%s) \n",currentStatement->sage_class_name());
             }
#endif

          if (isSgGlobal(currentStatement) != nullptr)
             {
            // push current scope onto stack of scopes (even if size == 0,
            // since top of stack is defined to be the global scope).

               stackOfScopes.push(currentScope);

#if PRINT_DEBUGGING_INFO
               printf ("Pushed global scope onto the stack stackOfScopes.size() = %" PRIuPTR " \n",stackOfScopes.size());
#endif
            // Empty the current scope stack so that it can be used
            // to accumulate new statements for the next scope.
               currentScope.erase(currentScope.begin(),currentScope.end());
             }

#if PRINT_DEBUGGING_INFO
          char buffer[256];
          snprintf (buffer,sizeof(buffer),"At base of evaluateInheritedAttribute: stackOfScopes.size() = %" PRIuPTR "",stackOfScopes.size());
          std::string displayString = buffer;
          display(displayString);

          printf ("################################ BASE ################################## \n");
#endif
        }

#if PRINT_DEBUGGING_INFO
     printf ("Leaving evaluateInheritedAttribute(): stackOfScopes.size() = %" PRIuPTR " \n",stackOfScopes.size());
#endif

     return inputInheritedAttribute;
   }

template <class ASTNodeCollection>
typename MidLevelRewrite<ASTNodeCollection>::PrefixSynthesizedAttribute
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
evaluateSynthesizedAttribute (
     SgNode*,
     typename MidLevelRewrite<ASTNodeCollection>::PrefixInheritedAttribute,
     typename MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::SynthesizedAttributesList)
   {
     return PrefixSynthesizedAttribute();
   }


template <class ASTNodeCollection>
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::DeclarationOrCommentListElement::
DeclarationOrCommentListElement ( SgStatement* astNode, bool includeInPrefix )
   {
  // If the astNode is in the same scope as a previous statement then 
  // don't save this node as a prefixStatement.

     prefixStatement = nullptr;
     comments        = astNode->getAttachedPreprocessingInfo();

     originatingStatement = astNode;
     ASSERT_not_null(originatingStatement);

  // Handle simple case of if the node is a declaration
     SgDeclarationStatement* declaration = isSgDeclarationStatement(astNode);
     if (declaration != nullptr)
        {
          prefixStatement = declaration;
        }
       else
        {
       // Handle more complex case of it node is not a declaration
          if ( includeInPrefix == true )
             {
               switch (astNode->variantT())
                  {
                 // Scope statements
                    case V_SgSwitchStatement:
                    case V_SgForStatement:
                    case V_SgWhileStmt:
                    case V_SgDoWhileStmt:
                    case V_SgIfStmt:
                    case V_SgCatchOptionStmt:
                         prefixStatement = astNode;
                         break;

                 // Other statements
                    case V_SgCaseOptionStmt:
                    case V_SgDefaultOptionStmt:
                         prefixStatement = astNode;
                         break;

                    default:
                         break;
                  }
             }
        }
   }

template <class ASTNodeCollection>
bool 
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::DeclarationOrCommentListElement::
isValidDeclarationOrCommentListElement() const
   {
     return ((prefixStatement != nullptr) || (comments != nullptr)) ? true : false;
   }

// DQ (3/28/2006): declaration required by g++ 3.4.x and 4.x compilers)
std::string unparseDeclarationToString ( SgDeclarationStatement* declaration, bool unparseAsDeclaration);
std::string unparseStatementWithoutBasicBlockToString ( SgStatement* statement );
std::string unparseScopeStatementWithoutBasicBlockToString ( SgScopeStatement* scope );

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::DeclarationOrCommentListElement::
generateString( 
     int & openingIfCounter, 
     int & closingEndifCounter , 
     bool generateIncludeDirectives, 
     bool skipTrailingDirectives,
     bool unparseAsDeclaration )
   {
     printf ("In DeclarationOrCommentListElement::generateString(): \n");
     printf ("     openingIfCounter          = %d \n",openingIfCounter);
     printf ("     closingEndifCounter       = %d \n",closingEndifCounter);
     printf ("     generateIncludeDirectives = %s \n",generateIncludeDirectives ? "true" : "false");
     printf ("     skipTrailingDirectives    = %s \n",skipTrailingDirectives ? "true" : "false");
     printf ("     unparseAsDeclaration      = %s \n",unparseAsDeclaration ? "true" : "false");

     std::string returnString;

  // If we only have a comment, then the declaration pointer is NULL!
     if (prefixStatement != nullptr)
        {
       // Handle the different sorts of statements that contribute to
       // the context info contained in the final prefix
          printf ("     prefixStatement           = %s \n",prefixStatement->sage_class_name());
          SgDeclarationStatement* declaration = isSgDeclarationStatement(prefixStatement);
          if (declaration != nullptr)
             {
            // DQ (1/7/2004): New version of EDG (ver 3.3) normalizes member function definitions when 
            // they appear in a class declaration where the class is  declaration in global scope.  
            // It builds only a member function declaration in place of the definition and builds 
            // a member function definition in the global scope.  This is equivalent semanticly, 
            // but not structurally (syntacticly).  This effects the prefix generation and the fix 
            // is to non generate the declaration of member functions within global scope.
               SgMemberFunctionDeclaration *memberFuctionDeclaration = 
                    isSgMemberFunctionDeclaration(prefixStatement);

               if (memberFuctionDeclaration != nullptr)
                  {
                    ASSERT_not_null(memberFuctionDeclaration->get_parent());
                    printf ("In generateString(): memberFuctionDeclaration->get_parent() = %s \n",
                         memberFuctionDeclaration->get_parent()->sage_class_name());
                  }

            // DQ (12/5/2004): Even in the case of a member function we might not want to unparse it except as a declaration!
               if ( (memberFuctionDeclaration != nullptr) &&
                    (unparseAsDeclaration == true) )
                  {
                    returnString = "/* skipped member function declaration in global scope */";
                  }
                 else
                  {
                    returnString = unparseDeclarationToString(declaration,unparseAsDeclaration);
                  }
             }
            else
             {
               SgScopeStatement* scope = isSgScopeStatement(prefixStatement);
               if (scope != nullptr)
                  {
                 // Unparse scope statements without their body (without SgBasicBlock)
                    returnString = unparseScopeStatementWithoutBasicBlockToString(scope);
                  }
                 else
                  {
                 // Other statements (e.g. SgCaseOptionStmt and SgDefaultOptionStmt)
                    SgStatement* statement = isSgStatement(prefixStatement);
                    ASSERT_not_null(statement);
                    returnString = unparseStatementWithoutBasicBlockToString(statement);
                  }
             }
        }

     printf ("     After prefix statement processing: returnString = %s \n",returnString.c_str());
     ASSERT_not_null(originatingStatement);

  // Don't prepend or append comments
     if (generateIncludeDirectives == true && comments != nullptr)
        {
       // DQ (2/3/2004): prefixDesign.txt shows the counter example for why we can't ignore 
       // more than comments if we are processing #include directives.  The same applies for 
       // #define directives as well.  Thus is we are to support #include or #define directives 
       // then we have to get all the other related (dependent) directive processing correct 
       // as well.

          std::string commentPrefix;
          std::string commentSuffix;
          AttachedPreprocessingInfoType::iterator j;
          for (j = comments->begin(); j != comments->end(); j++)
             {
               ASSERT_not_null(*j);
            // We have to keep track of any open #if #endif pairings and make sure 
            // that they match of the the remaining #if gts closed off with an #endif
            // But we only want ot count directives that are NOT skipped
               if ((*j)->getRelativePosition() == PreprocessingInfo::before || (skipTrailingDirectives == false))
                  {
                    switch ( (*j)->getTypeOfDirective() )
                       {
                         case PreprocessingInfo::CpreprocessorIfDeclaration:
                         case PreprocessingInfo::CpreprocessorDeadIfDeclaration:
                         case PreprocessingInfo::CpreprocessorIfdefDeclaration:
                         case PreprocessingInfo::CpreprocessorIfndefDeclaration:
                              openingIfCounter++;
                              break;
                         case PreprocessingInfo::CpreprocessorEndifDeclaration:
          
                              closingEndifCounter++;
                              break;

                      // these don't count to force an increment of the openingIfCounter
                         case PreprocessingInfo::CpreprocessorElseDeclaration:

                         case PreprocessingInfo::CpreprocessorElifDeclaration:
                         default:
                              break;
                       }
                  }

               // AS Since Wave is a full preprocessor all the PreprocessorInfo with directive type
               // PreprocessingInfo::CpreprocessorIncludeDeclaration is actually the include files
               //included in this project. For non-wave ROSE all include directives in the code is
               //attached as such a PreprocessingInfo object, so therefore we have to support all
               //other PreprocessingInfo objects as well (see prefixDesign.txt).
               //PS! If we need to support all the other preprocessor directives it is just to remove
               //the #ifndef USE_ROSE_BOOST_WAVE_SUPPORT #endif pairs for the Wave work.

            // Only use the CPP directive in certain cases (ignore comments, etc.)
               if ( (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorIncludeDeclaration 
                 || (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorDefineDeclaration  ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorUndefDeclaration   ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorIfdefDeclaration   ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorIfndefDeclaration  ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorIfDeclaration      ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorElseDeclaration    ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorElifDeclaration    ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::CpreprocessorEndifDeclaration   ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::ClinkageSpecificationStart      ||
                    (*j)->getTypeOfDirective() == PreprocessingInfo::ClinkageSpecificationEnd 
                    || (*j)->getTypeOfDirective() == PreprocessingInfo::CSkippedToken
                    )
                  {
                    if ((*j)->getRelativePosition() == PreprocessingInfo::before)
                       {
                      // The prefix does not need to be preceeded by a "\n" since they come first
                         commentPrefix += (*j)->getString();
                       }
                      else
                       {
                         if (skipTrailingDirectives == false)
                            {
                              commentSuffix += (*j)->getString();
                            }
                       }
                  }
             }

       // If we have a meaningful suffix to add (directives) then make sure it starts on a new line
          if (commentSuffix.length() > 0)
               commentSuffix = std::string("\n") + commentSuffix;

          returnString = commentPrefix + returnString + commentSuffix;
        }

     return returnString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generatePrefixString()
   {
  // This function generates a string by calling the functions to generate 
  // the global declarations and the local declarations and concatinating 
  // them together.

     std::string prefixString;
     prefixString += generatePrefixStringGlobalDeclarations();
     prefixString += generatePrefixStringLocalDeclarations();

     return prefixString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generatePrefixStringFromStatementList(
     ListOfStatementsType & statementList,
     bool skipStatementListTrailingDirectives, 
     bool containsAdditionalScopes )
   {
     std::string scopePrefixString;

  // Make a copy to avoid distroying the original list
     ListOfStatementsType tempList = statementList;
     const int lastDeclarationIndex = tempList.size()-1;
     int declarationCounter = 0;

     typename ListOfStatementsType::iterator lastDeclaration = tempList.end();
     for (typename ListOfStatementsType::iterator j = tempList.begin(); j != tempList.end(); j++)
        {
          if ( containsAdditionalScopes && (*j).prefixStatement != nullptr )
             {
               lastDeclaration = j;
             }
        }

     for (typename ListOfStatementsType::iterator i = tempList.begin(); i != tempList.end(); i++)
        {
       // Check for last declaration is the list and unparse without ";" if 
       // it is a function, otherwise unparse as a regular declaration
          bool unparseAsDeclaration = ( i == lastDeclaration ) ? false : true;

       // Skip all trailing directives on the last element of each list (except maybe the last one)
          bool skipTrailingDirectives = ( skipStatementListTrailingDirectives &&
                                          (declarationCounter == lastDeclarationIndex) );
          std::string declarationString = (*i).generateString(openingIfCounter,closingEndifCounter,
                                                         generateIncludeDirectives,skipTrailingDirectives,
                                                         unparseAsDeclaration);

          printf ("declarationCounter = %d declarationString = %s \n",declarationCounter,declarationString.c_str());
          scopePrefixString += declarationString + " \n";
          declarationCounter++;
        }

     return scopePrefixString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generateEndifForPrefixString(
    )
   {
  // The name of this function should be changed from generateEndifForPrefixString 
  // to generateDirectivesForPrefixString.

     std::string prefixString;

#if PRINT_DEBUGGING_INFO
     printf ("In generateEndifForPrefixString(): openingIfCounter = %d closingEndifCounter = %d \n",
          openingIfCounter,closingEndifCounter);
#endif

  // Add a trailing set of #endif directives if the #if and #endif directive counters don't match
     if (openingIfCounter != closingEndifCounter)
        {
          int numberOfOpeningIfDirectives    = closingEndifCounter - openingIfCounter;
          int numberOfClosingEndifDirectives = -numberOfOpeningIfDirectives;

          ASSERT_require(numberOfOpeningIfDirectives < 0);
          ASSERT_require(numberOfClosingEndifDirectives > 0);

       // Add any require #endif directives
          for (int i = 0; i < numberOfClosingEndifDirectives; i++)
             {
               if (i==0)
                    prefixString += "\n// Prefix generated matching endif\n#endif\n";
                 else
                    prefixString += "// Prefix generated matching endif\n#endif\n";

               closingEndifCounter++;
             }
        }

     return prefixString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generatePrefixStringGlobalDeclarations()
   {
     std::string globalPrefixString;

  // We need to handle the case of a prefix generated for SgGlobal 
  // (in which case the stack of scopes is empty!).  

     if (stackOfScopes.size() > 0)
        {
          ASSERT_require(stackOfScopes.size() > 0);

          StackOfListsType tempStack = stackOfScopes;
          int stackCounter = 0;
          int stackSize = tempStack.size();
          int lastScopeIndex = stackSize-1;
          bool skipStatementListTrailingDirectives = stackCounter < lastScopeIndex;

       // If additional scopes are included then the last declaration will be treated 
       // as a function declaration instead of a function prototype (with the next 
       // scopes "{ }" defining the function).
          bool containsAdditionalScopes = (stackSize > 1) ? true : false;

          ListOfStatementsType globalScopeList = tempStack.top();
          globalPrefixString = generatePrefixStringFromStatementList (
                                    globalScopeList,skipStatementListTrailingDirectives,
                                    containsAdditionalScopes);

       // DQ (2/2/2004): Only call this once to avoid premature generation of #endif
          globalPrefixString += generateEndifForPrefixString ( /* openingIfCounter,closingEndifCounter */ );
        }

     return globalPrefixString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generatePrefixStringLocalDeclarations()
   {
     std::string localPrefixString;

  // We need to handle the case of a prefix generated for SgGlobal 
  // (in which case the stack of scopes is empty!).  

     if (stackOfScopes.size() > 1)
        {
       // Make a copy of the stack to avoid distroying it while traversing it
          StackOfListsType tempStack = stackOfScopes;
          int stackSize = tempStack.size();
          int stackCounter = 0;

       // Pop off the global scope (which is on top of the stack)
          ASSERT_require(tempStack.size() > 0);
          tempStack.pop();
          stackSize--;

          int lastScopeIndex = tempStack.size()-1;
          for (int j=0; j < stackSize; j++)
             {
               ListOfStatementsType tempList = tempStack.top();
               bool skipStatementListTrailingDirectives = stackCounter < lastScopeIndex;
               bool containsAdditionalScopes = stackCounter < lastScopeIndex;

               char buffer[128] = "";
               snprintf (buffer,sizeof(buffer),"\n{ /* local stack #%d */ \n",j);

               localPrefixString += std::string(buffer);
               localPrefixString += generatePrefixStringFromStatementList (
                                         tempList,skipStatementListTrailingDirectives,
                                         containsAdditionalScopes);

               stackCounter++;
               tempStack.pop();
             }
        }

     return localPrefixString;
   }

template <class ASTNodeCollection>
std::string
MidLevelRewrite<ASTNodeCollection>::PrefixSuffixGenerationTraversal::
generateSuffixString()
   {
     std::string suffixString;
     int lastScopeIndex = stackOfScopes.size()-0;

     for (int i = 1; i < lastScopeIndex; i++)
        {
       // DQ (11/23/2003): Added ";" to close off class declararation statements
       //                  (for new code specificed as part of a class declaration).
          suffixString += "   };  ";
        }

     return suffixString;
   }

#endif

















