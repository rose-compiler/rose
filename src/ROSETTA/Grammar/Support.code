# Support functions for definition of C++ grammar (SAGE 3)

HEADER_START
  // DQ (4/13/2004): Make the copy constructor parameter a const ref instead of just ref parameter
  // previously was protected so it couldn't be used (too easily).
     private:
          $CLASSNAME(const $CLASSNAME &); /* private so it can't be used. */
          $CLASSNAME & operator= ( const $CLASSNAME & X );
HEADER_END


// ****************************************************
// ************ Support for Graph IR nodes ************ 
// ****************************************************
HEADER_GRAPH_PREDECLARATION_START

#if 0
// Required for Boost Spanning Tree support.
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/kruskal_min_spanning_tree.hpp>
#endif
/*!
    Doxygen documentation for graph class (should maybe be put with the rest of the
doxygen documentation in docs/testDoxygen directory instead).


*/
HEADER_GRAPH_PREDECLARATION_END

HEADER_OMP_CLAUSE_START
	/*!\brief  OpenMP default clause values
       */

       // Liao (5/30/2009): Added support for reduction clauses within an OpenMP directive
	enum omp_default_option_enum{
	  e_omp_default_unkown =0,
	  //4 values for default clause
	  //C/C++ default values
	  e_omp_default_none,
	  e_omp_default_shared,
	  //Fortran default values
	  e_omp_default_private,
	  e_omp_default_firstprivate,
	  e_omp_default_last
	};

        enum omp_schedule_kind_enum{
          e_omp_schedule_unkown=0,
          e_omp_schedule_static,
          e_omp_schedule_dynamic,
          e_omp_schedule_guided,
          e_omp_schedule_auto,
          e_omp_schedule_runtime,
          e_omp_schedule_last
        };

        enum omp_reduction_operator_enum
        {
            e_omp_reduction_unkown,
            // reduction operations
            //8 operand for C/C++
             //  shared 3 common operators for both C and Fortran
            e_omp_reduction_plus, //+
            e_omp_reduction_mul,  //*
            e_omp_reduction_minus, // -
        
            e_omp_reduction_bitand, // &
            e_omp_reduction_bitor,  // |
            e_omp_reduction_bitxor,  // ^
            e_omp_reduction_logand,  // &&
            e_omp_reduction_logor,   // ||
        
            e_omp_reduction_and, // .and.
            e_omp_reduction_or, // .or.
            e_omp_reduction_eqv,   // fortran .eqv.
            e_omp_reduction_neqv,   // fortran .neqv.
            e_omp_reduction_max,
            e_omp_reduction_min,
            e_omp_reduction_iand,
            e_omp_reduction_ior,
            e_omp_reduction_ieor,
            e_omp_reduction_last
        };


HEADER_OMP_CLAUSE_END
HEADER_GRAPH_START

      /*! \brief Edge Type 

          Values used to indicate types of edges used for program analysis.
       */
          enum GraphEdgeType
             {
            // DQ (4/29/2009): Added an error value 
               e_type_error, /*!< error value */  
               none,         /*!< none ??? */
               cfg,          /*!< edge used for Control Flow Graph */
               usage,        /*!< usage??? */
               e_last_type   /*!< last value (unused, serves as upper bound on values) */
             };

      /*! \brief Graph Properties

          Values used to indicate types of graphs used for program analysis.
       */
          enum GraphProperties
             {
            // DQ (4/29/2009): Added an error value 
               e_property_error,    /*!< error value */  
               name,                /*!< name of the node */  
               type,                /*!< name of the node */
               nodest_jmp,          /*!< this a jump without dest */
               itself_call,         /*!< this call calls itself */
               nodest_call,         /*!< call without dest */
               interrupt,           /*!< interrupt (int) */
               eval,                /*!< dfa : evaluation */
               regs,                /*!< dfa : registers */
               done,                /*!< dfa : indicates that this node has successfully been visited */
               dfa_standard,        /*!< dfa_standard_node color */  // dfa_standard_node color
               dfa_resolved_func,   /*!< a function that has been resolved by dfa */
               dfa_unresolved_func, /*!< a function that cant be resolved by dfa */
               dfa_variable,        /*!< defines the variable found by dfa */
               dfa_conditional_def, /*!< specifies the nodes that are defines but also conditional instructions */
               edgeLabel,           /*!< ??? */  
               visitedCounter,      /*!< counts the amount of a node being visited during dfa */
               variable,            /*!< stores the string of the variable */
               dfa_bufferoverflow,  /*!< indicates buffer overflow */
               e_last_property      /*!< last value (unused, serves as upper bound on values) */
             };



#if 0

  // DQ (4/29/2009): Boost graph Type
 //! Boost Graph Type used to represent ROSE graphs within Boost Graph Algorithms.
     typedef boost::adjacency_list < boost::vecS, boost::vecS, boost::undirectedS, boost::no_property, boost::property < boost::edge_weight_t, int > > BoostGraphType;

 //! Supporting graph types required by Boost Graph Library.
     typedef boost::graph_traits < BoostGraphType >::edge_descriptor   BoostEdgeDescriptor;

  // DQ (4/29/2009): We might need this in the future, but not now!
  // typedef boost::graph_traits < BoostGraphType >::vertex_descriptor BoostVertexDescriptor;

#endif


 //! Simple edge type used to input data to Boost algorithms
     typedef std::pair<int, int> BoostEdgeType;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
  // We need this local type so that the member access functions for data members of this type can be resolved.
  // typedef std::vector<SgGraph::BoostEdgeType> SgBoostEdgeList;
     typedef std::vector<BoostEdgeType> SgBoostEdgeList;
  // typedef SgBoostEdgeList* SgBoostEdgeListPtr;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
     typedef std::vector<int> SgBoostEdgeWeightList;
  // typedef SgBoostEdgeWeightList* SgBoostEdgeWeightListPtr;

     int hashCode( const char* p, int len) const; // hash a character array
  // void initialize_graph_id();
     void append_properties( int addr, const std::string & prop );

 //! Support for adding SgGraphNode to SgGraph.
     SgGraphNode* addNode( const std::string & name = "", SgNode* sg_node = NULL);

 //! Add support for externally build SgGraphNode objects
     SgGraphNode* addNode( SgGraphNode* node );

 //! Support for adding SgGraphEdge to SgGraph.
     SgGraphEdge* addEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgGraphEdge* addEdge( SgGraphEdge* edge );

     void post_construction_initialization();

 //! Support for Boost Minimum Spanning Tree.
  // std::vector <BoostEdgeDescriptor> generateSpanningTree();
     std::vector <SgGraphEdge*> generateSpanningTree();

     // tps (4/30/2009): Added properties for nodes and edges
     // todo: this will be replaced with AstAttributes once the graph conversion is done.
   	  std::string getProperty(SgGraph::GraphProperties property, SgGraphNode* node);
	  std::string getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge);
	  void setProperty(SgGraph::GraphProperties property, SgGraphNode* node, std::string value);
	  void setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge, std::string value);

 	// tps (4/30/2009): The following are functions on the graph that were used before 
 	// in the old graph implementation
  	//std::set<SgGraphEdge*> getEdge(SgGraphNode* src, SgGraphNode* trg);
        void checkIfGraphNodeExists(const std::string& trg_mnemonic, std::vector<SgGraphNode*>& nodes);
//SgGraphNode* checkIfGraphNodeExists(std::string& trg_mnemonic);
        


 //! Check if the node is present in the graph.
     bool exists( SgGraphNode* node );

 //! Check if the edge is present in the graph.
     bool exists( SgGraphEdge* edge );


 //! Builds a set of edges that are associated with a specific node.
     std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );

  //! Integer index version of "std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );"
     std::set<int> computeEdgeSet( int node_index );

 //! Build set of node index pairs associated with node index (one of the value of the pair will be equal to the input node_index).
     std::set< std::pair<int,int> > computeNodeIndexPairSet( int node_index );

 //! Builds a set of node index values associated with a label.
     std::set<SgGraphNode*> computeNodeSet( const std::string & label );

 //! Builds a set of all nodes in the graph.
     std::set<SgGraphNode*> computeNodeSet();

  //! Integer index version of "std::set<SgGraphNode*> computeNodeSet( const std::string & label );"
     std::set<int> computeNodeIndexSet( const std::string & label );

  // Number of nodes in graph.
     size_t numberOfGraphNodes() const;

  // Number of edges in graph.
     size_t numberOfGraphEdges() const;

     void display_node_index_to_edge_multimap() const;
     void display_node_index_to_node_map() const;
     void display_edge_index_to_edge_map() const;
     void display_node_index_pair_to_edge_multimap() const;
     void display_string_to_node_index_multimap() const;
     void display_string_to_edge_index_multimap() const;

#ifdef ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY
     void display_nodes() const;
     void display_edges() const;
#endif

//! Resize the internal hash tables based on the number of nodes (hash_maps and hash_multimaps for edges are made larger by multiplying by the value "numberOfEdges" ).
     void resize_hash_maps( size_t numberOfNodes, size_t numberOfEdges = 10 );

  //! Report the size in bytes of the graph (includes all edges and ndes from all hash_maps and hash_multimaps).
     size_t memory_usage();

HEADER_GRAPH_END


HEADER_GRAPH_POSTDECLARATION_START


// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
// We need this global type so that the member access functions (defined outside the class)
// for data members of this type can be resolved.
typedef SgGraph::SgBoostEdgeList SgBoostEdgeList;
typedef SgBoostEdgeList* SgBoostEdgeListPtr;

// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
typedef SgGraph::SgBoostEdgeWeightList SgBoostEdgeWeightList;
typedef SgBoostEdgeWeightList* SgBoostEdgeWeightListPtr;


// Supporting graph type required by Boost Graph Library.
// typedef boost::graph_traits < SgGraph::BoostGraphType >::edge_descriptor BoostEdgeDescriptor;


HEADER_GRAPH_POSTDECLARATION_END


HEADER_GRAPHNODE_START
     void append_properties( int addr, const std::string & prop );	

     void post_construction_initialization();
HEADER_GRAPHNODE_END


HEADER_GRAPHEDGE_START
     void append_properties( int addr, const std::string & prop );

     void post_construction_initialization();
HEADER_GRAPHEDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraphEdge(std::string name, std::string type, int n, SgGraphNode* from, SgGraphNode* to);

          SgGraphNode* get_from() { return p_node_A; }
          SgGraphNode* get_to()   { return p_node_B; }
HEADER_DIRECTED_GRAPH_EDGE_END

#if 0
HEADER_DIRECTED_GRAPH_NODE_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraphNode(std::string name, std::string type, int n);

       // DQ (4/23/2009): Added to debug use of new Graph node interfaces.
          SgDirectedGraphNode(std::string);
          SgDirectedGraphNode();
HEADER_DIRECTED_GRAPH_NODE_END


HEADER_DIRECTED_GRAPH_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraph(std::string, std::string);
HEADER_DIRECTED_GRAPH_END
#endif

HEADER_GRAPH_NODE_START
HEADER_GRAPH_NODE_END


HEADER_GRAPH_NODE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<std::string,SgGraphNode*, rose_hash::hash_string, rose_hash::eqstr_string> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_NODE_LIST_END


HEADER_GRAPH_EDGE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<SgGraphNode*,SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_EDGE_LIST_END


HEADER_UNDIRECTED_GRAPH_EDGE_START
          SgGraphNode* get_node1() { return p_node_A; }
          SgGraphNode* get_node2() { return p_node_B; }
HEADER_UNDIRECTED_GRAPH_EDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
HEADER_DIRECTED_GRAPH_EDGE_END


HEADER_INCIDENCE_UNDIRECTED_GRAPH_START
HEADER_INCIDENCE_UNDIRECTED_GRAPH_END


HEADER_INCIDENCE_DIRECTED_GRAPH_START
  // tps (4/30/2009): The following are functions on the graph that were used before 
  // in the old graph implementation
  	  std::set<SgGraphEdge*> getEdge(SgGraphNode* src);
  	  bool checkIfGraphEdgeExists(SgGraphNode* src);

     void post_construction_initialization();

 //! Support for adding SgGraphEdge to SgGraph.
     SgDirectedGraphEdge* addDirectedEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgDirectedGraphEdge* addDirectedEdge( SgDirectedGraphEdge* edge  );

	// tps (4/30/2009): Added to support functionality for DirectedGraphs		   
     void getSuccessors(SgGraphNode* node, std::vector <SgGraphNode*>& vec );
     void getPredecessors(SgGraphNode* node, std::vector <SgGraphNode*>& vec );
     std::set<SgDirectedGraphEdge*> getDirectedEdge(SgGraphNode* src, SgGraphNode* trg);
     bool checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg);

  // DQ (8/18/2009): Added support for construction of sets of edges.
     std::set<SgDirectedGraphEdge*> computeEdgeSetIn( SgGraphNode* node );
     std::set<int> computeEdgeSetIn( int node_index );
     std::set<SgDirectedGraphEdge*> computeEdgeSetOut( SgGraphNode* node );
     std::set<int> computeEdgeSetOut( int node_index );

HEADER_INCIDENCE_DIRECTED_GRAPH_END


HEADER_BIDIRECTIONAL_GRAPH_START
HEADER_BIDIRECTIONAL_GRAPH_END


HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_END


HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_END



// *********************************************************
// ************ Support for Type Modifier nodes ************
// *********************************************************
HEADER_MODIFIER_START
          SgModifier ( const SgModifier & X );
          SgModifier & operator= ( const SgModifier & X );

       // bit handling support used by many derived classes
          bool checkBit ( unsigned int bit, const SgBitVector & bitVector ) const;
          void setBit   ( unsigned int bit,       SgBitVector & bitVector ) const;
          void unsetBit ( unsigned int bit,       SgBitVector & bitVector ) const;

HEADER_MODIFIER_END


HEADER_MODIFIER_NODES_START
          SgModifierNodes();
      // ~SgModifierNodes();

          void post_construction_initialization();

       // DQ (2/12/2007): This function is not used.
       // SgModifierType* match(SgType*, unsigned int);

       // DQ (2/4/2006): Added mechamism to clear all bits
       // void reset();

HEADER_MODIFIER_NODES_END

HEADER_CV_TYPE_MODIFIER_START

       // const_volatile specifiers (const, volatile)

      /*! \brief Const Volatile Modifier 

          Must be either const, volatile, or neither.

          \internal Bit values can support multiple values in a single enum type
       */
          enum cv_modifier_enum
             {
               e_unknown,      /*!< Unknown value (error value) */
               e_default,      /*!< Default value (default) */
               e_const,        /*!< Const qualifier */
               e_volatile,     /*!< Volatile qualifier */
               e_last_modifier /*!< last value (unused, serves as upper bound on values) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

       // DQ (3/21/2005): the default setting is non-const and non-volatile
          bool isDefault() const;
          void setDefault();

          bool isConst() const;
          void setConst();

       // DQ (3/21/2005): We could have a design with no unset function since the cv data is not a bit vector
       // the design reflects that a CV modifier is either const or volatile or neither.
       // Thus unsetting const would be to set the default value.
          void unsetConst();

          bool isVolatile() const;
          void setVolatile();
       // DQ (3/21/2005): See comment for unsetConst() above
          void unsetVolatile();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgConstVolatileModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_CV_TYPE_MODIFIER_END

HEADER_STORAGE_MODIFIER_START

       // storage specifiers (auto, static, register, extern, mutable)

       // C++ grammar defines storage modifier to be only: auto, static, register, extern, mutable

       // DQ (4/6/2004): Added to provide uniform support for storage modifiers
      /*! \brief Storage Modifiers (only one value can be specified)

          Storage modifiers are used to specify location or properties of declarations.
          For example, static variables in functions are stored in global scope, register 
          variables are a hint to store the value in a CPU register (mosty ignored by 
          modern compilers).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum storage_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_extern        = 2,  /*!< extern storage modifier */
               e_static        = 3,  /*!< static storage modifier */
               e_auto          = 4,  /*!< auto storage value */
               e_unspecified   = 5,  /*!< previous (old) default value, not included in C++ grammar definition of storage modifier */
               e_register      = 6,  /*!< register storage modifier */
               e_mutable       = 7,  /*!< mutable storage modifier */
               e_typedef       = 8,  /*!< not used, not included in C++ grammar definition of storage modifier */
               e_asm           = 9,  /*!< not used, not included in C++ grammar definition of storage modifier */
#ifdef FORTRAN_SUPPORTED
            // included for later FORTRAN support
               e_local         = 10, /*!< Auto or static at back end's preference */
               e_common        = 11, /*!< A COMMON block */
               e_associated    = 12, /*!< Variable is part of an association */
               e_intrinsic     = 13, /*!< Intrinsic function or subroutine */
               e_pointer_based = 14, /*!< Pointee of a POINTER definition */
#endif

            // TV (04/08/2010): Support for CUDA storage modifiers
               e_cuda_global         = 15, /*!< CUDA, in device's global memory */
               e_cuda_constant       = 16, /*!< CUDA, in device's constant memory */
               e_cuda_shared         = 17, /*!< CUDA, in device's shared memory */
               e_cuda_dynamic_shared = 18, /*!< CUDA, in device's shared memory, dynamically allocated */

            // TV (05/06/2010): Support for OpenCL storage modifiers
               e_opencl_global   = 19, /*!< OpenCL, accessible from all the device */
               e_opencl_local    = 20, /*!< OpenCL, accessible for a work-group only */
               e_opencl_constant = 21, /*!< OpenCL, read-only variable accessible from all the device */
               e_opencl_private  = 22, /*!< OpenCL, accessible only from one work-item */
               
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isExtern() const;
          void setExtern();

          bool isStatic() const;
          void setStatic();

          bool isAuto() const;
          void setAuto();

          bool isUnspecified() const;
          void setUnspecified();

          bool isRegister() const;
          void setRegister();

          bool isMutable() const;
          void setMutable();

       // This is not used (but is present in the EDG AST)
          bool isTypedef() const;
          void setTypedef();

       // This is not used (but is present in the EDG AST)
          bool isAsm() const;
          void setAsm();

#if 0
       // DQ (11/18/2007): We store this information differently now!
#ifdef FORTRAN_SUPPORTED
       // These remaining access functions are specific to FORTRAN
          bool isLocal() const;
          void setLocal();

          bool isCommon() const;
          void setCommon();

          bool isAssociated() const;
          void setAssociated();

          bool isIntrinsic() const;
          void setIntrinsic();

          bool isPointerBased() const;
          void setPointerBased();
#endif
#endif

       // TV (04/08/2010): Support for CUDA storage modifiers

          bool isCudaGlobal() const;
          void setCudaGlobal();

          bool isCudaConstant() const;
          void setCudaConstant();

          bool isCudaShared() const;
          void setCudaShared();

          bool isCudaDynamicShared() const;
          void setCudaDynamicShared();

       // TV (05/06/2010): Support for OpenCL storage modifiers

          bool isOpenclGlobal() const;
          void setOpenclGlobal();

          bool isOpenclLocal() const;
          void setOpenclLocal();

          bool isOpenclConstant() const;
          void setOpenclConstant();

          bool isOpenclPrivate() const;
          void setOpenclPrivate();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgStorageModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_STORAGE_MODIFIER_END

HEADER_ACCESS_MODIFIER_START

       // access specifiers (private, protected, public)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Access Modifiers (only one value can be specified)

          \internal Only one value can be specified (at least in C and C++)

          \note Added an undefined value for Fortran 90 support.
       */
          enum access_modifier_enum
             {
               e_unknown   = 0,        /*!< error value */
               e_private   = 1,        /*!< private access (local to class members) */
               e_protected = 2,        /*!< protected access (local to class members and membrs of derived classes) */
               e_public    = 3,        /*!< public access (access within enclosing namespace) */
               e_default   = e_public, /*!< default value (public access) */
               e_undefined = 4,        /*!< fortran default value */
               e_last_modifier         /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgAccessModifier ( const SgAccessModifier & X );

       // Assignment Operator
          SgAccessModifier & operator= ( const SgAccessModifier & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isPrivate() const;
          void setPrivate();

          bool isProtected() const;
          void setProtected();

          bool isPublic() const;
          void setPublic();

       // DQ (11/24/2007): Added support for Fortran staements to have undefined access (default in modules should not be public (or private))
          bool isUndefined() const;
          void setUndefined();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgAccessModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ACCESS_MODIFIER_END

HEADER_FUNCTION_MODIFIER_START

      /*! \brief Function Modifiers (bitvector implementation permits multiple values to be specified)

          Function modifiers (inline, virtual, pure-virtual, explicit).

          \internal Many values can be specified (when the gnu attributes are included), so the implementation uses an STL bit vector.
       */
          enum function_modifier_enum
             {
            // Multiple values can be specified at one time
            // (e.g. inline and explicit (works in g++!))
               e_unknown            = 0, /*!< error value */
               e_default            = 1, /*!< default value */
               e_inline             = 2, /*!< inlined function */
               e_virtual            = 3, /*!< virtual function */
               e_pure_virtual       = 4, /*!< pure virtual function */
               e_explicit           = 5, /*!< explicit function (avoids type resolution through auto type promotion of function arguments) */
            // e_bind               = 6, /*!< Fortran bind attribute for functions (see also type modifier) */
               e_pure               = 7, /*!< Fortran pure attribute for functions (see also type modifier) */
               e_elemental          = 8, /*!< Fortran elemental attribute for functions (see also type modifier) */
               e_recursive          = 9, /*!< Fortran recursive attribute for functions (see also type modifier) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__constructor__            = 10,/*!< GNU specific attribute for (GNU extension) (a separately stored value permits the priority to be specified). */
               e_gnu_attribute__destructor__             = 11,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__pure__                   = 12,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weak__                   = 13,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 14,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 15,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 16,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__malloc__                 = 17,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__naked__                  = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_instrument_function__ = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_check_memory_usage__  = 20,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noinline__               = 21,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__always_inline__          = 22,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nothrow__                = 23,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 24,/*!< GNU specific attribute for (GNU extension) */
               
            // TV (04/08/2010): Support for CUDA functions modifiers
             
               e_cuda_device				 = 25, /*!< CUDA device function */
               e_cuda_kernel				 = 26, /*!< CUDA kernel */
               e_cuda_host				 = 27, /*!< CUDA host function */
               
            // TV (05/03/2010): Support for OpenCL functions modifiers
             
               e_opencl_kernel				 = 28, /*!< OpenCL kernel */
               e_opencl_vec_type_hint			 = 29, /*!< OpenCL */
               e_opencl_work_group_size_hint		 = 30, /*!< OpenCL */
               e_opencl_work_group_size_req		 = 31, /*!< OpenCL */

               e_last_modifier     /*!< last value (upper bound on range of values, used in error checking) */
             };
             
          // TV (05/03/2010)

             struct opencl_work_group_size_t {
             	unsigned long int x, y, z;
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isInline() const;
          void setInline();
          void unsetInline();

          bool isVirtual() const;
          void setVirtual();
          void unsetVirtual();

          bool isPureVirtual() const;
          void setPureVirtual();
          void unsetPureVirtual();

          bool isExplicit() const;
          void setExplicit();
          void unsetExplicit();
#if 0
       // DQ (11/21/2007): support for Fortran bind attribute on functions
          bool isBind() const;
          void setBind();
          void unsetBind();
#endif
       // DQ (11/21/2007): support for Fortran pure attribute on functions
          bool isPure() const;
          void setPure();
          void unsetPure();

       // DQ (11/30/2007): support for Fortran elemental attribute on functions
          bool isElemental() const;
          void setElemental();
          void unsetElemental();

       // DQ (11/30/2007): support for Fortran recursive attribute on functions
          bool isRecursive() const;
          void setRecursive();
          void unsetRecursive();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeConstructor() const;
          void setGnuAttributeConstructor();
          void unsetGnuAttributeConstructor();

          bool isGnuAttributeDestructor() const;
          void setGnuAttributeDestructor();
          void unsetGnuAttributeDestructor();

          bool isGnuAttributePure() const;
          void setGnuAttributePure();
          void unsetGnuAttributePure();

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeMalloc() const;
          void setGnuAttributeMalloc();
          void unsetGnuAttributeMalloc();

          bool isGnuAttributeNaked() const;
          void setGnuAttributeNaked();
          void unsetGnuAttributeNaked();

          bool isGnuAttributeNoInstrumentFunction() const;
          void setGnuAttributeNoInstrumentFunction();
          void unsetGnuAttributeNoInstrumentFunction();

          bool isGnuAttributeNoCheckMemoryUsage() const;
          void setGnuAttributeNoCheckMemoryUsage();
          void unsetGnuAttributeNoCheckMemoryUsage();

          bool isGnuAttributeNoInline() const;
          void setGnuAttributeNoInline();
          void unsetGnuAttributeNoInline();

          bool isGnuAttributeAlwaysInline() const;
          void setGnuAttributeAlwaysInline();
          void unsetGnuAttributeAlwaysInline();

          bool isGnuAttributeNoThrow() const;
          void setGnuAttributeNoThrow();
          void unsetGnuAttributeNoThrow();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

       // TV (04/08/2010): Support for CUDA functions modifiers
       
          bool isCudaDevice() const;
          void setCudaDevice();
          void unsetCudaDevice();

          bool isCudaKernel() const;
          void setCudaKernel();
          void unsetCudaKernel();

          bool isCudaHost() const;
          void setCudaHost();
          void unsetCudaHost();
          
       // TV (05/03/2010): Support for OpenCL functions modifiers
       
          bool isOpenclKernel() const;
          void setOpenclKernel();
          void unsetOpenclKernel();
          
          bool hasOpenclVecTypeHint() const;
          void setOpenclVecTypeHint();
          void unsetOpenclVecTypeHint();
          
          bool hasOpenclWorkGroupSizeHint() const;
          void setOpenclWorkGroupSizeHint();
          void unsetOpenclWorkGroupSizeHint();
          
          bool hasOpenclWorkGroupSizeReq() const;
          void setOpenclWorkGroupSizeReq();
          void unsetOpenclWorkGroupSizeReq();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgFunctionModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_FUNCTION_MODIFIER_END


HEADER_UPC_ACCESS_MODIFIER_START

       // UPC access specifiers (unspecified, shared, strict, relaxed)

      /*! \brief UPC Access Modifiers (only one value can be specified)

          Unified Parallel C modifiers (shared, strict, relaxed).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum upc_access_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown,       /*!< error value */
               e_default,       /*!< default value */
            // DQ and Liao (6/13/2008): "shared" can be used with "strict" and "relaxed" so it must be handled separately.
            // e_upc_shared,    /*!< UPC shared */
               e_upc_strict,    /*!< UPC strict */
               e_upc_relaxed,   /*!< UPC relaxed */
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

       // bool isUPC_Shared() const;
       // void setUPC_Shared();

          bool isUPC_Strict() const;
          void setUPC_Strict();

          bool isUPC_Relaxed() const;
          void setUPC_Relaxed();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgUPC_AccessModifier & m );

       // DQ (2/4/2006): Added mechanism to clear all bits
          void reset();

HEADER_UPC_ACCESS_MODIFIER_END


HEADER_SPECIAL_FUNCTION_MODIFIER_START

       // special_function specifiers (constructor, destructor, conversion, operator)

      /*! \brief Special Function Modifiers (only one value can be specified)

          Modifier information about (constructor, destructor, conversion operator (cast operator), and operator (general overloaded operators)).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum special_function_modifier_enum
             {
               e_unknown     = 0,         /*!< error value */
               e_default     = 1,         /*!< Not a special function (default) */
               e_none        = e_default, /*!< Not a special function (default) */
               e_constructor = 2,         /*!< A constructor */
               e_destructor  = 3,         /*!< A destructor */
               e_conversion  = 4,         /*!< A conversion operator function */
               e_operator    = 5,         /*!< Any other operator function */
               e_last_modifier            /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isNotSpecial() const;
          void setNotSpecial();
          void unsetNotSpecial();

          bool isConstructor() const;
          void setConstructor();
          void unsetConstructor();

          bool isDestructor() const;
          void setDestructor();
          void unsetDestructor();

          bool isConversion() const;
          void setConversion();
          void unsetConversion();

          bool isOperator() const;
          void setOperator();
          void unsetOperator();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgSpecialFunctionModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_SPECIAL_FUNCTION_MODIFIER_END

HEADER_DECLARATION_MODIFIER_START
       // Support for: storage specifiers, type specifiers, function specifiers,
       //              friend, typedef, export, throw

      /*! \brief Declaration Modifiers (only one value can be specified)

          Modifier information about (friend, typedef, export, and throw).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum declaration_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown = 0,  /*!< Unknown value (error) */
               e_default = 1,  /*!< Default value */
               e_friend  = 2,  /*!< Friend qualifier */
               e_typedef = 3,  /*!< Typedef qualifier (not clear if this is used, I don't think typedef is a modifier) */
               e_export  = 4,  /*!< Export qualifier */
               e_throw   = 5,  /*!< Exception handling support (throw) */
               e_bind    = 6,  /*!< Fortran bind attribute for declarations (functions, variable, and classes) */
               e_final   = 7,  /*!< PHP support for specification to not be extended (should be useful for Java, if required in the future) */
               e_last_modifier /*!< last modifier value (upper bound on range of values, used in error checking) */
             };

      /*! \brief GNU attribute for visability (only one value can be specified)

          visability values are: default, hidden, protected or internal visibility.

          \internal Only one value can be specified (at least in C and C++)
       */
          enum gnu_declaration_visability_enum
             {
               e_unknown_visibility     = 0,  /*!< Unknown value (error) */
               e_error_visibility       = 1,  /*!< Error value (error) */
               e_unspecified_visibility = 2,  /*!< Unspecified visibility (not the default value) */
               e_hidden_visibility      = 3,  /*!< hidden visibility */
               e_protected_visibility   = 4,  /*!< protected visibility */
               e_internal_visibility    = 5,  /*!< internal visibility (not clear if this is used, I don't think typedef is a modifier) */
               e_default_visibility     = 6,  /*!< default visibility */
               e_last_visibility_attribute /*!< last visibility attribute (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgDeclarationModifier ( const SgDeclarationModifier & X );

       // Assignment Operator
          SgDeclarationModifier & operator= ( const SgDeclarationModifier & X );

          void post_construction_initialization();

          SgTypeModifier    & get_typeModifier();
          SgAccessModifier  & get_accessModifier();
          SgStorageModifier & get_storageModifier();

          const SgTypeModifier    & get_typeModifier() const;
          const SgAccessModifier  & get_accessModifier() const;
          const SgStorageModifier & get_storageModifier() const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isFriend() const;
          void setFriend();
          void unsetFriend();

          bool isTypedef() const;
          void setTypedef();
          void unsetTypedef();

          bool isExport() const;
          void setExport();
          void unsetExport();

          bool isThrow() const;
          void setThrow();
          void unsetThrow();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // PHP specific attribute
          bool isFinal() const;
          void setFinal();
          void unsetFinal();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgDeclarationModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_DECLARATION_MODIFIER_END

HEADER_TYPE_MODIFIER_START

       // type specifier (elaborated-type-specifier, cv-qualifier, restrict)

       // DQ (9/7/2007): Added Fortran specific values to handle Fortran attribute specifiers.
       // DQ (4/6/2004): Added to provide uniform support for type modifiers
      /*! \brief Type Modifiers (multiple values can be specified at one time)

          Type modifier information about used for C/C++ and Fortran 77/90/2003.
          For Fortran values, each rerpesents a Fortran attribute specifier from section 5.1 
          of the Fortran 2003 standard.

          \internal These are used in a SgBitVector so that multiple values may be specified.
       */
          enum type_modifier_enum
             {
               e_unknown        = 0, /*!< Unknown value (error) */
               e_default        = 1, /*!< Unknown value (default) */
               e_restrict       = 2, /*!< Restrict qualifier (for C/C++) */

            // Fortran specific modifiers (in Fortran these are called attribute specifiers)
            // Note that public and private access attributes are mapped to the C/C++ access modifiers in SgDeclarationModifier
            // e_public_access  = 3, /*!< public qualifier (for Fortran 90) */
            // e_private_access = 4, /*!< private qualifier (for Fortran 90) */
               e_allocatable    = 3, /*!< allocatable attribute specifier (for Fortran 90) */
               e_asynchronous   = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
               e_bind           = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
               e_data           = 6, /*!< data attribute specifier (for Fortran 77) */
               e_dimension      = 7, /*!< dimension attribute specifier (for Fortran 77) */
            // This should map to the C/C++ extern modifier in SgStorageModifier
            // e_external       = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
               e_intent_in      = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
               e_intent_out     = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
               e_intent_inout   = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
               e_intrinsic      = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
               e_optional       = 12,/*!< optional attribute specifier (for Fortran 90) */
            // This should map to const in the SgConstVolatileModifier
            // e_parameter      = xx,/*!< parameter attribute specifier (for Fortran 77) */

            // This should be mapped to the SgPointerType in C/C++
            // e_pointer        = xx,/*!< pointer attribute specifier (for Fortran 90) */
            // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
            // e_protected      = xx,/*!< protected attribute specifier (for Fortran 2003) */
               e_save           = 13,/*!< save attribute specifier (for Fortran 77) */
               e_target         = 14,/*!< target attribute specifier (for Fortran 90) */
               e_value          = 15,/*!< value attribute specifier (for Fortran 2003) */
            // This should map to volatile in the SgConstVolatileModifier
            // e_volatile       = xx,/*!< volatile attribute specifier (for Fortran 2003) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__unused__            = 16,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__packed__            = 17,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__        = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__ = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noreturn__          = 20,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__const__             = 21,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__cdecl__             = 22,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__stdcall__           = 23,/*!< GNU specific attribute for function type (GNU extension) */

            // DQ (1/3/2009): New GNU attributes not previously supported in ROSE
               e_gnu_attribute__warn_unused_result__ = 24,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__nonnull__            = 25,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__sentinel__           = 26,/*!< GNU specific attribute for function type (GNU extension) */

            // Last attribute enum (used for internal bounds checking)
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // DQ (12/4/2007): Added support for gnu attributes representing machine modes (for types)
      /*! \brief GNU Extension Machine Mode type modifiers (only a single value can be specified at one time)

          Machine modes type modifier (required for rather exotic levels of source-to-source transformation in Linux.
          See http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes for lots of details.

          \internal These are used in an enum type (and I expect that this makes the storage over head small since the range is explicit).
       */
          enum gnu_extension_machine_mode_enum
             {
               e_gnu_extension_machine_mode_unknown     = 0, /*!< Unknown value (error) */
               e_gnu_extension_machine_mode_unspecified = 1, /*!< Unknown value (default) */
               e_gnu_extension_machine_mode_BImode      = 2, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QImode      = 3, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HImode      = 4, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PSImode     = 5, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SImode      = 6, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PDImode     = 7, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DImode      = 8, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TImode      = 9, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_OImode      = 10, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QFmode      = 11, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HFmode      = 12, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQFmode     = 13, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SFmode      = 14, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DFmode      = 15, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XFmode      = 16, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SDmode      = 17, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DDmode      = 18, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TDmode      = 19, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TFmode      = 20, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QQmode      = 21, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HQmode      = 22, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SQmode      = 23, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DQmode      = 24, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQmode      = 25, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UQQmode     = 26, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHQmode     = 27, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USQmode     = 28, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDQmode     = 29, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTQmode     = 30, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HAmode      = 31, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SAmode      = 32, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DAmode      = 33, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TAmode      = 34, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHAmode     = 35, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USAmode     = 36, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDAmode     = 37, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTAmode     = 38, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CCmode      = 39, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_BLKmode     = 40, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_VOIDmode    = 41, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QCmode      = 42, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HCmode      = 43, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SCmode      = 44, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DCmode      = 45, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XCmode      = 46, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TCmode      = 47, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CQImode     = 48, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CHImode     = 49, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CSImode     = 50, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CDImode     = 51, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CTImode     = 52, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_COImode     = 53, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_last_machine_mode /*!< last machine mode value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

       // Convert a single type_modifier_enum to an initializer
       // SgTypeModifier ( const SgTypeModifier::type_modifier_enum & m );

          void post_construction_initialization();

          SgUPC_AccessModifier     & get_upcModifier();
          SgConstVolatileModifier  & get_constVolatileModifier();
          SgElaboratedTypeModifier & get_elaboratedTypeModifier();

       // RV (2/2/2006): Added 'const' versions of above member functions.
          const SgUPC_AccessModifier     & get_upcModifier(void) const;
          const SgConstVolatileModifier  & get_constVolatileModifier(void) const;
          const SgElaboratedTypeModifier & get_elaboratedTypeModifier(void) const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isRestrict() const;
          void setRestrict();
          void unsetRestrict();

       // Fortran specific attribute
          bool isAllocatable() const;
          void setAllocatable();
          void unsetAllocatable();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // Fortran specific attribute
          bool isAsynchronous() const;
          void setAsynchronous();
          void unsetAsynchronous();

       // Fortran specific attribute
          bool isData() const;
          void setData();
          void unsetData();

       // Fortran specific attribute
          bool isDimension() const;
          void setDimension();
          void unsetDimension();

       // Fortran specific attribute
          bool isIntent_in() const;
          void setIntent_in();
          void unsetIntent_in();

       // Fortran specific attribute
          bool isIntent_out() const;
          void setIntent_out();
          void unsetIntent_out();

       // Fortran specific attribute
          bool isIntent_inout() const;
          void setIntent_inout();
          void unsetIntent_inout();

       // Fortran specific attribute
          bool isIntrinsic() const;
          void setIntrinsic();
          void unsetIntrinsic();

       // Fortran specific attribute
          bool isOptional() const;
          void setOptional();
          void unsetOptional();

       // Fortran specific attribute
          bool isSave() const;
          void setSave();
          void unsetSave();

       // Fortran specific attribute
          bool isTarget() const;
          void setTarget();
          void unsetTarget();

       // Fortran specific attribute
          bool isValue() const;
          void setValue();
          void unsetValue();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributePacked() const;
          void setGnuAttributePacked();
          void unsetGnuAttributePacked();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeNoReturn() const;
          void setGnuAttributeNoReturn();
          void unsetGnuAttributeNoReturn();

          bool isGnuAttributeConst() const;
          void setGnuAttributeConst();
          void unsetGnuAttributeConst();

          bool isGnuAttributeCdecl() const;
          void setGnuAttributeCdecl();
          void unsetGnuAttributeCdecl();

          bool isGnuAttributeStdcall() const;
          void setGnuAttributeStdcall();
          void unsetGnuAttributeStdcall();

          bool isGnuAttributeWarnUnusedResult() const;
          void setGnuAttributeWarnUnusedResult();
          void unsetGnuAttributeWarnUnusedResult();

          bool isGnuAttributeNonnull() const;
          void setGnuAttributeNonnull();
          void unsetGnuAttributeNonnull();

          bool isGnuAttributeSentinel() const;
          void setGnuAttributeSentinel();
          void unsetGnuAttributeSentinel();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgTypeModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_TYPE_MODIFIER_END

HEADER_ELABORATED_TYPE_MODIFIER_START
       // elaborated-type-specifier (class, struct, union, enum, typename, typename template)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Elaborated Type Modifiers (only one value can be specified)

          Modifier information about (class,struct, union, enum, and typename).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum elaborated_type_modifier_enum
             {
            // Only one value can be specified ???
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value (default) */
               e_class    = 2, /*!< class type */
               e_struct   = 3, /*!< struct type */
               e_union    = 4, /*!< union type */
               e_enum     = 5, /*!< enum type */
               e_typename = 6, /*!< typename type */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isClass() const;
          void setClass();

          bool isStruct() const;
          void setStruct();

          bool isUnion() const;
          void setUnion();

          bool isEnum() const;
          void setEnum();

          bool isTypename() const;
          void setTypename();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgElaboratedTypeModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ELABORATED_TYPE_MODIFIER_END

HEADER_LINKAGE_MODIFIER_START

       // linkage-specification (extern, extern "C", extern "C++", extern "Fortran")

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Linkage Modifiers (only one value can be specified)

          Modifier information about (C linkage, C++ linkage, Fortran linkage, and Fortran 90 linkage).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum linkage_modifier_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_C_linkage         = 2, /*!< C linkage */
               e_Cpp_linkage       = 3, /*!< C++ linkage */
               e_fortran_linkage   = 4, /*!< FORTRAN linkage (not really used yet) */
               e_fortran90_linkage = 5, /*!< FORTRAN 90 linkage (not really used yet) */
               e_last_modifier        /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isC_Linkage() const;
          void setC_Linkage();

          bool isCppLinkage() const;
          void setCppLinkage();

          bool isFortranLinkage() const;
          void setFortranLinkage();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgLinkageModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_LINKAGE_MODIFIER_END

HEADER_BASECLASS_MODIFIER_START
       // base-class-specifier (virtual, access specifiers)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Baseclass Modifiers (only one value can be specified)

          Modifier information about (virtual or not).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum baseclass_modifier_enum
             {
            // Only one value can be specified (at least in C, what about C++)
               e_unknown = 0,  /*!< error value */
               e_default = 1,  /*!< default value */
               e_virtual = 2,  /*!< virtual value */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          SgAccessModifier & get_accessModifier();
          const SgAccessModifier & get_accessModifier() const;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isVirtual() const;
          void setVirtual();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgBaseClassModifier & m );

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_BASECLASS_MODIFIER_END


HEADER_ATTRIBUTE_SUPPORT_START

     /* name Persistant Attribute Mechanism 

         This is the persistant attribute mechanism for attaching attributed to IR nodes across 
         multiple passes. Note that these attributes are persistant in that they are preserved 
         if the AST is written out to a file and read in from a file.  However, virtual function 
         in the user-defined class derived from the AstAttribute must be defined for the attribute
         to be defined across the boundary of File I/O (simple pack and unpack functions).  More
         sophisticated mechanisms are available within the AstAttributeMechanism object 
         (e.g iterating though attributes, etc; get_attributeMechanism() is available if direct
         access is required, however mostly only internal tools use this lower level support).

         \internal This used to be a public data member, but has been changed to be a protected 
         pointer instead.  The functional interface of the AstAttributeMechanism is presevered 
         but some of the names and the syntax for calling the interface have changed. The 
         pointer to the AstAttributeMechanism is now generated by ROSETTA.
      */
     /* */
     //! Add a new attribute represented by the named string.
         virtual void addNewAttribute(std::string s,AstAttribute* a);
     //! Returns attribute of name 's'.
         virtual AstAttribute* getAttribute(std::string s) const;
     //! Replace existing attribute of name 's' with new AstAttribute.
         virtual void updateAttribute(std::string s,AstAttribute* a);  // formerly called: replace in AstAttributeMechanism
     /*! \brief This is a wrapper function with the following semantics:
         if no attribute of name 's' exists then \b addNewAttribute(s,a); is called,
         otherwise \b updateAttribute(s,a); is called.
      */
         virtual void setAttribute(std::string s,AstAttribute* a);
     //! Remove attribute of name 's' if present.
         virtual void removeAttribute(std::string s);
     //! Tests if attribute of name 's' is present.
         virtual bool attributeExists(std::string s) const;
     //! Returns the number of attributes on this IR node.
         virtual int numberOfAttributes() const;

     /*! \fn AstAttributeMechanism* $CLASSNAME::get_attributeMechanism() const;
         \brief \b FOR \b INTERNAL \b USE Access function; if an attribute exists then 
                a pointer to it is returned, else error.

         This is an access function used for getting the interally held pointer to a valid 
         AstAttributeMechanism. It provides access to lower level functionality of the 
         AstAttributeMechanism, put is mostly of use to internal tools.
      */
     /*! \fn void $CLASSNAME::set_attributeMechanism(AstAttributeMechanism* a);
         \brief \b FOR \b INTERNAL \b USE Access function; sets poiner to value AstAttributeMechanism.

         This is an access function used for setting the interally held pointer to a valid 
         AstAttributeMechanism.
      */
     /* */


HEADER_ATTRIBUTE_SUPPORT_END


HEADER_NAME_GROUP_START
          const SgStringList & get_name_list() const;
          SgStringList & get_name_list();
HEADER_NAME_GROUP_END


HEADER_COMMON_BLOCK_OBJECT_START
HEADER_COMMON_BLOCK_OBJECT_END


HEADER_DIMENSION_OBJECT_START
HEADER_DIMENSION_OBJECT_END


HEADER_DATA_STATEMENT_GROUP_START

          const SgDataStatementObjectPtrList & get_object_list() const;
          SgDataStatementObjectPtrList & get_object_list();

          const SgDataStatementValuePtrList & get_value_list() const;
          SgDataStatementValuePtrList & get_value_list();

HEADER_DATA_STATEMENT_GROUP_END

HEADER_DATA_STATEMENT_OBJECT_START
HEADER_DATA_STATEMENT_OBJECT_END

HEADER_DATA_STATEMENT_VALUE_START

      //! Support for Fortran data statement
          enum data_statement_value_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_explict_list      = 2, /*!< list of value expressions */
               e_implicit_list     = 3, /*!< repeat-count * value */
               e_implied_do        = 4, /*!< implied do loop initializer */
               e_last_initializer_form  /*!< last value (upper bound on range of values, used in error checking) */
             };

          void post_construction_initialization();

HEADER_DATA_STATEMENT_VALUE_END


HEADER_FORMAT_ITEM_START
HEADER_FORMAT_ITEM_END


HEADER_FORMAT_ITEM_LIST_START

          const SgFormatItemPtrList & get_format_item_list() const;
          SgFormatItemPtrList & get_format_item_list();
          void set_format_item_list ( const SgFormatItemPtrList & formatItemList );

HEADER_FORMAT_ITEM_LIST_END


HEADER_TYPE_TABLE_START
          $CLASSNAME ();
          void insert_type(const SgName&, SgType *);

          SgType* lookup_type (const SgName&);

       // DQ (7/22/2010): Added to support AST merge.
          void remove_type(const SgName&);

          void print_typetable(std::ostream& os = std::cout);

HEADER_TYPE_TABLE_END



SOURCE_ATTRIBUTE_SUPPORT_START

#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
$CLASSNAME::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          assert(false);
        }

     return *p_attribute;
   }
#endif

void
$CLASSNAME::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          assert(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
$CLASSNAME::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          assert(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
$CLASSNAME::getAttribute(std::string s) const
   {
     //assert(get_attributeMechanism() != NULL); // Liao, bug 130 6/4/2008
     if (attributeExists(s)==false) return NULL;
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     assert(returnValue != NULL);
     return returnValue;
   }

void
$CLASSNAME::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     assert(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
$CLASSNAME::removeAttribute(std::string s)
   {
     assert(get_attributeMechanism() != NULL);
     get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // printf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
$CLASSNAME::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
$CLASSNAME::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }

SOURCE_ATTRIBUTE_SUPPORT_END


SOURCE_MODIFIER_START

SgModifier::SgModifier ( const SgModifier & X )
   {
  // DQ (4/13/2004): Nothing to do here, but this function prevents the SgSupport copy 
  // constructor from being called and we would like to keep that copy constructor 
  // private so that we can enforce error checking via the type system.
   }

SgModifier & 
SgModifier::operator= ( const SgModifier & X )
   {
     return *this;
   }

bool
SgModifier::checkBit ( unsigned int bit, const SgBitVector & bitVector ) const 
   {
     assert (bit < bitVector.size());
     return bitVector[bit];
   }

void
SgModifier::setBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     assert (bit < bitVector.size());
     bitVector[bit] = true;
   }

void
SgModifier::unsetBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     assert (bit < bitVector.size());
     bitVector[bit] = false;
   }

SOURCE_MODIFIER_END


SOURCE_MODIFIER_NODES_START

#if 1
// These are generated
SgModifierNodes::SgModifierNodes()
   {
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // p_next = (SgModifierNodes*)0L;
  // MK: Call the following function instead
     post_construction_initialization();
   }

#if 0
SgModifierNodes::~SgModifierNodes()
   {
     // delete nodes[];
     delete p_next;
   }
#endif
#endif

void
SgModifierNodes::post_construction_initialization()
   {
  // nodes = new (SgModifierType*)[4];
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // MK: p_nodes is an STL vector now, it needs to be initilized differently
     for (int i= 0; i<4; i++)
          p_nodes.push_back((SgModifierType*) NULL);
     p_next = (SgModifierNodes*) NULL;
   }

#if 0
// DQ (4/13/2004): Commented out as a test to see if we need this function
SgModifierType*
SgModifierNodes::match(SgType* base, unsigned int f)
   {
     for (int j = 0; j < 4; j++)
        {
          if (!p_nodes[j])
             {
               SgModifierType* newType = new SgModifierType(base, f);
               assert(newType != NULL);

               p_nodes[j] = newType;
               assert(p_nodes[j] != NULL);

               return p_nodes[j];
            // return nodes[j] = new SgModifierType(base, f);
             }
          assert(p_nodes[j] != NULL);
          if (p_nodes[j]->bitfield() == f)
             {
               return p_nodes[j];
             }
        }

     if (!p_next)
        {
          p_next = new SgModifierNodes();
          assert(p_next != NULL);
        }

     return p_next->match(base, f);
   }
#endif

SOURCE_MODIFIER_NODES_END


SOURCE_CV_TYPE_MODIFIER_START

$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isConst() const { return p_modifier == e_const; }
void $CLASSNAME::setConst()      { p_modifier = e_const; }
void $CLASSNAME::unsetConst()    { setDefault(); }

bool $CLASSNAME::isVolatile() const { return p_modifier == e_volatile; }
void $CLASSNAME::setVolatile()      { p_modifier = e_volatile; }
void $CLASSNAME::unsetVolatile()    { setDefault(); }

std::ostream & operator<< ( std::ostream & os, SgConstVolatileModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isConst() = ")    + std::string(isConst()    ? "true " : "false ");
     s += std::string("isVolatile() = ") + std::string(isVolatile() ? "true"  : "false");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
#if 0
     printf ("   isUnknown()         = %s \n",isUnknown()  ? "true" : "false");
     printf ("   isDefault()         = %s \n",isDefault()  ? "true" : "false");
     printf ("   isConst()           = %s \n",isConst()    ? "true" : "false");
     printf ("   isVolatile()        = %s \n",isVolatile() ? "true" : "false");
#else
     printf ("%s \n",displayString().c_str());
#endif
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_CV_TYPE_MODIFIER_END


SOURCE_STORAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isExtern() const { return p_modifier == e_extern; }
void $CLASSNAME::setExtern()      { p_modifier = e_extern; }

bool $CLASSNAME::isStatic() const { return p_modifier == e_static; }
void $CLASSNAME::setStatic()      { p_modifier = e_static; }

bool $CLASSNAME::isAuto() const { return p_modifier == e_auto; }
void $CLASSNAME::setAuto()      { p_modifier = e_auto; }

bool $CLASSNAME::isUnspecified() const { return p_modifier == e_unspecified; }
void $CLASSNAME::setUnspecified()      { p_modifier = e_unspecified; }

// This is not used (but is present in the EDG AST)
bool $CLASSNAME::isTypedef() const { return p_modifier == e_typedef; }
void $CLASSNAME::setTypedef()      { p_modifier = e_typedef; }

bool $CLASSNAME::isRegister() const { return p_modifier == e_register; }
void $CLASSNAME::setRegister()      { p_modifier = e_register; }

bool $CLASSNAME::isMutable() const { return p_modifier == e_mutable; }
void $CLASSNAME::setMutable()      { p_modifier = e_mutable; }

bool $CLASSNAME::isAsm() const { return p_modifier == e_asm; }
void $CLASSNAME::setAsm()      { p_modifier = e_asm; }

#ifdef FORTRAN_SUPPORTED
// These remaining access functions are specific to FORTRAN
bool $CLASSNAME::isLocal() const { return p_modifier == e_local; }
void $CLASSNAME::setLocal()      { p_modifier = e_local; }

bool $CLASSNAME::isCommon() const { return p_modifier == e_common; }
void $CLASSNAME::setCommon()      { p_modifier = e_common; }

bool $CLASSNAME::isAssociated() const { return p_modifier == e_associated; }
void $CLASSNAME::setAssociated()      { p_modifier = e_associated; }

bool $CLASSNAME::isIntrinsic() const { return p_modifier == e_intrinsic; }
void $CLASSNAME::setIntrinsic()      { p_modifier = e_intrinsic; }

bool $CLASSNAME::isPointerBased() const { return p_modifier == e_pointer_based; }
void $CLASSNAME::setPointerBased()      { p_modifier = e_pointer_based; }
#endif

// TV (08/04/2010): Support for CUDA storage modifiers

bool SgStorageModifier::isCudaGlobal() const { return p_modifier == e_cuda_global; }
void SgStorageModifier::setCudaGlobal()      { p_modifier = e_cuda_global; }

bool SgStorageModifier::isCudaConstant() const { return p_modifier == e_cuda_constant; }
void SgStorageModifier::setCudaConstant()      { p_modifier = e_cuda_constant; }

bool SgStorageModifier::isCudaShared() const { return p_modifier == e_cuda_shared; }
void SgStorageModifier::setCudaShared()      { p_modifier = e_cuda_shared; }

bool SgStorageModifier::isCudaDynamicShared() const { return p_modifier == e_cuda_dynamic_shared; }
void SgStorageModifier::setCudaDynamicShared()      { p_modifier = e_cuda_dynamic_shared; }

// TV (05/06/2010): Support for OpenCL storage modifiers

bool SgStorageModifier::isOpenclGlobal() const { return p_modifier == e_opencl_global; }
void SgStorageModifier::setOpenclGlobal()      { p_modifier = e_opencl_global; }

bool SgStorageModifier::isOpenclLocal() const { return p_modifier == e_opencl_local; }
void SgStorageModifier::setOpenclLocal()      { p_modifier = e_opencl_local; }

bool SgStorageModifier::isOpenclConstant() const { return p_modifier == e_opencl_constant; }
void SgStorageModifier::setOpenclConstant()      { p_modifier = e_opencl_constant; }

bool SgStorageModifier::isOpenclPrivate() const { return p_modifier == e_opencl_private; }
void SgStorageModifier::setOpenclPrivate()      { p_modifier = e_opencl_private; }

std::ostream & operator<< ( std::ostream & os, SgStorageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isExtern() = ")       + std::string(isExtern()       ? "true " : "false ");
     s += std::string("isStatic() = ")       + std::string(isStatic()       ? "true " : "false ");
     s += std::string("isAuto() = ")         + std::string(isAuto()         ? "true " : "false ");
     s += std::string("isUnspecified() = ")  + std::string(isUnspecified()  ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isRegister() = ")     + std::string(isRegister()     ? "true " : "false ");
     s += std::string("isMutable() = ")      + std::string(isMutable()      ? "true " : "false ");
     s += std::string("isAsm() = ")          + std::string(isAsm()          ? "true"  : "false");
#ifdef FORTRAN_SUPPORTED
     s += std::string("isLocal() = ")        + std::string(isLocal()        ? "true " : "false ");
     s += std::string("isCommon() = ")       + std::string(isCommon()       ? "true " : "false ");
     s += std::string("isAssociated() = ")   + std::string(isAssociated()   ? "true " : "false ");
     s += std::string("isIntrinsic() = ")    + std::string(isIntrinsic()    ? "true " : "false ");
     s += std::string("isPointerBased() = ") + std::string(isPointerBased() ? "true"  : "false");
#endif
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_STORAGE_MODIFIER_END

SOURCE_ACCESS_MODIFIER_START

// Copy constructor
SgAccessModifier::SgAccessModifier ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgAccessModifier &
SgAccessModifier::operator= ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgAccessModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgAccessModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgAccessModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgAccessModifier::isDefault() const { return p_modifier == e_default; }
void SgAccessModifier::setDefault()      { p_modifier = e_default; }

bool SgAccessModifier::isPrivate() const { return p_modifier == e_private; }
void SgAccessModifier::setPrivate()      { p_modifier = e_private; }

bool SgAccessModifier::isProtected() const { return p_modifier == e_protected; }
void SgAccessModifier::setProtected()      { p_modifier = e_protected; }

bool SgAccessModifier::isPublic() const { return p_modifier == e_public; }
void SgAccessModifier::setPublic()      { p_modifier = e_public; }

bool SgAccessModifier::isUndefined() const { return p_modifier == e_undefined; }
void SgAccessModifier::setUndefined()      { p_modifier = e_undefined; }

std::ostream & operator<< ( std::ostream & os, SgAccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
SgAccessModifier::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isPrivate() = ")   + std::string(isPrivate()   ? "true " : "false ");
     s += std::string("isProtected() = ") + std::string(isProtected() ? "true " : "false ");
     s += std::string("isPublic() = ")    + std::string(isPublic()    ? "true"  : "false ");
     s += std::string("isUndefined() = ") + std::string(isUndefined() ? "true"  : "false ");
     s += ")";
     return s;
   }

void
SgAccessModifier::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgAccessModifier::reset()
   {
     setDefault();
   }

SOURCE_ACCESS_MODIFIER_END


SOURCE_FUNCTION_MODIFIER_START
// Copy constructor
SgFunctionModifier::$CLASSNAME ( const SgFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

SgFunctionModifier &
SgFunctionModifier::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
SgFunctionModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgFunctionModifier::isUnknown() const { return checkBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::setUnknown()      { setBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::unsetUnknown()    { unsetBit(e_unknown,p_modifierVector); }

bool SgFunctionModifier::isDefault() const { return checkBit(e_default,p_modifierVector); }
void SgFunctionModifier::setDefault()      { setBit(e_default,p_modifierVector); }
void SgFunctionModifier::unsetDefault()    { unsetBit(e_default,p_modifierVector); }

bool SgFunctionModifier::isInline() const { return checkBit(e_inline,p_modifierVector); }
void SgFunctionModifier::setInline()      { setBit(e_inline,p_modifierVector); }
void SgFunctionModifier::unsetInline()    { unsetBit(e_inline,p_modifierVector); }

bool SgFunctionModifier::isVirtual() const { return checkBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::setVirtual()      { setBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::unsetVirtual()    { unsetBit(e_virtual,p_modifierVector); }

bool SgFunctionModifier::isPureVirtual() const { return checkBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::setPureVirtual()      { setBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::unsetPureVirtual()    { unsetBit(e_pure_virtual,p_modifierVector); }

bool SgFunctionModifier::isExplicit() const { return checkBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::setExplicit()      { setBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::unsetExplicit()    { unsetBit(e_explicit,p_modifierVector); }

#if 0
bool SgFunctionModifier::isBind() const { return checkBit(e_bind,p_modifierVector); }
void SgFunctionModifier::setBind()      { setBit(e_bind,p_modifierVector); }
void SgFunctionModifier::unsetBind()    { unsetBit(e_bind,p_modifierVector); }
#endif

bool SgFunctionModifier::isPure() const { return checkBit(e_pure,p_modifierVector); }
void SgFunctionModifier::setPure()      { setBit(e_pure,p_modifierVector); }
void SgFunctionModifier::unsetPure()    { unsetBit(e_pure,p_modifierVector); }

bool SgFunctionModifier::isElemental() const { return checkBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::setElemental()      { setBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::unsetElemental()    { unsetBit(e_elemental,p_modifierVector); }

bool SgFunctionModifier::isRecursive() const { return checkBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::setRecursive()      { setBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::unsetRecursive()    { unsetBit(e_recursive,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeConstructor() const { return checkBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeConstructor()      { setBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeConstructor()    { unsetBit(e_gnu_attribute__constructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDestructor() const { return checkBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDestructor()      { setBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDestructor()    { unsetBit(e_gnu_attribute__destructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributePure() const { return checkBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributePure()      { setBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributePure()    { unsetBit(e_gnu_attribute__pure__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeMalloc() const { return checkBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeMalloc()      { setBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeMalloc()    { unsetBit(e_gnu_attribute__malloc__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNaked() const { return checkBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNaked()      { setBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNaked()    { unsetBit(e_gnu_attribute__naked__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInstrumentFunction() const { return checkBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInstrumentFunction()      { setBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInstrumentFunction()    { unsetBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoCheckMemoryUsage() const { return checkBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoCheckMemoryUsage()      { setBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoCheckMemoryUsage()    { unsetBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInline() const { return checkBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInline()      { setBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInline()    { unsetBit(e_gnu_attribute__noinline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeAlwaysInline() const { return checkBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeAlwaysInline()      { setBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeAlwaysInline()    { unsetBit(e_gnu_attribute__always_inline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoThrow() const { return checkBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoThrow()      { setBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoThrow()    { unsetBit(e_gnu_attribute__nothrow__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__,p_modifierVector); }

// TV (04/08/2010): Support for CUDA functions modifiers

bool SgFunctionModifier::isCudaDevice() const { return checkBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::setCudaDevice()      { setBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::unsetCudaDevice()    { unsetBit(e_cuda_device,p_modifierVector); }

bool SgFunctionModifier::isCudaKernel() const { return checkBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::setCudaKernel()      { setBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::unsetCudaKernel()    { unsetBit(e_cuda_kernel,p_modifierVector); }

bool SgFunctionModifier::isCudaHost() const { return checkBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::setCudaHost()      { setBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::unsetCudaHost()    { unsetBit(e_cuda_host,p_modifierVector); }

// TV (05/03/2010): Support for OpenCL functions modifiers
       
bool SgFunctionModifier::isOpenclKernel() const { return checkBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::setOpenclKernel()      { setBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::unsetOpenclKernel()    { unsetBit(e_opencl_kernel, p_modifierVector); }
          
bool SgFunctionModifier::hasOpenclVecTypeHint() const { return checkBit(e_opencl_vec_type_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclVecTypeHint()       { setBit(e_opencl_vec_type_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclVecTypeHint()     { unsetBit(e_opencl_vec_type_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeHint() const { return checkBit(e_opencl_work_group_size_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeHint()       { setBit(e_opencl_work_group_size_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclWorkGroupSizeHint()     { unsetBit(e_opencl_work_group_size_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeReq() const { return checkBit(e_opencl_work_group_size_req, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeReq()       { setBit(e_opencl_work_group_size_req,p_modifierVector);}
void SgFunctionModifier::unsetOpenclWorkGroupSizeReq()     { unsetBit(e_opencl_work_group_size_req, p_modifierVector); }


std::ostream & operator<< ( std::ostream & os, SgFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv ) 
   {
  // DQ (1/26/2006): Modified to handle 64 bit machines
  // for (unsigned int i=0; i < bv.size(); i++)
  // for (vector<bool>::size_type i=0; i < bv.size(); i++)
     for (unsigned int i=0; i < bv.size(); i++)
          os << ((bv[i] == true) ? "T" : "F");
     return os;
   }

string
SgFunctionModifier::displayString() const
   {
     std::string s = "SgFunctionModifier(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isInline() = ")      + std::string(isInline()      ? "true " : "false ");
     s += std::string("isVirtual() = ")     + std::string(isVirtual()     ? "true " : "false ");
     s += std::string("isPureVirtual() = ") + std::string(isPureVirtual() ? "true " : "false ");
     s += std::string("isExplicit() = ")    + std::string(isExplicit()    ? "true"  : "false");
  // s += std::string("isBind() = ")        + std::string(isBind()        ? "true " : "false ");
     s += std::string("isPure() = ")        + std::string(isPure()        ? "true " : "false ");
     s += ")";
     return s;
   }

void
SgFunctionModifier::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgFunctionModifier::reset()
   {
  // Unset each bit separately
     unsetUnknown();
     unsetInline();
     unsetVirtual();
     unsetPureVirtual();
     unsetExplicit();
  // unsetBind();
     unsetPure();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }
   
SOURCE_FUNCTION_MODIFIER_END


SOURCE_UPS_ACCESS_MODIFIER_START
// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

// bool $CLASSNAME::isUPC_Shared() const { return p_modifier == e_upc_shared; }
// void $CLASSNAME::setUPC_Shared()      { p_modifier = e_upc_shared; }

bool $CLASSNAME::isUPC_Strict() const { return p_modifier == e_upc_strict; }
void $CLASSNAME::setUPC_Strict()      { p_modifier = e_upc_strict; }

bool $CLASSNAME::isUPC_Relaxed() const { return p_modifier == e_upc_relaxed; }
void $CLASSNAME::setUPC_Relaxed()      { p_modifier = e_upc_relaxed; }

std::ostream & operator<< ( std::ostream & os, SgUPC_AccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
  // s += std::string("isUPC_Shared() = ")  + std::string(isUPC_Shared()  ? "true " : "false ");
     s += std::string("isUPC_Strict() = ")  + std::string(isUPC_Strict()  ? "true " : "false ");
     s += std::string("isUPC_Relaxed() = ") + std::string(isUPC_Relaxed() ? "true"  : "false");

  // DQ (6/13/2008): Added support for layout and shared use with "strict" or "relaxed"
     s += std::string("get_isShared() = ")  + std::string(get_isShared() ? "true " : "false ");
     s += std::string("get_layout() = ")  + StringUtility::numberToString(get_layout());

     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_UPS_ACCESS_MODIFIER_END


SOURCE_SPECIAL_FUNCTION_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool $CLASSNAME::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void $CLASSNAME::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void $CLASSNAME::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool $CLASSNAME::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void $CLASSNAME::setDefault()       { setBit(e_default,p_modifierVector); }
void $CLASSNAME::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool $CLASSNAME::isNotSpecial() const  { return checkBit(e_none,p_modifierVector); }
void $CLASSNAME::setNotSpecial()       { setBit(e_none,p_modifierVector); }
void $CLASSNAME::unsetNotSpecial()     { unsetBit(e_none,p_modifierVector); }

bool $CLASSNAME::isConstructor() const { return checkBit(e_constructor,p_modifierVector); }
void $CLASSNAME::setConstructor()      { setBit(e_constructor,p_modifierVector); }
void $CLASSNAME::unsetConstructor()    { unsetBit(e_constructor,p_modifierVector); }

bool $CLASSNAME::isDestructor() const  { return checkBit(e_destructor,p_modifierVector); }
void $CLASSNAME::setDestructor()       { setBit(e_destructor,p_modifierVector); }
void $CLASSNAME::unsetDestructor()     { unsetBit(e_destructor,p_modifierVector); }

bool $CLASSNAME::isConversion() const  { return checkBit(e_conversion,p_modifierVector); }
void $CLASSNAME::setConversion()       { setBit(e_conversion,p_modifierVector); }
void $CLASSNAME::unsetConversion()     { unsetBit(e_conversion,p_modifierVector); }

bool $CLASSNAME::isOperator() const    { return checkBit(e_operator,p_modifierVector); }
void $CLASSNAME::setOperator()         { setBit(e_operator,p_modifierVector); }
void $CLASSNAME::unsetOperator()       { unsetBit(e_operator,p_modifierVector); }

std::ostream & operator<< ( std::ostream & os, SgSpecialFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isNotSpecial() = ")  + std::string(isNotSpecial()  ? "true " : "false ");
     s += std::string("isConstructor() = ") + std::string(isConstructor() ? "true " : "false ");
     s += std::string("isDestructor() = ")  + std::string(isDestructor()  ? "true " : "false ");
     s += std::string("isConversion() = ")  + std::string(isConversion()  ? "true " : "false ");
     s += std::string("isOperator() = ")    + std::string(isOperator()    ? "true"  : "false");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetNotSpecial();
     unsetConstructor();
     unsetDestructor();
     unsetConversion();
     unsetOperator();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }

SOURCE_SPECIAL_FUNCTION_MODIFIER_END

SOURCE_DECLARATION_MODIFIER_START

// Copy constructor
SgDeclarationModifier::SgDeclarationModifier ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
   }

SgDeclarationModifier &
SgDeclarationModifier::operator= ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
     return *this;
   }

void
SgDeclarationModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgDeclarationModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgDeclarationModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgDeclarationModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgDeclarationModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgDeclarationModifier::isFriend() const  { return checkBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::setFriend()       { setBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::unsetFriend()     { unsetBit(e_friend,p_modifierVector); }

bool SgDeclarationModifier::isTypedef() const  { return checkBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::setTypedef()       { setBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::unsetTypedef()     { unsetBit(e_typedef,p_modifierVector); }

bool SgDeclarationModifier::isExport() const  { return checkBit(e_export,p_modifierVector); }
void SgDeclarationModifier::setExport()       { setBit(e_export,p_modifierVector); }
void SgDeclarationModifier::unsetExport()     { unsetBit(e_export,p_modifierVector); }

bool SgDeclarationModifier::isThrow() const  { return checkBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::setThrow()       { setBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::unsetThrow()     { unsetBit(e_throw,p_modifierVector); }

bool SgDeclarationModifier::isBind() const { return checkBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::setBind()      { setBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::unsetBind()    { unsetBit(e_bind,p_modifierVector); }

bool SgDeclarationModifier::isFinal() const { return checkBit(e_final,p_modifierVector); }
void SgDeclarationModifier::setFinal()      { setBit(e_final,p_modifierVector); }
void SgDeclarationModifier::unsetFinal()    { unsetBit(e_final,p_modifierVector); }

std::ostream & operator<< ( std::ostream & os, SgDeclarationModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

string
SgDeclarationModifier::displayString() const
   {
     std::string s = "SgDeclarationModifier(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isFriend() = ")  + std::string(isFriend()  ? "true " : "false ");
     s += std::string("isTypedef() = ") + std::string(isTypedef() ? "true " : "false ");
     s += std::string("isExport() = ")  + std::string(isExport()  ? "true " : "false ");
     s += std::string("isThrow() = ")   + std::string(isThrow()   ? "true " : "false ");
     s += std::string("isBind() = ")    + std::string(isBind()    ? "true " : "false ");
     s += std::string("isFinal() = ")   + std::string(isFinal()   ? "true " : "false ");
     s += std::string("\n     ") + get_typeModifier().displayString() + " ";
     s += std::string("\n     ") + get_accessModifier().displayString() + " ";
     s += std::string("\n     ") + get_storageModifier().displayString();
     s += ")";
     return s;
   }

void
SgDeclarationModifier::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgTypeModifier &
SgDeclarationModifier::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

SgAccessModifier &
SgDeclarationModifier::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

SgStorageModifier &
SgDeclarationModifier::get_storageModifier ()
   {
     assert (this != NULL);
     return p_storageModifier;
   }

const SgTypeModifier &
SgDeclarationModifier::get_typeModifier () const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

const SgAccessModifier &
SgDeclarationModifier::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgStorageModifier &
SgDeclarationModifier::get_storageModifier () const
   {
     assert (this != NULL);
     return p_storageModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void
SgDeclarationModifier::reset()
   {
     unsetUnknown();
     unsetFriend();
     unsetTypedef();
     unsetExport();
     unsetThrow();
     unsetBind();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_typeModifier().reset();
     get_accessModifier().reset();
     get_storageModifier().reset();
   }

SOURCE_DECLARATION_MODIFIER_END

SOURCE_TYPE_MODIFIER_START

// Copy constructor
SgTypeModifier::SgTypeModifier ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
   }

SgTypeModifier &
SgTypeModifier::operator= ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
     return *this;
   }

void
SgTypeModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgTypeModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgTypeModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgTypeModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgTypeModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgTypeModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgTypeModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgTypeModifier::isRestrict() const { return checkBit(e_restrict,p_modifierVector); }
void SgTypeModifier::setRestrict()      { setBit(e_restrict,p_modifierVector); }
void SgTypeModifier::unsetRestrict()    { unsetBit(e_restrict,p_modifierVector); }

#if 0
               e_allocatable    = 3, /*!< allocatable attribute specifier (for Fortran 90) */
               e_asynchronous   = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
               e_bind           = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
               e_data           = 6, /*!< data attribute specifier (for Fortran 77) */
               e_dimension      = 7, /*!< dimension attribute specifier (for Fortran 77) */
            // This should map to the C/C++ extern modifier in SgStorageModifier
            // e_external       = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
               e_intent_in      = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
               e_intent_out     = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
               e_intent_inout   = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
               e_intrinsic      = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
               e_optional       = 12,/*!< optional attribute specifier (for Fortran 90) */
            // This should map to const in the SgConstVolatileModifier
            // e_parameter      = xx,/*!< parameter attribute specifier (for Fortran 77) */

            // This should be mapped to the SgPointerType in C/C++
            // e_pointer        = xx,/*!< pointer attribute specifier (for Fortran 90) */
            // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
            // e_protected      = xx,/*!< protected attribute specifier (for Fortran 2003) */
               e_save           = 13,/*!< save attribute specifier (for Fortran 77) */
               e_target         = 14,/*!< target attribute specifier (for Fortran 90) */
               e_value          = 15,/*!< value attribute specifier (for Fortran 2003) */
#endif

// Fortran specific attribute
bool SgTypeModifier::isAllocatable() const  { return checkBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::setAllocatable()       { setBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::unsetAllocatable()     { unsetBit(e_allocatable,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAsynchronous() const  { return checkBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::setAsynchronous()       { setBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::unsetAsynchronous()     { unsetBit(e_asynchronous,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isBind() const  { return checkBit(e_bind,p_modifierVector); }
void SgTypeModifier::setBind()       { setBit(e_bind,p_modifierVector); }
void SgTypeModifier::unsetBind()     { unsetBit(e_bind,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isData() const  { return checkBit(e_data,p_modifierVector); }
void SgTypeModifier::setData()       { setBit(e_data,p_modifierVector); }
void SgTypeModifier::unsetData()     { unsetBit(e_data,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isDimension() const  { return checkBit(e_dimension,p_modifierVector); }
void SgTypeModifier::setDimension()       { setBit(e_dimension,p_modifierVector); }
void SgTypeModifier::unsetDimension()     { unsetBit(e_dimension,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_in() const  { return checkBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::setIntent_in()       { setBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::unsetIntent_in()     { unsetBit(e_intent_in,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_out() const  { return checkBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::setIntent_out()       { setBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::unsetIntent_out()     { unsetBit(e_intent_out,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_inout() const  { return checkBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::setIntent_inout()       { setBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::unsetIntent_inout()     { unsetBit(e_intent_inout,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntrinsic() const  { return checkBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::setIntrinsic()       { setBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::unsetIntrinsic()     { unsetBit(e_intrinsic,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isOptional() const  { return checkBit(e_optional,p_modifierVector); }
void SgTypeModifier::setOptional()       { setBit(e_optional,p_modifierVector); }
void SgTypeModifier::unsetOptional()     { unsetBit(e_optional,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isSave() const  { return checkBit(e_save,p_modifierVector); }
void SgTypeModifier::setSave()       { setBit(e_save,p_modifierVector); }
void SgTypeModifier::unsetSave()     { unsetBit(e_save,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isTarget() const  { return checkBit(e_target,p_modifierVector); }
void SgTypeModifier::setTarget()       { setBit(e_target,p_modifierVector); }
void SgTypeModifier::unsetTarget()     { unsetBit(e_target,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isValue() const  { return checkBit(e_value,p_modifierVector); }
void SgTypeModifier::setValue()       { setBit(e_value,p_modifierVector); }
void SgTypeModifier::unsetValue()     { unsetBit(e_value,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeUnused() const  { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeUnused()       { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeUnused()     { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributePacked() const  { return checkBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::setGnuAttributePacked()       { setBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributePacked()     { unsetBit(e_gnu_attribute__packed__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeDeprecated() const  { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeDeprecated()       { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeDeprecated()     { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeTransparentUnion() const  { return checkBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeTransparentUnion()       { setBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeTransparentUnion()     { unsetBit(e_gnu_attribute__transparent_union__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNoReturn() const  { return checkBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNoReturn()       { setBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNoReturn()     { unsetBit(e_gnu_attribute__noreturn__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeConst() const  { return checkBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeConst()       { setBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeConst()     { unsetBit(e_gnu_attribute__const__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeCdecl() const  { return checkBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeCdecl()       { setBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeCdecl()     { unsetBit(e_gnu_attribute__cdecl__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeStdcall() const  { return checkBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeStdcall()       { setBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeStdcall()     { unsetBit(e_gnu_attribute__stdcall__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeWarnUnusedResult() const  { return checkBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeWarnUnusedResult()       { setBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeWarnUnusedResult()     { unsetBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNonnull() const  { return checkBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNonnull()       { setBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNonnull()     { unsetBit(e_gnu_attribute__nonnull__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeSentinel() const  { return checkBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeSentinel()       { setBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeSentinel()     { unsetBit(e_gnu_attribute__sentinel__,p_modifierVector); }

std::ostream& operator<< (std::ostream& os, SgTypeModifier& tm) 
   {
      os << tm.get_modifierVector(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isRestrict() = ") + std::string(isRestrict() ? "true " : "false ");
     s += std::string("\n     ") + get_constVolatileModifier().displayString() + " ";
     s += std::string("\n     ") + get_upcModifier().displayString() + " ";
     s += std::string("\n     ") + get_elaboratedTypeModifier().displayString();
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier ()
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier ()
   {
     assert (this != NULL);
     return p_upcModifier;
   }

SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier ()
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetRestrict();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_constVolatileModifier().reset();
     get_upcModifier().reset();
     get_elaboratedTypeModifier().reset();
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier (void) const
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier (void) const
   {
     assert (this != NULL);
     return p_upcModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier (void) const
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }

SOURCE_TYPE_MODIFIER_END


SOURCE_ELABORATED_TYPE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isClass() const { return p_modifier == e_class; }
void $CLASSNAME::setClass()      { p_modifier = e_class; }

bool $CLASSNAME::isStruct() const { return p_modifier == e_struct; }
void $CLASSNAME::setStruct()      { p_modifier = e_struct; }

bool $CLASSNAME::isUnion() const { return p_modifier == e_union; }
void $CLASSNAME::setUnion()      { p_modifier = e_union; }

bool $CLASSNAME::isEnum() const { return p_modifier == e_enum; }
void $CLASSNAME::setEnum()      { p_modifier = e_enum; }

bool $CLASSNAME::isTypename() const { return p_modifier == e_typename; }
void $CLASSNAME::setTypename()      { p_modifier = e_typename; }

std::ostream & operator<< ( std::ostream & os, SgElaboratedTypeModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isClass() = ")    + std::string(isClass()    ? "true " : "false ");
     s += std::string("isStruct() = ")   + std::string(isStruct()   ? "true " : "false ");
     s += std::string("isUnion() = ")    + std::string(isUnion()    ? "true " : "false ");
     s += std::string("isEnum() = ")     + std::string(isEnum()     ? "true " : "false ");
     s += std::string("isTypename() = ") + std::string(isTypename() ? "true"  : "false");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_ELABORATED_TYPE_MODIFIER_END

SOURCE_LINKAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isC_Linkage() const { return p_modifier == e_C_linkage; }
void $CLASSNAME::setC_Linkage()      { p_modifier = e_C_linkage; }

bool $CLASSNAME::isCppLinkage() const { return p_modifier == e_Cpp_linkage; }
void $CLASSNAME::setCppLinkage()      { p_modifier = e_Cpp_linkage; }

bool $CLASSNAME::isFortranLinkage() const { return p_modifier == e_fortran_linkage; }
void $CLASSNAME::setFortranLinkage()      { p_modifier = e_fortran_linkage; }

std::ostream & operator<< ( std::ostream & os, SgLinkageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")        + std::string(isUnknown()        ? "true " : "false ");
     s += std::string("isDefault() = ")        + std::string(isDefault()        ? "true " : "false ");
     s += std::string("isC_Linkage() = ")      + std::string(isC_Linkage()      ? "true " : "false ");
     s += std::string("isCppLinkage() = ")     + std::string(isCppLinkage()     ? "true " : "false ");
     s += std::string("isFortranLinkage() = ") + std::string(isFortranLinkage() ? "true"  : "false");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_LINKAGE_MODIFIER_END

SOURCE_BASECLASS_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isVirtual() const { return p_modifier == e_virtual; }
void $CLASSNAME::setVirtual()      { p_modifier = e_virtual; }

std::ostream & operator<< ( std::ostream & os, SgBaseClassModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isVirtual() = ") + std::string(isVirtual() ? "true " : "false ");
     s += std::string("\n     ") + get_accessModifier().displayString();
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

SgAccessModifier &
$CLASSNAME::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgAccessModifier &
$CLASSNAME::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
     get_accessModifier().reset();
   }

SOURCE_BASECLASS_MODIFIER_END






HEADER_SYMBOL_TABLE_PREDECLARATION_START

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv );

/*! \brief Name equality operator support for symbol tables within ROSE.
 */
//#ifdef _MSC_VER 
#if 0
// DQ (11/29/2009): attempting to fix: error C2903: 'rebind' : symbol is neither a class template nor a function template
// #pragma message ("WARNING: struct eqstr skipped for MSVC.")
#else
struct eqstr
   {
     bool operator()(const SgName& s1, const SgName& s2) const
        {
          return s1.getString() == s2.getString();
        }
   };
#endif

/*! \brief Hash name support for symbol tables within ROSE.
 */
struct hash_Name
   {
// CH (4/8/2010): Use boost::unordered instead     
//#ifndef _MSC_VER 
     // CH (4/13/2010): Use boost::hash<string> instead  
     //rose_hash::hash<const char*> hasher;
     rose_hash::hash<std::string> hasher;
//#else
//   public:
//      static const size_t bucket_size = 4;
//      static const size_t min_buckets = 8;
//#endif

     public:
          size_t operator()(const SgName & name) const
             {
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER 
//               return stdext::hash_compare<const char*>()(name.str()); 
//#else
               return hasher(name.str());
//#endif
             }
   };

/*! \brief Hash table support for symbol tables within ROSE.

       This hash table support is used by the symbol tables within ROSE.  There is one global
    symbol table for all function symbols and then there symbol tables for each scope 
    (implemented in the SgScopeDeclaration).

    \internal Trivia: This was developed by Alin Jula, and as payment I bought him dinner 
    when Ken Kennedy visited LLNL.

 */
 // tps (11/19/2009) : Constructor of hash_multimap in MSVS is different

// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
#if 0
// DQ (11/27/2009): Trying to fix MSVC compiler warning: 
//    warning C4717: 'rose_hash_multimap::rose_hash_multimap' : recursive on all control paths, function will cause runtime stack overflow.

#if 0
template<class _Kty> inline size_t hash_value(const _Kty& _Keyval);
	{	// hash _Keyval to size_t value one-to-one
	return ((size_t)_Keyval ^ _HASH_SEED);
	}
#else
inline size_t hash_value(const SgName & _Keyval)
   {
     printf ("In custom hash_value function \n");
     assert(false);

     return 0;
   }
#endif

// class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>
class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*>
   {
     protected:
          SgNode * parent;

     public:
       // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
          rose_hash_multimap()
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>(), parent(NULL)
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>(), parent(NULL)
             {}
// tps (11/18/2009) : this constructor is not valid, see Node.code
#if 0
          rose_hash_multimap(int sz) 
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>(sz), parent(NULL)
             {}
#endif
#if 0
          rose_hash_multimap(const rose_hash_multimap& rhs) 
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>((rose_hash_multimap)rhs),parent(rhs.parent)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name>(const_cast<rose_hash_multimap>(rhs)),parent(rhs.parent)
             {}
#endif
#else  // ifdef _MSC_VER

class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>
//class rose_hash_multimap : public __gnu_cxx::hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>
   {
     protected:
          SgNode * parent;

     public:
       // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
          rose_hash_multimap()
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(), parent(NULL)
             //: __gnu_cxx::hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>(), parent(NULL)
             {}
          rose_hash_multimap(int sz) 
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz), parent(NULL)
             //: __gnu_cxx::hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz), parent(NULL)
             {}
          rose_hash_multimap(const rose_hash_multimap& rhs) 
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(/*(rose_hash_multimap)*/rhs),parent(rhs.parent)
             //: __gnu_cxx::hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>((rose_hash_multimap)rhs),parent(rhs.parent)
             {}
#endif
          void set_parent(SgNode * new_parent) 
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
#if 0
            // DQ (2/19/2007): I am not sure why this is commented out (has been since it was introduced summer of 2005)
               hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator it;
               for (it = begin(); it != end(); ++it)
                  {
                    delete (*it).second;
                    (*it).second = NULL;
                  }
#endif
             }

         ~rose_hash_multimap()
             {
               delete_elements();

            // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
               parent = NULL;
             }

     // JH (01/01/2006) friend class declarations to get direct access to data member for the ast file IO
        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it );

HEADER_SYMBOL_TABLE_PREDECLARATION_END


HEADER_SYMBOL_TABLE_START

       // AJ (10/21/2004): Added support STL based implementation of hash table.
       // I have replaced the p_table in the SgSymbolTable from a SgSymbolHashMultimap 
       // to the STL hash_multimap<SgName,SgSymbol*,..>. The hash function for SgName 
       // uses the native STL hash function for char* . The methods of SgSymbolTable 
       // were adjusted (where necessary) to accomodate the STL hash_multimap table. 
       // What we have now is the old interaface of SgSymbolTable working with STL 
       // hash_multimap AND the STL interaface through the hash_multimap table.

       // DQ (1/30/2007): Added many member functions back into ROSE, now that we both 
       // better appriciate why they are required and we are overhaling the symbol 
       // table interface generally.
       // Comment from 9/7/2006):
       // Many member functions were removed because they are (with few exceptions, 
       // where they have been recently restored) infreqently used and too 
       // much funcionality to support robustly.  Now that we use STL internally
       // and we make the STL hash map available, users have all possible access.

       // typedefs to STL container used internally
          typedef rose_hash_multimap BaseHashType;
          typedef BaseHashType::iterator hash_iterator;

       // Default constructor (builds the hash table using a default size: 17 typically)
          SgSymbolTable();

       //! Added to support scopes that have more symbols (e.g. SgGlobal, and the function type table)
          SgSymbolTable(int sz);

       // Destructors are automatically generated by ROSETTA and so should not be explicitly represented
       // ~SgSymbolTable();

       // General function used to build AST
          void insert ( const SgName &, SgSymbol *sp );

       // DQ (1/31/2007): Depricated (is not well named and should return bool)
          int  find   ( const SgName &, SgSymbol *sp ) ROSE_DEPRECATED_FUNCTION;

       // DQ (1/31/2007): New functions that will replace the depricated find() member function
       // Note that this is log n in complexity
          bool exists ( const SgName &, SgSymbol *sp ) const; //! Complexity O(log n), checks for existence of symbol before matching against names.

       // DQ (1/31/2007): This is log n in complexity
          bool exists ( const SgName & ) const;               //! Complexity O(log n)

       // DQ (1/31/2007): This is linear in complexity (expensive)
          bool exists ( const SgSymbol *sp ) const;           //! Complexity O(log n)

       // DQ (2/6/2007): find functions that take the declarations that are internally associated with SgSymbol IR nodes.
          SgSymbol* find( const SgInitializedName* initializedName); //! Complexity O(n)
          SgSymbol* find( const SgFunctionType* functionType);       //! Complexity O(n)
          SgSymbol* find( const SgStatement* statement);             //! Complexity O(n)

       // DQ (1/30/2007): Added general remove function for an explicitly identified SgSymbol
          void remove ( const SgSymbol* symbol );  //! Complexity O(log n)

       // DQ (1/30/2007): Added general remove functions for all SgSymbol IR nodes.
       // This function will remove all symbols with the specified name (even ones of
       // different typese, see rest of comment).
       // This function is a bit dangerous except for function types since the only for the 
       // function type table are the names unique.  For non-function type symbol 
       // tables classes and typedefs can have the same name (e.g. "typedef struct X {} X;")
       // so removing the name might have unexpected results! 
          void remove_function_type ( const SgName & ); //! Complexity O(log n)

#if 0
       // DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
       // This removes all the symbols matching the name or name and type of symbol
       // These can be dangerous where there are the names in the symbol table are 
       // not unique and especially when using multiple un-names declarations of 
       // the same type or symbol.
          void remove_function      ( const SgName & );
          void remove_class         ( const SgName & );
          void remove_enum          ( const SgName & );
          void remove_typedef       ( const SgName & );
          void remove_label         ( const SgName & );
          void remove_var           ( const SgName & );
          void remove_enum_field    ( const SgName & );
          void remove_function_type ( const SgName & );
          void remove_namespace     ( const SgName & );
#endif

       // Used by SgScopeStatement::lookup_symbol(const SgName& n)
          SgSymbol* findany(const SgName &) ROSE_DEPRECATED_FUNCTION;

       // Used only for global function type table
          SgFunctionTypeSymbol* findfunctype(const SgName&) ROSE_DEPRECATED_FUNCTION;

       // Used by Qing's AST Interface code
          SgVariableSymbol*  findvar(const SgName &) ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     findclass(const SgName &) ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfunc(const SgName&) ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfunc(const SgName&, const SgType*) ROSE_DEPRECATED_FUNCTION;

       // DQ (1/30/2007): New interface member functions using name.
       // These function search first against the name and then iteratively continue through 
       // the internal STL container to look for an entry that match the name and the type of
       // the SgSymbol.  This is optimially fast only for the case where there are unique names.
          SgSymbol*          find_any(const SgName &);                    //! Complexity O(log n) for first match against name, then O(n)
          SgVariableSymbol*  find_variable(const SgName &);               //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*     find_class(const SgName &);                  //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol*  find_function(const SgName&);                //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol*  find_function(const SgName&, const SgType*); //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionTypeSymbol* find_function_type(const SgName&);        //! Complexity O(log n) for first match against name, then O(n)

       // Additional find functions (using name)
          SgTypedefSymbol*   find_typedef(const SgName &);    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum(const SgName &);       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(const SgName &); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label(const SgName &);      //! Complexity O(log n) for first match against name, then O(n)
          SgNamespaceSymbol* find_namespace(const SgName &);  //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateSymbol*  find_template(const SgName &);   //! Complexity O(log n) for first match against name, then O(n)

          SgSymbol*          findfirstany() ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  findfirstvar() ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     findfirstclass() ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfirstfunction() ROSE_DEPRECATED_FUNCTION;

       // DQ (1/30/2007): New interface member functions: get the first symbol using type of SgSymbol
          SgSymbol*          find_any();      //! Complexity O(log n) for first match against name, then O(n)
          SgVariableSymbol*  find_variable(); //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*     find_class();    //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol*  find_function(); //! Complexity O(log n) for first match against name, then O(n)
       // DQ (2/19/2007): this is equivalent to the STL "begin()" function because 
       // SgFunctionTypeSymbol objects are placed into the global function type table.
       // SgFunctionTypeSymbol*  find_function_type();
          SgTypedefSymbol*   find_typedef();    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum();       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label();      //! Complexity O(log n) for first match against name, then O(n)
          SgNamespaceSymbol* find_namespace();  //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateSymbol*  find_template();   //! Complexity O(log n) for first match against name, then O(n)

          SgSymbol*          nextany() ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  nextvar() ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     nextclass() ROSE_DEPRECATED_FUNCTION;

       // Get the next symbol of a specific type, return NULL if not available.
       // These functions use state information set by the find functions (either
       // the versions using the name or not using a name as a parameter).
          SgSymbol*          next_any();        //! Complexity O(n)
          SgVariableSymbol*  next_variable();   //! Complexity O(n)
          SgClassSymbol*     next_class();      //! Complexity O(n)
          SgFunctionSymbol*  next_function();   //! Complexity O(n)
          SgTypedefSymbol*   next_typedef();    //! Complexity O(n)
          SgEnumSymbol*      next_enum();       //! Complexity O(n)
          SgEnumFieldSymbol* next_enum_field(); //! Complexity O(n)
          SgLabelSymbol*     next_label();      //! Complexity O(n)
          SgNamespaceSymbol* next_namespace();  //! Complexity O(n)
          SgTemplateSymbol*  next_template();   //! Complexity O(n)

       // for both global function and member functions
          SgFunctionSymbol*  nextfunc() ROSE_DEPRECATED_FUNCTION;

#if 0
       // DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
       // The next for functions have been placed back into the Sage III interface.
          SgVariableSymbol*  findfirstvar();
          SgVariableSymbol*  nextvar();
          SgSymbol*          nextany();
          SgSymbol*          findfirstany();
#endif
       // This is a cute operator to use, but since it can't specify a type of SgSymbol it is not so useful in practice.
          SgSymbol* operator[](const SgName &) ROSE_DEPRECATED_FUNCTION;

      //! Computes the number of symbols of a specific name
          int count(const SgName &) const;

      //! Outputs symbol table information (useful for debugging)
          void print( std::string label, VariantT nodeType = V_SgSymbol );
       // void print( std::string label );

       // Output to ostream (this function is not implemented)
       // void print(std::ostream&);

      //! Computes the number of symbols in the symbol table (forced to count them, I think, internal STL detail).
          int size() const; //! Complexity O(n)

      //! generate an STL set of all symbols (supports AST merge, but may be temporary)
          std::set<SgNode*> get_symbols() const;

#if 0
// DQ (3/10/2007): This approach in the end, didn't work.  So I think this can be removed!
      //! Generate unique name for matching named symbols of the same type (support for AST merge)
          unsigned int generateUniqueNumberForMatchingSymbol( SgDeclarationStatement* symbolBasis ) const;
#endif

      //! Generates name from any IR node used to generate symbols (only works on specific IR nodes)
          SgName get_name( const SgNode* node) const;

HEADER_SYMBOL_TABLE_END


HEADER_BASECLASS_START
     public:
          void post_construction_initialization();

       // This function should be autogenerated
       // SgBaseClass(int specifier=0, SgClassDeclaration* ptr = NULL, int dir = 0);
          SgBaseClass(const SgBaseClass& ptr);
      // ~SgBaseClass();
          SgBaseClass& operator= (const SgBaseClass& ptr);
      //  int get_base_specifier() const;
      //  SgClassDeclaration* get_base_class() const;
      //  SgClassDeclaration* replace_base_class(SgClassDeclaration*);

          bool operator== (const SgBaseClass& ) const;
          bool operator< (const SgBaseClass&) const;

       // DQ (4/25/2004): Part of new modifier interface
          SgBaseClassModifier & get_baseClassModifier();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

#if 0
  // These are now autogenerated
     private:
          int p_specifier;
          int p_direct;
          SgClassDeclaration* p_ptr;
#endif


HEADER_BASECLASS_END


HEADER_SYMBOL_TABLE_POSTDECLARATION_START
HEADER_SYMBOL_TABLE_POSTDECLARATION_END

HEADER_INITIALIZED_NAME_START

     public:

      /*! \brief Preinitialization Enum (only one value can be specified)

          Initialization information which I forget the details of ...

          \internal Only one value can be specified (at least in C and C++)
       */
          enum preinitialization_enum
             {
            // When used as entries in the preinitialization list we record extra data require to reset instantiated template names
               e_unknown_preinitialization = 0, /*!< default value */
               e_virtual_base_class        = 1, /*!< virtual base class value */
               e_nonvirtual_base_class     = 2, /*!< nonvirtual base class value */
               e_data_member               = 3, /*!< data member value */
               e_last_preinitialization         /*!< last value (upper bound on range of values, used in error checking) */
             };

      /*! \brief Register names (x86 specific GNU names).

          \internal These are all machine-specific.
       */
          enum asm_register_name_enum
             {
               e_invalid_register = 0,  /*!< error value */
               e_memory_register,       /*!< memory */
               e_register_a,
               e_register_b,
               e_register_c,
               e_register_d,            /*!< eax, ebx, ecx, edx */
               e_register_si,
               e_register_di,
               e_register_bp,
               e_register_sp,           /*!< esi, edi, ebp, esp */
               e_register_r8,
               e_register_r9,
               e_register_r10,
               e_register_r11,          /*!< x86-64 extra integer registers */
               e_register_r12,
               e_register_r13,
               e_register_r14,
               e_register_r15,
               e_register_st0,
               e_register_st1,
               e_register_st2,
               e_register_st3,          /*!< 80387 floating point stack */
               e_register_st4,
               e_register_st5,
               e_register_st6,
               e_register_st7,
               e_register_mm0,
               e_register_mm1,
               e_register_mm2,
               e_register_mm3,          /*!< MMX registers */
               e_register_mm4,
               e_register_mm5,
               e_register_mm6,
               e_register_mm7,
               e_register_f0,
               e_register_f1,
               e_register_f2,
               e_register_f3,           /*!< SSE/SSE2 registers */
               e_register_f4,
               e_register_f5,
               e_register_f6,
               e_register_f7,
               e_register_f8,
               e_register_f9,
               e_register_f10,
               e_register_f11,          /*!< x86-64 extra SSE registers */
               e_register_f12,
               e_register_f13,
               e_register_f14,
               e_register_f15,
               e_register_flags,
               e_register_fpsr,
               e_register_dirflag,      /*!< control registers */
               e_unrecognized_register, /*!< used to represent an unrecognized register. */
               e_last_register
             };

       // DQ (1/3/2009): This might imply that we need a variable modifier (SgVariableModifier 
       // (as a new IR node, but for now implement these directly since they are GNU specific 
       // attributes (extensions)).
          enum gnu_variable_attribute_enum
             {
            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__weak__                   = 0, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 1, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 2, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 3, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nocommon__               = 4, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__      = 5, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 6,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__packed__                 = 6,/*!< GNU specific attribute for (GNU extension) */
               e_last_gnu_variable_attribute /*!< last value (upper bound on range of values, used in error checking) */
             };

          bool checkBit ( unsigned int bit ) const;
          void setBit ( unsigned int bit );
          void unsetBit ( unsigned int bit );

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeNoCommon() const;
          void setGnuAttributeNoCommon();
          void unsetGnuAttributeNoCommon();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

          void post_construction_initialization();
       // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const;
          virtual bool cfgIsIndexInteresting(unsigned int index) const;
          virtual unsigned int cfgFindChildIndex(SgNode* n);
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

          SgStorageModifier & get_storageModifier();

       // DQ (8/10/2010): Added const version of this function!
          const SgStorageModifier & get_storageModifier() const;

      //  These are automatically generated! (not an option currently)
      //  SgInitializedName();
      // ~SgInitializedName();
          SgInitializedName(
               const SgName& name, 
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgDeclarationStatement *declptr = 0,
//  QY 11/2/04  removed itemptr 
//               SgInitializedName *itemptr = 0,
               SgInitializedName *prev_decl_item = 0 ) ROSE_DEPRECATED_FUNCTION;

       // DQ (8/4/2006): New constructor that explicitly includes the Sg_File_Info and SgScopeStatement (recently added data members)
          SgInitializedName ( Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr, 
                              SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr );

#ifdef BUILD_X_VERSION_TERMINALS
          SgInitializedName(
               const SgName& name, 
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgX_DeclarationStatement *declptr = 0,
//               SgInitializedName *itemptr = 0,
               SgInitializedName *prev_decl_item = 0 );
#endif

          SgInitializedName(const SgInitializedName& ptr);

          SgInitializedName& operator= (const SgInitializedName& ptr);

          bool operator== (const SgInitializedName& ) const;
          bool operator< (const SgInitializedName&) const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): This custom function to match the version that would be automatically by ROSETTA, but we 
       // want to have a custom version of set_name(SgName name) that permits names to be reset (unloaded from the 
       // symbol table are reloaded into the symbol table).
       // SgName get_name() const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): Put back into place afterhaving been removed by accident in 12/??/2004
       // AJ (10/21/2004): Added function to support changing names of symbols, note that void set_name(SgName name) 
       // would be the automatically generated function.
       // void set_name(SgName name);
       // int set_name(SgName new_name);

          SgType *get_type() const;
          void set_type(SgType *t);

          SgInitializer *get_initializer() const;
          void set_initializer(SgInitializer* i);

#ifdef BUILD_X_VERSION_TERMINALS
       // Modified from SAGE (added access functions for X version of DeclarationStatement data member
          SgX_DeclarationStatement *get_X_declaration() const;
          void set_X_declaration(SgX_DeclarationStatement* decl);
#endif

          SgDeclarationStatement *get_declaration() const;
         // void set_declaration(SgDeclarationStatement* decl);

          SgDeclarationStatement *get_definition() const;
          void set_definition(SgDeclarationStatement* def);

       // DQ (8/2/2004): Force an explicit function matching the virtual function defined in SgNode
       // Sg_File_Info* get_file_info() const;

      //! Returns the name with appropriate qualified names representing nested scopes
          SgName get_qualified_name() const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (11/6/2006): use this to return the startOfConstruct source position.
          virtual Sg_File_Info* get_file_info(void) const;
          virtual void set_file_info(Sg_File_Info* X);

       // DQ (2/6/2007): Added support to get the symbol from the declaration (via the symbol table in the scope)
      //! Get the associated SgSymbol from the symbol table located in the scope
          SgSymbol* get_symbol_from_symbol_table() const;

       // PC (10/1/2009): Added support to get the symbol from the correct associated declaration
          SgSymbol* search_for_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_INITIALIZED_NAME_END


HEADER_NAME_START
       // We need to define the default constructor explicitly 
       // (else p_char is not initialized properly to NULL)
          SgName();
          SgName(const char* str);
          SgName(const std::string& str);
          SgName(const SgName& n);

      // ~SgName();

          int operator!=(const SgName& n1) const;
          int operator==(const SgName& n1) const;
          int operator<(const SgName& n1) const;

       // Added to support assignments to string variables.
          operator std::string () const;

       // DQ (11/28/2009): Fixed return value of function to be "bool" instead of "int"
          bool is_null(void) const;
          void replace_space(char t);
          SgName& operator<<(const std::string& str);

          static SgName itoname(int val);

          SgName& operator<<(int val);
          SgName& operator=(const SgName& n1);
          SgName& tail(int n); // keep std::string after n
          SgName& head(int n); // keep first n chars

          const char* str() const;
          std::string& getString();
          const std::string& getString() const;

       // In places where the str() member function is called it is toe get the 
       // length of the std::string in p_char so it makes since to provide a member 
       // function to get the length instead of making a the str() function a 
       // const member function!
          unsigned int get_length() const;

       // DQ: We made this a const function to work with the Sage Symbol Table implementation 
       // But it is a bad idea to have it since it causes problems where it is used.
       // EXAMPLE: char* char_pointer = tempSgName;
       // this code fragment causes a new SgName object to be build and the pointer to 
       // the std::string in the new object is returned then the SgName object goes out of 
       // scope and then reading the std::string causes a purify FMR error!
       // It might be that it should not be a const function (this is likely the 
       // real source of the problem), but I would like to remove it anyway for 
       // now to simplify the debugging!
       // operator char*() const;

       // To handle "assert(p_name != NULL);" where p_name is a SgName
       // object, STL requires that the "operator==()" be defined
       // (STL builds the "operator!=()" from the "operator==()"
          bool operator== (const int i) const { return false; }

          void display( const std::string& label ) const;

       // DQ (9/9/2004): Supporting function for building qualified names (specialied std::string concatination)
          static SgName assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName);

       // DQ (9/9/2004): friend function (string concatination)
          friend SgName operator+(const SgName & n1, const SgName & n2);

       // DQ (11/15/2004): Added to support general string operations (first used in the unparser)
          SgName & operator+= (const SgName & n1);

HEADER_NAME_END


HEADER_NAME_POSTDECLARATION_START
// extern const SgName defaultName("defaultName");

// DQ (10/5/2007): We no longer need this!
// extern const SgName SgdefaultName;

HEADER_NAME_POSTDECLARATION_END


HEADER_QUALIFIED_NAME_START
HEADER_QUALIFIED_NAME_END


HEADER_ATTRIBUTE_START
       // SgAttribute(char* str);
          int isSame(const std::string& str);
          virtual bool isPragma() { return 0; } // MS02/22/02
       // char *get_name() const;

      protected:
       // char* p_name;

HEADER_ATTRIBUTE_END


HEADER_BIT_ATTRIBUTE_START
       // SgBitAttribute(char *str);

//        int isAttributeSet(unsigned long int bit) const;
//        void setAttribute(unsigned long int bit);
//        void unsetAttribute(unsigned long int bit);
//        int isPragma() const;

  // private:
  //      unsigned long int p_bitflag;

HEADER_BIT_ATTRIBUTE_END


HEADER_FUNCTION_DECLARATION_ATTRIBUTE_START
       // SgFuncDecl_attr();
       // void set_suppress_atomic();
       // int get_suppress_atomic() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFuncDecl_attr();

     private:
       // enum { e_suppressatomic = 0x00000001 };

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_END

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
// int get_suppress_atomic(SgFunctionDeclaration *); 
// void set_suppress_atomic(SgFunctionDeclaration *);

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFuncDecl_attr::SgFuncDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END



HEADER_CLASS_DECLARATION_ATTRIBUTE_START
       /* local attribute class to suppress the printing of global keyword */
//        SgClassDecl_attr();
//        void set_suppress_global();
//        int get_suppress_global() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgClassDecl_attr();

     private:
//        enum { e_suppress_global = 0x00000001 };

HEADER_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_CLASS_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgClassDecl_attr::SgClassDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE.
//
       /* local attribute class to suppress the printing of global keyword */
          SgTemplateInstDecl_attr();
          void set_suppress_global();
          int get_suppress_global() const;

     private:

      /*! What is this enum value for???  Shouldn't there be a name? */
          enum
             {
               e_suppress_global = 0x00000001 /*!< What is the point of having a single value here? */
             };

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//int get_suppress_globalSgClassDeclaration *);
//void set_suppress_global(SgClassDeclaration *); 

HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION.
//
int get_suppress_global(SgTemplateInstantiationDecl *);
void set_suppress_global(SgTemplateInstantiationDecl *); 

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END


HEADER_PRAGMA_START
       // SgPragma(char *name);

          void post_construction_initialization();

          std::string get_pragma() const;
          bool samePragma(const std::string& str);
          bool isPragma() const;
          bool gotPrinted() const;
          void setPrinted(bool s = true);

       // DQ (8/3/2004): added function to match virtual function in SgNode
          Sg_File_Info* get_file_info() const;

HEADER_PRAGMA_END


HEADER_FILE_INFORMATION_START

      /*! \brief Enum type containing classifications if IR nodes.

          This is part of the classification mechanism for IR nodes within ROSE.
          Compiler generated code is not output in the code generation phase,
          but some compiler generated IR nodes must be output so such nodes are explicitly 
          marked within the classification process (implemented in ASTFixes.C).
             - Examples of transformation IR nodes include:
                -# Any relocated AST subtrees
                -# Any new IR nodes
             - Examples of compiler-generated IR nodes include:
                -# Any implicit or unnecessary casts not explicitly represented in the source code
                -# Instantiated templates
             - Examples of compiler-generated code marked for output (in code generation phase) include:
                -# Any transformed template instantiations
                -# required templates assigned to specific files (see ROSE prelinking details)
             - Examples of shared IR nodes include:
                -# All types (not implemented yet)
                -# All IR nodes shared across originally separate ASTs (see AST Merge Mechanism)
             - Examples of frontend specific IR nodes include:
                -# float __builtin_acosf (float __builtin__x);
                -# #define __builtin_va_start va_start
                -# All functions and variables defined in "rose_edg_required_macros_and_functions.h"

          \internal We need constructors taking a value of this type.
       */
          enum classifier
             {
               e_transformation                          = 0x1, /*!< classify as a transformation */
               e_compiler_generated                      = 0x2, /*!< classify as compiler generated */
               e_output_in_code_generation               = 0x4, /*!< classify as required when generating code in unparser (orthogonal concept to transformation and compiler generated) */
               e_shared                                  = 0x8, /*!< classify as a shared IR node (part of evolving support for AST merging) */
               e_frontend_specific                       = 0x10,/*!< classify as frontend specific (e.g. gnu compatable function from rose_edg_required_macros_and_functions.h) */
               e_source_position_unavailable_in_frontend = 0x20,/*!< classify as explictly unabailable from front-end */
               e_comment_or_directive                    = 0x40,/*!< classify as a comment or directive (not a part of the language grammar) */
               e_token                                   = 0x80 /*!< classify as a token from the parser (not a part of the language grammar) */
             };

       // ~Sg_File_Info();

       // DQ (5/10/2006): Remove these to simplify implementation.
          Sg_File_Info();
       // Sg_File_Info(const char* filename, int line = 0, int col = 0) ROSE_DEPRECATED_FUNCTION;
          Sg_File_Info(const std::string & filename, int line = 0, int col = 0);

       // DQ (2/15/2003): added copy constructor
          Sg_File_Info(const Sg_File_Info & X);

       // DQ (11/6/2008): Added to support construction of objects using Dwarf information.
          Sg_File_Info( int file_id, int line, int column );

          void post_construction_initialization();

       // DQ (11/6/2008): Added support for extending the internal static filename to integer id map
      //! Access function to permit files referenced in Dwarf to be mapped to integers using the same scheme as for source code.
          static int addFilenameToMap ( const std::string & filename );

      //! Returns the number of entries in the filename map
          static int numberOfSourceFiles();

          void set_filename (const char* filename) ROSE_DEPRECATED_FUNCTION;
          void set_filenameString ( const std::string & filename );
          void set_line (int line);
          void set_col ( int n );
          void display (const std::string label ) const;
          void display () const;
          std::string displayString (const std::string & label = "") const;
          //void output (std::ostream& os) ROSE_DEPRECATED_FUNCTION;

       // DQ (6/11/2007): output static data for debugging
          static void display_static_data( const std::string label );

          const char* get_filename() const ROSE_DEPRECATED_FUNCTION;
          const std::string& get_filenameString() const;
          int   get_line() const;
          int   get_col() const;

          void set_file_id ( int file_id );
          int get_file_id () const;

          std::string get_raw_filename() const;
          int   get_raw_line() const;
          int   get_raw_col() const;

       // DQ (12/22/2006): This copies the line number and column number information and verifies that 
       // the file name is the same (it does not reset any fo the classification flags).  This is more
       // useful than the assignment operator for updating information and is used in the file:
       // fixupSourcePositionInformation.C
          void updateSourcePosition ( Sg_File_Info* update );

       // DQ (6/20/2005): There are a number of reasons why an IR node might not have a position in the source code
       // this function abstracts that query process.
          bool hasPositionInSource() const;

       // DQ (6/21/2005): check if this file info object is from the same file

       // DQ (9/5/2008): Switched back to using SgFile instead of SgSourceFile.
       // bool isSameFile(SgFile* file) const;
       // bool isSameFile(SgSourceFile* file) const;
          bool isSameFile(SgFile* file) const;

       // DQ (1/18/2006): Added new function with more useful interface.
          bool isSameFile(Sg_File_Info* fileInfo) const;
       // DQ (11/1/2006): Alternative use case.
          bool isSameFile(const Sg_File_Info & fileInfo) const;

      //! Access function for classification bit field
       // bool isOriginal() const;
          bool isTransformation() const;
       // bool isDeclaration() const ROSE_DEPRECATED_FUNCTION;
       // bool isInitialization() const ROSE_DEPRECATED_FUNCTION;

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          bool isCompilerGenerated() const;
          bool isCompilerGeneratedNodeToBeUnparsed() const ROSE_DEPRECATED_FUNCTION;
          bool isOutputInCodeGeneration() const;
          bool isShared() const;
          bool isFrontendSpecific() const;
       // bool isUnused1() const;

          bool isSourcePositionUnavailableInFrontend() const;
          void unsetSourcePositionUnavailableInFrontend();
          void setSourcePositionUnavailableInFrontend();

       // DQ (12/23/2006): Added to support the Sg_File_Info objects used by comments and CPP directives 
       // (since their parents are NULL, becuase the PreprocessingInfo class is not dirived from a SgNode 
       // the parent point can't be used to point to it).
          bool isCommentOrDirective() const;
          void unsetCommentOrDirective();
          void setCommentOrDirective();

       // DQ (12/23/2006): Added to support Rama and Andreas's work on handling of token streams within the AST.
       // (The Sg_File_Info objects used have NULL parent pointers, becuase the token class is not dirived from a SgNode.
          bool isToken() const;
          void unsetToken();
          void setToken();

      //! Set/unset functions for classification bit field
       // void unsetOriginal();
       // void setOriginal();
          void unsetTransformation();
          void setTransformation();
       // void unsetDeclaration();
       // void setDeclaration();
       // void unsetInitialization();
       // void setInitialization();

      //! Mark as compiler generated but as required to be output by unparser (e.g. required template instatiations)
          void unsetCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;
          void setCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;

      //! Mark as to be output by the unparser (code generator)
          void unsetOutputInCodeGeneration();
          void setOutputInCodeGeneration();

      //! Support for shared IR nodes (shared via AST merge mechanism)
          void unsetShared();
          void setShared();

       // DQ (5/6/2006): Added to support gnu compatability mode (incomplete within EDG and 
       // which we make complete through the declaration of builtin functions as required).
          void unsetFrontendSpecific();
          void setFrontendSpecific();

       // MK (8/2/05) : Added support for unparsing set, to allow shared nodes to only be unparsed by
       //               the appropriate files
      //! Add files to the set that should be able to unparse the node
          void addFileToUnparse(int file_id); 
      //! Should this node be unparsed by this file?
          bool shouldUnparse(int file_id);

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          void unsetCompilerGenerated();
          void setCompilerGenerated();

       // DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
          static Sg_File_Info* generateDefaultFileInfo();

          static Sg_File_Info* generateDefaultFileInfoForTransformationNode();

       // DQ (1/11/2006): Added static function whicl allows specification of transformation with assignement to 
       // a specific file (where it would be unparsed). This function will call setOutputInCodeGeneration().
          static Sg_File_Info* generateFileInfoForTransformationNode( int file_id );
          static Sg_File_Info* generateFileInfoForTransformationNode( std::string filename );

          static Sg_File_Info* generateDefaultFileInfoForCompilerGeneratedNode();


      //! Get whole bit field fr modifier set
          unsigned int get_classificationBitField(void) const;
          void set_classificationBitField( unsigned int );

          void set_isPartOfTransformation( bool isPartOfTransformation ) ROSE_DEPRECATED_FUNCTION;
          bool get_isPartOfTransformation() ROSE_DEPRECATED_FUNCTION;

          void register_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION; /* register interest */
          void deregister_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION;

       // functions added by Dan Quinlan (suggested by Gary Lee)
       // int   getCurrentLine () const ROSE_DEPRECATED_FUNCTION;
       // std::string getCurrentFilename () const ROSE_DEPRECATED_FUNCTION;

       // int   getReferenceCount() ROSE_DEPRECATED_FUNCTION;
       // void  incrementReferenceCount() ROSE_DEPRECATED_FUNCTION;
       // void  decrementReferenceCount() ROSE_DEPRECATED_FUNCTION;

       // DQ (7/4/2005): Added to test internal consistancy
          bool ok() const;
       // bool consistancyCheck() const;

       // MK (8/2/05) : Added functions to interface with fileid maps, in order to eventually
       //               restrict access to the maps themselves
       // PC and AS (8/29/06) : made function return a const string reference as this will
       // eliminate the temporary string within the lifetime of the function.
          static const std::string& getFilenameFromID( int id );
          static int getIDFromFilename( std::string filename );

       // DQ (11/2/2006): Added simple assignment operator.
          Sg_File_Info & operator= ( const Sg_File_Info & X );

       // DQ (9/26/2004): Added operator== to permit testing of reused definitions of defining declarations!
          friend bool operator== ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/6/2004): Added operator!= to permit testing of reused definitions of defining declarations!
          friend bool operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/25/2004): Added operator> to permit testing of strting vs. ending file info object (assert starting < ending)
          friend bool operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y );

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember fileidtoname_map.
          static std::map<int, std::string> & get_fileidtoname_map();
       //! Access function for map of file names.
          static void set_fileidtoname_map(std::map<int, std::string> & X);

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember nametofileid_map.
         static std::map<std::string, int> & get_nametofileid_map();
       //! Access function for map of file names.
         static void set_nametofileid_map(std::map<std::string,int> & X);

       // MK (7/22/05) This enum is used by the file id mechanism
       /*! \brief Enum to hold previously common default values for filename used by the default and static SgNULL_File constructors.

           \internal These values can and likely should disappear in the future.
        */
          enum p_fileflags {
               COPY_FILE_ID                                 = -1, /*!< default value (equivalent to filename with "COPY") */
               NULL_FILE_ID                                 = -2, /*!< value equivalent to filename with "NULL_FILE" */
               TRANSFORMATION_FILE_ID                       = -3, /*!< value for all nodes marked as part of a translation */
               COMPILER_GENERATED_FILE_ID                   = -4, /*!< value for compiler generated IR nodes (NOT marked for output) */
               COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID = -5, /*!< value for compiler generated IR nodes (marked for output, deprecated value) */
            // MK (8/2/05) : Added new enum value to facilitate interface to maps. If we try
            //               to retrieve the fileid for a filename which isn't in the map, we return
            //               BAD_FILE_ID to indicate this.
               BAD_FILE_ID = -6   /*!< value returned if there is no file id mapped to given filename */
             };

#if 0
       // DQ (12/20/2005): These have been placed into ROSETTA

       // MK (7/22/05) These maps are used by the file id mechanism
      //! STL map object to hold file id's to strings
          static std::map<int, std::string> p_fileidtoname_map;
      //! STL map to hold reverse map of p_fileidtoname_map
          static std::map<std::string, int> p_nametofileid_map;

       // MK (7/22/05) These maps are used by the file id mechanism
      //! This allows us to generate unique file ids for every filename we see.
          static int p_max_file_id;
#endif

HEADER_FILE_INFORMATION_END

HEADER_APPLICATION_FILE_PREDECLARATION_START
// DQ (4/23/2006): Declaration of friend functions outside of class required by g++ 4.1.0!
// void alternativeSageEdgInterfaceConstruction( SgFile *file );
HEADER_APPLICATION_FILE_PREDECLARATION_END

HEADER_APPLICATION_FILE_START

       /*! \brief Enum type used to specify output of Fortran as fixed for free format.

           \internal Has no effect on C/C++ code generation.
        */
          enum outputFormatOption_enum 
             {
               e_unknown_output_format,    /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_fixed_form_output_format, /*!< value used to specify output of Fortran as fixed format */
               e_free_form_output_format   /*!< value used to specify output of Fortran as free format */
             };


       /*! \brief Enum type used to specify output language (option used for testing unparsers).

           \internal This is only for testing the unparsers and some language constructs will not unparse. 
                     This is also a way to play with some language translation ideas, but most useful one 
                     will require a specialized tranlator to be built.
        */
          enum outputLanguageOption_enum 
             {
               e_error_output_language,   /*!< error value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_default_output_language, /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_C_output_language,       /*!< value used to specify output of C (for testing C unparser) */
               e_Cxx_output_language,     /*!< value used to specify output of C++ (for testing C++ unparser) */
               e_Fortran_output_language, /*!< value used to specify output of Fortran (for testing the Fortran unparser from C) */
               e_Promela_output_language, /*!< value used to specify output of Promela for uses with SPIN (unsupported option) */
               e_PHP_output_language,     /*!< value used to specify output of PHP */
               e_last_output_language     /*!< upper bound on the range of values supported for the outputLanguageOption_enum */
             };

      //! The only useful constructor (the argc and argv are the user's command line inputs and the
      //! errorCode is the return value assembled from the multiple error codes associated with the 
      //! different phases of the compilation.  The fileNameIndex is the index into the list of
      //! file names input on the user's command line.  We need a way to process them individually!
          SgFile ( int & argc, char** & argv,  SgProject* project = NULL );
          SgFile(std::vector<std::string>& argv,  SgProject* project = NULL);

       // SgFile ( int & argc, char** & argv, int & errorCode, int fileNameIndex, SgProject* project );
       //   virtual void doSetupForConstructor(const std::vector<std::string>& argv, int& errorCode, int fileNameIndex, SgProject* project);
       //AS(10/04/08) Changed semantics of doSetupForConstructor to not call frontend
          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

      //! Default constructor (not meant to be used)
      //  SgFile() ROSE_DEPRECATED_FUNCTION;

      //! Destructor
      // ~SgFile();

      //! Initialization support for constructors
          void initialization ();

      //! Unparsing support for generating C++ code from the internal Abstract Syntax Tree (AST)
      //  void unparsestdout();

      //! Unparsing support for generating C++ code from the internal Abstract Syntax Tree (AST)
      //  void unparse ( std::ostream & os );

       // Root of the Abstract Syntax Tree (AST) representing this file 
       // (a Sg global declaration scope statement).
       // SgGlobal & root() ROSE_DEPRECATED_FUNCTION;

      //! Root of the Abstract Syntax Tree (AST) representing this file 
       // DQ (7/19/2005): Added to support future name change from "root"
       // SgGlobal* get_globalScope() const;

       // DQ (9/5/2008): Support for older name of the SgGlobal in SgSourceFile
       // SgGlobal* get_root() const;

       // DQ (3/18/2006): Modified the unparse function interface to permit specification of default 
       // arguments to control code generation formatting and use of alternative code generation 
       // approaches (copy based code generation).
       // void unparse ();
      //! Generate the C++ file representing the AST
          void unparse ( UnparseFormatHelp *unparseHelp = NULL, UnparseDelegate* unparseDelagate = NULL );

       // DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information) 
       // to be relative to the generated code instead of the original input code.  This is useful when 
       // we want to output references to the position of language constructs in the generated code
       // instead of the original input code.  Also useful for building references to locations in 
       // automatically generated code.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      //! Member function to compile the resulting output file from unparsing
      //  BP : 11/13/2001, modified to include compiler name
          int compileOutput ( int fileNameIndex, const std::string& compilerName );

       // function to generate PDF output file for AST
       // void outputPDF();

      //! associated filename
          std::string getFileName() const;

      //! Move this function from ROSE into the AST restructuring tool
//        friend void roseDisplayMechanism( SgFile *file );
          friend void alternativeSageEdgInterfaceConstruction( SgFile *file );


      //! Move this function from ROSE into the AST restructuring tool
       // int callFrontEnd ( int & argc, char** & argv , SgFile & file, int fileNameIndex );
       // int callFrontEnd ( int & argc, char** & argv );

       // Get the commandline from where it is stored internally
          virtual int callFrontEnd();

      //! Fixups to be run when the whole project has been created (this attaches preprocessing information).
       // GB (9/4/2009)
          void secondaryPassOverSourceFile();

       // DQ (9/2/2008): Added to factor out detail fo building the AST in callFrontEnd().
          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! Move this function from ROSE into the AST restructuring tool
          void processRoseCommandLineOptions ( std::vector<std::string>& argv );

       // DQ (6/21/2005): Added support for backend specific command-line options to be recognized in ROSE 
       // (required to control template instantiation).  Does not modify input parameters.
          void processBackendSpecificCommandLineOptions ( const std::vector<std::string>& argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all rose related options from a command line
          static void stripRoseCommandLineOptions ( std::vector<std::string> & argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all EDG related options from a command line
          static void stripEdgCommandLineOptions ( std::vector<std::string> & argv );

       // BP : 11/13/2001, modified to take compiler name
          void build_EDG_CommandLine ( std::vector<std::string> & inputCommandLine, std::vector<std::string>& argv, int fileNameIndex );

      //! Move this function from ROSE into the AST restructuring tool
      //  friend void pdfPrintAbstractSyntaxTreeEDG  ( SgFile *file, bool writeOutHeaderFiles = false );
      //  friend void pdfPrintAbstractSyntaxTreeEDG  ( SgFile *file );
      //  friend void pdfPrintAbstractSyntaxTreeSage ( SgFile *file, bool writeOutHeaderFiles = false );

       // Move this function from ROSE into the AST restructuring tool (placed here os it can be called)
          static void usage ( int status );

      //! Move this function from ROSE into the AST restructuring tool
          std::string getWorkingDirectory ();
          std::string getSourceDirectory  ();

      //! Generate an output filename from the source file name (xxx.C -> rose_xxx.C -> xxx.o -> xxx)
          std::string generateOutputFileName() const;

      //! Support for C preprocessed files (Fortran only).
          std::string generate_C_preprocessor_intermediate_filename( std::string filename );

       // The unparser and vendor compiler needs access to many variables
       // that are protected (Later this should be a member function).
       // friend void unparseFile ( SgFile & file );
       // friend int compileOutput ( int & argc, char** & argv, SgFile & file );
       // BP : 11/13/2001, modified to include compiler name
          std::vector<std::string> buildCompilerCommandLineOptions ( std::vector<std::string> & argv, int fileNameIndex, const std::string& compilerName );
       // BP : 11/13/2001, modified to include compiler name
          int compileOutput ( std::vector<std::string> & argv, int fileNameIndex, const std::string& compilerName );

          void display ( const std::string & label ) const;

      //! Test if project is compiled with -prelink as signal that we are prelinking and we have 
      //! to process the generated code instead of the user's application (to see and instatiate 
      //! all templates).
          bool isPrelinkPhase() const;

      //! Get the SgProject IR node if available (template instantiation information is stored there)
          SgProject* get_project();

       // DQ (1/17/2006): Build an explicit copy constructor that returns an error internally
          SgFile ( const SgFile & X );

       // DQ (1/18/2006): Added function to be match virtual function on SgNode
       // (so that the SgFile's Sg_File_Info object could be accessed).
       // Sg_File_Info* get_file_info(void) const;

      //! Sets up the source file name (there should only be one source file in the 
      //! commandline to a SgFile, there can be multiple ones to a SgProject).
      //    void setupSourceFilename ( const std::vector<std::string>& argv );

      //! Access function calling get_startOfConstruct(), provided to support older interface.
          Sg_File_Info* get_file_info() const;

      //! Access function calling set_startOfConstruct(), provided to support older interface.
          void set_file_info( Sg_File_Info* fileinfo );

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This function is called at several locations to build SgSourceFiles of different types (languages).
          void initializeSourcePosition( const std::string & sourceFilename );

       // DQ (2/5/2009): This is now a data member at SgProject and SgFile.
       // DQ (2/4/2009): Added the data member to the SgProject and tha access function to the SgFile,
       // it was previously reversed.
       // bool get_binary_only (void) const;

#if 0
// DQ (9/5/2008): Moved to SgSourceFile
#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
#endif

HEADER_APPLICATION_FILE_END

HEADER_APPLICATION_SOURCE_FILE_START
     public:
       // SgSourceFile ( int & argc, char** & argv, int & errorCode, int fileNameIndex = 0, SgProject* project = NULL );
          SgSourceFile(std::vector<std::string>& argv, SgProject* project = NULL);
          virtual int callFrontEnd();
       // SgSourceFile ( const SgSourceFile & X );

      //! Default constructor (not meant to be used)
       // SgSourceFile() ROSE_DEPRECATED_FUNCTION;

          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
#ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT // Liao 6/25/2010, support enable-only-c and haskell
      //! Support for setting Java's classpath (to support the Open Fortran Parser (OFP))
          static std::string build_classpath();

      //! Divide up the handling of different languages
          int build_Fortran_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
#endif          
          int build_C_and_Cxx_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_PHP_AST();
          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

       // DQ (12/19/2008): Added support for translation source position information using CPP linemarkers.
          void processCppLinemarkers();

       // DQ (9/5/2008): Support for older name of the SgGlobal in SgSourceFile
       // SgGlobal* get_root() const;

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This should be the only place where the SgGlobal (global scope object) is built.
          void initializeGlobalScope();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

#if 0
       // DQ (9/12/2009): Adding support for new name qualification (not ready yet).
       // typedef std::vector<SgNode*> NumberToStatementType;
       // void buildStatementNumbering( NumberToStatementType & numberToStatementContainer );
          void buildStatementNumbering();
#endif

HEADER_APPLICATION_SOURCE_FILE_END

HEADER_APPLICATION_BINARY_FILE_START
     public:
       // SgBinaryComposite ( int & argc, char** & argv, int & errorCode, int fileNameIndex = 0, SgProject* project = NULL );
          SgBinaryComposite(std::vector<std::string>& argv,  SgProject* project = NULL);
       // SgBinaryComposite ( const SgBinaryFile & X );

          virtual int callFrontEnd();
      //  Default constructor (not meant to be used)
      //  JJW (9/5/2008): the normal constructor has defaults for all of its arguments, so this is ambiguous
      //  SgBinaryComposite() ROSE_DEPRECATED_FUNCTION;

          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

      //! However, now we have a list of them to support library archives which contain multiple object files (*.o's).
          const SgAsmGenericFile* get_binaryFile() const;
          SgAsmGenericFile* get_binaryFile();
          void set_binaryFile( SgAsmGenericFile* file );

       //! This is refactored code, called once for a binary executable, and called on each object file for a library archive.
          void buildAsmAST( std::string executableFileName );
HEADER_APPLICATION_BINARY_FILE_END

HEADER_APPLICATION_UNKNOWN_FILE_START
     public:
          SgUnknownFile(std::vector<std::string>& argv, SgProject* project = NULL);

          virtual int callFrontEnd();
          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

HEADER_APPLICATION_UNKNOWN_FILE_END



HEADER_APPLICATION_FILE_LIST_START
     public:

HEADER_APPLICATION_FILE_LIST_END

HEADER_APPLICATION_DIRECTORY_START
     public:
          int numberOfFiles() const;
          SgFile* get_file(int i) const;

          int numberOfDirectories() const;
          SgDirectory* get_directory(int i) const;

          void post_construction_initialization();

HEADER_APPLICATION_DIRECTORY_END

HEADER_APPLICATION_DIRECTORY_LIST_START
     public:

HEADER_APPLICATION_DIRECTORY_LIST_END

HEADER_APPLICATION_PROJECT_START


      /*! Template Instantiation Options */
          enum template_instantiation_enum
             {
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value */
               e_none     = 2, /*!< no template instantiation */
               e_used     = 3, /*!< instantiate only templates that are used */
               e_all      = 4, /*!< instantiate all possible templates */
               e_local    = 5, /*!< instantiate only used templates and instantiate them as local entities */
               e_last          /*!< last value (used for error checking) */
             };

      //! The only useful constructors
          SgProject ( const std::vector<std::string>& argv);
          SgProject ( int argc, char** argv);

#if 0
      // DQ (10/16/2005): Depreicated a long time ago, removed it now!
      //! Deprecated old constructor (test use of gnu attribute (requires gnu 3.1+))
       // SgProject ( int &argc, char** argv, int & errorCode);
          SgProject ( int &argc, char** argv, int & errorCode) ROSE_DEPRECATED_FUNCTION;
#endif

      //! process command line and store options in the SgProject object. This options are used by parse und unparse.
          void processCommandLine(const std::vector<std::string>& argv);
          void processCommandLine(int argc, char** argv) { processCommandLine(std::vector<std::string>(argv, argv + argc)); }

      //! parse input file(s)
          int parse();

      //! processes command line and parses all files.
      //! Error code can be accessed using get_frontendErrorCode()
          int parse (const std::vector<std::string>& argv);
          int parse (int argc, char** argv) { return parse(std::vector<std::string>(argv, argv + argc)); }

     public:

      //! default constructor (not meant to be used)
          SgProject();

      //! Copy constructor (shallow copy, does not do deep copy of the AST)
          SgProject( const SgProject & project );

      //! Destructor
      // ~SgProject();

      //! The total number of files in this project (equal to the number of source files specified on the command line)
          int numberOfFiles() const;

      //! Total number of directories in the project.
          int numberOfDirectories() const;

      //! Access function for retriving a SgFile object from the list stored internally
      //! This function is depricated and "operator[unsigned int]" should be used instead.
          SgFile& get_file ( int i ) const ROSE_DEPRECATED_FUNCTION;

      //! Access function for putting a new SgFile object into the list stored internally
      //! This function is depricated and "get_fileList->push_back(SgFile*)" should be used instead.
          void set_file ( SgFile & file ) ROSE_DEPRECATED_FUNCTION;

      //! Access function for retriving a SgFile object from the list stored internally
          SgFile* operator[]( unsigned int i );

      //! function to generate output for all files in the project (arguments control code generation)
       // void unparse();
          void unparse ( UnparseFormatHelp *unparseFormatHelp = NULL, UnparseDelegate* unparseDelegate = NULL );

       // DQ (5/8/2010): Added support for resetting the source position information.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to compile the output from unparsing the project
       // BP : 11/13/2001, modified to take compiler name
       // int compileOutput( char *compilerName = CXX_COMPILER_NAME );
          int compileOutput( const std::string& compilerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );

      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to preform linking!
       // int link ( std::string linkerName = CXX_COMPILER_NAME );
          int link ( std::string linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );

      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to preform linking!
       // int link ( int argc, char** argv, std::string linkerName = CXX_COMPILER_NAME );
          int link ( const std::vector<std::string>& argv, std::string linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );

       // function to generate PDF output file for AST
       // void outputPDF();

      //! global concept of verbose level which controls useful output from the compiler (values greater than zero increase output level)
          static int p_verbose;

      //! Save the command line arguments (argc and argv) for the project (these are needed to process transformations)
       // static int project_argc;
       // static char** project_argv;

       // DQ (9/2/2008): Removed this redundant function
       // DQ: Get list of file names in project (generated from the list of SgFile nodes)
       // I think this is redundant with the other lists of filenames!
       // Rose_STL_Container<std::string> getFileNames() const;

      //! This function generates a list of files resolved to absolute paths (symbolic links should not be resolved).
          Rose_STL_Container<std::string> getAbsolutePathFileNames() const;

      //! DQ: Modified to accept a value on the command line (no longer a boolean variable)
      //! value of 0 means quiet and higher values output more information, default value 
      //! is zero (quiet).
          static int get_verbose (void);
          static void set_verbose (int);

       // DQ: bool values on the SgFile nodes which can be queried on the SgProject
       // nodes (must be the same across all SgFile nodes in the project).
          bool get_skip_transformation (void) const;
          bool get_skip_unparse (void) const;
          bool get_useBackendOnly (void) const;

       // DQ (4/6/2010): Added to support parsing only option.
          bool get_exit_after_parser(void) const;

          bool get_C_only   (void) const;
          bool get_C99_only (void) const;
          bool get_Cxx_only (void) const;

       // DQ (8/11/2007): Added Fortran support
          bool get_Fortran_only (void) const;
          bool get_F77_only     (void) const;
          bool get_F90_only     (void) const;
          bool get_F95_only     (void) const;
          bool get_F2003_only   (void) const;
          bool get_CoArrayFortran_only (void) const;

          void set_C_only       (bool value);
          void set_Cxx_only     (bool value);
          void set_Fortran_only (bool value);

          bool get_PHP_only(void) const;

       // DQ (2/4/2009): This is now a data member at the SgProject and so is automatically generated asa member function.
       // bool get_binary_only (void) const;

          void display ( const std::string & label ) const;

          void initialization();

          friend std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<std::string> & l );

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

          void skipfinalCompileStep(bool value);

          SgStringList & get_includePathList();
          const SgStringList & get_includePathList() const;
          void set_includePathList(const SgStringList & includePathList);

          SgStringList & get_excludePathList();
          const SgStringList & get_excludePathList() const;
          void set_excludePathList(const SgStringList & excludePathList);

          SgStringList & get_includeFileList();
          const SgStringList & get_includeFileList() const;
          void set_includeFileList(const SgStringList & includeFileList);

          SgStringList & get_excludeFileList();
          const SgStringList & get_excludeFileList() const;
          void set_excludeFileList(const SgStringList & excludeFileList);

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
#else
       // DQ (1/21/2010): In this case we want to support the previous interface so that we can transition easily.
          SgFilePtrList & get_fileList() const;
          void set_fileList(SgFilePtrList & fileList);
#endif


HEADER_APPLICATION_PROJECT_END


HEADER_OPTIONS_START
  // In general we avoid the definition of member function within the class declaration!
  // This is a minor divergence upon this policy.

     friend class Sg_Options& Sg_options();
     public:
          inline std::ostream& default_output()      { return *p_default_output;}
          inline void set_default_output(std::ostream& os){ p_default_output = &os;}

          inline std::ostream& debug_output()        { return *p_debug_output;}
          inline void set_debug_output(std::ostream& os)  { p_debug_output = &os;}

          inline std::ostream& error_output()        { return *p_error_output;}
          inline void set_error_output(std::ostream& os)  { p_error_output = &os;}

          inline std::ostream& logging_output()      { return *p_logging_output;}
          inline void set_logging_output(std::ostream& os){ p_logging_output = &os;}

          inline int debug_level()         {return p_debug_level;}
          inline void set_debug_level(int l) { p_debug_level = l; }

          inline int logging_level() {return p_logging_level;}
          inline void set_logging(std::ostream& log_file, int level) 
             { p_logging_level = level; p_logging_output = &log_file; }
#if 0
  // We need a option to permit the generated constructors to be protected or private
     private:
          Sg_Options(); /* to stop anyone but Sg_options() instantiating it */
#endif

HEADER_OPTIONS_END


HEADER_UNPARSE_INFO_START
       // This class defines it's data explicitly so that the explicitly defined 
       // member access functions will be used and none will be generated!

       // Default constructor defined here because the automatically generated constructor
       // would not be generated with the error checking that I require to debug the use of
       // the SgUnparse_Info object as an inherited attribute in the unparser.
          SgUnparse_Info ();

          SgUnparse_Info ( const SgUnparse_Info & X );
          SgUnparse_Info & operator= ( const SgUnparse_Info & X );

          void post_construction_initialization();

       // DQ (4/16/2003): Notes on how to improve the unparser:
       // Rather than having an inherited attribute that stores some context information 
       // and clearer approach would be to have an inherited attribute that stored all 
       // the context information.  The SgUnparse_Info object should be abandoned for 
       // the use of a persistant attribute built using an initial traversal (to set them)
       // over the entire tree.  Such a traversal would have to visit every node of 
       // the AST, because the unparser has to visit every node.

       // DQ (12/6/2003) Need to use a vector<bool> type to store flags so that we can include
       // more flags that permited in a 32bit long integer.  We used long long for a while, but 
       // this does not work with the 3.x gnu g++ compiler (and C++ does not allow enum values to
       // be more than long (32 bits on many machines, Intel x86).  Modifying the implementation
       // to use an STL vector<bool> type permits an unlimited number of flags (for future growth).

      /*! \brief Options available for unparsing the AST to generate source code

          These options can be set or unset and are passed from each unparse function to any 
          called unparse functions.  Sometimes a new unparse info object is generated, always 
          using the copy constructor, so that the options can be modified for unparsing 
          different parts of the AST.

          \internal This is implemented as a bit vector since it is over 32 bits.
       */
          enum unparse_type_num
             {
            //! DQ (11/4/2003): Build a default value to support initialization
               b_enum_defaultValue            = 0, /*!< default value */
            //! to postponing the printing of name for ptr of function or array etc
               b_isPointerToSomething         = 1, /*!< postponing the printing of name for ptr of function or array etc */
               b_isReferenceToSomething       = 2, /*!< postponing the printing of name for ptr of function or array etc */
            //! if it is in Variable Declaration, output either , or ; for SgExprStmt
               b_inVarDecl                    = 3, /*!< if it is in Variable Declaration, output either , or ; for SgExprStmt */
            //! in a function header, output type+ symbol 
               b_inArgList                    = 4, /*!< in a function header, output type+ symbol */
            //! no ';' for declaration statement
               b_SkipSemiColon                = 5, /*!< no ';' for declaration statement */
            //! to setup for printing of enum var in a VariableDeclaration
               b_inEnumDecl                   = 6, /*!< setup for printing of enum var in a VariableDeclaration */
            //! not really being used (yet)
               b_inTemplateList               = 7, /*!< not really being used (yet) */
            //! suppress printing of the base type
               b_SkipBaseType                 = 8, /*!< suppress printing of the base type */
            //! for skip "=" if in aggregate initializer
               b_inAggregateInitializer       = 9, /*!< skip "=" if in aggregate initializer */
            //! for print both type & sym name
               b_isWithType                   = 10, /*!< print both type and sym name */
            //! it is in conditional expr
               b_inConditional                = 11, /*!< is in conditional expr (context information) */
            //! skip printing definition part of a declaration
               b_SkipDefinition               = 12, /*!< skip output of definitions (sets b_SkipEnumDefinition, b_SkipFunctionDefinition, and b_SkipClassDefinition */
            //! need to put in either class/struct/union keyword 
               b_SkipClassSpecifier           = 13, /*!< skip the class specifier (modifier) */
            //! printing something within a variable declaration
               b_inEmbeddedDecl               = 14, /*!< printing something within a variable declaration */
            //! suppress the printing of global and atomic
               b_SkipGlobal                   = 15, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
               b_SkipAtomic                   = 16, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
            //! used by set/unsetName and set/unsetPrintName to bring down the
            //! Name to lower tree structure
               b_PrintName                    = 17, /*!< used by set/unsetName and set/unsetPrintName to bring down the Name to lower tree structure */
            //! to set the need to check if need access specifier (avoids redundently specific access modifiers)
               b_CheckAccess                  = 18, /*!< set the need to check if need access specifier */
            //! to skip function qualifiers
               b_SkipFunctionQualifier        = 19, /*!< skip function qualifiers */
            //! to show that the type above current one is an array
               b_isArrayType                  = 20, /*!< show that the type above current one is an array */
            //! to indicate that this is at the right hand side of a binary op
               b_inRhsExpr                    = 21, /*!< indicate that this is at the right hand side of a binary op */
            //! to flag the skipping of () printing in a function call
            //! this is for a bug in g++ that can not handle (P::dval->B::mfcall)()
            //! skipping the toplevel only
               b_SkipParen                    = 22, /*!< skip over output of matching "(" and ")" */
            //! for the case that this maybe a function type, separate the outputing of
            //! the type info into 2 parts, the return type part and the arg type
            //! by default this is always set to 0
               b_isTypeSecondPart             = 23, /*!< unparse only second part of type */
               b_isTypeFirstPart              = 24, /*!< unparse only first part of type */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipInitializer              = 25, /*!< skip output of initializers */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipComments                 = 26, /*!< ignore all comments in unparsing */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipCPPDirectives            = 27, /*!< ignore all C preprocessor directives (except #pragma which is in the AST) */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipEnumDefinition           = 28, /*!< skip over enum definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipFunctionDefinition       = 29, /*!< skip over the function definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipClassDefinition          = 30, /*!< skip over the class definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_AddSemiColonAfterDeclaration = 31, /*!< add ';' after declaration */
            //! MS: 09/03/02 Added by MS to make unparsing of white space optional
            //! currently only used in unparseToCompleteString (by removing whitespaces)
            //! I only added it here to follow the design but suggest to use varibles of type bool,
            //! and extend the ROSETTA code to add these attributes, and generate the access functions -
            //! unfortunately the naming scheme does not comply with ROSETTA's naming scheme for access functions.
               b_SkipWhitespaces              = 32, /*!< ignore any unrequired white space */
            //! DQ (11/3/2003): made all bit flags 64 bit long so that we could add a few
            //! more entries.  Added bit flag to control generation of prefix scope
            //! statements. This permits unparsing SgForStmt, SgWhileStmt, SgSwitchStmt,
            //! etc., without their body so that we can capture the full context of the 
            //! declarations associated with such statements.  In the case of SgSwitchStmt
            //! it also permits replacement of case statements which are specific to
            //! SgSwitchStmt basic blocks and no other basic blocks.  This verifies the 
            //! correctness of transformation specified.
               b_SkipBasicBlock               = 33, /*!< skip over the unparsing of the basic block */

           //! Templates that are modified need to be output, but all other output of a class 
           //! template only supports the output of the class template name (but in template 
           //! form, e.g. "Rose_STL_Container<int>").  If the template has not been transformed then we have 
           //! to control where it is output.  The default can't be to output the template 
           //! everywhere and then restrict it's use since the unparser can't turn that on, 
           //! so we have to restrict it everywhere and turn it on in several places.
               b_outputClassTemplateName      = 34, /*!< outputClassTemplateName */

            // DQ (5/27/2005): Added support for getting comments and directives output before any inserted 
            // compiler generated statements.
           //! Control output of compiler-generated statements (typically template specialization declarations).
           //! this allows the unparing of comments and preprocessor declarations before the compiler-generated
           //! statements appearing with any non-compiler-generated statement.
               b_outputCompilerGeneratedStatements = 35, /*!< outputCompilerGeneratedStatements */

            // DQ (4/5/2006): Added support for constant folded values to be optionally output
           //! Control output of constant folded values.
               b_SkipConstantFoldedExpressions = 36, /*!< SkipConstantFoldedExpressions */

            // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
               b_forceQualifiedNames           = 37, /*!< Force qualified names. */

            // DQ (10/11/2006): This is added to support a default where all qualified names are output.
           //! Control output of qualified names (not always wanted).
               b_SkipQualifiedNames           = 38, /*!< skip qualified names (e.g. names of defining declarations). */

           //! Control access specifiers use in generated code (public, protected, private).
               b_skipCheckAccess               = 39, /*!< Skip access specifier (different from b_CheckAccess, above) */

               b_requiresGlobalNameQualification = 40,/*!< Requires global qualifier on generated name. */

            // DQ (8/10/2006):
            // b_isAsmOutputOperand            = 40, /*!< Mark as output operand */

               b_useTypeAttributes             = 41,/*!< Fortran allows type attributes to be used in declarations (for example to dimension a collection of arrays). */

               b_SkipFormatting                = 42,/*!< Fortran code generation requires that we skip some formatting (e.g. column 7 formatting, even if fixed format output). */

            // FMZ: Added for generate fortran xxx.rose_mod file
               b_outputFortranModFile      = 43, /*!< Fortran mod file generation */

            //! DQ (12/6/2003): Added last value to use a upper bound in loops
               UNPARSE_TYPE_LAST /*!< last value used for debugging */
             };

      /*! Access modifiers for use with SgUnparseInfo (only) */
          enum access_attr_enum
             {
               a_unset_access     = 1, /*!< default value */
               a_private_access   = 2, /*!< private access value */
               a_protected_access = 3, /*!< protected access value */
               a_public_access    = 4  /*!< public access value */
             };

     private:

       // DQ (1/3/2009): This is similar code to what is in SgModifier::checkBit, setBit, unsetBit; so it could be refactored.
          bool checkBit(unparse_type_num bit) const;
          void setBit(unparse_type_num bit);
          void unsetBit(unparse_type_num bit);

     public:

       // access function to SgUnparse_Info 
          bool isUnsetAccess() const;
          void set_isUnsetAccess();
          bool isPrivateAccess() const;
          void set_isPrivateAccess();
          bool isProtectedAccess() const;
          void set_isProtectedAccess();
          bool isPublicAccess() const;
          void set_isPublicAccess();

          bool isPointerToSomething() const;
          void set_isPointerToSomething();
          void unset_isPointerToSomething();

          bool isReferenceToSomething() const;
          void set_isReferenceToSomething();
          void unset_isReferenceToSomething();
	 
          bool inVarDecl() const;
          void set_inVarDecl();
          void unset_inVarDecl();
	 
          bool inArgList() const;
          void set_inArgList();
          void unset_inArgList();
	 
          bool SkipSemiColon() const;
          void set_SkipSemiColon();
          void unset_SkipSemiColon();

          bool inEnumDecl() const;
          void set_inEnumDecl();
          void unset_inEnumDecl();

          bool inTemplateList() const;
          void set_inTemplateList();
          void unset_inTemplateList();

          bool SkipBaseType() const;
          void set_SkipBaseType();
          void unset_SkipBaseType();

          bool inAggregateInitializer() const;
          void set_inAggregateInitializer();
          void unset_inAggregateInitializer();

          bool isWithType() const;
          void set_isWithType();
          void unset_isWithType();

          bool inConditional() const;
          void set_inConditional();
          void unset_inConditional();

          bool SkipDefinition() const;
          void set_SkipDefinition();
          void unset_SkipDefinition();

          bool SkipClassSpecifier() const;
          void set_SkipClassSpecifier();
          void unset_SkipClassSpecifier();

          bool inEmbeddedDecl() const;
          void set_inEmbeddedDecl();
          void unset_inEmbeddedDecl();

          bool SkipGlobal() const;
          void set_SkipGlobal();
          void unset_SkipGlobal();

          bool SkipAtomic() const;
          void set_SkipAtomic();
          void unset_SkipAtomic();

          bool PrintName() const;
          void set_PrintName();
          void unset_PrintName();

          bool CheckAccess() const;
          void set_CheckAccess();
          void unset_CheckAccess();

          bool SkipFunctionQualifier() const;
          void set_SkipFunctionQualifier();
          void unset_SkipFunctionQualifier();

          bool isArrayType() const;
          void set_isArrayType();
          void unset_isArrayType();

          bool inRhsExpr() const;
          void set_inRhsExpr();
          void unset_inRhsExpr();

          bool SkipParen() const;
          void set_SkipParen();
          void unset_SkipParen();

          bool isTypeSecondPart() const;
          void set_isTypeSecondPart();
          void unset_isTypeSecondPart();

          bool isTypeFirstPart() const;
          void set_isTypeFirstPart();
          void unset_isTypeFirstPart();

          bool SkipInitializer() const;
          void set_SkipInitializer();
          void unset_SkipInitializer();

          bool SkipComments() const;
          void set_SkipComments();
          void unset_SkipComments();

       // MS: 09/03/03
          bool SkipWhitespaces() const;
          void set_SkipWhitespaces();
          void unset_SkipWhitespaces();

          bool SkipCPPDirectives() const;
          void set_SkipCPPDirectives();
          void unset_SkipCPPDirectives();

          bool SkipEnumDefinition() const;
          void set_SkipEnumDefinition();
          void unset_SkipEnumDefinition();

          bool SkipFunctionDefinition() const;
          void set_SkipFunctionDefinition();
          void unset_SkipFunctionDefinition();

          bool SkipClassDefinition() const;
          void set_SkipClassDefinition();
          void unset_SkipClassDefinition();

          bool AddSemiColonAfterDeclaration() const;
          void set_AddSemiColonAfterDeclaration();
          void unset_AddSemiColonAfterDeclaration();

       // DQ (11/04/03): Added to support unparsing control flow (SgForStmt, SgSwitch,
       //                etc.) to make prefix more precise. Can't add case to anything 
       //                but switch, and capture declarations in for loops, for example.
          bool SkipBasicBlock() const;
          void set_SkipBasicBlock();
          void unset_SkipBasicBlock();

       // DQ (3/18/2004): Added to support unparsing of class templates in variables but 
       // not in in instatiated template declarations (unless the template is transformed 
       // in which case another test is used).
          bool outputClassTemplateName() const;
          void set_outputClassTemplateName();
          void unset_outputClassTemplateName();

       // DQ (5/27/2005): support (see documentation above)
          bool outputCompilerGeneratedStatements() const;
          void set_outputCompilerGeneratedStatements();
          void unset_outputCompilerGeneratedStatements();

       // DQ (4/5/2006): Added support for constant folded values to be optionally output
      //! Control output of constant folded values, the default is to ignore constant 
      //! folded values and unparse the original code (as if no constant folding were done).
      //! (default is unset)
          bool SkipConstantFoldedExpressions() const;
          void set_SkipConstantFoldedExpressions();
          void unset_SkipConstantFoldedExpressions();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool forceQualifiedNames() const;
          void set_forceQualifiedNames();
          void unset_forceQualifiedNames();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool skipCheckAccess() const;
          void set_skipCheckAccess();
          void unset_skipCheckAccess();

       // DQ (10/11/2006): Added to support new implementation of name qualification
          bool SkipQualifiedNames() const;
          void set_SkipQualifiedNames();
          void unset_SkipQualifiedNames();

          bool requiresGlobalNameQualification() const;
          void set_requiresGlobalNameQualification();
          void unset_requiresGlobalNameQualification();

       // DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
          bool useTypeAttributes() const;
          void set_useTypeAttributes();
          void unset_useTypeAttributes();

          bool SkipFormatting() const;
          void set_SkipFormatting();
          void unset_SkipFormatting();

          std::string get_operator_name();
          void set_operator_name(const std::string& on);

          SgName& get_name();
          void set_name(const SgName& name);
          void unset_name();

          SgDeclarationStatement* get_decl_stmt();
          void set_decl_stmt(SgDeclarationStatement* stmt );
          void unset_decl_stmt();

          int get_nested_expression();
          void set_nested_expression();
          void unset_nested_expression();

#if 0
   // MK: These access functions are now automatically generated!
          SgNamedType *get_current_context();
          void set_current_context(SgNamedType *t);
#endif
          void unset_current_context();

          SgName get_array_index_list();

          void set_array_index_list(SgExpression *e, SgUnparse_Info finfo );
          void unset_array_index_list();

       // Support for processing of recursive references to structure tags within the data
       // structures that they define.
          void addStructureTag ( SgNamedType* structureTag );

      //! Access function for internal STL list of structure tags
          SgTypePtrList & getStructureTagList ();

       // DQ (1/9/2007): Modified to make const
          void display ( const std::string & label = "") const;
          std::string displayString ( const std::string & label ) const;

      /*! \brief Added to debug use of the default constructor 

          Added to debug use of the default constructor (to restrict it from being used so that
          we could detect where it is being used in place of the copy constructor which should
          be used to implement the SgUnparse_Info object correctly as an inherited attribute
          within the ROSE unparser.
       */
       // static bool forceDefaultConstructorToTriggerError;

       // DQ (9/6/2004): Support for list of scopes required to qualify names (e.g. types, data members, member functions, etc.)
       // SgSymbolPtrList & get_listOfScopeSymbols();
       // void set_listOfScopeSymbols ( const SgSymbolPtrList & l );

       // DQ (1/31/2006): moved static bool forceDefaultConstructorToTriggerError to be built by ROSETTA
          static bool get_forceDefaultConstructorToTriggerError();
          static void set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError);

       // FMZ (5/8/2008) Added to support to generate fortran XX.rose_mod file for a module
       // the code will based on fortran unparser code
          bool outputFortranModFile() const;
          void set_outputFortranModFile();
          void unset_outputFortranModFile();

HEADER_UNPARSE_INFO_END


HEADER_UNPARSE_POSTDECLARATION_START
//! extern declarations used by the unparser (a default object for many to reference)
// extern SgUnparse_Info SgNO_UNPARSE_INFO;

// support function declarations for unparsing
//extern void printSgVariant ( std::ostream& os, int x );
extern std::string getSgVariant ( int x);

HEADER_UNPARSE_POSTDECLARATION_END

HEADER_TEMPLATE_PARAMETER_START
     public:

      /*! Different uses of a template parameter */
          enum template_parameter_enum
             {
               parameter_undefined = 0, /*!< undefined (error) */
               type_parameter      = 1, /*!< type parameter */
               nontype_parameter   = 2, /*!< nontype parameter */
               template_parameter  = 3  /*!< template parameter */
             };

          void post_construction_initialization();

       // Different constructors for use in building the different types of parameters possible
          SgTemplateParameter ( SgType* parameter               , SgType* defaultParameter );
          SgTemplateParameter ( SgExpression* parameter         , SgExpression* defaultParameter );
          SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter );

HEADER_TEMPLATE_PARAMETER_END

HEADER_TEMPLATE_ARGUMENT_START
     public:

      /*! Different uses of a template argument */
          enum template_argument_enum
             {
               argument_undefined          = 0, /*!< undefined (error) */
               type_argument               = 1, /*!< type parameter */
               nontype_argument            = 2, /*!< nontype parameter */
               template_template_argument  = 3  /*!< template template parameter */
             };

          void post_construction_initialization();

       // Different constructors for use in building the different types of parameters possible
          SgTemplateArgument ( SgType*                      parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgExpression*                parameter, bool explicitlySpecified );
       // SgTemplateArgument ( SgTemplateInstantiationDecl* parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgTemplateDeclaration*       parameter, bool explicitlySpecified );

       // RV (2/2/2006): Added mangling for template arguments.
      //! Returns the template argument in mangled form.
          SgName get_mangled_name (void) const;

      //! Some template arguments have an associated scope (e.g. named types, and template template arguments)
          SgScopeStatement* get_scope () const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
#else
       // DQ (11/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_ARGUMENT_END


HEADER_TEMPLATE_PARAMETER_LIST_START
HEADER_TEMPLATE_PARAMETER_LIST_END

HEADER_TEMPLATE_ARGUMENT_LIST_START
HEADER_TEMPLATE_ARGUMENT_LIST_END

HEADER_OPENCL_ACCESS_MODE_MODIFIER_START

  // TV (05/03/2010): OpenCL Access Mode Support

	enum access_mode_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_read_only     = 2,  /*!< read only access mode modifier */
               e_write_only    = 3,  /*!< write only access mode modifier */
               e_read_write    = 4,  /*!< read-write access mode modifier */
               
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization();

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isReadOnly() const;
          void setReadOnly();

          bool isWriteOnly() const;
          void setWriteOnly();

          bool isReadWrite() const;
          void setReadWrite();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, SgStorageModifier & m );
          
HEADER_OPENCL_ACCESS_MODE_MODIFIER_END



// *************************************************
// *************************************************
//                  Source Code
// *************************************************
// *************************************************


SOURCE_START
  // No functions defined for the GrammarSource
SOURCE_END


SOURCE_SYMBOL_TABLE_START

// DQ (2/19/2007): Added mechanism to turn off expensive error checking!
#define SYMBOL_TABLE_ERROR_CHECKING 1

// DQ (7/24/2005): Make this a constant in the function if it is not used elsewhere!
// #define SYMTBL_INIT_SZ 16

SgSymbolTable::SgSymbolTable()
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!
     int symbolTableSize = 17;
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
#if 0
	 printf ("WARNING: Symbol table built using default constructor in SgSymbolTable(). \n");
     p_table = new BaseHashType();
#else
     p_table = new BaseHashType(symbolTableSize);
#endif
     assert (p_table != NULL);
   }

// DQ (2/19/2007): I have put it back into use as a way of 
// customizing the size of the underlying hash tables to be
// larger for certain scopes (e.g global scope usually has a 
// lot more symbols.

// DQ (1/31/2007): This function is not used!
SgSymbolTable::SgSymbolTable(int symbolTableSize)
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!

  // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
  // p_table = new SgSymbolHashMultiMap(sz);

// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
#if 0
	 printf ("WARNING: Symbol table built using default constructor in SgSymbolTable(int symbolTableSize). \n");
     p_table = new BaseHashType();
#else
     p_table = new BaseHashType(symbolTableSize);
#endif
     assert (p_table != NULL);
   }

std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it )
   {
  // DQ (1/19/2006): Error reported by Michelle Strout when compiled with g++ 4.0.2 on 64 bit machines
  // os << " pair (" << (*rhm_it).first.str() << "," << (int)((*rhm_it).second) << ")";
  // os << " pair (" << (*rhm_it).first.str() << "," << ((*rhm_it).second) << ")";
  // JJW (7/10/2008): The iterator may not be valid, so don't try to print what it points to
     os << "<iterator>";
     return os;
   }

SgName
SgSymbolTable::get_name( const SgNode* node) const
   {
  // DQ (2/20/2007): This function is used to get the name for the different types of declarations used to build symbols.

     SgName name;

     switch (node->variantT())
        {
       // We could implement a function on the selective nodes that generated the symbol 
       // name (the name used for the input of associated symbols in the symbol table).
          case V_SgLabelStatement:
             {
               const SgLabelStatement* labelStatement = isSgLabelStatement(node); 
               if (labelStatement->get_label() != NULL)
                  {
                    name = labelStatement->get_label();
                  }
                 else
                  {
                 // name = StringUtility::numberToString(labelStatement->get_numeric_label()->get_name());
                    assert(labelStatement->get_numeric_label() != NULL);
                    name = labelStatement->get_numeric_label()->get_name();
                  }
               break;
             }

          case V_SgClassDeclaration:
          case V_SgDerivedTypeStatement:
          case V_SgModuleStatement:
             {
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);
               name = classDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               const SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(node);
            // Note that get_name() returns a name with arguments such as "class_template<int>" while get_templateName() returns the template name withouth arguments.
            // name = templateInstantiationDeclaration->get_templateName();
            // printf ("In SgSymbolTable::find(const SgStatement*): case V_SgTemplateInstantiationDecl, using get_name() = %s instead of get_templateName() = %s \n",
            //      templateInstantiationDeclaration->get_name().str(),templateInstantiationDeclaration->get_templateName().str());
            // printf ("Base class get_name() = %s \n",templateInstantiationDeclaration->SgClassDeclaration::get_name().str());
               name = templateInstantiationDeclaration->get_name();
               break;
             }

          case V_SgEnumDeclaration:
             {
               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(node); 
               name = enumDeclaration->get_name();
               break;
             }

          case V_SgFunctionDeclaration:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgMemberFunctionDeclaration:
             {
               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               
               name = functionDeclaration->get_name();
               break;
             }

       // DQ (2/14/2007): Note that for template-based declarations there is a process where within the post-processing of 
       // the AST the names are updated from the EDG form (e.g. "template_name___Lnnn"), to the template specialization 
       // form (e.g. "template_name<int>"). Since the symbol references only one of the declarations, if there are defining 
       // declarations and non-defining declarations, the name can be changed in the declaration but not in the associated symbol.
       // Details of this situation require more clarification.
          case V_SgTemplateInstantiationFunctionDecl:
             {
               const SgTemplateInstantiationFunctionDecl* functionDeclaration = isSgTemplateInstantiationFunctionDecl(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               const SgTemplateInstantiationMemberFunctionDecl* functionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(node);
            // printf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // printf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // printf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(), 
            // get_templateName returns the name of the template which is required for code generation (where for 
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgNamespaceDeclarationStatement:
             {
               const SgNamespaceDeclarationStatement* namespaceDeclarationStatement = isSgNamespaceDeclarationStatement(node); 
               name = namespaceDeclarationStatement->get_name();
               break;
             }

       // DQ (8/30/2009): Added namespace alias support.
          case V_SgNamespaceAliasDeclarationStatement:
             {
               const SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = isSgNamespaceAliasDeclarationStatement(node); 
               name = namespaceAliasDeclarationStatement->get_name();
               break;
             }

          case V_SgTemplateDeclaration:
             {
               const SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
               const SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);
               name = typedefDeclaration->get_name();
               break;
             }

          case V_SgFunctionType:
             {
               const SgFunctionType* functionType = isSgFunctionType(node);
               name = functionType->get_mangled();
               break;
             }

          case V_SgInitializedName:
             {
               const SgInitializedName* initializedName = isSgInitializedName(node);
               name = initializedName->get_name();
               break;
             }

          default:
             {
               printf ("SgSymbolTable::get_name(SgNode*) undefined for %s \n",node->class_name().c_str());
               assert(false);
             }
        }

     return name;
   }


/* ************************************************************************
                               INSERT FUNCTIONS
   ************************************************************************/

void
SgSymbolTable::insert ( const SgName & nm , SgSymbol *sp )
   {
  // DQ (2/14/2007): Added assertion!
     assert(this != NULL);

  // DQ (2/19/2007): Added additional assertion!
     assert (p_table != NULL);

  // DQ (2/14/2007): Added assertion!
     assert (sp != NULL);

#if 0
  // This outputs a message for every use of the insert function (for non function type symbols) useful for tracing through bugs
     SgNode* symbolBasis = sp->get_symbol_basis();
     printf ("In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s \n",
          nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
          sp,sp->class_name().c_str(),symbolBasis,symbolBasis != NULL ? symbolBasis->class_name().c_str() : "NULL");
#endif

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // SgFunctionTypeSymbol does not have a valid get_symbol_basis(), so skip this case!
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
          if (sp->get_symbol_basis() == NULL)
             {
               printf ("Error (sp->get_symbol_basis() == NULL): name = %s sp = %p = %s \n",nm.str(),sp,sp->class_name().c_str());
             }
          assert(sp->get_symbol_basis() != NULL);
#if 0
       // This outputs a message for every use of the insert function (for non function type symbols) useful for tracing through bugs
          printf ("In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s \n",
             nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
             sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
#endif
        }
#endif

  // DQ (3/10/2007): This is a simpler assertion equivalent to the one above but without generating any error output 
     ROSE_ASSERT(isSgFunctionTypeSymbol(sp) != NULL || sp->get_symbol_basis() != NULL);

  // DQ (3/10/2007): Test for if the symbol exists
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
           SgType* t = sp->get_type();
           ROSE_ASSERT(t != NULL);
           printf ("ERROR: p_symbolSet.find(sp) != p_symbolSet.end(): base type = %p = %s \n",t,t->class_name().c_str());
        }
     ROSE_ASSERT(p_symbolSet.find(sp) == p_symbolSet.end());

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/19/2007): These is no need to do both of these since exists(sp) is more complete test!
  // DQ (2/25/2007): except that it is helpful to know which one fails.
     assert(exists(nm,sp) == false);
     assert(exists(sp)    == false);

  // DQ (2/14/2007): error checking (make sure that no two symbols are represented by the same basis declaration). 
  // But skip such tests on the SgFunctionTypeSymbol (only used for the function type table)
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
       // set<SgNode*> existingSymbolBasisDeclarations;
          map<SgNode*, rose_hash_multimap::iterator > existingSymbolBasisDeclarations;

          SgNode* sp_associatedDeclaration = sp->get_symbol_basis();
          assert(sp_associatedDeclaration != NULL);

          rose_hash_multimap::iterator i = get_table()->begin();
          while (i != get_table()->end())
             {
            // test if symbol is in set
               SgNode* associatedDeclaration = i->second->get_symbol_basis();
               assert(associatedDeclaration != NULL);

            // Check if this declaration has previously been used with another symbol!
               if (existingSymbolBasisDeclarations.find( sp_associatedDeclaration ) == existingSymbolBasisDeclarations.end())
                  {
                 // Add this declaration to the list associated with symbols in the table
                 // existingSymbolBasisDeclarations.insert( associatedDeclaration );
                    existingSymbolBasisDeclarations[associatedDeclaration] = i;
                  }
                 else
                  {
                    printf ("Error in symbol table located in parent = %p = %s \n",get_parent(),get_parent()->class_name().c_str());
                    assert(get_parent() != NULL);
                    get_parent()->get_file_info()->display("Error in symbol table");

                    string associatedDeclarationName = SageInterface::get_name(sp_associatedDeclaration);

                 // DQ (2/15/2007): Output the name of the symbol being inserted, the declaration associated with it, 
                 // and the name of the symbol previously inserted with the same associated declaration.
                    printf ("Symbol sp = %p = %s already associated with declaration = %p = %s (name = %s) in symbol table i = %p = %s \n",
                         sp,sp->class_name().c_str(),sp_associatedDeclaration,sp_associatedDeclaration->class_name().c_str(),
                         associatedDeclarationName.c_str(),existingSymbolBasisDeclarations[sp_associatedDeclaration]->second,existingSymbolBasisDeclarations[sp_associatedDeclaration]->second->class_name().c_str());
                    associatedDeclaration->get_file_info()->display("Dual use of associatedDeclaration in source: debug");

                    printf ("existingSymbolBasisDeclarations[sp_associatedDeclaration]->first = %s second = %p \n",
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->first.str(),
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->second);
                    assert(false);
                  }

               i++;
             }
        }
#endif

  // Now, finally insert it into the symbol table
  // std::pair<const SgName,SgSymbol*>  npair(nm,sp);
  // p_table->insert(npair);
     p_table->insert(std::pair<const SgName,SgSymbol*>(nm,sp));

  // DQ (5/11/2006): set the parent to avoid NULL pointers
     sp->set_parent(this);

  // DQ (3/10/2007): Insert this symbol into p_symbolSet which we use for fast tests of existance in the 
  // symbol table when we don't use the name.  This helps detect where symbols have been entered using one 
  // name and either reentered using an second name or the name changed and the symbol had not been properly 
  // unloaded and reloaded into the symbol table.  Since the names are not stored in the symbol, but computed 
  // from associated declaration this is an easy error to make and we detect this by backing up the test for 
  // if a symbol exists using a name with a test for if the symbol exists using ANY possible name (a search 
  // for the symbol independent of the name).  To avoid this being a linear search of the symbol table (too 
  // slow) we implement a set of symbols to permit fast tests for existence.
     p_symbolSet.insert(sp);

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // Error checking
     assert(exists(nm)    == true);
     assert(exists(nm,sp) == true);
     assert(exists(sp)    == true);
#endif

#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/14/2007): Added error checking!
     if (nm != sp->get_name())
        {
          printf ("Warning: symbol name does not match name used to input associated symbol into symbol table! sp = %p = %s nm = \"%s\" sp->get_name() = \"%s\" \n",sp,sp->class_name().c_str(),nm.str(),sp->get_name().str());

          assert(sp->get_symbol_basis() != NULL);
          assert(sp->get_symbol_basis()->get_file_info() != NULL);

          sp->get_symbol_basis()->get_file_info()->display("Error in source: debug");
          assert(false);
        }
#endif


#if 0
  // We can't test this because where symbols are inserted (EDG/SageIII translation) the scopes are not set yet (done in AST post-processing).
  // DQ (2/14/2007): Added error checking!
     SgStatement* statement = isSgStatement(sp->get_symbol_basis());
     if (statement != NULL)
        {
       // printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
       // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
          SgSymbol* symbolFromTable = statement->get_symbol_from_symbol_table();
          assert(symbolFromTable != NULL);
          assert(symbolFromTable == sp);
        }
       else
        {
          SgInitializedName* initializedName = isSgInitializedName(sp->get_symbol_basis());
          if (initializedName != NULL)
             {
            // printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
            // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
               SgSymbol* symbolFromTable = initializedName->get_symbol_from_symbol_table();
               assert(symbolFromTable != NULL);
               assert(symbolFromTable == sp);
             }
            else
             {
               printf ("Unknown symbol_base for input symbol sp = %p = %s sp->get_symbol_basis() = %p = %s \n",sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
               assert(false);
             }
        }
#endif
   }


/* ************************************************************************
                               REMOVE FUNCTIONS
   ************************************************************************/

// DQ (2/6/2007): This is too dangerous for use in ROSE (deletes all 
// possible SgSymbols that match the input name independent of type).
// It is however currently used in the global function type symbol table
// so we have named this function to make its purpose more clear.
// This function is not likely called except where complex function type 
// symbol table editing is required.  Since SgFunctionTypeSymbols are
// shared removing such symbols is a rather dangerous actvity!
void
SgSymbolTable::remove_function_type( const SgName & name )
   {

  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     assert (p_table != NULL);

// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
//  // DQ (11/29/2009): MSVC requires a different use of nonstandard.
//     list<rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator> deleteList;
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator it = get_table()->find(name);
//#else
     list<rose_hash_multimap::iterator> deleteList;
     rose_hash_multimap::iterator it = get_table()->find(name);
//#endif
     while (it != get_table()->end() && (*it).first == name)
        {
          assert(it->second->variantT() == V_SgFunctionTypeSymbol);

          deleteList.push_back(it);
          it++;
        }
#if 1
     printf ("In SgSymbolTable::remove_function_type( const SgName & name ): name = %s deleteList.size() = %zu \n",name.str(),deleteList.size());
#endif

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
//  // DQ (11/29/2009): MSVC requires a different use of nonstandard.
//     list<rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator>::iterator i = deleteList.begin();
//#else
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
//#endif
     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase((*i)->second);"
       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // printf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
       // get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase((*i)->second);

       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // printf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
          get_table()->erase(*i);

          i++;
        }

   }


SgSymbol*
SgSymbolTable::find( const SgInitializedName* initializedName)
   {
     assert(p_table != NULL);
     assert(initializedName != NULL);

  // printf ("Inside of SgSymbolTable::find( const SgInitializedName* ): initializedName = %p = %s \n",initializedName,SageInterface::get_name(initializedName).c_str());

     SgSymbol* returnSymbol = NULL;

     SgName name = initializedName->get_name();

  // printf ("Inside of SgSymbolTable::find( const SgInitializedName* ): name = %s \n",name.str());

  // Find the first symbol in the multimap
     p_iterator = p_table->find(name);

  // Iterate through the matching symbols in the multimap
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          assert(p_iterator->second != NULL);
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
       // printf ("In loop: p_iterator->second = %p symbolBasis = %p initializedName = %p \n",p_iterator->second,symbolBasis,initializedName);
       // printf ("In loop: symbolBasis->variantT() = %d statement->variantT() = %d \n",symbolBasis->variantT(),initializedName->variantT());
          assert(symbolBasis != NULL);
          if (isSgInitializedName(symbolBasis) != NULL)
             {
            // printf ("found a SgInitializedName \n");

               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == initializedName)
                  {
                 // printf ("returnSymbol->get_symbol_basis() == initializedName returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
                    return returnSymbol;
                  }
                 else
                  {
                 // printf ("returnSymbol->get_symbol_basis() != initializedName \n");
                  }
             }
            else
             {
            // printf ("Some other symbol was found (no matching variants) \n");
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgFunctionType* functionType)
   {
     assert(p_table != NULL);
     assert(functionType != NULL);

  // printf ("Inside of SgSymbolTable::find( const SgFunctionType* ): functionType = %p = %s \n",functionType,SageInterface::get_name(functionType).c_str());

     SgSymbol* returnSymbol = NULL;

     SgName name = functionType->get_mangled();

     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgSymbol((*p_iterator).second)->variantT() == functionType->variantT())
             {
               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == functionType)
                    return returnSymbol;
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgStatement* statement)
   {
     assert(p_table != NULL);
     assert(statement != NULL);

#if 0
     printf ("Inside of SgSymbolTable::find( const SgStatement* ): statement = %p = %s = %s \n",statement,statement->class_name().c_str(),SageInterface::get_name(statement).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = get_name(statement);

#if 0
     printf ("Inside of SgSymbolTable::find( const SgStatement* ): name = %s \n",name.str());
#endif

  // Get a quick pointer into the symbol table using the name (log n complexity)
     p_iterator = p_table->find(name);

  // Once we have p_iterator set via the name we don't typically have more than one iteration
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          assert(p_iterator->second != NULL);
#if 0
          printf ("In loop: p_iterator->second = %p statement = %p \n",p_iterator->second,statement);
          printf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
#endif

       // This is a virtual function call (not defined for function type symbols)
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
#if 0
          printf ("In loop: symbolBasis->variantT() = %d = %s statement->variantT() = %d = %s \n",
               symbolBasis->variantT(),Cxx_GrammarTerminalNames[symbolBasis->variantT()].name.c_str(),
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name.c_str());
#endif
          assert(symbolBasis != NULL);

          if (symbolBasis->variantT() == statement->variantT())
             {
#if 0
               printf ("matching variants \n");
#endif
               returnSymbol = p_iterator->second;

            // This is a very precise test which might be a problem because of defining and non-defining versions 
            // of declarations (we might be able to always use the non-defining declaration in these cases.  The 
            // switch which computes the names could normalize this aspect.
               if (returnSymbol->get_symbol_basis() == statement)
                  {
#if 0
                    printf ("returnSymbol->get_symbol_basis() == statement returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
#endif
                    return returnSymbol;
                  }
                 else
                  {
#if 0
                    printf ("returnSymbol->get_symbol_basis() != statement \n");
#endif
                  }
             }
            else
             {
#if 0
               printf ("Some other symbol was found (no matching variants) \n");
#endif
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }


void
SgSymbolTable::remove( const SgSymbol* symbol )
   {
  // This is used for the handled of non function type symbol tables, and is more useful when the 
  // symbols don't have unique names.

  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     assert (p_table != NULL);

#if 1
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // This is an expensive linear time search of the symbol table!
     assert(exists(symbol) == true);
#endif

  // This is a virtual function call
     SgName name = symbol->get_name();
#if 0
  // printf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) from SgSymbolTable = %p \n",symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),this);
     SgNode* symbolBasis = symbol->get_symbol_basis();
     assert(symbolBasis != NULL);
     printf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) symbol_basis = %p = %s = %s from SgSymbolTable = %p \n",
          symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),
          symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str(),this);
#endif
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator elementToDelete = get_table()->end();
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator it = get_table()->find(name);
//#else
     rose_hash_multimap::iterator elementToDelete = get_table()->end();
     rose_hash_multimap::iterator it = get_table()->find(name);
//#endif
     while ( (it != get_table()->end()) && (elementToDelete == get_table()->end()) && ((*it).first == name) )
        {
       // printf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
       // Make sure that we find the correct element
          if (it->second == symbol)
             {
            // printf ("Found iterator for symbol = %p \n",symbol);
               elementToDelete = it;
             }
          it++;
        }
#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/11/2007): This is part of making the symbol table use more precise.
     if (elementToDelete == get_table()->end())
        {
          printf ("Error: could not find symbol name = %s in symbol table (restart search using symbol pointer) \n",name.str());

       // DQ (2/19/2007): Added assertion to exit on error!  Enforcing this allows us to
       // make sure that the complexity is not linear in the size of the symbol table!
          assert(false);

          rose_hash_multimap::iterator i = get_table()->begin();
          while ( (i != get_table()->end()) && (elementToDelete == get_table()->end()) )
             {
            // printf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
            // Make sure that we find the correct element
               if (i->second == symbol)
                  {
                 // printf ("Found iterator for symbol = %p \n",symbol);
                    elementToDelete = i;
                  }
               i++;
             }

          if (elementToDelete != get_table()->end())
             {
               printf ("Warning: found symbol = %p = %s stored under a different name = %s \n",symbol,symbol->class_name().c_str(),elementToDelete->first.str());
               printf ("Location of problem in source code: \n");
               SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(symbol->get_symbol_basis());
               if (declarationStatement != NULL)
                  {
                    printf ("declarationStatement = %p = %s \n",declarationStatement,declarationStatement->class_name().c_str());
                    declarationStatement->get_startOfConstruct()->display("location of problem: debug");
                  }
               assert(false);
             }
        }
#endif

#if 0
  // DQ (2/13/2007): Now we really have an error to report
  // Make sure we found the input element to be removed!
     if (elementToDelete == get_table()->end())
        {
          printf ("Error: could not find symbol = %p name = %s in symbol table (failed to find symbol pointer under any name) \n",symbol,name.str());
          assert(false);
        }
#endif
     assert(elementToDelete != get_table()->end());

  // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase(elementToDelete->second);"
  // get_table()->erase(elementToDelete);

  // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
  // p_symbolSet.erase(symbol);
     p_symbolSet.erase(elementToDelete->second);

     get_table()->erase(elementToDelete);
   }



#if 0
// *****************************************************************
// DQ (2/6/2007): These are just too dangerous to use directly.
// Use the versions which take a declaration or a symbol explicitly.
// *****************************************************************

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      void remove_function      ( const SgName & );
      void remove_class         ( const SgName & );
      void remove_enum          ( const SgName & );
      void remove_typedef       ( const SgName & );
      void remove_label         ( const SgName & );
      void remove_var           ( const SgName & );
      void remove_enum_field    ( const SgName & );
      void remove_function_type ( const SgName & );
      void remove_namespace     ( const SgName & );
*/

#error "DEAD CODE!"

void
SgSymbolTable::remove_function( const SgName & name )
   {
     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgFunctionSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_class( const SgName & name )
   {
     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgClassSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase(i->second);"
       // get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          get_table()->erase(*i);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_enum( const SgName & name )
   {
     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_label( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     assert(false);

     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_var( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     assert(false);

     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_function_type( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     assert(false);

     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

void
SgSymbolTable::remove_namespace( const SgName & name )
   {
     printf ("Error: not implemented yet! \n");
     assert(false);

     assert(p_table != NULL);

     list<rose_hash_multimap::iterator> deleteList;
     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && (*p_iterator).first == name)
        {
          if (isSgEnumSymbol((*p_iterator).second))
             {
               deleteList.push_back(p_iterator);
             }
          p_iterator++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();
     while (i != deleteList.end())
        {
          get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase(i->second);

          i++;
        }
   }

#error "DEAD CODE!"

#endif

/* ************************************************************************
                               FIND FUNCTIONS
   ************************************************************************/

// DQ (2/10/2007): This is a depricated function
int
SgSymbolTable::find(const SgName & nm, SgSymbol *sp)
   {
     assert(p_table != NULL);

  // if(!p_table)
  //      return NULL;

  // DQ (5/22/2006): Made this a local variable
  // hash_iterator p_iterator = p_table->find(nm);
     p_iterator = p_table->find(nm);
  // while (p_iterator != p_table->end() && (*p_iterator).first == nm)
     while (p_iterator != p_table->end() && p_iterator->first == nm)
        {
          p_name    = nm;
          p_no_name = false;
       // if( ((SgSymbol *)(*p_iterator).second) == sp )
          if( p_iterator->second == sp )
               return true;
          p_iterator++;
        }

     return false;
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm ) const
   {
     assert(p_table != NULL);
     return p_table->find(nm) != p_table->end();
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgSymbol *sp ) const
   {
#if 0
// DQ (2/19/2007): Make sure that this sort of expensive symbol table is not called if SYMBOL_TABLE_ERROR_CHECKING  is not active
#if SYMBOL_TABLE_ERROR_CHECKING == 0
     printf ("Error: Expensive symbol table tests being called while SYMBOL_TABLE_ERROR_CHECKING == 0 \n");
     assert(false);
#endif


  // This is the more expensive implementation but more useful for error checking!
     bool returnValue = false;

     assert(p_table != NULL);
     hash_iterator i = p_table->begin();
     while ( returnValue == false && i != p_table->end() )
        {
       // if ((SgSymbol *)(i->second) == sp )
          if ( i->second == sp )
               returnValue = true;
          i++;
        }
     return returnValue;
#else
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // return p_symbolSet.find(sp) != p_symbolSet.end();
     return p_symbolSet.find(const_cast<SgSymbol*>(sp)) != p_symbolSet.end();
#endif
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm, SgSymbol *sp ) const
   {
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // Since we if we find the symbol it exists, we can test the name separately
  // bool returnValue = false;

  // Test if the symbol is in the set, else the name is not relavant to the existence
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
       // Now look to make sure that we have an entry with the correct name (and pointer value)
          hash_iterator p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && p_iterator->first == nm)
             {
               if ( p_iterator->second == sp )
                  {
                 // This allows us to short-circuit the rest of the iterations
                    return true;
                  }

               p_iterator++;
             }
        }

     return false;
   }

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any(const SgName &);
      SgVariableSymbol*  find_variable(const SgName &);
      SgClassSymbol*     find_class(const SgName &);
      SgFunctionSymbol*  find_function(const SgName&);
      SgFunctionSymbol*  find_function_type(const SgName&, const SgType*);
      SgTypedefSymbol*   find_typedef(const SgName &);
      SgEnumSymbol*      find_enum(const SgName &);
      SgEnumFieldSymbol* find_enum_field(const SgName &);
      SgLabelSymbol*     find_label(const SgName &) const;
      SgNamespaceSymbol* find_namespace(const SgName &);
*/

SgSymbol*
SgSymbolTable::findany(const SgName &nm)
   {
     return find_any(nm);
   }

SgSymbol*
SgSymbolTable::find_any(const SgName &nm)
   {
     assert(p_table != NULL);
     if(p_table)
        {
       // DQ (5/22/2006): Made this a local variable
       // hash_iterator p_iterator = p_table->find(nm);
          p_iterator = p_table->find(nm);
          if (p_iterator != p_table->end() && p_iterator->first == nm)
             {
               p_name    = nm; 
               p_no_name = false;
               return (SgSymbol *) p_iterator->second;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgTypedefSymbol*
SgSymbolTable::find_typedef(const SgName &nm)
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && p_iterator->first == nm)
             {
            // if(isSgTypedefSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgTypedefSymbol)
                  {
                    p_name=nm;
                    p_no_name = false;
                    return (SgTypedefSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumSymbol*
SgSymbolTable::find_enum(const SgName &nm)
   {
     assert(p_table != NULL);
     if(p_table != NULL)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgEnumSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgEnumSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgEnumSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumFieldSymbol*
SgSymbolTable::find_enum_field(const SgName &nm)
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator=p_table->find(nm);
          while(p_iterator != p_table->end() && p_iterator->first == nm)
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgEnumFieldSymbol)
                  {
                    p_name=nm;
                    p_no_name = false;
                    return (SgEnumFieldSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgVariableSymbol*
SgSymbolTable::findvar(const SgName &nm)
   {
     return find_variable(nm);
   }

SgVariableSymbol*
SgSymbolTable::find_variable(const SgName &nm)
   {
     assert(this != NULL);
     assert(p_table != NULL);

     p_iterator = p_table->find(nm);

     hash_iterator save_original_iterator = p_iterator;

  // First look through only the local (non-aliased) symbols.
     while(p_iterator != p_table->end() && (*p_iterator).first==nm)
        {
       // printf ("Looking for non-aliased symbols: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());
          if (p_iterator->second->variantT() == V_SgVariableSymbol)
             {
               p_name    = nm;
               p_no_name = false;
               return (SgVariableSymbol *) p_iterator->second;
             }

          p_iterator++;
        }

  // DQ (9/30/2008): If we have not found a symbol from the current scope, search for symbols 
  // injected from other scopes using the Fortran "use" statment (or in a future implementation 
  // the C++ "using" directive or "using" declaration).
     p_iterator = save_original_iterator;
     while(p_iterator != p_table->end() && (*p_iterator).first==nm)
        {
       // printf ("Looking for aliased symbols: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());
          SgAliasSymbol* aliasedSymbol = isSgAliasSymbol(p_iterator->second);
          if (aliasedSymbol != NULL)
             {
            // DQ (10/9/2008): Resolve the last link in any chain of alias symbols
            // SgVariableSymbol* variableSymbol = isSgVariableSymbol(aliasedSymbol->get_alias());
               SgVariableSymbol* variableSymbol = isSgVariableSymbol(aliasedSymbol->get_base());
               if ( variableSymbol != NULL )
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return variableSymbol;
                  }
             }
          
          p_iterator++;
        }

     return NULL;
   }

SgClassSymbol*
SgSymbolTable::findclass(const SgName &nm)
   {
     return find_class(nm);
   }

SgClassSymbol*
SgSymbolTable::find_class(const SgName &nm)
   {
     assert(p_table != NULL);

     p_iterator = p_table->find(nm);

     hash_iterator save_original_iterator = p_iterator;

  // First look through only the local (non-aliased) symbols.

     while (p_iterator != p_table->end() && (*p_iterator).first==nm)
        { 
          if ( p_iterator->second->variantT() == V_SgClassSymbol)
             {
               p_name    = nm;
               p_no_name = false;
               return (SgClassSymbol *) p_iterator->second;
             }
          p_iterator++;
        }

  // DQ (9/30/2008): If we have not found a symbol from the current scope, search for symbols 
  // injected from other scopes using the Fortran "use" statment (or in a future implementation 
  // the C++ "using" directive or "using" declaration).
     p_iterator = save_original_iterator;
     while(p_iterator != p_table->end() && (*p_iterator).first==nm)
        {
       // printf ("Looking for aliased symbols: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());
          SgAliasSymbol* aliasedSymbol = isSgAliasSymbol(p_iterator->second);
          if (aliasedSymbol != NULL)
             {
            // DQ (10/9/2008): Resolve the last link in any chain of alias symbols
            // SgClassSymbol* classSymbol = isSgClassSymbol(aliasedSymbol->get_alias());
               SgClassSymbol* classSymbol = isSgClassSymbol(aliasedSymbol->get_base());
               if ( classSymbol != NULL )
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return classSymbol;
                  }
             }
          
          p_iterator++;
        }

     return NULL;
   }

SgFunctionTypeSymbol*
SgSymbolTable::findfunctype(const SgName &nm)
   {
     return find_function_type(nm);
   }

SgFunctionTypeSymbol*
SgSymbolTable::find_function_type(const SgName &nm)
   {
     assert(p_table != NULL);
     SgFunctionTypeSymbol* returnFunctionType = NULL;

     hash_iterator i = p_table->find(nm);
  // if (i != p_table->end() && isSgFunctionTypeSymbol((*i).second))
     if (i != p_table->end() && i->second->variantT() == V_SgFunctionTypeSymbol)
        {
       // return (SgFunctionTypeSymbol *) i->second;
          returnFunctionType = (SgFunctionTypeSymbol *) i->second;
        }

  // return NULL;
     return returnFunctionType;
   }

SgLabelSymbol*
SgSymbolTable::find_label(const SgName &nm)
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgNamespaceSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgLabelSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgLabelSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgNamespaceSymbol* 
SgSymbolTable::find_namespace ( const SgName & nm )
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && (*p_iterator).first == nm)
             {
            // if (isSgNamespaceSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgNamespaceSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgNamespaceSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }

SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName &nm, const SgType* t)
   {
     return find_function(nm,t);
   }

SgFunctionSymbol*
SgSymbolTable::find_function (const SgName &nm, const SgType* t)
   {
  // AS (083006): cleaned up logic so that the function only have one return statement.

     SgFunctionSymbol *s = NULL;
     assert(p_table != NULL);
     if(p_table)
        {

       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i=p_table->find(nm);
       // JW and AS (08/30/06) changed to use equal range rather than find and
       //    iterating through the hash table. This is an optimization.

          std::pair<hash_iterator, hash_iterator> range = p_table->equal_range(nm);

          for (hash_iterator i = range.first; i != range.second; ++i)
             {
            // s = isSgFunctionSymbol((*i).second);
               s = isSgFunctionSymbol(i->second);

                //  if ( (s != NULL) && (s->get_declaration()->get_type() == t))
                // FMZ (10/29/2009) should compare name also
                if ( (s != NULL) && (s->get_declaration()->get_type() == t) && s->get_name().str()==nm.str())
                  {
                    p_name    = nm;
                    p_no_name = false;
                 // return ((SgFunctionSymbol *)(*i).second);
                    break;
                  }
             }
        }

     return s;
   }

SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName &nm)
   {
     return find_function(nm);
   }

SgFunctionSymbol*
SgSymbolTable::find_function(const SgName &nm)
   {
     assert(p_table != NULL);

  // First look through only the local (non-aliased) symbols.

     p_iterator = p_table->find(nm);

     hash_iterator save_original_iterator = p_iterator;

     while(p_iterator != p_table->end())
        {
          if (isSgFunctionSymbol(p_iterator->second) && (*p_iterator).first==nm)
             {
               p_name    = nm;
               p_no_name = false;
               return (SgFunctionSymbol *) p_iterator->second;
             }
            else
             {
            // DQ (10/11/2008): Added support to find renamed functions (common in Fortran 90)
            // F90 permits interface statements to effectively rename functions is scope, 
            // SgRenameSymbol IR nodes are used to represent the renamed functions.  This
            // renaming using an interface is different from the aliasing and combined renaming 
            // that is possible within the "use" statement.
               if ( p_iterator->second->variantT() == V_SgRenameSymbol)
                  {
                 // printf ("Found a SgRenameSymbol: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());

                    p_name    = nm;
                    p_no_name = false;
                    SgRenameSymbol* renameSymbol = isSgRenameSymbol(p_iterator->second);
                    assert(renameSymbol != NULL);

                 // DQ (10/11/2008): Moved SgRenameSymbol to be derived from SgFunctionSymbol.
                 // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(renameSymbol->get_original_symbol());
                    SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(renameSymbol);
                    assert(functionSymbol != NULL);
                    return functionSymbol;
                  }
             }

          p_iterator++;
        }

  // DQ (9/30/2008): If we have not found a symbol from the current scope, search for symbols 
  // injected from other scopes using the Fortran "use" statment (or in a future implementation 
  // the C++ "using" directive or "using" declaration).
     p_iterator = save_original_iterator;
     while(p_iterator != p_table->end() && (*p_iterator).first==nm)
        {
       // printf ("Looking for aliased symbols: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());
          SgAliasSymbol* aliasedSymbol = isSgAliasSymbol(p_iterator->second);
          if (aliasedSymbol != NULL)
             {
            // DQ (10/9/2008): Resolve the last link in any chain of alias symbols
            // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(aliasedSymbol->get_alias());
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(aliasedSymbol->get_base());
            // printf ("Looking for functionSymbol = %p \n",functionSymbol);

            // DQ (10/10/2008): The current problem is that this is NULL when the base of an aliased symbol is a SgRenameSymbol.
            // assert(functionSymbol != NULL);

               if ( functionSymbol != NULL )
                  {
                 // printf ("Found a valid functionSymbol = %p = %s \n",functionSymbol,functionSymbol->get_name().str());
                    p_name    = nm;
                    p_no_name = false;
                    return functionSymbol;
                  }
             }

          p_iterator++;
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template(const SgName &nm)
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->find(nm);
          while(p_iterator != p_table->end())
             {
            // if(isSgTemplateSymbol((*p_iterator).second))
               if ( p_iterator->second->variantT() == V_SgTemplateSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    return (SgTemplateSymbol *) p_iterator->second;
                  }
               p_iterator++;
             }
        }

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any();
      SgVariableSymbol*  find_variable();
      SgClassSymbol*     find_class();
      SgFunctionSymbol*  find_function();
      SgFunctionSymbol*  find_function_type();
      SgTypedefSymbol*   find_typedef();
      SgEnumSymbol*      find_enum();
      SgEnumFieldSymbol* find_enum_field();
      SgLabelSymbol*     find_label();
      SgNamespaceSymbol* find_namespace();
*/

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::findfirstany()
   {
     return find_any();
   }
SgSymbol*
SgSymbolTable::find_any()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true; 
          if(p_iterator != p_table->end())
            // return ((SgSymbol *) (*p_iterator).second);
               return (SgSymbol *) p_iterator->second;
        }

     return NULL;
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::findfirstvar()
   {
     return find_variable();
   }
SgVariableSymbol*
SgSymbolTable::find_variable()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;   
          while(p_iterator != p_table->end()) 
             {
            // if(isSgVariableSymbol((*p_iterator).second)) 
            //      return ((SgVariableSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgVariableSymbol) 
                    return (SgVariableSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::findfirstclass()
   {
     return find_class();
   }
SgClassSymbol*
SgSymbolTable::find_class()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgClassSymbol((*p_iterator).second)) 
            //      return ((SgClassSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgClassSymbol) 
                    return (SgClassSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::findfirstfunction()
   {
     return find_function();
   }
SgFunctionSymbol*
SgSymbolTable::find_function()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionSymbol) 
                    return (SgFunctionSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (1/30/2007): Added to make the interface consistant
// This function is not requires since SgFunctionTypeSymbols
// are stored into their own function table.  So this is 
// equivalent to STL function "begin()".
SgFunctionSymbol*
SgSymbolTable::find_function_type()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionTypeSymbol) 
                    return (SgFunctionTypeSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }
#endif

SgTypedefSymbol*
SgSymbolTable::find_typedef()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTypedefSymbol((*p_iterator).second)) 
            //      return ((SgTypedefSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTypedefSymbol) 
                    return (SgTypedefSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumSymbol*
SgSymbolTable::find_enum()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumSymbol((*p_iterator).second)) 
            //      return ((SgEnumSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumSymbol) 
                    return (SgEnumSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumFieldSymbol*
SgSymbolTable::find_enum_field()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second)) 
            //      return ((SgEnumFieldSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumFieldSymbol) 
                    return (SgEnumFieldSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::find_label()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgLabelSymbol((*p_iterator).second)) 
            //      return ((SgLabelSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgLabelSymbol) 
                    return (SgLabelSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::find_namespace()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgNamespaceSymbol((*p_iterator).second)) 
            //      return ((SgNamespaceSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgNamespaceSymbol) 
                    return (SgNamespaceSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTemplateSymbol((*p_iterator).second))
            //      return ((SgTemplateSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTemplateSymbol)
                    return (SgTemplateSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }




/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          next_any();
      SgVariableSymbol*  next_variable();
      SgClassSymbol*     next_class();
      SgFunctionSymbol*  next_function();
      SgTypedefSymbol*   next_typedef();
      SgEnumSymbol*      next_enum();
      SgEnumFieldSymbol* next_enum_field();
      SgLabelSymbol*     next_label();
      SgNamespaceSymbol* next_namespace();
*/

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::nextany()
   {
     return next_any();
   }
SgSymbol*
SgSymbolTable::next_any()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() )
             {
               if( p_no_name || (*p_iterator).first == p_name )
                    return (SgSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::nextvar()
   {
     return next_variable();
   }
SgVariableSymbol*
SgSymbolTable::next_variable()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgVariableSymbol((*p_iterator).second))
                    return ((SgVariableSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::nextclass()
   {
     return next_class();
   }
SgClassSymbol*
SgSymbolTable::next_class()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++; // go to next one

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgClassSymbol((*p_iterator).second))
                    return ((SgClassSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::nextfunc()
   {
     return next_function();
   }
SgFunctionSymbol*
SgSymbolTable::next_function()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgFunctionSymbol((*p_iterator).second))
                    return ((SgFunctionSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTypedefSymbol*
SgSymbolTable::next_typedef()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgTypedefSymbol((*p_iterator).second))
                    return ((SgTypedefSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }


// DQ (1/30/2007): Added this as a new member function.
SgEnumSymbol*
SgSymbolTable::next_enum()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgEnumSymbol((*p_iterator).second))
                    return ((SgEnumSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added this as a new member function.
SgEnumFieldSymbol*
SgSymbolTable::next_enum_field()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if(isSgEnumFieldSymbol((*p_iterator).second))
                    return ((SgEnumFieldSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::next_label()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgLabelSymbol((*p_iterator).second))
                    return ((SgLabelSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::next_namespace()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgNamespaceSymbol((*p_iterator).second))
                    return ((SgNamespaceSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::next_template()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
             {
               if (isSgTemplateSymbol((*p_iterator).second))
                    return ((SgTemplateSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }



#if 1
// DQ (1/30/2007): Added these back into ROSE.
SgSymbol*
SgSymbolTable::operator[](const SgName & nm)
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i=p_table->find(nm);
          hash_iterator i=p_table->find(nm);
          if (i != p_table->end())
               return (*i).second;
        }

     return NULL;
   }
#endif

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::size() const
   {
     assert(p_table != NULL);
     return p_table->size();
   }

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::count(const SgName &nm) const
   {
  // DQ (1/30/2007): assertion added
     assert(p_table != NULL);
     return p_table->count(nm);
   }

void
SgSymbolTable::print( std::string label, VariantT nodeType )
   {
     printf ("Printing out the data within the symbol table (p_table = %p,label = %s size = %d): \n",p_table,label.c_str(),size());

     printf ("Internal static data: p_no_name: %s p_name = %s \n",(p_no_name == true) ? "true" : "false",p_name.str());

  // These are just static data used internally for some of the symbol lookup functions (symbol tables are not given names).
  // printf ("SymbolTable has a name: %s \n",(p_no_name == true) ? "NO: it has no name" : "YES: it does have a name");
  // if (p_no_name == false)
  //      printf ("SymbolTable name = %s \n",p_name.str());

  // DQ (2/16/2006): This is a SgScopeStatement except for the SgSymbolTable used in the global function type symbol table
  // SgScopeStatement* parentNode = isSgScopeStatement(get_parent());
     SgNode* parentNode = get_parent();
     assert(parentNode != NULL);
     printf ("Symbol table has parent = %p = %s \n",parentNode,parentNode->class_name().c_str());

  // DQ (6/23/2005): It is not a problem for the global function table to not have a name!
  //   else
  //      assert (p_name.str() == NULL);

     assert(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i = p_table->begin();
          hash_iterator i = p_table->begin();

          int idx = 0;
          while (i != p_table->end())
             {
            // DQ: removed SgName casting operator to char*
            // cout << "[" << idx << "] " << (*i).first;
            // cout << "[" << idx << "] " << (*i).first.str();
               assert ( isSgSymbol( (*i).second ) != NULL );

            // printf ("Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) sage_class_name() = %s \n",
            //      idx,(*i).first.str(),(*i).second->sage_class_name());

               SgSymbol* symbol = isSgSymbol((*i).second);
               assert ( symbol != NULL );
               SgType* type = symbol->get_type();

            // DQ (5/7/2004): modified to allow for get_type() to return NULL
            // assert ( type != NULL );

               SgNamedType* namedType = isSgNamedType(type);
               SgName nameOfType;
               if (namedType != NULL)
                  {
                    nameOfType = namedType->get_name();
                 // char* nameString = namedType->get_name().str();
                 // printf ("Type is: (named type) = %s \n",nameString);
                  }
                 else
                  {
                 // DQ (5/7/2004): modified to allow for get_type() to return NULL
                    if (type != NULL)
                       {
                      // printf ("Type is: type->sage_class_name() = %s \n",type->sage_class_name());
                         nameOfType = type->sage_class_name();
                       }
                      else
                       {
                      // printf ("Type is: No type found in symbol (likely a possible error!) \n");
                         switch(symbol->variantT())
                            {
                              case V_SgNamespaceSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgNamespaceSymbol)";
                                   break;
                                 }

                              case V_SgTemplateSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgTemplateSymbol)";
                                   break;
                                 }

                              default:
                                 {
                                // This is likely an error, I think
                                   nameOfType = "unkown type name (likely a possible error!)";
                                   break;
                                 }
                            }
                       }
                  }

               bool outputSymbolInfo = (nodeType == V_SgSymbol) || (symbol->variantT() == nodeType);

            // Output of symbol information
               SgNode* symbolBasis = i->second->get_symbol_basis();
               if (symbolBasis != NULL)
                  {
                    assert(symbolBasis != NULL);

                    if (outputSymbolInfo == true)
                       {
                         printf ("Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());
                       }
                  }
                 else
                  {
                    if (outputSymbolInfo == true)
                       {
                         printf ("Warning Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = NULL \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str());
                       }
                  }

               SgName mangledName;
               SgSymbol* symbolFromTable = (*i).second;
               assert(symbolFromTable != NULL);
               switch(symbolFromTable->variantT())
                  {
                    case V_SgFunctionSymbol:
                       {
                         SgFunctionSymbol* symbol = isSgFunctionSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgMemberFunctionSymbol:
                       {
                         SgMemberFunctionSymbol* symbol = isSgMemberFunctionSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgClassSymbol:
                       {
                         SgClassSymbol* symbol = isSgClassSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgClassDeclaration* classDeclaration = symbol->get_declaration();
                         mangledName = classDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgEnumFieldSymbol:
                       {
                         SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgInitializedName* enumFieldName = symbol->get_declaration();
                         mangledName = enumFieldName->get_mangled_name();
                         break;
                       }
                    case V_SgEnumSymbol:
                       {
                         SgEnumSymbol* symbol = isSgEnumSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgEnumDeclaration* enumDeclaration = symbol->get_declaration();
                         mangledName = enumDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgFunctionTypeSymbol:
                       {
                         SgFunctionTypeSymbol* symbol = isSgFunctionTypeSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         mangledName = symbol->get_name();
                         printf ("A SgFunctionTypeSymbol also has a pointer to a SgType = %p \n",symbol->get_type());
                         break;
                       }
                    case V_SgLabelSymbol:
                       {
                         SgLabelSymbol* symbol = isSgLabelSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgLabelStatement* labelStatement = symbol->get_declaration();

                      // DQ (12/24/2007): Modified to reflect new implementation for Fortran numeric labels.
                      // mangledName = labelStatement->get_label();
                         if (labelStatement == NULL)
                            {
                              assert(symbol->get_numeric_label_value() >= 0);
                              mangledName = StringUtility::numberToString(symbol->get_numeric_label_value());
                            }
                           else
                            {
                              mangledName = labelStatement->get_label();
                            }
                         break;
                       }
                    case V_SgNamespaceSymbol:
                       {
                         SgNamespaceSymbol* symbol = isSgNamespaceSymbol(symbolFromTable);
                         assert(symbol != NULL);
#if 0
                         SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
                         mangledName = namespaceDeclaration->get_mangled_name();
                         printf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
#else
                         if (symbol->get_isAlias() == true)
                            {
                              SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = symbol->get_aliasDeclaration();
                              mangledName = namespaceAliasDeclarationStatement->get_mangled_name();
                              printf ("A SgNamespaceSymbol has an ALIAS with name = %s \n",symbol->get_name().str());
                            }
                           else
                            {
                              SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
                              mangledName = namespaceDeclaration->get_mangled_name();
                              printf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
                            }
#endif
                         break;
                       }
                    case V_SgTemplateSymbol:
                       {
                         SgTemplateSymbol* symbol = isSgTemplateSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgTemplateDeclaration* templateDeclaration = symbol->get_declaration();
                         mangledName = templateDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgTypedefSymbol:
                       {
                         SgTypedefSymbol* symbol = isSgTypedefSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgTypedefDeclaration* typedefDeclaration = symbol->get_declaration();
                         mangledName = typedefDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgVariableSymbol:
                       {
                         SgVariableSymbol* symbol = isSgVariableSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgInitializedName* initializedName = symbol->get_declaration();
                         mangledName = initializedName->get_mangled_name();
                         break;
                       }
                    case V_SgAliasSymbol:
                       {
                         SgAliasSymbol* symbol = isSgAliasSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         mangledName = symbol->get_name();
                         break;
                       }
                     
                    default:
                       {
                         mangledName = "unknown mangled name";
                         printf ("Error: SgSymbol not handled (%s) \n",symbolFromTable->class_name().c_str());

                      // DQ (6/8/2007): Make this case fail so we can detect this error.
                         assert(false);
                       }
                  }

               if (outputSymbolInfo == true)
                  {
                    printf ("   Symbol's associated mangled name = %s \n",mangledName.str());

                 // This is useful for the output of the function types when the global function type symbol table is output.
                 // handle case of function symbol (unparse the funtion type)
                    SgFunctionTypeSymbol *f = isSgFunctionTypeSymbol((*i).second);
                    if (f != NULL)
                       {
#if 1
                      // f->get_type()->unparse(); cout << endl;
                         std::cout << "     function: " << f->get_type()->unparseToString() << endl;
#else
                      // printf ("ERROR: unparse function for symbol type not implemented in SAGE3! \n");
                      // ROSE_ABORT();
#endif
                       }
                  }

            // Increment the symbol table's symbol iterator
               i++;

            // Increment the symbol counter (used for output)
               idx++;
             }
        }
       else
        {
       // DQ (6/27/2005): I think this is an error (we should always have a valid symbol table)
          printf ("Pointer to symbol table is NULL \n");
          assert(false);
        }
   }


set<SgNode*>
SgSymbolTable::get_symbols() const
   {
  // DQ (2/15/2007): generate a set of SgNode* so that we can use them for set difference against the delete list in AST merge.
     set<SgNode*> returnSet;

     assert(p_table != NULL);
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSC_VER
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator i = get_table()->begin();
//#else
     rose_hash_multimap::iterator i = get_table()->begin();
//#endif
     while (i != p_table->end())
        {
          assert(i->second != NULL);
          returnSet.insert(i->second);

          i++;
        }

     return returnSet;
   }


SOURCE_SYMBOL_TABLE_END


SOURCE_BASECLASS_START

void
SgBaseClass::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // DQ (4/25/2004): Note that because of limitiations in the ordering of output 
  // class declarations in ROSETTA, I was unable make this SgBaseClassModifier a 
  // data member and was forced to handle it as a pointer).
     p_baseClassModifier = new SgBaseClassModifier();
     assert ( p_baseClassModifier != NULL);
   }

#if 0
// This function should be autogenerated
SgBaseClass::SgBaseClass(int specifier ,SgClassDeclaration* ptr, int dir)
   : p_specifier(specifier), p_ptr(ptr), p_isDirectBaseClass(dir)
   {
   }
#endif

SgBaseClass::SgBaseClass(const SgBaseClass& X)
   {
  // these are the old names
  // p_specifier = ptr.p_specifier;
  // p_ptr       = ptr.p_ptr;
  // p_base_specifier = X.p_base_specifier;
     p_base_class     = X.p_base_class;

  // DQ (6/21/2005): Commented out since it is not used, we might want it later!
  // DQ: initialize all values
     p_isDirectBaseClass = 0;

     assert ( X.p_baseClassModifier != NULL);
     p_baseClassModifier = new SgBaseClassModifier( *(X.p_baseClassModifier) );
     assert ( p_baseClassModifier != NULL);
   }

#if 0
// generated automatically
SgBaseClass::~SgBaseClass()
   {
  /* delete p_ptr; */
   }
#endif

SgBaseClass &
SgBaseClass::operator= (const SgBaseClass & X)
   {
  // Old names
  // p_specifier = ptr.p_specifier;
  // p_direct    = ptr.p_direct; 
  // p_ptr       = ptr.p_ptr;

  // p_base_specifier     = X.p_base_specifier;
     p_base_class         = X.p_base_class;

  // DQ (6/21/2005): Renamed to make this more clear
     p_isDirectBaseClass  = X.p_isDirectBaseClass;

     assert (p_baseClassModifier   != NULL);
     assert (X.p_baseClassModifier != NULL);
     *p_baseClassModifier = *X.p_baseClassModifier;

     return *this;
   }

#if 0
// These are automatically generated now!
int
SgBaseClass::get_base_specifier() const
   { return p_specifier; }

SgClassDeclaration*
SgBaseClass::get_base_class() const
   { return p_ptr; }
#endif

#if 0
// DQ: I don't think this is used anywhere
SgClassDeclaration*
replace_base_class(SgClassDeclaration *);
#endif

// I assume these relational member functions are added to permit use with STL
bool
SgBaseClass::operator== (const SgBaseClass& ) const
   { return false; }

bool
SgBaseClass::operator< (const SgBaseClass&) const
   { return false; }

// DQ (4/25/2004): Part of new modifier interface
SgBaseClassModifier & 
SgBaseClass::get_baseClassModifier()
   {
     assert ( p_baseClassModifier != NULL);
     return *p_baseClassModifier;
   }
 
SOURCE_BASECLASS_END


SOURCE_X_INITIALIZED_NAME_START

// Include this code only if we are building a derived grammar (not a root grammar)
$CLASSNAME::$CLASSNAME 
   ( const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgX_DeclarationStatement *declptr ) 
   //   SgInitializedName *itemptr,
   //  SgInitializedName *prev_itemptr ) 
   : p_name(name), p_typeptr(typeptr), p_initptr(iptr), 
     p_is_initializer(1), p_declptr(NULL), p_X_declptr(declptr),
     p_prev_decl_item(prev_itemptr)
   {}

void
$CLASSNAME::set_X_declaration(SgX_DeclarationStatement * decl)
   { p_X_declptr = decl; }

SOURCE_X_INITIALIZED_NAME_END


SOURCE_INITIALIZED_NAME_START

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgInitializedName::get_symbol_from_symbol_table() const
   {
     assert(get_scope() != NULL);
     assert(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
   }

// PC (10/1/2009): Added support to get the symbol from the correct associated declaration
SgSymbol*
SgInitializedName::search_for_symbol_from_symbol_table() const
   {
     SgSymbol *symbol;
     if (p_prev_decl_item)
          symbol = p_prev_decl_item->get_symbol_from_symbol_table();
     else
          symbol = get_symbol_from_symbol_table();
     assert(symbol != NULL);
     return symbol;
   }

#if 0
SgInitializedName::~SgInitializedName() 
   {
   /*delete p_ptr;*/
   }

SgInitializedName::SgInitializedName()
   : p_typeptr(0), p_initptr(0), p_declptr(0),
    // p_itemptr(0), p_prev_itemptr(0), 
     p_is_initializer(1)
   {
   }
#endif


Sg_File_Info*
SgInitializedName::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgInitializedName::set_file_info(Sg_File_Info* X)
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode 
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return set_startOfConstruct(X);
   }

SgStorageModifier &
SgInitializedName::get_storageModifier()
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

const SgStorageModifier &
SgInitializedName::get_storageModifier() const
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

SgName
SgInitializedName::get_qualified_name() const
   {
  // DQ (8/22/2005): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     assert(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

void
SgInitializedName::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // printf ("In SgInitializedName::post_construction_initialization() this = %p \n",this);

     p_storageModifier = new SgStorageModifier();
     assert (p_storageModifier != NULL);
     p_storageModifier->setDefault();

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism = NULL;

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope = NULL;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
       // printf ("In SgInitializedName::post_construction_initialization(): resetting parent of valid initializer (p_initptr = %p) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // DQ (1/3/2009): Added support for GNU variable attributes (std::strings will default to null, so they are not setup).
     p_gnu_attribute_modifierVector          = SgBitVector(e_last_gnu_variable_attribute,false);
     p_gnu_attribute_initialization_priority = 0;
     p_gnu_attribute_alignment               = 0;

  // Borrow the enum definition (and default value from SgDeclarationModifier).
     p_gnu_attribute_visability              = SgDeclarationModifier::e_unknown_visibility;

  // FMZ added for coarray
     p_isCoArray = false;

   }

// This constructor is specific to the creation of SgInitializedName objects used as initializers
SgInitializedName::SgInitializedName
   ( const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgDeclarationStatement *declptr, 
    // QY:11/2/04 remove itemptr 
    // SgInitializedName *itemptr,
     SgInitializedName *prev_itemptr ) ROSE_DEPRECATED_FUNCTION
  // DQ (1/18/2006): name change to make consistant with virtual SgNode::get_file_info() 
  // DQ (11/20/2004): Reodered elements of pre-initialization list to avoid compiler warnings
  // : p_file_info(NULL), // Note that file_info is a new data member and is set explicitly after construction
   : p_startOfConstruct(NULL), // Note that file_info is a new data member and is set explicitly after construction
     p_name(name), 
     p_typeptr(typeptr),
  // p_itemptr(itemptr), Removed constructor parameter list
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
  // DQ (6/18/2006): declptr was not being used to set the internal p_declptr data member.
  // p_declptr(NULL),
     p_declptr(declptr),
  // DQ (11/20/2004): Added additional initialization of remaining data members
     p_storageModifier(NULL),
     p_scope(NULL),
  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization(e_unknown_preinitialization),
  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes (Added initialization to prevent valgrind warning)
     p_attributeMechanism(NULL),
  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code(SgInitializedName::e_invalid_register),
  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
     p_register_name_string(""),
  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType(false)
   {
     post_construction_initialization();
   }

// DQ (8/4/2006): This constructor adds the newer fileInfo data member to the constructor parameter list.
// We might soon depricate the older constructor.
SgInitializedName::SgInitializedName
   ( Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr, 
     SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr )
   // : p_file_info(fileInfo), // Note that file_info is a new data member and is set explicitly after construction
   : p_startOfConstruct(fileInfo), // Note that file_info is a new data member and is set explicitly after construction
     p_name(name), 
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_attributeMechanism(NULL),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_register_name_string(""),
  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType(false)
   {
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName (const SgInitializedName& ptr)
   {
     p_name           = ptr.p_name;

     p_typeptr        = ptr.p_typeptr;
     p_initptr        = ptr.p_initptr;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
          printf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in copy constructor) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // p_prev_itemptr   = ptr.p_prev_itemptr; 
     p_is_initializer = ptr.p_is_initializer;
     p_declptr        = ptr.p_declptr;
  // p_itemptr        = ptr.p_itemptr;

  // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
  // p_fileInfo       = ptr.p_fileInfo;
  // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;

  // DQ (12/17/2006): See if we can enforce this!
  // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
     assert(ptr.p_startOfConstruct != NULL);
     p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
     assert(p_startOfConstruct != NULL);

  // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
     p_startOfConstruct->set_parent(this);

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope          = ptr.p_scope;

  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization = ptr.p_preinitialization;

  // DQ (4/28/2004): Added storage modifier support (replacing the old interface)
     assert (ptr.p_storageModifier != NULL);
     p_storageModifier = new SgStorageModifier ( *(ptr.p_storageModifier) );
     assert (p_storageModifier != NULL);

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
     p_attributeMechanism = NULL;

  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code = SgInitializedName::e_invalid_register;

  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
  // Note: don't copy the register string (I think this is best, but it is debatable)
     p_register_name_string = "";

  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

  // DQ (1/3/2009): Added support for GNU variable attribues
     p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
     p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
     p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
     p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
     p_isCoArray                             = ptr.p_isCoArray;
   }

SgInitializedName&
SgInitializedName::operator= (const SgInitializedName& ptr) 
   {
     assert(this != NULL);

  /* check they are not the same name */
     if (this != &ptr)
        {
          p_name = ptr.p_name;

          p_typeptr        = ptr.p_typeptr;
          p_initptr        = ptr.p_initptr;

       // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
          if (p_initptr != NULL)
             {
            // printf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in operator=) \n",p_initptr);
#if 0
            // DQ (12/22/2006): Don't allow the parent of the input SgInitializedName to be modified, but make sure that it is set!
            // p_initptr->set_parent(this);
               if (p_initptr->get_parent() == NULL)
                  {
                    p_initptr->set_parent(this);
                  }
#else
            // DQ (12/22/2006): Interestingly, the inliner is dependent upon this working this way!  We should maybe look into this later.
               p_initptr->set_parent(this);
#endif
               assert(p_initptr->get_parent() != NULL);

            // printf ("Exiting as a test! operator= \n");
            // assert(false);
             }

       // p_prev_itemptr   = ptr.p_prev_itemptr;
          p_is_initializer = ptr.p_is_initializer;
          p_declptr        = ptr.p_declptr;
       // p_itemptr        = ptr.p_itemptr; 

       // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
       // p_fileInfo       = ptr.p_fileInfo;

       // DQ (6/23/2006): Added assertion to detect errors
       // assert(ptr.p_file_info != NULL);
       // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;
       // assert(p_file_info != NULL);
          assert(ptr.p_startOfConstruct != NULL);
       // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
          p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
          assert(p_startOfConstruct != NULL);

       // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
          p_startOfConstruct->set_parent(this);

       // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
          p_scope          = ptr.p_scope;

       // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
          p_preinitialization = ptr.p_preinitialization;

          assert (p_storageModifier != NULL);
          *p_storageModifier = *(ptr.p_storageModifier);

       // DQ (4/10/2006): Removed in favor of implementation at SgNode using
       // a pointer and the interface represented directly at the SgNode
       // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
          p_attributeMechanism = NULL;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_code = ptr.p_register_name_code;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_string = ptr.p_register_name_string;

       // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
          p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

       // DQ (1/3/2009): Added support for GNU variable attribues
          p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
          p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
          p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
          p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
          p_isCoArray                             = ptr.p_isCoArray;
        }
       else
        {
       // DQ (6/23/2006): Added debugging message to track this issue.
          printf ("SgInitializedName::operator=(): Attempt to copy self to self \n");
        }

  // assert(p_file_info != NULL);
     assert(p_startOfConstruct != NULL);

     return *this;
   }

bool
SgInitializedName::operator== (const SgInitializedName& ) const
   { return false; }

bool
SgInitializedName::operator< (const SgInitializedName&) const
   { return false; }

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (12/9/2004): This is how an automatically generated function!
SgName
SgInitializedName::get_name() const
   {
     assert (this != NULL);
     return p_name;
   }
#endif

#if 0
void
SgInitializedName::set_name ( SgName name )
   {
     assert (this != NULL);
     
     p_name = name;
   }
#endif

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (10/5/2007): This was a mistake to comment out, we want this functionality.  It is likely that
// similar function ality should be provided for all other names declarations that generate symbols
// for the symbol table.
// DQ (12/9/2004): This is now an automatically generated function!
// AJ (10/21/2004): Added support for changing the symbol name associated with an SgInitializedName
// by updating the symbol table
int
SgInitializedName::set_name(SgName new_name) 
   {
  // This function could likely be simpler now that we have better symbol table support.

     set_isModified(true);

  // find the appropriate symbol table.
     SgNode * node = this;

  // DQ (12/9/2004): This should likely call the get_scope function (which is more robust than traversing 
  // parents, there is a reason why we are forced to include the scope explicitly on some IR nodes, 
  // see test2004_133.C for details).
     while((node!=NULL) && ( isSgScopeStatement(node)==NULL))
          node = node->get_parent();

     assert(node!=NULL);

     SgScopeStatement * scope_stmt = isSgScopeStatement(node);

     assert(scope_stmt != NULL);
     assert(scope_stmt->get_symbol_table() != NULL);
     assert(scope_stmt->get_symbol_table()->get_table() != NULL);

     SgDeclarationStatement * parent_declaration = get_declaration();

     assert(parent_declaration != NULL);

  // Find the symbols associated with p_name 
     std::pair<SgSymbolTable::hash_iterator,SgSymbolTable::hash_iterator> pair_it = 
          scope_stmt->get_symbol_table()->get_table()->equal_range(p_name);

     SgSymbolTable::hash_iterator found_it=scope_stmt->get_symbol_table()->get_table()->end();

     for(SgSymbolTable::hash_iterator it = pair_it.first; it != pair_it.second; ++it)
        {
          switch(parent_declaration->getVariant())
             {
               case V_SgVariableDeclaration:
                  {
                    if (isSgVariableSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgClassDeclaration:
                  {
                    if (isSgClassSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgFunctionDeclaration:
                  {
                    if (isSgFunctionSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               default:
                  {
                  }
             };
        }

  // there is no Variable,Class or Function symbol associated with p_name 
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: There is no Variable,Class or Function symbol associated with p_name \n");
          return 0;
        }

     SgSymbol * associated_symbol = (*found_it).second;

  // erase the name from there
     scope_stmt->get_symbol_table()->get_table()->erase(found_it);

  // insert the new_name in the symbol table
     found_it = scope_stmt->get_symbol_table()->get_table()->insert(pair<SgName,SgSymbol*> ( new_name,associated_symbol));

  // if insertion failed
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          printf ("Warning: insertion of new symbol failed \n");
          return 0;
        }

  // Set the p_name to the new_name
     printf ("Reset p_name = %s to new_name = %s \n",p_name.str(),new_name.str());
     p_name = new_name;

  // Invalidate the p_iterator, p_no_name and p_name data members in the Symbol table

     return 1;
   }
#endif

SgType*
SgInitializedName::get_type() const
   {
     assert(this != NULL);
     return p_typeptr;
   }

void
SgInitializedName::set_type(SgType *t)
   {
     assert(this != NULL);
     p_typeptr = t;
   }

SgInitializer*
SgInitializedName::get_initializer() const 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     assert(this != NULL);
     if (p_is_initializer)
          return p_initptr;
       else
          return NULL;
   }

void
SgInitializedName::set_initializer(SgInitializer* i) 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     assert(this != NULL);
     p_initptr        = i;
     p_is_initializer = 1;
   }


// DQ (3/31/2006): New version from Rich (fixes bug where empty mangled name was generated)
SgName
SgInitializedName::get_mangled_name (void) const
   {
     SgName mangled_name; // return value

  // Case 1: Function parameters.
  // Generate names for parameters such that
  //   int foo (int x, int y) { return x + y; }
  //   int foo (int, int);
  //   int foo (int a, int b);
  // all generate the same unique names for equivalent parameters.
     const SgFunctionParameterList* func_params = isSgFunctionParameterList (get_declaration ());
     if (func_params)
        {
       // Find position (parameter number) in parameter list
          const SgInitializedNamePtrList& func_args = func_params->get_args ();
          SgInitializedNamePtrList::const_iterator i;
          size_t param_num = 0;
          for (i = func_args.begin (); i != func_args.end () && *i != this; ++i)
               param_num++;
          if (i != func_args.end ()) // found position
             {
            // Compute a mangled prefix from the function declaration.
               ostringstream s;
               const SgFunctionDeclaration* func_decl = isSgFunctionDeclaration (func_params->get_parent ());
               if (func_decl)
                    s << func_decl->get_mangled_name ().str ();
               s << "__ARG" << param_num+1;  // Append argument number (1-based)
               mangled_name = SgName (s.str ());
             }
         // else, an error (see below).
        }
       else // Case 2: Not a function parameter
        {
          SgScopeStatement* scope = get_scope ();
          if (scope == NULL)
             {
               printf ("SgInitializedName = %p = %s \n",this,get_name().str());
               get_file_info()->display("Error scope of SgInitializedName == NULL");
             }
          assert (scope != NULL);

          SgName qual_name = mangleQualifiers (scope);

          SgName name = get_name();
          if (name.get_length() > 0) // not empty
             {
               mangled_name = joinMangledQualifiers (qual_name, get_name ());
             }
            else
             {
            // name is empty
               if (isSgCatchOptionStmt (scope)) // e.g., 'try {...} catch (int) {...}
                  {
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("CATCHARG"));
                  }
                 else
                  {
                 // printf ("Must be a padding declaration (e.g. int:16) \n");
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("PADDING_VARIABLE"));
                  }
             }
        }

     if (!mangled_name.get_length ()) // Error: could not come up with a name.
        {
          printf ("Error in SgInitializedName::get_mangled_name(void): zero length mangled name generated (see if this is realistic)\n");
          SgScopeStatement* scope = get_scope ();
          assert (scope);
          printf ("  Surrounding scope is '%s'\n", scope->sage_class_name ());
          const SgDeclarationStatement* decl = get_declaration ();
          printf ("  Decl is '%s'\n", decl ? decl->sage_class_name () : "(none)");
          const SgDeclarationStatement* def = get_definition ();
          printf ("  Def is '%s'\n", def ? def->sage_class_name () : "(none)");
          const SgNode* par = decl ? decl->get_parent () : 0;
          printf ("  Parent(decl) is '%s'\n", par ? par->sage_class_name () : "(none)");

       // DQ (2/21/2007): I think this is OK for un-named function parameters, leave as a warning for now!.
       // assert(false);
       }

     return mangled_name;
   }


// QY 11/3/04
SgDeclarationStatement*
SgInitializedName::get_declaration() const
   {
  // DQ (6/13/2005): This function assumes that the parents have been set!
  // so it should not be used in the EDG/Sage translation!
  // assert(get_parent() != NULL);

#if 1
  // DQ (6/21/2006): Return to using this version of the code
  // DQ (6/21/2005): This is trying to traverse back through the scopes which might not make sense
     for (SgNode* r = get_parent(); r != NULL; r = r->get_parent())
        {
          SgDeclarationStatement* d = isSgDeclarationStatement(r);

       // DQ (6/21/2005): I think this should always be true!
       // assert(d != NULL);

          if (d != NULL)
             {
               return d;
             }
        }

     return NULL;
#else
  // DQ (6/18/2006): Since we store the declaration we should use the explictly stored 
  // value instead of anything generated from parents (structure can be problematic for C++).
     return get_declptr();
#endif
   }

SgDeclarationStatement*
SgInitializedName::get_definition() const
   {
  // printf ("Why does SgInitializedName::get_definition() return a declaration! \n");
  // DQ (6/21/2005): Because the SgVariableDefinition is derived from a SgDeclarationStatement 
  // and we return a SgVariableDefinition

  // DQ (6/21/2005): Is this always true? NO!
  // assert(isSgVariableDefinition(get_declptr()) != NULL);

     return get_declptr(); 
   }

/*
void
SgInitializedName::set_declaration(SgDeclarationStatement * decl)
   { 
     //p_declptr = decl; 
     set_parent(decl);
   }
*/

void
SgInitializedName::set_definition(SgDeclarationStatement * def)
   { 
#if DEBUG_SAGE_ACCESS_FUNCTIONS
  // DQ (6/12/2007): New access function tests using DEBUG_SAGE_ACCESS_FUNCTIONS and 
  // DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION in sage3.h indicate this is required.
     if (get_declptr() != NULL)
        {
          printf ("Note: overwriting SgInitializedName::get_declptr() = %p with NULL before assignment to def = %p \n",get_declptr(),def);
          set_declptr(NULL);
        }
#endif

     set_declptr(def);
   }

bool
SgInitializedName::checkBit ( unsigned int bit ) const
   {
     assert (bit < e_last_gnu_variable_attribute);
  // return p_gnu_attribute_modifierVector[bit];
     return (p_gnu_attribute_modifierVector[bit] == true);
   }

void
SgInitializedName::setBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = true;
   }

void
SgInitializedName::unsetBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = false;
   }


// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__); }
void SgInitializedName::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__); }
void SgInitializedName::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__); }
void SgInitializedName::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__); }
void SgInitializedName::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__); }
void SgInitializedName::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__); }
void SgInitializedName::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeNoCommon() const { return checkBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::setGnuAttributeNoCommon()      { setBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::unsetGnuAttributeNoCommon()    { unsetBit(e_gnu_attribute__nocommon__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeTransparentUnion() const { return checkBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::setGnuAttributeTransparentUnion()      { setBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::unsetGnuAttributeTransparentUnion()    { unsetBit(e_gnu_attribute__transparent_union__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__); }
void SgInitializedName::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__); }
void SgInitializedName::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__); }

SOURCE_INITIALIZED_NAME_END


SOURCE_NAME_START

// Added to support assignments to string variables.
SgName::operator std::string () const
   {
     return p_char;
   }

// DQ (10/5/2007): We no longer need this!
// Definition of defaultName (use a default parameter)
// const SgName SgdefaultName("defaultName");

SgName::SgName()
   : p_char("")
   { }

unsigned int
SgName::get_length() const
   {
     assert(this != NULL);
     return p_char.size();
   }

SgName::SgName(const char * str): p_char(str ? str : "") {}

// DQ (9/9/2004): Added support for conversion of strings to SgName
// I always wanted this and it was a pain that it didn't exist previously!
SgName::SgName(const std::string & str): p_char(str) {}

SgName::SgName(const SgName& n): p_char(n.p_char) {}

// SgName::SgName(const char *str, int n): p_char(str, n) {} // get first n chars in the string

int
SgName::operator!=(const SgName& n1) const 
   {
     assert(this != NULL);
     return p_char != n1.p_char;
   }

int
SgName::operator==(const SgName& n1) const
   {
     assert(this != NULL);

     return p_char == n1.p_char;
   }

int
SgName::operator<(const SgName& n1) const
   {
     assert(this != NULL);

     return p_char < n1.p_char;
   }

bool
SgName::is_null(void) const
   {
     assert(this != NULL);
     return p_char.empty();
   }

void
SgName::replace_space(char t)
   {
     assert(this != NULL);

     int len = p_char.size();
     for(int i=0; i < len; i++)
        {
       // if last one
          if(p_char[i]==' ') 
             {
               if(i==len-1) 
                    p_char.resize(p_char.size() - 1);
                 else 
                    p_char[i]=t;
             }
        }
   }

SgName&
SgName::operator<<(const std::string& str)
   {
     assert (this != NULL);

     p_char += str;
     return *this;
   }

SgName
SgName::itoname(int val)
   {
     std::ostringstream os;
     os << val;
     return SgName(os.str());
   }

SgName&
SgName::operator<<(int val)
   {
     assert(this != NULL);

     SgName str = itoname(val);
     p_char += str.p_char;
     return *this;
   }

SgName&
SgName::operator=(const SgName& n1)
   { 
     assert(this != NULL);
     this->p_char = n1.p_char;
     return *this;
   }

SgName&
SgName::tail(int n) // keep string after n
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? "" : p_char.substr(n);
     return *this;
   }

SgName&
SgName::head(int n) // keep first n chars
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? p_char : p_char.substr(0, n);
     return *this;
   }

const char* SgName::str() const {
     assert(this != NULL);
  return p_char.c_str();
}

std::string&
SgName::getString()
   {
     assert(this != NULL);
     return p_char;
   }

const std::string&
SgName::getString() const
   {
     assert(this != NULL);
     return p_char;
   }


void SgName::display( const std::string& label ) const
   {
     assert(this != NULL);

     std::cout << label << ": " << p_char << "\n";
   }

// DQ (9/9/2004): friend function
SgName
operator+(const SgName & n1, const SgName & n2)
   {
     return SgName(n1.p_char + n2.p_char);
   }

// DQ (11/15/2004): Added to support general string operations (first used in the unparser)
SgName & 
SgName::operator+= (const SgName & n1)
   {
     assert(this != NULL);
     p_char += n1.p_char;
     return *this;
   }

SgName
SgName::assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName)
   {
  // DQ (22/2005): Neede to add global scope specifier to handle some pathological cases (see test2005_144.C).
  // DQ (9/9/2004): Supporting function for building qualified names (specialied string concatination)
  // Previous code caused "::" to be inserted too often (e.g. where scope->get_qualified_name() was empty, as in global scope)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();

  // DQ (9/9/2004): We can't assert this since "" evaluates to is_null() being true!
  // assert(scopeQualifiedName.is_null() == false);

     SgName returnName;
  // DQ (9/9/2004): So these are redundent tests! (which was pleasant news to me!)
  // if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName == "") )
     if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName.getString() == "") )
        {
          returnName = localName;
#if 0
       // DQ (11/29/2004): It seems that any assignment of "" to a SgName forces it to be evaluated so that is_null() == true
       // DQ (11/29/2004): Added checking for is_null() so that returnName would always be a valid name
          if (localName.is_null() == true)
               returnName = "";
            else
               returnName = localName;
#endif
        }
       else 
        {
       // Trap out the case of global scope to avoid building "::::"
          if ( scopeQualifiedName == "::" )
             {
            // Avoid building "::::"
               returnName = scopeQualifiedName.getString() + localName.getString();
             }
            else
             {
               returnName = scopeQualifiedName.getString() + "::" + localName.getString();
             }
        }

  // returnName = scopeQualifiedName << "::" << localName.str();
  // assert(returnName.is_null() == false);
      
     return returnName;
   }


SOURCE_NAME_END


SOURCE_QUALIFIED_NAME_START
SOURCE_QUALIFIED_NAME_END


SOURCE_ATTRIBUTE_START

int
SgAttribute::isSame(const std::string& str)
   {
     return p_name == str;
   }

SOURCE_ATTRIBUTE_END


SOURCE_BIT_ATTRIBUTE_START
SOURCE_BIT_ATTRIBUTE_END


SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START
SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END


SOURCE_CLASS_DECLARATION_ATTRIBUTE_START
SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


SOURCE_PRAGMA_START

std::string
SgPragma::get_pragma() const
   { return get_name(); }

bool
SgPragma::samePragma(const std::string& str)
   { return get_name() == str; }

bool
SgPragma::isPragma() const
   { return 1; }

bool
SgPragma::gotPrinted() const
   { return p_printed; }

void
SgPragma::setPrinted(bool s)
   { p_printed=s; }

void
SgPragma::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_printed = false;
   }

// DQ (11/6/2006): This is not generated due to the name change of "file_info" to "startOfConstruct" (uncommented)
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgPragma::get_file_info() const
   {
  // return p_fileInfo;
     return p_startOfConstruct;
   }

SOURCE_PRAGMA_END


SOURCE_FILE_INFORMATION_START

// int Sg_File_Info::p_cur_line ROSE_DEPRECATED_VARIABLE  = 0;
// std::string Sg_File_Info::p_cur_file  ROSE_DEPRECATED_VARIABLE = "";

// MK (7/22/05) : Added support for file ids. Here we initialize the static file maps, etc
// int Sg_File_Info::p_max_file_id = 0;
std::map<std::string, int> Sg_File_Info::p_nametofileid_map;
std::map<int, std::string> Sg_File_Info::p_fileidtoname_map;


// DQ (7/4/2005): Added to test internal consistancy
bool
Sg_File_Info::ok() const
   {
     assert(this != NULL);

  // DQ (10/22/2007): Are these reasonable constraints when #line n "" are used?
     bool lineNumberOK      = p_line > 0;
     bool columnNumberOK    = p_col  > 0;

  // MK (7/22/05) We compare using p_fileid instead of p_filename now
  // bool filenameOK        = p_filename != NULL;
     bool filenameOK        = p_file_id != NULL_FILE_ID;

  // A compiler generated node has no defined association with a file, line number, or column number.
     bool compilerGenerated = isCompilerGenerated();

  // DQ (11/22/2006): Some nodes have no source position information and we have the live with this at points in the processing.
  // A node which was explicitly marked as a sourcePositionUnavailableInFrontendcompiler has no defined association with a file, line number, or column number.
     bool sourcePositionUnavailableInFrontend = isSourcePositionUnavailableInFrontend();

  // DQ (12/23/2006): If this is part of a transformation then it is OK by definition.
  // A node introduced as part of a transformation has no defined association with a file, line number, or column number.
     bool transformation  = isTransformation();

  // return  compilerGenerated || (lineNumberOK && filenameOK);
  // return  sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && filenameOK);
  // return  transformation || sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && columnNumberOK && filenameOK);
     return  (lineNumberOK && columnNumberOK && filenameOK) || compilerGenerated || sourcePositionUnavailableInFrontend || transformation;
   }

void
Sg_File_Info::updateSourcePosition ( Sg_File_Info* update )
   {
  // DQ (12/22/2006): This copies the line number and column number information and verifies that 
  // the file name is the same (it does not reset any of the classification flags).  This is more
  // useful than the assignment operator for updating information and is used in the file:
  // fixupSourcePositionInformation.C.

     assert(update != NULL);

  // Must have matching file name (only have to compare file_id's)
     assert(p_file_id == update->p_file_id);

  // Update only the line number and column number after verifying that the filenames are the same.
     p_line = update->p_line;
     p_col  = update->p_col;
   }


// DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
// Static function to return new Sg_File_Info object set to default values
Sg_File_Info* Sg_File_Info::generateDefaultFileInfo()
   {
     Sg_File_Info* returnValue = new Sg_File_Info("NULL_FILE",0,0);
     assert(returnValue != NULL);

  // DQ (6/7/2007): This causes "NULL_FILE" filenames to be introduced into the AST.
  // Gergo pointed out this problems and removing such entries will simplify the tests
  // that are done in the traverseInputFile traversal.
  // printf ("Sg_File_Info::generateDefaultFileInfo(): This function is depricated and is an error to call! \n");
  // assert(false);

  // printf ("Calling Sg_File_Info::generateDefaultFileInfo(): returnValue = %p \n",returnValue);

     return returnValue;
   }

// Static function to return new Sg_File_Info object set to default values appropriate for transformations
// static Sg_File_Info* generateTransformationDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForTransformationNode()
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setTransformation();

  // DQ (1/11/2006): Added call to setOutputInCodeGeneration() because the default 
  // behavior is to output all transformations.  Other functions allow transformations 
  // to be specified that would not be output (useful for when including new header files).
     returnValue->setOutputInCodeGeneration();

     returnValue->set_file_id( TRANSFORMATION_FILE_ID );

     return returnValue;
   }

// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( int file_id )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_file_id( file_id );

     return returnValue;
   }

// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( string filename )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_filenameString( filename );

     return returnValue;
   }

// Static function to return new Sg_File_Info object set to default values appropriate for compiler generated code
// static Sg_File_Info* generateCompilerGeneratedDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode()
   {
  // IR nodes using this function's return value will be marked as compiler generated (but not output, unless also marked as such)
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setCompilerGenerated();

     returnValue->set_file_id( COMPILER_GENERATED_FILE_ID );

     return returnValue;
   }

// DQ (11/2/2006): Added operator= member function to simple assignment (used in fixupSourcePositionInformation.C
// to modify Sg_File_Info objects so that they better reflect the original source code).
Sg_File_Info &
Sg_File_Info::operator= ( const Sg_File_Info & X )
   {
     p_file_id                = X.p_file_id;
     p_line                   = X.p_line;
     p_col                    = X.p_col;
     p_classificationBitField = X.p_classificationBitField;
     p_fileIDsToUnparse       = X.p_fileIDsToUnparse;

  // Record that this source position information was updated.
     set_isModified(true);

     return *this;
   }

// DQ (9/26/2004): Added operator== friend function to permit testing of reused definitions of defining declarations!
bool
operator== ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool returnValue = false;

  // Make this most efficent by putting the least likely match first 
  // (col, line, file) and the most expensive test (file) last.
     if (X.get_col() == Y.get_col())
        {
          if (X.get_line() == Y.get_line())
             {
	       // MK (7/22/05) : Replaced string comparisons with file_id comparisons
	       /*
               if ( string(X.get_filename()) == string(Y.get_filename()))
                  {
                    returnValue = true;
                  }
	       */
               if (X.p_file_id == Y.p_file_id)
                  {
                    returnValue = true;
                  }
             }
        }

     return returnValue;
   }


// DQ (10/6/2004): Added operator!= friend function to permit testing of reused definitions of defining declarations!
bool
operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     return operator==(X,Y) ? false : true;
   }

// DQ (10/25/2004): Added relational operators to permit testing of strting vs. ending file info object (assert starting < ending)
bool
operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // printf ("In operator > (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // printf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // printf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
          if (X.p_line > Y.p_line)
             {
            // printf ("TRUE: X.p_line = %d > X.p_line = %d \n",X.p_line,X.p_line);
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col > Y.p_col)
                       {
                      // printf ("TRUE: X.p_col = %d > Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // printf ("Sorry operator> (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }

bool
operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // printf ("In operator < (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // printf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // printf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
          if (X.p_line < Y.p_line)
             {
            // printf ("TRUE: X.p_line = %d < Y.p_line = %d \n",X.p_line,Y.p_line);
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col < Y.p_col)
                       {
                      // printf ("TRUE: X.p_col = %d < Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // printf ("Sorry operator< (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }

bool
operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
          if (X.p_line > Y.p_line)
             {
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col >= Y.p_col)
                         result = true;
                  }
             }
        }

  // printf ("Sorry operator>= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }

bool
operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
          if (X.p_line < Y.p_line)
             {
               result = true;
             }
            else
             {
               if (X.p_line == Y.p_line)
                  {
                    if (X.p_col <= Y.p_col)
                         result = true;
                  }
             }
        }

  // printf ("Sorry operator<= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }

//Liao 4/16/2010. The default value for display(label) cannot be instantiated from gdb,
// which is very annoying during debugging. I added the empty parameter one to better support debugging.
void
Sg_File_Info::display( ) const
{
  display ("");
}

void
Sg_File_Info::display( const std::string label ) const
   {
     assert(this != NULL);

     printf ("Inside of Sg_File_Info::display(%s) \n",label.c_str());
     printf ("     isTransformation                      = %s \n",isTransformation()    == true ? "true (part of a transformation)" : "false");
     printf ("     isCompilerGenerated                   = %s \n",isCompilerGenerated() == true ? "true (no position information)" : "false");
     printf ("     isOutputInCodeGeneration              = %s \n",isOutputInCodeGeneration() == true ? "true (output in code generator)" : "false");
     printf ("     isShared                              = %s \n",isShared() == true ? "true (shared within merged AST)" : "false");
     printf ("     isFrontendSpecific                    = %s \n",isFrontendSpecific() == true ? "true (part of ROSE support for gnu compatability)" : "false");
     printf ("     isSourcePositionUnavailableInFrontend = %s \n",isSourcePositionUnavailableInFrontend() == true ? "true (source position unavailable in frontend)" : "false");
     printf ("     isCommentOrDirective                  = %s \n",isCommentOrDirective() == true ? "true (this is a comment or CPP directive)" : "false");
     printf ("     isToken                               = %s \n",isToken() == true ? "true (this is from the token stream woven into the AST)" : "false");

  // if (isCompilerGenerated() == false)
     if (!isTransformation() && !isCompilerGenerated())
        {
          printf ("     filename = %s \n",get_filename());
          printf ("     line     = %d  column = %d \n",get_line(),get_col());
        }

  // DQ (6/17/2005): Way to get extra debugging information, if the
  // substring "debug" is found then extra information is output
  // if (label == "debug")
     if (label.find("debug") != std::string::npos)
        {
          printf ("     file_id  = %d \n",get_file_id());
          printf ("     filename = %s \n",get_raw_filename().c_str());
          printf ("     line     = %d  column   = %d \n",p_line,p_col);
        }

  // DQ (5/16/2005): output these values, but I think they might be removed 
  // later since I don't see the point of storing this information!
  // printf ("     isDeclaration    = %s \n",isDeclaration()    == true ? "true" : "false");
  // printf ("     isInitialization = %s \n",isInitialization() == true ? "true" : "false");
   }

string
Sg_File_Info::displayString(const std::string & label ) const
   {
     assert(this != NULL);

     std::string s;
     s += std::string("Inside of Sg_File_Info::displayString(") + label + std::string (") \n");
     s += std::string("isTransformation    = ") + std::string(isTransformation()    ? "true" : "false") + std::string(" ");
     s += std::string("isCompilerGenerated = ") + std::string(isCompilerGenerated() ? "true" : "false") + std::string(" ");
     if (!isTransformation() && !isCompilerGenerated())
        {
          s += std::string("line number = ")   + StringUtility::numberToString(get_line()) + std::string(" ");
          s += std::string("column number = ") + StringUtility::numberToString(get_col())  + std::string(" ");
          s += std::string("filename = ")      + std::string(get_filename()) + std::string(" ");
        }

     return s;
   }

void
Sg_File_Info::display_static_data( const std::string label )
   {
  // DQ (6/11/2007): output static data for debugging

     printf ("Inside of Sg_File_Info::display_static_data(%s) \n",label.c_str());

     // printf ("p_cur_line = %d \n",p_cur_line);
     // printf ("p_cur_file = %s \n",p_cur_file.c_str());

     // printf ("p_max_file_id = %d \n",p_max_file_id);

     printf ("p_nametofileid_map: \n");
     for (std::map<std::string,int>::iterator i = p_nametofileid_map.begin(); i != p_nametofileid_map.end(); i++)
        {
          printf ("name = %s id = %d \n",i->first.c_str(),i->second);
        }

     printf ("p_fileidtoname_map: \n");
     for (std::map<int,std::string>::iterator i = p_fileidtoname_map.begin(); i != p_fileidtoname_map.end(); i++)
        {
          printf ("id = %d name = %s \n",i->first,i->second.c_str());
        }
   }

// Since we make the arguments in the other constructor 
// have default values this constructor is redundant/ambiguous
// Sg_File_Info::Sg_File_Info() {}

Sg_File_Info::Sg_File_Info ()
   {
     assert(this != NULL);

  // Default constructor used for making copies of subtrees
     p_line                   = 0;
     p_col                    = 0;
     p_classificationBitField = 0;

  // MK (7/22/05) : Initialize p_file_id to inidicate a copy
     p_file_id = COPY_FILE_ID;

#if 0
     printf ("Sg_File_Info default constructor = %p \n",this);
  // display("In constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

// DQ (4/19/2006): Added constructor to take std::string as part of move
// away from C style strings to C++ style strings.
Sg_File_Info::Sg_File_Info ( const std::string & filename, int line, int col )
   : p_line(line), p_col(col)
   {
     assert(this != NULL);

  // DQ (10/22/2007): Fixed to permit "" to be a valid filename
  // DQ (5/11/2006): Allow "NULL_FILE" as a name (used within ROSE) to map to the NULL_FILE_ID 
  // if (filename.empty() == true)
  // if (filename.empty() == true || filename == "NULL_FILE")
     if (filename == "NULL_FILE")
        {
          p_file_id = NULL_FILE_ID;
        }
       else 
        {
       // DQ (7/25/2005): Refactored to use set_filename()
          set_filenameString(filename);
        }

     p_classificationBitField = 0;

     assert (p_col >= 0);

#if 0
     printf ("Sg_File_Info constructor(const std::string,int,int) = %p \n",this);
  // display("In constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

// DQ (2/15/2003): added copy constructor
Sg_File_Info::Sg_File_Info(const Sg_File_Info & X)
   : p_file_id(X.p_file_id),
     p_line(X.p_line),
     p_col(X.p_col),
  // DQ (7/29/2005): Preserve IR node classification within copy constructor
  // p_classificationBitField(0)
     p_classificationBitField(X.p_classificationBitField),
     p_fileIDsToUnparse(X.p_fileIDsToUnparse)
   {
     assert(this != NULL);

     assert (p_col >= 0);

#if 0
     printf ("Sg_File_Info copy constructor(const Sg_File_Info) = %p \n",this);
  // display("In copy constructor");
#endif

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

#if 0
// This is now removed but saved becuase it might be that it should be depricated for a while
Sg_File_Info::Sg_File_Info ( const char* filename, int line, int col )
   : p_line(line), p_col(col) // , p_isPartOfTransformation(false)
   {
     assert(this != NULL);

     if (!filename) {
          p_file_id = NULL_FILE_ID;
        }
       else 
        {
       // DQ (7/25/2005): Refactored to use set_filename()
          set_filename(filename);
        }

     p_classificationBitField = 0;

     if (p_col < 0)
        {
          printf ("Error p_col = %d \n",p_col);
        }
     assert (p_col >= 0);

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }
#endif

// DQ (11/6/2008): added constructor to support building objects from Dwarf 
// information (which uses a pre-resolved integer file_id instead of a string)
Sg_File_Info::Sg_File_Info( int file_id, int line, int column )
   : p_file_id(file_id),
     p_line(line),
     p_col(column),
     p_classificationBitField(0)
   {
     assert(this != NULL);

     assert (p_col >= 0);

  // Provide a common function called for initialization support.
     post_construction_initialization();
   }

void
Sg_File_Info::post_construction_initialization()
   {
     assert (this != NULL);
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // assert(this != (Sg_File_Info*) 0x5231b0);
   }


int 
Sg_File_Info::get_file_id () const
   {
  // DQ (10/27/2007): This is custom generated so that it can be consistant with the get_filename() member function
     assert (this != NULL);
  // return p_file_id;

  // initialize to bad value
     int returnValue = -99;

     if (isTransformation() == true)
        {
       // returnValue = undefinedValue;
          returnValue = TRANSFORMATION_FILE_ID;
        }
       else
        {
#if 1
       // DQ (11/1/2007): This does not allow for isSameFile() to compare properly when testing for "rose_edg_required_macros_and_functions.h"
          if ( isCompilerGenerated() == true )
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the file_id of the associated file ("rose_edg_required_macros_and_functions.h")
            // returnValue = undefinedValue;
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the file_id of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnValue = p_file_id;
                  }
                 else
                  {
                    returnValue = COMPILER_GENERATED_FILE_ID;
                  }
             }
            else
             {
               returnValue = p_file_id;
             }
#else
       // Older (previous) code
          if ( isCompilerGenerated() == true )
             {
            // returnValue = undefinedValue;
               returnValue = COMPILER_GENERATED_FILE_ID;
             }
            else
             {
               returnValue = p_file_id;
             }
#endif
        }

     return returnValue;
   }

void
Sg_File_Info::set_file_id ( int file_id )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_file_id = file_id;
   }

int
Sg_File_Info::numberOfSourceFiles()
   {
     return p_nametofileid_map.size();
   }

int
Sg_File_Info::addFilenameToMap ( const std::string & filename )
   {
  // DQ (11/6/2008): Added support for extending the internal static filename to integer id map.
  // This static function is used the the Dwarf support to convert filenames to integer values and 
  // maintain a map similar to the Dwarf mapping of integers to filenames as a way to save space
  // in the represnetation of source position mappings of the instructions in the binary.

     int returnValue = 0;
     if (p_nametofileid_map.count(filename) == 0)
        {
          returnValue = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = returnValue;
          p_fileidtoname_map[returnValue] = filename;
        }
       else
        {
          returnValue = p_nametofileid_map[filename];
        }

     return returnValue;
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filename(const char* filename)
Sg_File_Info::set_filenameString ( const std::string & filename )
   {
     assert (this != NULL);

     if (p_nametofileid_map.count(filename) == 0)
        {
          p_file_id = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = p_file_id;
          p_fileidtoname_map[p_file_id] = filename;
        }
       else
        {
          p_file_id = p_nametofileid_map[filename];
        }

  // DQ (8/31/2006): We can't enforce that this is an absolute path (test2001_04.C and test2004_60.C demonstrate why).
  // DQ (8/31/2006): Verify that this is a absolute path
  // string targetSubstring = "/";
  // string filenameString  = filename;
  // if (filenameString.substr(0,targetSubstring.size()) != targetSubstring)
  //      printf ("@@@@@@@@@@@@@@@@@@@@ In Sg_File_Info::Sg_File_Info(string,int,int): filename = %s @@@@@@@@@@@@@@@@@@@@\n",filenameString.c_str());
  // assert(filenameString.substr(0,targetSubstring.size()) == targetSubstring);

  // Detect use of AST Rewrite intermediate files (need to make sure they get absolute paths)
  // string targetSubstring2 = "rose_";
  // assert(filenameString.substr(0,targetSubstring2.size()) != targetSubstring2);
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filenameString ( const std::string & filename )
Sg_File_Info::set_filename(const char* filename)
   {
  // DQ (9/5/2006): Modified implementation
  // set_filename(filename.c_str());
     assert(filename != NULL);
     set_filenameString(filename);
   }

const std::string &
Sg_File_Info::get_filenameString() const
   {
     assert (this != NULL);
  // return p_filename;

     const std::string* returnString = NULL;

     if (isTransformation() == true)
        {
#if PRINT_DEVELOPER_WARNINGS
       // DQ (2/25/2006): Unclear how often we want to have this output, it is sometimes useful and sometime annoying.
          printf ("Sg_File_Info::get_filename called for transformation IR node \n");
#endif
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
       else
        {
          if (isCompilerGenerated() == true)
             {
#if 0
            // DQ (8/17/2005): only "compilergenerated" when compiler generate (not when marked for output)
            // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
            // printf ("Sg_File_Info::get_filename called for compiler generated IR node \n");
               static const std::string compilerGenerated_string = "compilerGenerated";
               returnString = &compilerGenerated_string;
#else
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the filename of the associated file ("rose_edg_required_macros_and_functions.h")
            // This has been fixed to be consistant with the implementation of get_file_id().
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the filename of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnString = &getFilenameFromID(p_file_id);
                  }
                 else
                  {
                    static const std::string compilerGenerated_string = "compilerGenerated";
                    returnString = &compilerGenerated_string;
                  }
#endif
             }
            else
             {
#if 0
               const char * tmp = getFilenameFromID(p_file_id).c_str();
               int length = strlen(tmp) + 1;
               returnString = new char[length];
               strncpy(returnString, tmp, length);
#endif
               returnString = &getFilenameFromID(p_file_id);
             }
        }

     assert (returnString != NULL);
     return *returnString;
   }

const char*
Sg_File_Info::get_filename() const
   {
  // DQ (10/15/2005): This function is the C++ string version of the get_filename() 
  // function which has been depricated. At some point the get_filename() function 
  // will be eliminated and later reinfroduced as get_filename() (finally returning 
  // a C++ string instead of a char* (C style string)).
     return get_filenameString().c_str();
   }

string
Sg_File_Info::get_raw_filename() const
   {
     assert (this != NULL);

  // return whatever name is in the map
     return getFilenameFromID(p_file_id);
   }

void
Sg_File_Info::set_line(int line)
   {
     assert (this != NULL);
     p_line = line;
   }

int
Sg_File_Info::get_line() const
   { 
     assert (this != NULL);
  // return p_line;
  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // printf ("Sg_File_Info::get_line called for transformation IR node (p_line = %d) \n",p_line);
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // printf ("Sg_File_Info::get_line called for compiler generated IR node (p_line = %d) \n",p_line);

            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
            // returnValue = undefinedValue;
            // returnValue = p_line;
               returnValue = undefinedValue;
             }
            else
             {
               returnValue = p_line;
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_line() const
   { 
     assert (this != NULL);
     return p_line;
   }

int
Sg_File_Info::get_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
  // return p_col;

  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // printf ("Sg_File_Info::get_col called for transformation IR node \n");
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // printf ("Sg_File_Info::get_col called for compiler generated IR node \n");
               returnValue = undefinedValue;
             }
            else
             {
               returnValue = p_col;
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
     return p_col;
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
void
Sg_File_Info::set_isPartOfTransformation( bool isPartOfTransformation )
   {
     assert (this != NULL);
  // p_isPartOfTransformation = isPartOfTransformation;

     if (isPartOfTransformation == true)
          setTransformation();
       else
          unsetTransformation();
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
bool
Sg_File_Info::get_isPartOfTransformation()
   {
     assert (this != NULL);
  // return p_isPartOfTransformation;
     return isTransformation();
   }

void
Sg_File_Info::register_node(SgLocatedNode* node)
   {} /* register interest */

void
Sg_File_Info::deregister_node(SgLocatedNode* node)
   {}

// functions added by Dan Quinlan (suggested by Gary Lee)
void
Sg_File_Info::set_col( int n )
   {
     assert (this != NULL);
     p_col = n;
     assert (p_col >= 0);
   }

#if 0
int
Sg_File_Info::getCurrentLine () const
   { 
     assert (this != NULL);
     printf ("This is a depricated function: char* Sg_File_Info::getCurrentLine() const \n");
     return p_cur_line;
   }

std::string
Sg_File_Info::getCurrentFilename () const
   {
     assert (this != NULL);
     printf ("This is a depricated function: char* Sg_File_Info::getCurrentFilename() const \n");
     return p_cur_file;
   }
#endif

bool
Sg_File_Info::hasPositionInSource() const
   {
     assert(this != NULL);

  // DQ (1/11/2006): Modified to not use the output function which mixed 
  // concepts of compiler generated with output (deprecated function).
  // bool result = ( ! ( isTransformation() || isCompilerGenerated() || isCompilerGeneratedNodeToBeUnparsed() ) );
     bool result = ( ! ( isTransformation() || isCompilerGenerated() || isOutputInCodeGeneration() ) );
     return result;
   }

// DQ (9/5/2008): Switched back to using SgFile instead of SgSourceFile.
// bool Sg_File_Info::isSameFile(SgFile* file) const
// bool Sg_File_Info::isSameFile(SgSourceFile* file) const
bool
Sg_File_Info::isSameFile(SgFile* file) const
   {
  // DQ (6/21/2005): check if this file info object is from the same file

  // This function abstracts the mechanism of comparing if a file info object is associated with a specific SgFile.
  // this function will be made more efficient later when we can abstract out the string comparision from the test.
  // Later we will implement a map from filename to unique "file number identifiers", this will permit significant
  // spaces saving in the IR by avoiding redundant storage of filename strings and also improve the efficiency of 
  // testing if two file info objects represent the same file (an integer equality test instead of string comparision).
  // File names are particularly long (since they include full path), so this will allow us to save a lot of space.

     assert(this != NULL);

     assert(file != NULL);

  // MK (7/22/05) : removing use of p_filename in favor of p_file_id
  // Generate names of the files 
     /*
     string inputFilename = file->getFileName();
     string currentFilename = get_filename();

     bool result = (currentFilename == inputFilename);
     */
#if 0
     SgScopeStatement * globalScope = (SgScopeStatement *)(file->get_root());
     assert(globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
#else
  // DQ (9/5/2008): Use the local Sg_File_Info instead of the one on the root (which is only available for a SgSourceFile)
     Sg_File_Info* fileInfo = file->get_startOfConstruct();
#endif
     assert(fileInfo != NULL);

  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo->get_file_id());
     bool result = (this->get_file_id() == fileInfo->get_file_id());
     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(Sg_File_Info* fileInfo) const
   {
     assert(fileInfo != NULL);

  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo->get_file_id());
     bool result = (this->get_file_id() == fileInfo->get_file_id());
     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(const Sg_File_Info & fileInfo) const
   {
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo.get_file_id());
     bool result = (this->get_file_id() == fileInfo.get_file_id());
     return result;
   }

//! Access functions for classification of File_Info objects
bool
Sg_File_Info::isTransformation() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_transformation);
   }

void
Sg_File_Info::setTransformation()
   {
     assert(this != NULL);
     p_classificationBitField |= e_transformation;
   }

void
Sg_File_Info::unsetTransformation()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_transformation;
   }

bool
Sg_File_Info::isCompilerGenerated() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_compiler_generated);
   }

void
Sg_File_Info::setCompilerGenerated()
   {
     assert(this != NULL);
     p_classificationBitField |= e_compiler_generated;
   }

void
Sg_File_Info::unsetCompilerGenerated()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_compiler_generated;
   }

// bool isCompilerGeneratedNodeToBeUnparsed() const;
bool
Sg_File_Info::isCompilerGeneratedNodeToBeUnparsed() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);

#if 0
  // DQ (6/17/2005): Allow these to be set separately so that setting a whole function to 
  // be unparsed will not make any expecific casts as compiler generated and not required!
  // If casts are the only issue then perhaps they should be marked explicitly as implicit 
  // or explicit (rather than compiler generated).
     bool result = (p_classificationBitField & e_output_in_code_generation);

  // error checking: if e_compiler_generated_node_to_be_unparsed then also e_compiler_generated
     if (result == true)
          assert(isCompilerGenerated() == true);

     return result;
#endif
   }

void
Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);
     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetCompilerGeneratedNodeToBeUnparsed()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation; 
   }

bool
Sg_File_Info::isOutputInCodeGeneration() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);
   }

void
Sg_File_Info::setOutputInCodeGeneration()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);
     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetOutputInCodeGeneration()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation;
   }

bool
Sg_File_Info::isShared() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_shared);
   }

void
Sg_File_Info::setShared()
   {
  // MK (8/3/05) : We always want to unparse the current file (this is a performance issue)
     assert(this != NULL);

  // DQ (10/27/2007): Make sure this is a valid file that we are trying to share.
  // I am unclear as to how important this is.
     int temp_file_id = this->get_file_id();
     if (temp_file_id < 0)
        {
          if (SgProject::get_verbose() > 0)
               printf ("Warning: trying to share file id = %d < 0 \n",temp_file_id);
        }

     if (isShared() == false)
        {
          p_fileIDsToUnparse.push_back(p_file_id);
        }

     p_classificationBitField |= e_shared;
   }

void
Sg_File_Info::unsetShared()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_shared;

  // MK (8/2/05) : Initialize the fileid set
     p_fileIDsToUnparse.clear();
   }

bool
Sg_File_Info::isFrontendSpecific() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_frontend_specific);
   }

void
Sg_File_Info::setFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField |= e_frontend_specific;
   }

void
Sg_File_Info::unsetFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_frontend_specific;
   }

bool
Sg_File_Info::isSourcePositionUnavailableInFrontend() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_source_position_unavailable_in_frontend);
   }

void
Sg_File_Info::setSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField |= e_source_position_unavailable_in_frontend;
   }

void
Sg_File_Info::unsetSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_source_position_unavailable_in_frontend;
   }

bool
Sg_File_Info::isCommentOrDirective() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_comment_or_directive);
   }

void
Sg_File_Info::setCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField |= e_comment_or_directive;
   }

void
Sg_File_Info::unsetCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_comment_or_directive;
   }

bool
Sg_File_Info::isToken() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_token);
   }

void
Sg_File_Info::setToken()
   {
     assert(this != NULL);
     p_classificationBitField |= e_token;
   }

void
Sg_File_Info::unsetToken()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_token;
   }

// MK (8/2/05) : Implementation for function to handle unparsing of particular files
void
Sg_File_Info::addFileToUnparse(int file_id)
   { 
     assert(this != NULL);
     p_fileIDsToUnparse.push_back(file_id);
   }

bool
Sg_File_Info::shouldUnparse(int file_id)
   {
     assert(this != NULL);
     return std::find(p_fileIDsToUnparse.begin(), p_fileIDsToUnparse.end(), file_id) != p_fileIDsToUnparse.end();
   }

unsigned int
Sg_File_Info::get_classificationBitField(void) const
   {
     assert(this != NULL);
     return p_classificationBitField;
   }

void
Sg_File_Info::set_classificationBitField( unsigned int bitflags )
   {
     assert(this != NULL);
     p_classificationBitField = bitflags;
   }

// MK (8/2/05): Added implementations for static functions to support interface to fileid maps
const string&
Sg_File_Info::getFilenameFromID(int id)
   {
  // This is a static function

     const std::string* name = NULL;
     switch(id)
        {
       // special cases
          case NULL_FILE_ID:
             {
               static const std::string null_file_string =  "NULL_FILE";
               name = &null_file_string;
               break;
             }
          case COPY_FILE_ID:
             {
               static const std::string copy_file_string  = "COPY";
               name = &copy_file_string;
               break;
             }
          case TRANSFORMATION_FILE_ID:
             {
               static const std::string transformation_string = "transformation";
               name = &transformation_string;
               break;
             }
          case COMPILER_GENERATED_FILE_ID:
             {
               static const std::string compilerGenerated_string = "compilerGenerated";
               name = &compilerGenerated_string;
               break;
             }
          case COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID:
             {
            // name = "compilerGenerated";
               printf ("The concept of COMPILER_GENERATED and OUTPUT are now decoupled, so make this an error \n");
               assert(false);
               break;
             }
          case BAD_FILE_ID:
             {
               static const std::string badfile_string = "badfile";
               name = &badfile_string;
               break;
             }

       // normal case
          default:
             {
            // assert that the id is present in the map (else error)
            // assert(p_fileidtoname_map.count(id) != 0);
               bool failure = (p_fileidtoname_map.count(id) == 0);
               if (failure == true)
                  {
                    printf ("Error: bad id number for file id (id = %d) \n",id);

                    display_static_data("error in getFilenameFromID");

                 // Note: this causes an empty entry to be generated in p_fileidtoname_map for the id == p_max_file_id (value of max map size)
                 // std::cout << p_fileidtoname_map[id] << std::endl;
                 // printf ("Error: bad id number for file id (id = %d) \n",id);
                  }
               assert(failure == false);

            // get the filename from the map using the valid id
               name = &p_fileidtoname_map[id];
             }
        }

     return *name;
   }

int
Sg_File_Info::getIDFromFilename( std::string filename )
   {
  // This is a static function

#if 1
  // DQ (10/22/2007): Should this be commented out?

     if (p_nametofileid_map.count(filename) == 0)
        {
          return BAD_FILE_ID;
        }
#endif

     return p_nametofileid_map[filename];
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<int, std::string> & 
Sg_File_Info::get_fileidtoname_map()
   {
     return p_fileidtoname_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_fileidtoname_map(std::map<int, std::string> & X)
   {
     p_fileidtoname_map = X;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<std::string, int> &
Sg_File_Info::get_nametofileid_map()
   {
     return p_nametofileid_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_nametofileid_map(std::map<std::string,int> & X)
   {
     p_nametofileid_map = X;
   }

SOURCE_FILE_INFORMATION_END


SOURCE_APPLICATION_FILE_START

int SgFile::buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine )
   {
     printf ("Base class of virtual function, SgFile::buildAST(), called by mistake! \n");
     assert(false);
     // tps (12/11/2009): Windows error : needs a return value
     return 0;
   }

#if 0
// DQ (2/5/2009): This is a data member in both the SgProject (records the command line setting, and the SgFile
// (specifies file type). So we don't need this member function from yesterday.
// DQ (2/4/2009): This is now a data member at the SgProject and so is automatically generated asa member function.
bool
SgFile::get_binary_only (void) const
   {
     SgProject* project = isSgProject(get_parent());
     assert(project != NULL);
     return project->get_binary_only();
   }
#endif

Sg_File_Info*
SgFile::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgFile::set_file_info( Sg_File_Info* fileinfo )
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode 
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     set_startOfConstruct(fileinfo);
   }

std::string
SgFile::getFileName () const
   {
  // Get the filename from the Sage III file object

     assert(this != NULL);

  // assert(get_fileInfo() != NULL);
#if 0
  // DQ (9/4/2008): Moved the global scope to the new SgSourceFile IR node.
     SgScopeStatement *globalScope = (SgScopeStatement *)(&(root()));
     assert (globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
#else
     Sg_File_Info* fileInfo = p_startOfConstruct;
#endif
     assert (fileInfo != NULL);
     std::string fileName = fileInfo->get_filenameString();
     return fileName;
   }

// function prototype
ROSEAttributesListPtr getPreprocessorDirectives( char *fileName);

// DQ (2/3/2004): Debugging segfault in use of il_header within ROSE
// #include "sageCommonSourceHeader.h"
// extern an_il_header il_header;

// Moved to sageSupport.C: void SgFile::setupSourceFilename ( const vector<string>& argv )
// Moved to sageSupport.C: void SgFile::doSetupForConstructor(const vector<string>& argv, int& errorCode, int fileNameIndex, SgProject* project)

SgFile::SgFile ( int & argc, char** & argv , SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     assert (argv && argc >= 0);

  // Note use of pointer arithmetic in the computation of "argv + argc", this is standard STL fair.
     doSetupForConstructor(vector<string>(argv, argv + argc),  project);
   }

SgFile::SgFile ( vector<string> & argv ,  SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     doSetupForConstructor(argv,  project);
   }


// DQ (1/17/2006): Added this (copy constructor) to be explicit 
// and avoid difficult bugs where it is compiler generated.
SgFile::SgFile ( const SgFile & X )
   {
     printf ("Error: calling private copy constructor! \n");
     assert(false);
   }

#include "Disassembler.h"

void
SgFile::initialization()
   {
     assert(this != NULL);

  // This should use a Sg_File_Info with the correct name (maybe this 
  // should be initialized by "callFrontEnd()")
  // Sg_File_Info* fileInfo = new Sg_File_Info("SgFile file unknown",0,0);

  // DQ (1/17/2006): Initialize the local file info pointer (this was not previously set!)
  // the name will be reset to the file name later in the construction of the SgFile.
  // set_file_info(new Sg_File_Info (*fileInfo));

  // DQ (12/23/3006): Let the fileInfo be initialized with line 1, column 1 (instead of 
  // line 0, column 0). This avoids it failing the test for a valid Sg_File_Info object 
  // later (e.g. in fixupSourcePositionInformation.C).
  // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
  // enforce that the filename is always an absolute path (starting with "/").
  // Sg_File_Info* fileInfo = new Sg_File_Info("SgFile::SgFile",0,0);
  // Sg_File_Info* fileInfo = new Sg_File_Info("",0,0);

#if 0
  // DQ (12/23/2008): Build this later when we have a valid filename.
     Sg_File_Info* fileInfo = new Sg_File_Info("",1,1);
     assert(fileInfo != NULL);

  // set_file_info(fileInfo);
     set_startOfConstruct(fileInfo);
     fileInfo->set_parent(this);
     assert(get_startOfConstruct() != NULL);
     assert(get_file_info() != NULL);
#endif

  // DQ (9/4/2008): This is now part of the SgSourceFile
  // assert (p_root == NULL);


#if 0
  // DQ (12/23/2008): Build this later when we have a valid filename.

  // DQ (9/5/2008): This part needs to be rewritten, this is temporary code!
     SgSourceFile* sourceFile = const_cast<SgSourceFile*>(isSgSourceFile(this));
     if (sourceFile != NULL)
        {
       // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
       // enforce that the filename is always an absolute path (starting with "/").
       // Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("SgGlobal::SgGlobal",0,0);
          Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("",0,0);
          assert (globalScopeFileInfo != NULL);

          printf ("@@@@@@@@ In SgFile::initialization(): Building SgGlobal (with empty filename) @@@@@@@@@ \n");

          sourceFile->set_globalScope( new SgGlobal( globalScopeFileInfo ) );
          assert (sourceFile->get_globalScope() != NULL);

       // DQ (2/15/2006): Set the parent of the SgGlobal IR node
          sourceFile->get_globalScope()->set_parent(this);

       // DQ (8/21/2008): Set the end of the global scope (even if it is updated later)
       // printf ("In SgFile::initialization(): p_root->get_endOfConstruct() = %p \n",p_root->get_endOfConstruct());
          assert(sourceFile->get_globalScope()->get_endOfConstruct() == NULL);
          sourceFile->get_globalScope()->set_endOfConstruct(new Sg_File_Info("",0,0));
          assert(sourceFile->get_globalScope()->get_endOfConstruct() != NULL);
        }
#endif

  // DQ (10/16/2005): Removed as part of cleanup to SgFile
  // DQ (12/6/2003): initialize these here.
  // p_defaultNumberOfCommandLineArguments = 0;
  // p_defaultCommandLineArgumentList      = NULL;

  // DQ (7/13/2004): Not previously initialized (except through constructor preinitialization list)
  // I have removed them from the constructor preinitialization list so that ALL local member data
  // could be set in this inialization function!
  // p_numberOfCommandLineArguments = 0;
  // p_commandLineArgumentList      = NULL;

  // DQ (10/15/2005): Don't have a default for this (use an empty string)!
  // p_unparse_output_filename = "rose_unparse.C";

     p_verbose                 = 0;
  // version                   = false;
  // help                      = false;

  // DQ (12/8/2007): use "-Wall" to control output of warnings
     p_output_warnings         = false;

  // DQ (7/13/2004): Not previously initialized!
     p_C_only                  = false;
     p_UPC_only                = false;
     p_upc_threads             = 0;
     p_C99_only                = false;
     p_Cxx_only                = false;

  // DQ (8/11/2007): Added support for Fortran
     p_Fortran_only            = false;
     p_F77_only                = false;
     p_F90_only                = false;
     p_F95_only                = false;
     p_F2003_only              = false;

  // DQ (1/23/2009): Added CoArray Fortran support.
     p_CoArrayFortran_only     = false;

     p_PHP_only                = false;

     p_requires_C_preprocessor = false;

  // DQ (2/5/2009): Putting this back now, so we have one at the SgProject and one at the SgFile.
  // DQ (2/4/2009): This was moved to the SgProject
     p_binary_only             = false;

  // DQ (2/5/2009): Support binary analysis of object files.
     p_isObjectFile            = false;

     p_inputFormat             = SgFile::e_unknown_output_format;
     p_outputFormat            = SgFile::e_unknown_output_format;
     p_backendCompileFormat    = SgFile::e_unknown_output_format;
     p_fortran_implicit_none   = false;
     p_openmp                  = false;
     p_openmp_parse_only       = true;
     p_openmp_ast_only         = false;
     p_openmp_lowering         = false;

  // DQ (12/8/2007): Added commandline support for cray pointers.
     p_cray_pointer_support = false;

  // DQ (12/11/2007): Added to support debugging of Fortran support in ROSE using OFP.
     p_output_parser_actions = false;

  // DQ (12/11/2007): Added to support debugging of Fortran support in ROSE using OFP.
     p_exit_after_parser = false;

  // DQ (1/4/2008): gFortran versions greater than 4.1 have bugs that prevent it from 
  // being used to to syntax checking on Fortran 2003 applications.  To allow Fortran
  // 2003 applications to be processed the syntax checking step done in ROSE using
  // that backend compiler (typically gfortran) needs to be skipped.  ROSE it self can
  // handle the Fortran 2003 code, but can not yet do sufficent syntax checking to
  // report errors in illegal Fortran 2003 code.
     p_skip_syntax_check = false;

  // After higher level ASTs are build optionally apply transformations
     p_skip_transformation     = false;
     p_skip_unparse            = false;

#if 1
  // The default should be to act like a C++ compiler
     p_skipfinalCompileStep    = false;
#else
     p_skipfinalCompileStep    = true;
#endif

  // p_new_unparser            = true;   // by default use the new unparser
     p_unparse_includes        = false;  // by default do NOT unparse include files into the source code
     p_unparse_line_directives = false;  // by default do NOT unparse #line directives into the source code

  // DQ (8/30/2008): Added support to tailor the unparsing of disassembled instructions and the binary file format.
     p_unparse_instruction_addresses = true;
     p_unparse_raw_memory_contents   = true;
     p_unparse_binary_file_format    = true;

  // DQ (8/27/2007): Support for alternative langauge code generation (unparsing), useful for testing specific language unparsers.
     p_outputLanguage          = SgFile::e_default_output_language;

#if 0
// Order of data member entries in support.C, matched against the 
// initialization to make sure that all data members are initialized.
X startOfConstruct
X root
X verbose
X output_warnings
X C_only
X UPC_only
X upc_threads
X C99_only
X Cxx_only
X Fortran_only
X F77_only
X F90_only
X F95_only
X F2003_only
X PHP_only
X requires_C_preprocessor
X binary_only
X inputFormat
X outputFormat
X backendCompileFormat
X fortran_implicit_none
X fortran_openmp
X cray_pointer_support
X output_parser_actions
X exit_after_parser
X skip_syntax_check
X skip_transformation
X skip_unparse
X skipfinalCompileStep
X unparse_includes
X unparse_line_directives
X unparse_instruction_addresses
X unparse_raw_memory_contents
X unparse_binary_file_format
X outputLanguage
STRING  sourceFileNameWithPath
STRING  sourceFileNameWithoutPath
STRING  unparse_output_filename
X useBackendOnly
X compileOnly
STRING  savedEdgCommandLine
X no_implicit_templates
X no_implicit_inline_templates
X skip_commentsAndDirectives
X collectAllCommentsAndDirectives
X preprocessorDirectivesAndCommentsList
X attributeMechanism
X KCC_frontend
X new_frontend
X disable_edg_backend
X disable_sage_backend
X testingLevel
X preinit_il
X enable_cp_backend
// X outputGrammarTreeFiles
// X outputGrammarTreeFilesForHeaderFiles
// X outputGrammarTreeFilesForEDG
X markGeneratedFiles
X negative_test
X strict_language_handling
X embedColorCodesInGeneratedCode
X generateSourcePositionCodes
X sourceFileUsesCppFileExtension
X sourceFileUsesFortranFileExtension
X sourceFileUsesFortran77FileExtension
X sourceFileUsesFortran90FileExtension
X sourceFileUsesFortran95FileExtension
X sourceFileUsesPHPFileExtension
X sourceFileUsesBinaryFileExtension
X binaryFile
X read_executable_file_format_only
X read_instructions_only
X aggressive
#endif

  // initialize p_useBackendOnly data member
     p_useBackendOnly = false;

     p_compileOnly             = false;

  // DQ (6/21/2005): initialize g++ specific template instantiation control flags
     p_no_implicit_templates        = false;
     p_no_implicit_inline_templates = false;

  // Added to permit all comments and CPP directives to be skipped (e.g. when unparsing all hearders)
     p_skip_commentsAndDirectives      = false;

  // DQ (4/19/2006): Added to control comment and directive handling (takes more time to process header files).
     p_collectAllCommentsAndDirectives = false;

  // DQ (4/7/2001) Added support for multiple files (save the preprocessor 
  //               directives and comments into the SgFile)
  //               the ROSEAttributesListContainer represents all preprocessor 
  //               declarations and comments from each source file (and its 
  //               corresponding include files) (thus a list of lists of lists 
  //               of cpp directives and comments!!!)

  // At construction this is a NULL pointer, it is updated later after construction of the AST.
     p_preprocessorDirectivesAndCommentsList = NULL; // new ROSEAttributesListContainer();
  // assert (p_preprocessorDirectivesAndCommentsList != NULL);
     assert (p_preprocessorDirectivesAndCommentsList == NULL);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/13/2006): Initialize new AstAttributeMechanism pointer (moved from SgNode)
     p_attributeMechanism = NULL;

     p_KCC_frontend            = false;

  // Alternatively we can call the new edg frontend to test the edg process
     p_new_frontend            = false;

  // controls call to the edg_main (disables all processing
  // and acts like a shell which calls the compiler)
     p_disable_edg_backend     = false;

  // Disable parsing of the EDG program tree into the SAGE program tree
     p_disable_sage_backend    = false;

  // Shorthand form for different levels of testing  (default is -1)
     p_testingLevel            = -1;

  // enable processing specific to templates
     p_preinit_il              = false;
     p_enable_cp_backend       = false;

  // p_outputGrammarTreeFiles  = false;  // default should be false (set to true while debugging)
  // p_outputGrammarTreeFilesForHeaderFiles = false; // default is to skip headers

  // Support for faster processing of pdf output (where we likely don't need the pdf output of the the EDG AST)
  // p_outputGrammarTreeFilesForEDG = false;

  // DQ (9/5/2006): Added mechanism to optionally watermark files generated by ROSE
     p_markGeneratedFiles = false;

  // DQ (9/19/2006): Allow testing of ROSE using input that is expected to fail (return passed if test failed)
     p_negative_test = false;

  // DQ (9/24/2006): Permit optional enforcement of ANSI standards
     p_strict_language_handling = false;
     
  // AS (9/29/2008): Use Wave 
     p_wave = false;

  // DQ (10/31/2006): Output information that can be used to colorize properties of generated code (useful for debugging).
     p_embedColorCodesInGeneratedCode = 0;

  // DQ (10/31/2006): Output separate file containing source position information for highlighting (useful for debugging).
     p_generateSourcePositionCodes = 0;

  // DQ (12/2/2006): This we be used (as in GNU) to set the languge mode (C++ files will turn on C++ language mode 
  // and only ".c" (C files) will turn on C language mode).
     p_sourceFileUsesCppFileExtension = false;

  // DQ (12/11/2007): Added default initialization of these values
     p_sourceFileUsesFortranFileExtension     = false;
     p_sourceFileUsesFortran77FileExtension   = false;
     p_sourceFileUsesFortran90FileExtension   = false;
     p_sourceFileUsesFortran95FileExtension   = false;
     p_sourceFileUsesFortran2003FileExtension = false;

  // DQ (1/23/2009): Added support for Co-Array Fortran (file extensions)
     p_sourceFileUsesCoArrayFortranFileExtension = false;     

     p_sourceFileUsesPHPFileExtension = false;

     p_sourceFileUsesBinaryFileExtension = false;

  // This will cause only the binary file format to be read and skipps instruction disassembly
     p_read_executable_file_format_only = false;

  // DQ (11/11/2008): Added to support visualization of only parts of the AST.
  // this will cause attributes to be added to IR nodes that will be skipped 
  // in the generation of DOT files.  This is helpful for debugging and in 
  // tutorial examples/presentations.
     p_visualize_executable_file_format_skip_symbols = false;

     p_visualize_dwarf_only      = false;
     p_skip_unparse_asm_commands = false;
     p_read_instructions_only    = false;

     p_disassemblerSearchHeuristics = Disassembler::SEARCH_DEFAULT;

   }

#if 0
// DQ (9/4/2008): This is now in SgSourceFile (and built using ROSETTA with a different name)
SgGlobal &
SgFile::root() ROSE_DEPRECATED_FUNCTION
   {
     assert(p_root != NULL);
     return *p_root;
   }
#endif

#if 0
// DQ (7/19/2005): Added to support better naming of global scope (root is not very clear)
// get_root() set_root() and root() will be depricated.
SgGlobal*
SgFile::get_globalScope() const
   {
  // This variable name will be changed in the future (to globalScope)
     assert(p_root != NULL);
     return p_root;
   }
#endif

#if 0
// DQ (5/9/2008): Added to support for previous variable name for some backward compatability.
SgGlobal*
SgSourceFile::get_root() const
   {
  // This variable name will be changed in the future (to globalScope)
     assert(p_globalScope != NULL);
     return p_globalScope;
   }
#endif

int
SgFile::compileOutput ( int fileNameIndex, const std::string& compilerName )
   {
  // Compile the output file from the unparing
     vector<string> argv = get_originalCommandLineArgumentList();
     assert(!argv.empty());
   
  // DQ (4/21/2006): I think we can now assert this! This is an unused function parameter!
     assert(fileNameIndex == 0);

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);

  // error checking
     assert (argv.size() > 1);

  // BP : 10/31/2001, strip out any rose options before passing the command line.
     stripRoseCommandLineOptions( argv );

  // DQ (2/12/2004): strip out edg specific options that 
  // would cause an error in the backend compiler.
     stripEdgCommandLineOptions( argv );

  // Call the compile
     int errorCode = compileOutput ( argv, fileNameIndex, compilerName );

  // return the error code from the compilation
     return errorCode;
   }

// function prototype
// void pdfPrintAbstractSyntaxTreeSage ( SgFile & sageFile, bool writeOutHeaderFiles );

#if 0
void
SgFile::outputPDF ()
   {
  // Output the program tree
     printf ("In SgFile::outputPDF(): Dumping the program tree (AST) to a file \n");

  // Use Markus's new pdf generator
     AstPDFGeneration pdftest;
     pdftest.generateWithinFile(this);
   }
#endif

#if 0
void
roseDisplayMechanism( SgFile *file )
   {
  // This is the function called by EDG if set using the set_sage_transform_function() 
  // function. We use it to permit the EDG AST to be dumped out to a file.  This
  // step must be done before EDG's AST is deleted and so can't be done when other 
  // Sage/ROSE transformations are done (which is now after the EDG AST is released 
  // under the new (simplified) interface).

  // This function is called at the point where the EDG program tree has already 
  // been parsed into the C++ (modified Sage) grammar but the EDG AST still exists.

#if ROSE_INTERNAL_DEBUG
     if ( file->get_verbose() > 1 )
        {
       // Find out what file we are doing transformations upon
          printf ("In roseDisplayMechanism: globalSourceFileName = %s \n",file->getFileName());
        }
#endif

     if (file->get_outputGrammarTreeFiles() == true)
        {
       // Output the program tree
          printf ("## Dumping the program tree (AST) to a file ## \n");

       // Permit the AST for the  header files to be output
       // as well (this makes the output files very large)
          bool writeOutHeaderFiles = file->get_outputGrammarTreeFilesForHeaderFiles();

       // Added to speed up processing of large files when we just want the SAGE 3 AST
          bool writeOutEDG_AST = file->get_outputGrammarTreeFilesForEDG();

       // Output the source code file (as represented by the EDG AST) as a PDF file (with bookmarks)
       // Allow this to be off by default since the files generated are so large and most often we just want the SAGE 3 AST
          if (writeOutEDG_AST == true)
               pdfPrintAbstractSyntaxTreeEDG ( file, writeOutHeaderFiles );
            else
               printf ("Skipping output of EDG AST in PDF format (EDG output must be turned on explicitly using commandline option) \n");

       // Output the source code file (as represented by the SAGE AST) as a PDF file (with bookmarks)
       // pdfPrintAbstractSyntaxTreeSage ( file, writeOutHeaderFiles );

       // printf ("Exiting after testing pdf file output of source code! \n");
       // ROSE_ABORT();
        }
       else
        {
       // printf ("## Skip dumping the EDG program tree to a file ## \n");
        }
   }
#endif

// Moved to sageSupport.C: int  SgFile::callFrontEnd ()
// Moved to sageSupport.C: void SgFile::stripRoseCommandLineOptions ( vector<string>& argv )
// Moved to sageSupport.C: void SgFile::processRoseCommandLineOptions ( vector<string> & argv )
// Moved to sageSupport.C: void SgFile::stripEdgCommandLineOptions ( vector<string> & argv )
// Moved to sageSupport.C: void SgFile::processBackendSpecificCommandLineOptions ( const vector<string>& argvOrig )
// Moved to sageSupport.C: bool SgFile::isPrelinkPhase() const

SgProject*
SgFile::get_project()
   {
  // If the project is a parent of the current SgFile then we find it, else return NULL.

     SgNode* parent = get_parent();

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // assert(parent != NULL);

     SgProject* project = NULL;

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // Just return NULL in this case!
     if (parent != NULL)
        {
          project = isSgProject(parent);
          while ( project == NULL && parent->get_parent() != NULL )
             {
               parent = parent->get_parent();
               assert(parent != NULL);
               project = isSgProject(parent);
             }
          assert ( project != NULL );
        }

     return project;
   }

// Moved to sageSupport.C: void SgFile::build_EDG_CommandLine ( vector<string> & inputCommandLine, vector<string> & argv, int fileNameIndex )
// Moved to sageSupport.C: void SgFile::usage ( int status )

#ifdef _MSC_VER
#include <direct.h> 	// getcwd()
#endif

 //! get the current directory
string
SgFile::getWorkingDirectory ()
   {
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

// CH (4/8/2010): "direct.h" in MSVC provides getcwd()     
//#ifdef _MSC_VER
//#pragma message ("WARNING: support for Linux getcwd() unavailable in Microsoft Visual Studio.")
//	 printf ("Error: support for Linux getcwd() unavailable in Microsoft Visual Studio.");
//	 assert(false);
//     char* returnString = NULL;
//#else
     char* returnString = getcwd(currentDirectory,maxPathNameLength - 1);
//#endif
     assert (returnString != NULL);
     currentDirectory[maxPathNameLength - 1] = 0; // Just in case

  // The semantics of the getcwd is that these shuld be the same (see if they are)
  // printf ("In ROSE::getWorkingDirectory: Current directory = %s \n",currentDirectory);
  // printf ("In ROSE::getWorkingDirectory: Current directory = %s \n",returnString);

  // live with the possible memory leak for now
  // delete currentDirectory;
     currentDirectory = NULL;

     return returnString;
   }

 //! get the source directory
string
SgFile::getSourceDirectory ()
   {
#if 0
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

     printf ("SgFile::getSourceDirectory not implemented! \n");
     ROSE_ABORT();

     return "";
#endif

     string sourceFile = get_sourceFileNameWithPath();
     assert(sourceFile.empty() == false);
     return StringUtility::getPathFromFileName(sourceFile);
   }


string
SgFile::generateOutputFileName() const
   {
  // DQ (10/16/2005): This function abstracts the generation of an 
  // output file name from the source file name.

     std::string sourceFileName = get_sourceFileNameWithPath();

  // std::string baseFileName    = ROSE::stripPathFromFileName(sourceFileName.c_str());
     std::string baseFileName    = StringUtility::stripPathFromFileName(sourceFileName);

     std::string baseFileNameWithoutSuffix = StringUtility::stripFileSuffixFromFileName(baseFileName);

  // printf ("sourceFileName = %s oldFileName = %s\n",sourceFileName.c_str(),baseFileName.c_str());

     std::string objectFileName;

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);

#if 0
     printf ("sourceFileName = %s \n",sourceFileName.c_str());
     printf ("baseFileName = %s \n",baseFileName.c_str());
     printf ("baseFileNameWithoutSuffix = %s \n",baseFileNameWithoutSuffix.c_str());
#endif

#ifndef USE_ORIGINAL_SOURCE_FILE_NAME_IN_PRELINKING

  // DQ (8/12/2007): I think this was part of the prelinker which is not no longer used!
  // printf ("isPrelinkPhase() = %s \n",isPrelinkPhase() ? "true" : "false");
     assert(isPrelinkPhase() == false);

     if (isPrelinkPhase() == true)
        {
       // test for leading "rose_" prefix in name (it should be present)
          assert(baseFileName.find("rose_") == 0);
       // and remove it since we want the unmodified file name to be used as a name of the object file!
          baseFileName.erase(0,5);

       // test for leading "rose_" prefix in name (it should NOT be present now)
          assert(baseFileName.find("rose_") == std::string::npos);
        }
#else

#error "DEAD CODE"

#endif

  // DQ (8/12/2007): Newer simpler code, made possible because of better internal support.  
  // This version is also now language independent and so supports the Fortran work.
     objectFileName = baseFileNameWithoutSuffix + ".o";

  // printf ("At base of SgFile::generateOutputFileName(): objectFileName = %s \n",objectFileName.c_str());
  // display("In SgFile::generateOutputFileName()");

     return objectFileName;
   }


// Moved to sageSupport.C: string SgFile::buildCompilerCommandLineOptions ( vector<string> & argv, int fileNameIndex, const string& compilerName )


// Forward declarations of classes used to control and tailor the code generation.
// class UnparseDelegate;
// class UnparseFormatHelp;

// DQ (3/18/2006): Modified interface to allow specification of pointer to user 
// defined UnparseFormatHelp object (to control code generation).
// DQ (8/20/2005): Removed default parameter from extern function declaration
// extern void unparseFile( SgFile&, UnparseDelegate* repl = NULL );
// Liao (2/8/2008): Removed default parameters due to conflicts with src/backend/unparser/unparser.h
// extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */);

void
// SgFile::unparse ()
SgFile::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
  // DQ (1/24/2010): This call to the timer has been moved to the unparseFile() function.
  // DQ (7/12/2005): Introduce tracking of performance of ROSE.
  // TimingPerformance timer ("AST Code Generation (unparsing):");

  // printf ("Inside of SgFile::unparse () ROSE_DEBUG = %d  \n",ROSE_DEBUG);

  // Not clear if we can or should eliminate this function.
  // printf ("This SgFile::unparse() function should no longer be called (I think)! \n");
  // assert(false);

  // Call the unparser mechanism
  // DQ (1/24/2010): Moved the extern declaration for unparseFile() to be local to this function (better code design).
     extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */);
     unparseFile ( this, unparseFormatHelp, unparseDelegate );
   }

// Moved to sageSupport.C: int SgFile::compileOutput ( vector<string>& argv, int fileNameIndex, const string& compilerNameOrig )


// DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information) 
// to be relative to the generated code instead of the original input code.  This is useful when 
// we want to output references to the position of language constructs in the generated code
// instead of the original input code.  Also useful for building references to locations in 
// automatically generated code.
void
SgFile::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     extern void resetSourcePositionToGeneratedCode( SgFile* file, UnparseFormatHelp *unparseHelp );
     resetSourcePositionToGeneratedCode( this, unparseFormatHelp );
   }

void
SgFile::display ( const std::string & label ) const
   {
  // This function prints out the member data values within the object
     printf ("\nIn SgFile::display(%s) \n",label.c_str());

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);
#if 0
  // DQ (9/4/2008): Moved p_root to SgSourceFile
     printf ("     p_root is %s pointer \n",(p_root != NULL) ? "VALID" : "NULL");
     assert (p_root != NULL);
#endif

  // printf ("Output the SgFile::p_file_info object = %p \n",get_file_info());
  // get_file_info()->display("Called from SgFile::display");
     printf ("Output the SgFile::p_startOfConstruct object = %p \n",get_startOfConstruct());
     assert (get_startOfConstruct() != NULL);
     get_startOfConstruct()->display("Called from SgFile::display");

     printf ("     p_verbose                              = %s (value=%d) \n",                      (p_verbose > 1) ? "true" : "false",p_verbose);
     printf ("     p_output_warnings                      = %s \n",                      (p_output_warnings == true) ? "true" : "false");

     printf ("     p_C_only()                             = %s \n",(p_C_only == true)   ? "true" : "false");
     printf ("     p_UPC_only()                           = %s \n",(p_UPC_only == true) ? "true" : "false");
     printf ("     p_upc_threads                          = %s (value=%d) \n",  (p_upc_threads > 1) ? "true" : "false",p_upc_threads);
     printf ("     p_C99_only()                           = %s \n",(p_C99_only == true) ? "true" : "false");
     printf ("     p_Cxx_only()                           = %s \n",(p_Cxx_only == true) ? "true" : "false");
     printf ("     p_Fortran_only()                       = %s \n",(p_Fortran_only == true) ? "true" : "false");
     printf ("     p_F77_only()                           = %s \n",(p_F77_only == true) ? "true" : "false");
     printf ("     p_F90_only()                           = %s \n",(p_F90_only == true) ? "true" : "false");
     printf ("     p_F95_only()                           = %s \n",(p_F95_only == true) ? "true" : "false");
     printf ("     p_F2003_only()                         = %s \n",(p_F2003_only == true) ? "true" : "false");
     printf ("     p_CoArrayFortran_only()                = %s \n",(p_CoArrayFortran_only == true) ? "true" : "false");
     printf ("     p_PHP_only()                           = %s \n",(p_PHP_only == true) ? "true" : "false");

     printf ("     p_requires_C_preprocessor              = %s \n",(p_requires_C_preprocessor == true) ? "true" : "false");

  // DQ (2/5/2009): Putting this back now, so we have one at the SgProject and one at the SgFile.
     printf ("     p_binary_only()                        = %s \n",(p_binary_only == true) ? "true" : "false");
     printf ("     p_isObjectFile()                       = %s \n",(p_isObjectFile == true) ? "true" : "false");

     string inputFormatName;
     switch(p_inputFormat)
        {
          case SgFile::e_unknown_output_format:    inputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: inputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  inputFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_inputFormat = %d \n",p_inputFormat);
               assert(false);
             }
        }

     printf ("     p_inputFormat                          = %s input format \n",inputFormatName.c_str());

     string outputFormatName;
     switch(p_outputFormat)
        {
          case SgFile::e_unknown_output_format:    outputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: outputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  outputFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_outputFormat = %d \n",p_outputFormat);
               assert(false);
             }
        }

     printf ("     p_outputFormat                         = %s output format \n",outputFormatName.c_str());

     string backendCompileFormatName;
     switch(p_backendCompileFormat)
        {
          case SgFile::e_unknown_output_format:    backendCompileFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: backendCompileFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  backendCompileFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_backendCompileFormat = %d \n",p_backendCompileFormat);
               assert(false);
             }
        }

     printf ("     p_backendCompileFormat                 = %s output format \n",backendCompileFormatName.c_str());

     printf ("     p_fortran_implicit_none                = %s \n",(p_fortran_implicit_none == true) ? "true" : "false");
     printf ("     p_openmp                       = %s \n",(p_openmp == true) ? "true" : "false");
     printf ("     p_cray_pointer_support                 = %s \n",(p_cray_pointer_support == true) ? "true" : "false");
     printf ("     p_output_parser_actions                = %s \n",(p_output_parser_actions == true) ? "true" : "false");
     printf ("     p_exit_after_parser                    = %s \n",(p_exit_after_parser == true) ? "true" : "false");

     printf ("     p_skip_syntax_check                    = %s \n",(p_skip_syntax_check      == true) ? "true" : "false");
     printf ("     p_skip_transformation                  = %s \n",(p_skip_transformation    == true) ? "true" : "false");
     printf ("     p_skip_unparse                         = %s \n",(p_skip_unparse           == true) ? "true" : "false");
     printf ("     p_skipfinalCompileStep                 = %s \n",(p_skipfinalCompileStep   == true) ? "true" : "false");

     printf ("     p_unparse_includes                     = %s \n",(p_unparse_includes                     == true) ? "true" : "false");
     printf ("     p_unparse_line_directives              = %s \n",(p_unparse_line_directives              == true) ? "true" : "false");
     printf ("     p_unparse_instruction_addresses        = %s \n",(p_unparse_instruction_addresses        == true) ? "true" : "false");
     printf ("     p_unparse_raw_memory_contents          = %s \n",(p_unparse_raw_memory_contents          == true) ? "true" : "false");
     printf ("     p_unparse_binary_file_format           = %s \n",(p_unparse_binary_file_format           == true) ? "true" : "false");

     string outputLanguageName;
     switch(p_outputLanguage)
        {
          case SgFile::e_error_output_language:   outputLanguageName = "error";   break;
          case SgFile::e_default_output_language: outputLanguageName = "default"; break;
          case SgFile::e_C_output_language:       outputLanguageName = "C";       break;
          case SgFile::e_Cxx_output_language:     outputLanguageName = "C++";     break;
          case SgFile::e_Fortran_output_language: outputLanguageName = "Fortran"; break;
          case SgFile::e_PHP_output_language: outputLanguageName = "PHP"; break;
          case SgFile::e_Promela_output_language: outputLanguageName = "Promela"; break;

          default:
             {
               printf ("Error: default reached p_outputFormat = %d \n",p_outputFormat);
               assert(false);
             }
        }

     printf ("     p_outputLanguage                       = %s output language \n",outputLanguageName.c_str());

     printf ("     p_sourceFileNameWithPath               = %s \n",p_sourceFileNameWithPath.c_str());
     printf ("     p_sourceFileNameWithoutPath            = %s \n",p_sourceFileNameWithoutPath.c_str());
     printf ("     p_unparse_output_filename              = %s \n",p_unparse_output_filename.c_str());

     printf ("     p_useBackendOnly                       = %s \n",(p_useBackendOnly == true) ? "true" : "false");
     printf ("     p_compileOnly                          = %s \n",(p_compileOnly  == true) ? "true" : "false");

     printf ("     p_savedEdgCommandLine                  = %s \n",p_savedEdgCommandLine.c_str());

     printf ("     p_no_implicit_templates                = %s \n",(p_no_implicit_templates == true) ? "true" : "false");
     printf ("     p_no_implicit_inline_templates         = %s \n",(p_no_implicit_inline_templates == true) ? "true" : "false");
     printf ("     p_skip_commentsAndDirectives           = %s \n",(p_skip_commentsAndDirectives == true) ? "true" : "false");
     printf ("     p_collectAllCommentsAndDirectives      = %s \n",(p_collectAllCommentsAndDirectives == true) ? "true" : "false");

     printf ("     p_preprocessorDirectivesAndCommentsList is %s pointer \n",(p_preprocessorDirectivesAndCommentsList != NULL) ? "VALID" : "NULL");

     printf ("     p_KCC_frontend                         = %s \n",(p_KCC_frontend                         == true) ? "true" : "false");
     printf ("     p_new_frontend                         = %s \n",(p_new_frontend                         == true) ? "true" : "false");
     printf ("     p_disable_edg_backend                  = %s \n",(p_disable_edg_backend                  == true) ? "true" : "false");
     printf ("     p_disable_sage_backend                 = %s \n",(p_disable_sage_backend                 == true) ? "true" : "false");
     printf ("     p_testingLevel                         = %d \n",p_testingLevel);

     printf ("     p_preinit_il                           = %s \n",(p_preinit_il                           == true) ? "true" : "false");
     printf ("     p_enable_cp_backend                    = %s \n",(p_enable_cp_backend                    == true) ? "true" : "false");

#if 0
     printf ("     p_outputGrammarTreeFiles               = %s \n",(p_outputGrammarTreeFiles               == true) ? "true" : "false");
     printf ("     p_outputGrammarTreeFilesForHeaderFiles = %s \n",(p_outputGrammarTreeFilesForHeaderFiles == true) ? "true" : "false");
     printf ("     p_outputGrammarTreeFilesForEDG         = %s \n",(p_outputGrammarTreeFilesForEDG  == true) ? "true" : "false");
#endif

     printf ("     p_markGeneratedFiles                   = %s \n",(p_markGeneratedFiles == true) ? "true" : "false");
     printf ("     p_negative_test                        = %s \n",(p_negative_test == true) ? "true" : "false");
     printf ("     p_strict_language_handling             = %s \n",(p_strict_language_handling == true) ? "true" : "false");
     printf ("     p_wave             = %s \n",(p_wave == true) ? "true" : "false");
     printf ("     p_embedColorCodesInGeneratedCode       = %s \n",(p_embedColorCodesInGeneratedCode == true) ? "true" : "false");
     printf ("     p_generateSourcePositionCodes          = %s \n",(p_generateSourcePositionCodes == true) ? "true" : "false");
     printf ("     p_sourceFileUsesCppFileExtension       = %s \n",(p_sourceFileUsesCppFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortranFileExtension   = %s \n",(p_sourceFileUsesFortranFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran77FileExtension = %s \n",(p_sourceFileUsesFortran77FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran90FileExtension = %s \n",(p_sourceFileUsesFortran90FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran95FileExtension = %s \n",(p_sourceFileUsesFortran95FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesPHPFileExtension       = %s \n",(p_sourceFileUsesPHPFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesBinaryFileExtension    = %s \n",(p_sourceFileUsesBinaryFileExtension == true) ? "true" : "false");
     printf ("     p_read_executable_file_format_only     = %s \n",(p_read_executable_file_format_only == true) ? "true" : "false");
     printf ("     p_read_instructions_only               = %s \n",(p_read_instructions_only == true) ? "true" : "false");


#if 0
// Order of data member entries in support.C, matched against the 
// initialization to make sure that all data members are initialized.
X startOfConstruct
X root
X verbose
X output_warnings
X C_only
X UPC_only
X upc_threads
X C99_only
X Cxx_only
X Fortran_only
X F77_only
X F90_only
X F95_only
X F2003_only
X PHP_only
X requires_C_preprocessor
X binary_only
X inputFormat
X outputFormat
X backendCompileFormat
X fortran_implicit_none
X fortran_openmp
X cray_pointer_support
X output_parser_actions
X exit_after_parser
X skip_syntax_check
X skip_transformation
X skip_unparse
X skipfinalCompileStep
X unparse_includes
X unparse_line_directives
X unparse_instruction_addresses
X unparse_raw_memory_contents
X unparse_binary_file_format
X outputLanguage
STRING  sourceFileNameWithPath
STRING  sourceFileNameWithoutPath
STRING  unparse_output_filename
X useBackendOnly
X compileOnly
STRING  savedEdgCommandLine
X no_implicit_templates
X no_implicit_inline_templates
X skip_commentsAndDirectives
X collectAllCommentsAndDirectives
X preprocessorDirectivesAndCommentsList
X attributeMechanism
X KCC_frontend
X new_frontend
X disable_edg_backend
X disable_sage_backend
X testingLevel
X preinit_il
X enable_cp_backend
// X outputGrammarTreeFiles
// X outputGrammarTreeFilesForHeaderFiles
// X outputGrammarTreeFilesForEDG

X markGeneratedFiles
X negative_test
X strict_language_handling
X embedColorCodesInGeneratedCode
X generateSourcePositionCodes
X sourceFileUsesCppFileExtension
X sourceFileUsesFortranFileExtension
X sourceFileUsesFortran77FileExtension
X sourceFileUsesFortran90FileExtension
X sourceFileUsesFortran95FileExtension
X sourceFileUsesPHPFileExtension
X sourceFileUsesBinaryFileExtension
X binaryFile
X read_executable_file_format_only
X read_instructions_only
X aggressive
#endif

   }

SOURCE_APPLICATION_FILE_END


SOURCE_APPLICATION_SOURCE_FILE_START

#if 0
SgSourceFile::SgSourceFile ()
   {
  // Default constructor

     assert (p_root == NULL);

  // DQ (9/4/2008): Setup of global scope moved from SgFile to SgSourceFile
  // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
  // enforce that the filename is always an absolute path (starting with "/").
  // Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("SgGlobal::SgGlobal",0,0);
     Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("",0,0);
     assert (globalScopeFileInfo != NULL);

     p_root = new SgGlobal( globalScopeFileInfo );
     assert (p_root != NULL);

  // DQ (2/15/2006): Set the parent of the SgGlobal IR node
     p_root->set_parent(this);

  // DQ (8/21/2008): Set the end of the global scope (even if it is updated later)
  // printf ("In SgFile::initialization(): p_root->get_endOfConstruct() = %p \n",p_root->get_endOfConstruct());
     assert(p_root->get_endOfConstruct() == NULL);
     p_root->set_endOfConstruct(new Sg_File_Info("",0,0));
     assert(p_root->get_endOfConstruct() != NULL);
   }
#endif

SOURCE_APPLICATION_SOURCE_FILE_END

SOURCE_APPLICATION_BINARY_FILE_START

const SgAsmGenericFile* 
SgBinaryComposite::get_binaryFile() const
   {
     assert(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

SgAsmGenericFile*
SgBinaryComposite::get_binaryFile()
   {
     assert(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

void
SgBinaryComposite::set_binaryFile( SgAsmGenericFile* file )
   {
     assert(p_genericFileList->get_files().empty() == true);
     p_genericFileList->get_files().push_back(file);
   }

SOURCE_APPLICATION_BINARY_FILE_END

SOURCE_APPLICATION_UNKNOWN_FILE_START
SgUnknownFile::SgUnknownFile ( vector<string> & argv ,  SgProject* project )
   : SgFile(argv, project)
   {
  // set_parent(project);
   }

SOURCE_APPLICATION_UNKNOWN_FILE_END


SOURCE_APPLICATION_FILE_LIST_START
SOURCE_APPLICATION_FILE_LIST_END

SOURCE_APPLICATION_DIRECTORY_START
int
SgDirectory::numberOfFiles() const
   {
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     return -1;
#else
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles().size();
#endif
   }

SgFile*
SgDirectory::get_file(int i) const
   {
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     return NULL;
#else
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles()[i];
#endif
   }

int
SgDirectory::numberOfDirectories() const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories().size();
   }

SgDirectory*
SgDirectory::get_directory(int i) const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories()[i];
   }

void 
SgDirectory::post_construction_initialization()
   {
  // Make sure these data members start out as NULL.
     assert(p_fileList == NULL);
     assert(p_directoryList == NULL);

  // Initialize pointers to valid opjects with empty lists.
     p_fileList      = new SgFileList();
     p_directoryList = new SgDirectoryList();

     assert(p_fileList != NULL);
     assert(p_directoryList != NULL);

     p_fileList->set_parent(this);
     p_directoryList->set_parent(this);
   }

SOURCE_APPLICATION_DIRECTORY_END

SOURCE_APPLICATION_DIRECTORY_LIST_START
SOURCE_APPLICATION_DIRECTORY_LIST_END

SOURCE_APPLICATION_PROJECT_START

//! Declaration of space for static variables
//static int SgProject::p_defaultNumberOfCommandLineArguments = 0;
//static char** SgProject::p_defaultCommandLineArgumentList   = NULL;


//! (static data) global concept of verbose level which controls useful output from the compiler
int SgProject::p_verbose = 0;

//! this can constructor can be used but parse(int argc, char** argv) needs to be called
SgProject::SgProject()
   {
     initialization();
   }

SgProject::SgProject( const SgProject & project )
   {
  // This copy constructor is not supported, it is implemented with to return an error message!

     initialization();

  // What is the point of this code!
  // p_numberOfCommandLineArguments(project.p_numberOfCommandLineArguments),
  // p_commandLineArgumentList(project.p_commandLineArgumentList),
  // p_defaultNumberOfCommandLineArguments(project.p_defaultNumberOfCommandLineArguments),
  // p_defaultCommandLineArgumentList(project.p_defaultCommandLineArgumentList),

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
  // DQ (1/20/2010): This is no longer a list and is now a pointer to a SgFileList IR node.

  // Build the empty STL lists
     p_fileList.clear();
#endif

  // print error message and quit
     printf ("ERROR: this SgProject copy constructor is not supposed to be used \n");
     printf ("    use SgProject ( int & argc, char** & argv , int & errorCode ) OR copy member function instead \n");
     ROSE_ABORT();
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( int argc, char** argv)
   {
     initialization();

     std::vector<std::string> argvList(argv, argv + argc);
     int errorCode = parse(argvList);
     set_frontendErrorCode(errorCode);
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( const std::vector<std::string>& argv )
   {
     initialization();

     int errorCode = parse(argv);
     set_frontendErrorCode(errorCode);
   }

#if 0
// DQ (10/16/2005): Depreicated a long time ago, removed it now!
//! Deprecated, do not use.
SgProject::SgProject ( int& argc, char** argv, int& refErrorCode)
   {
     printf ("This SgProject constructor is deprecated, do not use. \n");

     initialization();

     int errorCode;
     errorCode = parse(argc,argv);
     set_frontendErrorCode(errorCode);
     refErrorCode = errorCode;
   }
#endif

void
SgProject::initialization()
   {
  // DQ (10/16/2005): This function initializes default values (until we use an automatically generated version)

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     p_fileList.clear();
#else
  // Initialize to IR node
     p_fileList_ptr = new SgFileList();
     assert(p_fileList_ptr != NULL);

     p_fileList_ptr->set_parent(this);
#endif

  // p_numberOfCommandLineArguments        = 0;
  // p_commandLineArgumentList             = NULL;
  // p_defaultNumberOfCommandLineArguments = 0;
  // p_defaultCommandLineArgumentList      = NULL;
     p_frontendErrorCode                   = 0;
     p_backendErrorCode                    = 0;
     p_outputFileName                      = "";
     p_compileOnly                         = false;
     p_prelink                             = false;
     p_template_instantiation_mode         = e_unknown;
     p_astMerge                            = false;
     p_astMergeCommandFile                 = "";
     p_compilationPerformanceFile          = "";
     p_C_PreprocessorOnly                  = false;

  // DQ (5/2/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism                  = NULL;

  // DQ (1/23/2010): Added support for the project to have directory structure
     p_directoryList                       = NULL;

  // DQ (3/9/2009): Allow the verbose level to be set before we even call the SgProject constructor (helps debug Intel Pin usage).
     if (p_verbose > 0)
        {
          printf ("Note: Verbose was already set to non-zero value = %d (valid range is 0...10) \n",p_verbose);
          assert(p_verbose <= 10);
        }
       else
        {
          p_verbose                        = 0;
        }

  // DQ (2/4/2009): This was moved to the SgProject from the SgFile
     p_binary_only                         = false;

  // DQ (1/16/2008): This is part of a ROSE supported mechanism for the 
  // specification of exclude/include paths/files for interpretation by 
  // the ROSE translator.
  // p_lookForIncludePaths                 = false;
  // p_lookForExcludePaths                 = false;

  // DQ (1/20/2010): Added support for the project to have directory structure
  // (usefult for large scale code generation).
     assert(p_directoryList == NULL);

  // Initialize pointers to valid opjects with empty lists.
     p_directoryList = new SgDirectoryList();
     assert(p_directoryList != NULL);
     p_directoryList->set_parent(this);
   }

// DQ (2/1/2007): Added new operator so that w could depricate the inconsistant usage of 
// SgFile& in get_file() member function.  The get_file() member function is now depricated.
SgFile*
SgProject::operator[]( unsigned int i )
   {

  // Since we use an STL vector internally we can use the vector::operator[] directly.
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     assert(i < get_fileList().size());
     return p_fileList[i];
#else
     assert(p_fileList_ptr != NULL);
     assert(i < (unsigned)numberOfFiles());
     return p_fileList_ptr->get_listOfFiles()[i];
#endif
   }

// Moved to sageSupport.C: int SgProject::parse(const vector<string>& argv)
// Moved to sageSupport.C: void SgProject::processCommandLine(const vector<string>& input_argv)

std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<string> & l )
   {
  // printf ("Output Rose_STL_Container<string> in operator<< (std::ostream,Rose_STL_Container<string>) \n");
     return os;
   }

// DQ (5/22/2007): Moved to astPostProcessing
// DQ (5/8/2007): Function prototype declared in HiddenList.h
// void buildHiddenTypeAndDeclarationLists( SgProject* project );

#if 0
// Moved the sageSupport.C
int 
SgProject::parse()
   {
     int errorCode = 0;

#error "DEAD CODE!"

     return errorCode;
   }
#endif


#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
#else
// DQ (1/21/2010): In this case we want to support the previous interface so that we can transition easily.

SgFilePtrList &
SgProject::get_fileList() const
   {
     assert (this != NULL);
     return p_fileList_ptr->get_listOfFiles();
   }

void
SgProject::set_fileList( SgFilePtrList & fileList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_fileList_ptr->get_listOfFiles() = fileList;
   }

#endif

int
SgProject::numberOfFiles() const
   {
  // This function does not return a meaningful result until all the files have been processed
  // assert (p_fileList != NULL);

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     int returnValue = p_fileList.size();
#else
     assert (p_fileList_ptr != NULL);
     int returnValue = p_fileList_ptr->get_listOfFiles().size();
#endif
  // assert ( returnValue > 0 );

  // Seems like a good upper bound for now!
  // assert ( returnValue < 100 );

     return returnValue;
   }

int
SgProject::numberOfDirectories() const
   {
     assert (p_directoryList != NULL);
     int returnValue = p_directoryList->get_listOfDirectories().size();

     return returnValue;
   }

SgFile &
SgProject::get_file ( int i ) const
   {
  // error checking
     assert (i >= 0);
     assert (i < numberOfFiles());

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     SgFile* targetFile = p_fileList[i];
#else
     assert (p_fileList_ptr != NULL);
     SgFile* targetFile = p_fileList_ptr->get_listOfFiles()[i];
  // SgFile* targetFile = NULL;

  // printf ("Exiting since this is not finished. \n");
  // assert(false);
#endif
     assert (targetFile != NULL);

     return *targetFile;
   }

void
SgProject::set_file ( SgFile & file )
   {
  // assert (p_fileList != NULL);

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     p_fileList.push_back(&file);
#else
     assert (p_fileList_ptr != NULL);
     p_fileList_ptr->get_listOfFiles().push_back(&file);

  // DQ (1/25/2010): Set the parent of the file to point to the list (this is a change and may break some code).
  // But it is consistant within ROSE for how we handle list objects in the IR.
     file.set_parent(p_fileList_ptr);

  // printf ("Exiting since this is not finished. \n");
  // assert(false);
#endif

     assert (numberOfFiles() > 0);
   }

void
SgProject::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
#if 0
     for (int i = 0; i < numberOfFiles(); i++)
        {
       // printf ("In SgProject::unparse(): Unparsing file #%d \n",i);
          SgFile & file = get_file(i);

       // DQ (3/18/2006): Added support for user defined control of code generation
          file.unparse(unparseFormatHelp,unparseDelegate);
        }
#else
  // DQ (1/24/2010): refactored code to call existing function.
     extern void unparseProject( SgProject* project, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */);
     unparseProject( this, unparseFormatHelp, unparseDelegate);
#endif
   }

// Moved to sageSupport.C: int SgProject::compileOutput( const std::string& compilerName )

void
SgProject::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.resetSourcePositionToGeneratedCode( unparseFormatHelp );
        }
   }


#if 0
// DQ (9/2/2008): Removed this redundant function
// DQ (10/16/2005): I would like to get rid of this function since it is redundant with other 
// automatically generated functions containing list of source files (with and without paths).
Rose_STL_Container<string>
SgProject::getFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }
#endif

#if 1
// DQ (9/2/2008): Readded this function with a clearer name, since it is different from the
// list of filenames that appear on the command line; these are resolved to be absolute paths.
Rose_STL_Container<string>
SgProject::getAbsolutePathFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }
#endif

// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
int
SgProject::get_verbose (void)
   {
     return p_verbose;
   }

// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
void
SgProject::set_verbose ( int x )
   {
     p_verbose = x;
   }

bool
SgProject::get_skip_transformation (void) const
   {
  // look at how the files are set
     bool returnSkipTransformation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTransformation = returnSkipTransformation && (bool) file.get_skip_transformation();
        }
     return returnSkipTransformation;
   }

bool
SgProject::get_skip_unparse (void) const
   {
  // look at how the files are set
     bool returnSkipUnparse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipUnparse = returnSkipUnparse && (bool) file.get_skip_unparse();
        }
     return returnSkipUnparse;
   }

bool
SgProject::get_useBackendOnly (void) const
   {
  // look at how the files are set
     bool returnUseBackendOnly = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnUseBackendOnly = returnUseBackendOnly && (bool) file.get_useBackendOnly();
        }
     return returnUseBackendOnly;
   }

// DQ (4/6/2010): Added to support parsing only option.
bool
SgProject::get_exit_after_parser(void) const
   {
  // look at how the files are set
     bool returnExitAfterParse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnExitAfterParse = returnExitAfterParse && (bool) file.get_exit_after_parser();
        }
     return returnExitAfterParse;
   }

void 
SgProject::set_C_only       (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_C_only = value;
   }

void
SgProject::set_Cxx_only     (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_Cxx_only = value;
   }

void
SgProject::set_Fortran_only (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_Fortran_only = value;
   }

bool
SgProject::get_C_only (void) const
   {
  // look at how the files are set (C here implies C89)
  // bool result = false;
     bool result = p_C_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C_only();
        }
     return result;
   }

bool
SgProject::get_C99_only (void) const
   {
  // look at how the files are set (C99 only)
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_only();
        }
     return result;
   }

bool
SgProject::get_Cxx_only (void) const
   {
  // look at how the files are set (C++ only)
  // bool result = false;
     bool result = p_Cxx_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx_only();
        }
     return result;
   }

bool
SgProject::get_Fortran_only (void) const
   {
  // look at how the files are set
  // bool result = false;
     bool result = p_Fortran_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Fortran_only();
        }
     return result;
   }

bool
SgProject::get_F77_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F77_only();
        }
     return result;
   }

bool
SgProject::get_F90_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F90_only();
        }
     return result;
   }

bool
SgProject::get_F95_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F95_only();
        }
     return result;
   }

bool
SgProject::get_F2003_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2003_only();
        }
     return result;
   }

bool
SgProject::get_CoArrayFortran_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_CoArrayFortran_only();
        }
     return result;
   }

bool
SgProject::get_PHP_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_PHP_only();
        }
     return result;
   }

#if 0
// DQ (2/4/2009): This is now a data member at the SgProject and so is automatically generated asa member function.
bool
SgProject::get_binary_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_binary_only();
        }
     return result;
   }
#endif

void
SgProject::skipfinalCompileStep(bool value)
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          get_file(i).set_skipfinalCompileStep(value);
        }
   }


void
SgProject::display ( const std::string & label ) const
   {
     printf ("In SgProject::display(%s) \n",label.c_str());

     printf ("   p_verbose                              = %d \n",p_verbose);

     printf ("   p_outputFileName                       = %s \n",p_outputFileName.c_str());

     printf ("   p_sourceFileNameList.size()            = %zu \n", p_sourceFileNameList.size());
     printf ("   p_sourceFileNameList                   = \n      %s \n",StringUtility::listToString(p_sourceFileNameList).c_str());

     printf ("   p_objectFileNameList.size()            = %zu \n", p_objectFileNameList.size());
     printf ("   p_objectFileNameList                   = \n      %s \n",StringUtility::listToString(p_objectFileNameList).c_str());

     printf ("   p_libraryFileList.size()               = %zu \n", p_libraryFileList.size());
     printf ("   p_libraryFileList                      = \n      %s \n",StringUtility::listToString(p_libraryFileList).c_str());

     printf ("   p_librarySpecifierList.size()          = %zu \n", p_librarySpecifierList.size());
     printf ("   p_librarySpecifierList                 = \n      %s \n",StringUtility::listToString(p_librarySpecifierList).c_str());

     printf ("   p_libraryDirectorySpecifierList.size() = %zu \n", p_libraryDirectorySpecifierList.size());
     printf ("   p_libraryDirectorySpecifierList        = \n      %s \n",StringUtility::listToString(p_libraryDirectorySpecifierList).c_str());

     printf ("   p_includeDirectorySpecifierList.size() = %zu \n", p_includeDirectorySpecifierList.size());
     printf ("   p_includeDirectorySpecifierList        = \n      %s \n",StringUtility::listToString(p_includeDirectorySpecifierList).c_str());

     printf ("   p_compileOnly                          = %s \n",(p_compileOnly == true) ? "true" : "false");
     printf ("   p_prelink                              = %s \n",(p_prelink     == true) ? "true" : "false");

     printf ("   p_template_instantiation_mode          = %d \n",p_template_instantiation_mode);

     printf ("   p_astMerge                             = %s \n",(p_astMerge == true) ? "true" : "false");
     printf ("   p_astMergeCommandFile                  = %s \n",p_astMergeCommandFile.c_str());
     printf ("   p_compilationPerformanceFile           = %s \n",p_compilationPerformanceFile.c_str());

  // DQ (1/16/2008): This is part of a ROSE supported mechanism for the 
  // specification of exclude/include paths/files for interpretation by 
  // the ROSE translator.
  // printf ("   p_lookForIncludePaths                  = %s \n",(p_lookForIncludePaths == true) ? "true" : "false");
  // printf ("   p_lookForExcludePaths                  = %s \n",(p_lookForExcludePaths == true) ? "true" : "false");

     printf ("   p_includePathList.size()               = %zu \n", p_includePathList.size());
     printf ("   p_includePathList                      = \n      %s \n",StringUtility::listToString(p_includePathList).c_str());

     printf ("   p_excludePathList.size()               = %zu \n", p_excludePathList.size());
     printf ("   p_excludePathList                      = \n      %s \n",StringUtility::listToString(p_excludePathList).c_str());

     printf ("   p_includeFileList.size()               = %zu \n", p_includeFileList.size());
     printf ("   p_includeFileList                      = \n      %s \n",StringUtility::listToString(p_includeFileList).c_str());

     printf ("   p_excludeFileList.size()               = %zu \n", p_excludeFileList.size());
     printf ("   p_excludeFileList                      = \n      %s \n",StringUtility::listToString(p_excludeFileList).c_str());

     printf ("   p_preincludeFileList.size()            = %zu \n", p_preincludeFileList.size());
     printf ("   p_preincludeFileList                   = \n      %s \n",StringUtility::listToString(p_preincludeFileList).c_str());

     printf ("   p_preincludeDirectoryList.size()       = %zu \n", p_preincludeDirectoryList.size());
     printf ("   p_preincludeDirectoryList              = \n      %s \n",StringUtility::listToString(p_preincludeDirectoryList).c_str());

  // DQ (2/4/2009): Moved from SgFile to SgProject.
     printf ("   p_binary_only()                        = %s \n",(p_binary_only == true) ? "true" : "false");

     printf ("In this project: numberOfFiles() = %d \n",numberOfFiles());
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.display("called from SgProject::display()");
        }
   }

// Moved to sageSupport.C: int SgProject::link ( std::string linkerName )
// Moved to sageSupport.C: int SgProject::link ( const std::vector<std::string>& argv, std::string linkerName )

const SgStringList &
SgProject::get_includePathList () const
   {
     assert (this != NULL);
     return p_includePathList;
   }

SgStringList &
SgProject::get_includePathList ()
   {
     assert (this != NULL);
     return p_includePathList;
   }

void
SgProject::set_includePathList ( const SgStringList & includePathList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_includePathList = includePathList;
   }


const SgStringList &
SgProject::get_excludePathList () const
   {
     assert (this != NULL);
     return p_excludePathList;
   }

SgStringList &
SgProject::get_excludePathList ()
   {
     assert (this != NULL);
     return p_excludePathList;
   }

void
SgProject::set_excludePathList ( const SgStringList & excludePathList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_excludePathList = excludePathList;
   }

const SgStringList &
SgProject::get_includeFileList () const
   {
     assert (this != NULL);
     return p_includeFileList;
   }

SgStringList &
SgProject::get_includeFileList ()
   {
     assert (this != NULL);
     return p_includeFileList;
   }

void
SgProject::set_includeFileList ( const SgStringList & includeFileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_includeFileList = includeFileList;
   }


const SgStringList &
SgProject::get_excludeFileList () const
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

SgStringList &
SgProject::get_excludeFileList ()
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

void
SgProject::set_excludeFileList ( const SgStringList & excludeFileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_excludeFileList = excludeFileList;
   }


SOURCE_APPLICATION_PROJECT_END


SOURCE_OPTIONS_START
SOURCE_OPTIONS_END


SOURCE_UNPARSE_INFO_START

// SgUnparse_Info SgNO_UNPARSE_INFO;
extern void printSgVariant(std::ostream&,int);

// DQ (1/11/2004): Remove this static member and make it a member pointer
// Declaration of static member to support unparsing complex structures
SgTypePtrList SgUnparse_Info::p_structureTagProcessingList;

/*! \brief Debugging support 

     Debugging support to test correctness of the implementation the SgUnparse_Info 
     object as an inherited attribute in the unparser.
 */
bool SgUnparse_Info::p_forceDefaultConstructorToTriggerError = false;

bool
SgUnparse_Info::get_forceDefaultConstructorToTriggerError()
   {
     return p_forceDefaultConstructorToTriggerError;
   }
 
void
SgUnparse_Info::set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError)
   {
     p_forceDefaultConstructorToTriggerError = forceDefaultConstructorToTriggerError;
   }
 


// Default constructor defined here because the automatically generated constructor
// would not be generated with the error checking that I require to debug the use of
// the SgUnparse_Info object as an inherited attribute in the unparser.
SgUnparse_Info::SgUnparse_Info (  )
   : SgSupport()
   {
     static int counter = 0;
     counter++;

#ifdef DEBUG
     printf ("In SgUnparse_Info::SgUnparse_Info () sage_class_name() = %s counter = %d \n",sage_class_name(),counter);
#endif

  // Supporting error checking for test of SgUnparse_Info as an inherited attribute in the unparser
     if (p_forceDefaultConstructorToTriggerError == true)
        {
          printf ("SgUnparse_Info constructor called in inappropriate location (part of debugging code) counter = %d \n",counter);
#if 1
       // DQ (11/9/2009): This can be allowed to be uncommented!
          ROSE_ABORT();
#else
       // DQ (11/9/2009): Allow this to support debugging of the unparser (posabily recursive behavior) \n");
          printf ("Warning: Allow this to support debugging of the unparser (posabily recursive behavior) \n");
#endif
        }

  // Test the variant virtual function
     assert(Unparse_InfoTag == variant());
     post_construction_initialization();

  // printf ("p_unparse_attribute.size() = %zu \n",p_unparse_attribute.size());
  // printf ("SgNO_UNPARSE_INFO.p_unparse_attribute.size() = %zu \n",SgNO_UNPARSE_INFO.p_unparse_attribute.size());
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Test the isSgUnparse_Info() function since it has been problematic
     assert(isSgUnparse_Info(this) != NULL);
   }

// DQ (1/5/2008): I think this is a redundant function with the one in sageInterface.C
std::string
getSgVariant ( int variant )
   {
  // Return a string associated with the input variant!
  // check to make sure we have the correct variant and a valid string
     assert(variant == $GRAMMAR_NAMETerminalNames[variant].variant);

     return $GRAMMAR_NAMETerminalNames[variant].name;
   }

SgUnparse_Info::SgUnparse_Info ( const SgUnparse_Info & X )
   : SgSupport()
   {
     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     *this = X;

     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
   }

SgUnparse_Info & SgUnparse_Info::operator= ( const SgUnparse_Info & X )
   {
     p_unparse_attribute = X.p_unparse_attribute;
     p_access_attribute  = X.p_access_attribute;
     p_nested_expression = X.p_nested_expression;
     p_operator_name     = X.p_operator_name;
     p_var_name          = X.p_var_name;
     p_declstatement_ptr = X.p_declstatement_ptr;
     p_current_context   = X.p_current_context;
     p_array_index_list  = X.p_array_index_list;

  // DQ (11/6/2004): aded initialization of namespace context
     p_current_namespace = X.p_current_namespace;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = X.p_outputCodeGenerationFormatDelimiters;

     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size()   == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList = X.p_qualifiedNameList;

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = X.p_current_function_call;

  // DQ (5/22/2007): Added to support name qualification and access to the new hidden 
  // type, declaration and class elaboration lists stored in the scopes.
     p_current_scope = X.p_current_scope;

     return *this;
   }

bool
SgUnparse_Info::checkBit(unparse_type_num bit) const
   {
  // if(p_unparse_attribute & bit) return 1; else return 0;
  // bool returnValue = false;
  // if (p_unparse_attribute[bit]) 
  //      returnValue = true;
  // return returnValue;

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     return p_unparse_attribute[bit];
   }

void
SgUnparse_Info::setBit(unparse_type_num bit)
   { 
  // p_unparse_attribute |= bit; 

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = true;
   }

void
SgUnparse_Info::unsetBit(unparse_type_num bit)
   { 
  // p_unparse_attribute &= ~bit;

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = false;
   }

void
SgUnparse_Info::post_construction_initialization()
   {
  // DQ (11/4/2003): Modified initialization from "0" to "NULL"
  // and "" for non-integer values

     assert (this != NULL);

  // Clear all bit flags
  // p_unparse_attribute = b_enum_defaultValue;
     for (int i = 0; i < UNPARSE_TYPE_LAST; i++)
        {
          p_unparse_attribute.push_back(false);
        }
     assert (p_unparse_attribute.size() > 0);

     p_access_attribute  = a_unset_access;
     p_nested_expression = false;
     p_operator_name     = "";
     p_var_name          = "";
     p_declstatement_ptr = NULL;
     p_current_context   = NULL;
     p_array_index_list  = "";

  // DQ (11/6/2004): Added initialization of namespace context (error reported valgrind)
     p_current_namespace = NULL;

  // DQ (1/12/2003): If calling constructor then empty the list
  // constructors (except copy constructor) are only call in the 
  // initiation of a unparser traversal (precisely where there 
  // is no context yet build up).
  
  // printf ("p_structureTagProcessingList.size() = %zu \n",p_structureTagProcessingList.size());
     if (p_structureTagProcessingList.empty() != true)
        {
       // empty the list (using STL list's assignment operator)
          SgTypePtrList emptyList;
          p_structureTagProcessingList = emptyList;
        }

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = false;

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList.clear();

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = NULL;

  // DQ (6/2/2007): Added initialization of new data member.
     p_current_scope = NULL;
   }

bool
SgUnparse_Info::isUnsetAccess() const
   { return p_access_attribute == a_unset_access; }

void
SgUnparse_Info::set_isUnsetAccess()
   { p_access_attribute = a_unset_access; }

bool
SgUnparse_Info::isPrivateAccess() const
   { return p_access_attribute == a_private_access; }

void
SgUnparse_Info::set_isPrivateAccess()
   { p_access_attribute = a_private_access; }

bool
SgUnparse_Info::isProtectedAccess() const
   { return p_access_attribute == a_protected_access; }

void
SgUnparse_Info::set_isProtectedAccess()
   { p_access_attribute = a_protected_access; } 

bool
SgUnparse_Info::isPublicAccess() const
   { return p_access_attribute == a_public_access; }

void
SgUnparse_Info::set_isPublicAccess()
   { p_access_attribute = a_public_access; }  

bool
SgUnparse_Info::isPointerToSomething() const
   { return checkBit(b_isPointerToSomething); }

void
SgUnparse_Info::set_isPointerToSomething()
   { setBit(b_isPointerToSomething); }

void
SgUnparse_Info::unset_isPointerToSomething()
   { unsetBit(b_isPointerToSomething); }

bool
SgUnparse_Info::isReferenceToSomething() const
   { return checkBit(b_isReferenceToSomething); }

void
SgUnparse_Info::set_isReferenceToSomething()
   { setBit(b_isReferenceToSomething); }

void
SgUnparse_Info::unset_isReferenceToSomething()
   { unsetBit(b_isReferenceToSomething); }

bool
SgUnparse_Info::inVarDecl() const
   { return checkBit(b_inVarDecl); }

void
SgUnparse_Info::set_inVarDecl()
   { setBit(b_inVarDecl); }

void
SgUnparse_Info::unset_inVarDecl()
   { unsetBit(b_inVarDecl); }

bool
SgUnparse_Info::inArgList() const
   { return checkBit(b_inArgList); }

void
SgUnparse_Info::set_inArgList()
   { setBit(b_inArgList); }

void
SgUnparse_Info::unset_inArgList()
   { unsetBit(b_inArgList); }

bool
SgUnparse_Info::SkipSemiColon() const
   { return checkBit(b_SkipSemiColon); }

void
SgUnparse_Info::set_SkipSemiColon()
   { setBit(b_SkipSemiColon); }

void
SgUnparse_Info::unset_SkipSemiColon()
   { unsetBit(b_SkipSemiColon); }

bool
SgUnparse_Info::inEnumDecl() const
   { return checkBit(b_inEnumDecl); }

void
SgUnparse_Info::set_inEnumDecl()
   { setBit(b_inEnumDecl); }

void
SgUnparse_Info::unset_inEnumDecl()
   { unsetBit(b_inEnumDecl); }

bool
SgUnparse_Info::inTemplateList() const
   { return checkBit(b_inTemplateList); }

void
SgUnparse_Info::set_inTemplateList()
   { setBit(b_inTemplateList); }

void
SgUnparse_Info::unset_inTemplateList()
   { unsetBit(b_inTemplateList); }

bool
SgUnparse_Info::SkipBaseType() const
   { return checkBit(b_SkipBaseType); }

void
SgUnparse_Info::set_SkipBaseType()
   { setBit(b_SkipBaseType); }

void
SgUnparse_Info::unset_SkipBaseType()
   { unsetBit(b_SkipBaseType); }

bool
SgUnparse_Info::inAggregateInitializer() const
   { return checkBit(b_inAggregateInitializer); }

void
SgUnparse_Info::set_inAggregateInitializer()
   { setBit(b_inAggregateInitializer); }

void
SgUnparse_Info::unset_inAggregateInitializer()
   { unsetBit(b_inAggregateInitializer); }

bool
SgUnparse_Info::isWithType() const
   { return checkBit(b_isWithType); }

void
SgUnparse_Info::set_isWithType()
   { setBit(b_isWithType); }

void
SgUnparse_Info::unset_isWithType()
   { unsetBit(b_isWithType); }

bool
SgUnparse_Info::inConditional() const
   { return checkBit(b_inConditional); }

void
SgUnparse_Info::set_inConditional()
   { setBit(b_inConditional); }

void
SgUnparse_Info::unset_inConditional()
   { unsetBit(b_inConditional); }

// DQ (1/23/03) Modified use of SkipDefinition to separate the functionality across
// different types of definitions (Enum, Function, and Class definitions).
bool
SgUnparse_Info::SkipDefinition() const
   { // return checkBit(b_SkipDefinition);
     return checkBit(b_SkipEnumDefinition) && 
            checkBit(b_SkipFunctionDefinition) && 
            checkBit(b_SkipClassDefinition);
   }

void
SgUnparse_Info::set_SkipDefinition()
   { 
  // setBit(b_SkipDefinition); 
     setBit(b_SkipEnumDefinition); 
     setBit(b_SkipFunctionDefinition); 
     setBit(b_SkipClassDefinition); 
   }

void
SgUnparse_Info::unset_SkipDefinition()
   {
  // unsetBit(b_SkipDefinition);
     unsetBit(b_SkipEnumDefinition);
     unsetBit(b_SkipFunctionDefinition);
     unsetBit(b_SkipClassDefinition);
   }

bool
SgUnparse_Info::SkipClassSpecifier() const
   { return checkBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::set_SkipClassSpecifier()
   { setBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::unset_SkipClassSpecifier()
   { unsetBit(b_SkipClassSpecifier); }

bool
SgUnparse_Info::inEmbeddedDecl() const
   { return checkBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::set_inEmbeddedDecl()
   { setBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::unset_inEmbeddedDecl()
   { unsetBit(b_inEmbeddedDecl); }

bool
SgUnparse_Info::SkipGlobal() const
   { return checkBit(b_SkipGlobal); }

void
SgUnparse_Info::set_SkipGlobal()
   { setBit(b_SkipGlobal); }

void
SgUnparse_Info::unset_SkipGlobal()
   { unsetBit(b_SkipGlobal); }

bool
SgUnparse_Info::SkipAtomic() const
   { return checkBit(b_SkipAtomic); }

void
SgUnparse_Info::set_SkipAtomic()
   { setBit(b_SkipAtomic); }

void
SgUnparse_Info::unset_SkipAtomic()
   { unsetBit(b_SkipAtomic); }

bool
SgUnparse_Info::PrintName() const
   { return checkBit(b_PrintName); }

void
SgUnparse_Info::set_PrintName()
   { if(!p_var_name.is_null()) setBit(b_PrintName); }

void
SgUnparse_Info::unset_PrintName()
   { unsetBit(b_PrintName); }

bool
SgUnparse_Info::CheckAccess() const
   { return checkBit(b_CheckAccess); }

void
SgUnparse_Info::set_CheckAccess()
   { setBit(b_CheckAccess); }

void
SgUnparse_Info::unset_CheckAccess()
   { unsetBit(b_CheckAccess); }

bool
SgUnparse_Info::SkipFunctionQualifier() const
   { return checkBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::set_SkipFunctionQualifier()
   { setBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::unset_SkipFunctionQualifier()
   { unsetBit(b_SkipFunctionQualifier); }

bool
SgUnparse_Info::isArrayType() const
   { return checkBit(b_isArrayType); }

void
SgUnparse_Info::set_isArrayType()
   { setBit(b_isArrayType); }

void
SgUnparse_Info::unset_isArrayType()
   { unsetBit(b_isArrayType); }

bool
SgUnparse_Info::inRhsExpr() const
   { return checkBit(b_inRhsExpr); }

void
SgUnparse_Info::set_inRhsExpr()
   { setBit(b_inRhsExpr); }

void
SgUnparse_Info::unset_inRhsExpr()
   { unsetBit(b_inRhsExpr); }

bool
SgUnparse_Info::SkipParen() const
   { return checkBit(b_SkipParen); }

void
SgUnparse_Info::set_SkipParen()
   { setBit(b_SkipParen); }

void
SgUnparse_Info::unset_SkipParen()
   { unsetBit(b_SkipParen); }

bool
SgUnparse_Info::isTypeSecondPart() const
   { return checkBit(b_isTypeSecondPart); }

void
SgUnparse_Info::set_isTypeSecondPart()  
   { setBit(b_isTypeSecondPart); unsetBit(b_isTypeFirstPart); }

void
SgUnparse_Info::unset_isTypeSecondPart()
   { unsetBit(b_isTypeSecondPart); }

bool
SgUnparse_Info::isTypeFirstPart() const
   { return checkBit(b_isTypeFirstPart); }

void
SgUnparse_Info::set_isTypeFirstPart()  
   { setBit(b_isTypeFirstPart); unsetBit(b_isTypeSecondPart); }

void
SgUnparse_Info::unset_isTypeFirstPart()
   { unsetBit( b_isTypeFirstPart); }

std::string
SgUnparse_Info::get_operator_name()
   { return p_operator_name; }

void
SgUnparse_Info::set_operator_name(const std::string& on)
   {
     p_operator_name = on;
   }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipInitializer() const
   { return checkBit(b_SkipInitializer); }

void
SgUnparse_Info::set_SkipInitializer()
   { setBit(b_SkipInitializer); }

void
SgUnparse_Info::unset_SkipInitializer()
   { unsetBit(b_SkipInitializer); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipComments() const
   { return checkBit(b_SkipComments); }

void
SgUnparse_Info::set_SkipComments()
   { setBit(b_SkipComments); }

void
SgUnparse_Info::unset_SkipComments()
   { unsetBit(b_SkipComments); }

//! (09/03/03) MS: Added to make whitespace optional
bool
SgUnparse_Info::SkipWhitespaces() const
   { return checkBit(b_SkipWhitespaces); }

void
SgUnparse_Info::set_SkipWhitespaces()
   { setBit(b_SkipWhitespaces); }

void
SgUnparse_Info::unset_SkipWhitespaces()
   { unsetBit(b_SkipWhitespaces); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipCPPDirectives() const
   { return checkBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::set_SkipCPPDirectives()
   { setBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::unset_SkipCPPDirectives()
   { unsetBit(b_SkipCPPDirectives); }

bool
SgUnparse_Info::SkipEnumDefinition() const
   { return checkBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::set_SkipEnumDefinition()
   { setBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::unset_SkipEnumDefinition()
   { unsetBit(b_SkipEnumDefinition); }

bool
SgUnparse_Info::SkipFunctionDefinition() const
   { return checkBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::set_SkipFunctionDefinition()
   { setBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::unset_SkipFunctionDefinition()
   { unsetBit(b_SkipFunctionDefinition); }

bool
SgUnparse_Info::SkipClassDefinition() const
   { return checkBit(b_SkipClassDefinition); }

void
SgUnparse_Info::set_SkipClassDefinition()
   { setBit(b_SkipClassDefinition); }

void
SgUnparse_Info::unset_SkipClassDefinition()
   { unsetBit(b_SkipClassDefinition); }

bool
SgUnparse_Info::AddSemiColonAfterDeclaration() const
   { return checkBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::set_AddSemiColonAfterDeclaration()
   { setBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::unset_AddSemiColonAfterDeclaration()
   { unsetBit(b_AddSemiColonAfterDeclaration); }

bool
SgUnparse_Info::SkipBasicBlock() const
   { return checkBit(b_SkipBasicBlock); }

void
SgUnparse_Info::set_SkipBasicBlock()
   { setBit(b_SkipBasicBlock); }

void
SgUnparse_Info::unset_SkipBasicBlock()
   { unsetBit(b_SkipBasicBlock); }

// DQ (3/18/2004): Added to support unparsing of class templates in variables but 
// not in in instatiated template declarations (unless the template is transformed 
// in which case another test is used).
bool
SgUnparse_Info::outputClassTemplateName() const
   { return checkBit(b_outputClassTemplateName); }

void
SgUnparse_Info::set_outputClassTemplateName()
   { setBit(b_outputClassTemplateName); }

void
SgUnparse_Info::unset_outputClassTemplateName()
   { unsetBit(b_outputClassTemplateName); }

// DQ (5/27/2005): support (see documentation above, in header file enum value)
bool
SgUnparse_Info::outputCompilerGeneratedStatements() const
   { return checkBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::set_outputCompilerGeneratedStatements()
   { setBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::unset_outputCompilerGeneratedStatements()
   { unsetBit(b_outputCompilerGeneratedStatements); }


// DQ (4/5/2006): Added support for constant folded values to be optionally output
bool
SgUnparse_Info::SkipConstantFoldedExpressions() const
   { return checkBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::set_SkipConstantFoldedExpressions()
   { setBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::unset_SkipConstantFoldedExpressions()
   { unsetBit(b_SkipConstantFoldedExpressions); }


// DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
bool
SgUnparse_Info::forceQualifiedNames() const
   { return checkBit(b_forceQualifiedNames); }

void
SgUnparse_Info::set_forceQualifiedNames()
   { setBit(b_forceQualifiedNames); }

void
SgUnparse_Info::unset_forceQualifiedNames()
   { unsetBit(b_forceQualifiedNames); }

bool
SgUnparse_Info::skipCheckAccess() const
   { return checkBit(b_skipCheckAccess); }

void
SgUnparse_Info::set_skipCheckAccess()
   { setBit(b_skipCheckAccess); }

void
SgUnparse_Info::unset_skipCheckAccess()
   { unsetBit(b_skipCheckAccess); }

// DQ (10/11/2006): Added to support new implementation of name qualification
bool
SgUnparse_Info::SkipQualifiedNames() const
   { return checkBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::set_SkipQualifiedNames()
   { setBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::unset_SkipQualifiedNames()
   { unsetBit(b_SkipQualifiedNames); }

bool
SgUnparse_Info::requiresGlobalNameQualification() const
   { return checkBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::set_requiresGlobalNameQualification()
   { setBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::unset_requiresGlobalNameQualification()
   { unsetBit(b_requiresGlobalNameQualification); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
bool
SgUnparse_Info::useTypeAttributes() const
   { return checkBit(b_useTypeAttributes); }

void
SgUnparse_Info::set_useTypeAttributes()
   { setBit(b_useTypeAttributes); }

void
SgUnparse_Info::unset_useTypeAttributes()
   { unsetBit(b_useTypeAttributes); }

// DQ (12/26/2007): Added support to restrict formatting of Fortran code.
// This allows us to put statements on the same line as if-stmt, where-stmt, etc.
// Plus it allows us to skip the insertion of leading 6 spaces in fixed format output.
bool
SgUnparse_Info::SkipFormatting() const
   { return checkBit(b_SkipFormatting); }

void
SgUnparse_Info::set_SkipFormatting()
   { setBit(b_SkipFormatting); }

void
SgUnparse_Info::unset_SkipFormatting()
   { unsetBit(b_SkipFormatting); }


SgName&
SgUnparse_Info::get_name()
   { return p_var_name; }

void
SgUnparse_Info::set_name(const SgName& name)
   { p_var_name = name; set_PrintName(); }

void
SgUnparse_Info::unset_name()
   {
     unset_PrintName(); 
     p_var_name=0;
   }

SgDeclarationStatement*
SgUnparse_Info::get_decl_stmt()
   { return p_declstatement_ptr; }

void
SgUnparse_Info::set_decl_stmt(SgDeclarationStatement* stmt )
   { p_declstatement_ptr = stmt; }

void
SgUnparse_Info::unset_decl_stmt()
   { p_declstatement_ptr=0; }

int
SgUnparse_Info::get_nested_expression()
   { return p_nested_expression; }

void
SgUnparse_Info::set_nested_expression()
   { p_nested_expression++; }

void
SgUnparse_Info::unset_nested_expression()
   { p_nested_expression--; }

void
SgUnparse_Info::unset_current_context()
   { p_current_context = NULL; }

SgName
SgUnparse_Info::get_array_index_list()
{ return p_array_index_list; }

void
SgUnparse_Info::set_array_index_list(SgExpression *e, SgUnparse_Info finfo )
   {
#if 1
     printf ("ERROR: not implemented in SAGE3! \n");
     ROSE_ABORT();
#else
     p_array_index_list << "[";
     ostringstream buffer;
     if(e) e->unparse(finfo,buffer);
     p_array_index_list << buffer.str() << "]";
#endif
   }

void
SgUnparse_Info::unset_array_index_list()
   { p_array_index_list=0; }

// FMZ : Added to support to generated XX.rose_mod file for a module
//       (based on fortran unparser).
bool
SgUnparse_Info::outputFortranModFile() const
   { return checkBit(b_outputFortranModFile); }

void
SgUnparse_Info::set_outputFortranModFile()
   { setBit(b_outputFortranModFile); }

void
SgUnparse_Info::unset_outputFortranModFile()
   { unsetBit(b_outputFortranModFile); }


void
SgUnparse_Info::display ( const std::string & label ) const
   {
     printf ("Inside of SgUnparse_Info::display(%s) \n",label.c_str());

#if 0
#define PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) printf (#XX" = %s \n",(XX() == true) ? "true" : "false");

     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)
#else
  // DQ: Note that this provides better formatting of the output!
     printf ("isPointerToSomething                   = %s \n",( isPointerToSomething() == true ) ? "true" : "false");
     printf ("isReferenceToSomething                 = %s \n",( isReferenceToSomething() == true ) ? "true" : "false");
     printf ("inVarDecl                              = %s \n",( inVarDecl() == true ) ? "true" : "false");
     printf ("inArgList                              = %s \n",( inArgList() == true ) ? "true" : "false");
     printf ("SkipSemiColon                          = %s \n",( SkipSemiColon() == true ) ? "true" : "false");
     printf ("inEnumDecl                             = %s \n",( inEnumDecl() == true ) ? "true" : "false");
     printf ("inTemplateList                         = %s \n",( inTemplateList() == true ) ? "true" : "false");
     printf ("SkipBaseType                           = %s \n",( SkipBaseType() == true ) ? "true" : "false");
     printf ("inAggregateInitializer                 = %s \n",( inAggregateInitializer() == true ) ? "true" : "false");
     printf ("isWithType                             = %s \n",( isWithType() == true ) ? "true" : "false");
     printf ("inConditional                          = %s \n",( inConditional() == true ) ? "true" : "false");
     printf ("SkipDefinition                         = %s \n",( SkipDefinition() == true ) ? "true" : "false");
     printf ("SkipClassSpecifier                     = %s \n",( SkipClassSpecifier() == true ) ? "true" : "false");
     printf ("inEmbeddedDecl                         = %s \n",( inEmbeddedDecl() == true ) ? "true" : "false");
     printf ("SkipGlobal                             = %s \n",( SkipGlobal() == true ) ? "true" : "false");
     printf ("SkipAtomic                             = %s \n",( SkipAtomic() == true ) ? "true" : "false");
     printf ("PrintName                              = %s \n",( PrintName() == true ) ? "true" : "false");
     printf ("CheckAccess                            = %s \n",( CheckAccess() == true ) ? "true" : "false");
     printf ("SkipFunctionQualifier                  = %s \n",( SkipFunctionQualifier() == true ) ? "true" : "false");
     printf ("isArrayType                            = %s \n",( isArrayType() == true ) ? "true" : "false");
     printf ("inRhsExpr                              = %s \n",( inRhsExpr() == true ) ? "true" : "false");
     printf ("SkipParen                              = %s \n",( SkipParen() == true ) ? "true" : "false");
     printf ("isTypeSecondPart                       = %s \n",( isTypeSecondPart() == true ) ? "true" : "false");
     printf ("isTypeFirstPart                        = %s \n",( isTypeFirstPart() == true ) ? "true" : "false");
     printf ("SkipInitializer                        = %s \n",( SkipInitializer() == true ) ? "true" : "false");
     printf ("SkipComments                           = %s \n",( SkipComments() == true ) ? "true" : "false");
     printf ("SkipCPPDirectives                      = %s \n",( SkipCPPDirectives() == true ) ? "true" : "false");
     printf ("SkipEnumDefinition                     = %s \n",( SkipEnumDefinition() == true ) ? "true" : "false");
     printf ("SkipFunctionDefinition                 = %s \n",( SkipFunctionDefinition() == true ) ? "true" : "false");
     printf ("SkipClassDefinition                    = %s \n",( SkipClassDefinition() == true ) ? "true" : "false");
     printf ("AddSemiColonAfterDeclaration           = %s \n",( AddSemiColonAfterDeclaration() == true ) ? "true" : "false");
     printf ("SkipWhitespaces                        = %s \n",( SkipWhitespaces() == true ) ? "true" : "false");
     printf ("SkipBasicBlock                         = %s \n",( SkipBasicBlock() == true ) ? "true" : "false");
     printf ("outputClassTemplateName                = %s \n",( outputClassTemplateName() == true ) ? "true" : "false");
     printf ("outputCompilerGeneratedStatements      = %s \n",( outputCompilerGeneratedStatements() == true ) ? "true" : "false");
     printf ("SkipConstantFoldedExpressions          = %s \n",( SkipConstantFoldedExpressions() == true ) ? "true" : "false");
     printf ("forceQualifiedNames                    = %s \n",( forceQualifiedNames() == true ) ? "true" : "false");
     printf ("SkipQualifiedNames                     = %s \n",( SkipQualifiedNames() == true ) ? "true" : "false");
     printf ("skipCheckAccess                        = %s \n",( skipCheckAccess() == true ) ? "true" : "false");
     printf ("requiresGlobalNameQualification        = %s \n",( requiresGlobalNameQualification() == true ) ? "true" : "false");
#endif

     switch (p_access_attribute)
        {
          case a_unset_access:
               printf ("p_access                               = unset access \n");
               break;
          case a_private_access:
               printf ("p_access                               = private access \n");
               break;
          case a_protected_access:
               printf ("p_access                               = protected access \n");
               break;
          case a_public_access:
               printf ("p_access                               = public access \n");
               break;
          default:
               printf ("Error: default reached in switch \n");
               assert(false);
        }

  // DQ (1/26/2006): Modified to handle 64 bit machines
     printf ("p_structureTagProcessingList.size()    = %zu \n", p_structureTagProcessingList.size());
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          printf ("--- structure tag pointer = %p class name = %s \n",*i,(*i)->sage_class_name());

          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               printf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     printf ("p_nested_expression                    = %d \n",p_nested_expression);
     printf ("p_operator_name                        = %s \n", p_operator_name.c_str());
     printf ("p_var_name                             = %s \n",(p_var_name.is_null() == false) ? p_var_name.str() : "EmPtY sTrInG");
     printf ("p_declstatement_ptr                    = %p \n",p_declstatement_ptr);
     printf ("p_current_context                      = %p \n",p_current_context);
     printf ("p_array_index_list                     = %s \n",(p_array_index_list.is_null() == false) ? p_array_index_list.str() : "EmPtY sTrInG");
     printf ("p_current_namespace                    = %p \n",p_current_namespace);
     printf ("p_outputCodeGenerationFormatDelimiters = %s \n",p_outputCodeGenerationFormatDelimiters ? "true" : "false");
     printf ("p_current_function_call                = %p \n",p_current_function_call);
     printf ("p_current_scope                        = %p = %s \n",p_current_scope,p_current_scope != NULL ? p_current_scope->class_name().c_str() : "EmPtY sTrInG");
   }

string
SgUnparse_Info::displayString ( const std::string & label ) const
   {
  // using namespace std;
     std::string returnString = std::string("Inside of SgUnparse_Info::display( ") + label + std::string(" )\n");

#define STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) \
     returnString += std::string("     ") + std::string(#XX) + std::string(" = ") + std::string((XX() == true) ? "true" : "false") + std::string(" \n");

     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)

     switch (p_access_attribute)
        {
          case a_unset_access:
               returnString += std::string("p_access = unset access \n");
               break;
          case a_private_access:
               returnString += std::string("p_access = private access \n");
               break;
          case a_protected_access:
               returnString += std::string("p_access = protected access \n");
               break;
          case a_public_access:
               returnString += std::string("p_access = public access \n");
               break;
          default:
               printf("Error: default reached in switch \n");
               assert(false);
        }

     returnString += std::string("p_structureTagProcessingList.size() = ") + 
                     StringUtility::numberToString(p_structureTagProcessingList.size()) + std::string("\n");
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          returnString += std::string("--- structure tag pointer = ") + 
                          StringUtility::numberToString((void*)(*i)) + 
                          std::string("= class name = ") + std::string((*i)->sage_class_name()) + std::string("\n");
          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               returnString += std::string("     Class name = ") + std::string(classType->get_name().str()) + std::string("\n");
            // printf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     return returnString;
   }

void
SgUnparse_Info::addStructureTag ( SgNamedType* structureTag )
   {
  // push the pointer to the back of the list
     p_structureTagProcessingList.push_back(structureTag);
   }

SgTypePtrList &
SgUnparse_Info::getStructureTagList ()
   {
  // Access function for internal STL list
     return p_structureTagProcessingList;
   }

SOURCE_UNPARSE_INFO_END

HEADER_TYPEDEF_SEQ_START         
      //! Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
          const SgTypePtrList & get_typedefs() const;

      //! Get the list of input types (types of the parameters list) to this function type
          SgTypePtrList & get_typedefs();

      //! Append new typedef to typedef type list
          void append_typedef( SgType* what);

      //! Insert new typedef to typedef type list
          void insert_typedef(const SgTypePtrList::iterator& where, SgType* what);

HEADER_TYPEDEF_SEQ_END

SOURCE_TYPEDEF_SEQ_START
const SgTypePtrList & 
$CLASSNAME::get_typedefs() const 
   { return p_typedefs; }

SgTypePtrList & 
$CLASSNAME::get_typedefs() 
   { return p_typedefs; }

void
$CLASSNAME::append_typedef( SgType* what) 
   {
     insert_typedef(p_typedefs.end(),what);
   }

void
$CLASSNAME::insert_typedef(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_typedefs.insert(where,what);
   }
SOURCE_TYPEDEF_SEQ_END


HEADER_FUNCTION_PARAMETER_TYPE_LIST_START
      //! Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
          const SgTypePtrList & get_arguments() const;

      //! Get the list of input types (types of the parameters list) to this function type
          SgTypePtrList & get_arguments();

       // WAS: void append_argument(const SgTypePtr& what);
       // WAS: void insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)

      //! Append new argument to argument type list
          void append_argument( SgType* what);

      //! Insert new argument to argument type list
          void insert_argument(const SgTypePtrList::iterator& where, SgType* what);

       // DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFunctionParameterTypeList();

HEADER_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_FUNCTION_PARAMETER_TYPE_LIST_START
const SgTypePtrList & 
$CLASSNAME::get_arguments() const 
   { return p_arguments; }

SgTypePtrList & 
$CLASSNAME::get_arguments() 
   { return p_arguments; }

void
$CLASSNAME::append_argument( SgType* what) 
   {
     insert_argument(p_arguments.end(),what);
   }

void
$CLASSNAME::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
  // WAS: void SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)
  // printf ("ERROR (in modified SAGE3 function): not implemented in SAGE3! \n");
  // abort();
     p_arguments.insert(where,what);
   }

// DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFunctionParameterTypeList::SgFunctionParameterTypeList()
   {
  // Build the default constructor (nothing to build here since the only data member is an STL list)
   }
 
SOURCE_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_TEMPLATE_PARAMETER_START

void SgTemplateParameter::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_parameterType                       = parameter_undefined;
     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;
   }

// Different constructors for use in building the different types of parameters possible
SgTemplateParameter::SgTemplateParameter ( SgType* parameter, SgType* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType        = type_parameter;
     p_type                 = parameter;
     p_defaultTypeParameter = defaultParameter;
   }

SgTemplateParameter::SgTemplateParameter ( SgExpression* parameter, SgExpression* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType              = nontype_parameter;
     p_expression                 = NULL;
     p_defaultExpressionParameter = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter )
   {
     post_construction_initialization();

     p_parameterType                       = template_parameter;
     p_templateDeclaration                 = parameter;
     p_defaultTemplateDeclarationParameter = defaultParameter;
   }

SOURCE_TEMPLATE_PARAMETER_END


SOURCE_TEMPLATE_ARGUMENT_START

void SgTemplateArgument::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_argumentType          = argument_undefined;
     p_type                  = NULL;
     p_expression            = NULL;
  // p_templateInstantiation = NULL;
     p_templateDeclaration = NULL;
   }

// Different constructors for use in building the different types of arguments possible
SgTemplateArgument::SgTemplateArgument ( SgType* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = type_argument;
     p_type                = argument;
     p_explicitlySpecified = explicitlySpecified;

  // Don't set the parent of a type!
  // argument->set_parent(this);
   }

SgTemplateArgument::SgTemplateArgument ( SgExpression* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = nontype_argument;
     p_expression          = argument;
     p_explicitlySpecified = explicitlySpecified;

  // DQ (8/24/2006): Set the parent
     argument->set_parent(this);
   }

#if 0
// DQ (8/24/2006): This is the incorrect constructor to have, it should have been a SgTemplateDeclaration (see new version below)
SgTemplateArgument::SgTemplateArgument ( SgTemplateInstantiationDecl* parameter, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType          = template_argument;
     p_templateInstantiation = parameter;
     p_explicitlySpecified   = explicitlySpecified;
   }
#endif

// DQ (8/24/2006): This is the more correct version to have.
SgTemplateArgument::SgTemplateArgument ( SgTemplateDeclaration* argument, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType          = template_template_argument;
     p_templateDeclaration   = argument;
     p_explicitlySpecified   = explicitlySpecified;

  // DQ (8/24/2006): Set the parent ???  (make sure it is not already set!)
  // This is likely a shared IR node, so we don't want to set the parent here!
  // assert(argument->get_parent() == NULL);
  // argument->set_parent(this);
#if PRINT_DEVELOPER_WARNINGS
     printf ("Skipping setting of parent on SgTemplateDeclaration in SgTemplateArgument \n");
#endif
   }

// RV (2/2/2006): Added mangling of template arguments.
SgName
SgTemplateArgument::get_mangled_name (void) const
   {
     ostringstream mangled_name;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               SgName mangled_type = type->get_mangled();
               mangled_name << mangled_type.str();
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();
               assert(expr != NULL);
               mangled_name << mangleExpression(expr);
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               assert (templateDeclaration != NULL);

            // DQ (8/24/2006): This is not yet implemented, we can't handle this as a expression!
            // mangled_name << mangleExpression (templateDeclaration);

            // Let the mangled name be the simple name of the template (at least for now).
            // SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();
               SgName mangled_templateDeclaration = templateDeclaration->get_name();
               mangled_name << mangled_templateDeclaration.str();

#if PRINT_DEVELOPER_WARNINGS
               printf ("Mangling of template template argument to template type not well tested yet mangled name = %s \n",mangled_templateDeclaration.str());
#endif
            // assert(false);
               break;
             }

          default:
        //! \todo Find out when "unknown template argument" case occurs.
               mangled_name << "UNKNOWN";
               assert (false);
               break;
        }

     string str_mangled_name (mangled_name.str());

     return SgName (str_mangled_name.c_str());
   }

// DQ (6/9/2007): Some template arguments have a concept of scope, this is required to get the name qualification correct.
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
  // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)

     const SgNode* parentNode = this;
     while ( (isSgScopeStatement(parentNode) == NULL) && (parentNode->get_parent() != NULL) )
        {
          parentNode = parentNode->get_parent();
        }

  // Check to see if we made it back to the root (current root is SgProject).
  // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).
     if ( isSgScopeStatement(parentNode) == NULL &&
          dynamic_cast<const SgType*>(parentNode) == NULL &&
          dynamic_cast<const SgSymbol*>(parentNode) == NULL )
        {
          printf ("Error in SgTemplateArgument::get_scope(): could not trace back to SgScopeStatement node this = %s parentNode = %s \n",class_name().c_str(),parentNode->class_name().c_str());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(parentNode);
          if (templateInstantiation != NULL)
             {
               templateInstantiation->get_startOfConstruct()->display("Error in SgTemplateArgument::get_scope()");
             }
          assert(parentNode->get_parent() != NULL);
       // ROSE_ABORT();
          return NULL;
        }
       else
        {
          if ( dynamic_cast<const SgType*>(parentNode) != NULL || dynamic_cast<const SgSymbol*>(parentNode) != NULL )
             {
               printf ("Error: can't locate an associated SgStatement from SgTemplateArgument = %p \n",this);
               return NULL;
             }
        }

  // Make sure we have a SgStatement node
     const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     assert (scopeStatement != NULL);

  // return statement;
     return const_cast<SgScopeStatement*>(scopeStatement);
   }

#if 0
// Not the correct idea!
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
     SgScopeStatement* scope = NULL;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               const SgNamedType* namedType = isSgNamedType(type);
               if (namedType != NULL)
                  {
                    assert(namedType->get_declaration() != NULL);
                    scope = namedType->get_declaration()->get_scope();
                  }
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
            // Not clear if the scope should be defined here!
               const SgExpression* expr = get_expression();
               assert(expr != NULL);
               scope = NULL;
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               assert (templateDeclaration != NULL);

               scope = templateDeclaration->get_scope();
               break;
             }

          default:
             {
               printf ("Error in SgTemplateArgument::get_scope(): default reached! \n");
               assert (false);
               break;
             }
        }

     return scope;
   } 
#endif

SOURCE_TEMPLATE_ARGUMENT_END


SOURCE_TEMPLATE_PARAMETER_LIST_START
SOURCE_TEMPLATE_PARAMETER_LIST_END


SOURCE_TEMPLATE_ARGUMENT_LIST_START
SOURCE_TEMPLATE_ARGUMENT_LIST_END


SOURCE_GRAPHNODE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphNode::p_index_counter = 0;


// tps : todo : remove this soon
void
SgGraphNode::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }


void
SgGraphNode::post_construction_initialization()
   {

  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;

  // printf ("In SgGraphNode::post_construction_initialization(): p_index = %u p_index_counter = %u \n",p_index,p_index_counter);

   }

SOURCE_GRAPHNODE_END


SOURCE_GRAPHEDGE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphEdge::p_index_counter = 0;


// tps : todo : remove me
void
SgGraphEdge::append_properties( int addr, const std::string & prop )
   {
  // DQ (4/29/2009): Unclear what this comment (below) means...
  // implemented directly until we can fix how the statementList is built
     p_properties[addr] = prop;
   }


void
SgGraphEdge::post_construction_initialization()
   {

  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;

  // printf ("In SgGraphEdge::post_construction_initialization(): p_index = %u p_index_counter = %u \n",p_index,p_index_counter);

   }

SOURCE_GRAPHEDGE_END


SOURCE_GRAPH_START

//#if defined(ROSE_USE_NEW_GRAPH_NODES) && !defined(ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY)
//#warning "ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY not set"
//#endif


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraph::p_index_counter = 0;



// tps : todo : remove me -----------------------------------------
void
SgGraph::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }

int 
SgGraph::hashCode( const char* p, int len) const // hash a character array
   {
     assert(this != NULL);
     unsigned int h = 0;
     for (int i=0; i < len; i++)
        {
          h = (h<<5) | (h>>27);    // 5-bit cyclic shift
          h += (unsigned int)p[i]; // add in next character
        }
     return (int)h; 
   }
// -----------------------------------------------------



// DQ (4/28/2009): Added support to have internal list nodes built automatically in the SgGraph constructor.
void
SgGraph::post_construction_initialization()
   {
     assert(this != NULL);


  // Setup an internal graph_id
     p_index = p_index_counter++;

   }



std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphNode* node) {
  string value="";
  map < int , string> node_p = node->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}

std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge) {
  string value="";
  map < int , string> node_p = edge->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}


void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphNode* node,
			   std::string value) {
  node->append_properties(property, value);
}

void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge,
			   std::string value) {
  edge->append_properties(property, value);
}




void
SgGraph::checkIfGraphNodeExists(const string& trg_mnemonic, std::vector<SgGraphNode*>& nodes) {
  rose_graph_string_integer_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_string_integer_hash_multimap::const_iterator, rose_graph_string_integer_hash_multimap::const_iterator> 
    iter = p_string_to_node_index_multimap.equal_range(trg_mnemonic);
  it1 = iter.first;
  it2 = iter.second;
  SgGraphNode* node = NULL;
  for (;it1!=it2; ++it1) {
    //
    //rose_graph_string_integer_hash_multimap::iterator it = p_string_to_node_index_multimap.find(trg_mnemonic);
    //if (it!=p_string_to_node_index_multimap.end()) {
    int index =  it1->second;
    node = p_node_index_to_node_map.find(index)->second;
    nodes.push_back(node);
  }
  //  return nodes;

  //  return NULL;
}

#if 0
// old interface
SgGraphNode*
SgGraph::checkIfGraphNodeExists(string& trg_mnemonic) {
#if 1
  SgGraphNode* node = NULL;
  SgGraphNodeList* gnodes = get_nodes();
  rose_graph_hash_multimap nodes = gnodes->get_nodes();
  rose_graph_hash_multimap::iterator it = nodes.find(trg_mnemonic);
  if (it!=nodes.end()) {
    node =  it->second;
    return node;
  }
#endif

  return NULL;
}

  // Increase the size of the hash_map
     resize_hash_maps( 1000 );
#endif


SOURCE_GRAPH_END


SOURCE_DIRECTED_GRAPH_EDGE_START


SgDirectedGraphEdge::SgDirectedGraphEdge(std::string label, std::string type, int n, SgGraphNode* from, SgGraphNode* to)

   {
   	p_name = label;
//   	p_type=t;
   	p_node_A = from;
   	p_node_B=to;
   }

SOURCE_DIRECTED_GRAPH_EDGE_END

#if 0
SOURCE_DIRECTED_GRAPH_NODE_START
// DQ (4/23/2009): Removed to debug use of new Graph node interfaces.

SgDirectedGraphNode::SgDirectedGraphNode(std::string name , std::string t , int n)
   {
   	p_name = name;
//   	p_type=t;
   //	p_node_A = n1;
   }

SOURCE_DIRECTED_GRAPH_NODE_END


SOURCE_DIRECTED_GRAPH_START
SgDirectedGraph::SgDirectedGraph(std::string name, std::string t)
   {
   p_name=name;
   }
SOURCE_DIRECTED_GRAPH_END
#endif

SOURCE_INCIDENCE_UNDIRECTED_GRAPH_START
SOURCE_INCIDENCE_UNDIRECTED_GRAPH_END


SOURCE_INCIDENCE_DIRECTED_GRAPH_START


void
SgIncidenceDirectedGraph::post_construction_initialization()
   {
     assert(this != NULL);

   }


bool
SgIncidenceDirectedGraph::checkIfGraphEdgeExists(SgGraphNode* src) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesOut();
  bool exists = false;
  rose_graph_integer_edge_hash_multimap::iterator it = edges.find(src->get_index());
  if (it!=edges.end()) {
    exists=true;
  }
  return exists;
}

std::set <SgGraphEdge*>
SgIncidenceDirectedGraph::getEdge(SgGraphNode* src) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    //    SgGraphNode* source = it1->first;
    SgGraphEdge* edge = isSgGraphEdge(it1->second);
    medges.insert(edge);
  }
  return medges;
}






void
SgIncidenceDirectedGraph::getSuccessors(SgGraphNode* node, std::vector <SgGraphNode*>& vec ) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesOut();
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  //  cerr << " >>>>>>>>>>>>>>> Outedges for node " << node->get_index() << endl;
  assert(node);
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    //    cerr << "            are : " << edge->get_index() << endl;
    assert(edge);
    if (edge) {
      SgGraphNode* target = isSgGraphNode(edge->get_to());
      assert(target);
      if (target) {
	    string type_n = getProperty(SgGraph::type, edge);
	    if (type_n==RoseBin_support::ToString(SgGraph::cfg))
	       vec.push_back(target);
	    //else 
	    //   printf("Different edge type \n");
      }
    } else {
      printf("This is not a DirectedGraphEdge.\n");
      assert(edge);
    }
  }
}

void
SgIncidenceDirectedGraph::getPredecessors(SgGraphNode* node, std::vector <SgGraphNode*>& vec ) {
  //SgGraphEdgeList* gredges = get_edgesIn();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesIn();
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    //fails
    //	  get_edgesIn()->get_edges().equal_range(node);
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    if (edge) {
      SgGraphNode* source = isSgGraphNode(edge->get_from());
      if (source) {
	string type_n = getProperty(SgGraph::type, edge);
	if (type_n==RoseBin_support::ToString(SgGraph::cfg))
	  vec.push_back(source);
      }
    }
  }
}



set<SgDirectedGraphEdge*>
SgIncidenceDirectedGraph::getDirectedEdge(SgGraphNode* src, SgGraphNode* trg) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgDirectedGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    //    SgGraphNode* source = it1->first;
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    SgGraphNode* target = isSgGraphNode(edge->get_to());
    if (target==trg)
      medges.insert(edge);
  }
  return medges;
}


bool
SgIncidenceDirectedGraph::checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg) {
  if (src==NULL)
    return false;
  if (trg==NULL)
    return false;
  //  assert(src);
  //assert(src->get_index());
    
  //  SgGraphEdgeList* gedges = get_edgesOut();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesOut();
  bool exists = false;
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter = 
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    SgGraphNode* target = isSgGraphNode(edge->get_to());
    if (target==trg)
      exists=true;
  }
  return exists;
}



SOURCE_INCIDENCE_DIRECTED_GRAPH_END




SOURCE_NAME_GROUP_START
const SgStringList &
SgNameGroup::get_name_list() const
   {
     return p_name_list;
   }

SgStringList &
SgNameGroup::get_name_list()
   {
     return p_name_list;
   }
SOURCE_NAME_GROUP_END


SOURCE_COMMON_BLOCK_OBJECT_START
SOURCE_COMMON_BLOCK_OBJECT_END


SOURCE_DIMENSION_OBJECT_START
SOURCE_DIMENSION_OBJECT_END


SOURCE_DATA_STATEMENT_GROUP_START

const SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list() const
   {
     return p_object_list;
   }

SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list()
   {
     return p_object_list;
   }

const SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list() const
   {
     return p_value_list;
   }

SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list()
   {
     return p_value_list;
   }

SOURCE_DATA_STATEMENT_GROUP_END

SOURCE_DATA_STATEMENT_OBJECT_START
SOURCE_DATA_STATEMENT_OBJECT_END

SOURCE_DATA_STATEMENT_VALUE_START

void
SgDataStatementValue::post_construction_initialization()
   {
#if 0
     printf ("Inside of SgDataStatementValue::post_construction_initialization() initializer_list = %p \n",p_initializer_list);
     if (p_initializer_list == NULL)
        {
          p_initializer_list = new SgExprListExp();
          p_initializer_list->set_parent(this);
        }
#endif
   }
 
SOURCE_DATA_STATEMENT_VALUE_END


SOURCE_FORMAT_ITEM_START
SOURCE_FORMAT_ITEM_END


SOURCE_FORMAT_ITEM_LIST_START

const SgFormatItemPtrList &
SgFormatItemList::get_format_item_list() const
   {
     return p_format_item_list;
   }
 
SgFormatItemPtrList &
SgFormatItemList::get_format_item_list()
   {
     return p_format_item_list;
   }

void
SgFormatItemList::set_format_item_list ( const SgFormatItemPtrList & formatItemList )
   {
     p_format_item_list = formatItemList;
   }
 

SOURCE_FORMAT_ITEM_LIST_END

SOURCE_OPENCL_ACCESS_MODE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isReadOnly() const { return p_modifier == e_read_only; }
void $CLASSNAME::setReadOnly()      { p_modifier = e_read_only; }

bool $CLASSNAME::isWriteOnly() const { return p_modifier == e_write_only; }
void $CLASSNAME::setWriteOnly()      { p_modifier = e_write_only; }

bool $CLASSNAME::isReadWrite() const { return p_modifier == e_read_write; }
void $CLASSNAME::setReadWrite()      { p_modifier = e_read_write; }

std::ostream & operator<< ( std::ostream & os, $CLASSNAME & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isReadOnly() = ")  + std::string(isReadOnly()  ? "true " : "false ");
     s += std::string("isWriteOnly() = ") + std::string(isWriteOnly() ? "true " : "false ");
     s += std::string("isReadWrite() = ") + std::string(isReadWrite() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }


SOURCE_OPENCL_ACCESS_MODE_MODIFIER_END


SOURCE_TYPE_TABLE_START

/* \brief Hash table of types (table is stored on global scope).

   Hash table of types (table is stored on global scope and includes types
   from all scopes). Types are placed into and retrieved from this data 
   base (simple hash table) of SgTypes.
 */
SgTypeTable::SgTypeTable ()
   {
  // DQ (2/19/2007): Use a much larger size symbol table for the function types (the input value is the hash table size, which should be a prime number)!
  // p_function_type_table = new SgSymbolTable();
     p_type_table = new SgSymbolTable(1001);
     ROSE_ASSERT(p_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_type_table->set_parent(this);
   }

#if 0
// DQ (2/19/2007): This appears to not be called but is here because 
// the ROSETTA code requires it (I think).
void
SgTypeTable::post_construction_initialization()
   {
   }
#endif

void
SgTypeTable::print_typetable(std::ostream& os)
   {
  // printf ("ERROR: Sage $CLASSNAME::print_functypetable function called! \n");
  // abort();

     os << endl << "...TypeTbl..." << endl;
  // p_type_table.print(os);

     ROSE_ASSERT(p_type_table != NULL);
  // p_type_table->print(os);
     p_type_table->print("Called from $CLASSNAME::print_typetable");
   }

void
SgTypeTable::insert_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_type_table != NULL);
     ROSE_ASSERT (t != NULL);

  // DQ (7/22/2010): We might want to reuse the SgFunctionTypeSymbol or change the name of it to SgTypeSymbol
     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);
#if 0
  // DQ (7/29/2010): This can sometimes fail in unparsing types.  This is important becasse we now support type tables in ROSE.
     printf ("Inside of SgTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s = %s newSymbol = %p \n",
             n.str(),t->sage_class_name(),t->unparseToString().c_str(),newSymbol);
#endif
#if 0
  // DQ (7/29/2010): This is more robust for the new type table support.
     printf ("Inside of SgTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s newSymbol = %p \n",
             n.str(),t->sage_class_name(),newSymbol);
#endif
  // printf ("Is the qualified name being used! \n");
  // ROSE_ASSERT(false);

  // DQ (7/26/2010): Set the parent of the type to it symbol.
  // This is a new idea and will allow the parent pointer to be valid for all types and also 
  // point to something meaningful.  This is another benefit of using the type table idea.
     t->set_parent(newSymbol);

     p_type_table->insert(n, newSymbol);
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgTypeTable::remove_type(const SgName& n)
   {
     ROSE_ASSERT (p_type_table != NULL);
     p_type_table->remove_function_type(n);
   }

#if 0
// see if this is ever used!
void
SgTypeTable::insert_type(const SgFunctionDeclaration *fdecl)
   {
     assert(fdecl != NULL);
     printf ("Inside of SgTypeTable::insert_function_type(SgFunctionDeclaration = %s) \n",fdecl->get_name().str());
     SgFunctionType* type = isSgFunctionType(fdecl->get_type());
     ROSE_ASSERT(type != NULL);

     SgName n = type->get_mangled_type();
  // printf ("Using function name = %s  should be using qualified function type name \n",n.str());

     printf ("Looking up %s in function table \n",n.str());
     if (lookup_function_type(n) != NULL)
        {
          printf ("Found function %s (skip reinsertion) \n",n.str());
       // return; // DQ: no need for multiple return!
        }
       else
        {
       // printf ("Function NOT Found: so insert in table %s \n",n.str());
          insert_function_type(n,type);
        }
   }
#endif

SgType*
SgTypeTable::lookup_type(const SgName& n)
   {
  // printf ("In SgTypeTable::lookup_function_type: Looking for %s \n",n.str());
     ROSE_ASSERT (p_type_table != NULL);
  // SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(p_function_type_table->findfunctype(n));
     SgSymbol *symbol = p_type_table->find_function_type(n);
     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);
     SgType* returnType = NULL;

     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
       // printf ("In SgTypeTable::lookup_function_type(): found function type %s \n",returnType->class_name().c_str());
        }

     return returnType;
   }

SOURCE_TYPE_TABLE_END
