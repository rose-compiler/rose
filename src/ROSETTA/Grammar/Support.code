// Support functions for definition of C++ grammar (SAGE 3)

HEADER_START
  // This is part of the SgSupport class definition

  // DQ (4/13/2004): Make the copy constructor parameter a const ref instead of just ref parameter
  // previously was protected so it couldn't be used (too easily).
     private:
          $CLASSNAME(const $CLASSNAME &); /* private so it can't be used. */
          $CLASSNAME & operator= ( const $CLASSNAME & X );

        private:
                friend class boost::serialization::access;
                template<class S>
                void serialize(S &s, const unsigned /*version*/) {
                        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgNode);
                        // No data members are serialized at this time, but this serialization function needs to be
                        // defined because SgSupport is an indirect base class of SgBinaryComposite, which is
                        // serializable.
                }
HEADER_END


// ****************************************************
// ************ Support for Graph IR nodes ************
// ****************************************************
HEADER_GRAPH_PREDECLARATION_START

/*!
    Doxygen documentation for graph class (should maybe be put with the rest of the
doxygen documentation in docs/testDoxygen directory instead).


*/
HEADER_GRAPH_PREDECLARATION_END

HEADER_OMP_CLAUSE_START
  /*!\brief  OpenMP default clause values
       */

       // Liao (5/30/2009): Added support for reduction clauses within an OpenMP directive
  enum omp_default_option_enum{
    e_omp_default_unknown =0,
    //4 values for default clause
    //C/C++ default values
    e_omp_default_none,
    e_omp_default_shared,
    //Fortran default values
    e_omp_default_private,
    e_omp_default_firstprivate,
    e_omp_default_last
  };

        enum omp_schedule_kind_enum{
          e_omp_schedule_unknown = 0,
          e_omp_schedule_static,
          e_omp_schedule_dynamic,
          e_omp_schedule_guided,
          e_omp_schedule_auto,
          e_omp_schedule_runtime,
          e_omp_schedule_last
        };

        enum omp_reduction_operator_enum
        {
            e_omp_reduction_unknown,
            // reduction operations
            //8 operand for C/C++
             //  shared 3 common operators for both C and Fortran
            e_omp_reduction_plus, //+
            e_omp_reduction_mul,  //*
            e_omp_reduction_minus, // -

            e_omp_reduction_bitand, // &
            e_omp_reduction_bitor,  // |
            e_omp_reduction_bitxor,  // ^
            e_omp_reduction_logand,  // &&
            e_omp_reduction_logor,   // ||

            e_omp_reduction_and, // .and.
            e_omp_reduction_or, // .or.
            e_omp_reduction_eqv,   // fortran .eqv.
            e_omp_reduction_neqv,   // fortran .neqv.
            e_omp_reduction_max,
            e_omp_reduction_min,
            e_omp_reduction_iand,
            e_omp_reduction_ior,
            e_omp_reduction_ieor,
            e_omp_reduction_last
        };

        enum omp_dependence_type_enum
        {
            e_omp_depend_unknown,
            e_omp_depend_in,
            e_omp_depend_out,
            e_omp_depend_inout,
            e_omp_depend_last
        };

        // Liao 1/22/2012: experimental support for OpenMP Accelerator model
        enum omp_map_operator_enum
        {
          e_omp_map_unknown,
          e_omp_map_alloc,
          e_omp_map_to,
          e_omp_map_from,
          e_omp_map_tofrom,
          e_omp_map_last
        };

        // Liao, 11/11/2015: experimental support for data distribution policies
        enum omp_map_dist_data_enum
        {
          e_omp_map_dist_data_unknown,
          e_omp_map_dist_data_duplicate,
          e_omp_map_dist_data_block,
          e_omp_map_dist_data_cyclic,
          e_omp_map_dist_data_last
        };

        // Support thread affinity clause  proc_bind(master|close|spread)
        enum omp_proc_bind_policy_enum
        {
          e_omp_proc_bind_policy_unknown,
          e_omp_proc_bind_policy_master,
          e_omp_proc_bind_policy_close,
          e_omp_proc_bind_policy_spread,
          e_omp_proc_bind_policy_last
        };

        enum omp_atomic_clause_enum
        {
          e_omp_atomic_clause_unknown,
          e_omp_atomic_clause_read,
          e_omp_atomic_clause_write,
          e_omp_atomic_clause_update,
          e_omp_atomic_clause_capture
        };



HEADER_OMP_CLAUSE_END
HEADER_GRAPH_START

      /*! \brief Edge Type

          Values used to indicate types of edges used for program analysis.
       */
          enum GraphEdgeType
             {
            // DQ (4/29/2009): Added an error value
               e_type_error, /*!< error value */
               none,         /*!< none ??? */
               cfg,          /*!< edge used for Control Flow Graph */
               usage,        /*!< usage??? */
               e_last_type   /*!< last value (unused, serves as upper bound on values) */
             };

      /*! \brief Graph Properties

          Values used to indicate types of graphs used for program analysis.
       */
          enum GraphProperties
             {
            // DQ (4/29/2009): Added an error value
               e_property_error,    /*!< error value */
               name,                /*!< name of the node */
               type,                /*!< name of the node */
               nodest_jmp,          /*!< this a jump without dest */
               itself_call,         /*!< this call calls itself */
               nodest_call,         /*!< call without dest */
               interrupt,           /*!< interrupt (int) */
               eval,                /*!< dfa : evaluation */
               regs,                /*!< dfa : registers */
               done,                /*!< dfa : indicates that this node has successfully been visited */
               dfa_standard,        /*!< dfa_standard_node color */  // dfa_standard_node color
               dfa_resolved_func,   /*!< a function that has been resolved by dfa */
               dfa_unresolved_func, /*!< a function that cant be resolved by dfa */
               dfa_variable,        /*!< defines the variable found by dfa */
               dfa_conditional_def, /*!< specifies the nodes that are defines but also conditional instructions */
               edgeLabel,           /*!< ??? */
               visitedCounter,      /*!< counts the amount of a node being visited during dfa */
               variable,            /*!< stores the string of the variable */
               dfa_bufferoverflow,  /*!< indicates buffer overflow */
               e_last_property      /*!< last value (unused, serves as upper bound on values) */
             };


 //! Simple edge type used to input data to Boost algorithms
     typedef std::pair<int, int> BoostEdgeType;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
  // We need this local type so that the member access functions for data members of this type can be resolved.
     typedef std::vector<BoostEdgeType> SgBoostEdgeList;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
     typedef std::vector<int> SgBoostEdgeWeightList;

     int hashCode( const char* p, int len) const; // hash a character array
     void append_properties( int addr, const std::string & prop );

 //! Support for adding SgGraphNode to SgGraph.
     SgGraphNode* addNode( const std::string & name = "", SgNode* sg_node = NULL);

 //! Add support for externally build SgGraphNode objects
     SgGraphNode* addNode( SgGraphNode* node );

 //! Support for adding SgGraphEdge to SgGraph.
     SgGraphEdge* addEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgGraphEdge* addEdge( SgGraphEdge* edge );

     void post_construction_initialization() override;

 //! Support for Boost Minimum Spanning Tree.
     std::vector <SgGraphEdge*> generateSpanningTree();

     std::string getProperty(SgGraph::GraphProperties property, SgGraphNode* node);
     std::string getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge);
     void setProperty(SgGraph::GraphProperties property, SgGraphNode* node, std::string value);
     void setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge, std::string value);

     void checkIfGraphNodeExists(const std::string& trg_mnemonic, std::vector<SgGraphNode*>& nodes);

 //! Check if the node is present in the graph.
     bool exists( SgGraphNode* node );

 //! Check if the edge is present in the graph.
     bool exists( SgGraphEdge* edge );

 //! Builds a set of edges that are associated with a specific node.
     std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );

  //! Integer index version of "std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );"
     std::set<int> computeEdgeSet( int node_index );

 //! Build set of node index pairs associated with node index (one of the value of the pair will be equal to the input node_index).
     std::set< std::pair<int,int> > computeNodeIndexPairSet( int node_index );

 //! Builds a set of node index values associated with a label.
     std::set<SgGraphNode*> computeNodeSet( const std::string & label );

 //! Builds a set of all nodes in the graph.
     std::set<SgGraphNode*> computeNodeSet();

  //! Integer index version of "std::set<SgGraphNode*> computeNodeSet( const std::string & label );"
     std::set<int> computeNodeIndexSet( const std::string & label );

  // Number of nodes in graph.
     size_t numberOfGraphNodes() const;

  // Number of edges in graph.
     size_t numberOfGraphEdges() const;

     void display_node_index_to_edge_multimap() const;
     void display_node_index_to_node_map() const;
     void display_edge_index_to_edge_map() const;
     void display_node_index_pair_to_edge_multimap() const;
     void display_string_to_node_index_multimap() const;
     void display_string_to_edge_index_multimap() const;

#ifdef ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY
     void display_nodes() const;
     void display_edges() const;
#endif

//! Resize the internal hash tables based on the number of nodes (hash_maps and hash_multimaps for edges are made larger by multiplying by the value "numberOfEdges" ).
     void resize_hash_maps( size_t numberOfNodes, size_t numberOfEdges = 10 );

  //! Report the size in bytes of the graph (includes all edges and ndes from all hash_maps and hash_multimaps).
     size_t memory_usage();

HEADER_GRAPH_END


HEADER_GRAPH_POSTDECLARATION_START


// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
// We need this global type so that the member access functions (defined outside the class)
// for data members of this type can be resolved.
typedef SgGraph::SgBoostEdgeList SgBoostEdgeList;
typedef SgBoostEdgeList* SgBoostEdgeListPtr;

// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
typedef SgGraph::SgBoostEdgeWeightList SgBoostEdgeWeightList;
typedef SgBoostEdgeWeightList* SgBoostEdgeWeightListPtr;


HEADER_GRAPH_POSTDECLARATION_END


HEADER_GRAPHNODE_START
     void append_properties( int addr, const std::string & prop );
     void post_construction_initialization() override;
HEADER_GRAPHNODE_END


HEADER_GRAPHEDGE_START
     void append_properties( int addr, const std::string & prop );
     void post_construction_initialization() override;
HEADER_GRAPHEDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraphEdge(std::string name, std::string type, int n, SgGraphNode* from, SgGraphNode* to);

          SgGraphNode* get_from() { return p_node_A; }
          SgGraphNode* get_to()   { return p_node_B; }
HEADER_DIRECTED_GRAPH_EDGE_END


HEADER_GRAPH_NODE_START
HEADER_GRAPH_NODE_END


HEADER_GRAPH_NODE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<std::string,SgGraphNode*, rose_hash::hash_string, rose_hash::eqstr_string> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_NODE_LIST_END


HEADER_GRAPH_EDGE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<SgGraphNode*,SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_EDGE_LIST_END


HEADER_UNDIRECTED_GRAPH_EDGE_START
          SgGraphNode* get_node1() { return p_node_A; }
          SgGraphNode* get_node2() { return p_node_B; }
HEADER_UNDIRECTED_GRAPH_EDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
HEADER_DIRECTED_GRAPH_EDGE_END


HEADER_INCIDENCE_UNDIRECTED_GRAPH_START
HEADER_INCIDENCE_UNDIRECTED_GRAPH_END


HEADER_INCIDENCE_DIRECTED_GRAPH_START
  // tps (4/30/2009): The following are functions on the graph that were used before
  // in the old graph implementation
      std::set<SgGraphEdge*> getEdge(SgGraphNode* src);
      bool checkIfGraphEdgeExists(SgGraphNode* src);

     void post_construction_initialization() override;

 //! Support for adding SgGraphEdge to SgGraph.
     SgDirectedGraphEdge* addDirectedEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgDirectedGraphEdge* addDirectedEdge( SgDirectedGraphEdge* edge  );

 //! Remove an edge from graph
     bool removeDirectedEdge( SgDirectedGraphEdge* edge  );

  // tps (4/30/2009): Added to support functionality for DirectedGraphs
     void getSuccessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const;
     void getPredecessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const;
     std::set<SgDirectedGraphEdge*> getDirectedEdge(SgGraphNode* src, SgGraphNode* trg);
     bool checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg);

  // DQ (8/18/2009): Added support for construction of sets of edges.
     std::set<SgDirectedGraphEdge*> computeEdgeSetIn( SgGraphNode* node );
     std::set<int> computeEdgeSetIn( int node_index );
     std::set<SgDirectedGraphEdge*> computeEdgeSetOut( SgGraphNode* node );
     std::set<int> computeEdgeSetOut( int node_index );

HEADER_INCIDENCE_DIRECTED_GRAPH_END


HEADER_BIDIRECTIONAL_GRAPH_START
HEADER_BIDIRECTIONAL_GRAPH_END


HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_END


HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_END



// *********************************************************
// ************ Support for Type Modifier nodes ************
// *********************************************************
HEADER_MODIFIER_START
          SgModifier ( const SgModifier & X );
          SgModifier & operator= ( const SgModifier & X );

       // bit handling support used by many derived classes
          bool checkBit ( unsigned int bit, const SgBitVector & bitVector ) const;
          void setBit   ( unsigned int bit,       SgBitVector & bitVector ) const;
          void unsetBit ( unsigned int bit,       SgBitVector & bitVector ) const;

HEADER_MODIFIER_END


HEADER_MODIFIER_NODES_START
          SgModifierNodes();
      // ~SgModifierNodes();

          void post_construction_initialization() override;

       // DQ (2/12/2007): This function is not used.
       // SgModifierType* match(SgType*, unsigned int);

       // DQ (2/4/2006): Added mechamism to clear all bits
       // void reset();

HEADER_MODIFIER_NODES_END

HEADER_CV_TYPE_MODIFIER_START

       // const_volatile specifiers (const, volatile)

      /*! \brief Const Volatile Modifier

          Must be either const, volatile, or neither.

          \internal Bit values can support multiple values in a single enum type
       */
          enum cv_modifier_enum
             {
               e_unknown,        /*!< Unknown value (error value) */
               e_default,        /*!< Default value (default) */
               e_const,          /*!< Const qualifier */
               e_volatile,       /*!< Volatile qualifier */
               e_const_volatile, /*!< Const and Volatile qualifier */

            // DQ (8/11/2011): Added support for Java "transient" modifier.
               e_java_transient, /*!< Java transient qualifier (specifies no serialization of declaration) */

               e_last_modifier /*!< last value (unused, serves as upper bound on values) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

       // DQ (3/21/2005): the default setting is non-const and non-volatile
          bool isDefault() const;
          void setDefault();

          bool isConst() const;
          void setConst();

       // DQ (3/21/2005): We could have a design with no unset function since the cv data is not a bit vector
       // the design reflects that a CV modifier is either const or volatile or neither.
       // Thus unsetting const would be to set the default value.
          void unsetConst();

          bool isVolatile() const;
          void setVolatile();
       // DQ (3/21/2005): See comment for unsetConst() above
          void unsetVolatile();

       // DQ (8/11/2011): Java support.
          bool isJavaTransient() const;
          void setJavaTransient();
          void unsetJavaTransient();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgConstVolatileModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_CV_TYPE_MODIFIER_END

HEADER_STORAGE_MODIFIER_START

       // storage specifiers (auto, static, register, extern, mutable)

       // C++ grammar defines storage modifier to be only: auto, static, register, extern, mutable

       // DQ (4/6/2004): Added to provide uniform support for storage modifiers
      /*! \brief Storage Modifiers (only one value can be specified)

          Storage modifiers are used to specify location or properties of declarations.
          For example, static variables in functions are stored in global scope, register
          variables are a hint to store the value in a CPU register (mosty ignored by
          modern compilers).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum storage_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_extern        = 2,  /*!< extern storage modifier */
               e_static        = 3,  /*!< static storage modifier */
               e_auto          = 4,  /*!< auto storage value */
               e_unspecified   = 5,  /*!< previous (old) default value, not included in C++ grammar definition of storage modifier */
               e_register      = 6,  /*!< register storage modifier */
               e_mutable       = 7,  /*!< mutable storage modifier */
               e_typedef       = 8,  /*!< not used, not included in C++ grammar definition of storage modifier */
               e_asm           = 9,  /*!< not used, not included in C++ grammar definition of storage modifier */
#ifdef FORTRAN_SUPPORTED
            // included for later FORTRAN support
               e_local         = 10, /*!< Auto or static at back end's preference */
               e_common        = 11, /*!< A COMMON block */
               e_associated    = 12, /*!< Variable is part of an association */
               e_intrinsic     = 13, /*!< Intrinsic function or subroutine */
               e_pointer_based = 14, /*!< Pointee of a POINTER definition */
#endif

            // Rasmussen (02/04/2018): Fortran contiguous array storage attribute
               e_contiguous    = 15, /*!< Contiguous array memory-storage attribute */

            // TV (04/08/2010): Support for CUDA storage modifiers
               e_cuda_global         = 16, /*!< CUDA, in device's global memory */
               e_cuda_constant       = 17, /*!< CUDA, in device's constant memory */
               e_cuda_shared         = 18, /*!< CUDA, in device's shared memory */
               e_cuda_dynamic_shared = 19, /*!< CUDA, in device's shared memory, dynamically allocated */

           // Rasmussen (03/13/2018): New CUDA storage modifiers
               e_cuda_device_memory  = 20, /*!< CUDA, in device's global memory */
               e_cuda_managed        = 21, /*!< CUDA, memory managed between host and device */
               e_cuda_pinned         = 22, /*!< CUDA, in device's texture memory (read only)  */
               e_cuda_texture        = 23, /*!< CUDA, in host's page-locked memory */

            // Rasmussen (04/02/2020): Jovial packing specifiers
               e_packing_none  = 24, /*!< None indicates items are not packed */
               e_packing_mixed = 25, /*!< Mixed indicates a density of packing that can be between N and D */
               e_packing_dense = 26, /*!< Dense indicates dense packing */

               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isExtern() const;
          void setExtern();

          bool isStatic() const;
          void setStatic();

          bool isAuto() const;
          void setAuto();

          bool isUnspecified() const;
          void setUnspecified();

          bool isRegister() const;
          void setRegister();

          bool isMutable() const;
          void setMutable();

       // This is not used (but is present in the EDG AST)
          bool isTypedef() const;
          void setTypedef();

       // This is not used (but is present in the EDG AST)
          bool isAsm() const;
          void setAsm();

       // Rasmussen (02/06/2018): Fortran contiguous array storage attribute
          bool isContiguous() const;
          void setContiguous();

       // Rasmussen (04/02/2020): Jovial packing specifiers
          bool isPackingNone() const;
          void setPackingNone();

          bool isPackingMixed() const;
          void setPackingMixed();

          bool isPackingDense() const;
          void setPackingDense();

       // TV (04/08/2010): Support for CUDA storage modifiers

          bool isCudaGlobal() const;
          void setCudaGlobal();

          bool isCudaConstant() const;
          void setCudaConstant();

          bool isCudaShared() const;
          void setCudaShared();

          bool isCudaDynamicShared() const;
          void setCudaDynamicShared();

       // Rasmussen (03/13/2018): New CUDA storage modifiers

          bool isCudaDeviceMemory() const;
          void setCudaDeviceMemory();

          bool isCudaManaged() const;
          void setCudaManaged();

          bool isCudaPinned() const;
          void setCudaPinned();

          bool isCudaTexture() const;
          void setCudaTexture();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_STORAGE_MODIFIER_END

HEADER_ACCESS_MODIFIER_START

       // access specifiers (private, protected, public)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Access Modifiers (only one value can be specified)

          \internal Only one value can be specified (at least in C and C++)

          \note Added an undefined value for Fortran 90 support.
       */
          enum access_modifier_enum
             {
               e_unknown   = 0,        /*!< error value */
               e_private   = 1,        /*!< private access (local to class members) */
               e_protected = 2,        /*!< protected access (local to class members and membrs of derived classes) */
               e_public    = 3,        /*!< public access (access within enclosing namespace) */
            // DQ (8/11/2020): new code for bug Cxx_tests/test2020_28.C.
               e_default   = 4,        /*!< default value (public access) */  /*NO_STRINGIFY*/
               e_undefined = 5,        /*!< fortran default value */
               e_last_modifier         /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgAccessModifier ( const SgAccessModifier & X );

       // Assignment Operator
          SgAccessModifier & operator= ( const SgAccessModifier & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isPrivate() const;
          void setPrivate();

          bool isProtected() const;
          void setProtected();

          bool isPublic() const;
          void setPublic();

       // DQ (11/24/2007): Added support for Fortran staements to have undefined access (default in modules should not be public (or private))
          bool isUndefined() const;
          void setUndefined();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgAccessModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ACCESS_MODIFIER_END

HEADER_FUNCTION_MODIFIER_START

      /*! \brief Function Modifiers (bitvector implementation permits multiple values to be specified)

          Function modifiers (inline, virtual, pure-virtual, explicit).

          \internal Many values can be specified (when the gnu attributes are included), so the implementation uses an STL bit vector.
       */
          enum function_modifier_enum
             {
            // Multiple values can be specified at one time
            // (e.g. inline and explicit (works in g++!))
               e_unknown            = 0, /*!< error value */
               e_default            = 1, /*!< default value */
               e_inline             = 2, /*!< inlined function */
               e_virtual            = 3, /*!< virtual function */
               e_pure_virtual       = 4, /*!< pure virtual function */
               e_explicit           = 5, /*!< explicit function (avoids type resolution through auto type promotion of function arguments) */
            // e_bind               = 6, /*!< Fortran bind attribute for functions (see also type modifier) */
               e_pure               = 7, /*!< Fortran pure attribute for functions (see also type modifier) */
               e_elemental          = 8, /*!< Fortran elemental attribute for functions (see also type modifier) */
               e_recursive          = 9, /*!< Fortran recursive attribute for functions (see also type modifier) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__constructor__            = 10,/*!< GNU specific attribute for (GNU extension) (a separately stored value permits the priority to be specified). */
               e_gnu_attribute__destructor__             = 11,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__pure__                   = 12,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weak__                   = 13,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 14,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 15,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 16,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__malloc__                 = 17,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__naked__                  = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_instrument_function__ = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_check_memory_usage__  = 20,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noinline__               = 21,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__always_inline__          = 22,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nothrow__                = 23,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 24,/*!< GNU specific attribute for (GNU extension) */

            // TV (04/08/2010): Support for CUDA functions modifiers
               e_cuda_device                 = 25, /*!< CUDA device function called from device */
               e_cuda_kernel                 = 26, /*!< CUDA kernel */
               e_cuda_host                   = 27, /*!< CUDA host function */

            // Rasmussen (03/13/2018): New CUDA function modifiers
               e_cuda_global_function        = 28, /*!< CUDA device function called from host */
               e_cuda_grid_global            = 29, /*!< CUDA device function called from host */

            // TV (05/03/2010): Support for OpenCL functions modifiers
               e_opencl_kernel               = 30, /*!< OpenCL kernel */
               e_opencl_vec_type_hint        = 31, /*!< OpenCL */
               e_opencl_work_group_size_hint = 32, /*!< OpenCL */
               e_opencl_work_group_size_req  = 33, /*!< OpenCL */

            // DQ (8/11/2011): Added support for Java specific function modifiers.
               e_java_native                 = 34, /*!< Java native keyword used for JNI function specification */
               e_java_synchronized           = 35, /*!< Java synchronized keyword used to only allow one thread at a time into a particular section of code */
               e_java_strictfp               = 36, /*!< Java strictfp keyword used to specify strict floating point evaluation by JVM */
               e_java_initializer            = 37, /*!< Java initializer keyword used to specify that this "synthetic" function is, in fact, an initializer block */

            // DQ (4/13/2019): Added C++11 options for function modifiers.
               e_marked_default            = 38, /*!< marked using "= default" syntax (different from default enum value) */
               e_marked_delete             = 39, /*!< marked using "= delete" syntax */

            // Rasmussen (10/26/2019): Jovial function modifier
               e_reentrant                 = 40, /*!< re-entrant function */

               e_last_modifier     /*!< last value (upper bound on range of values, used in error checking) */
             };

          // TV (05/03/2010)

             struct opencl_work_group_size_t {
              unsigned long int x, y, z;
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isInline() const;
          void setInline();
          void unsetInline();

          bool isVirtual() const;
          void setVirtual();
          void unsetVirtual();

          bool isPureVirtual() const;
          void setPureVirtual();
          void unsetPureVirtual();

          bool isExplicit() const;
          void setExplicit();
          void unsetExplicit();

       // DQ (11/21/2007): support for Fortran pure attribute on functions
          bool isPure() const;
          void setPure();
          void unsetPure();

       // DQ (11/30/2007): support for Fortran elemental attribute on functions
          bool isElemental() const;
          void setElemental();
          void unsetElemental();

       // DQ (11/30/2007): support for Fortran recursive attribute on functions
          bool isRecursive() const;
          void setRecursive();
          void unsetRecursive();

       // Rasmussen (10/26/2019): support for Jovial reentrant attribute on functions
          bool isReentrant() const;
          void setReentrant();
          void unsetReentrant();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeConstructor() const;
          void setGnuAttributeConstructor();
          void unsetGnuAttributeConstructor();

          bool isGnuAttributeDestructor() const;
          void setGnuAttributeDestructor();
          void unsetGnuAttributeDestructor();

          bool isGnuAttributePure() const;
          void setGnuAttributePure();
          void unsetGnuAttributePure();

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeMalloc() const;
          void setGnuAttributeMalloc();
          void unsetGnuAttributeMalloc();

          bool isGnuAttributeNaked() const;
          void setGnuAttributeNaked();
          void unsetGnuAttributeNaked();

          bool isGnuAttributeNoInstrumentFunction() const;
          void setGnuAttributeNoInstrumentFunction();
          void unsetGnuAttributeNoInstrumentFunction();

          bool isGnuAttributeNoCheckMemoryUsage() const;
          void setGnuAttributeNoCheckMemoryUsage();
          void unsetGnuAttributeNoCheckMemoryUsage();

          bool isGnuAttributeNoInline() const;
          void setGnuAttributeNoInline();
          void unsetGnuAttributeNoInline();

          bool isGnuAttributeAlwaysInline() const;
          void setGnuAttributeAlwaysInline();
          void unsetGnuAttributeAlwaysInline();

          bool isGnuAttributeNoThrow() const;
          void setGnuAttributeNoThrow();
          void unsetGnuAttributeNoThrow();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

       // TV (04/08/2010): Support for CUDA functions modifiers

          bool isCudaDevice() const;
          void setCudaDevice();
          void unsetCudaDevice();

          bool isCudaKernel() const;
          void setCudaKernel();
          void unsetCudaKernel();

          bool isCudaHost() const;
          void setCudaHost();
          void unsetCudaHost();

       // Rasmussen (03/13/2018): New CUDA function modifiers

          bool isCudaGlobalFunction() const;
          void setCudaGlobalFunction();
          void unsetCudaGlobalFunction();

          bool isCudaGridGlobal() const;
          void setCudaGridGlobal();
          void unsetCudaGridGlobal();

       // TV (05/03/2010): Support for OpenCL functions modifiers

          bool isOpenclKernel() const;
          void setOpenclKernel();
          void unsetOpenclKernel();

          bool hasOpenclVecTypeHint() const;
          void setOpenclVecTypeHint();
          void unsetOpenclVecTypeHint();

          bool hasOpenclWorkGroupSizeHint() const;
          void setOpenclWorkGroupSizeHint();
          void unsetOpenclWorkGroupSizeHint();

          bool hasOpenclWorkGroupSizeReq() const;
          void setOpenclWorkGroupSizeReq();
          void unsetOpenclWorkGroupSizeReq();


       // DQ (8/11/2011): Added support for Java specific function modifiers.
          bool isJavaNative() const;
          void setJavaNative();
          void unsetJavaNative();

          bool isJavaSynchronized() const;
          void setJavaSynchronized();
          void unsetJavaSynchronized();

          bool isJavaStrictfp() const;
          void setJavaStrictfp();
          void unsetJavaStrictfp();

          bool isJavaInitializer() const;
          void setJavaInitializer();
          void unsetJavaInitializer();


       // DQ (4/13/2019): Added C++11 options for function modifiers.
          bool isMarkedDefault() const;
          void setMarkedDefault();
          void unsetMarkedDefault();

       // DQ (4/13/2019): Added C++11 options for function modifiers.
          bool isMarkedDelete() const;
          void setMarkedDelete();
          void unsetMarkedDelete();


          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgFunctionModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_FUNCTION_MODIFIER_END


HEADER_UPC_ACCESS_MODIFIER_START

       // UPC access specifiers (unspecified, shared, strict, relaxed)

      /*! \brief UPC Access Modifiers (only one value can be specified)

          Unified Parallel C modifiers (shared, strict, relaxed).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum upc_access_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown,       /*!< error value */
               e_default,       /*!< default value */
            // DQ and Liao (6/13/2008): "shared" can be used with "strict" and "relaxed" so it must be handled separately.
            // e_upc_shared,    /*!< UPC shared */
               e_upc_strict,    /*!< UPC strict */
               e_upc_relaxed,   /*!< UPC relaxed */
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

       // bool isUPC_Shared() const;
       // void setUPC_Shared();

          bool isUPC_Strict() const;
          void setUPC_Strict();

          bool isUPC_Relaxed() const;
          void setUPC_Relaxed();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgUPC_AccessModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechanism to clear all bits
          void reset();

HEADER_UPC_ACCESS_MODIFIER_END

// Rasmussen (4/4/2020): Added SgStructureModifier for Jovial tables
HEADER_STRUCTURE_MODIFIER_START

       // Jovial structure specifiers (unspecified, parallel, tight)

      /*! \brief Jovial Structure Modifier/Specifier (tight implies serial)

          Jovial Structure Specifier (parallel, tight).

          \internal Only one value can be specified
       */
          enum jovial_structure_modifier_enum
             {
               e_unknown,                    /*!< error value */
               e_default,                    /*!< jovial table structure is unspecified, indicates serial structure */
               e_table_structure_parallel,   /*!< jovial table has parallel structure */
               e_table_structure_tight,      /*!< jovial table has serial structure that is tightly packed */
               e_last_modifier               /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isParallel() const;
          void setParallel();

          bool isTight() const;
          void setTight();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgStructureModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // Clear all bits
          void reset();

HEADER_STRUCTURE_MODIFIER_END


HEADER_SPECIAL_FUNCTION_MODIFIER_START

       // special_function specifiers (constructor, destructor, conversion, operator)

      /*! \brief Special Function Modifiers (only one value can be specified)

          Modifier information about (constructor, destructor, conversion operator (cast operator), and operator (general overloaded operators)).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum special_function_modifier_enum
             {
               e_unknown            = 0,         /*!< error value */
               e_default            = 1,         /*!< Not a special function (default) */
               e_none               = e_default, /*!< Not a special function (default) */ /*NO_STRINGIFY*/
               e_constructor        = 2,         /*!< A constructor */
               e_destructor         = 3,         /*!< A destructor */
               e_conversion         = 4,         /*!< A conversion operator function */
               e_operator           = 5,         /*!< Any other operator function */
               e_uld_operator       = 6,         /*!< ULD operator function (operators on literals) */
               e_lambda_entry_point = 7,   /*!< C++11 lambda support */
               e_last_modifier            /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isNotSpecial() const;
          void setNotSpecial();
          void unsetNotSpecial();

          bool isConstructor() const;
          void setConstructor();
          void unsetConstructor();

          bool isDestructor() const;
          void setDestructor();
          void unsetDestructor();

          bool isConversion() const;
          void setConversion();
          void unsetConversion();

          bool isOperator() const;
          void setOperator();
          void unsetOperator();

          bool isUldOperator() const;
          void setUldOperator();
          void unsetUldOperator();

          bool isLambdaEntryPoint() const;
          void setLambdaEntryPoint();
          void unsetLambdaEntryPoint();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgSpecialFunctionModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_SPECIAL_FUNCTION_MODIFIER_END

HEADER_DECLARATION_MODIFIER_START
       // Support for: storage specifiers, type specifiers, function specifiers,
       //              friend, typedef, export, throw

      /*! \brief Declaration Modifiers (only one value can be specified)

          Modifier information about (friend, typedef, export, and throw).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum declaration_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown       = 0,  /*!< Unknown value (error) */
               e_default       = 1,  /*!< Default value */
               e_friend        = 2,  /*!< Friend qualifier */
               e_typedef       = 3,  /*!< Typedef qualifier (not clear if this is used, I don't think typedef is a modifier) */
               e_export        = 4,  /*!< Export qualifier */
               e_throw         = 5,  /*!< Exception handling support (throw) */
               e_bind          = 6,  /*!< Fortran bind attribute for declarations (functions, variable, and classes) */
               e_final         = 7,  /*!< PHP, Java, and C++11 support for specification to not be extended */
               e_override      = 8,  /*!< C++11 support for specification to not be extended */

            // DQ (8/11/2011): Added support for Java "abstract" declaration modifier.
               e_java_abstract = 9,  /*!< abstract keyword for Java functions, classes and interfaces */

            // Rasmussen (2/26/2020): Added support for Jovial modifiers
               e_jovial_def = 10,         /*!< Definition specification for Jovial declarations */
               e_jovial_ref = 11,         /*!< Reference specification for Jovial declarations */
               e_jovial_static = 12,      /*!< Explicitly marked as STATIC in Jovial */

               e_ms_declspec_align        = 13, /*!< Microsoft declspec() attributes */
               e_ms_declspec_allocate     = 14, /*!< Microsoft declspec() attributes */
               e_ms_declspec_appdomain    = 15, /*!< Microsoft declspec() attributes */
               e_ms_declspec_code_seg     = 16, /*!< Microsoft declspec() attributes */
               e_ms_declspec_deprecated   = 17, /*!< Microsoft declspec() attributes */
               e_ms_declspec_dllimport    = 18, /*!< Microsoft declspec() attributes */
               e_ms_declspec_dllexport    = 19, /*!< Microsoft declspec() attributes */
               e_ms_declspec_jitintrinsic = 20, /*!< Microsoft declspec() attributes */
               e_ms_declspec_naked        = 21, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noalias      = 22, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noinline     = 23, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noreturn     = 24, /*!< Microsoft declspec() attributes */
               e_ms_declspec_nothrow      = 25, /*!< Microsoft declspec() attributes */
               e_ms_declspec_novtable     = 26, /*!< Microsoft declspec() attributes */
               e_ms_declspec_process      = 27, /*!< Microsoft declspec() attributes */
               e_ms_declspec_property     = 28, /*!< Microsoft declspec() attributes */
               e_ms_declspec_restrict     = 29, /*!< Microsoft declspec() attributes */
               e_ms_declspec_safebuffers  = 30, /*!< Microsoft declspec() attributes */
               e_ms_declspec_selectany    = 31, /*!< Microsoft declspec() attributes */
               e_ms_declspec_thread       = 32, /*!< Microsoft declspec() attributes */
               e_ms_declspec_uuid         = 33, /*!< Microsoft declspec() attributes */

            // PP (6/15/2020): Added support for Ada modifiers
               e_ada_abstract = 34,         /*!< Ada abstract declaration */
               e_ada_limited  = 35,         /*!< Ada limited declaration */
               e_ada_tagged   = 36,         /*!< Ada tagged declaration */
               e_ada_separate = 37,         /*!< Ada separate declaration */

               e_last_modifier       /*!< last modifier value (upper bound on range of values, used in error checking) */
             };

      /*! \brief GNU attribute for visability (only one value can be specified)

          visability values are: default, hidden, protected or internal visibility.

          \internal Only one value can be specified (at least in C and C++)
       */
          enum gnu_declaration_visability_enum
             {
               e_unknown_visibility     = 0,  /*!< Unknown value (error) */
               e_error_visibility       = 1,  /*!< Error value (error) */
               e_unspecified_visibility = 2,  /*!< Unspecified visibility (not the default value) */
               e_hidden_visibility      = 3,  /*!< hidden visibility */
               e_protected_visibility   = 4,  /*!< protected visibility */
               e_internal_visibility    = 5,  /*!< internal visibility (not clear if this is used, I don't think typedef is a modifier) */
               e_default_visibility     = 6,  /*!< default visibility */
               e_last_visibility_attribute /*!< last visibility attribute (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgDeclarationModifier ( const SgDeclarationModifier & X );

       // Assignment Operator
          SgDeclarationModifier & operator= ( const SgDeclarationModifier & X );

          void post_construction_initialization() override;

          SgTypeModifier    & get_typeModifier();
          SgAccessModifier  & get_accessModifier();
          SgStorageModifier & get_storageModifier();

          const SgTypeModifier    & get_typeModifier() const;
          const SgAccessModifier  & get_accessModifier() const;
          const SgStorageModifier & get_storageModifier() const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isFriend() const;
          void setFriend();
          void unsetFriend();

          bool isTypedef() const;
          void setTypedef();
          void unsetTypedef();

          bool isExport() const;
          void setExport();
          void unsetExport();

          bool isThrow() const;
          void setThrow();
          void unsetThrow();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // PHP, Java, and C++11 specific attribute
          bool isFinal() const;
          void setFinal();
          void unsetFinal();

       // C++11 specific attribute
          bool isOverride() const;
          void setOverride();
          void unsetOverride();

       // DQ (8/11/2011): Added Java specific "abstract" attribute.
          bool isJavaAbstract() const;
          void setJavaAbstract();
          void unsetJavaAbstract();

       // Rasmussen (2/26/2020): Added Jovial Def and Ref specifications plus an explicitly static attribute
          bool isJovialDef() const;
          void setJovialDef();
          void unsetJovialDef();

          bool isJovialRef() const;
          void setJovialRef();
          void unsetJovialRef();

          bool isJovialStatic() const;
          void setJovialStatic();
          void unsetJovialStatic();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_align() const;
          void set_ms_declspec_align();
          void unset_ms_declspec_align();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_allocate() const;
          void set_ms_declspec_allocate();
          void unset_ms_declspec_allocate();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_appdomain() const;
          void set_ms_declspec_appdomain();
          void unset_ms_declspec_appdomain();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_code_seg() const;
          void set_ms_declspec_code_seg();
          void unset_ms_declspec_code_seg();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_deprecated() const;
          void set_ms_declspec_deprecated();
          void unset_ms_declspec_deprecated();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_dllimport() const;
          void set_ms_declspec_dllimport();
          void unset_ms_declspec_dllimport();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_dllexport() const;
          void set_ms_declspec_dllexport();
          void unset_ms_declspec_dllexport();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_jitintrinsic() const;
          void set_ms_declspec_jitintrinsic();
          void unset_ms_declspec_jitintrinsic();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_naked() const;
          void set_ms_declspec_naked();
          void unset_ms_declspec_naked();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noalias() const;
          void set_ms_declspec_noalias();
          void unset_ms_declspec_noalias();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noinline() const;
          void set_ms_declspec_noinline();
          void unset_ms_declspec_noinline();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noreturn() const;
          void set_ms_declspec_noreturn();
          void unset_ms_declspec_noreturn();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_nothrow() const;
          void set_ms_declspec_nothrow();
          void unset_ms_declspec_nothrow();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_novtable() const;
          void set_ms_declspec_novtable();
          void unset_ms_declspec_novtable();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_process() const;
          void set_ms_declspec_process();
          void unset_ms_declspec_process();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_property() const;
          void set_ms_declspec_property();
          void unset_ms_declspec_property();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_restrict() const;
          void set_ms_declspec_restrict();
          void unset_ms_declspec_restrict();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_safebuffers() const;
          void set_ms_declspec_safebuffers();
          void unset_ms_declspec_safebuffers();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_selectany() const;
          void set_ms_declspec_selectany();
          void unset_ms_declspec_selectany();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_thread() const;
          void set_ms_declspec_thread();
          void unset_ms_declspec_thread();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_uuid() const;
          void set_ms_declspec_uuid();
          void unset_ms_declspec_uuid();

       // PP (06/15/2020): Adding Ada declaration modifiers
          bool isAdaAbstract() const;
          void setAdaAbstract();
          void unsetAdaAbstract();

          bool isAdaLimited() const;
          void setAdaLimited();
          void unsetAdaLimited();

          bool isAdaTagged() const;
          void setAdaTagged();
          void unsetAdaTagged();

       // PP (02/22/2022): Adding Ada modifier for stubs
          bool isAdaSeparate() const;
          void setAdaSeparate();
          void unsetAdaSeparate();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgDeclarationModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_DECLARATION_MODIFIER_END

HEADER_TYPE_MODIFIER_START

       // type specifier (elaborated-type-specifier, cv-qualifier, restrict)

       // DQ (9/7/2007): Added Fortran specific values to handle Fortran attribute specifiers.
       // DQ (4/6/2004): Added to provide uniform support for type modifiers
      /*! \brief Type Modifiers (multiple values can be specified at one time)

          Type modifier information about used for C/C++ and Fortran 77/90/2003.
          For Fortran values, each rerpesents a Fortran attribute specifier from section 5.1
          of the Fortran 2003 standard.

          \internal These are used in a SgBitVector so that multiple values may be specified.
       */
          enum type_modifier_enum
             {
               e_unknown        = 0, /*!< Unknown value (error) */
               e_default        = 1, /*!< Unknown value (default) */
               e_restrict       = 2, /*!< Restrict qualifier (for C/C++) */

            // Fortran specific modifiers (in Fortran these are called attribute specifiers)
            // Note that public and private access attributes are mapped to the C/C++ access modifiers in SgDeclarationModifier
            // e_public_access  = 3, /*!< public qualifier (for Fortran 90) */
            // e_private_access = 4, /*!< private qualifier (for Fortran 90) */
               e_allocatable    = 3, /*!< allocatable attribute specifier (for Fortran 90) */
               e_asynchronous   = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
               e_bind           = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
               e_data           = 6, /*!< data attribute specifier (for Fortran 77) */
               e_dimension      = 7, /*!< dimension attribute specifier (for Fortran 77) */
            // This should map to the C/C++ extern modifier in SgStorageModifier
            // e_external       = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
               e_intent_in      = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
               e_intent_out     = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
               e_intent_inout   = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
               e_intrinsic      = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
               e_optional       = 12,/*!< optional attribute specifier (for Fortran 90) */

            // DQ (8/28/2010): Added support for Fortran 90 type attributes (bind already present, and access-spec handled by C/C++ access modifiers in SgDeclarationModifier
               e_extends       = 13,/*!< optional attribute specifier (for Fortran 90) */
               e_abstract      = 14,/*!< optional attribute specifier (for Fortran 90) */

            // This should map to const in the SgConstVolatileModifier
            // e_parameter      = xx,/*!< parameter attribute specifier (for Fortran 77) */

            // This should be mapped to the SgPointerType in C/C++
            // e_pointer        = xx,/*!< pointer attribute specifier (for Fortran 90) */
            // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
            // e_protected      = xx,/*!< protected attribute specifier (for Fortran 2003) */
               e_save           = 15,/*!< save attribute specifier (for Fortran 77) */
               e_target         = 16,/*!< target attribute specifier (for Fortran 90) */
               e_value          = 17,/*!< value attribute specifier (for Fortran 2003) */
            // This should map to volatile in the SgConstVolatileModifier
            // e_volatile       = xx,/*!< volatile attribute specifier (for Fortran 2003) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__unused__             = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__packed__             = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__         = 20,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__  = 21,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noreturn__           = 22,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__const__              = 23,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__cdecl__              = 24,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__stdcall__            = 25,/*!< GNU specific attribute for function type (GNU extension) */

            // DQ (1/3/2009): New GNU attributes not previously supported in ROSE
               e_gnu_attribute__warn_unused_result__ = 26,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__nonnull__            = 27,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__sentinel__           = 28,/*!< GNU specific attribute for function type (GNU extension) */

            // TV (02/27/2012): Address space modifer
               e_address_space__                     = 29,/*!< address space modifier, get_address_space_value() give the associated param */

            // TV (02/27/2012): OpenCL related Modifier
               e_ocl_global__                        = 30,/*!< OpenCL specific address space modifier */
               e_ocl_local__                         = 31,/*!< OpenCL specific address space modifier */
               e_ocl_constant__                      = 32,/*!< OpenCL specific address space modifier */

            // TV (03/03/2012): Address space modifer
               e_vector_type__                       = 33,/*!< GCC vector type attribute and other vector extentions */

            // DQ (1/24/2016): New GNU attributes not previously supported in ROSE (added to support custom device specification on types).
            // This is part of an experiment to support a new feature in CUDA that would allow device specification in the function parameter type.
            // I am not certain that it should not already exist, but we don't have it implemented in ROSE.  EDG appears to drop the "__device__"
            // keyword, so I am trying to capture it as an attribute.
               e_gnu_attribute__device__             = 34,/*!< Using GNU support for general attributes in the contect of parameter type (ROSE extension using GNU attribute extension) */

            // Rasmussen (3/1/2020): numeric type specifiers for Jovial
               e_round                               = 35,/*!< Jovial rounding specifier */
               e_truncate                            = 36,/*!< Jovial truncation specifier */
               e_truncate_towards_zero               = 37,/*!< Jovial truncation towards zero specifier */

            // PP (7/7/21): add support for Ada aliased declarations
               e_aliased                             = 38,/*!< Ada aliased variable/parameter/field declaration */
            // PP (2/16/24): add support for Ada null exclusion
               e_notnull                             = 39,/*!< Ada not null access types */

            // Last attribute enum (used for internal bounds checking)
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // DQ (12/4/2007): Added support for gnu attributes representing machine modes (for types)
      /*! \brief GNU Extension Machine Mode type modifiers (only a single value can be specified at one time)

          Machine modes type modifier (required for rather exotic levels of source-to-source transformation in Linux.
          See http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes for lots of details.

          \internal These are used in an enum type (and I expect that this makes the storage over head small since the range is explicit).
       */
          enum gnu_extension_machine_mode_enum
             {
               e_gnu_extension_machine_mode_unknown     = 0, /*!< Unknown value (error) */
               e_gnu_extension_machine_mode_unspecified = 1, /*!< Unknown value (default) */
               e_gnu_extension_machine_mode_BImode      = 2, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QImode      = 3, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HImode      = 4, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PSImode     = 5, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SImode      = 6, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PDImode     = 7, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DImode      = 8, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TImode      = 9, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_OImode      = 10, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QFmode      = 11, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HFmode      = 12, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQFmode     = 13, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SFmode      = 14, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DFmode      = 15, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XFmode      = 16, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SDmode      = 17, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DDmode      = 18, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TDmode      = 19, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TFmode      = 20, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QQmode      = 21, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HQmode      = 22, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SQmode      = 23, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DQmode      = 24, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQmode      = 25, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UQQmode     = 26, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHQmode     = 27, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USQmode     = 28, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDQmode     = 29, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTQmode     = 30, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HAmode      = 31, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SAmode      = 32, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DAmode      = 33, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TAmode      = 34, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHAmode     = 35, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USAmode     = 36, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDAmode     = 37, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTAmode     = 38, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CCmode      = 39, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_BLKmode     = 40, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_VOIDmode    = 41, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QCmode      = 42, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HCmode      = 43, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SCmode      = 44, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DCmode      = 45, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XCmode      = 46, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TCmode      = 47, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CQImode     = 48, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CHImode     = 49, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CSImode     = 50, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CDImode     = 51, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CTImode     = 52, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_COImode     = 53, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_last_machine_mode /*!< last machine mode value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

       // Convert a single type_modifier_enum to an initializer
       // SgTypeModifier ( const SgTypeModifier::type_modifier_enum & m );

          void post_construction_initialization() override;

          SgUPC_AccessModifier     & get_upcModifier();
          SgConstVolatileModifier  & get_constVolatileModifier();
          SgElaboratedTypeModifier & get_elaboratedTypeModifier();

       // RV (2/2/2006): Added 'const' versions of above member functions.
          const SgUPC_AccessModifier     & get_upcModifier(void) const;
          const SgConstVolatileModifier  & get_constVolatileModifier(void) const;
          const SgElaboratedTypeModifier & get_elaboratedTypeModifier(void) const;

          SgStructureModifier            & get_structureModifier();
          const SgStructureModifier      & get_structureModifier() const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isRestrict() const;
          void setRestrict();
          void unsetRestrict();

       // Fortran specific attribute
          bool isAllocatable() const;
          void setAllocatable();
          void unsetAllocatable();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // Fortran specific attribute
          bool isAsynchronous() const;
          void setAsynchronous();
          void unsetAsynchronous();

       // Fortran specific attribute
          bool isData() const;
          void setData();
          void unsetData();

       // Fortran specific attribute
          bool isDimension() const;
          void setDimension();
          void unsetDimension();

       // Fortran specific attribute
          bool isIntent_in() const;
          void setIntent_in();
          void unsetIntent_in();

       // Fortran specific attribute
          bool isIntent_out() const;
          void setIntent_out();
          void unsetIntent_out();

       // Fortran specific attribute
          bool isIntent_inout() const;
          void setIntent_inout();
          void unsetIntent_inout();

       // Fortran specific attribute
          bool isIntrinsic() const;
          void setIntrinsic();
          void unsetIntrinsic();

       // Fortran specific attribute
          bool isOptional() const;
          void setOptional();
          void unsetOptional();

       // Fortran specific attribute
          bool isSave() const;
          void setSave();
          void unsetSave();

       // Fortran specific attribute
          bool isTarget() const;
          void setTarget();
          void unsetTarget();

       // Fortran specific attribute
          bool isValue() const;
          void setValue();
          void unsetValue();

       // Fortran specific attribute
          bool isExtends() const;
          void setExtends();
          void unsetExtends();

       // Fortran specific attribute
          bool isAbstract() const;
          void setAbstract();
          void unsetAbstract();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributePacked() const;
          void setGnuAttributePacked();
          void unsetGnuAttributePacked();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeNoReturn() const;
          void setGnuAttributeNoReturn();
          void unsetGnuAttributeNoReturn();

          bool isGnuAttributeConst() const;
          void setGnuAttributeConst();
          void unsetGnuAttributeConst();

          bool isGnuAttributeCdecl() const;
          void setGnuAttributeCdecl();
          void unsetGnuAttributeCdecl();

          bool isGnuAttributeStdcall() const;
          void setGnuAttributeStdcall();
          void unsetGnuAttributeStdcall();

          bool isGnuAttributeWarnUnusedResult() const;
          void setGnuAttributeWarnUnusedResult();
          void unsetGnuAttributeWarnUnusedResult();

          bool isGnuAttributeNonnull() const;
          void setGnuAttributeNonnull();
          void unsetGnuAttributeNonnull();

          bool isGnuAttributeSentinel() const;
          void setGnuAttributeSentinel();
          void unsetGnuAttributeSentinel();

          bool haveAddressSpace() const;
          void setAddressSpace();
          void unsetAddressSpace();

          bool isOpenclGlobal() const;
          void setOpenclGlobal();
          void unsetOpenclGlobal();

          bool isOpenclLocal() const;
          void setOpenclLocal();
          void unsetOpenclLocal();

          bool isOpenclConstant() const;
          void setOpenclConstant();
          void unsetOpenclConstant();

          bool isVectorType() const;
          void setVectorType();
          void unsetVectorType();

          bool isGnuAttributeDevice() const;
          void setGnuAttributeDevice();
          void unsetGnuAttributeDevice();

       // Jovial specific attribute
          bool isRound() const;
          void setRound();
          void unsetRound();

       // Jovial specific attribute
          bool isTruncate() const;
          void setTruncate();
          void unsetTruncate();

       // Jovial specific attribute
          bool isTruncateTowardsZero() const;
          void setTruncateTowardsZero();
          void unsetTruncateTowardsZero();

       // Ada attribute for aliased variables, parameters, and components
          bool isAliased() const;
          void setAliased();
          void unsetAliased();

       // Ada attribute for not null access types
          bool isNotNull() const;
          void setNotNull();
          void unsetNotNull();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgTypeModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

       // DQ (11/28/2015): We need a better way to support equivalents and difference in the SgTypeModifier.
          bool isIdentity() const;

HEADER_TYPE_MODIFIER_END

HEADER_ELABORATED_TYPE_MODIFIER_START
       // elaborated-type-specifier (class, struct, union, enum, typename, typename template)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Elaborated Type Modifiers (only one value can be specified)

          Modifier information about (class,struct, union, enum, and typename).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum elaborated_type_modifier_enum
             {
            // Only one value can be specified ???
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value (default) */
               e_class    = 2, /*!< class type */
               e_struct   = 3, /*!< struct type */
               e_union    = 4, /*!< union type */
               e_enum     = 5, /*!< enum type */
               e_typename = 6, /*!< typename type */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isClass() const;
          void setClass();

          bool isStruct() const;
          void setStruct();

          bool isUnion() const;
          void setUnion();

          bool isEnum() const;
          void setEnum();

          bool isTypename() const;
          void setTypename();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgElaboratedTypeModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ELABORATED_TYPE_MODIFIER_END

HEADER_LINKAGE_MODIFIER_START

       // linkage-specification (extern, extern "C", extern "C++", extern "Fortran")

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Linkage Modifiers (only one value can be specified)

          Modifier information about (C linkage, C++ linkage, Fortran linkage, and Fortran 90 linkage).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum linkage_modifier_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_C_linkage         = 2, /*!< C linkage */
               e_Cpp_linkage       = 3, /*!< C++ linkage */
               e_fortran_linkage   = 4, /*!< FORTRAN linkage (not really used yet) */
               e_fortran90_linkage = 5, /*!< FORTRAN 90 linkage (not really used yet) */
               e_last_modifier        /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isC_Linkage() const;
          void setC_Linkage();

          bool isCppLinkage() const;
          void setCppLinkage();

          bool isFortranLinkage() const;
          void setFortranLinkage();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgLinkageModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_LINKAGE_MODIFIER_END

HEADER_BASECLASS_MODIFIER_START
       // base-class-specifier (virtual, access specifiers)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Baseclass Modifiers (only one value can be specified)

          Modifier information about (virtual or not).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum baseclass_modifier_enum
             {
            // Only one value can be specified (at least in C, what about C++)
               e_unknown = 0,  /*!< error value */
               e_default = 1,  /*!< default value */
               e_virtual = 2,  /*!< virtual value */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          SgAccessModifier & get_accessModifier();
          const SgAccessModifier & get_accessModifier() const;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isVirtual() const;
          void setVirtual();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgBaseClassModifier & m );
      friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_BASECLASS_MODIFIER_END



HEADER_ATTRIBUTE_SUPPORT_START

     /* name Persistant Attribute Mechanism

         This is the persistant attribute mechanism for attaching attributes to IR nodes across
         multiple passes. Note that these attributes are persistant in that they are preserved
         if the AST is written out to a file and read in from a file.  However, virtual function
         in the user-defined class derived from the AstAttribute must be defined for the attribute
         to be defined across the boundary of File I/O (simple pack and unpack functions).  More
         sophisticated mechanisms are available within the AstAttributeMechanism object
         (e.g iterating though attributes, etc; get_attributeMechanism() is available if direct
         access is required, however mostly only internal tools use this lower level support).

         \internal This used to be a public data member, but has been changed to be a protected
         pointer instead.  The functional interface of the AstAttributeMechanism is presevered
         but some of the names and the syntax for calling the interface have changed. The
         pointer to the AstAttributeMechanism is now generated by ROSETTA.
      */
     /* */
     //! Add a new attribute represented by the named string.
         virtual void addNewAttribute(std::string s,AstAttribute* a) override;
     //! Returns attribute of name 's'.
         virtual AstAttribute* getAttribute(std::string s) const override;
     //! Replace existing attribute of name 's' with new AstAttribute.
         virtual void updateAttribute(std::string s,AstAttribute* a) override;  // formerly called: replace in AstAttributeMechanism
     /*! \brief This is a wrapper function with the following semantics:
         if no attribute of name 's' exists then \b addNewAttribute(s,a); is called,
         otherwise \b updateAttribute(s,a); is called.
      */
         virtual void setAttribute(std::string s,AstAttribute* a) override;
     //! Remove attribute of name 's' if present.
         virtual void removeAttribute(std::string s) override;
     //! Tests if attribute of name 's' is present.
         virtual bool attributeExists(std::string s) const override;
     //! Returns the number of attributes on this IR node.
         virtual int numberOfAttributes() const override;

     /*! \fn AstAttributeMechanism* $CLASSNAME::get_attributeMechanism() const;
         \brief \b FOR \b INTERNAL \b USE Access function; if an attribute exists then
                a pointer to it is returned, else error.

         This is an access function used for getting the interally held pointer to a valid
         AstAttributeMechanism. It provides access to lower level functionality of the
         AstAttributeMechanism, put is mostly of use to internal tools.
      */
     /*! \fn void $CLASSNAME::set_attributeMechanism(AstAttributeMechanism* a);
         \brief \b FOR \b INTERNAL \b USE Access function; sets poiner to value AstAttributeMechanism.

         This is an access function used for setting the interally held pointer to a valid
         AstAttributeMechanism.
      */
     /* */


HEADER_ATTRIBUTE_SUPPORT_END


HEADER_NAME_GROUP_START
          const SgStringList & get_name_list() const;
          SgStringList & get_name_list();
HEADER_NAME_GROUP_END


HEADER_COMMON_BLOCK_OBJECT_START
HEADER_COMMON_BLOCK_OBJECT_END


HEADER_DIMENSION_OBJECT_START
HEADER_DIMENSION_OBJECT_END


HEADER_DATA_STATEMENT_GROUP_START

          const SgDataStatementObjectPtrList & get_object_list() const;
          SgDataStatementObjectPtrList & get_object_list();

          const SgDataStatementValuePtrList & get_value_list() const;
          SgDataStatementValuePtrList & get_value_list();

HEADER_DATA_STATEMENT_GROUP_END

HEADER_DATA_STATEMENT_OBJECT_START
HEADER_DATA_STATEMENT_OBJECT_END

HEADER_DATA_STATEMENT_VALUE_START

      //! Support for Fortran data statement
          enum data_statement_value_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_explicit_list     = 2, /*!< list of value expressions */
               e_implicit_list     = 3, /*!< repeat-count * value */
               e_implied_do        = 4, /*!< implied do loop initializer */
               e_last_initializer_form  /*!< last value (upper bound on range of values, used in error checking) */
             };

          void post_construction_initialization() override;

HEADER_DATA_STATEMENT_VALUE_END


HEADER_FORMAT_ITEM_START
HEADER_FORMAT_ITEM_END


HEADER_FORMAT_ITEM_LIST_START

          const SgFormatItemPtrList & get_format_item_list() const;
          SgFormatItemPtrList & get_format_item_list();
          void set_format_item_list ( const SgFormatItemPtrList & formatItemList );

HEADER_FORMAT_ITEM_LIST_END


HEADER_TYPE_TABLE_START
          $CLASSNAME ();
          void insert_type(const SgName&, SgType *);

          SgType* lookup_type (const SgName&);

       // DQ (7/22/2010): Added to support AST merge.
          void remove_type(const SgName&);

          void print_typetable(std::ostream& os = std::cout);

HEADER_TYPE_TABLE_END


SOURCE_ATTRIBUTE_SUPPORT_START

void
$CLASSNAME::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
$CLASSNAME::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          ROSE_ASSERT(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
$CLASSNAME::getAttribute(std::string s) const
   {
     //assert(get_attributeMechanism() != NULL); // Liao, bug 130 6/4/2008
     if (attributeExists(s)==false) return NULL;
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     ROSE_ASSERT(returnValue != NULL);
     return returnValue;
   }

void
$CLASSNAME::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     ROSE_ASSERT(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
$CLASSNAME::removeAttribute(std::string s)
   {
     if (get_attributeMechanism())
         get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
$CLASSNAME::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
$CLASSNAME::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }

SOURCE_ATTRIBUTE_SUPPORT_END


SOURCE_MODIFIER_START

SgModifier::SgModifier ( const SgModifier & X )
   {
  // DQ (4/13/2004): Nothing to do here, but this function prevents the SgSupport copy
  // constructor from being called and we would like to keep that copy constructor
  // private so that we can enforce error checking via the type system.
   }

SgModifier &
SgModifier::operator= ( const SgModifier & X )
   {
     return *this;
   }

bool
SgModifier::checkBit ( unsigned int bit, const SgBitVector & bitVector ) const
   {
     ROSE_ASSERT (bit < bitVector.size());
     return bitVector[bit];
   }

void
SgModifier::setBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     ROSE_ASSERT (bit < bitVector.size());
     bitVector[bit] = true;
   }

void
SgModifier::unsetBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     ROSE_ASSERT (bit < bitVector.size());
     bitVector[bit] = false;
   }

SOURCE_MODIFIER_END


SOURCE_MODIFIER_NODES_START

// These are generated
SgModifierNodes::SgModifierNodes()
   {
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // p_next = (SgModifierNodes*)0L;
  // MK: Call the following function instead
     post_construction_initialization();
   }

void
SgModifierNodes::post_construction_initialization()
   {
  // nodes = new (SgModifierType*)[4];
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // MK: p_nodes is an STL vector now, it needs to be initilized differently
     for (int i= 0; i<4; i++)
          p_nodes.push_back((SgModifierType*) NULL);
     p_next = (SgModifierNodes*) NULL;
   }

SOURCE_MODIFIER_NODES_END


SOURCE_CV_TYPE_MODIFIER_START

$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isConst() const { return p_modifier == e_const || p_modifier == e_const_volatile; }
void $CLASSNAME::setConst()      { p_modifier = (p_modifier == e_volatile) ? e_const_volatile : e_const; }
void $CLASSNAME::unsetConst()    { p_modifier = (p_modifier == e_const_volatile) ? e_volatile : e_default; }

bool $CLASSNAME::isVolatile() const { return p_modifier == e_volatile || p_modifier == e_const_volatile; }
void $CLASSNAME::setVolatile()      { p_modifier = (p_modifier == e_const) ? e_const_volatile : e_volatile; }
void $CLASSNAME::unsetVolatile()    { p_modifier = (p_modifier == e_const_volatile) ? e_const : e_default; }

// DQ (8/11/2011): Added support for Java "transient" keyword to disable serialization.
bool $CLASSNAME::isJavaTransient() const { return p_modifier == e_java_transient; }
void $CLASSNAME::setJavaTransient()      { p_modifier = e_java_transient; }
void $CLASSNAME::unsetJavaTransient()    { setDefault(); }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")       + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")       + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isConst() = ")         + std::string(isConst()    ? "true " : "false ");
     s += std::string("isVolatile() = ")      + std::string(isVolatile() ? "true " : "false ");

     s += std::string("isJavaTransient() = ") + std::string(isJavaTransient() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgConstVolatileModifier & m)
   {
     os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
  return
         (lhs.isUnknown()  == rhs.isUnknown() ) &&
         (lhs.isDefault()  == rhs.isDefault() ) &&
         (lhs.isConst()    == rhs.isConst()   ) &&
         (lhs.isVolatile() == rhs.isVolatile()) ;
   }


// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_CV_TYPE_MODIFIER_END


SOURCE_STORAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isExtern() const { return p_modifier == e_extern; }
void $CLASSNAME::setExtern()      { p_modifier = e_extern; }

bool $CLASSNAME::isStatic() const { return p_modifier == e_static; }
void $CLASSNAME::setStatic()      { p_modifier = e_static; }

bool $CLASSNAME::isAuto() const { return p_modifier == e_auto; }
void $CLASSNAME::setAuto()      { p_modifier = e_auto; }

bool $CLASSNAME::isUnspecified() const { return p_modifier == e_unspecified; }
void $CLASSNAME::setUnspecified()      { p_modifier = e_unspecified; }

// This is not used (but is present in the EDG AST)
bool $CLASSNAME::isTypedef() const { return p_modifier == e_typedef; }
void $CLASSNAME::setTypedef()      { p_modifier = e_typedef; }

bool $CLASSNAME::isRegister() const { return p_modifier == e_register; }
void $CLASSNAME::setRegister()      { p_modifier = e_register; }

bool $CLASSNAME::isMutable() const { return p_modifier == e_mutable; }
void $CLASSNAME::setMutable()      { p_modifier = e_mutable; }

bool $CLASSNAME::isAsm() const { return p_modifier == e_asm; }
void $CLASSNAME::setAsm()      { p_modifier = e_asm; }

#ifdef FORTRAN_SUPPORTED
// These remaining access functions are specific to FORTRAN
bool $CLASSNAME::isLocal() const { return p_modifier == e_local; }
void $CLASSNAME::setLocal()      { p_modifier = e_local; }

bool $CLASSNAME::isCommon() const { return p_modifier == e_common; }
void $CLASSNAME::setCommon()      { p_modifier = e_common; }

bool $CLASSNAME::isAssociated() const { return p_modifier == e_associated; }
void $CLASSNAME::setAssociated()      { p_modifier = e_associated; }

bool $CLASSNAME::isIntrinsic() const { return p_modifier == e_intrinsic; }
void $CLASSNAME::setIntrinsic()      { p_modifier = e_intrinsic; }

bool $CLASSNAME::isPointerBased() const { return p_modifier == e_pointer_based; }
void $CLASSNAME::setPointerBased()      { p_modifier = e_pointer_based; }
#endif

// Rasmussen (02/04/2018): Fortran contiguous array storage attribute
bool SgStorageModifier::isContiguous() const { return p_modifier == e_contiguous; }
void SgStorageModifier::setContiguous()      {        p_modifier  = e_contiguous; }

// Rasmussen (04/02/2020): Jovial packing specifiers
bool SgStorageModifier::isPackingNone() const  { return p_modifier == e_packing_none; }
void SgStorageModifier::setPackingNone()       {        p_modifier  = e_packing_none; }

bool SgStorageModifier::isPackingMixed() const { return p_modifier == e_packing_mixed; }
void SgStorageModifier::setPackingMixed()      {        p_modifier  = e_packing_mixed; }

bool SgStorageModifier::isPackingDense() const { return p_modifier == e_packing_dense; }
void SgStorageModifier::setPackingDense()      {        p_modifier  = e_packing_dense; }

// TV (08/04/2010): Support for CUDA storage modifiers

bool SgStorageModifier::isCudaGlobal() const { return p_modifier == e_cuda_global; }
void SgStorageModifier::setCudaGlobal()      { p_modifier = e_cuda_global; }

bool SgStorageModifier::isCudaConstant() const { return p_modifier == e_cuda_constant; }
void SgStorageModifier::setCudaConstant()      { p_modifier = e_cuda_constant; }

bool SgStorageModifier::isCudaShared() const { return p_modifier == e_cuda_shared; }
void SgStorageModifier::setCudaShared()      { p_modifier = e_cuda_shared; }

bool SgStorageModifier::isCudaDynamicShared() const { return p_modifier == e_cuda_dynamic_shared; }
void SgStorageModifier::setCudaDynamicShared()      { p_modifier = e_cuda_dynamic_shared; }

// Rasmussen (03/13/2018): New CUDA storage modifiers

bool SgStorageModifier::isCudaDeviceMemory() const { return p_modifier == e_cuda_device_memory; }
void SgStorageModifier::setCudaDeviceMemory()      {        p_modifier  = e_cuda_device_memory; }

bool SgStorageModifier::isCudaManaged()      const { return p_modifier == e_cuda_managed; }
void SgStorageModifier::setCudaManaged()           {        p_modifier  = e_cuda_managed; }

bool SgStorageModifier::isCudaPinned()       const { return p_modifier == e_cuda_pinned; }
void SgStorageModifier::setCudaPinned()            {        p_modifier  = e_cuda_pinned; }

bool SgStorageModifier::isCudaTexture()      const { return p_modifier == e_cuda_texture; }
void SgStorageModifier::setCudaTexture()           {        p_modifier  = e_cuda_texture; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isExtern() = ")       + std::string(isExtern()       ? "true " : "false ");
     s += std::string("isStatic() = ")       + std::string(isStatic()       ? "true " : "false ");
     s += std::string("isAuto() = ")         + std::string(isAuto()         ? "true " : "false ");
     s += std::string("isUnspecified() = ")  + std::string(isUnspecified()  ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isRegister() = ")     + std::string(isRegister()     ? "true " : "false ");
     s += std::string("isMutable() = ")      + std::string(isMutable()      ? "true " : "false ");
     s += std::string("isAsm() = ")          + std::string(isAsm()          ? "true " : "false ");
#ifdef FORTRAN_SUPPORTED
     s += std::string("isLocal() = ")        + std::string(isLocal()        ? "true " : "false ");
     s += std::string("isCommon() = ")       + std::string(isCommon()       ? "true " : "false ");
     s += std::string("isAssociated() = ")   + std::string(isAssociated()   ? "true " : "false ");
     s += std::string("isIntrinsic() = ")    + std::string(isIntrinsic()    ? "true " : "false ");
     s += std::string("isPointerBased() = ") + std::string(isPointerBased() ? "true " : "false ");
#endif
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()        == rhs.isUnknown() ) &&
         (lhs.isDefault()        == rhs.isDefault() ) &&
         (lhs.isExtern()         == rhs.isExtern()  ) &&
         (lhs.isStatic()         == rhs.isStatic()  ) &&
         (lhs.isAuto()           == rhs.isAuto()  ) &&
         (lhs.isUnspecified()    == rhs.isUnspecified()  ) &&
         (lhs.isRegister()       == rhs.isRegister()  ) &&
         (lhs.isMutable()        == rhs.isMutable()  ) &&
         (lhs.isTypedef()        == rhs.isTypedef()  ) &&
         (lhs.isAsm()            == rhs.isAsm()  ) &&
         (lhs.isContiguous()     == rhs.isContiguous()  ) &&
         (lhs.isCudaGlobal()     == rhs.isCudaGlobal()  ) &&
         (lhs.isCudaConstant()   == rhs.isCudaConstant()) &&
         (lhs.isCudaShared()     == rhs.isCudaShared()  ) &&
         (lhs.isCudaManaged()    == rhs.isCudaManaged() ) &&
         (lhs.isCudaPinned()     == rhs.isCudaPinned()  ) &&
         (lhs.isCudaTexture()    == rhs.isCudaTexture() ) &&
         (lhs.isCudaDynamicShared() == rhs.isCudaDynamicShared() ) &&
         (lhs.isCudaDeviceMemory()  == rhs.isCudaDeviceMemory()  ) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_STORAGE_MODIFIER_END

SOURCE_ACCESS_MODIFIER_START

// Copy constructor
SgAccessModifier::SgAccessModifier ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgAccessModifier &
SgAccessModifier::operator= ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgAccessModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgAccessModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgAccessModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgAccessModifier::isDefault() const { return p_modifier == e_default; }
void SgAccessModifier::setDefault()      { p_modifier = e_default; }

bool SgAccessModifier::isPrivate() const { return p_modifier == e_private; }
void SgAccessModifier::setPrivate()      { p_modifier = e_private; }

bool SgAccessModifier::isProtected() const { return p_modifier == e_protected; }
void SgAccessModifier::setProtected()      { p_modifier = e_protected; }

bool SgAccessModifier::isPublic() const { return p_modifier == e_public; }
void SgAccessModifier::setPublic()      { p_modifier = e_public; }

bool SgAccessModifier::isUndefined() const { return p_modifier == e_undefined; }
void SgAccessModifier::setUndefined()      { p_modifier = e_undefined; }

string
SgAccessModifier::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isPrivate() = ")   + std::string(isPrivate()   ? "true " : "false ");
     s += std::string("isProtected() = ") + std::string(isProtected() ? "true " : "false ");
     s += std::string("isPublic() = ")    + std::string(isPublic()    ? "true " : "false ");
     s += std::string("isUndefined() = ") + std::string(isUndefined() ? "true " : "false ");
     s += ")";
     return s;
   }

void
SgAccessModifier::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgAccessModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()  == rhs.isUnknown() ) &&
         (lhs.isDefault()  == rhs.isDefault() ) &&
         (lhs.isPrivate()  == rhs.isPrivate() ) &&
         (lhs.isProtected()== rhs.isProtected()) &&
         (lhs.isPublic()   == rhs.isPublic()  ) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void SgAccessModifier::reset()
   {
     setDefault();
   }

SOURCE_ACCESS_MODIFIER_END


SOURCE_FUNCTION_MODIFIER_START
// Copy constructor
SgFunctionModifier::$CLASSNAME ( const SgFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

SgFunctionModifier &
SgFunctionModifier::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
SgFunctionModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgFunctionModifier::isUnknown() const { return checkBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::setUnknown()      { setBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::unsetUnknown()    { unsetBit(e_unknown,p_modifierVector); }

bool SgFunctionModifier::isDefault() const { return checkBit(e_default,p_modifierVector); }
void SgFunctionModifier::setDefault()      { setBit(e_default,p_modifierVector); }
void SgFunctionModifier::unsetDefault()    { unsetBit(e_default,p_modifierVector); }

bool SgFunctionModifier::isInline() const { return checkBit(e_inline,p_modifierVector); }
void SgFunctionModifier::setInline()      { setBit(e_inline,p_modifierVector); }
void SgFunctionModifier::unsetInline()    { unsetBit(e_inline,p_modifierVector); }

bool SgFunctionModifier::isVirtual() const { return checkBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::setVirtual()      { setBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::unsetVirtual()    { unsetBit(e_virtual,p_modifierVector); }

bool SgFunctionModifier::isPureVirtual() const { return checkBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::setPureVirtual()      { setBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::unsetPureVirtual()    { unsetBit(e_pure_virtual,p_modifierVector); }

bool SgFunctionModifier::isExplicit() const { return checkBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::setExplicit()      { setBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::unsetExplicit()    { unsetBit(e_explicit,p_modifierVector); }

bool SgFunctionModifier::isPure() const { return checkBit(e_pure,p_modifierVector); }
void SgFunctionModifier::setPure()      { setBit(e_pure,p_modifierVector); }
void SgFunctionModifier::unsetPure()    { unsetBit(e_pure,p_modifierVector); }

bool SgFunctionModifier::isElemental() const { return checkBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::setElemental()      { setBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::unsetElemental()    { unsetBit(e_elemental,p_modifierVector); }

bool SgFunctionModifier::isRecursive() const { return checkBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::setRecursive()      { setBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::unsetRecursive()    { unsetBit(e_recursive,p_modifierVector); }

// Rasmussen (10/26/2019): Added Jovial specific attribute
bool SgFunctionModifier::isReentrant() const { return checkBit(e_reentrant,p_modifierVector); }
void SgFunctionModifier::setReentrant()      { setBit(e_reentrant,p_modifierVector); }
void SgFunctionModifier::unsetReentrant()    { unsetBit(e_reentrant,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeConstructor() const { return checkBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeConstructor()      { setBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeConstructor()    { unsetBit(e_gnu_attribute__constructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDestructor() const { return checkBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDestructor()      { setBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDestructor()    { unsetBit(e_gnu_attribute__destructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributePure() const { return checkBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributePure()      { setBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributePure()    { unsetBit(e_gnu_attribute__pure__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeMalloc() const { return checkBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeMalloc()      { setBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeMalloc()    { unsetBit(e_gnu_attribute__malloc__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNaked() const { return checkBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNaked()      { setBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNaked()    { unsetBit(e_gnu_attribute__naked__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInstrumentFunction() const { return checkBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInstrumentFunction()      { setBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInstrumentFunction()    { unsetBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoCheckMemoryUsage() const { return checkBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoCheckMemoryUsage()      { setBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoCheckMemoryUsage()    { unsetBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInline() const { return checkBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInline()      { setBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInline()    { unsetBit(e_gnu_attribute__noinline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeAlwaysInline() const { return checkBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeAlwaysInline()      { setBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeAlwaysInline()    { unsetBit(e_gnu_attribute__always_inline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoThrow() const { return checkBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoThrow()      { setBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoThrow()    { unsetBit(e_gnu_attribute__nothrow__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__,p_modifierVector); }

// TV (04/08/2010): Support for CUDA functions modifiers
bool SgFunctionModifier::isCudaDevice() const { return checkBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::setCudaDevice()      { setBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::unsetCudaDevice()    { unsetBit(e_cuda_device,p_modifierVector); }

bool SgFunctionModifier::isCudaKernel() const { return checkBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::setCudaKernel()      { setBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::unsetCudaKernel()    { unsetBit(e_cuda_kernel,p_modifierVector); }

bool SgFunctionModifier::isCudaHost() const { return checkBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::setCudaHost()      { setBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::unsetCudaHost()    { unsetBit(e_cuda_host,p_modifierVector); }

// Rasmussen (03/13/2018): New CUDA function modifiers
bool SgFunctionModifier::isCudaGlobalFunction() const { return checkBit(e_cuda_global_function,p_modifierVector); }
void SgFunctionModifier::setCudaGlobalFunction()      {          setBit(e_cuda_global_function,p_modifierVector); }
void SgFunctionModifier::unsetCudaGlobalFunction()    {        unsetBit(e_cuda_global_function,p_modifierVector); }

bool SgFunctionModifier::isCudaGridGlobal() const { return checkBit(e_cuda_grid_global,p_modifierVector); }
void SgFunctionModifier::setCudaGridGlobal()      {          setBit(e_cuda_grid_global,p_modifierVector); }
void SgFunctionModifier::unsetCudaGridGlobal()    {        unsetBit(e_cuda_grid_global,p_modifierVector); }

// TV (05/03/2010): Support for OpenCL functions modifiers
bool SgFunctionModifier::isOpenclKernel() const { return checkBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::setOpenclKernel()      { setBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::unsetOpenclKernel()    { unsetBit(e_opencl_kernel, p_modifierVector); }

bool SgFunctionModifier::hasOpenclVecTypeHint() const { return checkBit(e_opencl_vec_type_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclVecTypeHint()       { setBit(e_opencl_vec_type_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclVecTypeHint()     { unsetBit(e_opencl_vec_type_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeHint() const { return checkBit(e_opencl_work_group_size_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeHint()       { setBit(e_opencl_work_group_size_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclWorkGroupSizeHint()     { unsetBit(e_opencl_work_group_size_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeReq() const { return checkBit(e_opencl_work_group_size_req, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeReq()       { setBit(e_opencl_work_group_size_req,p_modifierVector);}
void SgFunctionModifier::unsetOpenclWorkGroupSizeReq()     { unsetBit(e_opencl_work_group_size_req, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaNative() const { return checkBit(e_java_native, p_modifierVector); }
void SgFunctionModifier::setJavaNative()      { setBit(e_java_native, p_modifierVector); }
void SgFunctionModifier::unsetJavaNative()    { unsetBit(e_java_native, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaSynchronized() const { return checkBit(e_java_synchronized, p_modifierVector); }
void SgFunctionModifier::setJavaSynchronized()      { setBit(e_java_synchronized, p_modifierVector); }
void SgFunctionModifier::unsetJavaSynchronized()    { unsetBit(e_java_synchronized, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaStrictfp() const { return checkBit(e_java_strictfp, p_modifierVector); }
void SgFunctionModifier::setJavaStrictfp()      { setBit(e_java_strictfp, p_modifierVector); }
void SgFunctionModifier::unsetJavaStrictfp()    { unsetBit(e_java_strictfp, p_modifierVector); }

// PC (07/24/2012): Added support for Java specific feature: Initializer blocks.
bool SgFunctionModifier::isJavaInitializer() const { return checkBit(e_java_initializer, p_modifierVector); }
void SgFunctionModifier::setJavaInitializer()      { setBit(e_java_initializer, p_modifierVector); }
void SgFunctionModifier::unsetJavaInitializer()    { unsetBit(e_java_initializer, p_modifierVector); }


// DQ (4/13/2019): Added C++11 options for function modifiers.
bool SgFunctionModifier::isMarkedDefault() const { return checkBit(e_marked_default, p_modifierVector); }
void SgFunctionModifier::setMarkedDefault()      { setBit(e_marked_default, p_modifierVector); }
void SgFunctionModifier::unsetMarkedDefault()    { unsetBit(e_marked_default, p_modifierVector); }

// DQ (4/13/2019): Added C++11 options for function modifiers.
bool SgFunctionModifier::isMarkedDelete() const { return checkBit(e_marked_delete, p_modifierVector); }
void SgFunctionModifier::setMarkedDelete()      { setBit(e_marked_delete, p_modifierVector); }
void SgFunctionModifier::unsetMarkedDelete()    { unsetBit(e_marked_delete, p_modifierVector); }




string
SgFunctionModifier::displayString() const
   {
     std::string s = "SgFunctionModifier(";
     s += std::string("isUnknown() = ")          + std::string(isUnknown()          ? "true " : "false ");
     s += std::string("isDefault() = ")          + std::string(isDefault()          ? "true " : "false ");
     s += std::string("isInline() = ")           + std::string(isInline()           ? "true " : "false ");
     s += std::string("isVirtual() = ")          + std::string(isVirtual()          ? "true " : "false ");
     s += std::string("isPureVirtual() = ")      + std::string(isPureVirtual()      ? "true " : "false ");
     s += std::string("isExplicit() = ")         + std::string(isExplicit()         ? "true " : "false ");
  // s += std::string("isBind() = ")             + std::string(isBind()             ? "true " : "false ");
     s += std::string("isPure() = ")             + std::string(isPure()             ? "true " : "false ");

  // DQ (2/26/2013): Bug report noticed that a set of these attributes were not properly support.
     s += std::string("isElemental() = ")                        + std::string(isElemental() ? "true " : "false ");
     s += std::string("isRecursive() = ")                        + std::string(isRecursive() ? "true " : "false ");
     s += std::string("isReentrant() = ")                        + std::string(isReentrant() ? "true " : "false ");
     s += std::string("isGnuAttributeConstructor() = ")          + std::string(isGnuAttributeConstructor() ? "true " : "false ");
     s += std::string("isGnuAttributeDestructor() = ")           + std::string(isGnuAttributeDestructor() ? "true " : "false ");
     s += std::string("isGnuAttributePure() = ")                 + std::string(isGnuAttributePure() ? "true " : "false ");
     s += std::string("isGnuAttributeWeak() = ")                 + std::string(isGnuAttributeWeak() ? "true " : "false ");
     s += std::string("isGnuAttributeUnused() = ")               + std::string(isGnuAttributeUnused() ? "true " : "false ");
     s += std::string("isGnuAttributeUsed() = ")                 + std::string(isGnuAttributeUsed() ? "true " : "false ");
     s += std::string("isGnuAttributeDeprecated() = ")           + std::string(isGnuAttributeDeprecated() ? "true " : "false ");
     s += std::string("isGnuAttributeMalloc() = ")               + std::string(isGnuAttributeMalloc() ? "true " : "false ");
     s += std::string("isGnuAttributeNaked() = ")                + std::string(isGnuAttributeNaked() ? "true " : "false ");
     s += std::string("isGnuAttributeNoInstrumentFunction() = ") + std::string(isGnuAttributeNoInstrumentFunction() ? "true " : "false ");
     s += std::string("isGnuAttributeNoCheckMemoryUsage() = ")   + std::string(isGnuAttributeNoCheckMemoryUsage() ? "true " : "false ");
     s += std::string("isGnuAttributeNoInline() = ")             + std::string(isGnuAttributeNoInline() ? "true " : "false ");
     s += std::string("isGnuAttributeAlwaysInline() = ")         + std::string(isGnuAttributeAlwaysInline() ? "true " : "false ");
     s += std::string("isGnuAttributeNoThrow() = ")              + std::string(isGnuAttributeNoThrow() ? "true " : "false ");
     s += std::string("isGnuAttributeWeakReference() = ")        + std::string(isGnuAttributeWeakReference() ? "true " : "false ");

     s += std::string("isJavaNative() = ")       + std::string(isJavaNative()       ? "true " : "false ");
     s += std::string("isJavaSynchronized() = ") + std::string(isJavaSynchronized() ? "true " : "false ");
     s += std::string("isJavaStrictfp() = ")     + std::string(isJavaStrictfp()     ? "true " : "false ");
     s += std::string("isJavaInitializer() = ")  + std::string(isJavaInitializer()  ? "true " : "false ");
     s += ")";
     return s;
   }

void
SgFunctionModifier::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgFunctionModifier & m)
   {
      os << m.get_modifierVector();
     return os;
   }

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv )
   {
  // DQ (1/26/2006): Modified to handle 64 bit machines
  // for (unsigned int i=0; i < bv.size(); i++)
  // for (vector<bool>::size_type i=0; i < bv.size(); i++)
     for (unsigned int i=0; i < bv.size(); i++)
          os << ((bv[i] == true) ? "T" : "F");
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
         (lhs.isUnknown() == rhs.isUnknown() ) &&
         (lhs.isDefault() == rhs.isDefault() ) &&
         (lhs.isInline()  == rhs.isInline()  ) &&
         // C++ specific
         (lhs.isVirtual()     == rhs.isVirtual()    ) &&
         (lhs.isPureVirtual() == rhs.isPureVirtual()) &&
         // Fortran specific
         (lhs.isExplicit()  == rhs.isExplicit() ) &&
         (lhs.isPure()      == rhs.isPure()     ) &&
         (lhs.isElemental() == rhs.isElemental()) &&
         (lhs.isRecursive() == rhs.isRecursive()) &&
         (lhs.isReentrant() == rhs.isReentrant()) &&
         // GNU specific
         (lhs.isGnuAttributeConstructor() == rhs.isGnuAttributeConstructor()) &&
         (lhs.isGnuAttributeDestructor()  == rhs.isGnuAttributeDestructor() ) &&
         (lhs.isGnuAttributePure()        == rhs.isGnuAttributePure()       ) &&
         (lhs.isGnuAttributeWeak()        == rhs.isGnuAttributeWeak()       ) &&
         (lhs.isGnuAttributeUnused()      == rhs.isGnuAttributeUnused()     ) &&
         (lhs.isGnuAttributeUsed()        == rhs.isGnuAttributeUsed()       ) &&
         (lhs.isGnuAttributeDeprecated()  == rhs.isGnuAttributeDeprecated() ) &&
         (lhs.isGnuAttributeMalloc()      == rhs.isGnuAttributeMalloc()     ) &&
         (lhs.isGnuAttributeNaked()       == rhs.isGnuAttributeNaked()      ) &&
         (lhs.isGnuAttributeNoInstrumentFunction() == rhs.isGnuAttributeNoInstrumentFunction()) &&
         (lhs.isGnuAttributeNoCheckMemoryUsage() == rhs.isGnuAttributeNoCheckMemoryUsage()) &&
         (lhs.isGnuAttributeNoInline()           == rhs.isGnuAttributeNoInline()          ) &&
         (lhs.isGnuAttributeAlwaysInline()       == rhs.isGnuAttributeAlwaysInline()      ) &&
         (lhs.isGnuAttributeNoThrow()            == rhs.isGnuAttributeNoThrow()           ) &&
         (lhs.isGnuAttributeWeakReference()      == rhs.isGnuAttributeWeakReference()     ) &&
         // Cuda specific
         (lhs.isCudaDevice()         == rhs.isCudaDevice()) &&
         (lhs.isCudaKernel()         == rhs.isCudaKernel()) &&
         (lhs.isCudaHost()           == rhs.isCudaHost()  ) &&
         (lhs.isCudaGlobalFunction() == rhs.isCudaGlobalFunction()) &&
         (lhs.isCudaGridGlobal()     == rhs.isCudaGridGlobal()) &&
         // OpenCL specific
         (lhs.isOpenclKernel()             == rhs.isOpenclKernel()            ) &&
         (lhs.hasOpenclVecTypeHint()       == rhs.hasOpenclVecTypeHint()      ) &&
         (lhs.hasOpenclWorkGroupSizeHint() == rhs.hasOpenclWorkGroupSizeHint()) &&
         (lhs.hasOpenclWorkGroupSizeReq()  == rhs.hasOpenclWorkGroupSizeReq() ) &&
         (lhs.isJavaNative()               == rhs.isJavaNative()              ) &&
         (lhs.isJavaSynchronized()         == rhs.isJavaSynchronized()        ) &&
         (lhs.isJavaStrictfp()             == rhs.isJavaStrictfp()            ) &&
         (lhs.isJavaInitializer()          == rhs.isJavaInitializer()         ) &&
       true;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgFunctionModifier::reset()
   {
  // Unset each bit separately
     unsetUnknown();
     unsetInline();
     unsetVirtual();
     unsetPureVirtual();
     unsetExplicit();
  // unsetBind();
     unsetPure();

     unsetJavaNative();
     unsetJavaSynchronized();
     unsetJavaStrictfp();
     unsetJavaInitializer();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }

SOURCE_FUNCTION_MODIFIER_END



SOURCE_UPC_ACCESS_MODIFIER_START
// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

// bool $CLASSNAME::isUPC_Shared() const { return p_modifier == e_upc_shared; }
// void $CLASSNAME::setUPC_Shared()      { p_modifier = e_upc_shared; }

bool $CLASSNAME::isUPC_Strict() const { return p_modifier == e_upc_strict; }
void $CLASSNAME::setUPC_Strict()      { p_modifier = e_upc_strict; }

bool $CLASSNAME::isUPC_Relaxed() const { return p_modifier == e_upc_relaxed; }
void $CLASSNAME::setUPC_Relaxed()      { p_modifier = e_upc_relaxed; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
  // s += std::string("isUPC_Shared() = ")  + std::string(isUPC_Shared()  ? "true " : "false ");
     s += std::string("isUPC_Strict() = ")  + std::string(isUPC_Strict()  ? "true " : "false ");
     s += std::string("isUPC_Relaxed() = ") + std::string(isUPC_Relaxed() ? "true " : "false ");

  // DQ (6/13/2008): Added support for layout and shared use with "strict" or "relaxed"
     s += std::string("get_isShared() = ")  + std::string(get_isShared() ? "true " : "false ");
     s += std::string("get_layout() = ")  + Rose::StringUtility::numberToString(get_layout());

     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgUPC_AccessModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()     == rhs.isUnknown()    ) &&
         (lhs.isDefault()     == rhs.isDefault()    ) &&
         (lhs.isUPC_Strict()  == rhs.isUPC_Strict() ) &&
         (lhs.isUPC_Relaxed() == rhs.isUPC_Relaxed()) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_UPC_ACCESS_MODIFIER_END

// Rasmussen (4/4/2020): Added SgStructureModifier for Jovial tables
SOURCE_STRUCTURE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isParallel() const { return p_modifier == e_table_structure_parallel; }
void $CLASSNAME::setParallel()      { p_modifier = e_table_structure_parallel; }

bool $CLASSNAME::isTight()    const { return p_modifier == e_table_structure_tight; }
void $CLASSNAME::setTight()         { p_modifier = e_table_structure_tight; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isParallel() = ")    + std::string(isParallel()    ? "true " : "false ");
     s += std::string("isTight() = ")       + std::string(isTight()       ? "true " : "false ");

     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgStructureModifier & m)
   {
     os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
        return
         (lhs.isUnknown()  == rhs.isUnknown()  ) &&
         (lhs.isDefault()  == rhs.isDefault()  ) &&
         (lhs.isParallel() == rhs.isParallel() ) &&
         (lhs.isTight()    == rhs.isTight()    ) &&
       true;
}

void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_STRUCTURE_MODIFIER_END


SOURCE_SPECIAL_FUNCTION_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool $CLASSNAME::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void $CLASSNAME::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void $CLASSNAME::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool $CLASSNAME::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void $CLASSNAME::setDefault()       { setBit(e_default,p_modifierVector); }
void $CLASSNAME::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool $CLASSNAME::isNotSpecial() const  { return checkBit(e_none,p_modifierVector); }
void $CLASSNAME::setNotSpecial()       { setBit(e_none,p_modifierVector); }
void $CLASSNAME::unsetNotSpecial()     { unsetBit(e_none,p_modifierVector); }

bool $CLASSNAME::isConstructor() const { return checkBit(e_constructor,p_modifierVector); }
void $CLASSNAME::setConstructor()      { setBit(e_constructor,p_modifierVector); }
void $CLASSNAME::unsetConstructor()    { unsetBit(e_constructor,p_modifierVector); }

bool $CLASSNAME::isDestructor() const  { return checkBit(e_destructor,p_modifierVector); }
void $CLASSNAME::setDestructor()       { setBit(e_destructor,p_modifierVector); }
void $CLASSNAME::unsetDestructor()     { unsetBit(e_destructor,p_modifierVector); }

bool $CLASSNAME::isConversion() const  { return checkBit(e_conversion,p_modifierVector); }
void $CLASSNAME::setConversion()       { setBit(e_conversion,p_modifierVector); }
void $CLASSNAME::unsetConversion()     { unsetBit(e_conversion,p_modifierVector); }

bool $CLASSNAME::isOperator() const    { return checkBit(e_operator,p_modifierVector); }
void $CLASSNAME::setOperator()         { setBit(e_operator,p_modifierVector); }
void $CLASSNAME::unsetOperator()       { unsetBit(e_operator,p_modifierVector); }

bool $CLASSNAME::isUldOperator() const    { return checkBit(e_uld_operator,p_modifierVector); }
void $CLASSNAME::setUldOperator()         { setBit(e_uld_operator,p_modifierVector); }
void $CLASSNAME::unsetUldOperator()       { unsetBit(e_uld_operator,p_modifierVector); }

bool $CLASSNAME::isLambdaEntryPoint() const    { return checkBit(e_lambda_entry_point,p_modifierVector); }
void $CLASSNAME::setLambdaEntryPoint()         { setBit(e_lambda_entry_point,p_modifierVector); }
void $CLASSNAME::unsetLambdaEntryPoint()       { unsetBit(e_lambda_entry_point,p_modifierVector); }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isNotSpecial() = ")  + std::string(isNotSpecial()  ? "true " : "false ");
     s += std::string("isConstructor() = ") + std::string(isConstructor() ? "true " : "false ");
     s += std::string("isDestructor() = ")  + std::string(isDestructor()  ? "true " : "false ");
     s += std::string("isConversion() = ")  + std::string(isConversion()  ? "true " : "false ");
     s += std::string("isOperator() = ")    + std::string(isOperator()    ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgSpecialFunctionModifier & m)
   {
      os << m.get_modifierVector();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()     == rhs.isUnknown()    ) &&
         (lhs.isDefault()     == rhs.isDefault()    ) &&
         (lhs.isNotSpecial()  == rhs.isNotSpecial() ) &&
         (lhs.isConstructor() == rhs.isConstructor()) &&
         (lhs.isDestructor()  == rhs.isDestructor() ) &&
         (lhs.isConversion()  == rhs.isConversion() ) &&
         (lhs.isOperator()    == rhs.isOperator()   ) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetNotSpecial();
     unsetConstructor();
     unsetDestructor();
     unsetConversion();
     unsetOperator();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }

SOURCE_SPECIAL_FUNCTION_MODIFIER_END

SOURCE_DECLARATION_MODIFIER_START

// Copy constructor
SgDeclarationModifier::SgDeclarationModifier ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
   }

SgDeclarationModifier &
SgDeclarationModifier::operator= ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
     return *this;
   }

void
SgDeclarationModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgDeclarationModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgDeclarationModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgDeclarationModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgDeclarationModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgDeclarationModifier::isFriend() const  { return checkBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::setFriend()       { setBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::unsetFriend()     { unsetBit(e_friend,p_modifierVector); }

bool SgDeclarationModifier::isTypedef() const  { return checkBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::setTypedef()       { setBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::unsetTypedef()     { unsetBit(e_typedef,p_modifierVector); }

bool SgDeclarationModifier::isExport() const  { return checkBit(e_export,p_modifierVector); }
void SgDeclarationModifier::setExport()       { setBit(e_export,p_modifierVector); }
void SgDeclarationModifier::unsetExport()     { unsetBit(e_export,p_modifierVector); }

bool SgDeclarationModifier::isThrow() const  { return checkBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::setThrow()       { setBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::unsetThrow()     { unsetBit(e_throw,p_modifierVector); }

bool SgDeclarationModifier::isBind() const { return checkBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::setBind()      { setBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::unsetBind()    { unsetBit(e_bind,p_modifierVector); }

bool SgDeclarationModifier::isFinal() const { return checkBit(e_final,p_modifierVector); }
void SgDeclarationModifier::setFinal()      { setBit(e_final,p_modifierVector); }
void SgDeclarationModifier::unsetFinal()    { unsetBit(e_final,p_modifierVector); }

// DQ (8/11/2014): C++11 specific attribute
bool SgDeclarationModifier::isOverride() const { return checkBit(e_override,p_modifierVector); }
void SgDeclarationModifier::setOverride()      { setBit(e_override,p_modifierVector); }
void SgDeclarationModifier::unsetOverride()    { unsetBit(e_override,p_modifierVector); }

// DQ (8/11/2011): Added support for Java "abstract" declaration modifier.
bool SgDeclarationModifier::isJavaAbstract() const { return checkBit(e_java_abstract,p_modifierVector); }
void SgDeclarationModifier::setJavaAbstract()      { setBit(e_java_abstract,p_modifierVector); }
void SgDeclarationModifier::unsetJavaAbstract()    { unsetBit(e_java_abstract,p_modifierVector); }

// Rasmussen (2/26/2020): Added support for Jovial modifiers
bool SgDeclarationModifier::isJovialDef() const { return checkBit(e_jovial_def,p_modifierVector); }
void SgDeclarationModifier::setJovialDef()      { setBit(e_jovial_def,p_modifierVector); }
void SgDeclarationModifier::unsetJovialDef()    { unsetBit(e_jovial_def,p_modifierVector); }

bool SgDeclarationModifier::isJovialRef() const { return checkBit(e_jovial_ref,p_modifierVector); }
void SgDeclarationModifier::setJovialRef()      { setBit(e_jovial_ref,p_modifierVector); }
void SgDeclarationModifier::unsetJovialRef()    { unsetBit(e_jovial_ref,p_modifierVector); }

bool SgDeclarationModifier::isJovialStatic() const { return checkBit(e_jovial_static,p_modifierVector); }
void SgDeclarationModifier::setJovialStatic()      { setBit(e_jovial_static,p_modifierVector); }
void SgDeclarationModifier::unsetJovialStatic()    { unsetBit(e_jovial_static,p_modifierVector); }

// PP (6/15/2020): Added support for Ada modifiers
bool SgDeclarationModifier::isAdaAbstract() const { return checkBit(e_ada_abstract,p_modifierVector); }
void SgDeclarationModifier::setAdaAbstract()      { setBit(e_ada_abstract,p_modifierVector); }
void SgDeclarationModifier::unsetAdaAbstract()    { unsetBit(e_ada_abstract,p_modifierVector); }

bool SgDeclarationModifier::isAdaLimited() const  { return checkBit(e_ada_limited,p_modifierVector); }
void SgDeclarationModifier::setAdaLimited()       { setBit(e_ada_limited,p_modifierVector); }
void SgDeclarationModifier::unsetAdaLimited()     { unsetBit(e_ada_limited,p_modifierVector); }

bool SgDeclarationModifier::isAdaTagged() const   { return checkBit(e_ada_tagged,p_modifierVector); }
void SgDeclarationModifier::setAdaTagged()        { setBit(e_ada_tagged,p_modifierVector); }
void SgDeclarationModifier::unsetAdaTagged()      { unsetBit(e_ada_tagged,p_modifierVector); }

bool SgDeclarationModifier::isAdaSeparate() const { return checkBit(e_ada_separate,p_modifierVector); }
void SgDeclarationModifier::setAdaSeparate()      { setBit(e_ada_separate,p_modifierVector); }
void SgDeclarationModifier::unsetAdaSeparate()    { unsetBit(e_ada_separate,p_modifierVector); }


// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_align() const { return checkBit(e_ms_declspec_align,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_align()      { setBit(e_ms_declspec_align,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_align()    { unsetBit(e_ms_declspec_align,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_allocate() const { return checkBit(e_ms_declspec_allocate,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_allocate()      { setBit(e_ms_declspec_allocate,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_allocate()    { unsetBit(e_ms_declspec_allocate,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_appdomain() const { return checkBit(e_ms_declspec_appdomain,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_appdomain()      { setBit(e_ms_declspec_appdomain,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_appdomain()    { unsetBit(e_ms_declspec_appdomain,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_code_seg() const { return checkBit(e_ms_declspec_code_seg,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_code_seg()      { setBit(e_ms_declspec_code_seg,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_code_seg()    { unsetBit(e_ms_declspec_code_seg,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_deprecated() const { return checkBit(e_ms_declspec_deprecated,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_deprecated()      { setBit(e_ms_declspec_deprecated,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_deprecated()    { unsetBit(e_ms_declspec_deprecated,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_dllimport() const { return checkBit(e_ms_declspec_dllimport,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_dllimport()      { setBit(e_ms_declspec_dllimport,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_dllimport()    { unsetBit(e_ms_declspec_dllimport,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_dllexport() const { return checkBit(e_ms_declspec_dllexport,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_dllexport()      { setBit(e_ms_declspec_dllexport,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_dllexport()    { unsetBit(e_ms_declspec_dllexport,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_jitintrinsic() const { return checkBit(e_ms_declspec_jitintrinsic,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_jitintrinsic()      { setBit(e_ms_declspec_jitintrinsic,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_jitintrinsic()    { unsetBit(e_ms_declspec_jitintrinsic,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_naked() const { return checkBit(e_ms_declspec_naked,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_naked()      { setBit(e_ms_declspec_naked,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_naked()    { unsetBit(e_ms_declspec_naked,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noalias() const { return checkBit(e_ms_declspec_noalias,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noalias()      { setBit(e_ms_declspec_noalias,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noalias()    { unsetBit(e_ms_declspec_noalias,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noinline() const { return checkBit(e_ms_declspec_noinline,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noinline()      { setBit(e_ms_declspec_noinline,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noinline()    { unsetBit(e_ms_declspec_noinline,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noreturn() const { return checkBit(e_ms_declspec_noreturn,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noreturn()      { setBit(e_ms_declspec_noreturn,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noreturn()    { unsetBit(e_ms_declspec_noreturn,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_nothrow() const { return checkBit(e_ms_declspec_nothrow,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_nothrow()      { setBit(e_ms_declspec_nothrow,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_nothrow()    { unsetBit(e_ms_declspec_nothrow,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_novtable() const { return checkBit(e_ms_declspec_novtable,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_novtable()      { setBit(e_ms_declspec_novtable,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_novtable()    { unsetBit(e_ms_declspec_novtable,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_process() const { return checkBit(e_ms_declspec_process,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_process()      { setBit(e_ms_declspec_process,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_process()    { unsetBit(e_ms_declspec_process,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_property() const { return checkBit(e_ms_declspec_property,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_property()      { setBit(e_ms_declspec_property,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_property()    { unsetBit(e_ms_declspec_property,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_restrict() const { return checkBit(e_ms_declspec_restrict,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_restrict()      { setBit(e_ms_declspec_restrict,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_restrict()    { unsetBit(e_ms_declspec_restrict,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_safebuffers() const { return checkBit(e_ms_declspec_safebuffers,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_safebuffers()      { setBit(e_ms_declspec_safebuffers,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_safebuffers()    { unsetBit(e_ms_declspec_safebuffers,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_selectany() const { return checkBit(e_ms_declspec_selectany,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_selectany()      { setBit(e_ms_declspec_selectany,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_selectany()    { unsetBit(e_ms_declspec_selectany,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_thread() const { return checkBit(e_ms_declspec_thread,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_thread()      { setBit(e_ms_declspec_thread,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_thread()    { unsetBit(e_ms_declspec_thread,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_uuid() const { return checkBit(e_ms_declspec_uuid,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_uuid()      { setBit(e_ms_declspec_uuid,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_uuid()    { unsetBit(e_ms_declspec_uuid,p_modifierVector); }






string
SgDeclarationModifier::displayString() const
   {
     std::string s = "SgDeclarationModifier(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isFriend() = ")       + std::string(isFriend()       ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isExport() = ")       + std::string(isExport()       ? "true " : "false ");
     s += std::string("isThrow() = ")        + std::string(isThrow()        ? "true " : "false ");
     s += std::string("isBind() = ")         + std::string(isBind()         ? "true " : "false ");
     s += std::string("isFinal() = ")        + std::string(isFinal()        ? "true " : "false ");
     s += std::string("isJavaAbstract() = ") + std::string(isJavaAbstract() ? "true " : "false ");
     s += std::string("isJovialDef() = ")    + std::string(isJovialDef()    ? "true " : "false ");
     s += std::string("isJovialRef() = ")    + std::string(isJovialRef()    ? "true " : "false ");
     s += std::string("isJovialStatic() = ") + std::string(isJovialStatic() ? "true " : "false ");
     s += std::string("isAdaAbstract() = ")  + std::string(isAdaAbstract()  ? "true " : "false ");
     s += std::string("isAdaLimited() = ")   + std::string(isAdaLimited()   ? "true " : "false ");
     s += std::string("isAdaTagged() = ")    + std::string(isAdaTagged()    ? "true " : "false ");
     s += std::string("\n     ") + get_typeModifier().displayString()   + " ";
     s += std::string("\n     ") + get_accessModifier().displayString() + " ";
     s += std::string("\n     ") + get_storageModifier().displayString();
     s += ")";
     return s;
   }

void
SgDeclarationModifier::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgDeclarationModifier & m)
   {
      os << m.get_modifierVector();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
         (lhs.get_typeModifier()    == rhs.get_typeModifier()   ) &&
         (lhs.get_accessModifier()  == rhs.get_accessModifier() ) &&
         (lhs.get_storageModifier() == rhs.get_storageModifier()) &&
         (lhs.isUnknown()           == rhs.isUnknown()) &&
         (lhs.isDefault()           == rhs.isDefault()) &&
         (lhs.isFriend()            == rhs.isFriend() ) &&
         (lhs.isTypedef()           == rhs.isTypedef()) &&
         (lhs.isExport()            == rhs.isExport() ) &&
         (lhs.isThrow()             == rhs.isThrow()  ) &&
         (lhs.isBind()              == rhs.isBind()   ) &&
         (lhs.isFinal()             == rhs.isFinal()  ) &&
         (lhs.isJavaAbstract()      == rhs.isJavaAbstract() ) &&
         (lhs.isJovialDef()         == rhs.isJovialDef() ) &&
         (lhs.isJovialRef()         == rhs.isJovialRef() ) &&
         (lhs.isJovialStatic()      == rhs.isJovialStatic() ) &&
         (lhs.isAdaAbstract()       == rhs.isAdaAbstract() )  &&
         (lhs.isAdaLimited()        == rhs.isAdaLimited() )   &&
         (lhs.isAdaTagged()         == rhs.isAdaTagged() )    &&
          true;
   }

SgTypeModifier &
SgDeclarationModifier::get_typeModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_typeModifier;
   }

SgAccessModifier &
SgDeclarationModifier::get_accessModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_accessModifier;
   }

SgStorageModifier &
SgDeclarationModifier::get_storageModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_storageModifier;
   }

const SgTypeModifier &
SgDeclarationModifier::get_typeModifier () const
   {
     ROSE_ASSERT (this != NULL);
     return p_typeModifier;
   }

const SgAccessModifier &
SgDeclarationModifier::get_accessModifier () const
   {
     ROSE_ASSERT (this != NULL);
     return p_accessModifier;
   }

const SgStorageModifier &
SgDeclarationModifier::get_storageModifier () const
   {
     ROSE_ASSERT (this != NULL);
     return p_storageModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void
SgDeclarationModifier::reset()
   {
     unsetUnknown();
     unsetFriend();
     unsetTypedef();
     unsetExport();
     unsetThrow();
     unsetBind();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_typeModifier().reset();
     get_accessModifier().reset();
     get_storageModifier().reset();
   }

SOURCE_DECLARATION_MODIFIER_END

SOURCE_TYPE_MODIFIER_START

// Copy constructor
SgTypeModifier::SgTypeModifier ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
   }

SgTypeModifier &
SgTypeModifier::operator= ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
     return *this;
   }

void
SgTypeModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgTypeModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgTypeModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgTypeModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgTypeModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgTypeModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgTypeModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgTypeModifier::isRestrict() const { return checkBit(e_restrict,p_modifierVector); }
void SgTypeModifier::setRestrict()      { setBit(e_restrict,p_modifierVector); }
void SgTypeModifier::unsetRestrict()    { unsetBit(e_restrict,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAllocatable() const  { return checkBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::setAllocatable()       { setBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::unsetAllocatable()     { unsetBit(e_allocatable,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAsynchronous() const  { return checkBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::setAsynchronous()       { setBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::unsetAsynchronous()     { unsetBit(e_asynchronous,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isBind() const  { return checkBit(e_bind,p_modifierVector); }
void SgTypeModifier::setBind()       { setBit(e_bind,p_modifierVector); }
void SgTypeModifier::unsetBind()     { unsetBit(e_bind,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isData() const  { return checkBit(e_data,p_modifierVector); }
void SgTypeModifier::setData()       { setBit(e_data,p_modifierVector); }
void SgTypeModifier::unsetData()     { unsetBit(e_data,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isDimension() const  { return checkBit(e_dimension,p_modifierVector); }
void SgTypeModifier::setDimension()       { setBit(e_dimension,p_modifierVector); }
void SgTypeModifier::unsetDimension()     { unsetBit(e_dimension,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_in() const  { return checkBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::setIntent_in()       { setBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::unsetIntent_in()     { unsetBit(e_intent_in,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_out() const  { return checkBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::setIntent_out()       { setBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::unsetIntent_out()     { unsetBit(e_intent_out,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_inout() const  { return checkBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::setIntent_inout()       { setBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::unsetIntent_inout()     { unsetBit(e_intent_inout,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntrinsic() const  { return checkBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::setIntrinsic()       { setBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::unsetIntrinsic()     { unsetBit(e_intrinsic,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isOptional() const  { return checkBit(e_optional,p_modifierVector); }
void SgTypeModifier::setOptional()       { setBit(e_optional,p_modifierVector); }
void SgTypeModifier::unsetOptional()     { unsetBit(e_optional,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isSave() const  { return checkBit(e_save,p_modifierVector); }
void SgTypeModifier::setSave()       { setBit(e_save,p_modifierVector); }
void SgTypeModifier::unsetSave()     { unsetBit(e_save,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isTarget() const  { return checkBit(e_target,p_modifierVector); }
void SgTypeModifier::setTarget()       { setBit(e_target,p_modifierVector); }
void SgTypeModifier::unsetTarget()     { unsetBit(e_target,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isValue() const  { return checkBit(e_value,p_modifierVector); }
void SgTypeModifier::setValue()       { setBit(e_value,p_modifierVector); }
void SgTypeModifier::unsetValue()     { unsetBit(e_value,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isExtends() const  { return checkBit(e_extends,p_modifierVector); }
void SgTypeModifier::setExtends()       { setBit(e_extends,p_modifierVector); }
void SgTypeModifier::unsetExtends()     { unsetBit(e_extends,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAbstract() const  { return checkBit(e_abstract,p_modifierVector); }
void SgTypeModifier::setAbstract()       { setBit(e_abstract,p_modifierVector); }
void SgTypeModifier::unsetAbstract()     { unsetBit(e_abstract,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeUnused() const  { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeUnused()       { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeUnused()     { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributePacked() const  { return checkBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::setGnuAttributePacked()       { setBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributePacked()     { unsetBit(e_gnu_attribute__packed__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeDeprecated() const  { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeDeprecated()       { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeDeprecated()     { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeTransparentUnion() const  { return checkBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeTransparentUnion()       { setBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeTransparentUnion()     { unsetBit(e_gnu_attribute__transparent_union__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNoReturn() const  { return checkBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNoReturn()       { setBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNoReturn()     { unsetBit(e_gnu_attribute__noreturn__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeConst() const  { return checkBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeConst()       { setBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeConst()     { unsetBit(e_gnu_attribute__const__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeCdecl() const  { return checkBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeCdecl()       { setBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeCdecl()     { unsetBit(e_gnu_attribute__cdecl__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeStdcall() const  { return checkBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeStdcall()       { setBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeStdcall()     { unsetBit(e_gnu_attribute__stdcall__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeWarnUnusedResult() const  { return checkBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeWarnUnusedResult()       { setBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeWarnUnusedResult()     { unsetBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNonnull() const  { return checkBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNonnull()       { setBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNonnull()     { unsetBit(e_gnu_attribute__nonnull__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeSentinel() const  { return checkBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeSentinel()       { setBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeSentinel()     { unsetBit(e_gnu_attribute__sentinel__,p_modifierVector); }

bool SgTypeModifier::haveAddressSpace() const { return checkBit(e_address_space__,p_modifierVector); }
void SgTypeModifier::setAddressSpace()        { setBit(e_address_space__,p_modifierVector); }
void SgTypeModifier::unsetAddressSpace()      { unsetBit(e_address_space__,p_modifierVector); }

bool SgTypeModifier::isOpenclGlobal() const { return checkBit(e_ocl_global__,p_modifierVector); }
void SgTypeModifier::setOpenclGlobal()      { setBit(e_ocl_global__,p_modifierVector); }
void SgTypeModifier::unsetOpenclGlobal()    { unsetBit(e_ocl_global__,p_modifierVector); }

bool SgTypeModifier::isOpenclLocal() const { return checkBit(e_ocl_local__,p_modifierVector); }
void SgTypeModifier::setOpenclLocal()      { setBit(e_ocl_local__,p_modifierVector); }
void SgTypeModifier::unsetOpenclLocal()    { unsetBit(e_ocl_local__,p_modifierVector); }

bool SgTypeModifier::isOpenclConstant() const { return checkBit(e_ocl_constant__,p_modifierVector); }
void SgTypeModifier::setOpenclConstant()      { setBit(e_ocl_constant__,p_modifierVector); }
void SgTypeModifier::unsetOpenclConstant()    { unsetBit(e_ocl_constant__,p_modifierVector); }

bool SgTypeModifier::isVectorType() const { return checkBit(e_vector_type__,p_modifierVector); }
void SgTypeModifier::setVectorType()      { setBit(e_vector_type__,p_modifierVector); }
void SgTypeModifier::unsetVectorType()    { unsetBit(e_vector_type__,p_modifierVector); }

// DQ (1/24/2016): Added GNU specific attributes for custom specification of CUDA device in function parameter types.
bool SgTypeModifier::isGnuAttributeDevice() const  { return checkBit(e_gnu_attribute__device__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeDevice()       { setBit(e_gnu_attribute__device__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeDevice()     { unsetBit(e_gnu_attribute__device__,p_modifierVector); }

// Rasmussen (3/1/2020): numeric type specifiers for Jovial
bool SgTypeModifier::isRound() const  { return checkBit(e_round,p_modifierVector); }
void SgTypeModifier::setRound()       { setBit(e_round,p_modifierVector); }
void SgTypeModifier::unsetRound()     { unsetBit(e_round,p_modifierVector); }

bool SgTypeModifier::isTruncate() const  { return checkBit(e_truncate,p_modifierVector); }
void SgTypeModifier::setTruncate()       { setBit(e_truncate,p_modifierVector); }
void SgTypeModifier::unsetTruncate()     { unsetBit(e_truncate,p_modifierVector); }

bool SgTypeModifier::isTruncateTowardsZero() const  { return checkBit(e_truncate_towards_zero,p_modifierVector); }
void SgTypeModifier::setTruncateTowardsZero()       { setBit(e_truncate_towards_zero,p_modifierVector); }
void SgTypeModifier::unsetTruncateTowardsZero()     { unsetBit(e_truncate_towards_zero,p_modifierVector); }

bool SgTypeModifier::isAliased() const  { return checkBit(e_aliased,p_modifierVector); }
void SgTypeModifier::setAliased()       { setBit(e_aliased,p_modifierVector); }
void SgTypeModifier::unsetAliased()     { unsetBit(e_aliased,p_modifierVector); }

bool SgTypeModifier::isNotNull() const  { return checkBit(e_notnull,p_modifierVector); }
void SgTypeModifier::setNotNull()       { setBit(e_notnull,p_modifierVector); }
void SgTypeModifier::unsetNotNull()     { unsetBit(e_notnull,p_modifierVector); }


string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")                + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")                + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isRestrict() = ")               + std::string(isRestrict() ? "true " : "false ");
     s += std::string("isAliased() = ")                + std::string(isAliased()  ? "true " : "false ");
     s += std::string("isNotNull() = ")                + std::string(isNotNull()  ? "true " : "false ");
     s += std::string("gnu_extension_machine_mode = ") + Rose::StringUtility::numberToString((int)p_gnu_extension_machine_mode) + " ";
     s += std::string("gnu_attribute_alignment = ")    + Rose::StringUtility::numberToString((int)p_gnu_attribute_alignment)    + " ";
     s += std::string("gnu_attribute_sentinel = ")     + Rose::StringUtility::numberToString((int)p_gnu_attribute_sentinel)     + " ";
     s += std::string("address_space_value = ")        + Rose::StringUtility::numberToString((int)p_address_space_value)        + " ";
     s += std::string("vector_size = ")                + Rose::StringUtility::numberToString((int)p_vector_size)                + " ";
     s += std::string("   ")                           + get_constVolatileModifier().displayString()                            + " ";
     s += std::string("   ")                           + get_upcModifier().displayString()                                      + " ";
     s += std::string("   ")                           + get_structureModifier().displayString()                                + " ";
     s += std::string("   ")                           + get_elaboratedTypeModifier().displayString();
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream& operator<< (std::ostream& os, const SgTypeModifier& tm)
   {
      os << tm.get_modifierVector();
     return os;
   }

// DQ (11/28/2015): We need a better way to support wrappers of types that are significant and not significant.
bool SgTypeModifier::isIdentity() const
   {
  // When this is true, the SgTypeModifier acts as a simple wrapper to a base type that is equivalent.
     bool identity = false;

  // This needs to be an expanded set of fields later.
     identity = (get_constVolatileModifier().isConst() == false) && (get_constVolatileModifier().isVolatile() == false) && (isRestrict() == false);

     return identity;
   }


bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
          (lhs.get_upcModifier()            == rhs.get_upcModifier()           ) &&
          (lhs.get_structureModifier()      == rhs.get_structureModifier()     ) &&
          (lhs.get_constVolatileModifier()  == rhs.get_constVolatileModifier() ) &&
          (lhs.get_elaboratedTypeModifier() == rhs.get_elaboratedTypeModifier()) &&
          (lhs.isUnknown() == rhs.isUnknown()) &&
          (lhs.isDefault() == rhs.isDefault()) &&
       // C specific
          (lhs.isRestrict() == rhs.isRestrict()) &&
       // Fortran specific
          (lhs.isAllocatable()  == rhs.isAllocatable() ) &&
          (lhs.isBind()         == rhs.isBind()        ) &&
          (lhs.isAsynchronous() == rhs.isAsynchronous()) &&
          (lhs.isData()         == rhs.isData()        ) &&
          (lhs.isDimension()    == rhs.isDimension()   ) &&
          (lhs.isIntent_in()    == rhs.isIntent_in()   ) &&
          (lhs.isIntent_out()   == rhs.isIntent_out()  ) &&
          (lhs.isIntent_inout() == rhs.isIntent_inout()) &&
          (lhs.isIntrinsic()    == rhs.isIntrinsic()   ) &&
          (lhs.isOptional()     == rhs.isOptional()    ) &&
          (lhs.isSave()         == rhs.isSave()        ) &&
          (lhs.isTarget()       == rhs.isTarget()      ) &&
          (lhs.isValue()        == rhs.isValue()       ) &&
       // GNU specific
          (lhs.isGnuAttributeUnused()           == rhs.isGnuAttributeUnused()          ) &&
          (lhs.isGnuAttributePacked()           == rhs.isGnuAttributePacked()          ) &&
          (lhs.isGnuAttributeDeprecated()       == rhs.isGnuAttributeDeprecated()      ) &&
          (lhs.isGnuAttributeTransparentUnion() == rhs.isGnuAttributeTransparentUnion()) &&
          (lhs.isGnuAttributeNoReturn()         == rhs.isGnuAttributeNoReturn()        ) &&
          (lhs.isGnuAttributeConst()            == rhs.isGnuAttributeConst()           ) &&
          (lhs.isGnuAttributeCdecl()            == rhs.isGnuAttributeCdecl()           ) &&
          (lhs.isGnuAttributeStdcall()          == rhs.isGnuAttributeStdcall()         ) &&
          (lhs.isGnuAttributeWarnUnusedResult() == rhs.isGnuAttributeWarnUnusedResult()) &&
          (lhs.isGnuAttributeNonnull()          == rhs.isGnuAttributeNonnull()         ) &&
          (lhs.isGnuAttributeSentinel()         == rhs.isGnuAttributeSentinel()        ) &&
       // Address Space
          (lhs.haveAddressSpace()        == rhs.haveAddressSpace()        ) &&
          (lhs.get_address_space_value() == rhs.get_address_space_value() ) &&
       // OpenCL specific
          (lhs.isOpenclGlobal()   == rhs.isOpenclGlobal()    ) &&
          (lhs.isOpenclLocal()    == rhs.isOpenclLocal()    ) &&
          (lhs.isOpenclConstant() == rhs.isOpenclConstant() ) &&
       // Vector Type
          (lhs.isVectorType()    == rhs.isVectorType()    ) &&
          (lhs.get_vector_size() == rhs.get_vector_size() ) &&
          true;
   }

SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_constVolatileModifier;
   }

SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_upcModifier;
   }

SgStructureModifier &
$CLASSNAME::get_structureModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_structureModifier;
   }

SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_elaboratedTypeModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetRestrict();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_constVolatileModifier().reset();
     get_upcModifier().reset();
     get_structureModifier().reset();
     get_elaboratedTypeModifier().reset();
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier (void) const
   {
     ROSE_ASSERT (this != NULL);
     return p_constVolatileModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier (void) const
   {
     ROSE_ASSERT (this != NULL);
     return p_upcModifier;
   }

const SgStructureModifier &
$CLASSNAME::get_structureModifier (void) const
   {
     ROSE_ASSERT (this != NULL);
     return p_structureModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier (void) const
   {
     ROSE_ASSERT (this != NULL);
     return p_elaboratedTypeModifier;
   }

SOURCE_TYPE_MODIFIER_END


SOURCE_ELABORATED_TYPE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isClass() const { return p_modifier == e_class; }
void $CLASSNAME::setClass()      { p_modifier = e_class; }

bool $CLASSNAME::isStruct() const { return p_modifier == e_struct; }
void $CLASSNAME::setStruct()      { p_modifier = e_struct; }

bool $CLASSNAME::isUnion() const { return p_modifier == e_union; }
void $CLASSNAME::setUnion()      { p_modifier = e_union; }

bool $CLASSNAME::isEnum() const { return p_modifier == e_enum; }
void $CLASSNAME::setEnum()      { p_modifier = e_enum; }

bool $CLASSNAME::isTypename() const { return p_modifier == e_typename; }
void $CLASSNAME::setTypename()      { p_modifier = e_typename; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isClass() = ")    + std::string(isClass()    ? "true " : "false ");
     s += std::string("isStruct() = ")   + std::string(isStruct()   ? "true " : "false ");
     s += std::string("isUnion() = ")    + std::string(isUnion()    ? "true " : "false ");
     s += std::string("isEnum() = ")     + std::string(isEnum()     ? "true " : "false ");
     s += std::string("isTypename() = ") + std::string(isTypename() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgElaboratedTypeModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()  == rhs.isUnknown() ) &&
         (lhs.isDefault()  == rhs.isDefault() ) &&
         (lhs.isClass()    == rhs.isClass()   ) &&
         (lhs.isStruct()   == rhs.isStruct()  ) &&
         (lhs.isUnion()    == rhs.isUnion()   ) &&
         (lhs.isEnum()     == rhs.isEnum()    ) &&
         (lhs.isTypename() == rhs.isTypename()) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_ELABORATED_TYPE_MODIFIER_END

SOURCE_LINKAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isC_Linkage() const { return p_modifier == e_C_linkage; }
void $CLASSNAME::setC_Linkage()      { p_modifier = e_C_linkage; }

bool $CLASSNAME::isCppLinkage() const { return p_modifier == e_Cpp_linkage; }
void $CLASSNAME::setCppLinkage()      { p_modifier = e_Cpp_linkage; }

bool $CLASSNAME::isFortranLinkage() const { return p_modifier == e_fortran_linkage; }
void $CLASSNAME::setFortranLinkage()      { p_modifier = e_fortran_linkage; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")        + std::string(isUnknown()        ? "true " : "false ");
     s += std::string("isDefault() = ")        + std::string(isDefault()        ? "true " : "false ");
     s += std::string("isC_Linkage() = ")      + std::string(isC_Linkage()      ? "true " : "false ");
     s += std::string("isCppLinkage() = ")     + std::string(isCppLinkage()     ? "true " : "false ");
     s += std::string("isFortranLinkage() = ") + std::string(isFortranLinkage() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgLinkageModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.isUnknown()        == rhs.isUnknown()       ) &&
         (lhs.isDefault()        == rhs.isDefault()       ) &&
         (lhs.isC_Linkage()      == rhs.isC_Linkage()     ) &&
         (lhs.isCppLinkage()     == rhs.isCppLinkage()    ) &&
         (lhs.isFortranLinkage() == rhs.isFortranLinkage()) &&
       true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_LINKAGE_MODIFIER_END

SOURCE_BASECLASS_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isVirtual() const { return p_modifier == e_virtual; }
void $CLASSNAME::setVirtual()      { p_modifier = e_virtual; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isVirtual() = ") + std::string(isVirtual() ? "true " : "false ");
     s += std::string("\n     ") + get_accessModifier().displayString();
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgBaseClassModifier & m)
   {
      os << m.get_modifier();
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
  return
         (lhs.get_accessModifier() == rhs.get_accessModifier()) &&
         (lhs.isUnknown() == rhs.isUnknown()) &&
         (lhs.isDefault() == rhs.isDefault()) &&
         (lhs.isVirtual() == rhs.isVirtual()) &&
       true;
}

SgAccessModifier &
$CLASSNAME::get_accessModifier ()
   {
     ROSE_ASSERT (this != NULL);
     return p_accessModifier;
   }

const SgAccessModifier &
$CLASSNAME::get_accessModifier () const
   {
     ROSE_ASSERT (this != NULL);
     return p_accessModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
     get_accessModifier().reset();
   }

SOURCE_BASECLASS_MODIFIER_END






HEADER_SYMBOL_TABLE_PREDECLARATION_START

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv );

// forward class declaration to support case sensitive/insensitive symbol tables.
class rose_hash_multimap;

/*! \brief Name equality operator support for symbol tables within ROSE.
 */
struct eqstr
   {
  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     const rose_hash_multimap* hash_multimap;

  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     eqstr(const rose_hash_multimap* p) : hash_multimap(p) {}

  // The definition of this function requires the reference to the member function
  // rose_hash_multimap::get_case_insensitive_semantics() so it must be seen after
  // the rose_hash_multimap class definition.
     bool operator()(const SgName & s1, const SgName & s2) const;
   };

/*! \brief Hash name support for symbol tables within ROSE.
 */
struct hash_Name
   {
  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     const rose_hash_multimap* hash_multimap;

  // CH (4/8/2010): Use boost::unordered instead
  // CH (4/13/2010): Use boost::hash<string> instead
  // rose_hash::hash<const char*> hasher;
     rose_hash::hash<std::string> hasher;

     public:
       // DQ (12/22/2005): Added constructor to support case insensitive name semantics
          hash_Name(const rose_hash_multimap* p) : hash_multimap(p) {}

       // The definition of this function requires the reference to the member function
       // rose_hash_multimap::get_case_insensitive_semantics() so it must be seen after
       // the rose_hash_multimap class definition.
          size_t operator()(const SgName & name) const;
   };

/*! \brief Hash table support for symbol tables within ROSE.

       This hash table support is used by the symbol tables within ROSE.  There is one global
    symbol table for all function symbols and then there symbol tables for each scope
    (implemented in the SgScopeDeclaration).

    \internal Trivia: The first version was developed by Alin Jula, and as payment I bought him dinner
                      when Ken Kennedy visited LLNL (summer of 2005).

 */

// tps (11/19/2009) : Constructor of hash_multimap in MSVS is different
// CH (4/8/2010): Use boost::unordered instead

class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>
   {
     protected:
          SgNode * parent;
          bool case_insensitive_semantics;

     public:
       // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
       // DQ (11/27/2010): Newer version of code after adding support for case insensitive behavior.
          rose_hash_multimap()
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(17,hash_Name(this),eqstr(this)), parent(NULL), case_insensitive_semantics(false)
             {
             }

         rose_hash_multimap(int sz)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz,hash_Name(this),eqstr(this)), parent(NULL), case_insensitive_semantics(false)
             {
             }

          rose_hash_multimap(const rose_hash_multimap & rhs)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(/*(rose_hash_multimap)*/rhs), parent(rhs.parent), case_insensitive_semantics(rhs.case_insensitive_semantics)
             {
             }

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }

          SgNode* get_parent() const
             {
               return parent;
             }

       // DQ (11/28/2010): Added support to set/unset case sensitivity in symbol table handling.
          void set_case_insensitive_semantics(bool b)
             {
               case_insensitive_semantics = b;
             }

       // DQ (11/28/2010): Added support to set/unset case sensitivity in symbol table handling.
          bool get_case_insensitive_semantics() const
             {
               return case_insensitive_semantics;
             }

          void delete_elements();

         ~rose_hash_multimap()
             {
               delete_elements();

            // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
               parent = NULL;
             }

     // JH (01/01/2006) friend class declarations to get direct access to data member for the ast file IO
        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_hash_multimap*>;
   };


std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it );

HEADER_SYMBOL_TABLE_PREDECLARATION_END


HEADER_SYMBOL_TABLE_START

       // AJ (10/21/2004): Added support STL based implementation of hash table.
       // I have replaced the p_table in the SgSymbolTable from a SgSymbolHashMultimap
       // to the STL hash_multimap<SgName,SgSymbol*,..>. The hash function for SgName
       // uses the native STL hash function for char* . The methods of SgSymbolTable
       // were adjusted (where necessary) to accomodate the STL hash_multimap table.
       // What we have now is the old interaface of SgSymbolTable working with STL
       // hash_multimap AND the STL interaface through the hash_multimap table.

       // DQ (1/30/2007): Added many member functions back into ROSE, now that we both
       // better appriciate why they are required and we are overhaling the symbol
       // table interface generally.
       // Comment from 9/7/2006):
       // Many member functions were removed because they are (with few exceptions,
       // where they have been recently restored) infreqently used and too
       // much funcionality to support robustly.  Now that we use STL internally
       // and we make the STL hash map available, users have all possible access.

       // typedefs to STL container used internally
          typedef rose_hash_multimap BaseHashType;
          typedef BaseHashType::iterator hash_iterator;

       // Default constructor (builds the hash table using a default size: 17 typically)
          SgSymbolTable();

       //! Added to support scopes that have more symbols (e.g. SgGlobal, and the function type table)
          SgSymbolTable(int sz);

       // Destructors are automatically generated by ROSETTA and so should not be explicitly represented
       // ~SgSymbolTable();

       // General function used to build AST
          void insert ( const SgName & name, SgSymbol *sp );

       // DQ (11/27/2010): Changing the return type to "bool"
       // DQ (1/31/2007): Deprecated (is not well named and should return bool)
       // int  find   ( const SgName & name, SgSymbol *sp, bool case_insensitive = false ) ROSE_DEPRECATED_FUNCTION;
          bool find   ( const SgName & name, SgSymbol *sp ) ROSE_DEPRECATED_FUNCTION;

       // DQ (1/31/2007): New functions that will replace the deprecated find() member function
       // Note that this is log n in complexity
          bool exists ( const SgName &, SgSymbol *sp ) const; //! Complexity O(log n), checks for existence of symbol before matching against names.

       // DQ (1/31/2007): This is log n in complexity
          bool exists ( const SgName & name) const;               //! Complexity O(log n)

       // DQ (1/31/2007): This is linear in complexity (expensive)
          bool exists ( const SgSymbol *sp ) const;           //! Complexity O(n)

       // DQ (2/6/2007): find functions that take the declarations that are internally associated with SgSymbol IR nodes.
          SgSymbol* find( const SgInitializedName* initializedName); //! Complexity O(n)
          SgSymbol* find( const SgFunctionType* functionType);       //! Complexity O(n)
          SgSymbol* find( const SgStatement* statement);             //! Complexity O(n)

       // DQ (1/30/2007): Added general remove function for an explicitly identified SgSymbol
          void remove ( const SgSymbol* symbol );  //! Complexity O(log n)

       // DQ (1/30/2007): Added general remove functions for all SgSymbol IR nodes.
       // This function will remove all symbols with the specified name (even ones of
       // different types, see rest of comment).
       // This function is a bit dangerous except for function types since only for the
       // function type table are the names unique.  For non-function type symbol
       // tables classes and typedefs can have the same name (e.g. "typedef struct X {} X;")
       // so removing the name might have unexpected results!
          void remove_function_type ( const SgName & name); //! Complexity O(log n)

       // DQ (1/30/2007): New interface member functions using name.
       // These function search first against the name and then iteratively continue through
       // the internal STL container to look for an entry that match the name and the type of
       // the SgSymbol.  This is optimially fast only for the case where there are unique names.
       // SgSymbol* find_any(const SgName & name);                   //! Complexity O(log n) for first match against name, then O(n)
          SgSymbol* find_any(const SgName & name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList); //! Complexity O(log n) for first match against name, then O(n)

          SgVariableSymbol*  find_variable(const SgName & name);               //! Complexity O(log n) for first match against name, then O(n)

// #ifndef ROSE_USE_SWIG_SUPPORT
#ifndef SWIG
       // DQ (3/10/2013): These functions are left undefined in the final link step for SWIG support, so remove it from SWIG processing for now.

       // DQ (12/27/2011): Added support for template declarations in the AST.
       // SgTemplateVariableSymbol* find_template_variable(const SgName & name);
          SgVariableSymbol*         find_nontemplate_variable(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
#endif
          SgClassSymbol*     find_class(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
       // This is important in handling the viability of symbols through base classes when private base
       // class derivation is used.
       // SgAliasSymbol* find_alias(const SgName & nm);

       // DQ (8/10/2013): I have needed to change the API to support more than just template arguments (adding support for template parameters).
       // DQ (8/8/2013): I have needed to change the API to support more than just classes.
       // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* X_templateArgumentsList, SgClassSymbol* classSymbol);
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* X_templateArgumentsList, SgSymbol* symbol);
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
          bool hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
          bool hasMatchingTemplateParametersOrNoTemplateParameters(SgTemplateParameterPtrList* templateParameterList, SgSymbol* symbol);
          bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
       // template <class T> bool hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(T* templateParametersOrArgumentsList, SgSymbol* symbol);
          template <class T> bool hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(std::vector<T*>* templateParametersOrArgumentsList, SgSymbol* symbol);

          SgClassSymbol* find_class(const SgName & name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
       // This is important in handling the viability of symbols through base classes when private base
       // class derivation is used.
       // SgAliasSymbol* find_alias(const SgName & name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

          SgNonrealSymbol*   find_nonreal(const SgName & name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList);

          SgFunctionSymbol* find_function(const SgName& name);                //! Complexity O(log n) for first match against name, then O(n)
       // SgFunctionSymbol* find_function(const SgName&, const SgType* name); //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol* find_function(const SgName&, const SgType* name, SgTemplateArgumentPtrList* templateArgumentList = NULL);

          SgFunctionTypeSymbol* find_function_type(const SgName& name);        //! Complexity O(log n) for first match against name, then O(n)

       // Additional find functions (using name)
          SgTypedefSymbol*   find_typedef(const SgName & name);    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum(const SgName & name);       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label(const SgName & name);      //! Complexity O(log n) for first match against name, then O(n)
          SgJavaLabelSymbol* find_java_label(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
                                                                   // charles4: added 09/12/2011 for Java
          SgNamespaceSymbol* find_namespace(const SgName & name);  //! Complexity O(log n) for first match against name, then O(n)

       // DQ (5/19/2013): Find the aliasSymbol for which the (aliasSymbol->get_base() == sp).
          SgAliasSymbol*     find_aliased_symbol(const SgName & nm, SgSymbol *sp);

       // DQ (12/26/2011): Added more refined level of support for template declarations in the AST.
       // SgTemplateClassSymbol* find_template_class (const SgName & nm);

       // DQ (1/30/2007): New interface member functions: get the first symbol using type of SgSymbol
          SgSymbol*          find_any();      //! Complexity O(log n) for first match against name, then O(n)
          SgVariableSymbol*  find_variable(); //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*     find_class();    //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol*  find_function(); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (2/19/2007): this is equivalent to the STL "begin()" function because
       // SgFunctionTypeSymbol objects are placed into the global function type table.
       // SgFunctionTypeSymbol*  find_function_type();

          SgTypedefSymbol*   find_typedef();    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum();       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label();      //! Complexity O(log n) for first match against name, then O(n)
          SgNamespaceSymbol* find_namespace();  //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateSymbol*  find_template();   //! Complexity O(log n) for first match against name, then O(n)

       // DQ (12/27/2011): Added support for template declarations in the AST.
       // DQ (12/12/2011): New functions to support template declarations in the AST.
       // SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type);
      //! Complexity O(log n) for first match against name, then O(n)
       // SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList);
          SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList);

          SgTemplateVariableSymbol* find_template_variable(const SgName& name, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentsList);

       // DQ (8/10/2013): Adding template parameter support for overloaded templates (note that the
       // template arguments for specialization are not required since partial template function
       // specialization is not allowed in C++ and any requirement for specialized functions could
       // only be for instantiatied template functions which would use a different symbol lookup function.
       // SgFunctionSymbol* find_nontemplate_function(const SgName& name, const SgType* type);
          SgFunctionSymbol* find_nontemplate_function(const SgName& name, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (12/27/2011): Added support for template declarations in the AST.
      //! Complexity O(log n) for first match against name, then O(n)
       // SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type);
       // SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList);
          SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList);
       // SgMemberFunctionSymbol*         find_nontemplate_member_function(const SgName& name, const SgType* type);
          SgMemberFunctionSymbol*         find_nontemplate_member_function(const SgName& name, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (9/9/2012): We need to pass the template parameters to help disambiguate the symblos using more than just the names.
       // SgTemplateClassSymbol* find_template_class   (const SgName& name);                     //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateClassSymbol* find_template_class (const SgName & nm, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList );

       // DQ (3/8/2017): Adding support for template typedef declarations and their symbol table handling.
       // SgTemplateTypedefSymbol* find_template_typedef (const SgName & nm, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList );
          SgTemplateTypedefSymbol* find_template_typedef (const SgName & nm);

       // SgClassSymbol*         find_nontemplate_class(const SgName& name);                     //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*         find_nontemplate_class(const SgName& name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

       // Get the next symbol of a specific type, return NULL if not available.
       // These functions use state information set by the find functions (either
       // the versions using the name or not using a name as a parameter).
          SgSymbol*          next_any();        //! Complexity O(n)
          SgVariableSymbol*  next_variable();   //! Complexity O(n)
          SgClassSymbol*     next_class();      //! Complexity O(n)
          SgFunctionSymbol*  next_function();   //! Complexity O(n)
          SgTypedefSymbol*   next_typedef();    //! Complexity O(n)
          SgEnumSymbol*      next_enum();       //! Complexity O(n)
          SgEnumFieldSymbol* next_enum_field(); //! Complexity O(n)
          SgLabelSymbol*     next_label();      //! Complexity O(n)
          SgNamespaceSymbol* next_namespace();  //! Complexity O(n)
          SgTemplateSymbol*  next_template();   //! Complexity O(n)

      //! Computes the number of symbols of a specific name
          int count(const SgName &) const;

      //! Computes the number of alias symbols of a specific name (used in name qualification support).
          int count_aliases(const SgName &) const;

      //! Outputs symbol table information (useful for debugging)
          void print( std::string label, VariantT nodeType = V_SgSymbol );
          void print();
       // void print( std::string label );

       // Output to ostream (this function is not implemented)
       // void print(std::ostream&);

      //! Computes the number of symbols in the symbol table (forced to count them, I think, internal STL detail).
          int size() const; //! Complexity O(n)

      //! generate an STL set of all symbols (supports AST merge, but may be temporary)
          std::set<SgNode*> get_symbols() const;

      //! Generates name from any IR node used to generate symbols (only works on specific IR nodes)
          SgName get_name( const SgNode* node) const;

       // DQ (11/28/2010): Added case sensitive/insensitive option to symbol table behavior.
      /*! \brief Query of scope symbol table behavior (is symbol table behavior case sensitive (C/C++) or case insensitive (Fortran).

          Note that a case insensitive symbol table can only be built that way from the SgSymbolTable constructor
          and not be toggled back and forth at will.
       */
          bool isCaseInsensitive() const;
          void setCaseInsensitive(bool b);

       // DQ (3/30/2014): This is a mode introduced to match the C++ handling of symbols of base classes with that of Java.
       // This might be temporary, but is at least a part of how we are sorting out the differences between C++ and Java
       // for symbols data members in base classes.  In C++ these are represented as SgAliasSymbols in the derived classes
       // (permitting access issues to be addressed).  In Java this is less sophisticated and one has to seach the base
       // classes explicitly.  This mode permits the semantics of searching for symbols to be handled from the derived class
       // directly.  It might be a better design to have the Java symbol handling be a bit more like that of C++, but this
       // must be discussed in some detail before we go that far.
          static bool get_force_search_of_base_classes();
          static void set_force_search_of_base_classes( bool value );

       // DQ (7/12/2014): Adding support for static data member.
          static SgNodeSet & get_aliasSymbolCausalNodeSet();

       // DQ (8/3/2019): Display function for static data member.
          static void display_aliasSymbolCausalNodeSet();

     protected:

       // DQ (4/14/2017): Test test2017_30.C demonstrates that we need to be able to force the filtering of symbols from templates
       // DQ (5/20/2013): Added refactoring of symbol lookup support so that we can handle new namespace support for symbols.
       // template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type);
       // template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList);
          template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols);

     public:

          size_t maxCollisions();

HEADER_SYMBOL_TABLE_END


HEADER_SYMBOL_TABLE_POSTDECLARATION_START

HEADER_SYMBOL_TABLE_POSTDECLARATION_END


// HEADER SYMBOL_TABLE_POSTDECLARATION_START
// HEADER SYMBOL_TABLE_POSTDECLARATION_END


HEADER_BASECLASS_START
     public:
          void post_construction_initialization() override;

       // This function should be autogenerated
       // SgBaseClass(int specifier=0, SgClassDeclaration* ptr = NULL, int dir = 0);
          SgBaseClass(const SgBaseClass& ptr);
      // ~SgBaseClass();
          SgBaseClass& operator= (const SgBaseClass& ptr);
      //  int get_base_specifier() const;
      //  SgClassDeclaration* get_base_class() const;
      //  SgClassDeclaration* replace_base_class(SgClassDeclaration*);

          bool operator== (const SgBaseClass& ) const;
          bool operator< (const SgBaseClass&) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix() const;

HEADER_BASECLASS_END

HEADER_EXP_BASE_CLASS_START
     public:
          void post_construction_initialization() override;
HEADER_EXP_BASE_CLASS_END

HEADER_NONREAL_BASE_CLASS_START
     public:
          void post_construction_initialization() override;
HEADER_NONREAL_BASE_CLASS_END


HEADER_INITIALIZED_NAME_START

     public:

      /*! \brief Preinitialization Enum (only one value can be specified)

          Initialization information which I forget the details of ...

          \internal Only one value can be specified (at least in C and C++)
       */
          enum preinitialization_enum
             {
            // When used as entries in the preinitialization list we record extra data require to reset instantiated template names
               e_unknown_preinitialization = 0, /*!< default value */
               e_virtual_base_class        = 1, /*!< virtual base class value */
               e_nonvirtual_base_class     = 2, /*!< nonvirtual base class value */
               e_data_member               = 3, /*!< data member value */
               e_delegation_constructor    = 4, /*!< delegation constructor (C++11 feature) */
               e_last_preinitialization         /*!< last value (upper bound on range of values, used in error checking) */
             };

      /*! \brief Register names (x86 specific GNU names).

          \internal These are all machine-specific.
       */
          enum asm_register_name_enum
             {
               e_invalid_register = 0,  /*!< error value */
               e_memory_register,       /*!< memory */
               e_register_a,
               e_register_b,
               e_register_c,
               e_register_d,            /*!< eax, ebx, ecx, edx */
               e_register_si,
               e_register_di,
               e_register_bp,
               e_register_sp,           /*!< esi, edi, ebp, esp */
               e_register_r8,
               e_register_r9,
               e_register_r10,
               e_register_r11,          /*!< x86-64 extra integer registers */
               e_register_r12,
               e_register_r13,
               e_register_r14,
               e_register_r15,
               e_register_st0,
               e_register_st1,
               e_register_st2,
               e_register_st3,          /*!< 80387 floating point stack */
               e_register_st4,
               e_register_st5,
               e_register_st6,
               e_register_st7,
               e_register_mm0,
               e_register_mm1,
               e_register_mm2,
               e_register_mm3,          /*!< MMX registers */
               e_register_mm4,
               e_register_mm5,
               e_register_mm6,
               e_register_mm7,
               e_register_f0,
               e_register_f1,
               e_register_f2,
               e_register_f3,           /*!< SSE/SSE2 registers */
               e_register_f4,
               e_register_f5,
               e_register_f6,
               e_register_f7,
               e_register_f8,
               e_register_f9,
               e_register_f10,
               e_register_f11,          /*!< x86-64 extra SSE registers */
               e_register_f12,
               e_register_f13,
               e_register_f14,
               e_register_f15,
               e_register_flags,
               e_register_fpsr,
               e_register_dirflag,      /*!< control registers */
               e_register_f16,
               e_register_f17,
               e_register_f18,
               e_register_f19,
               e_register_f20,
               e_unrecognized_register, /*!< used to represent an unrecognized register. */
               e_last_register
             };

       // DQ (1/3/2009): This might imply that we need a variable modifier (SgVariableModifier
       // (as a new IR node, but for now implement these directly since they are GNU specific
       // attributes (extensions)).
          enum gnu_variable_attribute_enum
             {
            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__weak__                   = 0, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 1, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 2, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 3, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nocommon__               = 4, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__      = 5, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 6,/*!< GNU specific attribute for (GNU extension) */

            // DQ (12/30/2013): Added support fo packing for variables (e.g. field values), instead of just there types.
            // Also, fixed bug where packed was same enum value as weakref
               e_gnu_attribute__packed__                 = 7,/*!< GNU specific attribute for (GNU extension) */

            // DQ (1/6/2014): Added support for GNU noreturn attribute
               e_gnu_attribute__noreturn__               = 8,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noreorder__              = 9,/*!< GNU specific attribute for (GNU extension) */

               e_ms_declspec_parameter_appdomain    = 10, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_deprecated   = 11, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_dllimport    = 12, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_dllexport    = 13, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_novtable     = 14, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_process      = 15, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_property     = 16, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_restrict     = 17, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_selectany    = 18, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_thread       = 19, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_uuid         = 20, /*!< Microsoft declspec() attributes */

               e_last_gnu_variable_attribute /*!< last value (upper bound on range of values, used in error checking) */
             };

        // driscoll6 (8/4/11): support for excess specifiers in python (*args and **kwargs)
          enum excess_specifier_enum
             {
               e_excess_specifier_none = 0,
               e_excess_specifier_positionals,
               e_excess_specifier_keywords,
               e_excess_specifier_last /* sentry */
             };

          bool checkBit ( unsigned int bit ) const;
          void setBit ( unsigned int bit );
          void unsetBit ( unsigned int bit );

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeNoCommon() const;
          void setGnuAttributeNoCommon();
          void unsetGnuAttributeNoCommon();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

       // DQ (12/30/2013): Added support fo packing for variables (e.g. field values), instead of just there types.
       // The differences are represented in test codes: test2013_104.c and test2013_113.c.
          bool isGnuAttributePacked() const;
          void setGnuAttributePacked();
          void unsetGnuAttributePacked();

       // DQ (1/6/2014): Added support for noreturn attribute on function parameters (appies only for function pointers used as function parameters).
          bool isGnuAttributeNoReturn() const;
          void setGnuAttributeNoReturn();
          void unsetGnuAttributeNoReturn();

          bool isGnuAttributeNoReorder() const;
          void setGnuAttributeNoReorder();
          void unsetGnuAttributeNoReorder();

          bool is_ms_declspec_parameter_appdomain() const;
          void set_ms_declspec_parameter_appdomain();
          void unset_ms_declspec_parameter_appdomain();

          bool is_ms_declspec_parameter_deprecated() const;
          void set_ms_declspec_parameter_deprecated();
          void unset_ms_declspec_parameter_deprecated();

          bool is_ms_declspec_parameter_dllimport() const;
          void set_ms_declspec_parameter_dllimport();
          void unset_ms_declspec_parameter_dllimport();

          bool is_ms_declspec_parameter_dllexport() const;
          void set_ms_declspec_parameter_dllexport();
          void unset_ms_declspec_parameter_dllexport();

          bool is_ms_declspec_parameter_novtable() const;
          void set_ms_declspec_parameter_novtable();
          void unset_ms_declspec_parameter_novtable();

          bool is_ms_declspec_parameter_process() const;
          void set_ms_declspec_parameter_process();
          void unset_ms_declspec_parameter_process();

          bool is_ms_declspec_parameter_restrict() const;
          void set_ms_declspec_parameter_restrict();
          void unset_ms_declspec_parameter_restrict();

          bool is_ms_declspec_parameter_selectany() const;
          void set_ms_declspec_parameter_selectany();
          void unset_ms_declspec_parameter_selectany();

          bool is_ms_declspec_parameter_thread() const;
          void set_ms_declspec_parameter_thread();
          void unset_ms_declspec_parameter_thread();

          bool is_ms_declspec_parameter_uuid() const;
          void set_ms_declspec_parameter_uuid();
          void unset_ms_declspec_parameter_uuid();

          void post_construction_initialization() override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
       // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int index) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          SgStorageModifier & get_storageModifier();

       // DQ (8/10/2010): Added const version of this function!
          const SgStorageModifier & get_storageModifier() const;

          SgInitializedName(
               const SgName& name,
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgDeclarationStatement *declptr = 0,
//  QY 11/2/04  removed itemptr
//               SgInitializedName *itemptr = 0,
               SgInitializedName *prev_decl_item = 0 ) ROSE_DEPRECATED_FUNCTION;

       // DQ (8/4/2006): New constructor that explicitly includes the Sg_File_Info and SgScopeStatement (recently added data members)
          SgInitializedName ( Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr,
                              SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr );

#ifdef BUILD_X_VERSION_TERMINALS
          SgInitializedName(
               const SgName& name,
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgX_DeclarationStatement *declptr = 0,
               SgInitializedName *prev_decl_item = 0 );
#endif

       // DQ (10/13/2014): Adding a default constructor for compatability with what was previously the API before the newer aterm support.
          SgInitializedName() ROSE_DEPRECATED_FUNCTION;

          SgInitializedName(const SgInitializedName& ptr);

          SgInitializedName& operator= (const SgInitializedName& ptr);

          bool operator== (const SgInitializedName& ) const;
          bool operator< (const SgInitializedName&) const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): This custom function to match the version that would be automatically by ROSETTA, but we
       // want to have a custom version of set_name(SgName name) that permits names to be reset (unloaded from the
       // symbol table are reloaded into the symbol table).
       // SgName get_name() const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): Put back into place afterhaving been removed by accident in 12/xx/2004
       // AJ (10/21/2004): Added function to support changing names of symbols, note that void set_name(SgName name)
       // would be the automatically generated function.
       // void set_name(SgName name);
       // int set_name(SgName new_name);

          SgType *get_type() const;
          void set_type(SgType *t);

          SgInitializer *get_initializer() const;
          void set_initializer(SgInitializer* i);

#ifdef BUILD_X_VERSION_TERMINALS
       // Modified from SAGE (added access functions for X version of DeclarationStatement data member
          SgX_DeclarationStatement *get_X_declaration() const;
          void set_X_declaration(SgX_DeclarationStatement* decl);
#endif

          SgDeclarationStatement *get_declaration() const;
         // void set_declaration(SgDeclarationStatement* decl);

          SgDeclarationStatement *get_definition() const;
          void set_definition(SgDeclarationStatement* def);

       // DQ (8/2/2004): Force an explicit function matching the virtual function defined in SgNode
       // Sg_File_Info* get_file_info() const;

      //! Returns the name with appropriate qualified names representing nested scopes
          SgName get_qualified_name() const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (11/6/2006): use this to return the startOfConstruct source position.
       //   virtual Sg_File_Info* get_file_info(void) const;
       //   virtual void set_file_info(Sg_File_Info* X);

       // DQ (2/6/2007): Added support to get the symbol from the declaration (via the symbol table in the scope)
      //! Get the associated SgSymbol from the symbol table located in the scope, without considering possible prev_decl_item. Internal use only. Users should use search_for_symbol_from_symbol_table() instead.
          SgSymbol* get_symbol_from_symbol_table() const;

       // PC (10/1/2009): Added support to get the symbol from the correct associated declaration
       //! User interface for retrieving the associated symbol. It searches through the possible chain of prev_decl_item.
          SgSymbol* search_for_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (12/16/2013): Added support for name qualification on SgInitializedName for use in preinitialization lists.
          SgName get_qualified_name_prefix() const;

       // DQ (3/21/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length_for_type);

       // DQ (3/31/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required_for_type);

       // DQ (3/31/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required_for_type);

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix_for_type() const;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);

HEADER_INITIALIZED_NAME_END


HEADER_NAME_START
       // We need to define the default constructor explicitly
       // (else p_char is not initialized properly to NULL)
          SgName();
          SgName(const char* str);
          SgName(const std::string& str);
          SgName(const SgName& n);

      // ~SgName();

          int operator!=(const SgName& n1) const;
          int operator==(const SgName& n1) const;
          int operator< (const SgName& n1) const;

       // DQ (11/27/2010): Added to support case sensitive and case insensitive semantics.
          static bool caseInsensitiveEquality ( const SgName & x, const SgName & y );

       // DQ (4/21/2020): I think this might be used but not defined.
       // Added to support assignments to string variables.
          operator std::string () const;

       // DQ (11/28/2009): Fixed return value of function to be "bool" instead of "int"
          bool is_null(void) const;
          void replace_space(char t);
          SgName& operator<<(const std::string& str);

          static SgName itoname(int val);

          SgName& operator<<(int val);
          SgName& operator=(const SgName& n1);
          SgName& tail(int n); // keep std::string after n
          SgName& head(int n); // keep first n chars

          const char* str() const;
          std::string& getString();
          const std::string& getString() const;

       // In places where the str() member function is called it is toe get the
       // length of the std::string in p_char so it makes since to provide a member
       // function to get the length instead of making a the str() function a
       // const member function!
          unsigned int get_length() const;

       // DQ: We made this a const function to work with the Sage Symbol Table implementation
       // But it is a bad idea to have it since it causes problems where it is used.
       // EXAMPLE: char* char_pointer = tempSgName;
       // this code fragment causes a new SgName object to be build and the pointer to
       // the std::string in the new object is returned then the SgName object goes out of
       // scope and then reading the std::string causes a purify FMR error!
       // It might be that it should not be a const function (this is likely the
       // real source of the problem), but I would like to remove it anyway for
       // now to simplify the debugging!
       // operator char*() const;

       // To handle "assert(p_name != NULL);" where p_name is a SgName
       // object, STL requires that the "operator==()" be defined
       // (STL builds the "operator!=()" from the "operator==()"
          bool operator== (const int) const { return false; }

          void display( const std::string& label ) const;

       // DQ (9/9/2004): Supporting function for building qualified names (specialied std::string concatination)
          static SgName assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName);

       // DQ (9/9/2004): friend function (string concatination)
          ROSE_DLL_API friend SgName operator+(const SgName & n1, const SgName & n2);

       // DQ (11/15/2004): Added to support general string operations (first used in the unparser)
          SgName & operator+= (const SgName & n1);

          SgName invertCase() const;

HEADER_NAME_END


HEADER_NAME_POSTDECLARATION_START
// extern const SgName defaultName("defaultName");

// DQ (10/5/2007): We no longer need this!
// extern const SgName SgdefaultName;

HEADER_NAME_POSTDECLARATION_END


HEADER_QUALIFIED_NAME_START
HEADER_QUALIFIED_NAME_END


HEADER_ATTRIBUTE_START
       // SgAttribute(char* str);
          int isSame(const std::string& str);

       // DQ (12/6/2016): This needs to match being const as in the derived class (this also eliminates a compiler warning).
       // virtual bool isPragma() { return 0; } // MS02/22/02
          virtual bool isPragma() const { return 0; }

       // char *get_name() const;

      protected:
       // char* p_name;

HEADER_ATTRIBUTE_END


HEADER_BIT_ATTRIBUTE_START
       // SgBitAttribute(char *str);

//        int isAttributeSet(unsigned long int bit) const;
//        void setAttribute(unsigned long int bit);
//        void unsetAttribute(unsigned long int bit);
//        int isPragma() const;

  // private:
  //      unsigned long int p_bitflag;

HEADER_BIT_ATTRIBUTE_END


HEADER_FUNCTION_DECLARATION_ATTRIBUTE_START
       // SgFuncDecl_attr();
       // void set_suppress_atomic();
       // int get_suppress_atomic() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFuncDecl_attr();

     private:
       // enum { e_suppressatomic = 0x00000001 };

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_END

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
// int get_suppress_atomic(SgFunctionDeclaration *);
// void set_suppress_atomic(SgFunctionDeclaration *);

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFuncDecl_attr::SgFuncDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END



HEADER_CLASS_DECLARATION_ATTRIBUTE_START
       /* local attribute class to suppress the printing of global keyword */
//        SgClassDecl_attr();
//        void set_suppress_global();
//        int get_suppress_global() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgClassDecl_attr();

     private:
//        enum { e_suppress_global = 0x00000001 };

HEADER_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_CLASS_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgClassDecl_attr::SgClassDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE.
//
       /* local attribute class to suppress the printing of global keyword */
          SgTemplateInstDecl_attr();
          void set_suppress_global();
          int get_suppress_global() const;

     private:

      /*! What is this enum value for???  Shouldn't there be a name? */
          enum
             {
               e_suppress_global = 0x00000001 /*!< What is the point of having a single value here? */
             };

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//int get_suppress_globalSgClassDeclaration *);
//void set_suppress_global(SgClassDeclaration *);

HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION.
//
int get_suppress_global(SgTemplateInstantiationDecl *);
void set_suppress_global(SgTemplateInstantiationDecl *);

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END


HEADER_PRAGMA_START
       // SgPragma(char *name);

          void post_construction_initialization() override;

          std::string get_pragma() const;
          bool samePragma(const std::string& str);
          bool isPragma() const override;
          bool gotPrinted() const;
          void setPrinted(bool s = true);

       // DQ (8/3/2004): added function to match virtual function in SgNode
          Sg_File_Info* get_file_info() const override;

HEADER_PRAGMA_END


HEADER_FILE_INFORMATION_START

      /*! \brief Enum type containing classifications if IR nodes.

          This is part of the classification mechanism for IR nodes within ROSE.
          Compiler generated code is not output in the code generation phase,
          but some compiler generated IR nodes must be output so such nodes are explicitly
          marked within the classification process (implemented in ASTFixes.C).
             - Examples of transformation IR nodes include:
                -# Any relocated AST subtrees
                -# Any new IR nodes
             - Examples of compiler-generated IR nodes include:
                -# Any implicit or unnecessary casts not explicitly represented in the source code
                -# Instantiated templates
             - Examples of compiler-generated code marked for output (in code generation phase) include:
                -# Any transformed template instantiations
                -# required templates assigned to specific files (see ROSE prelinking details)
             - Examples of shared IR nodes include:
                -# All types (not implemented yet)
                -# All IR nodes shared across originally separate ASTs (see AST Merge Mechanism)
             - Examples of frontend specific IR nodes include:
                -# float __builtin_acosf (float __builtin__x);
                -# #define __builtin_va_start va_start
                -# All functions and variables defined in "rose_edg_required_macros_and_functions.h"

          \internal We need constructors taking a value of this type.
       */
          enum classifier
             {
               e_transformation                          = 0x1,  /*!< classify as a transformation */
               e_compiler_generated                      = 0x2,  /*!< classify as compiler generated */
               e_output_in_code_generation               = 0x4,  /*!< classify as required when generating code in unparser (orthogonal concept to transformation and compiler generated) */
               e_shared                                  = 0x8,  /*!< classify as a shared IR node (part of evolving support for AST merging) */
               e_frontend_specific                       = 0x10, /*!< classify as frontend specific (e.g. gnu compatable function from rose_edg_required_macros_and_functions.h) */
               e_source_position_unavailable_in_frontend = 0x20, /*!< classify as explictly unabailable from front-end */
               e_comment_or_directive                    = 0x40, /*!< classify as a comment or directive (not a part of the language grammar) */
               e_token                                   = 0x80, /*!< classify as a token from the parser (not a part of the language grammar) */
            // DQ (4/24/2013): Added support for default arguments.
               e_default_argument                        = 0x100,/*!< classify as a default arguement to function call expression */
            // DQ (4/24/2013): Added support for implicit cast.
               e_implicit_cast                           = 0x200 /*!< classify as a implicit cast */
             };

       // ~Sg_File_Info();

       // DQ (5/10/2006): Remove these to simplify implementation.
          Sg_File_Info();
       // Sg_File_Info(const char* filename, int line = 0, int col = 0) ROSE_DEPRECATED_FUNCTION;
          Sg_File_Info(const std::string & filename, int line = 0, int col = 0);

       // DQ (2/15/2003): added copy constructor
          Sg_File_Info(const Sg_File_Info & X);

       // DQ (11/6/2008): Added to support construction of objects using Dwarf information.
          Sg_File_Info( int file_id, int line, int column );

          void post_construction_initialization() override;

       // ROSE-1499, ROSE-1639 (added const to char*)
          void check_file_id(const char * label, bool assertion=true) const;

       // DQ (11/6/2008): Added support for extending the internal static filename to integer id map
      //! Access function to permit files referenced in Dwarf to be mapped to integers using the same scheme as for source code.
          static int addFilenameToMap ( const std::string & filename );

      //! Returns the number of entries in the filename map
          static int numberOfSourceFiles();

          void set_filename (const char* filename) ROSE_DEPRECATED_FUNCTION;
          void set_filenameString ( const std::string & filename );
          void set_line (int line);
          void set_col ( int n );
          void display (const std::string label ) const;
          void display () const;
          std::string displayString (const std::string & label = "") const;
          //void output (std::ostream& os) ROSE_DEPRECATED_FUNCTION;

       // DQ (6/11/2007): output static data for debugging
          static void display_static_data( const std::string label );

          const char* get_filename() const ROSE_DEPRECATED_FUNCTION;
          const std::string& get_filenameString() const;
          int   get_line() const;
          int   get_col() const;

       // DQ (2/28/2019): Support for multi-file handling.
      //! Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.
          int   get_line(int file_id) const;

          void set_file_id ( int file_id );
          int  get_file_id () const;

          std::string get_raw_filename() const;
          int  get_raw_line() const;
          int  get_raw_col() const;

       // DQ (12/18/2012): Added support for physical filename and line number data.
          void set_physical_filename ( const std::string & filename );
          std::string get_physical_filename() const;
          void set_physical_file_id ( int physical_file_id );
          int  get_physical_file_id () const;
          void set_physical_line (int line);
          int  get_physical_line() const;
          void set_physical_source_position_to_match_logical_source_position();

#if 1
       // DQ (5/20/2021): Added to support debugging.
          int*  get_physical_file_id_reference ();
#endif

       // DQ (2/28/2019): Support for multi-file handling.
      //! Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.
          int  get_physical_line(int file_id) const;

       // DQ (2/28/2019): This is required because the physical id returned can be dependent on the file id when this is a shared IR node.
          int  get_physical_file_id (int file_id) const;

       // DQ (1/23/2013): Added source position sequence information. This work supports the handling of default arguments and addresses
       // new future capabilities to ROSE.
          void set_source_sequence_number (unsigned int n);
          unsigned int get_source_sequence_number() const;

       // DQ (12/22/2006): This copies the line number and column number information and verifies that
       // the file name is the same (it does not reset any fo the classification flags).  This is more
       // useful than the assignment operator for updating information and is used in the file:
       // fixupSourcePositionInformation.C
          void updateSourcePosition ( Sg_File_Info* update );

       // DQ (6/20/2005): There are a number of reasons why an IR node might not have a position in the source code
       // this function abstracts that query process.
          bool hasPositionInSource() const;

          bool isSameFile(SgFile* file) const;

          bool isSameFile(Sg_File_Info* fileInfo) const;
          bool isSameFile(const Sg_File_Info & fileInfo) const;

      //! Access function for classification bit field
          bool isTransformation() const;

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          bool isCompilerGenerated() const;
          bool isCompilerGeneratedNodeToBeUnparsed() const ROSE_DEPRECATED_FUNCTION;
          bool isOutputInCodeGeneration() const;
          bool isShared() const;
          bool isFrontendSpecific() const;

          bool isSourcePositionUnavailableInFrontend() const;
          void unsetSourcePositionUnavailableInFrontend();
          void setSourcePositionUnavailableInFrontend();

       // DQ (12/23/2006): Added to support the Sg_File_Info objects used by comments and CPP directives
       // (since their parents are NULL, becuase the PreprocessingInfo class is not dirived from a SgNode
       // the parent point can't be used to point to it).
          bool isCommentOrDirective() const;
          void unsetCommentOrDirective();
          void setCommentOrDirective();

       // DQ (12/23/2006): Added to support Rama and Andreas's work on handling of token streams within the AST.
       // (The Sg_File_Info objects used have NULL parent pointers, becuase the token class is not dirived from a SgNode.
          bool isToken() const;
          void unsetToken();
          void setToken();

       // DQ (4/24/2013): Added support for marking as default argument.  Note that compiler generated is not specific
       // enough because even implicit casts would then be confused as default arguments.
          bool isDefaultArgument() const;
          void unsetDefaultArgument();
          void setDefaultArgument();

       // DQ (4/26/2013): Added support for marking as implicit casts.  Note that compiler generated is not
       // as specific as we want (though it has worked for a long time, we want a more precise mechanism).
          bool isImplicitCast() const;
          void unsetImplicitCast();
          void setImplicitCast();

      //! Set/unset functions for classification bit field
          void unsetTransformation();
          void setTransformation();

      //! Mark as compiler generated but as required to be output by unparser (e.g. required template instatiations)
          void unsetCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;
          void setCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;

      //! Mark as to be output by the unparser (code generator)
          void unsetOutputInCodeGeneration();
          void setOutputInCodeGeneration();

      //! Support for shared IR nodes (shared via AST merge mechanism)
          void unsetShared();
          void setShared();

       // DQ (5/6/2006): Added to support gnu compatability mode (incomplete within EDG and
       // which we make complete through the declaration of builtin functions as required).
          void unsetFrontendSpecific();
          void setFrontendSpecific();

       // MK (8/2/05) : Added support for unparsing set, to allow shared nodes to only be unparsed by
       //               the appropriate files
      //! Add files to the set that should be able to unparse the node
          void addFileToUnparse(int file_id);
      //! Should this node be unparsed by this file?
          bool shouldUnparse(int file_id);

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          void unsetCompilerGenerated();
          void setCompilerGenerated();

       // DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
          static Sg_File_Info* generateDefaultFileInfo();

          static Sg_File_Info* generateDefaultFileInfoForTransformationNode();

       // DQ (1/11/2006): Added static function whicl allows specification of transformation with assignement to
       // a specific file (where it would be unparsed). This function will call setOutputInCodeGeneration().
          static Sg_File_Info* generateFileInfoForTransformationNode( int file_id );
          static Sg_File_Info* generateFileInfoForTransformationNode( std::string filename );

          static Sg_File_Info* generateDefaultFileInfoForCompilerGeneratedNode();


      //! Get whole bit field fr modifier set
          unsigned int get_classificationBitField(void) const;
          void set_classificationBitField( unsigned int );

          void set_isPartOfTransformation( bool isPartOfTransformation ) ROSE_DEPRECATED_FUNCTION;
          bool get_isPartOfTransformation() ROSE_DEPRECATED_FUNCTION;

          void register_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION; /* register interest */
          void deregister_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION;

       // DQ (7/4/2005): Added to test internal consistancy
          bool ok() const;

       // MK (8/2/05) : Added functions to interface with fileid maps, in order to eventually
       //               restrict access to the maps themselves
       // PC and AS (8/29/06) : made function return a const string reference as this will
       // eliminate the temporary string within the lifetime of the function.
          static const std::string& getFilenameFromID( int id );
          static int getIDFromFilename( std::string filename );

       // DQ (11/2/2006): Added simple assignment operator.
          Sg_File_Info & operator= ( const Sg_File_Info & X );

       // DQ (9/26/2004): Added operator== to permit testing of reused definitions of defining declarations!
          friend bool operator== ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/6/2004): Added operator!= to permit testing of reused definitions of defining declarations!
          friend bool operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/25/2004): Added operator> to permit testing of strting vs. ending file info object (assert starting < ending)
          friend bool operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y );

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember fileidtoname_map.
          static std::map<int, std::string> & get_fileidtoname_map();
       //! Access function for map of file names.
          static void set_fileidtoname_map(std::map<int, std::string> & X);

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember nametofileid_map.
         static std::map<std::string, int> & get_nametofileid_map();
       //! Access function for map of file names.
         static void set_nametofileid_map(std::map<std::string,int> & X);

       // MK (7/22/05) This enum is used by the file id mechanism
       /*! \brief Enum to hold previously common default values for filename used by the default and static SgNULL_File constructors.

           \internal These values can and likely should disappear in the future.
        */
          enum p_fileflags {
               COPY_FILE_ID                                 = -1, /*!< default value (equivalent to filename with "COPY") */
               NULL_FILE_ID                                 = -2, /*!< value equivalent to filename with "NULL_FILE" */
               TRANSFORMATION_FILE_ID                       = -3, /*!< value for all nodes marked as part of a translation */
               COMPILER_GENERATED_FILE_ID                   = -4, /*!< value for compiler generated IR nodes (NOT marked for output) */
               COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID = -5, /*!< value for compiler generated IR nodes (marked for output, deprecated value) */
            // MK (8/2/05) : Added new enum value to facilitate interface to maps. If we try
            //               to retrieve the fileid for a filename which isn't in the map, we return
            //               BAD_FILE_ID to indicate this.
               BAD_FILE_ID = -6   /*!< value returned if there is no file id mapped to given filename */
             };


HEADER_FILE_INFORMATION_END

HEADER_APPLICATION_FILE_PREDECLARATION_START
HEADER_APPLICATION_FILE_PREDECLARATION_END

HEADER_APPLICATION_FILE_START

private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
             s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgSupport);
             // Most data members are not serialized yet, but this is here because SgFile is a base class of
             // SgBinaryComposite whose fields are serialized.
        }

public:

       /*! \brief Enum type used to specify output of Fortran as fixed for free format.

           \internal Has no effect on C/C++ code generation.
        */
          enum outputFormatOption_enum
             {
               e_unknown_output_format,    /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_fixed_form_output_format, /*!< value used to specify output of Fortran as fixed format */
               e_free_form_output_format   /*!< value used to specify output of Fortran as free format */
             };


       /*! \brief Enum type used to specify output language (option used for testing unparsers).

           \internal This is only for testing the unparsers and some language constructs will not unparse.
                     This is also a way to play with some language translation ideas, but most useful one
                     will require a specialized tranlator to be built.
        */
          enum languageOption_enum
             {
               e_error_language,   /*!< error value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_default_language, /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_C_language,       /*!< value used to specify output of C (for testing C unparser) */
               e_Cxx_language,     /*!< value used to specify output of C++ (for testing C++ unparser) */
               e_Binary_language,  /*!< value used to specify output of Binary ISA */
               e_Fortran_language, /*!< value used to specify output of Fortran (for testing the Fortran unparser) */
               e_Java_language,    /*!< value used to specify output of Java (for testing Java unparser) */
               e_Jvm_language,     /*!< value used to specify Java binary JVM language */
               e_Promela_language, /*!< value used to specify output of Promela for uses with SPIN (unsupported option) */
               e_PHP_language,     /*!< value used to specify output of PHP    */
               e_Python_language,  /*!< value used to specify output of Python */
               e_Csharp_language,  /*!< value used to specify output of Csharp */
               e_Ada_language,     /*!< value used to specify output of Ada    */
               e_Jovial_language,  /*!< value used to specify output of Jovial */
               e_last_language     /*!< upper bound on the range of values supported for the outputLanguageOption_enum */
             };

public:
          enum standard_enum
             {
               e_default_standard,
               e_c89_standard,
               e_c90_standard,
               e_c99_standard,
               e_c11_standard,
               e_c17_standard,
               e_c23_standard,
               e_c2y_standard,
               e_upc_standard,
               e_cxx98_standard,
               e_cxx03_standard,
               e_cxx11_standard,
               e_cxx14_standard,
               e_cxx17_standard,
               e_cxx20_standard,
               e_cxx23_standard,
               e_cxx26_standard,
               e_upcxx_standard,
               e_f77_standard,
               e_f90_standard,
               e_f95_standard,
               e_f03_standard,
               e_f08_standard,
               e_f18_standard
             };

public:
          enum standard_enum get_standard(void) const;
          void set_standard(enum standard_enum e_std);
          void set_default_standard(void);

          /** A string to report standard in debug messages (for example). */
          std::string display_standard(enum standard_enum e_std);

          bool is_gnu_standard(void) const;
          void set_gnu_standard();
          void unset_gnu_standard();

          bool get_C89_only (void) const;
          void set_C89_only (void);

          bool get_C89_gnu_only (void) const;
          void set_C89_gnu_only (void);

          bool get_C90_only (void) const;
          void set_C90_only (void);

          bool get_C90_gnu_only (void) const;
          void set_C90_gnu_only (void);

          bool get_C99_only (void) const;
          void set_C99_only (void);

          bool get_C99_gnu_only (void) const;
          void set_C99_gnu_only (void);

          bool get_C11_only (void) const;
          void set_C11_only (void);

          bool get_C11_gnu_only (void) const;
          void set_C11_gnu_only (void);

          bool get_C17_only (void) const;
          void set_C17_only (void);

          bool get_C17_gnu_only (void) const;
          void set_C17_gnu_only (void);

          bool get_C23_only (void) const;
          void set_C23_only (void);

          bool get_C23_gnu_only (void) const;
          void set_C23_gnu_only (void);

          bool get_C2y_only (void) const;
          void set_C2y_only (void);

          bool get_C2y_gnu_only (void) const;
          void set_C2y_gnu_only (void);

          bool get_UPC_only (void) const;
          void set_UPC_only (void);

          bool get_Cxx98_only (void) const;
          void set_Cxx98_only (void);

          bool get_Cxx98_gnu_only (void) const;
          void set_Cxx98_gnu_only (void);

          bool get_Cxx03_only (void) const;
          void set_Cxx03_only (void);

          bool get_Cxx03_gnu_only (void) const;
          void set_Cxx03_gnu_only (void);

          bool get_Cxx11_only (void) const;
          void set_Cxx11_only (void);

          bool get_Cxx11_gnu_only (void) const;
          void set_Cxx11_gnu_only (void);

          bool get_Cxx14_only (void) const;
          void set_Cxx14_only (void);

          bool get_Cxx14_gnu_only (void) const;
          void set_Cxx14_gnu_only (void);

          bool get_Cxx17_only (void) const;
          void set_Cxx17_only (void);

          bool get_Cxx17_gnu_only (void) const;
          void set_Cxx17_gnu_only (void);

          bool get_Cxx20_only (void) const;
          void set_Cxx20_only (void);

          bool get_Cxx20_gnu_only (void) const;
          void set_Cxx20_gnu_only (void);

          bool get_Cxx23_only (void) const;
          void set_Cxx23_only (void);

          bool get_Cxx23_gnu_only (void) const;
          void set_Cxx23_gnu_only (void);

          bool get_Cxx26_only (void) const;
          void set_Cxx26_only (void);

          bool get_Cxx26_gnu_only (void) const;
          void set_Cxx26_gnu_only (void);

          bool get_UPCxx_only (void) const;
          void set_UPCxx_only (void);

          bool get_F77_only     (void) const;
          void set_F77_only     (void);

          bool get_F90_only     (void) const;
          void set_F90_only     (void);

          bool get_F95_only     (void) const;
          void set_F95_only     (void);

          bool get_F2003_only   (void) const;
          void set_F2003_only   (void);

          bool get_F2008_only   (void) const;
          void set_F2008_only   (void);

          bool get_F2018_only   (void) const;
          void set_F2018_only   (void);

public:

      //! The only useful constructor (argc and argv are the user's command line inputs).
          SgFile(int &argc, char** &argv, SgProject* project = nullptr);
          SgFile(std::vector<std::string>& argv, SgProject* project = nullptr);

          SgFile(const SgFile &) = delete;
          SgFile & operator= (const SgFile &) = delete;

          void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

      //! Generate the C++ file representing the AST
          void unparse(UnparseFormatHelp *unparseHelp = nullptr, UnparseDelegate* unparseDelagate = nullptr);

       // DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information)
       // to be relative to the generated code instead of the original input code.  This is useful when
       // we want to output references to the position of language constructs in the generated code
       // instead of the original input code.  Also useful for building references to locations in
       // automatically generated code.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      //! Member function to compile the resulting output file from unparsing
         int compileOutput(int fileNameIndex);

      //! associated filename
          std::string getFileName() const;

// #ifndef ROSE_USE_SWIG_SUPPORT
#ifndef SWIG
       // DQ (3/10/2013): This function is left undefined in the final link step for SWIG support, so remove it from SWIG processing for now.
          friend void alternativeSageEdgInterfaceConstruction( SgFile *file );
#endif

       // Get the commandline from where it is stored internally
          virtual int callFrontEnd();

      //! Fixups to be run when the whole project has been created (this attaches preprocessing information).
          void secondaryPassOverSourceFile();

       // DQ (9/2/2008): Added to factor out detail for building the AST in callFrontEnd().
          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! Move this function from ROSE into the AST restructuring tool
          void processRoseCommandLineOptions(std::vector<std::string>& argv);

       // DQ (6/21/2005): Added support for backend specific command-line options to be recognized in ROSE
       // (required to control template instantiation).  Does not modify input parameters.
          void processBackendSpecificCommandLineOptions ( const std::vector<std::string>& argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all rose related options from a command line
          static void stripRoseCommandLineOptions ( std::vector<std::string> & argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all EDG related options from a command line
          static void stripEdgCommandLineOptions ( std::vector<std::string> & argv );

       // DQ (4/2/2011): Added Fortran specific support to filter command line options from the backend compiler's command line.
      //! function that removes all OFP related options from a command line
          static void stripFortranCommandLineOptions ( std::vector<std::string> & argv );

       // Pei-Hung (12/20/2021): Added translator support to filter command line options from the backend compiler's command line.
      //! function that removes options that should be used only in frontend from a command line
          static void stripTranslationCommandLineOptions ( std::vector<std::string> & argv );

       // BP : 11/13/2001, modified to take compiler name
          void build_EDG_CommandLine ( std::vector<std::string> & inputCommandLine, std::vector<std::string>& argv, int fileNameIndex );

       // TV: 02/15/12, CLANG also need a command line builder
          void build_CLANG_CommandLine ( std::vector<std::string> & inputCommandLine, std::vector<std::string>& argv, int fileNameIndex );

       // Move this function from ROSE into the AST restructuring tool (placed here os it can be called)
          static void usage ( int status );

      //! Move this function from ROSE into the AST restructuring tool
          std::string getWorkingDirectory ();
          std::string getSourceDirectory  ();

      //! Generate an output filename from the source file name (xxx.C -> rose_xxx.C -> xxx.o -> xxx)
          std::string generateOutputFileName() const;

       // DQ (9/24/2013): I think this is more useful as a static function (and I need it this way in the unparser).
      //! Support for C preprocessed files (Fortran only).
          static std::string generate_C_preprocessor_intermediate_filename( std::string filename );

       // The unparser and vendor compiler needs access to many variables
       // that are protected (Later this should be a member function).
          std::vector<std::string> buildCompilerCommandLineOptions ( std::vector<std::string> & argv, int fileNameIndex, const std::string& compilerName );
          int compileOutput ( std::vector<std::string> & argv, int fileNameIndex );

          void display ( const std::string & label ) const;

      //! Test if project is compiled with -prelink as signal that we are prelinking and we have
      //! to process the generated code instead of the user's application (to see and instatiate
      //! all templates).
          bool isPrelinkPhase() const;

      //! Get the SgProject IR node if available (template instantiation information is stored there)
          SgProject* get_project();

      //! Access function calling get_startOfConstruct(), provided to support older interface.
          Sg_File_Info* get_file_info() const override;

      //! Access function calling set_startOfConstruct(), provided to support older interface.
          void set_file_info( Sg_File_Info* fileinfo );

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This function is called at several locations to build SgSourceFiles of different types (languages).
          void initializeSourcePosition(const std::string & sourceFilename);

       // DQ (6/13/2013): Added to support to call the frontend after all SgFiles are built up.
          void runFrontend(int &nextErrorCode);

       // DQ (9/24/2013): Added function to output the name of the language for the generated code.
          static std::string get_outputLanguageOptionName(languageOption_enum);

       // DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented
       // as a static member variable instead of non-static member variable.  See test2015_141.c
       // for where this is required.
          static void set_skip_unparse_asm_commands(bool);
          static bool get_skip_unparse_asm_commands();

       // DQ (4/24/2021): Added support for p_header_file_unparsing_optimization to be implemented
       // as a static member variable instead of non-static member variable.  Part of header file
       // optimization support.
          static void set_header_file_unparsing_optimization(bool);
          static bool get_header_file_unparsing_optimization();

HEADER_APPLICATION_FILE_END

HEADER_APPLICATION_SOURCE_FILE_START
#ifndef ROSE_SKIP_COMPILATION_OF_WAVE
     public:
       // King84 (2010.09.22): Added support for getting the preprocessed token stream and the raw token stream.
          typedef boost::wave::cpplexer::lex_token<>  token_type;
          typedef std::list<token_type>             LexTokenList;
     protected:
          LexTokenList rawTokenStream;
     public:
          LexTokenList& get_rawTokenStream() { return rawTokenStream; }
#else
     public:
#endif

          SgSourceFile(std::vector<std::string>& argv, SgProject* project = nullptr);
          virtual int callFrontEnd() override;

          SgSourceFile(const SgSourceFile &) = delete;
          SgSourceFile & operator= (const SgSourceFile &) = delete;

          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine ) override;
// #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT // Liao 6/25/2010, support enable-only-c and haskell

      //! Divide up the handling of different languages
          int build_Fortran_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

      //! Support for processing Java source files.
          int build_Java_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
// #endif
          int build_C_and_Cxx_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_PHP_AST();
          int build_Python_AST();

       // DQ (8/25/2017): Adding multiple language support (function definitions in src/frontend/SageIII/sage_support/sage_support.C).
          int build_Csharp_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_Ada_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_Jovial_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

       // DQ (12/19/2008): Added support for translation source position information using CPP linemarkers (this is specific to Fortran).
          void processCppLinemarkers();

       // DQ (12/13/2012): Added support for more translation source position information using CPP linemarkers (this is not specific to Fortran).
       // void gatherASTSourcePositionsBasedOnDetectedLineDirectives();
          void fixupASTSourcePositionsBasedOnDetectedLineDirectives(std::set<int> equivalentFilenames);

       // DQ (9/5/2008): Support for older name of the SgGlobal in SgSourceFile
       // SgGlobal* get_root() const;

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This should be the only place where the SgGlobal (global scope object) is built.
          void initializeGlobalScope();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (1/20/2021): Changed the API to use a pointer to a std::map<SgNode*,TokenStreamSequenceToNodeMapping*> instead of a reference.
       // DQ (10/28/2013): Abstract access to the new token subsequence map (currently for statements).
          void set_tokenSubsequenceMap(std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* tokenStreamSequenceMap);
          std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & get_tokenSubsequenceMap();

       // DQ (11/27/2013): Added support for definition of the token unparsing frontier in the AST.
          void set_token_unparse_frontier(std::map<SgStatement*,FrontierNode*> & tokenStreamSequenceMap);
          std::map<SgStatement*,FrontierNode*> & get_token_unparse_frontier();

       // DQ (11/27/2013): Added support for adjacency of nodes in the unparsing frontier in the AST.
          void set_token_unparse_frontier_adjacency(std::map<SgNode*,PreviousAndNextNodeData*> & tokenStreamSequenceMap);
          std::map<SgNode*,PreviousAndNextNodeData*> & get_token_unparse_frontier_adjacency();

       // DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
          void set_redundantlyMappedTokensToStatementMultimap(std::multimap<int,SgStatement*> & X);
          std::multimap<int,SgStatement*> & get_redundantlyMappedTokensToStatementMultimap();

       // DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
          std::set<int> & get_redundantTokenEndingsSet();
          void set_redundantTokenEndingsSet(std::set<int> & X);

       // DQ (9/28/2018): Removed static keyword (I don't think we wnat this to be a static function.
       // DQ (11/20/2015): Added support for retrieving representative whitespace in unparsing transformations when using the token-based unparsing.
          void set_representativeWhitespaceStatementMap(std::map<SgScopeStatement*,SgStatement*> & representativeWhitespaceStatementMap);
          std::map<SgScopeStatement*,SgStatement*> & get_representativeWhitespaceStatementMap();

       // DQ (9/28/2018): Removed static keyword (I don't think we wnat this to be a static function.
       // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.
          void set_macroExpansionMap(std::map<SgStatement*,MacroExpansion*> & macroExpansionMap);
          std::map<SgStatement*,MacroExpansion*> & get_macroExpansionMap();

       // DQ (3/2/2022): Added a function to support initialization of all data members.
          void initialization();

HEADER_APPLICATION_SOURCE_FILE_END


HEADER_INCLUDE_FILE_START
HEADER_INCLUDE_FILE_END


HEADER_HEADER_FILE_REPORT_START
     private:
       // Define these as private so that we can control and/or eliminate their use.

     public:
          void display( const std::string & label) const;

HEADER_HEADER_FILE_REPORT_END


HEADER_APPLICATION_BINARY_COMPOSITE_START
        private:
                friend class boost::serialization::access;

                template<class S>
                void serialize(S &s, const unsigned /*version*/) {
                     s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgFile);
                     s & BOOST_SERIALIZATION_NVP(p_genericFileList);
                     s & BOOST_SERIALIZATION_NVP(p_interpretations);
                }

     public:
          SgBinaryComposite(std::vector<std::string>& argv, SgProject* project = nullptr);

          SgBinaryComposite(const SgBinaryComposite &) = delete;
          SgBinaryComposite & operator= (const SgBinaryComposite &) = delete;

          void post_construction_initialization() override;

          virtual int callFrontEnd() override;
          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine ) override;

      //! However, now we have a list of them to support library archives which contain multiple object files (*.o's).
          const SgAsmGenericFile* get_binaryFile() const;
          SgAsmGenericFile* get_binaryFile();
          void set_binaryFile( SgAsmGenericFile* file );

       //! This is refactored code, called once for a binary executable, and called on each object file for a library archive.
          void buildAsmAST( std::string executableFileName );
HEADER_APPLICATION_BINARY_COMPOSITE_END


HEADER_APPLICATION_JVM_COMPOSITE_START
        private:
                friend class boost::serialization::access;

                template<class S>
                void serialize(S &s, const unsigned /*version*/) {
                     s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgBinaryComposite);
                }

     public:
          SgJvmComposite(std::vector<std::string>& argv, SgProject* project = nullptr);

          SgJvmComposite(const SgJvmComposite &) = delete;
          SgJvmComposite & operator= (const SgJvmComposite &) = delete;

          void post_construction_initialization() override;

          virtual int callFrontEnd() override;
          virtual int buildAST(std::vector<std::string> argv, std::vector<std::string> inputCommandLine) override;

HEADER_APPLICATION_JVM_COMPOSITE_END


HEADER_APPLICATION_UNKNOWN_FILE_START
     public:
          SgUnknownFile(std::vector<std::string> &argv, SgProject* project = nullptr);

          virtual int callFrontEnd() override;

HEADER_APPLICATION_UNKNOWN_FILE_END



HEADER_APPLICATION_FILE_LIST_START
     public:

HEADER_APPLICATION_FILE_LIST_END


HEADER_APPLICATION_DIRECTORY_START
     public:
          int numberOfFiles() const;
          SgFile* get_file(int i) const;

          int numberOfDirectories() const;
          SgDirectory* get_directory(int i) const;

          void post_construction_initialization() override;

HEADER_APPLICATION_DIRECTORY_END


HEADER_APPLICATION_DIRECTORY_LIST_START
     public:

HEADER_APPLICATION_DIRECTORY_LIST_END


HEADER_JAVA_IMPORT_STATEMENT_LIST_START
     public:

HEADER_JAVA_IMPORT_STATEMENT_LIST_END


HEADER_JAVA_CLASS_DECLARATION_LIST_START
     public:

HEADER_JAVA_CLASS_DECLARATION_LIST_END


HEADER_APPLICATION_PROJECT_START

      /*! Template Instantiation Options */
          enum template_instantiation_enum
             {
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value */
               e_none     = 2, /*!< no template instantiation */
               e_used     = 3, /*!< instantiate only templates that are used */
               e_all      = 4, /*!< instantiate all possible templates */
               e_local    = 5, /*!< instantiate only used templates and instantiate them as local entities */
               e_last          /*!< last value (used for error checking) */
             };

      //! The only useful constructors (constant folding in the frontend is false by default).
          SgProject(const std::vector<std::string>& argv, bool frontendConstantFolding = false);
          SgProject(int argc, char** argv, bool frontendConstantFolding = false);

       // DQ (4/10/2017): Adding support for use of Saywer for command line handling.
      //! Use of Saywer support for command line handling (work in progress).
          std::vector<std::string> parseCommandLine(std::vector<std::string> argv);

       // DQ (4/10/2017): Adding support for use of Saywer for command line handling.
       // Sawyer::CommandLine::SwitchGroup commandLineSwitches();

      //! Use of Saywer support for specification of ROSE specific command line switches (work in progress).
          Sawyer::CommandLine::SwitchGroup frontendAllSwitches();
          Sawyer::CommandLine::SwitchGroup backendAllSwitches();

      //! process command line and store options in the SgProject object. This options are used by parse und unparse.
          void processCommandLine(const std::vector<std::string>& argv);
          void processCommandLine(int argc, char** argv) { processCommandLine(std::vector<std::string>(argv, argv + argc)); }

      //! parse input file(s)
          int parse();

      //! processes command line and parses all files.
      //! Error code can be accessed using get_frontendErrorCode()
          int parse (const std::vector<std::string>& argv);
          int parse (int argc, char** argv) { return parse(std::vector<std::string>(argv, argv + argc)); }

     private:
          void post_construction_initialization() override;

     public:

          SgProject(const SgProject &) = delete;
          SgProject & operator= (const SgProject &) = delete;

      //! The total number of files in this project (equal to the number of source files specified on the command line)
          int numberOfFiles() const;

      //! Total number of directories in the project.
          int numberOfDirectories() const;

      //! Access function for retrieving a SgFile object from the list stored internally
      //! This function is deprecated and "operator[unsigned int]" should be used instead.
          SgFile & get_file(int) const ROSE_DEPRECATED_FUNCTION;

      //! Access function for putting a new SgFile object into the list stored internally
      //! This function is deprecated and "get_fileList->push_back(SgFile*)" should be used instead.
          void set_file(SgFile &) ROSE_DEPRECATED_FUNCTION;

      //! Intended for use with the -rose:keep_going commandline option.
      //! \returns A list of files that encountered an error within either
      //!          the frontend, unparser, or backend compilation.
          SgFilePtrList get_files() const;
          SgFilePtrList get_files_with_errors() const;
          SgFilePtrList get_files_without_errors() const;

      //! Access function for retriving a SgFile object from the list stored internally
          SgFile* operator[]( unsigned int i );

      //! Access function for retriving a SgFile object from the list stored internally, but using the filename with full path.
          SgFile* operator[]( std::string filename );

      //! function to generate output for all files in the project (arguments control code generation)
          void unparse ( UnparseFormatHelp *unparseFormatHelp = NULL, UnparseDelegate* unparseDelegate = NULL );

       // DQ (5/8/2010): Added support for resetting the source position information.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      //! function to compile the output from unparsing the project
          int compileOutput();
          int RunFrontend();

      //! function to preform linking!
          int link(std::string linkerName);

      //! function to preform linking!
          int link(const std::vector<std::string>& argv, std::string linkerName);

      //! global concept of verbose level which controls useful output from the compiler (values greater than zero increase output level)
          static int p_verbose;

	//! global to tell mangler to turn off short mangled name optimization. Default is false. (ie, by default short name mangling is enabled)
          static bool p_mangled_noshortname;

	//! global to output the command line that goes to the backend compiler. Default is false.
          static bool p_showBackendCommandLine;

       // DQ (4/4/2020): Adding support for unparse headers feature specific diagnostics.
      //! global concept of verbose level which controls useful output from the unparse headers feature (values greater than zero increase output level)
          static int p_unparseHeaderFilesDebug;

      //! This function generates a list of files resolved to absolute paths (symbolic links should not be resolved).
          Rose_STL_Container<std::string> getAbsolutePathFileNames() const;

      //! DQ: Modified to accept a value on the command line (no longer a boolean variable)
      //! value of 0 means quiet and higher values output more information, default value
      //! is zero (quiet).
          static int get_verbose (void);
          static void set_verbose (int);

          static bool get_mangled_noshortname (void);
          static void set_mangled_noshortname ( bool noshortname );

          static bool get_showBackendCommandLine (void);
          static void set_showBackendCommandLine ( bool show );

      //! Jim Leek 2023/03/17: Modified to check that the application root is sane
         std::string get_applicationRootDirectory() const;
         void set_applicationRootDirectory(std::string applicationRootDirectory);

       // DQ (4/4/2020): Added debugging support for feature specific unparsing of header files.
          static int get_unparseHeaderFilesDebug (void);
          static void set_unparseHeaderFilesDebug (int);

       // DQ: bool values on the SgFile nodes which can be queried on the SgProject
       // nodes (must be the same across all SgFile nodes in the project).
          bool get_skip_translation_from_edg_ast_to_rose_ast (void) const;
          bool get_skip_transformation (void) const;
          bool get_skip_unparse (void) const;
          bool get_useBackendOnly (void) const;

       // DQ (4/6/2010): Added to support parsing only option.
          bool get_exit_after_parser(void) const;

       // DQ (12/28/2010): Added to support skipping compilation in backendCompilesUsingOriginalInputFile()
          bool get_skipfinalCompileStep (void) const;

          void set_C_only(bool value);
          bool get_C_only(void) const;

          bool get_C89_only(void) const;
          bool get_C89_gnu_only(void) const;
          bool get_C90_only(void) const;
          bool get_C90_gnu_only(void) const;
          bool get_C99_only(void) const;
          bool get_C99_gnu_only(void) const;
          bool get_C11_only(void) const;
          bool get_C11_gnu_only(void) const;
          bool get_C17_only(void) const;
          bool get_C17_gnu_only(void) const;
          bool get_C23_only(void) const;
          bool get_C23_gnu_only(void) const;
          bool get_C2y_only(void) const;
          bool get_C2y_gnu_only(void) const;

          void set_Cxx_only(bool value);
          bool get_Cxx_only(void) const;

          bool get_Cxx98_only(void) const;
          bool get_Cxx98_gnu_only(void) const;
          bool get_Cxx03_only(void) const;
          bool get_Cxx03_gnu_only(void) const;
          bool get_Cxx11_only(void) const;
          bool get_Cxx11_gnu_only(void) const;
          bool get_Cxx14_only(void) const;
          bool get_Cxx14_gnu_only(void) const;
          bool get_Cxx17_only(void) const;
          bool get_Cxx17_gnu_only(void) const;
          bool get_Cxx20_only(void) const;
          bool get_Cxx20_gnu_only(void) const;
          bool get_Cxx23_only(void) const;
          bool get_Cxx23_gnu_only(void) const;
          bool get_Cxx26_only(void) const;
          bool get_Cxx26_gnu_only(void) const;

          void set_Fortran_only (bool value);
          bool get_Fortran_only (void) const;

          bool get_F77_only     (void) const;
          bool get_F90_only     (void) const;
          bool get_F95_only     (void) const;
          bool get_F2003_only   (void) const;
          bool get_F2008_only   (void) const;
          bool get_F2018_only   (void) const;
          bool get_CoArrayFortran_only (void) const;

          bool get_PHP_only(void) const;

          bool get_Python_only(void) const;

          bool get_Java_only (void) const;
          void set_Java_only (bool value);
          std::list<std::string> get_Java_classpath (void) const;
          void set_Java_classpath (std::list<std::string> param);
          std::list<std::string> get_Java_sourcepath (void) const;
          void set_Java_sourcepath (std::list<std::string> param);
          std::string get_Java_destdir (void) const;
          void set_Java_destdir (std::string param);
          std::string get_Java_source_destdir (void) const;
          void set_Java_source_destdir (std::string param);

       // DQ (8/25/2017): Added more language support.
          bool get_Csharp_only (void) const;

          bool get_Ada_only (void) const;
          void set_Ada_only (bool value);

          bool get_Jovial_only (void) const;
          void set_Jovial_only (bool value);

          bool get_Jvm_only (void) const;
          void set_Jvm_only (bool value);

          void display ( const std::string & label ) const;

          friend std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<std::string> & l );

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

          void skipfinalCompileStep(bool value);

          SgStringList & get_includePathList();
          const SgStringList & get_includePathList() const;
          void set_includePathList(const SgStringList & includePathList);

          SgStringList & get_excludePathList();
          const SgStringList & get_excludePathList() const;
          void set_excludePathList(const SgStringList & excludePathList);

          SgStringList & get_includeFileList();
          const SgStringList & get_includeFileList() const;
          void set_includeFileList(const SgStringList & includeFileList);

          SgStringList & get_excludeFileList();
          const SgStringList & get_excludeFileList() const;
          void set_excludeFileList(const SgStringList & excludeFileList);

       // negara1 (07/29/2011)
          std::string findIncludedFile(PreprocessingInfo* preprocessingInfo);

          int get_detect_dangling_pointers(void) const;

          SgFilePtrList & get_fileList() const;
          void set_fileList(SgFilePtrList & fileList);

       // DQ (8/3/2018): Added support for evaluation of options at the project level (which are normally associated with files).
          bool get_unparse_tokens (void) const;

HEADER_APPLICATION_PROJECT_END


HEADER_OPTIONS_START
  // In general we avoid the definition of member function within the class declaration!
  // This is a minor divergence upon this policy.

     friend class Sg_Options& Sg_options();
     public:
          inline std::ostream& default_output()      { return *p_default_output;}
          inline void set_default_output(std::ostream& os){ p_default_output = &os;}

          inline std::ostream& debug_output()        { return *p_debug_output;}
          inline void set_debug_output(std::ostream& os)  { p_debug_output = &os;}

          inline std::ostream& error_output()        { return *p_error_output;}
          inline void set_error_output(std::ostream& os)  { p_error_output = &os;}

          inline std::ostream& logging_output()      { return *p_logging_output;}
          inline void set_logging_output(std::ostream& os){ p_logging_output = &os;}

          inline int debug_level()         {return p_debug_level;}
          inline void set_debug_level(int l) { p_debug_level = l; }

          inline int logging_level() {return p_logging_level;}
          inline void set_logging(std::ostream& log_file, int level)
             { p_logging_level = level; p_logging_output = &log_file; }
HEADER_OPTIONS_END


HEADER_UNPARSE_INFO_START
       // This class defines it's data explicitly so that the explicitly defined
       // member access functions will be used and none will be generated!

       // Default constructor defined here because the automatically generated constructor
       // would not be generated with the error checking that I require to debug the use of
       // the SgUnparse_Info object as an inherited attribute in the unparser.
          SgUnparse_Info ();

          SgUnparse_Info ( const SgUnparse_Info & X );
          SgUnparse_Info & operator= ( const SgUnparse_Info & X );

          void post_construction_initialization() override;

       // DQ (4/16/2003): Notes on how to improve the unparser:
       // Rather than having an inherited attribute that stores some context information
       // and clearer approach would be to have an inherited attribute that stored all
       // the context information.  The SgUnparse_Info object should be abandoned for
       // the use of a persistant attribute built using an initial traversal (to set them)
       // over the entire tree.  Such a traversal would have to visit every node of
       // the AST, because the unparser has to visit every node.

       // DQ (12/6/2003) Need to use a vector<bool> type to store flags so that we can include
       // more flags that permited in a 32bit long integer.  We used long long for a while, but
       // this does not work with the 3.x gnu g++ compiler (and C++ does not allow enum values to
       // be more than long (32 bits on many machines, Intel x86).  Modifying the implementation
       // to use an STL vector<bool> type permits an unlimited number of flags (for future growth).

      /*! \brief Options available for unparsing the AST to generate source code

          These options can be set or unset and are passed from each unparse function to any
          called unparse functions.  Sometimes a new unparse info object is generated, always
          using the copy constructor, so that the options can be modified for unparsing
          different parts of the AST.

          \internal This is implemented as a bit vector since it is over 32 bits.
       */
          enum unparse_type_num
             {
            //! DQ (11/4/2003): Build a default value to support initialization
               b_enum_defaultValue            = 0, /*!< default value */
            //! to postponing the printing of name for ptr of function or array etc
               b_isPointerToSomething         = 1, /*!< postponing the printing of name for ptr of function or array etc */
               b_isReferenceToSomething       = 2, /*!< postponing the printing of name for ptr of function or array etc */
            //! if it is in Variable Declaration, output either , or ; for SgExprStmt
               b_inVarDecl                    = 3, /*!< if it is in Variable Declaration, output either , or ; for SgExprStmt */
            //! in a function header, output type+ symbol
               b_inArgList                    = 4, /*!< in a function header, output type+ symbol */
            //! no ';' for declaration statement
               b_SkipSemiColon                = 5, /*!< no ';' for declaration statement */
            //! to setup for printing of enum var in a VariableDeclaration
               b_inEnumDecl                   = 6, /*!< setup for printing of enum var in a VariableDeclaration */
            //! not really being used (yet)
               b_inTemplateList               = 7, /*!< not really being used (yet) */
            //! suppress printing of the base type
               b_SkipBaseType                 = 8, /*!< suppress printing of the base type */
            //! for skip "=" if in aggregate initializer
               b_inAggregateInitializer       = 9, /*!< skip "=" if in aggregate initializer */
            //! for print both type & sym name
               b_isWithType                   = 10, /*!< print both type and sym name */
            //! it is in conditional expr
               b_inConditional                = 11, /*!< is in conditional expr (context information) */
            //! skip printing definition part of a declaration
               b_SkipDefinition               = 12, /*!< skip output of definitions (sets b_SkipEnumDefinition, b_SkipFunctionDefinition, and b_SkipClassDefinition */
            //! need to put in either class/struct/union keyword
               b_SkipClassSpecifier           = 13, /*!< skip the class specifier (modifier) */
            //! printing something within a variable declaration
               b_inEmbeddedDecl               = 14, /*!< printing something within a variable declaration */
            //! suppress the printing of global and atomic
               b_SkipGlobal                   = 15, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
               b_SkipAtomic                   = 16, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
            //! used by set/unsetName and set/unsetPrintName to bring down the
            //! Name to lower tree structure
               b_PrintName                    = 17, /*!< used by set/unsetName and set/unsetPrintName to bring down the Name to lower tree structure */
            //! to set the need to check if need access specifier (avoids redundently specific access modifiers)
               b_CheckAccess                  = 18, /*!< set the need to check if need access specifier */
            //! to skip function qualifiers
               b_SkipFunctionQualifier        = 19, /*!< skip function qualifiers */
            //! to show that the type above current one is an array
               b_isArrayType                  = 20, /*!< show that the type above current one is an array */
            //! to indicate that this is at the right hand side of a binary op
               b_inRhsExpr                    = 21, /*!< indicate that this is at the right hand side of a binary op */
            //! to flag the skipping of () printing in a function call
            //! this is for a bug in g++ that can not handle (P::dval->B::mfcall)()
            //! skipping the toplevel only
               b_SkipParen                    = 22, /*!< skip over output of matching "(" and ")" */
            //! for the case that this maybe a function type, separate the outputing of
            //! the type info into 2 parts, the return type part and the arg type
            //! by default this is always set to 0
               b_isTypeSecondPart             = 23, /*!< unparse only second part of type */
               b_isTypeFirstPart              = 24, /*!< unparse only first part of type */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipInitializer              = 25, /*!< skip output of initializers */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipComments                 = 26, /*!< ignore all comments in unparsing */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipCPPDirectives            = 27, /*!< ignore all C preprocessor directives (except #pragma which is in the AST) */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipEnumDefinition           = 28, /*!< skip over enum definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipFunctionDefinition       = 29, /*!< skip over the function definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_SkipClassDefinition          = 30, /*!< skip over the class definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation
            //! of declarations in rewrite mechanism
               b_AddSemiColonAfterDeclaration = 31, /*!< add ';' after declaration */
            //! MS: 09/03/02 Added by MS to make unparsing of white space optional
            //! currently only used in unparseToCompleteString (by removing whitespaces)
            //! I only added it here to follow the design but suggest to use varibles of type bool,
            //! and extend the ROSETTA code to add these attributes, and generate the access functions -
            //! unfortunately the naming scheme does not comply with ROSETTA's naming scheme for access functions.
               b_SkipWhitespaces              = 32, /*!< ignore any unrequired white space */
            //! DQ (11/3/2003): made all bit flags 64 bit long so that we could add a few
            //! more entries.  Added bit flag to control generation of prefix scope
            //! statements. This permits unparsing SgForStmt, SgWhileStmt, SgSwitchStmt,
            //! etc., without their body so that we can capture the full context of the
            //! declarations associated with such statements.  In the case of SgSwitchStmt
            //! it also permits replacement of case statements which are specific to
            //! SgSwitchStmt basic blocks and no other basic blocks.  This verifies the
            //! correctness of transformation specified.
               b_SkipBasicBlock               = 33, /*!< skip over the unparsing of the basic block */

           //! Templates that are modified need to be output, but all other output of a class
           //! template only supports the output of the class template name (but in template
           //! form, e.g. "Rose_STL_Container<int>").  If the template has not been transformed then we have
           //! to control where it is output.  The default can't be to output the template
           //! everywhere and then restrict it's use since the unparser can't turn that on,
           //! so we have to restrict it everywhere and turn it on in several places.
               b_outputClassTemplateName      = 34, /*!< outputClassTemplateName */

            // DQ (5/27/2005): Added support for getting comments and directives output before any inserted
            // compiler generated statements.
           //! Control output of compiler-generated statements (typically template specialization declarations).
           //! this allows the unparing of comments and preprocessor declarations before the compiler-generated
           //! statements appearing with any non-compiler-generated statement.
               b_outputCompilerGeneratedStatements = 35, /*!< outputCompilerGeneratedStatements */

            // DQ (4/5/2006): Added support for constant folded values to be optionally output
           //! Control output of constant folded values.
               b_SkipConstantFoldedExpressions = 36, /*!< SkipConstantFoldedExpressions */

            // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
               b_forceQualifiedNames           = 37, /*!< Force qualified names. */

            // DQ (10/11/2006): This is added to support a default where all qualified names are output.
           //! Control output of qualified names (not always wanted).
               b_SkipQualifiedNames           = 38, /*!< skip qualified names (e.g. names of defining declarations). */

           //! Control access specifiers use in generated code (public, protected, private).
               b_skipCheckAccess               = 39, /*!< Skip access specifier (different from b_CheckAccess, above) */

               b_requiresGlobalNameQualification = 40,/*!< Requires global qualifier on generated name. */

            // DQ (8/10/2006):
            // b_isAsmOutputOperand            = 40, /*!< Mark as output operand */

               b_useTypeAttributes             = 41,/*!< Fortran allows type attributes to be used in declarations (for example to dimension a collection of arrays). */

               b_SkipFormatting                = 42,/*!< Fortran code generation requires that we skip some formatting (e.g. column 7 formatting, even if fixed format output). */

            // FMZ: Added for generate fortran xxx.rose_mod file
               b_outputFortranModFile      = 43, /*!< Fortran mod file generation */

            // DQ (1/16/2011): Fortran support required.
               b_supressStrippedTypeName = 44, /*!< Unparsing of Fortran types with multiple attributes requires skipping the stripped base type name if it has already been output. */

            // DQ (4/13/2013): Added support to unparse code using overloaded operator names or operator syntax (to match the input code).
               b_prefixOperator = 45, /*!< Part of support to unparse code using overloaded operator names or operator syntax (to match the input code); this marks prefix operators to be unparsed before the LHS s output. */

            // DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
               b_supressArrayBound = 46, /*!< Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax for secondary (prototype) declarations (e.g. int array[];). */

            // DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
               b_supressImplicitThisOperator = 47, /*!< Supress output of SgThisExp (required to support lambda function code generation). */

            // DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
               b_unparsedPartiallyUsingTokenStream = 48, /*!< Record that the statement was partially unparsed using the token stream. */

            // DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
               b_skipCompilerGeneratedSubExpressions = 49, /*!< Supress compiler generated subexpressions (used to output fields in the 2nd parameter of the offsetof() function family. */

            // DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
               b_parentStatementListBeingUnparsedUsingPartialTokenSequence = 50, /*!< Controls output formatting (CR's) in mixing unparsing from token stream with unparsing from the AST. */

            // DQ (2/8/2016): Adding support for C++11 specific initialization lists.
               b_cxx11_initialization_list = 51, /*!< Indicate when we are in a C++11 specific initialization list. */

            // DQ (2/3/2019): Need to know when we are unparsing the base type within a typedef so that member pointers can be output with parenthesis (see Cxx11_tests/test2019_77.C).
           //! to setup unparsing of base types in typedef declarations (for SgPointerMemberType) which requires extra parenthesis.
               b_inTypedefDecl             = 52, /*!< setup unparsing of base types in typedef declarations (for SgPointerMemberType) which requires extra parenthesis */

            // DQ (4/13/2019): Generated strings of template instantiations need to sometimes exclude the initial name qualification to avoid it being redundantly generated, see Cxx11_tests/test2019_350.C).
               b_SkipNameQualification     = 53, /*!< Skip the use of name qualification (used in generating strings of template instantiations) */

            // DQ (12/26/2019): Use an alternative defining declaration in unparsing of named type, see Cxx11_tests/test2019_518a.C and test2019_518b.C).
            // Required to support multiple file handling, and its unparsing.
               b_useAlternativeDefiningDeclaration = 54, /*!< Skip the use of name qualification (used in generating strings of template instantiations) */

            // DQ (1/6/2021): Adding support to detect use of unparseToString() functionality.  This is required to avoid premature saving of state
            // regarding the static previouslyUnparsedTokenSubsequences which is required to support multiple statements (e.g. a variable declarations
            // with containing multiple variables which translates (typically) to multiple variable declarations (each with one variable) within the AST).
               b_usedInUparseToStringFunction = 55, /*!< Mark this use as being called from the unparseToString() functions (used in debugging) */

            //! DQ (12/6/2003): Added last value to use a upper bound in loops
               UNPARSE_TYPE_LAST /*!< last value used for debugging */
             };

      /*! Access modifiers for use with SgUnparseInfo (only) */
          enum access_attr_enum
             {
               a_unset_access     = 1, /*!< default value */
               a_private_access   = 2, /*!< private access value */
               a_protected_access = 3, /*!< protected access value */
               a_public_access    = 4,  /*!< public access value */
            // DQ (8/12/2020): added a new value to support when this is not set explicitly (see Cxx_tests/test2020_28.C).
               a_default_access   = 5  /*!< public access value */
             };

     private:

       // DQ (1/3/2009): This is similar code to what is in SgModifier::checkBit, setBit, unsetBit; so it could be refactored.
          bool checkBit(unparse_type_num bit) const;
          void setBit(unparse_type_num bit);
          void unsetBit(unparse_type_num bit);

     public:

       // access function to SgUnparse_Info
          bool isUnsetAccess() const;
          void set_isUnsetAccess();
          bool isPrivateAccess() const;
          void set_isPrivateAccess();
          bool isProtectedAccess() const;
          void set_isProtectedAccess();
          bool isPublicAccess() const;
          void set_isPublicAccess();

       // DQ (8/12/2020): Adding a default value for when it is not set explicitly.
          bool isDefaultAccess() const;
          void set_isDefaultAccess();

          bool isPointerToSomething() const;
          void set_isPointerToSomething();
          void unset_isPointerToSomething();

          bool isReferenceToSomething() const;
          void set_isReferenceToSomething();
          void unset_isReferenceToSomething();

          bool inVarDecl() const;
          void set_inVarDecl();
          void unset_inVarDecl();

          bool inArgList() const;
          void set_inArgList();
          void unset_inArgList();

          bool SkipSemiColon() const;
          void set_SkipSemiColon();
          void unset_SkipSemiColon();

          bool inEnumDecl() const;
          void set_inEnumDecl();
          void unset_inEnumDecl();

          bool inTemplateList() const;
          void set_inTemplateList();
          void unset_inTemplateList();

          bool SkipBaseType() const;
          void set_SkipBaseType();
          void unset_SkipBaseType();

          bool inAggregateInitializer() const;
          void set_inAggregateInitializer();
          void unset_inAggregateInitializer();

          bool isWithType() const;
          void set_isWithType();
          void unset_isWithType();

          bool inConditional() const;
          void set_inConditional();
          void unset_inConditional();

          bool SkipDefinition() const;
          void set_SkipDefinition();
          void unset_SkipDefinition();

          bool SkipClassSpecifier() const;
          void set_SkipClassSpecifier();
          void unset_SkipClassSpecifier();

          bool inEmbeddedDecl() const;
          void set_inEmbeddedDecl();
          void unset_inEmbeddedDecl();

          bool SkipGlobal() const;
          void set_SkipGlobal();
          void unset_SkipGlobal();

          bool SkipAtomic() const;
          void set_SkipAtomic();
          void unset_SkipAtomic();

          bool PrintName() const;
          void set_PrintName();
          void unset_PrintName();

          bool CheckAccess() const;
          void set_CheckAccess();
          void unset_CheckAccess();

          bool SkipFunctionQualifier() const;
          void set_SkipFunctionQualifier();
          void unset_SkipFunctionQualifier();

          bool isArrayType() const;
          void set_isArrayType();
          void unset_isArrayType();

          bool inRhsExpr() const;
          void set_inRhsExpr();
          void unset_inRhsExpr();

          bool SkipParen() const;
          void set_SkipParen();
          void unset_SkipParen();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Tests the setting of the flag to permit output of 2nd part of type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          bool isTypeSecondPart() const;

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Sets flag to permit output of 2nd part of type.

          This sets the flag for output of the 2nd part of a type and unsets the flag for the 1st part of the type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          void set_isTypeSecondPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Unsets the flag to permit output of 2nd part of type.

          This only unsets the flag for the output of the 2nd part of a type (no change to the flag for the 1st part of the type).

          \internal This and the isTypeFirstPart flag can both be false or only one can be true.
       */
          void unset_isTypeSecondPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Tests the setting of the flag to permit output of 1st part of type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          bool isTypeFirstPart() const;

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Sets flag to permit output of 1st part of type.

          This sets the flag for output of the 1st part of a type and unsets the flag for the 2nd part of the type.

          \internal This and the isTypeSecondPart flag are mutually exclusive.
       */
          void set_isTypeFirstPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Unsets the flag to permit output of 1st part of type.

          This only unsets the flag for the output of the 1st part of a type (not change to the flag for the 2nd part of the type).

          \internal This and the isTypeSecondPart flag can both be false or only one can be true.
       */
          void unset_isTypeFirstPart();

          bool SkipInitializer() const;
          void set_SkipInitializer();
          void unset_SkipInitializer();

          bool SkipComments() const;
          void set_SkipComments();
          void unset_SkipComments();

       // MS: 09/03/03
          bool SkipWhitespaces() const;
          void set_SkipWhitespaces();
          void unset_SkipWhitespaces();

          bool SkipCPPDirectives() const;
          void set_SkipCPPDirectives();
          void unset_SkipCPPDirectives();

          bool SkipEnumDefinition() const;
          void set_SkipEnumDefinition();
          void unset_SkipEnumDefinition();

          bool SkipFunctionDefinition() const;
          void set_SkipFunctionDefinition();
          void unset_SkipFunctionDefinition();

          bool SkipClassDefinition() const;
          void set_SkipClassDefinition();
          void unset_SkipClassDefinition();

          bool AddSemiColonAfterDeclaration() const;
          void set_AddSemiColonAfterDeclaration();
          void unset_AddSemiColonAfterDeclaration();

       // DQ (11/04/03): Added to support unparsing control flow (SgForStmt, SgSwitch,
       //                etc.) to make prefix more precise. Can't add case to anything
       //                but switch, and capture declarations in for loops, for example.
          bool SkipBasicBlock() const;
          void set_SkipBasicBlock();
          void unset_SkipBasicBlock();

       // DQ (3/18/2004): Added to support unparsing of class templates in variables but
       // not in in instatiated template declarations (unless the template is transformed
       // in which case another test is used).
          bool outputClassTemplateName() const;
          void set_outputClassTemplateName();
          void unset_outputClassTemplateName();

       // DQ (5/27/2005): support (see documentation above)
          bool outputCompilerGeneratedStatements() const;
          void set_outputCompilerGeneratedStatements();
          void unset_outputCompilerGeneratedStatements();

       // DQ (4/5/2006): Added support for constant folded values to be optionally output
      //! Control output of constant folded values, the default is to ignore constant
      //! folded values and unparse the original code (as if no constant folding were done).
      //! (default is unset)
          bool SkipConstantFoldedExpressions() const;
          void set_SkipConstantFoldedExpressions();
          void unset_SkipConstantFoldedExpressions();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool forceQualifiedNames() const;
          void set_forceQualifiedNames();
          void unset_forceQualifiedNames();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool skipCheckAccess() const;
          void set_skipCheckAccess();
          void unset_skipCheckAccess();

       // DQ (10/11/2006): Added to support new implementation of name qualification
          bool SkipQualifiedNames() const;
          void set_SkipQualifiedNames();
          void unset_SkipQualifiedNames();

          bool requiresGlobalNameQualification() const;
          void set_requiresGlobalNameQualification();
          void unset_requiresGlobalNameQualification();

       // DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
          bool useTypeAttributes() const;
          void set_useTypeAttributes();
          void unset_useTypeAttributes();

          bool SkipFormatting() const;
          void set_SkipFormatting();
          void unset_SkipFormatting();

          bool supressStrippedTypeName() const;
          void set_supressStrippedTypeName();
          void unset_supressStrippedTypeName();

          std::string get_operator_name();
          void set_operator_name(const std::string& on);

          SgName& get_name();
          void set_name(const SgName& name);
          void unset_name();

          SgDeclarationStatement* get_decl_stmt();
          void set_decl_stmt(SgDeclarationStatement* stmt );
          void unset_decl_stmt();

          int get_nested_expression();
          void set_nested_expression();
          void unset_nested_expression();

       // DQ (4/13/2013): Added support to mark output of overloaded operators an prefix operators.
          bool isPrefixOperator() const;
          void set_prefixOperator();
          void unset_prefixOperator();

       // DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
          bool supressArrayBound() const;
          void set_supressArrayBound();
          void unset_supressArrayBound();

       // DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
          bool supressImplicitThisOperator() const;
          void set_supressImplicitThisOperator();
          void unset_supressImplicitThisOperator();

       // DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
          bool unparsedPartiallyUsingTokenStream() const;
          void set_unparsedPartiallyUsingTokenStream();
          void unset_unparsedPartiallyUsingTokenStream();

       // DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
          bool skipCompilerGeneratedSubExpressions() const;
          void set_skipCompilerGeneratedSubExpressions();
          void unset_skipCompilerGeneratedSubExpressions();

       // DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
          bool parentStatementListBeingUnparsedUsingPartialTokenSequence() const;
          void set_parentStatementListBeingUnparsedUsingPartialTokenSequence();
          void unset_parentStatementListBeingUnparsedUsingPartialTokenSequence();

       // DQ (2/8/2016): Adding support for C++11 specific initialization lists.
          bool get_cxx11_initialization_list() const;
          void set_cxx11_initialization_list();
          void unset_cxx11_initialization_list();

       // DQ (2/3/2019): unparsing for base type in typedefs when base type is a member pointer.
          bool inTypedefDecl() const;
          void set_inTypedefDecl();
          void unset_inTypedefDecl();

       // DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
          bool SkipNameQualification() const;
          void set_SkipNameQualification();
          void unset_SkipNameQualification();

       // DQ (12/26/2019): unparsing for defining declarations in named types defined in multiple translation units (multi-file support).
          bool useAlternativeDefiningDeclaration() const;
          void set_useAlternativeDefiningDeclaration();
          void unset_useAlternativeDefiningDeclaration();

       // DQ (1/6/2021): Adding support to detect use of unparseToString() functionality.  This is required to avoid premature saving of state
       // regarding the static previouslyUnparsedTokenSubsequences which is required to support multiple statements (e.g. a variable declarations
       // with containing multiple variables which translates (typically) to multiple variable declarations (each with one variable) within the AST).
          bool usedInUparseToStringFunction() const;
          void set_usedInUparseToStringFunction();
          void unset_usedInUparseToStringFunction();

       // DQ (11/21/2021): Adding support for types to be unparsed with the context of the correct declaration to support multi-file handling.
          void unset_declaration_of_context();

          void unset_current_context();

          SgName get_array_index_list();

          void set_array_index_list(SgExpression *e, SgUnparse_Info finfo );
          void unset_array_index_list();

       // Support for processing of recursive references to structure tags within the data
       // structures that they define.
          void addStructureTag ( SgNamedType* structureTag );

      //! Access function for internal STL list of structure tags
          SgTypePtrList & getStructureTagList ();

       // DQ (1/9/2007): Modified to make const
          void display ( const std::string & label = "") const;
          std::string displayString ( const std::string & label ) const;

      /*! \brief Added to debug use of the default constructor

          Added to debug use of the default constructor (to restrict it from being used so that
          we could detect where it is being used in place of the copy constructor which should
          be used to implement the SgUnparse_Info object correctly as an inherited attribute
          within the ROSE unparser.
       */
       // static bool forceDefaultConstructorToTriggerError;

       // DQ (9/6/2004): Support for list of scopes required to qualify names (e.g. types, data members, member functions, etc.)
       // SgSymbolPtrList & get_listOfScopeSymbols();
       // void set_listOfScopeSymbols ( const SgSymbolPtrList & l );

       // DQ (1/31/2006): moved static bool forceDefaultConstructorToTriggerError to be built by ROSETTA
          static bool get_forceDefaultConstructorToTriggerError();
          static void set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError);

       // FMZ (5/8/2008) Added to support to generate fortran XX.rose_mod file for a module
       // the code will based on fortran unparser code
          bool outputFortranModFile() const;
          void set_outputFortranModFile();
          void unset_outputFortranModFile();

       // driscoll6 (6/6/2011) Mutators for p_nestingLevel
          void inc_nestingLevel();
          void dec_nestingLevel();

       // DQ (8/16/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).
       // We need to build the access functions directly because of the static data member.
          static bool get_extern_C_with_braces();
          static void set_extern_C_with_braces( bool extern_C_with_braces );

       // DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
          static SgStatement* get_previouslyUnparsedStatement();
          static void set_previouslyUnparsedStatement( SgStatement* previouslyUnparsedStatement );

       // DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
          static bool get_previousStatementUnparsedFromTokenStream();
          static void set_previousStatementUnparsedFromTokenStream( bool previousStatementUnparsedFromTokenStream );

HEADER_UNPARSE_INFO_END


HEADER_UNPARSE_POSTDECLARATION_START
//! extern declarations used by the unparser (a default object for many to reference)
// extern SgUnparse_Info SgNO_UNPARSE_INFO;

// support function declarations for unparsing
//extern void printSgVariant ( std::ostream& os, int x );
extern std::string getSgVariant ( int x);

HEADER_UNPARSE_POSTDECLARATION_END


HEADER_TEMPLATE_PARAMETER_START
     public:

       // DQ (8/10/2013): We need to unify how to reference the enum values between template parameters and template arguments.
       // enum SgTemplateArgument::template_argument_enum;
       // typedef SgTemplateArgument::template_argument_enum template_parameter_enum;

      /*! Different uses of a template parameter */
          enum template_parameter_enum
             {
               parameter_undefined = 0, /*!< undefined (error) */
               type_parameter      = 1, /*!< type parameter */
               nontype_parameter   = 2, /*!< nontype parameter */
               template_parameter  = 3  /*!< template parameter */
             };

          void post_construction_initialization() override;

       // Different constructors for use in building the different types of parameters possible
          SgTemplateParameter ( SgType* parameter               , SgType* defaultParameter );
          SgTemplateParameter ( SgExpression* parameter         , SgExpression* defaultParameter );
          SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter );

       // DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
          static bool is_matching_type    (const SgTemplateParameter & X, const SgTemplateParameter & Y);
          static bool is_matching_nontype (const SgTemplateParameter & X, const SgTemplateParameter & Y);
          static bool is_matching_template(const SgTemplateParameter & X, const SgTemplateParameter & Y);

       // DQ (5/19/2014): This is added to symetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
          static bool is_matching_template_pack_expansion (const SgTemplateParameter & X, const SgTemplateParameter & Y);

          static bool is_matching_kind    (const SgTemplateParameter & X, const SgTemplateParameter & Y);

          SgName get_mangled_name (void) const;

HEADER_TEMPLATE_PARAMETER_END

HEADER_TEMPLATE_ARGUMENT_START
     public:

      /*! Different uses of a template argument */
          enum template_argument_enum
             {
               argument_undefined               = 0, /*!< undefined (error) */
               type_argument                    = 1, /*!< type parameter */
               nontype_argument                 = 2, /*!< nontype parameter */
               template_template_argument       = 3, /*!< template template parameter */
               start_of_pack_expansion_argument = 4  /*!< start of pack expansion parameter */
             };

          void post_construction_initialization() override;

       // Different constructors for use in building the different types of parameters possible
          SgTemplateArgument ( SgType*                      parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgExpression*                parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgTemplateDeclaration*       parameter, bool explicitlySpecified );

       // DQ (7/3/2013): Added new type of template argument type to support varadic template arguments.
          SgTemplateArgument ( bool explicitlySpecified );

       // RV (2/2/2006): Added mangling for template arguments.
      //! Returns the template argument in mangled form.
          SgName get_mangled_name (void) const;

      //! Some template arguments have an associated scope (e.g. named types, and template template arguments)
          SgScopeStatement* get_scope () const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (11/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the template argument type.
          SgName get_qualified_name_prefix() const;

       // DQ (7/24/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix_for_type() const;

       // DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
          static bool is_matching_type    (const SgTemplateArgument & X, const SgTemplateArgument & Y);
          static bool is_matching_nontype (const SgTemplateArgument & X, const SgTemplateArgument & Y);
          static bool is_matching_template(const SgTemplateArgument & X, const SgTemplateArgument & Y);

       // DQ (5/19/2014): This is added to symetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
          static bool is_matching_template_pack_expansion (const SgTemplateArgument & X, const SgTemplateArgument & Y);

          static bool is_matching_kind    (const SgTemplateArgument & X, const SgTemplateArgument & Y);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);

       // DQ (5/22/2016): Adding display function for debugging.
          void display( const std::string & label) const;

       // DQ (3/10/2018): Adding debugging support.
          std::string unparseToStringSupport();

       // DQ (2/10/2019): Adding debugging support.
          std::string template_argument_kind () const;

       // DQ (2/10/2019): Refactored support for template unparsing.
          bool isTemplateArgumentFromAnonymousClass() const;

       // DQ (2/11/2019): Refactored support for logic to control when template arguments are unparsed.
       // Temporarily this code is located in the unparseCxx_expressions.C file.
          void outputTemplateArgument(bool & skip_unparsing, bool & stop_unparsing);

HEADER_TEMPLATE_ARGUMENT_END


HEADER_TEMPLATE_PARAMETER_LIST_START
HEADER_TEMPLATE_PARAMETER_LIST_END

HEADER_TEMPLATE_ARGUMENT_LIST_START

       // DQ (2/10/2019): I think this IR node is no longer used.
       // DQ (3/10/2018): Adding debugging support.
       // std::string unparseToStringSupport();

HEADER_TEMPLATE_ARGUMENT_LIST_END

HEADER_OPENCL_ACCESS_MODE_MODIFIER_START

       // TV (05/03/2010): OpenCL Access Mode Support

          enum access_mode_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_read_only     = 2,  /*!< read only access mode modifier */
               e_write_only    = 3,  /*!< write only access mode modifier */
               e_read_write    = 4,  /*!< read-write access mode modifier */

               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() override;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isReadOnly() const;
          void setReadOnly();

          bool isWriteOnly() const;
          void setWriteOnly();

          bool isReadWrite() const;
          void setReadWrite();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m );

HEADER_OPENCL_ACCESS_MODE_MODIFIER_END



// *************************************************
// *************************************************
//                  Source Code
// *************************************************
// *************************************************


SOURCE_START
  // No functions defined for the GrammarSource
SOURCE_END


SOURCE_SYMBOL_TABLE_START

// This function was moved to be defined outside of eqstr so that we could
// reference the data member rose_hash_multimap::case_insensitive_semantics.
bool
eqstr::operator()(const SgName & s1, const SgName & s2) const
   {
     ROSE_ASSERT(hash_multimap != NULL);

     if (hash_multimap->get_case_insensitive_semantics() == true)
        {
          return SgName::caseInsensitiveEquality(s1,s2);
        }
       else
        {
       // This is the SgName::operator==(const SgName & s1, const SgName & s2) member function
          return s1 == s2;
        }
   }


// DQ (11/5/2020): Moved this out of the generated header file and into the generated source
// file so that it could be more easily changed without recompiling all of ROSE.
void
rose_hash_multimap::delete_elements()
   {
  // DQ (11/5/2020): Call the clear function so that we can remove all elements.
     clear();
   }


size_t
hash_Name::operator()(const SgName & name) const
   {
  // CH (4/8/2010): Use boost::unordered instead
  // return hasher(name.str());

     ROSE_ASSERT(hash_multimap != NULL);

     if (hash_multimap->get_case_insensitive_semantics() == true)
        {
       // We need to compute the hash on the normalized form of the name (pick lower case).
          std::string s = name;

       // Convert string to lower case.
          std::transform(s.begin(), s.end(),s.begin(),::tolower);

       // Return hashed value on the normalized (lower case) string.
          return hasher(s.c_str());
        }
       else
        {
          return hasher(name.str());
        }
   }

// DQ (2/19/2007): Added mechanism to turn off expensive error checking!
#define SYMBOL_TABLE_ERROR_CHECKING 0

// DQ (11/27/2010): Added support for case sensitive and case insensitive symbol table (internal name matching).
SgSymbolTable::SgSymbolTable()
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!
     int symbolTableSize = 17;

  // CH (4/8/2010): Use boost::unordered instead
     p_table = new BaseHashType(symbolTableSize);
     ROSE_ASSERT (p_table != NULL);
   }

// DQ (2/19/2007): I have put it back into use as a way of
// customizing the size of the underlying hash tables to be
// larger for certain scopes (e.g global scope usually has a
// lot more symbols.

SgSymbolTable::SgSymbolTable(int symbolTableSize)
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!
     p_table = new BaseHashType(symbolTableSize);
     ROSE_ASSERT (p_table != NULL);
   }

bool
SgSymbolTable::isCaseInsensitive() const
   {
  // Case sensitive symbol tables are used for C/C++ and case insensitive scopes are for Fortran.
  // Note that a case insensitive symbol table can only be built that way from the constructor
  // and not be toggled back and forth at will.

     ROSE_ASSERT(p_table != NULL);
     return p_table->get_case_insensitive_semantics();
   }

void
SgSymbolTable::setCaseInsensitive(bool b)
   {
  // Case sensitive symbol tables are used for C/C++ and case insensitive scopes are for Fortran.
  // Note that a case insensitive symbol table can only be built that way from the constructor
  // and not be toggled back and forth at will.

     ROSE_ASSERT(p_table != NULL);

  // Make it NOT an error to redundantly set the case sensitivity/insensitivity.
     bool changingCaseSensitivity = b != p_table->get_case_insensitive_semantics();
     if (changingCaseSensitivity == true)
        {
          if (p_table->empty() == false)
             {
               mprintf ("Error: Can't change case sensitivity of non-empty symbol table.\n");
               mprintf ("   Solution: set the case sensitivity/insensitivity earlier in processing (immediately after the call to build the scope) \n");
             }
          ROSE_ASSERT(p_table->empty() == true);

          p_table->set_case_insensitive_semantics(b);
        }
   }

std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it )
   {
  // DQ (1/19/2006): Error reported by Michelle Strout when compiled with g++ 4.0.2 on 64 bit machines
  // os << " pair (" << (*rhm_it).first.str() << "," << (int)((*rhm_it).second) << ")";
  // os << " pair (" << (*rhm_it).first.str() << "," << ((*rhm_it).second) << ")";
  // JJW (7/10/2008): The iterator may not be valid, so don't try to print what it points to
     os << "<iterator>";
     return os;
   }

SgName
SgSymbolTable::get_name( const SgNode* node) const
   {
  // DQ (2/20/2007): This function is used to get the name for the different types of declarations used to build symbols.

     SgName name;

     switch (node->variantT())
        {
       // We could implement a function on the selective nodes that generated the symbol
       // name (the name used for the input of associated symbols in the symbol table).
          case V_SgLabelStatement:
             {
               const SgLabelStatement* labelStatement = isSgLabelStatement(node);
               if (labelStatement->get_label() != NULL)
                  {
                    name = labelStatement->get_label();
                  }
                 else
                  {
                 // name = Rose::StringUtility::numberToString(labelStatement->get_numeric_label()->get_name());
                    ROSE_ASSERT(labelStatement->get_numeric_label() != NULL);
                    name = labelStatement->get_numeric_label()->get_name();
                  }
               break;
             }

          case V_SgJavaLabelStatement: // charles4: 09/13/2011 added for Java support
             {
               const SgJavaLabelStatement* labelStatement = isSgJavaLabelStatement(node);
               ROSE_ASSERT (labelStatement->get_label() != NULL);
               name = labelStatement->get_label();
               break;
             }

          case V_SgClassDeclaration:
          case V_SgDerivedTypeStatement:
          case V_SgModuleStatement:
          case V_SgJavaPackageDeclaration:
          case V_SgJovialTableStatement:
             {
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);
               name = classDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               const SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(node);
            // Note that get_name() returns a name with arguments such as "class_template<int>" while get_templateName() returns the template name withouth arguments.
               name = templateInstantiationDeclaration->get_name();
               break;
             }

          case V_SgEnumDeclaration:
             {
               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(node);
               name = enumDeclaration->get_name();
               break;
             }

          case V_SgFunctionDeclaration:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgMemberFunctionDeclaration:
          case V_SgAdaEntryDecl:
             {
               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);
               name = functionDeclaration->get_name();
               break;
             }

       // DQ (2/14/2007): Note that for template-based declarations there is a process where within the post-processing of
       // the AST the names are updated from the EDG form (e.g. "template_name___Lnnn"), to the template specialization
       // form (e.g. "template_name<int>"). Since the symbol references only one of the declarations, if there are defining
       // declarations and non-defining declarations, the name can be changed in the declaration but not in the associated symbol.
       // Details of this situation require more clarification.
          case V_SgTemplateInstantiationFunctionDecl:
             {
               const SgTemplateInstantiationFunctionDecl* functionDeclaration = isSgTemplateInstantiationFunctionDecl(node);

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               const SgTemplateInstantiationMemberFunctionDecl* functionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(node);

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgNamespaceDeclarationStatement:
             {
               const SgNamespaceDeclarationStatement* namespaceDeclarationStatement = isSgNamespaceDeclarationStatement(node);
               name = namespaceDeclarationStatement->get_name();
               break;
             }

       // DQ (8/30/2009): Added namespace alias support.
          case V_SgNamespaceAliasDeclarationStatement:
             {
               const SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = isSgNamespaceAliasDeclarationStatement(node);
               name = namespaceAliasDeclarationStatement->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
       // DQ (11/23/2011): Added more support for template declaration IR nodes.
          case V_SgTemplateFunctionDeclaration:
             {
               const SgTemplateFunctionDeclaration* templateDeclaration = isSgTemplateFunctionDeclaration(node);
               name = templateDeclaration->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
          case V_SgTemplateMemberFunctionDeclaration:
             {
               const SgTemplateMemberFunctionDeclaration* templateDeclaration = isSgTemplateMemberFunctionDeclaration(node);
               name = templateDeclaration->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
       // DQ (6/11/2011): Added support for new template declaration IR nodes.
          case V_SgTemplateClassDeclaration:
             {
               const SgTemplateClassDeclaration* templateDeclaration = isSgTemplateClassDeclaration(node);
               name = templateDeclaration->get_name();
               break;
             }
       // DQ (12/26/2011): This is no longer a base class for SgTemplateClassDeclaration and other templae declaration IR nodes.
       // It is used only for the EDG 3.3 compatable support for template declarations.
          case V_SgTemplateDeclaration:
             {
               const SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(node);
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
               const SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);
               name = typedefDeclaration->get_name();
               break;
             }

       // DQ (11/5/2014): Adding support for templated typedef.
          case V_SgTemplateInstantiationTypedefDeclaration:
             {
               const SgTemplateInstantiationTypedefDeclaration* templateInstantiationDeclaration = isSgTemplateInstantiationTypedefDeclaration(node);
               name = templateInstantiationDeclaration->get_name();
               break;
             }

       // DQ (11/4/2014): Adding support for templated typedef.
          case V_SgTemplateTypedefDeclaration:
             {
               const SgTemplateTypedefDeclaration* templateDeclaration = isSgTemplateTypedefDeclaration(node);
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgFunctionType:
             {
               const SgFunctionType* functionType = isSgFunctionType(node);

            // DQ (3/19/2016): Klocworks reports this as an issue, since functionType could be NULL.
            // So I am adding an assertion to see if this is a reasonalbe solution.  I am not clear
            // why all of the other cases in this function are not flagged as issues by Klocworks.
               ROSE_ASSERT(functionType != NULL);

               name = functionType->get_mangled();
               break;
             }

          case V_SgInitializedName:
             {
               const SgInitializedName* initializedName = isSgInitializedName(node);
               name = initializedName->get_name();
               break;
             }

          case V_SgAdaPackageSpecDecl:
             {
               const SgAdaPackageSpecDecl* dcl = isSgAdaPackageSpecDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaPackageBodyDecl:
             {
               const SgAdaPackageBodyDecl* dcl = isSgAdaPackageBodyDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaGenericDecl:
             {
               const SgAdaGenericDecl* dcl = isSgAdaGenericDecl(node);

               name = dcl->get_name();
               break;
#if OBSOLETE_CODE
               // PP(10/14/22): SgAdaGenericDecl received name field to support name mangling
               //               during construction.
               ROSE_ASSERT(dcl->get_declaration() != NULL);

               if (isSgAdaPackageSpecDecl(dcl->get_declaration())) {
                 SgAdaPackageSpecDecl* inner_dcl = isSgAdaPackageSpecDecl(dcl->get_declaration());
                 name = inner_dcl->get_name();
                 break;
               }
               if (isSgFunctionDeclaration(dcl->get_declaration())) {
                 SgFunctionDeclaration* inner_dcl = isSgFunctionDeclaration(dcl->get_declaration());
                 name = inner_dcl->get_name();
                 break;
               }
               mprintf ("Malformed input: SgAdaGenericDecl expected PackageSpecDecl or FunctionDeclaration\n");
               ROSE_ASSERT(false);
               break;
#endif /* OBSOLETE_CODE */
             }

          case V_SgAdaGenericInstanceDecl:
             {
               const SgAdaGenericInstanceDecl* dcl = isSgAdaGenericInstanceDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaFormalTypeDecl:
             {
               const SgAdaFormalTypeDecl* dcl = isSgAdaFormalTypeDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaFormalPackageDecl:
             {
               const SgAdaFormalPackageDecl* dcl = isSgAdaFormalPackageDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaTaskSpecDecl:
             {
               const SgAdaTaskSpecDecl* dcl = isSgAdaTaskSpecDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaTaskTypeDecl:
             {
               const SgAdaTaskTypeDecl* dcl = isSgAdaTaskTypeDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaTaskBodyDecl:
             {
               const SgAdaTaskBodyDecl* dcl = isSgAdaTaskBodyDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaProtectedSpecDecl:
             {
               const SgAdaProtectedSpecDecl* dcl = isSgAdaProtectedSpecDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaProtectedTypeDecl:
             {
               const SgAdaProtectedTypeDecl* dcl = isSgAdaProtectedTypeDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaProtectedBodyDecl:
             {
               const SgAdaProtectedBodyDecl* dcl = isSgAdaProtectedBodyDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaRenamingDecl:
             {
               const SgAdaRenamingDecl* dcl = isSgAdaRenamingDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgAdaFunctionRenamingDecl:
             {
               const SgAdaFunctionRenamingDecl* dcl = isSgAdaFunctionRenamingDecl(node);
               name = dcl->get_name();
               break;
             }

          case V_SgNonrealDecl:
             {
               const SgNonrealDecl* nrdecl = isSgNonrealDecl(node);
               name = nrdecl->get_name();
               break;
             }

          default:
             {
               mprintf ("SgSymbolTable::get_name(SgNode*) undefined for %s \n",node->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return name;
   }


/* ************************************************************************
                               INSERT FUNCTIONS
   ************************************************************************/

void
SgSymbolTable::insert ( const SgName & nm , SgSymbol *sp )
   {
  // For simplicity, there is only a single insert member function to put a symbol into the symbol table.
     ASSERT_not_null(this);

  // DQ (2/19/2007): Added additional assertion!
     ROSE_ASSERT (p_table != NULL);

  // DQ (2/14/2007): Added assertion!
     ROSE_ASSERT (sp != NULL);

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
#if SYMBOL_TABLE_ERROR_CHECKING
  // SgFunctionTypeSymbol does not have a valid get_symbol_basis(), so skip this case!
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
          if (sp->get_symbol_basis() == NULL)
             {
               mprintf ("Error (sp->get_symbol_basis() == NULL): name = %s sp = %p = %s \n",nm.str(),sp,sp->class_name().c_str());
             }
          ROSE_ASSERT(sp->get_symbol_basis() != NULL);
        }

  // DQ (3/10/2007): This is a simpler assertion equivalent to the one above but without generating any error output
     ROSE_ASSERT(isSgFunctionTypeSymbol(sp) != NULL || sp->get_symbol_basis() != NULL);
#endif

  // DQ (3/10/2007): Test for if the symbol exists
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
          SgType* t = sp->get_type();
          ROSE_ASSERT(t != NULL);
          mprintf ("ERROR: p_symbolSet.find(sp) != p_symbolSet.end(): base type = %p = %s \n",t,t->class_name().c_str());
        }
     ROSE_ASSERT(p_symbolSet.find(sp) == p_symbolSet.end());

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // DQ (12/3/2011): Turning on symbol table checking.
#if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/19/2007): These is no need to do both of these since exists(sp) is more complete test!
  // DQ (2/25/2007): except that it is helpful to know which one fails.
     ROSE_ASSERT(exists(nm,sp) == false);
     ROSE_ASSERT(exists(sp)    == false);

  // DQ (2/14/2007): error checking (make sure that no two symbols are represented by the same basis declaration).
  // But skip such tests on the SgFunctionTypeSymbol (only used for the function type table)
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
       // set<SgNode*> existingSymbolBasisDeclarations;
          map<SgNode*, rose_hash_multimap::iterator > existingSymbolBasisDeclarations;

          SgNode* sp_associatedDeclaration = sp->get_symbol_basis();
          ROSE_ASSERT(sp_associatedDeclaration != NULL);

          rose_hash_multimap::iterator i = get_table()->begin();
          while (i != get_table()->end())
             {
            // test if symbol is in set
               SgNode* associatedDeclaration = i->second->get_symbol_basis();
               ROSE_ASSERT(associatedDeclaration != NULL);

            // Check if this declaration has previously been used with another symbol!
               if (existingSymbolBasisDeclarations.find( sp_associatedDeclaration ) == existingSymbolBasisDeclarations.end())
                  {
                 // Add this declaration to the list associated with symbols in the table
                 // existingSymbolBasisDeclarations.insert( associatedDeclaration );
                    existingSymbolBasisDeclarations[associatedDeclaration] = i;
                  }
                 else
                  {
                    mprintf ("Error in symbol table located in parent = %p = %s \n",get_parent(),get_parent()->class_name().c_str());
                    ROSE_ASSERT(get_parent() != NULL);
                    get_parent()->get_file_info()->display("Error in symbol table");

                    string associatedDeclarationName = SageInterface::get_name(sp_associatedDeclaration);

                 // DQ (2/15/2007): Output the name of the symbol being inserted, the declaration associated with it,
                 // and the name of the symbol previously inserted with the same associated declaration.
                    mprintf ("Symbol sp = %p = %s already associated with declaration = %p = %s (name = %s) in symbol table i = %p = %s \n",
                         sp,sp->class_name().c_str(),sp_associatedDeclaration,sp_associatedDeclaration->class_name().c_str(),
                         associatedDeclarationName.c_str(),existingSymbolBasisDeclarations[sp_associatedDeclaration]->second,existingSymbolBasisDeclarations[sp_associatedDeclaration]->second->class_name().c_str());
                    associatedDeclaration->get_file_info()->display("Dual use of associatedDeclaration in source: debug");

                    mprintf ("existingSymbolBasisDeclarations[sp_associatedDeclaration]->first = %s second = %p \n",
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->first.str(),
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->second);
                    ROSE_ASSERT(false);
                  }

               i++;
             }
        }
#endif

  // Now, finally insert it into the symbol table
  // std::pair<const SgName,SgSymbol*>  npair(nm,sp);
  // p_table->insert(npair);
     p_table->insert(std::pair<const SgName,SgSymbol*>(nm,sp));

  // DQ (5/11/2006): set the parent to avoid NULL pointers
     sp->set_parent(this);

  // DQ (3/10/2007): Insert this symbol into p_symbolSet which we use for fast tests of existance in the
  // symbol table when we don't use the name.  This helps detect where symbols have been entered using one
  // name and either reentered using an second name or the name changed and the symbol had not been properly
  // unloaded and reloaded into the symbol table.  Since the names are not stored in the symbol, but computed
  // from associated declaration this is an easy error to make and we detect this by backing up the test for
  // if a symbol exists using a name with a test for if the symbol exists using ANY possible name (a search
  // for the symbol independent of the name).  To avoid this being a linear search of the symbol table (too
  // slow) we implement a set of symbols to permit fast tests for existence.
     p_symbolSet.insert(sp);

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // DQ (12/3/2011): Turning on symbol table checking.
#if SYMBOL_TABLE_ERROR_CHECKING
  // Error checking
     ROSE_ASSERT(exists(nm)    == true);
     ROSE_ASSERT(exists(nm,sp) == true);
     ROSE_ASSERT(exists(sp)    == true);
#endif

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
#if SYMBOL_TABLE_ERROR_CHECKING
   // Liao 11/12/2012: Fortran numeric label symbol is different: a label "05" is stored as a numeric value of 5 so naive comparison will fail.
   // we have to handle this case specially.
   SgLabelSymbol * ls = isSgLabelSymbol(sp);
   bool special_handled = false;
   if (ls != NULL)
   {
     SgStatement* fortran_stmt = ls->get_fortran_statement();
     if (fortran_stmt != NULL)
     {
       int label_value = atoi (nm.getString().c_str());
       ROSE_ASSERT (label_value == ls->get_numeric_label_value());
       special_handled = true;
     }
   }

  // DQ (12/3/2011): Turning on symbol table checking.
  // DQ (2/14/2007): Added error checking!
     if (!special_handled && (nm != sp->get_name()))
        {
          mprintf ("Warning: symbol name does not match name used to input associated symbol into symbol table! sp = %p = %s nm = \"%s\" sp->get_name() = \"%s\" \n",sp,sp->class_name().c_str(),nm.str(),sp->get_name().str());

          ROSE_ASSERT(sp->get_symbol_basis() != NULL);
          ROSE_ASSERT(sp->get_symbol_basis()->get_file_info() != NULL);

          sp->get_symbol_basis()->get_file_info()->display("Error in source: debug");
          ROSE_ASSERT(false);
        }
#endif
   }


/* ************************************************************************
                               REMOVE FUNCTIONS
   ************************************************************************/

// DQ (2/6/2007): This is too dangerous for use in ROSE (deletes all
// possible SgSymbols that match the input name independent of type).
// It is however currently used in the global function type symbol table
// so we have named this function to make its purpose more clear.
// This function is not likely called except where complex function type
// symbol table editing is required.  Since SgFunctionTypeSymbols are
// shared removing such symbols is a rather dangerous actvity!
void
SgSymbolTable::remove_function_type( const SgName & name )
   {
  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     ROSE_ASSERT (p_table != NULL);

  // CH (4/8/2010): Use boost::unordered instead
     list<rose_hash_multimap::iterator> deleteList;
     rose_hash_multimap::iterator it = get_table()->find(name);

  // DQ (11/27/2010): Adding support for case insensitive name lookup (using the rose_hash_multimap's key equality function).
     while (it != get_table()->end() && get_table()->key_eq()((*it).first,name))
        {
          ROSE_ASSERT(it->second->variantT() == V_SgFunctionTypeSymbol);

          deleteList.push_back(it);
          it++;
        }

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
  // CH (4/8/2010): Use boost::unordered instead
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();

     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase((*i)->second);"
       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase((*i)->second);

       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
          get_table()->erase(*i);

          i++;
        }

   }

#define DEBUG_FIND_INITIALIZED_NAME_SYMBOL 0

SgSymbol*
SgSymbolTable::find( const SgInitializedName* initializedName) {
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
  printf ("In SgSymbolTable::find( const SgInitializedName* ):\n");
  printf ("  this = %p\n", this);
  printf ("  initializedName = %p : %s \n", initializedName, SageInterface::get_name(initializedName).c_str());
#endif
  ROSE_ASSERT(p_table != NULL);
  ROSE_ASSERT(initializedName != NULL);

  SgName name = initializedName->get_name();
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
  printf ("  name = %s \n",name.str());
#endif
  if (isSgTemplateVariableInstantiation(initializedName->get_parent())) {
    SgTemplateVariableInstantiation * tplinst = (SgTemplateVariableInstantiation *)initializedName->get_parent();
    name = SageBuilder::appendTemplateArgumentsToName(name, tplinst->get_templateArguments());
  }
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
  printf ("  name = %s \n",name.str());
#endif

  p_iterator = p_table->find(name);

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
  printf ("  this->count(name) = %d\n", this->count(name));
#endif

  // Iterate through the matching symbols in the multimap
  SgSymbol * sym = nullptr;
  while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name)) {
    sym = p_iterator->second;
    ROSE_ASSERT(sym != NULL);
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
    printf ("  sym = %p : %s\n", sym, sym->class_name().c_str());
#endif
    SgNode * symbolBasis = sym->get_symbol_basis();
    ROSE_ASSERT(symbolBasis != NULL);
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
    printf ("  symbolBasis = %p : %s\n", symbolBasis, symbolBasis->class_name().c_str());
#endif
    if (symbolBasis == initializedName) break;

    sym = nullptr;
    p_iterator++;
  }
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
  printf ("  sym = %p : %s\n", sym, sym ? sym->class_name().c_str() : "");
#endif
  ROSE_ASSERT(sym == nullptr || sym->get_symbol_basis() == initializedName);

  return sym;
}

SgSymbol*
SgSymbolTable::find( const SgFunctionType* functionType)
   {
     ROSE_ASSERT(p_table != NULL);
     ROSE_ASSERT(functionType != NULL);

#if 0
     mprintf ("Inside of SgSymbolTable::find( const SgFunctionType* ): functionType = %p = %s \n",functionType,SageInterface::get_name(functionType).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = functionType->get_mangled();

     p_iterator = p_table->find(name);
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name))
        {
       // DQ (3/19/2016): This is an issue for Klocworks.
          SgSymbol* symbol = isSgSymbol((*p_iterator).second);
          ROSE_ASSERT(symbol != NULL);
          if (symbol->variantT() == functionType->variantT())
             {
               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == functionType)
                    return returnSymbol;
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgStatement* statement)
   {
     ROSE_ASSERT(p_table != NULL);
     ROSE_ASSERT(statement != NULL);

#define DEBUG_FIND_SYMBOL_FROM_STATEMENT 0

#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
     mprintf ("Inside of SgSymbolTable::find( const SgStatement* ): statement = %p = %s = %s \n",statement,statement->class_name().c_str(),SageInterface::get_name(statement).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = get_name(statement);
  // Liao 11/28/2012: a declaration can have empty name "". But it will have a symbol with a mangled name starting with "__unnamed_".
  // A ResetEmptyNames process to handle this should be used before this find is called.
  // I cannot assert this since this function can be called before the empty name is reset.
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
     mprintf ("Inside of SgSymbolTable::find( const SgStatement* ): name = %s \n",name.str());
#endif

  // Get a quick pointer into the symbol table using the name (log n complexity)
     p_iterator = p_table->find(name);

  // Once we have p_iterator set via the name we don't typically have more than one iteration
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name))
        {
          ROSE_ASSERT(p_iterator->second != NULL);
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: p_iterator->second = %p statement = %p \n",p_iterator->second,statement);
          mprintf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
#endif

       // This is a virtual function call (not defined for function type symbols)
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();

#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: statement->variantT() = %d = %s \n",
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name.c_str());
#endif
       // DQ (1/27/2019): Test this to see if we can generate a dot graph to debug the problem.
          ROSE_ASSERT(symbolBasis != NULL);

#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: symbolBasis->variantT() = %d = %s statement->variantT() = %d = %s \n",
               symbolBasis->variantT(),Cxx_GrammarTerminalNames[symbolBasis->variantT()].name.c_str(),
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name.c_str());
#endif
          ROSE_ASSERT(symbolBasis != NULL);

          if (symbolBasis->variantT() == statement->variantT())
             {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
               mprintf ("matching variants \n");
#endif
               returnSymbol = p_iterator->second;

            // This is a very precise test which might be a problem because of defining and non-defining versions
            // of declarations (we might be able to always use the non-defining declaration in these cases.  The
            // switch which computes the names could normalize this aspect.
               if (returnSymbol->get_symbol_basis() == statement)
                  {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
                    mprintf ("returnSymbol->get_symbol_basis() == statement returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
#endif
                    return returnSymbol;
                  }
                 else
                  {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
                    mprintf ("returnSymbol->get_symbol_basis() != statement (returnSymbol->get_symbol_basis() = %p statement = %p) \n",returnSymbol->get_symbol_basis(),statement);
#endif
                  }
             }
            else
             {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
               mprintf ("Some other symbol was found (no matching variants) \n");
#endif
             }
          p_iterator++;
        }
     return NULL;
   }


void
SgSymbolTable::remove( const SgSymbol* symbol )
   {
  // This is used for the handled of non function type symbol tables, and is more useful when the
  // symbols don't have unique names.

  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     ROSE_ASSERT (p_table != NULL);

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
#if SYMBOL_TABLE_ERROR_CHECKING
  // This is an expensive linear time search of the symbol table!
     ROSE_ASSERT(exists(symbol) == true);
#endif

  // This is a virtual function call
     SgName name = symbol->get_name();
     rose_hash_multimap::iterator elementToDelete = get_table()->end();
     rose_hash_multimap::iterator it = get_table()->find(name);

     while ( (it != get_table()->end()) && (elementToDelete == get_table()->end()) && get_table()->key_eq()((*it).first,name) )
        {
       // Make sure that we find the correct element
          if (it->second == symbol)
             {
               elementToDelete = it;
             }
          it++;
        }

  // DQ (8/15/2020): Original code before the chagne below.
     ROSE_ASSERT(elementToDelete != get_table()->end());

  // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
     p_symbolSet.erase(elementToDelete->second);

     get_table()->erase(elementToDelete);
   }


/* ************************************************************************
                               FIND FUNCTIONS
   ************************************************************************/

// DQ (11/27/2010): Change return type to "bool".
bool
SgSymbolTable::find(const SgName & nm, SgSymbol *sp)
   {
     ROSE_ASSERT(p_table != NULL);

  // DQ (5/22/2006): Made this a local variable
     p_iterator = p_table->find(nm);
     while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
        {
          p_name    = nm;
          p_no_name = false;
          if( p_iterator->second == sp )
               return true;
          p_iterator++;
        }

     return false;
   }

SgAliasSymbol*
SgSymbolTable::find_aliased_symbol(const SgName & nm, SgSymbol *sp)
   {
  // DQ (5/19/2013): This function finds the symbol for which the alias is sp, not the symbol to be returned being sp.
     ROSE_ASSERT(p_table != NULL);

     ROSE_ASSERT(sp != NULL);

#if 0
     mprintf ("In SgSymbolTable::find_aliased_symbol(): We are only using the name = %s sp = %p = %s (not any template arguments or template parameters) \n",nm.str(),sp,sp->class_name().c_str());
#endif

     p_iterator = p_table->find(nm);

     while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
        {
          p_name    = nm;
          p_no_name = false;

          ROSE_ASSERT(p_iterator->second != NULL);
#if 0
          mprintf ("In SgSymbolTable::find_aliased_symbol(): in loop: nm = %s p_iterator->second = %p = %s \n",nm.str(),p_iterator->second,p_iterator->second->class_name().c_str());
#endif

          SgAliasSymbol* aliasSymbol = isSgAliasSymbol(p_iterator->second);
          if ( (aliasSymbol != NULL) && (aliasSymbol->get_alias() == sp) )
             {
               return aliasSymbol;
             }

          p_iterator++;
        }

     return NULL;
   }

bool
SgSymbolTable::exists ( const SgName & nm ) const
   {
     ASSERT_not_null(p_table);
     return p_table->find(nm) != p_table->end();
   }

bool
SgSymbolTable::exists ( const SgSymbol *sp ) const
   {
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
     return p_symbolSet.find(const_cast<SgSymbol*>(sp)) != p_symbolSet.end();
   }

bool
SgSymbolTable::exists ( const SgName & nm, SgSymbol *sp ) const
   {
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // Since we if we find the symbol it exists, we can test the name separately

  // Test if the symbol is in the set, else the name is not relavant to the existence
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
       // Now look to make sure that we have an entry with the correct name (and pointer value)
          hash_iterator p_iterator = p_table->find(nm);
          while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
             {
               if ( p_iterator->second == sp )
                  {
                 // This allows us to short-circuit the rest of the iterations
                    return true;
                  }

               p_iterator++;
             }
        }

     return false;
   }

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any(const SgName &);
      SgVariableSymbol*  find_variable(const SgName &);
      SgClassSymbol*     find_class(const SgName &);
      SgFunctionSymbol*  find_function(const SgName&);
      SgFunctionSymbol*  find_function_type(const SgName&, const SgType*);
      SgTypedefSymbol*   find_typedef(const SgName &);
      SgEnumSymbol*      find_enum(const SgName &);
      SgEnumFieldSymbol* find_enum_field(const SgName &);
      SgLabelSymbol*     find_label(const SgName &) const;
      SgJavaLabelSymbol* find_label(const SgName &) const; // charles4: added 9/12/2011 for Java
      SgNamespaceSymbol* find_namespace(const SgName &);
*/

SgSymbol*
SgSymbolTable::find_any(const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // DQ (6/24/2013): This special case requires some special support in find_symbol_support.
  // return find_symbol_support<SgSymbol>(nm,templateParameterList,templateArgumentList);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgSymbol>(nm,NULL,templateParameterList,templateArgumentList,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgTypedefSymbol*
SgSymbolTable::find_typedef(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgTypedefSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgTypedefSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumSymbol*
SgSymbolTable::find_enum(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgEnumSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgEnumSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumFieldSymbol*
SgSymbolTable::find_enum_field(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgEnumFieldSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgEnumFieldSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

SgVariableSymbol*
SgSymbolTable::find_variable(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgVariableSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

SgClassSymbol*
SgSymbolTable::find_class(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // SgClassSymbol* s = find_symbol_support<SgClassSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     SgClassSymbol* s = find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);

  // DQ (5/23/2013): Report when we are not being strict in the symbol that we return.
     if (isSgTemplateClassSymbol(s) != NULL)
        {
          mprintf ("WARNING: returing a SgTemplateClassSymbol from find_symbol_support<SgClassSymbol>(nm = %s); \n",nm.str());
        }

     return s;
   }

#define DEBUG_MATCHING_TEMPLATE_ARGUMENTS 0

bool
SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
   {
  // DQ (8/8/2013): I don't think that we need to handle the case of where there is both a valid SgTemplateParameterPtrList and SgTemplateArgumentPtrList.
     bool returnValue = false;

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("In TOP SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(): templateParameterList = %p templateArgumentsList = %p \n",templateParameterList,templateArgumentsList);
#endif

     if (templateParameterList != NULL)
        {
       // Note that this should be a template case if template parameters were specified.

       // DQ (8/19/2013): template classes need to use both the template parameter list and the template argument list.
          returnValue = hasMatchingTemplateParametersOrNoTemplateParameters(templateParameterList,symbol);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("In SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(): after evaluation of templateParameterList: templateParameterList = %p templateArgumentsList = %p returnValue = %s \n",templateParameterList,templateArgumentsList,returnValue ? "true" : "false");
#endif

          if (returnValue == true && templateArgumentsList != NULL)
             {
            // Since this function can be called when searching on the most general case of SgSymbol, we have to
            // permit this case to be evaluated.  However, since it only make sense for SgTemplateClassSymbol we
            // can return "true" for all other cases.
            // This case should only be for template class symbols (case of partial specialization).
               if (isSgTemplateClassSymbol(symbol) != NULL)
                  {
                    returnValue = hasMatchingTemplateArgumentsOrNoTemplateArguments(templateArgumentsList,symbol);
                  }
                 else
                  {
                 // DQ (5/22/2016): Isn't this an error to not also test the template arguments for non-class templates.
#if 0
                    mprintf ("WARNING: Isn't this an error to not also test the template arguments for non-class templates. \n");
#endif
                 // return "returnValue == true" for all other cases.
                  }
             }
        }
       else
        {
       // This is not a template and is either an instantiation of a template or non-instantiation (normal class, function, etc.).
          returnValue = hasMatchingTemplateArgumentsOrNoTemplateArguments(templateArgumentsList,symbol);
        }

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("In SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments() templateParameterList = %p templateArgumentsList = %p returnValue = %s \n",templateParameterList,templateArgumentsList,returnValue ? "true" : "false");
#endif

     return returnValue;
   }

bool
SgSymbolTable::hasMatchingTemplateParametersOrNoTemplateParameters(SgTemplateParameterPtrList* templateParameterList, SgSymbol* symbol)
   {
  // This is an overloaded function.

  // This function hides the details of calling the template version of the function.
  // return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateParameterPtrList>(templateParameterList,symbol);
     return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateParameter>(templateParameterList,symbol);
   }

bool
SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
   {
  // This is an overloaded function.

  // This is the refactored version of the previous function API.
  // This function hides the details of calling the template version of the function.
  // return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateArgumentPtrList>(templateArgumentsList,symbol);
     return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateArgument>(templateArgumentsList,symbol);
   }

// DQ (8/10/2013): Base template for specializations specific to template arguments and template parameters.
template <class T> std::vector<T*> getTemplateParametersOrArgumentsList(SgSymbol* symbol)
   {
     return std::vector<T*>();
   }

template <>
std::vector<SgTemplateArgument*> getTemplateParametersOrArgumentsList<SgTemplateArgument>(SgSymbol* symbol)
   {
  // Template specialization for handling template arguments.

  // DQ (8/11/2013): This function uses the STL copy operation and might have a more efficient implementation.
     std::vector<SgTemplateArgument*> returnList;

     ROSE_ASSERT(symbol != NULL);
#if 0
     mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
     switch(symbol->variantT())
        {
          case V_SgClassSymbol:
             {
               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);
               ROSE_ASSERT(classSymbol != NULL);

               SgClassDeclaration* classDeclaration = classSymbol->get_declaration();
               ROSE_ASSERT(classDeclaration != NULL);
               SgTemplateInstantiationDecl* templateClassInstantiation = isSgTemplateInstantiationDecl(classDeclaration);
               if (templateClassInstantiation != NULL)
                  {
                    returnList = templateClassInstantiation->get_templateArguments();
                  }
               break;
             }

          case V_SgFunctionSymbol:
             {
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);
               ROSE_ASSERT(functionSymbol != NULL);

               SgFunctionDeclaration* functionDeclaration = functionSymbol->get_declaration();
               ROSE_ASSERT(functionDeclaration != NULL);
               SgTemplateInstantiationFunctionDecl* templateFunctionInstantiation = isSgTemplateInstantiationFunctionDecl(functionDeclaration);
               if (templateFunctionInstantiation != NULL)
                  {
                    returnList = templateFunctionInstantiation->get_templateArguments();
                  }
               break;
             }

        // DQ (8/12/2013): Added case for SgMemberFunctionSymbol
          case V_SgMemberFunctionSymbol:
             {
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);
               ROSE_ASSERT(memberFunctionSymbol != NULL);

               SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionSymbol->get_declaration();
               ROSE_ASSERT(memberFunctionDeclaration != NULL);
               SgTemplateInstantiationMemberFunctionDecl* templateMemberFunctionInstantiation = isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration);
               if (templateMemberFunctionInstantiation != NULL)
                  {
                    returnList = templateMemberFunctionInstantiation->get_templateArguments();
                  }
               break;
             }

        // DQ (8/19/2013): Added case for SgTemplateClassSymbol
          case V_SgTemplateClassSymbol:
             {
               SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);
               ROSE_ASSERT(templateClassSymbol != NULL);

               ROSE_ASSERT(templateClassSymbol->get_declaration() != NULL);

               SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(templateClassSymbol->get_declaration());

               if (templateClassDeclaration != NULL)
                  {
                    returnList = templateClassDeclaration->get_templateSpecializationArguments();
                  }
               break;
             }

          case V_SgTemplateVariableSymbol:
             {
               SgTemplateVariableSymbol* vsym = isSgTemplateVariableSymbol(symbol);
               ROSE_ASSERT(vsym != NULL);

               SgInitializedName* iname = vsym->get_declaration();
               ROSE_ASSERT(iname != NULL);

               SgTemplateVariableDeclaration * tplvdecl = isSgTemplateVariableDeclaration(iname->get_parent());
               ROSE_ASSERT(tplvdecl != NULL);

               returnList = tplvdecl->get_templateSpecializationArguments();
               break;
             }

       // DQ (9/12/2016): Providing better implementation for template typedef symbol support.
       // DQ (11/10/2014): Providing an initial implementation for template typedef symbol support.
          case V_SgTemplateTypedefSymbol:
             {
#if 0
               mprintf ("WARNING: returning NULL in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
               SgTemplateTypedefSymbol* templateTypedefSymbol = isSgTemplateTypedefSymbol(symbol);
               ROSE_ASSERT(templateTypedefSymbol != NULL);

               ROSE_ASSERT(templateTypedefSymbol->get_declaration() != NULL);

               SgTemplateTypedefDeclaration* templateTypedefDeclaration = isSgTemplateTypedefDeclaration(templateTypedefSymbol->get_declaration());

               if (templateTypedefDeclaration != NULL)
                  {
                 // returnList = templateTypedefDeclaration->get_templateArguments();
                    returnList = templateTypedefDeclaration->get_templateSpecializationArguments();
                  }
               break;
             }

       // DQ (4/10/2017): Added case for other symbols (but we only return the empty list for this case).
          case V_SgLabelSymbol:

       // DQ (8/19/2013): Added case for other symbols (but we only return the empty list for this case).
          case V_SgVariableSymbol:
          case V_SgTypedefSymbol:
          case V_SgEnumSymbol:
          case V_SgEnumFieldSymbol:
          case V_SgNamespaceSymbol:
          case V_SgAdaGenericSymbol: // workaround some Ada symbols without names. Ada2Cpp cannot remove them for now.
             {
            // This function requires this case so that it can be called within very general contexts.
            // However, for this case we only return the empty template parameter list.

               break;
             }

          case V_SgNonrealSymbol:
             {
#if 0
               mprintf ("In SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): Case of SgNonrealSymbol\n");
#endif
               SgNonrealSymbol * nrsym = isSgNonrealSymbol(symbol);
               ROSE_ASSERT(nrsym != NULL);
               SgNonrealDecl * nrdecl = isSgNonrealDecl(nrsym->get_declaration());
               ROSE_ASSERT(nrdecl != NULL);
               returnList = nrdecl->get_tpl_args();
               break;
             }

          case V_SgTemplateSymbol:
             {
               mprintf ("Case of SgTemplateSymbol not handled yet in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>() \n");
               ROSE_ASSERT(false);
               break;
             }

          default:
             {
               mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return returnList;
   }

template <>
std::vector<SgTemplateParameter*> getTemplateParametersOrArgumentsList<SgTemplateParameter>(SgSymbol* symbol)
   {
  // Template specialization for handling template parameters.

  // DQ (8/11/2013): This function uses the STL copy operation and might have a more efficient implementation.
     std::vector<SgTemplateParameter*> returnList;

     ROSE_ASSERT(symbol != NULL);

#if 0
     mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif

     switch(symbol->variantT())
        {
          case V_SgTemplateClassSymbol:
             {
               SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);
               ROSE_ASSERT(templateClassSymbol != NULL);

               SgClassDeclaration* classDeclaration = templateClassSymbol->get_declaration();
               ROSE_ASSERT(classDeclaration != NULL);
               SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(classDeclaration);
               if (templateClassDeclaration != NULL)
                  {
                    returnList = templateClassDeclaration->get_templateParameters();
                  }
               break;
             }

          case V_SgTemplateFunctionSymbol:
             {
               SgTemplateFunctionSymbol* templateFunctionSymbol = isSgTemplateFunctionSymbol(symbol);
               ROSE_ASSERT(templateFunctionSymbol != NULL);

               SgFunctionDeclaration* functionDeclaration = templateFunctionSymbol->get_declaration();
               ROSE_ASSERT(functionDeclaration != NULL);
               SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(functionDeclaration);
               if (templateFunctionDeclaration != NULL)
                  {
#if 0
                    mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): Get the template parameter lise from templateFunctionDeclaration = %p = %s name = %s \n",
                         templateFunctionDeclaration,templateFunctionDeclaration->class_name().c_str(),templateFunctionDeclaration->get_name().str());
#endif
                    returnList = templateFunctionDeclaration->get_templateParameters();
                  }
                 else
                  {
                    mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
               break;
             }

        // DQ (8/12/2013): Added case for SgTemplateMemberFunctionSymbol
          case V_SgTemplateMemberFunctionSymbol:
             {
               SgTemplateMemberFunctionSymbol* templateMemberFunctionSymbol = isSgTemplateMemberFunctionSymbol(symbol);
               ROSE_ASSERT(templateMemberFunctionSymbol != NULL);

               SgMemberFunctionDeclaration* memberFunctionDeclaration = templateMemberFunctionSymbol->get_declaration();
               ROSE_ASSERT(memberFunctionDeclaration != NULL);
               SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(memberFunctionDeclaration);
               if (templateMemberFunctionDeclaration != NULL)
                  {
#if 0
                    mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): Get the template parameter lise from templateFunctionDeclaration = %p = %s name = %s \n",
                         templateMemberFunctionDeclaration,templateMemberFunctionDeclaration->class_name().c_str(),templateMemberFunctionDeclaration->get_name().str());
#endif
                    returnList = templateMemberFunctionDeclaration->get_templateParameters();
                  }
                 else
                  {
                    mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
               break;
             }

          case V_SgTemplateVariableSymbol:
             {
               SgTemplateVariableSymbol* vsym = isSgTemplateVariableSymbol(symbol);
               ROSE_ASSERT(vsym != NULL);

               SgInitializedName* iname = vsym->get_declaration();
               ROSE_ASSERT(iname != NULL);

               SgTemplateVariableDeclaration * tplvdecl = isSgTemplateVariableDeclaration(iname->get_parent());
               ROSE_ASSERT(tplvdecl != NULL);

               returnList = tplvdecl->get_templateParameters();
               break;
             }

       // DQ (11/10/2014): Providing an initial implementation for template typedef symbol support.
          case V_SgTemplateTypedefSymbol:
             {
            // DQ (3/5/2017): Converted to use message logging, but the mechanism is not supported here yet.
               mprintf ("WARNING: returning NULL in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
               break;
             }
       // DQ (8/19/2013): Added case for other symbols (but we only return the empty list for this case).
          case V_SgClassSymbol:
          case V_SgVariableSymbol:
          case V_SgFunctionSymbol:
          case V_SgMemberFunctionSymbol:
          case V_SgTypedefSymbol:
          case V_SgEnumSymbol:
          case V_SgEnumFieldSymbol:
          case V_SgNamespaceSymbol:
          case V_SgAdaGenericSymbol: // workaround some Ada symbols without names. Ada2Cpp cannot remove them for now.
             {
            // This function requires this case so that it can be called within very general contexts.
            // However, for this case we only return the empty template parameter list.

               break;
             }

          case V_SgNonrealSymbol:
             {
               SgNonrealSymbol * nrsym = isSgNonrealSymbol(symbol);
               ROSE_ASSERT(nrsym != NULL);
               SgNonrealDecl * nrdecl = isSgNonrealDecl(nrsym->get_declaration());
               ROSE_ASSERT(nrdecl != NULL);
               returnList = nrdecl->get_tpl_params();
               break;
             }

          case V_SgTemplateSymbol:
             {
               mprintf ("Case of SgTemplateSymbol not handled yet in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>() \n");
               ROSE_ASSERT(false);
               break;
             }

          default:
             {
               mprintf ("Exiting in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return returnList;
   }


// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgClassSymbol* classSymbol)
// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
template <class T>
bool
SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(std::vector<T*>* templateParametersOrArgumentsList, SgSymbol* symbol)
   {
  // DQ (8/8/2013): I needed to change the API to be more generic to support template for functions (and not just classes).

  // DQ (1/30/2013): Note that this function only supports the evaluation of template arguments for classes (and structs, and unions),
  // but not for any types of functions.  Not clear if this is a problem for the future or not, but usually there is more symmetry required.

  // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.
     bool returnValue = false;

     ROSE_ASSERT(symbol != NULL);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("\nIn SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(): templateParametersOrArgumentsList = %p symbol = %p = %s \n",templateParametersOrArgumentsList,symbol,symbol->class_name().c_str());
#endif

     if (templateParametersOrArgumentsList != NULL)
        {
          std::vector<T*> templateParametersOrArgumentsListFromSymbol = getTemplateParametersOrArgumentsList<T>(symbol);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("In SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(): templateParametersOrArgumentsList->size() = %" PRIuPTR " templateParametersOrArgumentsListFromSymbol.size() = %" PRIuPTR " \n",
               templateParametersOrArgumentsList->size(),templateParametersOrArgumentsListFromSymbol.size());
#endif
       // Output a message for this case, but don't make it an error.
          if (templateParametersOrArgumentsListFromSymbol.empty() == false)
             {
            // DQ (9/19/2013): I now think this should not be an error, since it would not permit the general case where this function is used.
            // ROSE_ASSERT(templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size());
             }

          if ( (templateParametersOrArgumentsListFromSymbol.empty() == false) && (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size()) )
             {
            // Check if they are the same size...

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
               mprintf ("In SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): symbol = %p = %s templateParametersOrArgumentsList->size() = %" PRIuPTR " templateClassInstantiation->get_templateArguments().size() = %" PRIuPTR " \n",
                       symbol,symbol->class_name().c_str(),templateParametersOrArgumentsList->size(),templateParametersOrArgumentsListFromSymbol.size());
               for (size_t i = 0; i < templateParametersOrArgumentsList->size(); i++)
                  {
                    mprintf ("----- (*templateParametersOrArgumentsList)[%" PRIuPTR "] = %p templateClassInstantiation->get_templateArguments()[%" PRIuPTR "] = %p \n",i,(*templateParametersOrArgumentsList)[i],i,templateParametersOrArgumentsListFromSymbol[i]);
                  }
#endif
               if (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size())
                  {
                 // Check if they are the same STL vector values...
                    if (*templateParametersOrArgumentsList == templateParametersOrArgumentsListFromSymbol)
                       {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): The template argument vectors are equal \n");
#endif
                         returnValue = true;
                       }

                 // DQ (8/23/2012): If these are SgTemplateType arguments then consider them the same for now.
                 // It is less clear how to handle template arguments because the names can change in different parts of the
                 // template declaration, so for now we will rely on the instantiated templates name and the number of arguments
                 // if they are all SgTemplateType template arguments.
                    if (returnValue == false)
                       {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): Double check if we had set returnValue to false based on SgTemplateType template arguments (if so, then return true) \n");
#endif

                      // DQ (12/30/2018): I think a better name for this variable would be "is_matching_template_type_boolean".
                         bool isTemplateType = true;
                      // DQ 12/30/2018): We only want to test up to the first template parameter or argument that is not matching.
                      // Alternatively a "while" loop might be more clear.
                         for (size_t i = 0; ((isTemplateType == true) && (i < templateParametersOrArgumentsList->size())); i++)
                            {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                              printf("----- (*templateParametersOrArgumentsList)[%zd]        = %p = %s\n", i, (*templateParametersOrArgumentsList)[i],        (*templateParametersOrArgumentsList)[i]->unparseToString().c_str()        );
                              printf("----- templateParametersOrArgumentsListFromSymbol[%zd] = %p = %s\n", i, templateParametersOrArgumentsListFromSymbol[i], templateParametersOrArgumentsListFromSymbol[i]->unparseToString().c_str() );
#endif

                              T* templateParameterOrArgumentLocal      = (*templateParametersOrArgumentsList)[i];
                              T* templateParameterOrArgumentFromSymbol = templateParametersOrArgumentsListFromSymbol[i];
                              ROSE_ASSERT(templateParameterOrArgumentLocal != NULL);
                              ROSE_ASSERT(templateParameterOrArgumentFromSymbol != NULL);

                           // DQ (6/17/2013): The get_argumentType() can be either of these.
                           //    type_argument               = 1, /*!< type parameter */
                           //    nontype_argument            = 2, /*!< nontype parameter */
                           //    template_template_argument  = 3  /*!< template template parameter */

                           // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                           // Note that this predicate function does not test if the types are equivalent.
                              if (T::is_matching_type(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                 {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("----- Template parameters or arguments match in parameter or argument type: \n");
                                   mprintf ("-----    --- templateParameterOrArgumentLocal->get_type()      = %p = %s \n",templateParameterOrArgumentLocal->get_type(),     templateParameterOrArgumentLocal->get_type()->class_name().c_str());
                                   mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_type() = %p = %s \n",templateParameterOrArgumentFromSymbol->get_type(),templateParameterOrArgumentFromSymbol->get_type()->class_name().c_str());
#endif
                                   isTemplateType = SageInterface::isEquivalentType(templateParameterOrArgumentLocal->get_type(),templateParameterOrArgumentFromSymbol->get_type());
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("-----    --- SageInterface::isEquivalentType() returns: isTemplateType = %s \n",(isTemplateType == true) ? "true" : "false");
#endif
                                 }
                                else
                                 {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("-----    --- T::is_matching_type() == false \n");
#endif
                                // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                                // DQ (6/17/2013): This newer code does a better job of resolving if template arguments are equivalent (more can be done still).
                                   if (T::is_matching_nontype(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                      {
                                     // Test for equivalence of nontype arguments (e.g. values).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("WARNING: These are both nontype template arguments (which we are considering to be the same withouth enough testing \n");
#endif
                                        ROSE_ASSERT(templateParameterOrArgumentLocal->get_expression() != NULL || templateParameterOrArgumentLocal->get_initializedName() != NULL);
                                        ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_expression() != NULL || templateParameterOrArgumentFromSymbol->get_initializedName() != NULL);
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("-----    --- templateParameterOrArgumentLocal->get_expression()      = %p \n",templateParameterOrArgumentLocal->get_expression());
                                        mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_expression() = %p \n",templateParameterOrArgumentFromSymbol->get_expression());
#endif
                                     // DQ (8/11/2013): We have added a SgInitializedName pointer to SgTemplateArgument (so it now matches the SgTemplateParameter,
                                     // and because it was needed for more complex template arguments, analigous to test2013_303.C)
                                        if (templateParameterOrArgumentLocal->get_expression() == templateParameterOrArgumentFromSymbol->get_expression())
                                           {
                                          // DQ (8/11/2013): Note that these might have been equal because they were both NULL.
                                          // isTemplateType = true;
                                             if (templateParameterOrArgumentLocal->get_expression() != NULL)
                                                {
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- templateParameterOrArgumentLocal->get_initializedName()      = %p type = %p \n",
                                                       templateParameterOrArgumentLocal->get_initializedName(),templateParameterOrArgumentLocal->get_initializedName()->get_type());
                                                  mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_initializedName() = %p type = %p \n",
                                                       templateParameterOrArgumentFromSymbol->get_initializedName(),templateParameterOrArgumentFromSymbol->get_initializedName()->get_type());
#endif
                                                  ROSE_ASSERT(templateParameterOrArgumentLocal->get_initializedName() != NULL);
                                                  ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_initializedName() != NULL);

                                               // DQ (12/8/2015): FIXME: This is not a good enough test, this can be improved.
                                                  if (templateParameterOrArgumentLocal->get_initializedName() == templateParameterOrArgumentFromSymbol->get_initializedName())
                                                     {
                                                       isTemplateType = true;
                                                     }
                                                    else
                                                     {
                                                    // DQ (8/19/2013): The possible problem here is that two SgInitializedName objects might be the same and yet be different pointers.
                                                    // So this might still not be a good enough test.  An alternative might be to double check the name and the scope as what might be
                                                    // a better test.
                                                    // DQ (12/8/2015): Check if the names are the same (independent of the SgIntializedName object pointers).
                                                       std::string str1 = templateParameterOrArgumentLocal->get_initializedName()->get_name().str();
                                                       std::string str2 = templateParameterOrArgumentFromSymbol->get_initializedName()->get_name().str();
                                                       if (str1 != str2)
                                                          {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS || 0
                                                            mprintf ("-----    --- --- These are NOT the same initializedName values and should have resolved to be the same pointer value if there were the same initializedName! (really?) \n");
                                                            mprintf ("WARNING: initializedName associated with same different initializedName was not checked... (might be different initializedName with the same name and type) \n");
                                                            mprintf ("templateParameterOrArgumentLocal->get_initializedName() = %s templateParameterOrArgumentFromSymbol->get_initializedName() = %s \n",str1.c_str(),str2.c_str());
#endif
                                                          }


                                                    // DQ (2/16/2014): test2014_17.C demonstrates that the SgInitializedName pointers need not match for this to be the same template parameter.
                                                    // I think it is enough that they are the same type, but it migh also be required that the names match as well (but I don't think this is
                                                    // required for C++).
                                                    // isTemplateType = false;

                                                    // DQ (12/8/2015): Using newly implemented function for type equivalence.
                                                    // DQ (12/8/2015): FIXME: This is not a good enough test, this can be improved.
                                                    // DQ (12/15/2015): This causes a problem for SgTemplateType and SgMemberFunctionType and demonstrates the problem for debugging.
                                                       if (templateParameterOrArgumentLocal->get_initializedName()->get_type()->isEquivalentType(templateParameterOrArgumentFromSymbol->get_initializedName()->get_type()) == true)
                                                          {
                                                            isTemplateType = true;
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                            mprintf ("-----    --- --- These are NOT the same initializedName pointers, but they match in type! \n");
#endif
                                                         // DQ (7/7/2014): If these are not the same name then there is no match (see test2014_78.C).
                                                         // TV (06/21/2018): TODO look into this more...
                                                            if (false && templateParameterOrArgumentLocal->get_initializedName()->get_name() != templateParameterOrArgumentFromSymbol->get_initializedName()->get_name())
                                                               {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                              // DQ (7/7/2014): For now output debugging informationfor this case.
                                                                 mprintf ("These names failed to match: \n");
                                                                 mprintf (" --- templateParameterOrArgumentLocal->get_initializedName()->get_name()      = %s \n",templateParameterOrArgumentLocal->get_initializedName()->get_name().str());
                                                                 mprintf (" --- templateParameterOrArgumentFromSymbol->get_initializedName()->get_name() = %s \n",templateParameterOrArgumentFromSymbol->get_initializedName()->get_name().str());
#endif
                                                                 isTemplateType = false;
                                                               }
                                                         // DQ (2/16/2014): I am not certain that the names have to match, but assert this for now as part of testing!
                                                         // ROSE_ASSERT (templateParameterOrArgumentLocal->get_initializedName()->get_name() == templateParameterOrArgumentFromSymbol->get_initializedName()->get_name());
                                                          }
                                                         else
                                                          {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                            mprintf ("-----    --- --- These are NOT the same initializedName pointers OR the same type! \n");
#endif
                                                            isTemplateType = false;
                                                          }
                                                     }
                                                }
                                           }
                                          else
                                           {
                                          // DQ (12/8/2015): FIXME: These pointers to different expressions are nearly always the same expression after evaluation.
                                          // Different pointer values mean different expressions (I hope this is always true).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS || 0
                                             mprintf ("-----    --- --- These are NOT the same expresion values and should have resolved to be the same pointer value if there were the same expression! (really?) \n");
                                             mprintf ("WARNING: value associated with same different expressions was not checked... (might be different constants with the same value) \n");
                                             std::string str1 = templateParameterOrArgumentLocal->get_expression()->unparseToString();
                                             std::string str2 = templateParameterOrArgumentFromSymbol->get_expression()->unparseToString();
                                             mprintf ("unparsed expressions: %s and %s \n",str1.c_str(),str2.c_str());
#endif
                                           }
                                      }
                                     else
                                      {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("-----    --- T::is_matching_nontype() == false \n");
#endif
                                     // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                                        if (T::is_matching_template(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                           {
                                          // Test for equivalence of template_template arguments.
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("WARNING: These are both template template template arguments (which we are considering to be the same without enough testing \n");
#endif
                                             ROSE_ASSERT(templateParameterOrArgumentLocal->get_templateDeclaration() != NULL);
                                             ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_templateDeclaration() != NULL);
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("-----    --- templateParameterOrArgumentLocal->get_templateDeclaration()      = %p \n",templateParameterOrArgumentLocal->get_templateDeclaration());
                                             mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_templateDeclaration() = %p \n",templateParameterOrArgumentFromSymbol->get_templateDeclaration());
#endif
                                             if (templateParameterOrArgumentLocal->get_templateDeclaration() == templateParameterOrArgumentFromSymbol->get_templateDeclaration())
                                                {
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
                                               // Different pointer values mean different expressions (I hope this is always true).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- --- These are NOT the same template declaration values and should have resolved to be the same pointer value if there were the same template template declaration argument value \n");
#endif
                                                }
                                           }
                                          else
                                           {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("-----    --- T::is_matching_template() == false \n");
#endif
                                          // ROSE_ASSERT(templateArgumentLocal->get_argumentType() != templateArgumentFromSymbol->get_argumentType());
                                          // DQ (5/19/2014): Output more debugging information.
                                             if (T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                                {
                                                  SgTemplateArgument* templateArgumentLocal        = isSgTemplateArgument(templateParameterOrArgumentLocal);
                                                  SgTemplateArgument* templateArgumentFromSymbol   = isSgTemplateArgument(templateParameterOrArgumentFromSymbol);
                                                  SgTemplateParameter* templateParameterLocal      = isSgTemplateParameter(templateParameterOrArgumentLocal);
                                                  SgTemplateParameter* templateParameterFromSymbol = isSgTemplateParameter(templateParameterOrArgumentFromSymbol);
                                                  if (templateArgumentLocal != NULL)
                                                     {
                                                       ROSE_ASSERT(templateArgumentFromSymbol != NULL);
                                                     }
                                                    else
                                                     {
                                                       ROSE_ASSERT(templateParameterLocal != NULL);
                                                       ROSE_ASSERT(templateParameterFromSymbol != NULL);
                                                     }
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("----- T::is_matching_kind() == false: \n");
#endif
                                                }

                                          // DQ (5/19/2014): /include/boost/chrono/duration.hpp contains a new kind of template argument that maps to what EDG calls tak_start_of_pack_expansion.
                                          // This support is not yet implemented in ROSE (version 1.50 of Boost and version 4.9 of EDG are required to detect this).
                                          // returning "isTemplateType = false;" for now.
                                          // ROSE_ASSERT(T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == false);
                                             if (T::is_matching_template_pack_expansion(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("----- SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): This is the case of a template_pack_expansion: not yet supported (edg calls this tak_start_of_pack_expansion) \n");
#endif
                                               // DQ (12/28/2018): Return true if both a marked as template pack.
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- T::is_matching_template_pack_expansion() == false \n");
#endif
                                                  ROSE_ASSERT(T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == false);

                                               // DQ (12/28/2018): Return false.
                                                  isTemplateType = false;
                                                }

                                          // DQ (12/28/2018): We want to set this differently in the two branches above.
                                           }
                                      }
                                 }
                            }

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): we are relying on only the existence of all SgTemplateType template arguments to decide that this is a match isTemplateType = %s \n",
                              isTemplateType ? "true" : "false");
#endif
                         returnValue = isTemplateType;
                       }
                  }
             }
            else
             {
            // DQ (8/22/2012): Consider if this make sense...yes, if it is not a template instantiation then matching is based on name in a specific scope only.
            // DQ (5/8/2016): Actually it is based on the name and the template parameters (I think the number of template parameters only, but I am not certain).
            // DQ (5/8/2016): If the list is not empty then it had a different number of arguments and so it can't be the same (return false)
               if (templateParametersOrArgumentsListFromSymbol.empty() == false)
                  {
                 // && (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size())
                 // Check if they are the same size...
                 // DQ (5/8/2016): If the list is not empty then it had a different number of arguments and so it can't be the same (return false)
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                    mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsListFromSymbol.empty() == false: different size list: (return false) \n");
#endif
                    returnValue = false;
                  }
                 else
                  {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                    mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsListFromSymbol.empty() == true (return true) \n");
#endif
                    returnValue = true;
                  }
             }
        }
       else
        {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsList == NULL (return true) \n");
#endif
          returnValue = true;
        }

     return returnValue;
   }


SgClassSymbol*
SgSymbolTable::find_class(const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.

  // DQ (5/20/2013): Using the find_template_symbol_support() function with templateParameterList == NULL;
  // s = find_symbol_support<SgTemplateClassSymbol>(nm);
  // SgTemplateParameterPtrList* templateParameterList = NULL;
  // return find_template_symbol_support<SgClassSymbol,SgClassDeclaration>(nm,templateParameterList,templateArgumentsList);

  // return find_symbol_with_template_args_support<SgClassSymbol>(nm,templateArgumentsList);
  // return find_symbol_support<SgClassSymbol>(nm,NULL,templateArgumentsList);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,templateArgumentsList,filterTemplateSymbols);
   }

SgNonrealSymbol*
SgSymbolTable::find_nonreal(const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgNonrealSymbol>(nm,NULL,templateParameterList,templateArgumentsList,filterTemplateSymbols);
   }


SgFunctionTypeSymbol*
SgSymbolTable::find_function_type(const SgName & nm)
   {
  // return find_symbol_support<SgFunctionTypeSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgFunctionTypeSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

SgLabelSymbol*
SgSymbolTable::find_label(const SgName & nm)
   {
  // return find_symbol_support<SgLabelSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgLabelSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

//
// charles4: added this function for the Java case...
//
SgJavaLabelSymbol*
SgSymbolTable::find_java_label(const SgName & nm)
   {
  // return find_symbol_support<SgJavaLabelSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgJavaLabelSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgNamespaceSymbol*
SgSymbolTable::find_namespace ( const SgName & nm )
   {
  // return find_symbol_support<SgNamespaceSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgNamespaceSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// SgFunctionSymbol* SgSymbolTable::find_function (const SgName & nm, const SgType* t)
SgFunctionSymbol*
SgSymbolTable::find_function (const SgName & nm, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(type != NULL);

     bool filterTemplateSymbols = false;
     SgFunctionSymbol *s = find_symbol_with_type_support<SgFunctionSymbol>(nm,type,NULL,templateArgumentList,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (8/13/2013): We should not be returning a template symbol from this function (verify this).
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

// DQ (12/27/2011): Added more support for template declarations in the AST.
// DQ (12/12/2011): New functions to support template declarations in the AST.
// SgTemplateSymbol* SgFunctionSymbol* SgSymbolTable::find_nontemplate_function(const SgName& nm, const SgType* t)
SgFunctionSymbol*
SgSymbolTable::find_nontemplate_function(const SgName& nm, const SgType* t, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(t != NULL);

     bool filterTemplateSymbols = true;
     SgFunctionSymbol *s = find_symbol_with_type_support<SgFunctionSymbol>(nm,t,NULL,templateArgumentList,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (5/23/2013): Added assertion on retuned symbol.
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

// DQ (7/31/2013): Adding support for template parameters and template specialization.
// SgTemplateFunctionSymbol* SgSymbolTable::find_template_function(const SgName& nm, const SgType* t)
// SgTemplateFunctionSymbol* SgSymbolTable::find_template_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateSpecializationArgumentList)
SgTemplateFunctionSymbol*
SgSymbolTable::find_template_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateParameterList)
   {
     bool filterTemplateSymbols = false;
     SgTemplateFunctionSymbol *s = find_symbol_with_type_support<SgTemplateFunctionSymbol>(nm,t,templateParameterList,NULL,filterTemplateSymbols);

     return s;
   }

SgTemplateVariableSymbol*
SgSymbolTable::find_template_variable(const SgName& nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     bool filterTemplateSymbols = false;
     SgTemplateVariableSymbol *s = find_symbol_with_type_support<SgTemplateVariableSymbol>(nm,NULL,templateParameterList,templateArgumentsList,filterTemplateSymbols);

     return s;
   }


// DQ (12/27/2011): Added more support for template declarations in the AST.
// SgMemberFunctionSymbol* SgSymbolTable::find_nontemplate_member_function(const SgName& nm, const SgType* t)
SgMemberFunctionSymbol*
SgSymbolTable::find_nontemplate_member_function(const SgName& nm, const SgType* t, SgTemplateArgumentPtrList* templateArgumentList)
   {
     SgMemberFunctionSymbol *s = NULL;

     bool filterTemplateSymbols = true;
     s = find_symbol_with_type_support<SgMemberFunctionSymbol>(nm,t,NULL,templateArgumentList,filterTemplateSymbols);

     return s;
   }

SgTemplateMemberFunctionSymbol*
SgSymbolTable::find_template_member_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateParameterList)
   {
     bool filterTemplateSymbols = false;
     SgTemplateMemberFunctionSymbol *s = find_symbol_with_type_support<SgTemplateMemberFunctionSymbol>(nm,t,templateParameterList,NULL,filterTemplateSymbols);

     return s;
   }


// DQ (12/26/2011): Adding revised support for template declarations in the AST.
SgClassSymbol*
SgSymbolTable::find_nontemplate_class (const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     bool filterTemplateSymbols = true;
     SgClassSymbol* s = find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,templateArgumentsList,filterTemplateSymbols);

  // DQ (8/12/2013): The semantics of find_symbol_with_template_args_support() was to never
  // return a SgTemplateClassSymbol where as the semantics of find_symbol_support() is to
  // return anything that is a derived class from SgClassSymbol, which can be a SgTemplateClassSymbol.
  // So this is an error in EDG/ROSE function: retrieveAssociatedClassSymbol().
  // Need to fix this tomorrow morning (make the function optionally strict so that we can
  // reuse the same minimal templated support.
     ROSE_ASSERT(isSgTemplateClassSymbol(s) == NULL);

     return s;
   }


// SgTemplateClassSymbol* SgSymbolTable::find_template_class (const SgName & nm)
SgTemplateClassSymbol*
SgSymbolTable::find_template_class (const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
   {
//   ROSE_ASSERT(templateParameterList != NULL); // TV: when we are looking for the original declaration of a template from potential specialization (we only have the name)

     bool filterTemplateSymbols = false;
     SgTemplateClassSymbol *s = find_symbol_with_type_support<SgTemplateClassSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList,filterTemplateSymbols);

     return s;
   }

// DQ (3/8/2017): Adding support for SgTemplateTypedefSymbol handling.
// SgTemplateClassSymbol* SgSymbolTable::find_template_class (const SgName & nm)
// SgTemplateTypedefSymbol* SgSymbolTable::find_template_typedef (const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
SgTemplateTypedefSymbol*
SgSymbolTable::find_template_typedef (const SgName & nm)
   {
  // ROSE_ASSERT(templateParameterList != NULL);

     SgTemplateParameterPtrList* templateParameterList              = NULL;
     SgTemplateArgumentPtrList*  templateSpecializationArgumentList = NULL;

     bool filterTemplateSymbols = false;
  // SgTemplateTypedefSymbol *s = find_symbol_with_type_support<SgTemplateTypedefSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList);
     SgTemplateTypedefSymbol *s = find_symbol_with_type_support<SgTemplateTypedefSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList,filterTemplateSymbols);

     return s;
   }

SgFunctionSymbol*
SgSymbolTable::find_function(const SgName & nm)
   {
     bool filterTemplateSymbols = false;
     SgFunctionSymbol* s = find_symbol_with_type_support<SgFunctionSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (8/13/2013): We should not be returning a template symbol from this function (verify this).
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

#define DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING 0

template<class ReturnType>
bool
templateParameterAndArgumentErrorChecking(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/11/2013): This function implements error checking on when template arguments and template parameters can be used relative to specific IR nodes
  // (template declarations, template instantiations, and non-template instantiations (normal functions and classes).

  // This function implements error checking for the functions: SgSymbolTable::find_symbol_support() and SgSymbolTable::find_symbol_with_type_support().
  // It is used within an assertion at the top of these template functions.

     bool returnValue = true;

     VariantT returnTypeVariant = (VariantT)ReturnType::static_variant;

  // DQ (8/17/2013): We need to permit ReturnType to be a SgSymbol so that we can support more general queries in the symbol table.
     if ((returnTypeVariant != V_SgSymbol) && (templateParameterList != NULL || templateArgumentList != NULL))
        {
          if (templateParameterList != NULL)
             {
            // ROSE_ASSERT((VariantT)ReturnType::static_variant == V_SgTemplateClassDeclaration || (VariantT)ReturnType::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)ReturnType::static_variant == V_SgTemplateMemberFunctionDeclaration);
               returnValue = (returnTypeVariant == V_SgTemplateClassSymbol || returnTypeVariant == V_SgTemplateFunctionSymbol || returnTypeVariant == V_SgTemplateMemberFunctionSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
               mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList != NULL && templateArgumentList == NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
             }

          if (templateParameterList != NULL && templateArgumentList != NULL)
             {
            // This is the only allowed case (since functions template can be partially specialized.
               returnValue = (returnTypeVariant == V_SgTemplateClassSymbol || returnTypeVariant == V_SgTemplateVariableSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
               mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList != NULL && templateArgumentList != NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
             }
            else
             {
               if (templateArgumentList != NULL)
                  {
                    returnValue = (returnTypeVariant == V_SgClassSymbol || returnTypeVariant == V_SgFunctionSymbol || returnTypeVariant == V_SgMemberFunctionSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
                    mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList == NULL && templateArgumentList != NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
                  }
             }
        }

     return returnValue;
   }


#define DEBUG_SYMBOL_FILTER 0

// DQ (4/14/2017): Test test2017_30.C demonstrates that we need to be able to force the filtering of symbols from templates
// and that they only way to do this is with an extra paramter to force this to happen.  Since the lack of information triggers
// the more general semantics to return any symbol (which is fine as a simple API, but inconsistant with when this is called
// indirectly from the lookup_nontemplate_function_symbol() function (for example).
// template<class ReturnSymbolType> ReturnSymbolType* symbolFilter(ReturnSymbolType* symbol, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
template<class ReturnSymbolType>
ReturnSymbolType*
symbolFilter(ReturnSymbolType* symbol, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols)
   {
  // DQ (8/13/2013): This function filters types of IR nodes that could not be considered given the rules
  // for what IR nodes apply when template parameters lists and template argument lists are provided.

     if (symbol != NULL)
        {
          VariantT symbolVariant = symbol->variantT();

#if DEBUG_SYMBOL_FILTER
          mprintf ("In symbolFilter(): symbolVariant = %d ReturnSymbolType variant = %d templateParameterList = %p templateArgumentList = %p \n",(int)symbolVariant,(int)ReturnSymbolType::static_variant,templateParameterList,templateArgumentList);
          mprintf ("   --- symbol = %p = %s \n",symbol,symbol->class_name().c_str());
          mprintf ("   --- symbol->get_name() = %s \n",symbol->get_name().str());
          mprintf ("   --- V_SgClassSymbol = %d \n",(int)V_SgClassSymbol);
          mprintf ("   --- V_SgFunctionSymbol = %d V_SgMemberFunctionSymbol = %d \n",(int)V_SgFunctionSymbol,(int)V_SgMemberFunctionSymbol);
          mprintf ("   --- V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
               (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
          mprintf ("   --- filterTemplateSymbols = %s \n",filterTemplateSymbols ? "true" : "false");
#endif

          if (templateParameterList != NULL)
             {
            // DQ (8/13/2013): If a template parameter list AND template argument list WERE provided then we only want to find class templates,
            // so if this is NOT a template reset it to NULL. Note that the previous cast will have eliminated function symbols
               if ( (templateArgumentList != NULL) && (symbolVariant == V_SgClassSymbol) )
                  {
#if DEBUG_SYMBOL_FILTER
                    mprintf ("Reset symbol to NULL: (templateParameterList != NULL && templateArgumentList != NULL): V_SgClassSymbol = %d \n",(int)V_SgClassSymbol);
#endif
                    symbol = NULL;
                  }

            // DQ (8/13/2013): If a template parameter list WAS provided and a template argument list was NOT provided then we only want to find function templates,
            // so if this is NOT a template reset it to NULL. Note that the previous cast will have eliminated class symbols.
               if ( (templateArgumentList == NULL) && (symbolVariant == V_SgFunctionSymbol || symbolVariant == V_SgMemberFunctionSymbol) )
                  {
#if DEBUG_SYMBOL_FILTER
                    mprintf ("Reset symbol to NULL: (templateParameterList != NULL && templateArgumentList == NULL): V_SgFunctionSymbol = %d V_SgMemberFunctionSymbol = %d \n",(int)V_SgFunctionSymbol,(int)V_SgMemberFunctionSymbol);
#endif
                    symbol = NULL;
                  }
             }
            else
             {
               if (templateArgumentList != NULL)
                  {
                 // DQ (8/13/2013): If a template parameter list was NOT provided then we only want to find non-templates,
                 // so if this IS a template reset it to NULL.
                    if ( symbolVariant == V_SgTemplateFunctionSymbol || symbolVariant == V_SgTemplateMemberFunctionSymbol || symbolVariant == V_SgTemplateClassSymbol )
                       {
                      // This can't be a template since there is no templateParameterList
#if DEBUG_SYMBOL_FILTER
                         mprintf ("Reset symbol to NULL: (templateParameterList == NULL): V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
                              (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
#endif
                         symbol = NULL;
                       }
                  }
                 else
                  {
                 // DQ (4/14/2017): Added support to disallow template symbolds explicitly.
                    if (filterTemplateSymbols == true)
                       {
                      // DQ (4/14/2017): This can't be a template symbol since we explicitly disallow it using a function parameter to control this.
#if DEBUG_SYMBOL_FILTER
                         mprintf ("Reset symbol to NULL: (filterTemplateSymbols == true && templateParameterList == NULL && templateArgumentList == NULL): V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
                              (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
#endif
                      // DQ (4/14/2017): Check if this is a template symbol (if so then set symbol to NULL to avoid returning a template symbol).
                         if ( symbolVariant == V_SgTemplateFunctionSymbol || symbolVariant == V_SgTemplateMemberFunctionSymbol ||
                              symbolVariant == V_SgTemplateClassSymbol    || symbolVariant == V_SgTemplateTypedefSymbol        ||
                              symbolVariant == V_SgTemplateVariableSymbol )
                            {
                              symbol = NULL;
                            }
                       }
                      else
                       {
                      // DQ (4/14/2017): Original case before adding explicit control to avoid symbols associated with template declarations.

                      // If both templateParameterList == NULL and templateArgumentList == NULL, then we have not provided enough
                      // information and are looking up symbols based only on name (and maybe type) and need to find the first match
                      // based on only this limited information.  Basically, we want to provide the best possible match when less
                      // than enough information is available to make a precise match.
#if DEBUG_SYMBOL_FILTER
                         mprintf ("DO NOT Reset symbol to NULL: (templateParameterList == NULL && templateArgumentList == NULL): not enough information provided for a precise match \n");
#endif
                       }
                  }
             }
        }

#if DEBUG_SYMBOL_FILTER
     mprintf ("Leaving symbolFilter(): symbol = %p templateParameterList = %p templateArgumentList = %p filterTemplateSymbols = %s \n",
          symbol,templateParameterList,templateArgumentList,filterTemplateSymbols ? "true" : "false");
#endif

     return symbol;
   }

bool
isSubset(const std::vector<SgNode*>& a_vector, const std::set<SgNode*>& b_set)
   {
  // DQ (7/12/2014): I am not aware of a faster algorithm for this. Using the shorter
  // vector (from the SgAliasSymbol) first will generally reduce the complexity for
  // order Na * log Nb instead of log Nb.  The value of Na would be the number of
  // causal nodes for any SgAliasSymbol (typically one) and Nb would be the number
  // of causal SgNode objects (e.g. SgUsingDirectiveStatement, SgUsingDeclarationStatement,
  // SgBaseClass, etc.).

#define DEBUG_IS_SUBSET 0

#if DEBUG_IS_SUBSET
     mprintf ("In isSubset(): a_vector.size() = %zu b_set.size() = %zu \n",a_vector.size(),b_set.size());
#endif

     for (std::vector<SgNode*>::const_iterator i = a_vector.begin(); i != a_vector.end(); i++)
        {
          bool found = false;
          std::set<SgNode*>::const_iterator j = find(b_set.begin(),b_set.end(),*i);
          found = (j != b_set.end());
#if DEBUG_IS_SUBSET
          mprintf ("In isSubset(): loop: found = %s *i = %p = %s \n",found ? "true" : "false",*i,(*i)->class_name().c_str());
#endif
          if (!found)
             {
#if DEBUG_IS_SUBSET
               mprintf ("Leaving isSubset(): returning false \n");
#endif
               return false;
             }
        }

#if DEBUG_IS_SUBSET
     mprintf ("Leaving isSubset(): returning true \n");
#endif

     return true;
   }


#define DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS 0

namespace
{
  // PP (4/29/22): replace SgSymbol::get_declaration
  //               with functions that check whether get_declaration exists
  template <class SageSymbol>
  auto getTypeOfDeclaration(const SageSymbol* sym) -> decltype(sym->get_declaration()->get_type())
  {
    auto ptr = sym->get_declaration();
    ASSERT_not_null(ptr);

    return ptr->get_type();
  }

  [[noreturn]]
  auto getTypeOfDeclaration(const SgSymbol*) -> SgType*
  {
    ROSE_ABORT();
  }
}

// DQ (4/14/2017): Added explicit control to filer symbols associated with templates (see test2017_30.C for where this is required).
// DQ (7/31/2013): Added support for template parameters and template specialization.
// template<class ReturnType> ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type)
// template<class ReturnType> ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
template<class ReturnType>
ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols)
   {
  // Templated function to support retrival of different types of symbols from the symbol table.
  // This refactors a lot of code (some now and more later).

  // This low level templated function only makes sense for where the ReturnType is either of:
  //    SgFunctionSymbol, SgMemberFunctionSymbol, SgTemplateFunctionSymbol, SgTemplateMemberFunctionSymbol.

  // DQ (5/20/2013): Newer implementation of the symbol table handling to account for the template type, SgRenameSymbol, and SgAliasSymbols (in that order).

     ROSE_ASSERT(p_table != NULL);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
     mprintf ("---------------------------------------------------------------------------------- \n");
     mprintf ("In find_symbol_with_type_support(nm = %s, type = %p = %s, templateParameterList = %p, templateArgumentList = %p, filterTemplateSymbols = %s) \n",
          nm.str(),type,(type != NULL) ? type->class_name().c_str() : "null",templateParameterList,templateArgumentList,filterTemplateSymbols ? "true" : "false");
#endif

     ROSE_ASSERT(templateParameterAndArgumentErrorChecking<ReturnType>(templateParameterList,templateArgumentList) == true);

  // Find the sublist that match the name.
     std::pair<hash_iterator, hash_iterator> range = p_table->equal_range(nm);
     std::pair<hash_iterator, hash_iterator> save_original_range = range;

  // First look through only the local (non-aliased) symbols.

     for (hash_iterator i = range.first; i != range.second; ++i)
        {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("Check for SgAliasSymbol in SgSymbolTable::find_symbol_with_type_support(const SgName & nm = %s) \n",nm.str());
#endif
          p_iterator = i;

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: p_iterator->second = %p = %s \n",nm.str(),p_iterator->second,p_iterator->second->class_name().c_str());
#endif

       // DQ (8/13/2013): Note that the effect of this is that if ReturnType == SgFunctionSymbol then symbol will be
       // valid for both SgFunctionSymbol and SgMemberFunctionSymbol.  However, since SgTemplateFunctionSymbol is derived
       // from SgFunctionSymbol and SgTemplateMemberFunctionSymbol is derived from SgMemberFunctionSymbol, the same is
       // not true for template function and template member function relationship.  A SgTemplateMemberFunctionSymbol
       // is NOT derived from a SgTemplateFunctionSymbol and thus a SgTemplateMemberFunctionSymbol dynamic_cast to a
       // SgTemplateFunctionSymbol will be a NULL pointer (where for non-templates is will be a valid pointer.
       // The solution is to always know if you want to find the class, function, or member functions symbol for
       // either a template or non-template.  Note that template instanitations are handled using SgFunctionSymbol
       // and SgMemberFunctionSymbols (since they are functions), however, they require template arguments to be
       // properly resolved.  Template declarations similarly require template parameters.  Since partial specialization
       // of functions and member functions is not allowed in C++, template functions and template member functions
       // don't use template arguments to there resolution.  Since template classes can be partially specialized, both
       // template parameters and template arguments are required for their resolution.
          ReturnType* symbol = dynamic_cast<ReturnType*>(p_iterator->second);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: (BEFORE symbolFilter) symbol = %p = %s \n",nm.str(),symbol,(symbol != NULL) ? symbol->class_name().c_str() : "null");
#endif
       // DQ (8/13/2013): Added function to filter out types of symbols that would be found from
       // a dynamic cast but which we are not interested in given the rules where template parameter
       // lists and template argument lists apply.
       // DQ (4/14/2017): Added explicit control to filter template symbols.
          symbol = symbolFilter<ReturnType>(symbol,templateParameterList,templateArgumentList,filterTemplateSymbols);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: (AFTER symbolFilter) symbol = %p = %s \n",nm.str(),symbol,(symbol != NULL) ? symbol->class_name().c_str() : "null");
#endif

       // DQ (8/21/2013): This is an additional filter that was not previously used (and copied from the
       // find_symbol_support() function).
       // DQ (6/24/2013): We catch the case of SgAliasSymbol in the tailing test of the symbol table,
       // there we properly resolve it to its base symbol.  When this template is instatiated using
       // SgSymbol we have to worry about this detail, else the initialization of symbol above can never
       // result in a SgAliasSymbol. So this is a result of writting very general code. Not sure how to
       // make this a compile-time test so that we could avoid the overhead of using this dynamic cast.
       // One performance alternative would be to have a specialization of this template for the general
       // case of SgSymbol, but that should be considered later when we are sure that this is the final
       // working implementation (so we will leave the code it is most re-factored state for now).
          if ( (symbol != NULL) && (symbol->variantT() == (VariantT)SgAliasSymbol::static_variant) )
             {
               symbol = NULL;
             }

          if ( (symbol != NULL) && ( (type == NULL) || ( (type != NULL) && (getTypeOfDeclaration(symbol) == type) ) ) )
             {
               p_name    = nm;
               p_no_name = false;
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In SgSymbolTable::find_symbol_with_type_support(): name = %s type = %p = %s symbol = %p = %s \n",nm.str(),type,(type != NULL) ? type->class_name().c_str() : "null",symbol,symbol->class_name().c_str());
#endif

            // DQ (8/7/2013): Added support for template function overloading using template parameters.
            // Note: We are handling the template arguments into the hasMatchingTemplateArgumentsOrNoTemplateArguments()
            // as template specialization arguments which may be incorrect.

            // DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based
            // on the arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is
            // being constructed).
               if (hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(templateParameterList,templateArgumentList,symbol) == true)
                  {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Found a match: return symbol = %p = %s nm = %s \n",symbol,symbol->class_name().c_str(),nm.str());
#endif
                 // DQ (8/8/2013): I think we should return the symbol rather than break.
                 // DQ (9/9/2012): We could either call "break" to get out of the loop, or directly "return s".
                    return symbol;
                  }
                 else
                  {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): The template arguments are NOT the same for symbol = %p = %s (keep searching) nm = %s \n",symbol,symbol->class_name().c_str(),nm.str());
#endif
                 // DQ (9/9/2012): If this is not a match, then we have to set s == NULL so that we will not accidentally returning the WRONG sysmbol at the end of the loop.
                    symbol = NULL;
                  }
             }
            else
             {
            // DQ (10/11/2008): Added support to find renamed functions (common in Fortran 90)
            // F90 permits interface statements to effectively rename functions is scope,
            // SgRenameSymbol IR nodes are used to represent the renamed functions.  This
            // renaming using an interface is different from the aliasing and combined renaming
            // that is possible within the "use" statement.
               if ( p_iterator->second->variantT() == V_SgRenameSymbol)
                  {
                    p_name    = nm;
                    p_no_name = false;
                    SgRenameSymbol* renameSymbol = isSgRenameSymbol(p_iterator->second);
                    ROSE_ASSERT(renameSymbol != NULL);

                 // DQ (10/11/2008): Moved SgRenameSymbol to be derived from SgFunctionSymbol.

                 // DQ (5/24/2013): This should have been expressed in terms of renameSymbol->get_original_symbol().
                    ReturnType* original_renamed_symbol = dynamic_cast<ReturnType*>(renameSymbol->get_original_symbol());
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Need filtering for SgRenameSymbol cases \n");
#endif
                    ROSE_ASSERT(original_renamed_symbol != NULL);
                    return original_renamed_symbol;
                  }
             }

       // p_iterator++;
        }

  // DQ (9/30/2008): If we have not found a symbol from the current scope, search for symbols
  // injected from other scopes using the Fortran "use" statment (or in a future implementation
  // the C++ "using" directive or "using" declaration).

  // Reset the range so we can look for SgAliasSymbols.
     range = save_original_range;

  // Iterate through the list that match the name to find the one that is a SgTemplateSymbol and has a matching SgType pointer.
     for (hash_iterator i = range.first; i != range.second; ++i)
        {
          p_iterator = i;

          SgAliasSymbol* aliasedSymbol = isSgAliasSymbol(p_iterator->second);
          if (aliasedSymbol != NULL)
             {
            // DQ (10/9/2008): Resolve the last link in any chain of alias symbols
               ReturnType* original_aliased_symbol = dynamic_cast<ReturnType*>(aliasedSymbol->get_base());

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In loop over target ALIASED symbols associated with nm = %s (BEFORE symbolFilter) original_aliased_symbol = %p = %s \n",nm.str(),original_aliased_symbol,(original_aliased_symbol != NULL) ? original_aliased_symbol->class_name().c_str() : "null");
#endif
            // DQ (8/13/2013): Added function to filter out types of symbols that would be found from
            // a dynamic cast but which we are not interested in given the rules where template parameter
            // lists and template argument lists apply.
            // DQ (4/14/2017): Added explicit control to filter template symbols.
               original_aliased_symbol = symbolFilter<ReturnType>(original_aliased_symbol,templateParameterList,templateArgumentList,filterTemplateSymbols);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In loop over target ALIASED symbols associated with nm = %s (AFTER symbolFilter) original_aliased_symbol = %p = %s \n",nm.str(),original_aliased_symbol,(original_aliased_symbol != NULL) ? original_aliased_symbol->class_name().c_str() : "null");
#endif

            // Liao 9/15/2016
            // Allow template function type match. They may have arguments of template types
            SgFunctionType* f1 = NULL;
            if (original_aliased_symbol != NULL && isSgFunctionSymbol(original_aliased_symbol))
              f1= isSgFunctionType(isSgFunctionSymbol(original_aliased_symbol)->get_declaration()->get_type());
            SgFunctionType* f2 = NULL;
            if (type != NULL)
              f2 = isSgFunctionType (const_cast <SgType*> (type));

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
            mprintf ("In loop over target ALIASED symbols associated with nm = %s compare types = %p and %p \n",nm.str(),f1, f2);
#endif

            bool equavilentFunctionType= ( (f1!= NULL && f2!= NULL) && (SageInterface::isEquivalentFunctionType(f1, f2)) );

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
            mprintf ("  -- equavilentFunctionType = %s\n", equavilentFunctionType ? "true" : "false");
#endif

               if ( (original_aliased_symbol != NULL) && ( (type == NULL) || ((type != NULL) && (getTypeOfDeclaration(original_aliased_symbol) == type || equavilentFunctionType)) ) )
                  {
                    p_name    = nm;
                    p_no_name = false;

                 // DQ (8/7/2013): Added support for template function overloading using template parameters.
                 // DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based
                 // on the arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is
                 // being constructed).
                    if (hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(templateParameterList,templateArgumentList,original_aliased_symbol) == true)
                       {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Found a match: return original_aliased_symbol = %p = %s nm = %s \n",original_aliased_symbol,original_aliased_symbol->class_name().c_str(),nm.str());
#endif
                      // DQ (8/8/2013): I think we should return the symbol rather than break.
                      // DQ (9/9/2012): We could either call "break" to get out of the loop, or directly "return s".
                      // break;

                      // DQ (7/12/2014): To support better symbol handling for name qualification. At this point were
                      // we have identified the target aliased symbol, we need to check if the associated reason for
                      // it being an alias symbol has been seen in the AST yet.  The cause for the alias symbol is a
                      // causal node that is stored in the SgAliasSymbol (new modification to SgAliasSymbol).  The list
                      // of possible causal nodes for alias symbols to be inserted is held in a static member of the
                      // SgSymbolTable (new modification to SgSymbolTable).

                         bool foundCausalNode = isSubset(aliasedSymbol->get_causal_nodes(),get_aliasSymbolCausalNodeSet());
                         if (foundCausalNode == true)
                            {
                           // DQ (1/23/2019): I think that this support is specific to the references to a symbol before
                           // a using directive that would make is visible vs after the using directive.  Unfortunately it
                           // is not sufficent to support when a class is derivied from another class and private derivation
                           // would cause alis symbols to be seen or not seen in the subsequent coass derivations (see
                           // Cxx_tests/test2019_21.C).
                           // NOTE: the set defined by get_aliasSymbolCausalNodeSet() is only maintained in the name qualification
                           // support and so it is useless within the
                           // FixupAstSymbolTablesToSupportAliasedSymbols::injectSymbolsFromReferencedScopeIntoCurrentScope()
                           // function.  So to fix this we have added to code in this function to insert the causal nodes into
                           // the required set.  It might be that this set should be cleared before starting the namequalification
                           // phase.

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                              mprintf ("Found causal node for SgAliasSymbol: aliasedSymbol = %p = %s original_aliased_symbol = %p = %s \n",
                                   aliasedSymbol,aliasedSymbol->class_name().c_str(),original_aliased_symbol,original_aliased_symbol->class_name().c_str());
                              ROSE_ASSERT(aliasedSymbol->get_alias() != NULL);
                              mprintf (" --- aliasedSymbol = %p aliasedSymbol->get_alias() = %p = %s \n",aliasedSymbol,aliasedSymbol->get_alias(),aliasedSymbol->get_alias()->class_name().c_str());
                              mprintf (" --- aliasedSymbol->get_causal_nodes().size() = %" PRIuPTR " \n",aliasedSymbol->get_causal_nodes().size());
                              mprintf (" --- get_aliasSymbolCausalNodeSet().size()    = %" PRIuPTR " \n",get_aliasSymbolCausalNodeSet().size());
#endif
                              return original_aliased_symbol;
                            }
                           else
                            {
                           // DQ (7/12/2014): If we didn't find the causal node then we can't consider the alias to exist
                           // yet in the traversal of the AST represented by the symbol table query at this point.
                              original_aliased_symbol = NULL;

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                              mprintf ("associated causal nodes not seen yet in traversal of AST: \n");
                              ROSE_ASSERT(aliasedSymbol->get_alias() != NULL);
                              mprintf (" --- aliasedSymbol = %p aliasedSymbol->get_alias() = %p = %s \n",aliasedSymbol,aliasedSymbol->get_alias(),aliasedSymbol->get_alias()->class_name().c_str());
                              mprintf (" --- aliasedSymbol->get_causal_nodes().size() = %zu \n",aliasedSymbol->get_causal_nodes().size());
                              mprintf (" --- get_aliasSymbolCausalNodeSet().size()    = %zu \n",get_aliasSymbolCausalNodeSet().size());
                              for (std::vector<SgNode*>::iterator i = aliasedSymbol->get_causal_nodes().begin(); i != aliasedSymbol->get_causal_nodes().end(); i++)
                                 {
                                   mprintf ("   --- causal node = %p = %s \n",*i,(*i)->class_name().c_str());
                                 }
#endif
                            }
                       }
                      else
                       {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::find_symbol_with_type_support(): The template arguments are NOT the same for original_aliased_symbol = %p = %s (keep searching) nm = %s \n",original_aliased_symbol,original_aliased_symbol->class_name().c_str(),nm.str());
#endif
                      // DQ (9/9/2012): If this is not a match, then we have to set s == NULL so that we will not accidentally returning the WRONG sysmbol at the end of the loop.
                         original_aliased_symbol = NULL;
                       }
                  }
             }
        }

     if (this->get_force_search_of_base_classes() == true)
        {
       // DQ (3/28/2014): If we reach this point, then in the case of Java, we have to search the
       // base class definitions (since the representation of Java base class does not presently
       // inject the base class symbols into the derived class symbol table.  There are pros and
       // const to this design.  But this function will at least make the API semantics that same.
          SgNode* parentNode = this->get_parent();
          ROSE_ASSERT(parentNode != NULL);
          SgClassDefinition* classDefinition = isSgClassDefinition(parentNode);
          if (classDefinition != NULL)
             {
               SgBaseClassPtrList & base_classes = classDefinition->get_inheritances();

               SgBaseClassPtrList::iterator i = base_classes.begin();
               while (i != base_classes.end())
                  {
                    SgBaseClass* baseClass = *i;
                    ROSE_ASSERT(baseClass != NULL);
                    SgClassDeclaration* baseClassDeclaration = baseClass->get_base_class();
                    ROSE_ASSERT(baseClassDeclaration != NULL);
                    SgClassDeclaration* baseClassDeclaration_defining = isSgClassDeclaration(baseClassDeclaration->get_definingDeclaration());

                 // DQ: Note that we have to implement conditional lookup based on base class permissions, plus the access permissions of base class members.
                    if (baseClassDeclaration_defining != NULL)
                       {
                         SgClassDefinition* baseClassDefinition = baseClassDeclaration_defining->get_definition();
                         ROSE_ASSERT(baseClassDefinition != NULL);

                         ROSE_ASSERT(baseClassDefinition->get_symbol_table() != NULL);

                      // DQ (4/14/2017): Added explicit support to filter symbols associated with templates.
                      // Make a recursive call on the symbol table associated with the base class.
                         ReturnType* symbol = baseClassDefinition->get_symbol_table()->find_symbol_with_type_support<ReturnType>(nm,type,templateParameterList,templateArgumentList,filterTemplateSymbols);
                         if (symbol != NULL)
                            {
                              return symbol;
                            }
                       }

                    i++;
                  }
             }
        }

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any();
      SgVariableSymbol*  find_variable();
      SgClassSymbol*     find_class();
      SgFunctionSymbol*  find_function();
      SgFunctionSymbol*  find_function_type();
      SgTypedefSymbol*   find_typedef();
      SgEnumSymbol*      find_enum();
      SgEnumFieldSymbol* find_enum_field();
      SgLabelSymbol*     find_label();
      SgNamespaceSymbol* find_namespace();
*/

SgSymbol*
SgSymbolTable::find_any()
   {
     ROSE_ASSERT(p_table != NULL);
     p_iterator = p_table->begin();
     p_no_name  = true;
     if(p_iterator != p_table->end())
          return (SgSymbol *) p_iterator->second;

     return NULL;
   }

SgVariableSymbol*
SgSymbolTable::find_variable()
   {
     ROSE_ASSERT(p_table != NULL);

     p_iterator = p_table->begin();
     p_no_name  = true;
     while(p_iterator != p_table->end())
        {
          if (p_iterator->second->variantT() == V_SgVariableSymbol)
               return (SgVariableSymbol *) p_iterator->second;
          p_iterator++;
        }

     return NULL;
   }

SgClassSymbol*
SgSymbolTable::find_class()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
               if (p_iterator->second->variantT() == V_SgClassSymbol)
                    return (SgClassSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgFunctionSymbol*
SgSymbolTable::find_function()
   {
     ROSE_ASSERT(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while(p_iterator != p_table->end())
             {
            // if(isSgFunctionSymbol((*p_iterator).second))
            //      return ((SgFunctionSymbol *)(*p_iterator).second);

            // DQ (8/3/2022): I think this needs to support the variant being either a V_SgFunctionSymbol or a V_SgMemberFunctionSymbol.
            // Else we would need another function to support member functions (which might be the better solution).
            // Better yet, this code should be using a consistant way to check for SgFunctionSymbol IR nodes as is done in
            // the next_function_symbol() function.
            // if (p_iterator->second->variantT() == V_SgFunctionSymbol)
            //      return (SgFunctionSymbol *) p_iterator->second;
            // if (p_iterator->second->variantT() == V_SgFunctionSymbol || p_iterator->second->variantT() == V_SgMemberFunctionSymbol)
               if (isSgFunctionSymbol((*p_iterator).second))
                    return (SgFunctionSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgTypedefSymbol*
SgSymbolTable::find_typedef()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgTypedefSymbol((*p_iterator).second))
            //      return ((SgTypedefSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTypedefSymbol)
                    return (SgTypedefSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumSymbol*
SgSymbolTable::find_enum()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgEnumSymbol((*p_iterator).second))
            //      return ((SgEnumSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumSymbol)
                    return (SgEnumSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumFieldSymbol*
SgSymbolTable::find_enum_field()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second))
            //      return ((SgEnumFieldSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumFieldSymbol)
                    return (SgEnumFieldSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::find_label()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgLabelSymbol((*p_iterator).second))
            //      return ((SgLabelSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgLabelSymbol)
                    return (SgLabelSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::find_namespace()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgNamespaceSymbol((*p_iterator).second))
            //      return ((SgNamespaceSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgNamespaceSymbol)
                    return (SgNamespaceSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template()
   {
     ROSE_ASSERT(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end())
             {
            // if (isSgTemplateSymbol((*p_iterator).second))
            //      return ((SgTemplateSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTemplateSymbol)
                    return (SgTemplateSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          next_any();
      SgVariableSymbol*  next_variable();
      SgClassSymbol*     next_class();
      SgFunctionSymbol*  next_function();
      SgTypedefSymbol*   next_typedef();
      SgEnumSymbol*      next_enum();
      SgEnumFieldSymbol* next_enum_field();
      SgLabelSymbol*     next_label();
      SgNamespaceSymbol* next_namespace();
*/

SgSymbol*
SgSymbolTable::next_any()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() )
             {
               if( p_no_name || get_table()->key_eq()((*p_iterator).first,p_name) )
                    return (SgSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return nullptr;
   }

SgVariableSymbol*
SgSymbolTable::next_variable()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgVariableSymbol((*p_iterator).second))
                    return ((SgVariableSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgClassSymbol*
SgSymbolTable::next_class()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++; // go to next one

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgClassSymbol((*p_iterator).second))
                    return ((SgClassSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgFunctionSymbol*
SgSymbolTable::next_function()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgFunctionSymbol((*p_iterator).second))
                    return ((SgFunctionSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgTypedefSymbol*
SgSymbolTable::next_typedef()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgTypedefSymbol((*p_iterator).second))
                    return ((SgTypedefSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }


SgEnumSymbol*
SgSymbolTable::next_enum()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgEnumSymbol((*p_iterator).second))
                    return ((SgEnumSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgEnumFieldSymbol*
SgSymbolTable::next_enum_field()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if(isSgEnumFieldSymbol((*p_iterator).second))
                    return ((SgEnumFieldSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::next_label()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgLabelSymbol((*p_iterator).second))
                    return ((SgLabelSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgNamespaceSymbol*
SgSymbolTable::next_namespace()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgNamespaceSymbol((*p_iterator).second))
                    return ((SgNamespaceSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

SgTemplateSymbol*
SgSymbolTable::next_template()
   {
     ASSERT_not_null(p_table);
     if (p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgTemplateSymbol((*p_iterator).second))
                    return ((SgTemplateSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return nullptr;
   }

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::size() const
   {
     ASSERT_not_null(p_table);
     return p_table->size();
   }

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::count(const SgName & nm) const
   {
     ASSERT_not_null(p_table);
     return p_table->count(nm);
   }

int
SgSymbolTable::count_aliases(const SgName & nm) const
   {
     ASSERT_not_null(p_table);

  // This is the fastest way (that I know of) to iterate over just those entries that match the key.
     std::pair<hash_iterator,hash_iterator> range = p_table->equal_range(nm);

     hash_iterator start = range.first;
     hash_iterator last  = range.second;

     int count = 0;
     hash_iterator i = start;
     while (i != last)
        {
       // Count only the alias symbols.
           if (isSgAliasSymbol((*i).second) != NULL)
               count++;

          i++;
        }

     return count;
   }

void
SgSymbolTable::print() // Liao 5/5/2011. Added this to support calling this from gdb
  {
    print ("default settings", V_SgSymbol);
  }

void
SgSymbolTable::print( std::string label, VariantT nodeType )
   {
     printf ("Printing out the data within the symbol table (p_table = %p,label = %s size = %d): \n",p_table,label.c_str(),size());
     printf ("Internal static data: p_no_name: %s p_name = %s \n",(p_no_name == true) ? "true" : "false",p_name.str());

     SgNode* parentNode = get_parent();
     ASSERT_not_null(parentNode);
     printf ("Symbol table has parent = %p = %s \n",parentNode,parentNode->class_name().c_str());

     ASSERT_not_null(p_table);
     if (p_table)
        {
          hash_iterator i = p_table->begin();

          int idx = 0;
          while (i != p_table->end())
             {
               ASSERT_not_null ( isSgSymbol( (*i).second ) );

               SgSymbol* symbol = isSgSymbol((*i).second);
               ASSERT_not_null(symbol);
               SgType* type = symbol->get_type();

               SgNamedType* namedType = isSgNamedType(type);
               SgName nameOfType;
               if (namedType != NULL)
                  {
                    nameOfType = namedType->get_name();
                  }
                 else
                  {
                    if (type != nullptr)
                       {
                         nameOfType = type->sage_class_name();
                       }
                      else
                       {
                         switch(symbol->variantT())
                            {
                              case V_SgNamespaceSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgNamespaceSymbol)";
                                   break;
                                 }

                              case V_SgTemplateSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgTemplateSymbol)";
                                   break;
                                 }

                              default:
                                 {
                                // This is likely an error, I think
                                   nameOfType = "unknown type name (likely a possible error!)";
                                   break;
                                 }
                            }
                       }
                  }

               bool outputSymbolInfo = (nodeType == V_SgSymbol) || (symbol->variantT() == nodeType);

            // Output of symbol information
               SgNode* symbolBasis = i->second->get_symbol_basis();
               if (symbolBasis != NULL)
                  {
                    ROSE_ASSERT(symbolBasis != NULL);

                    if (outputSymbolInfo == true)
                       {
                         SgAliasSymbol* aliasSymbol = isSgAliasSymbol((*i).second);
                         if (aliasSymbol != NULL)
                            {
                              ROSE_ASSERT(aliasSymbol->get_alias() != NULL);

                              printf ("Symbol %4d: name = %s SgSymbol = %p = %s (alias to %s) type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                                   idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),aliasSymbol->get_alias()->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                                   nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());

                           // DQ (12/24/2020): I want to add the details of the causal nodes.
                              printf (" --- alias node details: causal_nodes.size() = %zu \n",aliasSymbol->get_causal_nodes().size());
                              SgNodePtrList & causal_nodes_list = aliasSymbol->get_causal_nodes();
                              SgNodePtrList::iterator j = causal_nodes_list.begin();
                              while (j != causal_nodes_list.end())
                                 {
                                   SgNode* causal_node = *j;
                                   ROSE_ASSERT(causal_node != NULL);
                                   printf (" --- causal node = %p = %s \n",causal_node,causal_node->class_name().c_str());
                                   SgBaseClass* baseClass = isSgBaseClass(causal_node);
                                   if (baseClass != NULL)
                                      {
                                        SgClassDeclaration* baseClassDeclaration = baseClass->get_base_class();
                                        ROSE_ASSERT(baseClassDeclaration != NULL);
                                        printf (" --- --- baseClass = %p baseClassDeclaration = %p name = %s \n",baseClass,baseClassDeclaration,baseClassDeclaration->get_name().str());
                                      }
                                   j++;
                                 }
                            }
                           else
                            {
                              printf ("Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                                   idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                                   nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());
                            }
                       }
                  }
                 else
                  {
                    if (outputSymbolInfo == true)
                       {
                         printf ("Warning Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = NULL \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str());
                       }
                  }

            // DQ (12/3/2011): Refactored code.
               SgSymbol* symbolFromTable = (*i).second;
               SgName mangledName = symbolFromTable->get_mangled_name();

               if (outputSymbolInfo == true)
                  {
                    printf ("   Symbol's associated mangled name = %s \n",mangledName.str());

                 // This is useful for the output of the function types when the global function type symbol table is output.
                 // handle case of function symbol (unparse the funtion type)
                    SgFunctionTypeSymbol *f = isSgFunctionTypeSymbol((*i).second);
                    if (f != NULL)
                       {
                         std::cout << "     function: " << f->get_type()->unparseToString() << endl;
                       }
                  }

            // Increment the symbol table's symbol iterator
               i++;

            // Increment the symbol counter (used for output)
               idx++;
             }
        }
       else
        {
       // DQ (6/27/2005): I think this is an error (we should always have a valid symbol table)
          printf ("Pointer to symbol table is NULL \n");
          ROSE_ASSERT(false);
        }
   }


set<SgNode*>
SgSymbolTable::get_symbols() const
   {
  // DQ (2/15/2007): generate a set of SgNode* so that we can use them for set difference against the delete list in AST merge.
     set<SgNode*> returnSet;

     ROSE_ASSERT(p_table != NULL);
     rose_hash_multimap::iterator i = get_table()->begin();

     while (i != p_table->end())
        {
          ROSE_ASSERT(i->second != NULL);
          returnSet.insert(i->second);

          i++;
        }

     return returnSet;
   }


size_t
SgSymbolTable::maxCollisions()
   {
     ROSE_ASSERT(p_table != NULL);

     unsigned nbuckets = p_table->bucket_count();
     size_t maxColl = 0;
     for (unsigned i = 0; i < nbuckets; ++i)
        {
          if(p_table->bucket_size(i)>maxColl)
               maxColl = p_table->bucket_size(i);
        }

     return maxColl;
   }

// DQ (3/30/2014): Declaration of space for static data member.
bool SgSymbolTable::p_force_search_of_base_classes = false;

// DQ (7/12/2014): Declaration of space for static data member.
SgNodeSet SgSymbolTable::p_aliasSymbolCausalNodeSet;

bool
SgSymbolTable::get_force_search_of_base_classes()
   {
     return p_force_search_of_base_classes;
   }

void
SgSymbolTable::set_force_search_of_base_classes( bool value )
   {
     p_force_search_of_base_classes = value;
   }

// DQ (7/12/2014): Access function for static data member.
SgNodeSet &
SgSymbolTable::get_aliasSymbolCausalNodeSet()
   {
     return p_aliasSymbolCausalNodeSet;
   }


// DQ (8/3/2019): Display function for static data member.
void
SgSymbolTable::display_aliasSymbolCausalNodeSet()
   {
     SgNodeSet::iterator i = p_aliasSymbolCausalNodeSet.begin();
     while (i != p_aliasSymbolCausalNodeSet.end())
        {
          printf ("SgSymbolTable::p_aliasSymbolCausalNodeSet: *i = %p = %s \n",*i,(*i)->class_name().c_str());

          i++;
        }
   }




SOURCE_SYMBOL_TABLE_END


SOURCE_BASECLASS_START

void
SgBaseClass::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // DQ (4/25/2004): Note that because of limitiations in the ordering of output
  // class declarations in ROSETTA, I was unable make this SgBaseClassModifier a
  // data member and was forced to handle it as a pointer).
     p_baseClassModifier = new SgBaseClassModifier();
     ROSE_ASSERT ( p_baseClassModifier != NULL);

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;
   }

SgBaseClass::SgBaseClass(const SgBaseClass& X)
   {
  // these are the old names
  // p_specifier = ptr.p_specifier;
  // p_ptr       = ptr.p_ptr;
  // p_base_specifier = X.p_base_specifier;
     p_base_class     = X.p_base_class;

  // DQ (6/21/2005): Commented out since it is not used, we might want it later!
  // DQ: initialize all values
     p_isDirectBaseClass = 0;

     ROSE_ASSERT ( X.p_baseClassModifier != NULL);
     p_baseClassModifier = new SgBaseClassModifier( *(X.p_baseClassModifier) );
     ROSE_ASSERT ( p_baseClassModifier != NULL);

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;
   }

SgBaseClass &
SgBaseClass::operator= (const SgBaseClass & X)
   {
  // Old names
  // p_specifier = ptr.p_specifier;
  // p_direct    = ptr.p_direct;
  // p_ptr       = ptr.p_ptr;

  // p_base_specifier     = X.p_base_specifier;
     p_base_class         = X.p_base_class;

  // DQ (6/21/2005): Renamed to make this more clear
     p_isDirectBaseClass  = X.p_isDirectBaseClass;

     ROSE_ASSERT (p_baseClassModifier   != NULL);
     ROSE_ASSERT (X.p_baseClassModifier != NULL);
     *p_baseClassModifier = *X.p_baseClassModifier;

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;

     return *this;
   }

// I assume these relational member functions are added to permit use with STL
bool
SgBaseClass::operator== (const SgBaseClass& ) const
   { return false; }

bool
SgBaseClass::operator< (const SgBaseClass&) const
   { return false; }

SgName
SgBaseClass::get_qualified_name_prefix() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgBaseClass
  //    SgTemplateArgument

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgBaseClass*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
       // mprintf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
        }

  // mprintf ("nameQualifier for SgBaseClass = %s = %s \n",class_name().c_str(),nameQualifier.str());

     return nameQualifier;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgBaseClass::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgBaseClass::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgBaseClass::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgBaseClass::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgBaseClass::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgBaseClass::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }


SOURCE_BASECLASS_END

SOURCE_EXP_BASE_CLASS_START
void
SgExpBaseClass::post_construction_initialization()
   {
   }
SOURCE_EXP_BASE_CLASS_END

SOURCE_NONREAL_BASE_CLASS_START
void
SgNonrealBaseClass::post_construction_initialization()
   {
   }
SOURCE_NONREAL_BASE_CLASS_END

SOURCE_X_INITIALIZED_NAME_START

// Include this code only if we are building a derived grammar (not a root grammar)
$CLASSNAME::$CLASSNAME
   ( const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgX_DeclarationStatement *declptr )
   //   SgInitializedName *itemptr,
   //  SgInitializedName *prev_itemptr )
   : p_name(name), p_typeptr(typeptr), p_initptr(iptr),
     p_is_initializer(1), p_declptr(NULL), p_X_declptr(declptr),
     p_prev_decl_item(prev_itemptr)
   {}

void
$CLASSNAME::set_X_declaration(SgX_DeclarationStatement * decl)
   { p_X_declptr = decl; }

SOURCE_X_INITIALIZED_NAME_END


SOURCE_INITIALIZED_NAME_START

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgInitializedName::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

#define DEBUG__SgInitializedName__search_for_symbol_from_symbol_table 0

// PC (10/1/2009): Added support to get the symbol from the correct associated declaration
SgSymbol*
SgInitializedName::search_for_symbol_from_symbol_table() const
   {
#if DEBUG__SgInitializedName__search_for_symbol_from_symbol_table
     printf("In SgInitializedName::search_for_symbol_from_symbol_table():\n");
     printf("  this = %p : %s\n", this, this->class_name().c_str());
#endif
     SgInitializedName* aPrevDeclItem = p_prev_decl_item;
     while(aPrevDeclItem != NULL && aPrevDeclItem->p_prev_decl_item != NULL) {
       // looks for self loop, should we have a more complex check (using a set of seen nodes)?
       ROSE_ASSERT(aPrevDeclItem->p_prev_decl_item != aPrevDeclItem);
       aPrevDeclItem = aPrevDeclItem->p_prev_decl_item;
     }

     SgSymbol* symbol = nullptr;
     if (aPrevDeclItem != nullptr) {
       symbol = aPrevDeclItem->get_symbol_from_symbol_table();
     } else {
       symbol = get_symbol_from_symbol_table();
     }

#if DEBUG__SgInitializedName__search_for_symbol_from_symbol_table
     printf("  symbol = %p : %s\n", symbol, symbol->class_name().c_str());
#endif
     return symbol;
   }

// DQ (10/13/2014): Adding a default constructor for compatability with what was previously the API before the newer aterm support.
SgInitializedName::SgInitializedName() ROSE_DEPRECATED_FUNCTION
   : p_name(""),
     p_microsoft_uuid_string(""),
     p_typeptr(NULL),
     p_initptr(NULL),
     p_prev_decl_item(NULL),
     p_is_initializer(true),
     p_declptr(NULL),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
  // This constructor has been added to support the previous API, I would like to depricate it.
   }

SgStorageModifier &
SgInitializedName::get_storageModifier()
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

const SgStorageModifier &
SgInitializedName::get_storageModifier() const
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

SgName
SgInitializedName::get_qualified_name() const
   {
  // DQ (8/22/2005): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // mprintf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     assert(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // mprintf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }


SgName
SgInitializedName::get_qualified_name_prefix() const
   {
  // DQ (12/16/2013): Added support for name qualification on SgInitializedName for use in preinitialization lists.

     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgInitializedName*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
#if 0
          mprintf ("In SgInitializedName::get_qualified_name_prefix(): Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }

#if 0
     mprintf ("In SgInitializedName::get_qualified_name_prefix(): nameQualifier for SgInitializedName = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }


SgName
SgInitializedName::get_qualified_name_prefix_for_type() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgInitializedName*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
          mprintf ("SgInitializedName::get_qualified_name_prefix_for_type(): Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }

#if 0
     mprintf ("SgInitializedName::get_qualified_name_prefix_for_type(): nameQualifier for SgInitializedName = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }


void
SgInitializedName::post_construction_initialization()
   {
  // Liao 11/5/2010, for debugging purpose
  // if (p_name.getString() == string("a0"))
  //      abort();
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_storageModifier = new SgStorageModifier();
     assert (p_storageModifier != NULL);
     p_storageModifier->setDefault();

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism = NULL;

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope = NULL;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
          p_initptr->set_parent(this);
        }

  // DQ (1/3/2009): Added support for GNU variable attributes (std::strings will default to null, so they are not setup).
     p_gnu_attribute_modifierVector          = SgBitVector(e_last_gnu_variable_attribute,false);
     p_gnu_attribute_initialization_priority = 0;

  // DQ (3/1/2013): Changed default value to -1 and type to signed short so that we could reserve negative values to be a marked for not explicitly specified.
     p_gnu_attribute_alignment               = -1;

  // Borrow the enum definition (and default value from SgDeclarationModifier).
     p_gnu_attribute_visability              = SgDeclarationModifier::e_unknown_visibility;

  // FMZ added for coarray
     p_isCoArray = false;

  // DQ (10/26/2010): These were not properly initialized.
     p_shapeDeferred          = false;
     p_initializationDeferred = false;
     p_protected_declaration  = false;

  // DQ (2/5/2014): I just noticed that the initialization of these were missing.
     p_name_qualification_length_for_type = 0;
     p_type_elaboration_required_for_type = false;
     p_global_qualification_required_for_type = false;

  // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
     p_hasArrayTypeWithEmptyBracketSyntax = false;

  // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
     p_using_C11_Alignas_keyword                     = false;
     p_constant_or_type_argument_for_Alignas_keyword = NULL;

  // DQ (8/2/2014): Adding support for C++11 auto keyword.
     p_using_auto_keyword = false;
     p_auto_decltype = NULL;

  // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
     p_using_device_keyword = false;

  // DQ (6/10/2012): Testing for test2012_102.C.
  // mprintf ("In SgInitializedName::post_construction_initialization(): this = %p \n",this);
   }

// This constructor is specific to the creation of SgInitializedName objects used as initializers
SgInitializedName::SgInitializedName (
  const SgName& name, SgType *typeptr, SgInitializer* iptr,
  SgDeclarationStatement *declptr,
  SgInitializedName *prev_itemptr
) ROSE_DEPRECATED_FUNCTION :
     p_name(name),
     p_microsoft_uuid_string(""),
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName(
  Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr
) :
     p_name(name),
     p_microsoft_uuid_string(""),
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(scope),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
     p_startOfConstruct = fileInfo;
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName (const SgInitializedName& ptr)
   {
     p_name           = ptr.p_name;

     p_typeptr        = ptr.p_typeptr;
     p_initptr        = ptr.p_initptr;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
          mprintf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in copy constructor) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // p_prev_itemptr   = ptr.p_prev_itemptr;
     p_is_initializer = ptr.p_is_initializer;
     p_declptr        = ptr.p_declptr;
  // p_itemptr        = ptr.p_itemptr;

  // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
  // p_fileInfo       = ptr.p_fileInfo;
  // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;

  // DQ (12/17/2006): See if we can enforce this!
  // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
     assert(ptr.p_startOfConstruct != NULL);
     p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
     assert(p_startOfConstruct != NULL);

  // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
     p_startOfConstruct->set_parent(this);

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope          = ptr.p_scope;

  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization = ptr.p_preinitialization;

  // DQ (4/28/2004): Added storage modifier support (replacing the old interface)
     assert (ptr.p_storageModifier != NULL);
     p_storageModifier = new SgStorageModifier ( *(ptr.p_storageModifier) );
     assert (p_storageModifier != NULL);

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
     p_attributeMechanism = NULL;

  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code = SgInitializedName::e_invalid_register;

  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
  // Note: don't copy the register string (I think this is best, but it is debatable)
     p_register_name_string = "";

  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

  // DQ (1/3/2009): Added support for GNU variable attribues
     p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
     p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
     p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
     p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
     p_isCoArray                             = ptr.p_isCoArray;

  // DQ (10/26/2010): Previously uninitialized data members.
     p_shapeDeferred          = ptr.p_shapeDeferred;
     p_initializationDeferred = ptr.p_initializationDeferred;
     p_protected_declaration  = ptr.p_protected_declaration;

  // DQ (2/5/2014): I just noticed that the initialization of these were missing.
     p_name_qualification_length_for_type     = ptr.p_name_qualification_length_for_type;
     p_type_elaboration_required_for_type     = ptr.p_type_elaboration_required_for_type;
     p_global_qualification_required_for_type = ptr.p_global_qualification_required_for_type;


  // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
     p_hasArrayTypeWithEmptyBracketSyntax     = ptr.p_hasArrayTypeWithEmptyBracketSyntax;

  // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
     p_using_C11_Alignas_keyword                     = ptr.p_using_C11_Alignas_keyword;
     p_constant_or_type_argument_for_Alignas_keyword = ptr.p_constant_or_type_argument_for_Alignas_keyword;

  // DQ (8/2/2014): Adding support for C++11 auto keyword.
     p_using_auto_keyword                     = ptr.p_using_auto_keyword;
     p_auto_decltype                          = ptr.p_auto_decltype;

  // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
     p_using_device_keyword                   = ptr.p_using_device_keyword;
   }

SgInitializedName&
SgInitializedName::operator= (const SgInitializedName& ptr)
   {
     assert(this != NULL);

  /* check they are not the same name */
     if (this != &ptr)
        {
          p_name = ptr.p_name;

          p_typeptr        = ptr.p_typeptr;
          p_initptr        = ptr.p_initptr;

       // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
          if (p_initptr != NULL)
             {
            // DQ (12/22/2006): Interestingly, the inliner is dependent upon this working this way!  We should maybe look into this later.
               p_initptr->set_parent(this);
               assert(p_initptr->get_parent() != NULL);
             }

          p_is_initializer = ptr.p_is_initializer;
          p_declptr        = ptr.p_declptr;

       // DQ (6/23/2006): Added assertion to detect errors
          assert(ptr.p_startOfConstruct != NULL);
          p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
          assert(p_startOfConstruct != NULL);

       // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
          p_startOfConstruct->set_parent(this);

       // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
          p_scope          = ptr.p_scope;

       // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
          p_preinitialization = ptr.p_preinitialization;

          assert (p_storageModifier != NULL);
          *p_storageModifier = *(ptr.p_storageModifier);

       // DQ (4/10/2006): Removed in favor of implementation at SgNode using
       // a pointer and the interface represented directly at the SgNode
       // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
          p_attributeMechanism = NULL;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_code = ptr.p_register_name_code;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_string = ptr.p_register_name_string;

       // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
          p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

       // DQ (1/3/2009): Added support for GNU variable attribues
          p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
          p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
          p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
          p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
          p_isCoArray                             = ptr.p_isCoArray;

       // DQ (2/5/2014): I just noticed that the initialization of these were missing.
          p_name_qualification_length_for_type     = ptr.p_name_qualification_length_for_type;
          p_type_elaboration_required_for_type     = ptr.p_type_elaboration_required_for_type;
          p_global_qualification_required_for_type = ptr.p_global_qualification_required_for_type;

       // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
          p_hasArrayTypeWithEmptyBracketSyntax = ptr.p_hasArrayTypeWithEmptyBracketSyntax;

       // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
          p_using_C11_Alignas_keyword                     = ptr.p_using_C11_Alignas_keyword;
          p_constant_or_type_argument_for_Alignas_keyword = ptr.p_constant_or_type_argument_for_Alignas_keyword;

       // DQ (8/2/2014): Adding support for C++11 auto keyword.
          p_using_auto_keyword                     = ptr.p_using_auto_keyword;

       // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
          p_using_device_keyword                   = ptr.p_using_device_keyword;
        }
       else
        {
       // DQ (6/23/2006): Added debugging message to track this issue.
          mprintf ("SgInitializedName::operator=(): Attempt to copy self to self \n");
        }

     assert(p_startOfConstruct != NULL);

     return *this;
   }

bool
SgInitializedName::operator== (const SgInitializedName& ) const
   { return false; }

bool
SgInitializedName::operator< (const SgInitializedName&) const
   { return false; }

SgType*
SgInitializedName::get_type() const
   {
     ASSERT_not_null(this);
     return p_typeptr;
   }

void
SgInitializedName::set_type(SgType *t)
   {
     assert(this != NULL);

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     p_typeptr = t;
   }

SgInitializer*
SgInitializedName::get_initializer() const
   {
     ASSERT_not_null(this);
     if (p_is_initializer)
          return p_initptr;
       else
          return nullptr;
   }

void
SgInitializedName::set_initializer(SgInitializer* i)
   {
     ASSERT_not_null(this);

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     p_initptr        = i;
     p_is_initializer = 1;
   }


// DQ (3/31/2006): New version from Rich (fixes bug where empty mangled name was generated)
SgName
SgInitializedName::get_mangled_name (void) const
   {
     SgName mangled_name; // return value

  // Case 1: Function parameters.
  // Generate names for parameters such that
  //   int foo (int x, int y) { return x + y; }
  //   int foo (int, int);
  //   int foo (int a, int b);
  // all generate the same unique names for equivalent parameters.
     const SgFunctionParameterList* func_params = isSgFunctionParameterList (get_declaration ());
     if (func_params)
        {
       // Find position (parameter number) in parameter list
          const SgInitializedNamePtrList& func_args = func_params->get_args ();
          SgInitializedNamePtrList::const_iterator i;
          size_t param_num = 0;
          for (i = func_args.begin (); i != func_args.end () && *i != this; ++i)
               param_num++;
          if (i != func_args.end ()) // found position
             {
            // Compute a mangled prefix from the function declaration.
               ostringstream s;
               const SgFunctionDeclaration* func_decl = isSgFunctionDeclaration (func_params->get_parent ());
               if (func_decl)
                    s << func_decl->get_mangled_name ().str ();
               s << "__ARG" << param_num+1;  // Append argument number (1-based)
               mangled_name = SgName (s.str ());
             }
         // else, an error (see below).
        }
       else // Case 2: Not a function parameter
        {
          SgScopeStatement* scope = get_scope ();
          if (scope == NULL)
             {
               mprintf ("SgInitializedName = %p = %s \n",this,get_name().str());
               get_file_info()->display("Error scope of SgInitializedName == NULL");
             }
          assert (scope != NULL);

          SgName qual_name = mangleQualifiers (scope);

          SgName name = get_name();
          if (name.get_length() > 0) // not empty
             {
               mangled_name = joinMangledQualifiers (qual_name, get_name ());
             }
            else
             {
            // name is empty
               if (isSgCatchOptionStmt (scope)) // e.g., 'try {...} catch (int) {...}
                  {
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("CATCHARG"));
                  }
                 else
                  {
                 // mprintf ("Must be a padding declaration (e.g. int:16) \n");
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("PADDING_VARIABLE"));
                  }
             }
        }

     if (!mangled_name.get_length ()) // Error: could not come up with a name.
        {
          mprintf ("Error in SgInitializedName::get_mangled_name(void): zero length mangled name generated (see if this is realistic)\n");
          SgScopeStatement* scope = get_scope ();
          assert (scope);
          mprintf ("  Surrounding scope is '%s'\n", scope->sage_class_name ());
          const SgDeclarationStatement* decl = get_declaration ();
          mprintf ("  Decl is '%s'\n", decl ? decl->sage_class_name () : "(none)");
          const SgDeclarationStatement* def = get_definition ();
          mprintf ("  Def is '%s'\n", def ? def->sage_class_name () : "(none)");
          const SgNode* par = decl ? decl->get_parent () : 0;
          mprintf ("  Parent(decl) is '%s'\n", par ? par->sage_class_name () : "(none)");

       // DQ (2/21/2007): I think this is OK for un-named function parameters, leave as a warning for now!.
       // assert(false);
       }

     return mangled_name;
   }


// QY 11/3/04
SgDeclarationStatement*
SgInitializedName::get_declaration() const
   {
     assert (this != NULL);
  // DQ (6/13/2005): This function assumes that the parents have been set!
  // so it should not be used in the EDG/Sage translation!

  // DQ (6/21/2006): Return to using this version of the code
  // DQ (6/21/2005): This is trying to traverse back through the scopes which might not make sense
     for (SgNode* r = get_parent(); r != NULL; r = r->get_parent())
        {
          SgDeclarationStatement* d = isSgDeclarationStatement(r);

       // DQ (6/21/2005): I think this should always be true!
       // assert(d != NULL);

          if (d != NULL)
             {
               return d;
             }
        }

     return nullptr;
   }

SgDeclarationStatement*
SgInitializedName::get_definition() const
   {
  // mprintf ("Why does SgInitializedName::get_definition() return a declaration! \n");
  // DQ (6/21/2005): Because the SgVariableDefinition is derived from a SgDeclarationStatement
  // and we return a SgVariableDefinition

     return get_declptr();
   }

void
SgInitializedName::set_definition(SgDeclarationStatement * def)
   {
#if DEBUG_SAGE_ACCESS_FUNCTIONS
  // DQ (6/12/2007): New access function tests using DEBUG_SAGE_ACCESS_FUNCTIONS and
  // DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION in sage3.h indicate this is required.
     if (get_declptr() != NULL)
        {
          mprintf ("Note: overwriting SgInitializedName::get_declptr() = %p with NULL before assignment to def = %p \n",get_declptr(),def);
          set_declptr(NULL);
        }
#endif

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     set_declptr(def);
   }

bool
SgInitializedName::checkBit ( unsigned int bit ) const
   {
     assert (bit < e_last_gnu_variable_attribute);
  // return p_gnu_attribute_modifierVector[bit];
     return (p_gnu_attribute_modifierVector[bit] == true);
   }

void
SgInitializedName::setBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = true;
   }

void
SgInitializedName::unsetBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = false;
   }


// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__); }
void SgInitializedName::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__); }
void SgInitializedName::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__); }
void SgInitializedName::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__); }
void SgInitializedName::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__); }
void SgInitializedName::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__); }
void SgInitializedName::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeNoCommon() const { return checkBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::setGnuAttributeNoCommon()      { setBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::unsetGnuAttributeNoCommon()    { unsetBit(e_gnu_attribute__nocommon__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeTransparentUnion() const { return checkBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::setGnuAttributeTransparentUnion()      { setBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::unsetGnuAttributeTransparentUnion()    { unsetBit(e_gnu_attribute__transparent_union__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__); }
void SgInitializedName::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__); }
void SgInitializedName::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__); }

// DQ (12/30/2013): Added support for packing on variables (instead of just on the types).
bool SgInitializedName::isGnuAttributePacked() const  { return checkBit(e_gnu_attribute__packed__); }
void SgInitializedName::setGnuAttributePacked()       { setBit(e_gnu_attribute__packed__); }
void SgInitializedName::unsetGnuAttributePacked()     { unsetBit(e_gnu_attribute__packed__); }

// DQ (12/30/2013): Added support for packing on variables (instead of just on the types).
bool SgInitializedName::isGnuAttributeNoReturn() const  { return checkBit(e_gnu_attribute__noreturn__); }
void SgInitializedName::setGnuAttributeNoReturn()       { setBit(e_gnu_attribute__noreturn__); }
void SgInitializedName::unsetGnuAttributeNoReturn()     { unsetBit(e_gnu_attribute__noreturn__); }

bool SgInitializedName::isGnuAttributeNoReorder() const  { return checkBit(e_gnu_attribute__noreorder__); }
void SgInitializedName::setGnuAttributeNoReorder()       { setBit(e_gnu_attribute__noreorder__); }
void SgInitializedName::unsetGnuAttributeNoReorder()     { unsetBit(e_gnu_attribute__noreorder__); }

bool SgInitializedName::is_ms_declspec_parameter_appdomain() const  { return checkBit(e_ms_declspec_parameter_appdomain); }
void SgInitializedName::set_ms_declspec_parameter_appdomain()       { setBit(e_ms_declspec_parameter_appdomain); }
void SgInitializedName::unset_ms_declspec_parameter_appdomain()     { unsetBit(e_ms_declspec_parameter_appdomain); }

bool SgInitializedName::is_ms_declspec_parameter_deprecated() const  { return checkBit(e_ms_declspec_parameter_deprecated); }
void SgInitializedName::set_ms_declspec_parameter_deprecated()       { setBit(e_ms_declspec_parameter_deprecated); }
void SgInitializedName::unset_ms_declspec_parameter_deprecated()     { unsetBit(e_ms_declspec_parameter_deprecated); }

bool SgInitializedName::is_ms_declspec_parameter_dllimport() const  { return checkBit(e_ms_declspec_parameter_dllimport); }
void SgInitializedName::set_ms_declspec_parameter_dllimport()       { setBit(e_ms_declspec_parameter_dllimport); }
void SgInitializedName::unset_ms_declspec_parameter_dllimport()     { unsetBit(e_ms_declspec_parameter_dllimport); }

bool SgInitializedName::is_ms_declspec_parameter_dllexport() const  { return checkBit(e_ms_declspec_parameter_dllexport); }
void SgInitializedName::set_ms_declspec_parameter_dllexport()       { setBit(e_ms_declspec_parameter_dllexport); }
void SgInitializedName::unset_ms_declspec_parameter_dllexport()     { unsetBit(e_ms_declspec_parameter_dllexport); }

bool SgInitializedName::is_ms_declspec_parameter_novtable() const  { return checkBit(e_ms_declspec_parameter_novtable); }
void SgInitializedName::set_ms_declspec_parameter_novtable()       { setBit(e_ms_declspec_parameter_novtable); }
void SgInitializedName::unset_ms_declspec_parameter_novtable()     { unsetBit(e_ms_declspec_parameter_novtable); }

bool SgInitializedName::is_ms_declspec_parameter_process() const  { return checkBit(e_ms_declspec_parameter_process); }
void SgInitializedName::set_ms_declspec_parameter_process()       { setBit(e_ms_declspec_parameter_process); }
void SgInitializedName::unset_ms_declspec_parameter_process()     { unsetBit(e_ms_declspec_parameter_process); }

bool SgInitializedName::is_ms_declspec_parameter_restrict() const  { return checkBit(e_ms_declspec_parameter_restrict); }
void SgInitializedName::set_ms_declspec_parameter_restrict()       { setBit(e_ms_declspec_parameter_restrict); }
void SgInitializedName::unset_ms_declspec_parameter_restrict()     { unsetBit(e_ms_declspec_parameter_restrict); }

bool SgInitializedName::is_ms_declspec_parameter_selectany() const  { return checkBit(e_ms_declspec_parameter_selectany); }
void SgInitializedName::set_ms_declspec_parameter_selectany()       { setBit(e_ms_declspec_parameter_selectany); }
void SgInitializedName::unset_ms_declspec_parameter_selectany()     { unsetBit(e_ms_declspec_parameter_selectany); }

bool SgInitializedName::is_ms_declspec_parameter_thread() const  { return checkBit(e_ms_declspec_parameter_thread); }
void SgInitializedName::set_ms_declspec_parameter_thread()       { setBit(e_ms_declspec_parameter_thread); }
void SgInitializedName::unset_ms_declspec_parameter_thread()     { unsetBit(e_ms_declspec_parameter_thread); }

bool SgInitializedName::is_ms_declspec_parameter_uuid() const  { return checkBit(e_ms_declspec_parameter_uuid); }
void SgInitializedName::set_ms_declspec_parameter_uuid()       { setBit(e_ms_declspec_parameter_uuid); }
void SgInitializedName::unset_ms_declspec_parameter_uuid()     { unsetBit(e_ms_declspec_parameter_uuid); }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
int
SgInitializedName::get_name_qualification_length() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgInitializedName::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool
SgInitializedName::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgInitializedName::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool
SgInitializedName::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgInitializedName::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgInitializedName::get_name_qualification_length_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgInitializedName::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

bool
SgInitializedName::get_type_elaboration_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgInitializedName::set_type_elaboration_required_for_type ( bool type_elaboration_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

bool
SgInitializedName::get_global_qualification_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgInitializedName::set_global_qualification_required_for_type ( bool global_qualification_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }

SOURCE_INITIALIZED_NAME_END


SOURCE_NAME_START

// Added to support assignments to string variables.
SgName::operator std::string () const
   {
     return p_char;
   }

// DQ (10/5/2007): We no longer need this!
// Definition of defaultName (use a default parameter)
// const SgName SgdefaultName("defaultName");

SgName::SgName() : p_char("")
   {
   }

unsigned int
SgName::get_length() const
   {
     ASSERT_not_null(this);
     return p_char.size();
   }

SgName::SgName(const char * str): p_char(str ? str : "")
   {
   }

SgName::SgName(const std::string & str): p_char(str)
   {
   }

SgName::SgName(const SgName& n): p_char(n.p_char)
   {
   }

int
SgName::operator!=(const SgName& n1) const
   {
     ASSERT_not_null(this);
     return p_char != n1.p_char;
   }

int
SgName::operator==(const SgName& n1) const
   {
     ASSERT_not_null(this);
     return p_char == n1.p_char;
   }

#ifdef _MSC_VER
#define strncasecmp _strnicmp
#endif
// DQ (11/27/2010): Added support for case insensitive name matching.
bool
SgName::caseInsensitiveEquality ( const SgName & x, const SgName & y )
   {
  // This function checks a case insensitive match of x against y.
  // This is required because Fortran is case insensitive.

     size_t x_length = x.p_char.length();
     size_t y_length = y.p_char.length();

     return (x_length == y_length) ? strncasecmp(x.p_char.c_str(),y.p_char.c_str(),x_length) == 0 : false;
   }


int
SgName::operator<(const SgName& n1) const
   {
     assert(this != NULL);

     return p_char < n1.p_char;
   }

bool
SgName::is_null(void) const
   {
     assert(this != NULL);
     return p_char.empty();
   }

void
SgName::replace_space(char t)
   {
     assert(this != NULL);

     int len = p_char.size();
     for(int i=0; i < len; i++)
        {
       // if last one
          if(p_char[i]==' ')
             {
               if(i==len-1)
                    p_char.resize(p_char.size() - 1);
                 else
                    p_char[i]=t;
             }
        }
   }

SgName&
SgName::operator<<(const std::string& str)
   {
     assert (this != NULL);

     p_char += str;
     return *this;
   }

SgName
SgName::itoname(int val)
   {
     std::ostringstream os;
     os << val;
     return SgName(os.str());
   }

SgName&
SgName::operator<<(int val)
   {
     assert(this != NULL);

     SgName str = itoname(val);
     p_char += str.p_char;
     return *this;
   }

SgName&
SgName::operator=(const SgName& n1)
   {
     assert(this != NULL);
     this->p_char = n1.p_char;
     return *this;
   }

SgName&
SgName::tail(int n) // keep string after n
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? "" : p_char.substr(n);
     return *this;
   }

SgName&
SgName::head(int n) // keep first n chars
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? p_char : p_char.substr(0, n);
     return *this;
   }

const char* SgName::str() const {
     assert(this != NULL);
  return p_char.c_str();
}

std::string&
SgName::getString()
   {
     assert(this != NULL);
     return p_char;
   }

const std::string&
SgName::getString() const
   {
     assert(this != NULL);
     return p_char;
   }


void SgName::display( const std::string& label ) const
   {
     assert(this != NULL);

     std::cout << label << ": " << p_char << "\n";
   }

// DQ (9/9/2004): friend function
SgName
operator+(const SgName & n1, const SgName & n2)
   {
     return SgName(n1.p_char + n2.p_char);
   }

// DQ (11/15/2004): Added to support general string operations (first used in the unparser)
SgName &
SgName::operator+= (const SgName & n1)
   {
     assert(this != NULL);
     p_char += n1.p_char;
     return *this;
   }

SgName
SgName::assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName)
   {
     SgName returnName;
  // DQ (9/9/2004): So these are redundent tests! (which was pleasant news to me!)
     if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName.getString() == "") )
        {
          returnName = localName;
        }
       else
        {
          std::string scopeDelimiter;
          if (SageInterface::is_Java_language() || SageInterface::is_Ada_language())
              scopeDelimiter = ".";
          else
              scopeDelimiter = "::";

       // Trap out the case of global scope to avoid building "::::"
          if ( scopeQualifiedName == scopeDelimiter )
             {
            // Avoid building "::::"
               returnName = scopeQualifiedName.getString() + localName.getString();
             }
            else
             {
               returnName = scopeQualifiedName.getString() + scopeDelimiter + localName.getString();
             }
        }

     return returnName;
   }

SgName
SgName::invertCase() const
   {
     string s = p_char;

     char* str = &(s[0]);
     while(*str)
        {
          if(isupper(*str))
               *str = tolower(*str);
            else
               if(islower(*str))
                    *str = toupper(*str);
          str++;
        }

     return s;
   }



SOURCE_NAME_END


SOURCE_QUALIFIED_NAME_START
SOURCE_QUALIFIED_NAME_END


SOURCE_ATTRIBUTE_START

int
SgAttribute::isSame(const std::string& str)
   {
     return p_name == str;
   }

SOURCE_ATTRIBUTE_END


SOURCE_BIT_ATTRIBUTE_START
SOURCE_BIT_ATTRIBUTE_END


SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START
SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END


SOURCE_CLASS_DECLARATION_ATTRIBUTE_START
SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


SOURCE_PRAGMA_START

std::string
SgPragma::get_pragma() const
   { return get_name(); }

bool
SgPragma::samePragma(const std::string& str)
   { return get_name() == str; }

bool
SgPragma::isPragma() const
   { return 1; }

bool
SgPragma::gotPrinted() const
   { return p_printed; }

void
SgPragma::setPrinted(bool s)
   { p_printed=s; }

void
SgPragma::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_printed = false;
   }

// DQ (11/6/2006): This is not generated due to the name change of "file_info" to "startOfConstruct" (uncommented)
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgPragma::get_file_info() const
   {
  // return p_fileInfo;
     return p_startOfConstruct;
   }

SOURCE_PRAGMA_END


SOURCE_FILE_INFORMATION_START

// int Sg_File_Info::p_cur_line ROSE_DEPRECATED_VARIABLE  = 0;
// std::string Sg_File_Info::p_cur_file  ROSE_DEPRECATED_VARIABLE = "";

// MK (7/22/05) : Added support for file ids. Here we initialize the static file maps, etc
// int Sg_File_Info::p_max_file_id = 0;
std::map<std::string, int> Sg_File_Info::p_nametofileid_map;
std::map<int, std::string> Sg_File_Info::p_fileidtoname_map;


// DQ (7/4/2005): Added to test internal consistancy
bool
Sg_File_Info::ok() const
   {
     assert(this != NULL);

  // DQ (10/22/2007): Are these reasonable constraints when #line n "" are used?
     bool lineNumberOK      = p_line > 0;
     bool columnNumberOK    = p_col  > 0;

  // MK (7/22/05) We compare using p_fileid instead of p_filename now
  // bool filenameOK        = p_filename != NULL;
     bool filenameOK        = p_file_id != NULL_FILE_ID;

  // A compiler generated node has no defined association with a file, line number, or column number.
     bool compilerGenerated = isCompilerGenerated();

  // DQ (11/22/2006): Some nodes have no source position information and we have the live with this at points in the processing.
  // A node which was explicitly marked as a sourcePositionUnavailableInFrontendcompiler has no defined association with a file, line number, or column number.
     bool sourcePositionUnavailableInFrontend = isSourcePositionUnavailableInFrontend();

  // DQ (12/23/2006): If this is part of a transformation then it is OK by definition.
  // A node introduced as part of a transformation has no defined association with a file, line number, or column number.
     bool transformation  = isTransformation();

     bool physicalFileOK = (p_physical_file_id >= 0);

     if (physicalFileOK == false)
        {
          mprintf ("Note: In Sg_File_Info::ok(): p_physical_file_id = %d \n",p_physical_file_id);
        }

  // return  compilerGenerated || (lineNumberOK && filenameOK);
  // return  sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && filenameOK);
  // return  transformation || sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && columnNumberOK && filenameOK);
     return  (lineNumberOK && columnNumberOK && filenameOK) || compilerGenerated || sourcePositionUnavailableInFrontend || transformation;
   }

void
Sg_File_Info::updateSourcePosition ( Sg_File_Info* update )
   {
  // DQ (12/22/2006): This copies the line number and column number information and verifies that
  // the file name is the same (it does not reset any of the classification flags).  This is more
  // useful than the assignment operator for updating information and is used in the file:
  // fixupSourcePositionInformation.C.

     assert(update != NULL);

  // Must have matching file name (only have to compare file_id's)
     assert(p_file_id == update->p_file_id);

  // Update only the line number and column number after verifying that the filenames are the same.
     p_line = update->p_line;
     p_col  = update->p_col;

  // DQ (12/20/2012): Added support for physical source position (existing file_id and line data represents logical position data).
     ROSE_ASSERT(p_physical_file_id == update->p_physical_file_id);
     p_physical_line = update->p_physical_line;

  // DQ (1/23/2013): Added support for source sequence numbering information.
     p_source_sequence_number = update->p_source_sequence_number;
   }


// DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
// Static function to return new Sg_File_Info object set to default values
Sg_File_Info* Sg_File_Info::generateDefaultFileInfo()
   {
     Sg_File_Info* returnValue = new Sg_File_Info("NULL_FILE",0,0);
     assert(returnValue != NULL);

  // DQ (6/7/2007): This causes "NULL_FILE" filenames to be introduced into the AST.
  // Gergo pointed out this problems and removing such entries will simplify the tests
  // that are done in the traverseInputFile traversal.

     return returnValue;
   }

Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForTransformationNode()
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setTransformation();

  // DQ (1/11/2006): Added call to setOutputInCodeGeneration() because the default
  // behavior is to output all transformations.  Other functions allow transformations
  // to be specified that would not be output (useful for when including new header files).
     returnValue->setOutputInCodeGeneration();

     returnValue->set_file_id( TRANSFORMATION_FILE_ID );

     return returnValue;
   }


// DQ (1/11/2006): Added version of function where filename (file_id) can
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( int file_id )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_file_id( file_id );

#if 0
     mprintf ("In Sg_File_Info::generateFileInfoForTransformationNode(file_id = %d) return = %p \n",file_id,returnValue);
#endif

     return returnValue;
   }


// DQ (1/11/2006): Added version of function where filename (file_id) can
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( string filename )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_filenameString( filename );

#if 0
     mprintf ("In Sg_File_Info::generateFileInfoForTransformationNode(filename = %s) return = %p \n",filename.c_str(),returnValue);
#endif

     return returnValue;
   }


// Static function to return new Sg_File_Info object set to default values appropriate for compiler generated code
// static Sg_File_Info* generateCompilerGeneratedDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode()
   {
  // IR nodes using this function's return value will be marked as compiler generated (but not output, unless also marked as such)
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setCompilerGenerated();

     returnValue->set_file_id( COMPILER_GENERATED_FILE_ID );

#if 0
     mprintf ("In Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode() return = %p \n",returnValue);
#endif

     return returnValue;
   }


// DQ (11/2/2006): Added operator= member function to simple assignment (used in fixupSourcePositionInformation.C
// to modify Sg_File_Info objects so that they better reflect the original source code).
Sg_File_Info &
Sg_File_Info::operator= ( const Sg_File_Info & X )
   {
#if 0
     mprintf ("In Sg_File_Info::operator=(): get_parent() = %p = %s \n",get_parent(),(get_parent() != NULL) ? get_parent()->class_name().c_str() : "null");
     mprintf ("In Sg_File_Info::operator=(): this = %p &X = %p \n",this,&X);
#endif

     p_file_id                  = X.p_file_id;
     p_line                     = X.p_line;
     p_col                      = X.p_col;
     p_classificationBitField   = X.p_classificationBitField;
     p_fileIDsToUnparse         = X.p_fileIDsToUnparse;
     p_fileLineNumbersToUnparse = X.p_fileLineNumbersToUnparse;

  // DQ (12/20/2012): Added support for physical source position (existing file_id and line data represents logical position data).
     p_physical_file_id = X.p_physical_file_id;
     p_physical_line    = X.p_physical_line;

  // DQ (1/23/2013): Added support for source sequence numbering information.
     p_source_sequence_number = X.p_source_sequence_number;

  // Record that this source position information was updated.
     set_isModified(true);

     return *this;
   }


// DQ (9/26/2004): Added operator== friend function to permit testing of reused definitions of defining declarations!
bool
operator== ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool returnValue = false;

  // Make this most efficent by putting the least likely match first
  // (col, line, file) and the most expensive test (file) last.
     if (X.get_col() == Y.get_col())
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.get_line() == Y.get_line())
          if (X.get_physical_line() == Y.get_physical_line())
             {
         // MK (7/22/05) : Replaced string comparisons with file_id comparisons
         /*
               if ( string(X.get_filename()) == string(Y.get_filename()))
                  {
                    returnValue = true;
                  }
         */
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_file_id == Y.p_file_id)
               if (X.p_physical_file_id == Y.p_physical_file_id)
                  {
                    returnValue = true;
                  }
             }
        }

     return returnValue;
   }


// DQ (10/6/2004): Added operator!= friend function to permit testing of reused definitions of defining declarations!
bool
operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     return operator==(X,Y) ? false : true;
   }


// DQ (10/25/2004): Added relational operators to permit testing of strting vs. ending file info object (assert starting < ending)
bool
operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // mprintf ("In operator > (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // mprintf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // mprintf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
       // if (X.p_line > Y.p_line)
          if (X.p_physical_line > Y.p_physical_line)
             {
            // mprintf ("TRUE: X.p_line = %d > X.p_line = %d \n",X.p_line,X.p_line);
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col > Y.p_col)
                       {
                      // mprintf ("TRUE: X.p_col = %d > Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // mprintf ("Sorry operator> (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // mprintf ("In operator < (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // mprintf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // mprintf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
       // if (X.p_line < Y.p_line)
          if (X.p_physical_line < Y.p_physical_line)
             {
            // mprintf ("TRUE: X.p_line = %d < Y.p_line = %d \n",X.p_line,Y.p_line);
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col < Y.p_col)
                       {
                      // mprintf ("TRUE: X.p_col = %d < Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // mprintf ("Sorry operator< (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.p_line > Y.p_line)
          if (X.p_physical_line > Y.p_physical_line)
             {
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col >= Y.p_col)
                         result = true;
                  }
             }
        }

  // mprintf ("Sorry operator>= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.p_line < Y.p_line)
          if (X.p_physical_line < Y.p_physical_line)
             {
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col <= Y.p_col)
                         result = true;
                  }
             }
        }

  // mprintf ("Sorry operator<= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


//Liao 4/16/2010. The default value for display(label) cannot be instantiated from gdb,
// which is very annoying during debugging. I added the empty parameter one to better support debugging.
void
Sg_File_Info::display() const
   {
     display ("");
   }


void
Sg_File_Info::display( const std::string label ) const
   {
     assert(this != NULL);

  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("Inside of Sg_File_Info::display(%s) of this pointer = %p \n",label.c_str(), this);
     printf ("     isTransformation                      = %s \n",isTransformation()                      == true ? "true (part of a transformation)" : "false");
     printf ("     isCompilerGenerated                   = %s \n",isCompilerGenerated()                   == true ? "true (no position information)" : "false");
     printf ("     isOutputInCodeGeneration              = %s \n",isOutputInCodeGeneration()              == true ? "true (output in code generator)" : "false");
     printf ("     isShared                              = %s \n",isShared()                              == true ? "true (shared within merged AST)" : "false");
     printf ("     isFrontendSpecific                    = %s \n",isFrontendSpecific()                    == true ? "true (part of ROSE support for gnu compatability)" : "false");
     printf ("     isSourcePositionUnavailableInFrontend = %s \n",isSourcePositionUnavailableInFrontend() == true ? "true (source position unavailable in frontend)" : "false");
     printf ("     isCommentOrDirective                  = %s \n",isCommentOrDirective()                  == true ? "true (this is a comment or CPP directive)" : "false");
     printf ("     isToken                               = %s \n",isToken()                               == true ? "true (this is from the token stream woven into the AST)" : "false");
     printf ("     isDefaultArgument                     = %s \n",isDefaultArgument()                     == true ? "true (root of default argument)" : "false");
     printf ("     isImplicitCast                        = %s \n",isImplicitCast()                        == true ? "true (implicit instead of explicit cast)" : "false");

  // if (isCompilerGenerated() == false)
     if (!isTransformation() && !isCompilerGenerated())
        {
          printf ("     (computed) filename = %s \n",get_filename());
          printf ("     (computed) line     = %d  column = %d \n",get_line(),get_col());
        }
       else // Liao, 11/12/2012, more information for debugging
        {
          printf ("     Filename and line, column info should be invalid for transformation or compiler generated objects\n");
          printf ("     we print their values anyway for your reference\n");
          printf ("     (computed) filename = %s \n",get_filename());
          printf ("     (computed) line     = %d  column = %d \n",get_line(),get_col());
        }

  // DQ (6/17/2005): Way to get extra debugging information, if the
  // substring "debug" is found then extra information is output
  // if (label == "debug")
     if (label.find("debug") != std::string::npos)
        {
          printf ("     (internal) file_id   = %d \n",get_file_id());
          printf ("     (internal) filename  = %s \n",get_raw_filename().c_str());
          printf ("     (internal  line      = %d  column   = %d \n",p_line,p_col);
        }

     printf ("     (computed) physical_file_id    = %d = %s \n",get_physical_file_id(),get_physical_filename().c_str());
     printf ("     (internal) physical_file_id    = %d = %s \n",get_physical_file_id(),getFilenameFromID(get_physical_file_id()).c_str());
     printf ("     (internal) physical_file_id    = %d = %s \n",p_physical_file_id,getFilenameFromID(p_physical_file_id).c_str());
     printf ("     (computed) physical_line       = %d \n",p_physical_line);

  // DQ (1/23/2013): Added support for source sequence numbering information.
     printf ("     source_sequence_number         = %d \n",p_source_sequence_number);
   }

string
Sg_File_Info::displayString(const std::string & label ) const
   {
     assert(this != NULL);

     std::string s;
     s += std::string("Inside of Sg_File_Info::displayString(") + label + std::string (") \n");
     s += std::string("isTransformation    = ") + std::string(isTransformation()    ? "true " : "false ") + std::string(" ");
     s += std::string("isCompilerGenerated = ") + std::string(isCompilerGenerated() ? "true " : "false ") + std::string(" ");
     if (!isTransformation() && !isCompilerGenerated())
        {
          s += std::string("line number = ")   + Rose::StringUtility::numberToString(get_line()) + std::string(" ");
          s += std::string("column number = ") + Rose::StringUtility::numberToString(get_col())  + std::string(" ");
          s += std::string("filename = ")      + std::string(get_filename()) + std::string(" ");
        }

     return s;
   }

void
Sg_File_Info::display_static_data( const std::string label )
   {
  // DQ (6/11/2007): output static data for debugging

  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("Inside of Sg_File_Info::display_static_data(%s) \n",label.c_str());

  // mprintf ("p_cur_line = %d \n",p_cur_line);
  // mprintf ("p_cur_file = %s \n",p_cur_file.c_str());

  // mprintf ("p_max_file_id = %d \n",p_max_file_id);

     printf ("p_nametofileid_map: \n");
     for (std::map<std::string,int>::iterator i = p_nametofileid_map.begin(); i != p_nametofileid_map.end(); i++)
        {
          printf ("name = %s id = %d \n",i->first.c_str(),i->second);
        }

     printf ("p_fileidtoname_map: \n");
     for (std::map<int,std::string>::iterator i = p_fileidtoname_map.begin(); i != p_fileidtoname_map.end(); i++)
        {
          printf ("id = %d name = %s \n",i->first,i->second.c_str());
        }
   }

// Since we make the arguments in the other constructor
// have default values this constructor is redundant/ambiguous
// Sg_File_Info::Sg_File_Info() {}

Sg_File_Info::Sg_File_Info()
   : p_file_id(COPY_FILE_ID), p_line(0), p_col(0),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     ASSERT_not_null(this);
     post_construction_initialization();
   }

// DQ (4/19/2006): Added constructor to take std::string as part of move
// away from C style strings to C++ style strings.
Sg_File_Info::Sg_File_Info ( const std::string & filename, int line, int col )
   : p_file_id(NULL_FILE_ID), p_line(line), p_col(col),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     if (filename != "NULL_FILE")
        {
          set_filenameString(filename);
        }

     set_physical_source_position_to_match_logical_source_position();

     post_construction_initialization();
   }

// DQ (2/15/2003): added copy constructor
Sg_File_Info::Sg_File_Info(const Sg_File_Info & X)
   : p_file_id(X.p_file_id),
     p_line(X.p_line),
     p_col(X.p_col),
     p_classificationBitField(X.p_classificationBitField),
     p_physical_file_id(X.p_physical_file_id),
     p_physical_line(X.p_physical_line),
     p_source_sequence_number(X.p_source_sequence_number),
     p_fileIDsToUnparse(X.p_fileIDsToUnparse),
     p_fileLineNumbersToUnparse(X.p_fileLineNumbersToUnparse)
   {
     post_construction_initialization();
   }

// DQ (11/6/2008): added constructor to support building objects from Dwarf
// information (which uses a pre-resolved integer file_id instead of a string)
Sg_File_Info::Sg_File_Info( int file_id, int line, int column )
   : p_file_id(file_id),
     p_line(line),
     p_col(column),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     post_construction_initialization();
   }

void
Sg_File_Info::post_construction_initialization()
   {
     ASSERT_not_null(this);
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // ROSE-1499 check that p_file_id is valid
     check_file_id("Sg_File_Info::post_construction_initialization");
   }

// ROSE-1499, ROSE-1639 (added const to char*)
void Sg_File_Info::check_file_id(const char * label, bool assertion) const {
  if ( ( (p_file_id >= 0) && (p_fileidtoname_map.count(p_file_id) == 0) ) || ( (p_file_id < -6) || ( p_file_id > (int)p_fileidtoname_map.size() ) ) ) {
    printf("ERROR from %s:\n", label);
    printf("  Sg_File_Info::this = %p\n", this);
    printf("  p_file_id = %d\n", p_file_id);
    printf("  p_nametofileid_map.size() = %zu\n", p_nametofileid_map.size());
    printf("  p_fileidtoname_map.size() = %zu\n", p_fileidtoname_map.size());
    printf("  isTransformation() = %d\n", isTransformation());
    printf("  isCompilerGenerated() = %d\n", isCompilerGenerated());
    printf("  isFrontendSpecific() = %d\n", isFrontendSpecific());
  }
  if (assertion) {
     ROSE_ASSERT((p_file_id < 0) || (p_fileidtoname_map.count(p_file_id) > 0));
     ROSE_ASSERT((p_file_id > -7) && (p_file_id < (int)p_fileidtoname_map.size()));
  }
}

int
Sg_File_Info::get_file_id () const
   {
  // DQ (10/27/2007): This is custom generated so that it can be consistant with the get_filename() member function
     assert (this != NULL);

     check_file_id("Sg_File_Info::get_file_id");

  // initialize to bad value
     int returnValue = -99;

     if (isTransformation() == true)
        {
       // returnValue = undefinedValue;
          returnValue = TRANSFORMATION_FILE_ID;
        }
       else
        {
       // DQ (11/1/2007): This does not allow for isSameFile() to compare properly when testing for "rose_edg_required_macros_and_functions.h"
          if ( isCompilerGenerated() == true )
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the file_id of the associated file ("rose_edg_required_macros_and_functions.h")
            // returnValue = undefinedValue;
               if ( isFrontendSpecific() == true )
                  {
#define FAIL_ON_ROSE_1532 0
#if FAIL_ON_ROSE_1532
                    if (p_fileidtoname_map.count(p_file_id) == 0 && p_file_id == COMPILER_GENERATED_FILE_ID) {
                      printf("ERROR: Sg_File_Info::get_file_id(this = %p):\n", this);
                      printf("  isFrontendSpecific() == true => p_file_id == file_id_of(\"rose_edg_required_macros_and_functions.h\")\n");
                      printf("  BUT:  p_file_id = %d\n", p_file_id);
                      printf("  HERE: p_file_id == COMPILER_GENERATED_FILE_ID\n");
                      printf("  BYPASSED: seen for a SgInitializedName in the parameter list of __builtin_atan2\n");
                      ROSE_ASSERT(false);
                    }
#endif
                 // ROSE-1499: check that p_file_id is valid
                    ROSE_ASSERT(p_file_id == COMPILER_GENERATED_FILE_ID || p_fileidtoname_map.count(p_file_id) > 0);
                 // In this case return the file_id of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnValue = p_file_id;
                  }
                 else
                  {
                    returnValue = COMPILER_GENERATED_FILE_ID;
                  }
             }
            else
             {
#define FAIL_ON_ROSE_1533 0
#if FAIL_ON_ROSE_1533
               if (p_fileidtoname_map.count(p_file_id) == 0 && p_file_id == NULL_FILE_ID) {
                 printf("ERROR: Sg_File_Info::get_file_id(this = %p):\n", this);
                 printf("  p_nametofileid_map.size() = %d\n", p_nametofileid_map.size());
                 printf("  p_fileidtoname_map.size() = %d\n", p_fileidtoname_map.size());
                 printf("  p_file_id should represent a valid file.\n", p_file_id);
                 printf("  HERE: p_file_id == NULL_FILE_ID\n");
                 printf("  BYPASSED: seen for a SgCtorInitializerList of foo1 in Cxx_tests/test2003_01.C (the SgCtorInitializerList is implicit).\n");
                 ROSE_ASSERT(false);
               }
#endif
            // ROSE-1499: check that p_file_id is valid
               ROSE_ASSERT(p_file_id == NULL_FILE_ID || p_file_id == COMPILER_GENERATED_FILE_ID || p_fileidtoname_map.count(p_file_id) > 0);
               returnValue = p_file_id;
             }
        }

  // DQ (12/18/2012): Added assertion.
     ROSE_ASSERT(returnValue != -99);

     return returnValue;
   }

void
Sg_File_Info::set_file_id( int file_id )
   {
     assert (this != NULL);
     set_isModified(true);

     check_file_id("Sg_File_Info::set_file_id");

     p_file_id = file_id;
   }


int
Sg_File_Info::get_physical_file_id() const
   {
  // DQ (12/18/2012): Added support for physical file position information.
     assert (this != NULL);

  // Initialize to error value.
     int return_physical_file_id = NULL_FILE_ID;

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     bool physicalFileOK = (p_physical_file_id >= 0);
     int file_id = get_file_id();

#if 0
     printf ("In Sg_File_Info::get_physical_file_id(): \n");
     printf (" --- (before being set) return_physical_file_id = %d \n",return_physical_file_id);
     printf (" --- p_physical_file_id                         = %d \n",p_physical_file_id);
     printf (" --- physicalFileOK                             = %s \n",physicalFileOK ? "true" : "false");
     printf (" --- file_id                                    = %d \n",file_id);
     printf (" --- isCompilerGenerated()                      = %s \n",isCompilerGenerated() ? "true" : "false");
#endif

  // DQ (8/20/2018): Not clear why this language specific rule is a good idea.
  // PHL (01/06/2014) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
        {
          return file_id;
        }

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     if (physicalFileOK == false && file_id < 0)
        {
          return_physical_file_id = file_id;
        }
       else
        {
       // DQ (8/22/2018): Use the file_id for compiler generated nodes, because they don't have a valid source position.
          if (isCompilerGenerated() == true)
             {
#if 1
               return_physical_file_id = file_id;
#else
            // DQ (5/20/2021): If the physical_file_id has been set (as we now do to support the header file unparsing)
            // then where it is a physical file (id >= 0) then we want to return this value, even of this is marked as
            // compiler generated.
            // if (physicalFileOK == false && file_id < 0)
               if (physicalFileOK == true)
                  {
                    return_physical_file_id = p_physical_file_id;
                  }
                 else
                  {
                    return_physical_file_id = file_id;
                  }
#endif
             }
            else
             {
               return_physical_file_id = p_physical_file_id;
             }
        }

     return return_physical_file_id;
   }


// DQ (5/20/2021): Added to support debugging.
int*
Sg_File_Info::get_physical_file_id_reference()
   {
     assert (this != NULL);

     return &p_physical_file_id;
   }


int
Sg_File_Info::get_physical_file_id(int input_file_id) const
   {
     ASSERT_not_null(this);

  // Initialize to error value.
     int return_physical_file_id = NULL_FILE_ID;

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     bool physicalFileOK = (p_physical_file_id >= 0);
     int local_file_id = get_file_id();

  // DQ (8/20/2018): Not clear why this language specific rule is a good idea.
  // PHL (01/06/2014) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
        {
          return local_file_id;
        }

#if 0
     mprintf ("In Sg_File_Info::get_physical_file_id(int): physicalFileOK = %s \n",physicalFileOK ? "true" : "false");
     mprintf (" --- local_file_id = %d \n",local_file_id);
#endif

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     if (physicalFileOK == false && local_file_id < 0)
        {
          return_physical_file_id = local_file_id;
        }
       else
        {
       // DQ (8/22/2018): Use the file_id for compiler generated nodes, because they don't have a valid source position.
#if 0
          mprintf ("In Sg_File_Info::get_physical_file_id(int): isCompilerGenerated() = %s local_file_id = %d p_physical_file_id = %d \n",isCompilerGenerated() ? "true" : "false",local_file_id,p_physical_file_id);
#endif
          if (isCompilerGenerated() == true)
             {
               return_physical_file_id = local_file_id;
             }
            else
             {
            // return_physical_file_id = p_physical_file_id;

               if (input_file_id == this->get_physical_file_id())
                  {
                    return_physical_file_id = p_physical_file_id;
                  }
                 else
                  {
                    SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),input_file_id);
                    if (pos != p_fileIDsToUnparse.end())
                       {
                         mprintf ("Sg_File_Info::get_physical_file_id(int): input file is sharing this IR node: input_file_id = %d physical_file_id = %d \n",input_file_id,this->get_physical_file_id());
                         ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                         ROSE_ASSERT(index >= 0);
                         ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());

                      // DQ (12/23/2019): Added debugging info.
                         if (p_fileLineNumbersToUnparse.size() != p_fileIDsToUnparse.size())
                            {
                              mprintf ("Error: p_fileLineNumbersToUnparse.size() != p_fileIDsToUnparse.size() \n");
                              mprintf (" --- p_fileLineNumbersToUnparse.size() = %zu \n",p_fileLineNumbersToUnparse.size());
                              mprintf (" --- p_fileIDsToUnparse.size()         = %zu \n",p_fileIDsToUnparse.size());
                            }
                         ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
                         mprintf (" --- index = %d shared input file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
                         ROSE_ASSERT(input_file_id == p_fileIDsToUnparse[index]);
                         return_physical_file_id = p_fileIDsToUnparse[index];
                         mprintf (" --- returning return_physical_file_id = %d \n",return_physical_file_id);
                       }
                      else
                       {
                      // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                      // This is a reasonable default, if we don't want to make this an error.

                         return_physical_file_id = p_physical_file_id;
                       }
                  }
             }
        }

     return return_physical_file_id;
   }


void
Sg_File_Info::set_physical_file_id( int physical_file_id )
   {
     assert (this != NULL);

     set_isModified(true);

#if 0
     printf ("In Sg_File_Info::set_physical_file_id(physical_file_id = %d) this = %p \n",physical_file_id,this);
#endif

     p_physical_file_id = physical_file_id;

  // Make sure this is a previously handled file.
     if (p_physical_file_id >= 0)
        {
          ROSE_ASSERT(p_fileidtoname_map.find(p_physical_file_id) != p_fileidtoname_map.end());
        }
   }


void
Sg_File_Info::set_physical_source_position_to_match_logical_source_position()
   {
     assert (this != NULL);

     set_isModified(true);

     p_physical_file_id = p_file_id;
     p_physical_line    = p_line;

  // Make sure this is a previously handled file.
     if (p_physical_file_id >= 0)
        {
          ROSE_ASSERT(p_fileidtoname_map.find(p_physical_file_id) != p_fileidtoname_map.end());
        }
   }


int
Sg_File_Info::numberOfSourceFiles()
   {
     return p_nametofileid_map.size();
   }


int
Sg_File_Info::addFilenameToMap ( const std::string & filename )
   {
  // DQ (11/6/2008): Added support for extending the internal static filename to integer id map.
  // This static function is used the the Dwarf support to convert filenames to integer values and
  // maintain a map similar to the Dwarf mapping of integers to filenames as a way to save space
  // in the represnetation of source position mappings of the instructions in the binary.

     int returnValue = 0;
     if (p_nametofileid_map.count(filename) == 0)
        {
          returnValue = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = returnValue;
          p_fileidtoname_map[returnValue] = filename;
        }
       else
        {
          returnValue = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());

     return returnValue;
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filename(const char* filename)
Sg_File_Info::set_filenameString ( const std::string & filename )
   {
     assert (this != NULL);

     check_file_id("Sg_File_Info::set_filenameString");

#if 0
     mprintf ("In Sg_File_Info::set_filenameString(filename = %s) this = %p \n",filename.c_str(),this);
#endif

  // DQ (6/6/2019): I think this is a more efficent implementation.
  // p_nametofileid_map has type: std::map<std::string, int>
  // if (p_nametofileid_map.count(filename) == 0)
     if (p_nametofileid_map.find(filename) == p_nametofileid_map.end())
        {
          p_file_id = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = p_file_id;
          p_fileidtoname_map[p_file_id] = filename;
        }
       else
        {
          p_file_id = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());

  // DQ (3/19/2017): Note that this is important for Fortran support (where IR nodes frequently
  // start with (isSourcePositionUnavailableInFrontend() == true) and are fixed up afterward.
     if ( isSourcePositionUnavailableInFrontend() == true )
        {
#if 0
          mprintf ("In Sg_File_Info::set_filenameString(): reset isSourcePositionUnavailableInFrontend() to false: filename = %s \n",filename.c_str());
#endif
          unsetSourcePositionUnavailableInFrontend();
        }

  // DQ (8/31/2006): We can't enforce that this is an absolute path (test2001_04.C and test2004_60.C demonstrate why).
  // DQ (8/31/2006): Verify that this is a absolute path
  // string targetSubstring = "/";
  // string filenameString  = filename;
  // if (filenameString.substr(0,targetSubstring.size()) != targetSubstring)
  //      mprintf ("@@@@@@@@@@@@@@@@@@@@ In Sg_File_Info::Sg_File_Info(string,int,int): filename = %s @@@@@@@@@@@@@@@@@@@@\n",filenameString.c_str());
  // assert(filenameString.substr(0,targetSubstring.size()) == targetSubstring);

  // Detect use of AST Rewrite intermediate files (need to make sure they get absolute paths)
  // string targetSubstring2 = "rose_";
  // assert(filenameString.substr(0,targetSubstring2.size()) != targetSubstring2);
   }

void
Sg_File_Info::set_physical_filename ( const std::string & filename )
   {
     assert (this != NULL);

#if 0
     mprintf ("In Sg_File_Info::set_physical_filename(filename = %s) this = %p p_nametofileid_map.count(filename) = %" PRIuPTR " \n",filename.c_str(),this,p_nametofileid_map.count(filename));
#endif

  // DQ (6/6/2019): I think this is a more efficent implementation.
  // p_nametofileid_map has type: std::map<std::string, int>
  // if (p_nametofileid_map.count(filename) == 0)
     if (p_nametofileid_map.find(filename) == p_nametofileid_map.end())
        {
       // If the filename is not in the p_nametofileid_map then we need to add it.
          p_physical_file_id = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = p_physical_file_id;
          p_fileidtoname_map[p_physical_file_id] = filename;
        }
       else
        {
       // If it is in the p_nametofileid_map then we just need to get the integer file id.
          p_physical_file_id = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filenameString ( const std::string & filename )
Sg_File_Info::set_filename(const char* filename)
   {
     check_file_id("Sg_File_Info::set_filename");

  // DQ (9/5/2006): Modified implementation
  // set_filename(filename.c_str());
     assert(filename != NULL);
     set_filenameString(filename);
   }

const std::string &
Sg_File_Info::get_filenameString() const
   {
     assert (this != NULL);
     check_file_id("Sg_File_Info::get_filenameString");

     const std::string* returnString = NULL;

     if (isTransformation() == true)
        {
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
       else
        {
          if (isCompilerGenerated() == true)
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the filename of the associated file ("rose_edg_required_macros_and_functions.h")
            // This has been fixed to be consistant with the implementation of get_file_id().
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the filename of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnString = &getFilenameFromID(p_file_id);
                  }
                 else
                  {
                    static const std::string compilerGenerated_string = "compilerGenerated";
                    returnString = &compilerGenerated_string;
                  }
             }
            else
             {
               returnString = &getFilenameFromID(p_file_id);
             }
        }

     assert (returnString != NULL);

     return *returnString;
   }

const char*
Sg_File_Info::get_filename() const
   {

     check_file_id("Sg_File_Info::get_filename");

  // DQ (10/15/2005): This function is the C string version of the get_filename()
  // function which has been deprecated. At some point the get_filename() function
  // will be eliminated and later reinfroduced as get_filename() (finally building
  // a C++ string implementation instead of a char* (C style string) based implementation).
     return get_filenameString().c_str();
   }

string
Sg_File_Info::get_raw_filename() const
   {
     assert (this != NULL);

  // return whatever name is in the map
     return getFilenameFromID(p_file_id);
   }

string
Sg_File_Info::get_physical_filename() const
   {
     assert (this != NULL);

  // DQ (9/21/2013): The support to return the filename must account for when this is compiler generated, a transformations, part of the front-end, etc.
     const std::string* returnString = NULL;

     if (isTransformation() == true)
        {
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
       else
        {
          if (isCompilerGenerated() == true)
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the filename of the associated file ("rose_edg_required_macros_and_functions.h")
            // This has been fixed to be consistant with the implementation of get_file_id().
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the filename of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnString = &getFilenameFromID(p_physical_file_id);
                  }
                 else
                  {
                    static const std::string compilerGenerated_string = "compilerGenerated";
                    returnString = &compilerGenerated_string;
                  }
             }
            else
             {
               returnString = &getFilenameFromID(p_physical_file_id);
             }
        }

     assert (returnString != NULL);

     return *returnString;
   }

void
Sg_File_Info::set_line(int line)
   {
     assert (this != NULL);

     p_line = line;
     if (isTransformation() || isCompilerGenerated())
        {
          if (line !=0) // Liao, 11/12/2012. get_line() won't return the value being set!!
             {
               mprintf ("warning: Sg_File_Info::set_line() tried to set non-zero line number to a transformation or compiler generated file info obj.\n");
             }
        }
       else
        {
       // DQ (3/19/2017): Note that this is important for Fortran support (where IR nodes frequently
       // start with (isSourcePositionUnavailableInFrontend() == true) and are fixed up afterward.
          if ( isSourcePositionUnavailableInFrontend() == true )
             {
#if 0
               mprintf ("In Sg_File_Info::set_line(): reset isSourcePositionUnavailableInFrontend() to false: line = %d \n",line);
#endif
               unsetSourcePositionUnavailableInFrontend();
             }
        }
   }

int
Sg_File_Info::get_line() const
   {
     assert (this != NULL);

     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
          if ( isCompilerGenerated() == true )
             {
            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
               returnValue = undefinedValue;
             }
            else
             {
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    returnValue = p_line;
                  }
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }


// DQ (2/28/2019): Support for multi-file handling.
int
Sg_File_Info::get_line(int file_id) const
   {
  // Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.

     assert (this != NULL);

     const int undefinedValue = 0;
     int returnValue = 0;

     if (isTransformation() == true)
        {
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
          if ( isCompilerGenerated() == true )
             {
            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
               returnValue = undefinedValue;
             }
            else
             {
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
            // if (isFrontendSpecific() == true || isSourcePositionUnavailableInFrontend() == true )
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    if (file_id == this->get_physical_file_id())
                       {
                         returnValue = p_line;
                       }
                      else
                       {
                      // SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),this->get_physical_file_id());
                         SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),file_id);
                         if (pos != p_fileIDsToUnparse.end())
                            {
#if 0
                              mprintf ("Sg_File_Info::get_line(int): input file is sharing this IR node: input file_id = %d physical_file_id = %d \n",file_id,this->get_physical_file_id());
#endif
                              ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                              ROSE_ASSERT(index >= 0);
                              ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
                              ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
#if 0
                              mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                              ROSE_ASSERT(file_id == p_fileIDsToUnparse[index]);
                              returnValue = p_fileLineNumbersToUnparse[index];
#if 0
                              mprintf (" --- returning returnValue = %d \n",returnValue);
#endif
                            }
                           else
                            {
                           // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                           // This is a reasonable default, if we don't want to make this an error.

                              returnValue = p_line;
                            }
                       }
                  }
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }


int
Sg_File_Info::get_raw_line() const
   {
     assert (this != NULL);
     return p_line;
   }

void
Sg_File_Info::set_physical_line(int line)
   {
     assert (this != NULL);
     p_physical_line = line;
   }

int
Sg_File_Info::get_physical_line(int file_id) const
   {
     assert (this != NULL);

     int returnValue = 0;

  // DQ (2/28/2019): Physical source position information is not supported for Fortran yet (not debugged at least).
     if (SageInterface::is_Fortran_language() )
        {
          returnValue = Sg_File_Info::get_line();
        }
       else
        {
       // returnValue = p_physical_line;
          if (file_id == this->get_physical_file_id())
             {
               returnValue = p_physical_line;
             }
            else
             {
               SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),file_id);
               if (pos != p_fileIDsToUnparse.end())
                  {
#if 0
                    mprintf ("Sg_File_Info::get_physical_line(int): input file is sharing this IR node: input file_id = %d physical_file_id = %d \n",file_id,this->get_physical_file_id());
#endif
                    ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                    ROSE_ASSERT(index >= 0);
                    ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
                    ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
#if 0
                    mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                    ROSE_ASSERT(file_id == p_fileIDsToUnparse[index]);
                    returnValue = p_fileLineNumbersToUnparse[index];
#if 0
                    mprintf (" --- returning returnValue = %d \n",returnValue);
#endif
                  }
                 else
                  {
                 // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                 // This is a reasonable default, if we don't want to make this an error.

                    returnValue = p_physical_line;
                  }
             }
        }

     return returnValue;
   }

int
Sg_File_Info::get_physical_line() const
   {
     assert (this != NULL);
     // PHL (11/25/2013) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
     {
       return Sg_File_Info::get_line();
     }else{
       return p_physical_line;
     }
   }

// DQ (1/23/2013): Added source position sequence information.
// This work supports the handling of default arguments and addes
// new future capabilities to ROSE.
void
Sg_File_Info::set_source_sequence_number (unsigned int n)
   {
     assert (this != NULL);
     p_source_sequence_number = n;
   }

unsigned int
Sg_File_Info::get_source_sequence_number() const
   {
     assert (this != NULL);
     return p_source_sequence_number;
   }

int
Sg_File_Info::get_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
  // return p_col;

  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // mprintf ("Sg_File_Info::get_col called for transformation IR node \n");
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // mprintf ("Sg_File_Info::get_col called for compiler generated IR node \n");
               returnValue = undefinedValue;
             }
            else
             {
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
            // if (isFrontendSpecific() == true || isSourcePositionUnavailableInFrontend() == true )
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    returnValue = p_col;
                  }
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
     return p_col;
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
void
Sg_File_Info::set_isPartOfTransformation( bool isPartOfTransformation )
   {
     assert (this != NULL);
  // p_isPartOfTransformation = isPartOfTransformation;

     if (isPartOfTransformation == true)
          setTransformation();
       else
          unsetTransformation();
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
bool
Sg_File_Info::get_isPartOfTransformation()
   {
     assert (this != NULL);
  // return p_isPartOfTransformation;
     return isTransformation();
   }

void
Sg_File_Info::register_node(SgLocatedNode* node)
   {} /* register interest */

void
Sg_File_Info::deregister_node(SgLocatedNode* node)
   {}

// functions added by Dan Quinlan (suggested by Gary Lee)
void
Sg_File_Info::set_col( int n )
   {
     assert (this != NULL);
     p_col = n;
     assert (p_col >= 0);
   }

bool
Sg_File_Info::hasPositionInSource() const
   {
     ASSERT_not_null(this);
     bool result = ( ! ( isTransformation() || isCompilerGenerated() || isOutputInCodeGeneration() ) );

     return result;
   }

bool
Sg_File_Info::isSameFile(SgFile* file) const
   {
  // This function abstracts the mechanism of comparing if a file info object is associated with a specific SgFile.
  // this function will be made more efficient later when we can abstract out the string comparision from the test.
  // Later we will implement a map from filename to unique "file number identifiers", this will permit significant
  // spaces saving in the IR by avoiding redundant storage of filename strings and also improve the efficiency of
  // testing if two file info objects represent the same file (an integer equality test instead of string comparision).
  // File names are particularly long (since they include full path), so this will allow us to save a lot of space.

     ASSERT_not_null(this);
     ASSERT_not_null(file);

  // DQ (9/5/2008): Use the local Sg_File_Info instead of the one on the root (which is only available for a SgSourceFile)
     Sg_File_Info* fileInfo = file->get_startOfConstruct();
     ASSERT_not_null(fileInfo);

  // DQ (9/17/2013): This function should always refer to physical file data.
     bool result = (this->get_physical_file_id() == fileInfo->get_physical_file_id());

  // DQ (2/27/2019): Adding support for shared IR nodes, so that they can be traversed from AST for each of multiple files.
     if (result == false)
        {
       // Check is this could be a shared file info.
          if (p_fileIDsToUnparse.empty() == false)
             {
#if 0
               mprintf ("Sg_File_Info::isSameFile(SgFile*): p_fileIDsToUnparse.size() = %zu \n",p_fileIDsToUnparse.size());
#endif
            // if (find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),fileInfo->get_physical_file_id()) != p_fileIDsToUnparse.end())
               SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),fileInfo->get_physical_file_id());
               if (pos != p_fileIDsToUnparse.end())
                  {
#if 0
                    mprintf ("Sg_File_Info::isSameFile(SgFile*): input file is sharing this IR node: input file_id = %d \n",fileInfo->get_physical_file_id());
#endif
                    ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                    ROSE_ASSERT(index >= 0);
                    ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
#if 0
                    mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                 // result = true;
                    result = (fileInfo->get_physical_file_id() == p_fileIDsToUnparse[index]);
#if 0
                    mprintf (" --- returning result = %s \n",result ? "true" : "false");
#endif
                  }
             }
        }

     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(Sg_File_Info* fileInfo) const
   {
     assert(fileInfo != NULL);

  // DQ (9/17/2013): This function should always refer to physical file data.
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id()
  // bool result = (p_file_id == fileInfo->get_file_id());
  // bool result = (this->get_file_id() == fileInfo->get_file_id());
     bool result = (this->get_physical_file_id() == fileInfo->get_physical_file_id());

     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(const Sg_File_Info & fileInfo) const
   {
  // DQ (9/17/2013): This function should always refer to physical file data.
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id()
  // bool result = (p_file_id == fileInfo.get_file_id());
  // bool result = (this->get_file_id() == fileInfo.get_file_id());
     bool result = (this->get_physical_file_id() == fileInfo.get_physical_file_id());

     return result;
   }

//! Access functions for classification of File_Info objects
bool
Sg_File_Info::isTransformation() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_transformation);
   }

void
Sg_File_Info::setTransformation()
   {
     assert(this != NULL);
     p_classificationBitField |= e_transformation;

#if 0
  // DQ (7/13/2021): Added debugging code.
     static int counter = 0;

     SgNode* parent = this->get_parent();
     if (parent != NULL)
        {
          SgCastExp* castExpression = isSgCastExp(parent);
          if (castExpression != NULL)
             {
               printf ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \n");
               printf ("In Sg_File_Info::setTransformation(): Found SgCastExp %p counter = %d \n",castExpression,counter);
               printf ("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX \n");
             }
            else
             {
               printf ("In Sg_File_Info::setTransformation(): !SgCastExp: parent = %p = %s counter = %d \n",parent,parent->class_name().c_str(),counter);
             }
        }
       else
        {
          printf ("In Sg_File_Info::setTransformation(): parent == NULL: counter = %d \n",counter);
        }

     counter++;
#endif
   }

void
Sg_File_Info::unsetTransformation()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_transformation;
   }

bool
Sg_File_Info::isCompilerGenerated() const
   {
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::isCompilerGenerated(): this = %p \n",this);
#endif

     return (p_classificationBitField & e_compiler_generated);
   }

void
Sg_File_Info::setCompilerGenerated()
   {
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::setCompilerGenerated(): this = %p \n",this);
#endif

     p_classificationBitField |= e_compiler_generated;
   }

void
Sg_File_Info::unsetCompilerGenerated()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_compiler_generated;
   }

// bool isCompilerGeneratedNodeToBeUnparsed() const;
bool
Sg_File_Info::isCompilerGeneratedNodeToBeUnparsed() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);
   }

void
Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed(): this = %p \n",this);
#endif

     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetCompilerGeneratedNodeToBeUnparsed()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation;
   }

bool
Sg_File_Info::isOutputInCodeGeneration() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);
   }

void
Sg_File_Info::setOutputInCodeGeneration()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);

#if 0
     mprintf ("In setOutputInCodeGeneration(): this = %p parent = %p \n",this,this->get_parent());
#endif

  // DQ (5/19/2013): Testing...debugging test2013_171.C.
  // ROSE_ASSERT(isSgNamespaceDefinitionStatement(this->get_parent()) == NULL);

     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetOutputInCodeGeneration()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation;
   }

bool
Sg_File_Info::isShared() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_shared);
   }

void
Sg_File_Info::setShared()
   {
  // MK (8/3/05) : We always want to unparse the current file (this is a performance issue)
     assert(this != NULL);
  // DQ (10/27/2007): Make sure this is a valid file that we are trying to share.
  // I am unclear as to how important this is.
     int temp_file_id = this->get_file_id();
     if (temp_file_id < 0)
        {
          if (SgProject::get_verbose() > 0)
               mprintf ("Warning: trying to share file id = %d < 0 \n",temp_file_id);
        }
     p_classificationBitField |= e_shared;
   }

void
Sg_File_Info::unsetShared()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_shared;
   }

bool
Sg_File_Info::isFrontendSpecific() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_frontend_specific);
   }

void
Sg_File_Info::setFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField |= e_frontend_specific;
   }

void
Sg_File_Info::unsetFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_frontend_specific;
   }

bool
Sg_File_Info::isSourcePositionUnavailableInFrontend() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_source_position_unavailable_in_frontend);
   }

void
Sg_File_Info::setSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField |= e_source_position_unavailable_in_frontend;

#if 0
  // DQ (8/3/2012): We don't want to use this unless absolutely required; so output a message to support debugging.
     mprintf ("In Sg_File_Info::setSourcePositionUnavailableInFrontend() \n");
#endif
   }

void
Sg_File_Info::unsetSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_source_position_unavailable_in_frontend;

#if 0
  // DQ (8/3/2012): We don't want to use this unless absolutely required; so output a message to support debugging.
     mprintf ("In Sg_File_Info::unsetSourcePositionUnavailableInFrontend() \n");
#endif
   }

bool
Sg_File_Info::isCommentOrDirective() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_comment_or_directive);
   }

void
Sg_File_Info::setCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField |= e_comment_or_directive;
   }

void
Sg_File_Info::unsetCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_comment_or_directive;
   }

bool
Sg_File_Info::isToken() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_token);
   }

void
Sg_File_Info::setToken()
   {
     assert(this != NULL);
     p_classificationBitField |= e_token;
   }

void
Sg_File_Info::unsetToken()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_token;
   }

// DQ (4/24/2013): Added support for marking as default argument.  Note that compiler generated is not specific
// enough because even implicit casts would then be confused as default arguments.
bool
Sg_File_Info::isDefaultArgument() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_default_argument);
   }

void
Sg_File_Info::unsetDefaultArgument()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_default_argument;
   }

void
Sg_File_Info::setDefaultArgument()
   {
     assert(this != NULL);
     p_classificationBitField |= e_default_argument;
   }

// DQ (4/26/2013): Added support for marking as implicit casts.  Note that compiler generated is not
// as specific as we want (though it has worked for a long time, we want a more precise mechanism).
bool
Sg_File_Info::isImplicitCast() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_implicit_cast);
   }

void
Sg_File_Info::unsetImplicitCast()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_implicit_cast;
   }

void
Sg_File_Info::setImplicitCast()
   {
     assert(this != NULL);
     p_classificationBitField |= e_implicit_cast;
   }




// MK (8/2/05) : Implementation for function to handle unparsing of particular files
void
Sg_File_Info::addFileToUnparse(int file_id)
   {
     assert(this != NULL);

  // DQ (2/27/2019): Debugging how this is getting out of sync with the list of line numbers for multi-file handling.
     mprintf ("Error: In Sg_File_Info::addFileToUnparse(): I think this function should not be called \n");
     ROSE_ASSERT(false);

     p_fileIDsToUnparse.push_back(file_id);
   }

bool
Sg_File_Info::shouldUnparse(int file_id)
   {
     assert(this != NULL);
     return std::find(p_fileIDsToUnparse.begin(), p_fileIDsToUnparse.end(), file_id) != p_fileIDsToUnparse.end();
   }

unsigned int
Sg_File_Info::get_classificationBitField(void) const
   {
     assert(this != NULL);
     return p_classificationBitField;
   }

void
Sg_File_Info::set_classificationBitField( unsigned int bitflags )
   {
     assert(this != NULL);
     p_classificationBitField = bitflags;
   }

// MK (8/2/05): Added implementations for static functions to support interface to fileid maps
const string&
Sg_File_Info::getFilenameFromID(int id)
   {
  // This is a static function

     const std::string* name = NULL;
     switch(id)
        {
       // special cases
          case NULL_FILE_ID:
             {
               static const std::string null_file_string =  "NULL_FILE";
               name = &null_file_string;
               break;
             }
          case COPY_FILE_ID:
             {
               static const std::string copy_file_string  = "COPY";
               name = &copy_file_string;
               break;
             }
          case TRANSFORMATION_FILE_ID:
             {
               static const std::string transformation_string = "transformation";
               name = &transformation_string;
               break;
             }
          case COMPILER_GENERATED_FILE_ID:
             {
               static const std::string compilerGenerated_string = "compilerGenerated";
               name = &compilerGenerated_string;
               break;
             }
          case COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID:
             {
            // name = "compilerGenerated";
               mprintf ("The concept of COMPILER_GENERATED and OUTPUT are now decoupled, so make this an error \n");
               assert(false);
               break;
             }
          case BAD_FILE_ID:
             {
               static const std::string badfile_string = "badfile";
               name = &badfile_string;
               break;
             }

       // normal case
          default:
             {
            // assert that the id is present in the map (else error)
            // assert(p_fileidtoname_map.count(id) != 0);
               bool failure = (p_fileidtoname_map.count(id) == 0);
               if (failure == true)
                  {
                    mprintf ("Error: bad id number for file id (id = %d) \n",id);

                    display_static_data("error in getFilenameFromID");

                 // Note: this causes an empty entry to be generated in p_fileidtoname_map for the id == p_max_file_id (value of max map size
                  }
               ROSE_ASSERT(failure == false);

            // get the filename from the map using the valid id
               name = &p_fileidtoname_map[id];
             }
        }

     return *name;
   }

int
Sg_File_Info::getIDFromFilename( std::string filename )
   {
  // This is a static function
     if (p_nametofileid_map.count(filename) == 0)
        {
          return BAD_FILE_ID;
        }

     return p_nametofileid_map[filename];
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<int, std::string> &
Sg_File_Info::get_fileidtoname_map()
   {
     return p_fileidtoname_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_fileidtoname_map(std::map<int, std::string> & X)
   {
     p_fileidtoname_map = X;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<std::string, int> &
Sg_File_Info::get_nametofileid_map()
   {
     return p_nametofileid_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_nametofileid_map(std::map<std::string,int> & X)
   {
     p_nametofileid_map = X;
   }

SOURCE_FILE_INFORMATION_END


SOURCE_APPLICATION_FILE_START

// DQ (5/23/2015): Add static data member declaration.
bool SgFile::p_skip_unparse_asm_commands = false;

// DQ (4/24/2021): Add static data member declaration.
bool SgFile::p_header_file_unparsing_optimization = false;

// std::string SgFile::get_outputLanguageOptionName ( SgFile::outputLanguageOption_enum lang )
std::string
SgFile::get_outputLanguageOptionName ( SgFile::languageOption_enum lang )
   {
     string s;
     switch (lang)
        {
          case SgFile::e_error_language:   s = "error";   break;
          case SgFile::e_default_language: s = "default"; break;
          case SgFile::e_C_language:       s = "C";       break;
          case SgFile::e_Cxx_language:     s = "C++";     break;
          case SgFile::e_Binary_language:  s = "Binary";  break;
          case SgFile::e_Fortran_language: s = "Fortran"; break;
          case SgFile::e_Java_language:    s = "Java";    break;
          case SgFile::e_Jvm_language:     s = "JVM";     break;
          case SgFile::e_PHP_language:     s = "PHP";     break;
          case SgFile::e_Python_language:  s = "Python";  break;
          case SgFile::e_Csharp_language:  s = "Csharp";  break;
          case SgFile::e_Ada_language:     s = "Ada";     break;
          case SgFile::e_Jovial_language:  s = "Jovial";  break;
          case SgFile::e_Promela_language: s = "Promela"; break;

          default:
             {
               mprintf ("In SgFile::outputLanguageOption(): lang = %" PRIuPTR " \n",(size_t)lang);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

int SgFile::buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine )
   {
     mprintf ("Base class of virtual function, SgFile::buildAST(), called by mistake! \n");
     ROSE_ASSERT(false);

  // tps (12/11/2009): Windows error : needs a return value
     return 0;
   }

Sg_File_Info*
SgFile::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgFile::set_file_info( Sg_File_Info* fileinfo )
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     set_startOfConstruct(fileinfo);
   }

std::string
SgFile::getFileName() const
   {
  // Get the filename from the Sage III file object
     ASSERT_not_null(this);

     Sg_File_Info* fileInfo = p_startOfConstruct;
     ASSERT_not_null(fileInfo);

  // DQ (8/16/2018): I think we want to original filename as constructed and reported by the
  // get_raw_filename() function, since if the statement is transformed as a file we don't what
  // the name "transformation".
     std::string fileName = fileInfo->get_raw_filename();

     return fileName;
   }

SgFile::SgFile(int &argc, char** &argv, SgProject* project)
   : SgFile()
   {
     assert (argv && argc >= 0);

  // Note use of pointer arithmetic in the computation of "argv + argc", this is standard STL fair.
     doSetupForConstructor(vector<string>(argv, argv + argc),  project);
   }

SgFile::SgFile(vector<string> &argv, SgProject* project)
   : SgFile()
   {
     doSetupForConstructor(argv, project);
   }


#include <Rose/BinaryAnalysis/Disassembler/Base.h>

enum SgFile::standard_enum SgFile::get_standard(void) const { return p_standard; }
void SgFile::set_standard(enum standard_enum e_std) { p_standard = e_std; }
void SgFile::set_default_standard(void) { p_standard = e_default_standard; }

// DQ (1/10/2019): Add way to output a string to report standard in debug messages.
std::string SgFile::display_standard(enum standard_enum e_std)
   {
     string s;

     switch (e_std)
        {
          case e_default_standard: s = "e_default_standard"; break;
          case e_c89_standard: s = "e_c89_standard"; break;
          case e_c90_standard: s = "e_c90_standard"; break;
          case e_c99_standard: s = "e_c99_standard"; break;
          case e_c11_standard: s = "e_c11_standard"; break;
          case e_c17_standard: s = "e_c17_standard"; break;
          case e_c23_standard: s = "e_c23_standard"; break;
          case e_c2y_standard: s = "e_c2y_standard"; break;
          case e_upc_standard: s = "e_upc_standard"; break;
          case e_cxx98_standard: s = "e_cxx98_standard"; break;
          case e_cxx03_standard: s = "e_cxx03_standard"; break;
          case e_cxx11_standard: s = "e_cxx11_standard"; break;
          case e_cxx14_standard: s = "e_cxx14_standard"; break;
          case e_cxx17_standard: s = "e_cxx17_standard"; break;
          case e_cxx20_standard: s = "e_cxx20_standard"; break;
          case e_cxx23_standard: s = "e_cxx23_standard"; break;
          case e_cxx26_standard: s = "e_cxx26_standard"; break;
          case e_upcxx_standard: s = "e_upcxx_standard"; break;
          case e_f77_standard: s = "e_f77_standard"; break;
          case e_f90_standard: s = "e_f90_standard"; break;
          case e_f95_standard: s = "e_f95_standard"; break;
          case e_f03_standard: s = "e_f03_standard"; break;
          case e_f08_standard: s = "e_f08_standard"; break;
          case e_f18_standard: s = "e_f18_standard"; break;

          default:
             {
               printf ("Error default reached in switch: SgFile::display_standard(): e_std = %x \n",e_std);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

bool SgFile::is_gnu_standard(void) const { return p_gnu_standard; }
void SgFile::set_gnu_standard(void) { p_gnu_standard = true; }
void SgFile::unset_gnu_standard(void) { p_gnu_standard = false; }

bool SgFile::get_C89_only (void) const { return p_standard == e_c89_standard; }
void SgFile::set_C89_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c89_standard; }

bool SgFile::get_C89_gnu_only (void) const { return p_standard == e_c89_standard && p_gnu_standard; }
void SgFile::set_C89_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c89_standard; p_gnu_standard = true; }

bool SgFile::get_C90_only (void) const { return p_standard == e_c90_standard; }
void SgFile::set_C90_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c90_standard; }

bool SgFile::get_C90_gnu_only (void) const { return p_standard == e_c90_standard && p_gnu_standard; }
void SgFile::set_C90_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c90_standard; p_gnu_standard = true; }

bool SgFile::get_C99_only (void) const { return p_standard == e_c99_standard; }
void SgFile::set_C99_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c99_standard; }

bool SgFile::get_C99_gnu_only (void) const { return p_standard == e_c99_standard && p_gnu_standard; }
void SgFile::set_C99_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c99_standard; p_gnu_standard = true; }

bool SgFile::get_C11_only (void) const { return p_standard == e_c11_standard; }
void SgFile::set_C11_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c11_standard; }

bool SgFile::get_C11_gnu_only (void) const { return p_standard == e_c11_standard && p_gnu_standard; }
void SgFile::set_C11_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c11_standard; p_gnu_standard = true; }

bool SgFile::get_C17_only (void) const { return p_standard == e_c17_standard; }
void SgFile::set_C17_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c17_standard; }

bool SgFile::get_C17_gnu_only (void) const { return p_standard == e_c17_standard && p_gnu_standard; }
void SgFile::set_C17_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c17_standard; p_gnu_standard = true; }

bool SgFile::get_C23_only (void) const { return p_standard == e_c23_standard; }
void SgFile::set_C23_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c23_standard; }

bool SgFile::get_C23_gnu_only (void) const { return p_standard == e_c23_standard && p_gnu_standard; }
void SgFile::set_C23_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c23_standard; p_gnu_standard = true; }

bool SgFile::get_C2y_only (void) const { return p_standard == e_c2y_standard; }
void SgFile::set_C2y_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c2y_standard; }

bool SgFile::get_C2y_gnu_only (void) const { return p_standard == e_c2y_standard && p_gnu_standard; }
void SgFile::set_C2y_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c2y_standard; p_gnu_standard = true; }

bool SgFile::get_UPC_only (void) const { return p_standard == e_upc_standard; }
void SgFile::set_UPC_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_upc_standard; }

bool SgFile::get_Cxx98_only (void) const { return p_standard == e_cxx98_standard; }
void SgFile::set_Cxx98_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx98_standard; }

bool SgFile::get_Cxx98_gnu_only (void) const { return p_standard == e_cxx98_standard && p_gnu_standard; }
void SgFile::set_Cxx98_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx98_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx03_only (void) const { return p_standard == e_cxx03_standard; }
void SgFile::set_Cxx03_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx03_standard; }

bool SgFile::get_Cxx03_gnu_only (void) const { return p_standard == e_cxx03_standard && p_gnu_standard; }
void SgFile::set_Cxx03_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx03_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx11_only (void) const { return p_standard == e_cxx11_standard; }
void SgFile::set_Cxx11_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx11_standard; }

bool SgFile::get_Cxx11_gnu_only (void) const { return p_standard == e_cxx11_standard && p_gnu_standard; }
void SgFile::set_Cxx11_gnu_only (void) {set_C_only(false); set_Cxx_only(true); p_standard = e_cxx11_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx14_only (void) const { return p_standard == e_cxx14_standard; }
void SgFile::set_Cxx14_only (void) {set_C_only(false); set_Cxx_only(true);  p_standard = e_cxx14_standard; }

bool SgFile::get_Cxx14_gnu_only (void) const { return p_standard == e_cxx14_standard && p_gnu_standard; }
void SgFile::set_Cxx14_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx14_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx17_only (void) const { return p_standard == e_cxx17_standard; }
void SgFile::set_Cxx17_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx17_standard; }

bool SgFile::get_Cxx17_gnu_only (void) const { return p_standard == e_cxx17_standard && p_gnu_standard; }
void SgFile::set_Cxx17_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx17_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx20_only (void) const { return p_standard == e_cxx20_standard; }
void SgFile::set_Cxx20_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx20_standard; }

bool SgFile::get_Cxx20_gnu_only (void) const { return p_standard == e_cxx20_standard && p_gnu_standard; }
void SgFile::set_Cxx20_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx20_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx23_only (void) const { return p_standard == e_cxx23_standard; }
void SgFile::set_Cxx23_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx23_standard; }

bool SgFile::get_Cxx23_gnu_only (void) const { return p_standard == e_cxx23_standard && p_gnu_standard; }
void SgFile::set_Cxx23_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx23_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx26_only (void) const { return p_standard == e_cxx26_standard; }
void SgFile::set_Cxx26_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx26_standard; }

bool SgFile::get_Cxx26_gnu_only (void) const { return p_standard == e_cxx26_standard && p_gnu_standard; }
void SgFile::set_Cxx26_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx26_standard; p_gnu_standard = true; }

bool SgFile::get_UPCxx_only (void) const { return p_standard == e_upcxx_standard; }
void SgFile::set_UPCxx_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_upcxx_standard; }

bool SgFile::get_F77_only     (void) const { return p_standard == e_f77_standard; }
void SgFile::set_F77_only     (void) { set_Fortran_only(true); p_standard = e_f77_standard; }

bool SgFile::get_F90_only     (void) const { return p_standard == e_f90_standard; }
void SgFile::set_F90_only     (void) { set_Fortran_only(true); p_standard = e_f90_standard; }

bool SgFile::get_F95_only     (void) const { return p_standard == e_f95_standard; }
void SgFile::set_F95_only     (void) { set_Fortran_only(true); p_standard = e_f95_standard; }

bool SgFile::get_F2003_only   (void) const { return p_standard == e_f03_standard; }
void SgFile::set_F2003_only   (void) { set_Fortran_only(true); p_standard = e_f03_standard; }

bool SgFile::get_F2008_only   (void) const { return p_standard == e_f08_standard; }
void SgFile::set_F2008_only   (void) { set_Fortran_only(true); p_standard = e_f08_standard; }

bool SgFile::get_F2018_only   (void) const { return p_standard == e_f18_standard; }
void SgFile::set_F2018_only   (void) { set_Fortran_only(true); p_standard = e_f18_standard; }

// int SgFile::compileOutput ( int fileNameIndex, const std::string& compilerName )
int
SgFile::compileOutput ( int fileNameIndex )
   {
  // Compile the output file from the unparing
     vector<string> argv = get_originalCommandLineArgumentList();
     assert(!argv.empty());

  // DQ (4/21/2006): I think we can now assert this! This is an unused function parameter!
     assert(fileNameIndex == 0);

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);

  // error checking
     assert (argv.size() > 1);

  // BP : 10/31/2001, strip out any rose options before passing the command line.
     stripRoseCommandLineOptions( argv );

     if (get_C_only() || get_Cxx_only() || get_Fortran_only() )
        {
          stripEdgCommandLineOptions( argv );
        }

  // Pei-Hung: 12/20/2021, strip out options for frontend parsing.  Needed by ada2cpp
     if (get_Cxx_only())
        {
          stripTranslationCommandLineOptions( argv );
        }

     if (get_Fortran_only())
        {
          stripFortranCommandLineOptions( argv );
        }

  // Call the compile
     int errorCode = compileOutput ( argv, fileNameIndex );

     return errorCode;
   }

SgProject*
SgFile::get_project()
   {
  // If the project is a parent of the current SgFile then we find it, else return NULL.
     SgNode* parent = get_parent();
     SgProject* project = NULL;

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // Just return NULL in this case!
     if (parent)
        {
          project = isSgProject(parent);
          while ( project == nullptr && parent->get_parent() != nullptr )
             {
               parent = parent->get_parent();
               ASSERT_not_null(parent);
               project = isSgProject(parent);
             }
          ASSERT_not_null(project);
        }

     return project;
   }

#ifdef _MSC_VER
#include <direct.h>   // getcwd()
#endif

 //! get the current directory
string
SgFile::getWorkingDirectory ()
   {
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

// CH (4/8/2010): "direct.h" in MSVC provides getcwd()
     char* returnString = getcwd(currentDirectory,maxPathNameLength - 1);
     assert (returnString != NULL);
     currentDirectory[maxPathNameLength - 1] = 0; // Just in case

  // live with the possible memory leak for now
  // delete currentDirectory;
     currentDirectory = NULL;

     return returnString;
   }

//! get the source directory
string
SgFile::getSourceDirectory ()
   {
     string sourceFile = get_sourceFileNameWithPath();
     assert(sourceFile.empty() == false);
     return Rose::StringUtility::getPathFromFileName(sourceFile);
   }


string
SgFile::generateOutputFileName() const
   {
  // DQ (10/16/2005): This function abstracts the generation of an
  // output file name from the source file name.

     std::string sourceFileName = get_sourceFileNameWithPath();
     std::string baseFileName    = Rose::StringUtility::stripPathFromFileName(sourceFileName);
     std::string baseFileNameWithoutSuffix = Rose::StringUtility::stripFileSuffixFromFileName(baseFileName);
     std::string objectFileName;

#ifndef USE_ORIGINAL_SOURCE_FILE_NAME_IN_PRELINKING

  // DQ (8/12/2007): I think this was part of the prelinker which is not no longer used!
  // mprintf ("isPrelinkPhase() = %s \n",isPrelinkPhase() ? "true" : "false");
     assert(isPrelinkPhase() == false);

     if (isPrelinkPhase() == true)
        {
       // test for leading "rose_" prefix in name (it should be present)
          assert(baseFileName.find("rose_") == 0);
       // and remove it since we want the unmodified file name to be used as a name of the object file!
          baseFileName.erase(0,5);

       // test for leading "rose_" prefix in name (it should NOT be present now)
          assert(baseFileName.find("rose_") == std::string::npos);
        }
#endif

  // DQ (4/2/2011): Added support for Java.
     if (get_Java_only() == true)
        {
       // Java output files are *.class files.
          objectFileName = baseFileNameWithoutSuffix + ".class";
        }
       else
        {
       // DQ (8/12/2007): Newer simpler code, made possible because of better internal support.
       // This version is also now language independent and so supports the Fortran work.
          objectFileName = baseFileNameWithoutSuffix + ".o";
        }

  // DQ (1/26/2022): Need to enforce consistancy of the output object file path and the output object file.
     if (get_objectFileNameWithoutPath() != "")
        {
          if (get_objectFileNameWithPath() == "")
             {
               mprintf ("NOTE: both objectFileNameWithPath and objectFileNameWithoutPath must be set consistantly \n");
               mprintf (" --- get_objectFileNameWithoutPath() = %s \n",get_objectFileNameWithoutPath().c_str());
               mprintf (" --- get_objectFileNameWithPath()    = %s \n",get_objectFileNameWithPath().c_str());
             }
        }
       else
        {
          if (get_objectFileNameWithPath() != "")
             {
               mprintf ("NOTE: both objectFileNameWithPath and objectFileNameWithoutPath must be set consistantly \n");
               mprintf (" --- get_objectFileNameWithoutPath() = %s \n",get_objectFileNameWithoutPath().c_str());
               mprintf (" --- get_objectFileNameWithPath()    = %s \n",get_objectFileNameWithPath().c_str());
             }
        }


     std::string specified_objectFileName = get_objectFileNameWithoutPath();
     if (specified_objectFileName.length() == 0)
        {
#if 0
          printf (" --- get_objectFileNameWithoutPath() returned empty string, using generateOutputFileName(): objectFileName = %s \n",objectFileName.c_str());
#endif
        }
       else
        {
#if 0
          printf (" --- using value from get_objectFileNameWithoutPath(): objectFileName = %s \n",objectFileName.c_str());
#endif
          objectFileName = specified_objectFileName;
        }

  // mprintf ("At base of SgFile::generateOutputFileName(): objectFileName = %s \n",objectFileName.c_str());
  // display("In SgFile::generateOutputFileName()");

     return objectFileName;
   }

// DQ (3/18/2006): Modified interface to allow specification of pointer to user
// defined UnparseFormatHelp object (to control code generation).
// DQ (8/20/2005): Removed default parameter from extern function declaration
// Liao (2/8/2008): Removed default parameters due to conflicts with src/backend/unparser/unparser.h

void
SgFile::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
  // DQ (1/24/2010): This call to the timer has been moved to the unparseFile() function.
  // DQ (7/12/2005): Introduce tracking of performance of ROSE.
  // TimingPerformance timer ("AST Code Generation (unparsing):");

  // Call the unparser mechanism
  // DQ (1/24/2010): Moved the extern declaration for unparseFile() to be local to this function (better code design).
     extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */, SgScopeStatement* unparseScope /* = NULL */);
     unparseFile ( this, unparseFormatHelp, unparseDelegate, NULL );
   }

// DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information)
// to be relative to the generated code instead of the original input code.  This is useful when
// we want to output references to the position of language constructs in the generated code
// instead of the original input code.  Also useful for building references to locations in
// automatically generated code.
void
SgFile::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     extern void resetSourcePositionToGeneratedCode( SgFile* file, UnparseFormatHelp *unparseHelp );
     resetSourcePositionToGeneratedCode( this, unparseFormatHelp );
   }

void
SgFile::display ( const std::string & label ) const
   {
  // This function prints out the member data values within the object

  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("\nIn SgFile::display(%s) \n",label.c_str());

     mprintf ("Output the SgFile::p_startOfConstruct object = %p \n",get_startOfConstruct());
     assert (get_startOfConstruct() != NULL);
     get_startOfConstruct()->display("Called from SgFile::display");

     printf ("     p_verbose                                   = %s (value=%d) \n",(p_verbose > 1) ? "true" : "false",p_verbose);

     printf ("     p_output_warnings                           = %s \n",(p_output_warnings == true) ? "true" : "false");

     printf ("     p_C_only()                                  = %s \n",(p_C_only == true)   ? "true" : "false");
     printf ("     p_upc_threads                               = %s (value=%d) \n",  (p_upc_threads > 1) ? "true" : "false",p_upc_threads);

  // DQ (3/28/2013): Added support to specify C89 support, so that default can be C99 support (same as EDG3x branch).
     printf ("     p_Cxx_only()                                = %s \n",(p_Cxx_only == true) ? "true" : "false");
     printf ("     p_Java_only()                               = %s \n",(p_Java_only == true) ? "true" : "false");
     printf ("     p_Jvm_only()                                = %s \n",(p_Jvm_only == true) ? "true" : "false");
     printf ("     p_Fortran_only()                            = %s \n",(p_Fortran_only == true) ? "true" : "false");
     printf ("     p_CoArrayFortran_only()                     = %s \n",(p_CoArrayFortran_only == true) ? "true" : "false");
     printf ("     p_PHP_only()                                = %s \n",(p_PHP_only == true) ? "true" : "false");
     printf ("     p_Python_only()                             = %s \n",(p_Python_only == true) ? "true" : "false");

  // DQ (8/25/2017): Added more language support.
     printf ("     p_Csharp_only()                             = %s \n",(p_Csharp_only == true) ? "true" : "false");
     printf ("     p_Ada_only()                                = %s \n",(p_Ada_only == true) ? "true" : "false");
     printf ("     p_Jovial_only()                             = %s \n",(p_Jovial_only == true) ? "true" : "false");

     printf ("     p_requires_C_preprocessor                   = %s \n",(p_requires_C_preprocessor == true) ? "true" : "false");

  // DQ (2/5/2009): Putting this back now, so we have one at the SgProject and one at the SgFile.
     printf ("     p_binary_only()                             = %s \n",(p_binary_only == true) ? "true" : "false");
     printf ("     p_isObjectFile()                            = %s \n",(p_isObjectFile == true) ? "true" : "false");

     string inputFormatName;
     switch(p_inputFormat)
        {
          case SgFile::e_unknown_output_format:    inputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: inputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  inputFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_inputFormat = %d \n",p_inputFormat);
               assert(false);
             }
        }

     printf ("     p_inputFormat                               = %s input format \n",inputFormatName.c_str());

     string outputFormatName;
     switch(p_outputFormat)
        {
          case SgFile::e_unknown_output_format:    outputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: outputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  outputFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_outputFormat = %d \n",p_outputFormat);
               assert(false);
             }
        }

     printf ("     p_outputFormat                              = %s output format \n",outputFormatName.c_str());

     string backendCompileFormatName;
     switch(p_backendCompileFormat)
        {
          case SgFile::e_unknown_output_format:    backendCompileFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: backendCompileFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  backendCompileFormatName = "free";  break;

          default:
             {
               printf ("Error: default reached p_backendCompileFormat = %d \n",p_backendCompileFormat);
               assert(false);
             }
        }

     printf ("     p_backendCompileFormat                      = %s output format \n",backendCompileFormatName.c_str());

     printf ("     p_fortran_implicit_none                     = %s \n",(p_fortran_implicit_none == true) ? "true" : "false");
     printf ("     p_openmp                                    = %s \n",(p_openmp == true) ? "true" : "false");
     printf ("     p_cray_pointer_support                      = %s \n",(p_cray_pointer_support == true) ? "true" : "false");
     printf ("     p_output_parser_actions                     = %s \n",(p_output_parser_actions == true) ? "true" : "false");
     printf ("     p_exit_after_parser                         = %s \n",(p_exit_after_parser == true) ? "true" : "false");

     printf ("     p_skip_syntax_check                         = %s \n",(p_skip_syntax_check      == true) ? "true" : "false");
     printf ("     p_skip_translation_from_edg_ast_to_rose_ast = %s \n",(p_skip_translation_from_edg_ast_to_rose_ast == true) ? "true" : "false");
     printf ("     p_skip_transformation                       = %s \n",(p_skip_transformation    == true) ? "true" : "false");
     printf ("     p_skip_unparse                              = %s \n",(p_skip_unparse           == true) ? "true" : "false");
     printf ("     p_skipfinalCompileStep                      = %s \n",(p_skipfinalCompileStep   == true) ? "true" : "false");

     printf ("     p_unparse_includes                          = %s \n",(p_unparse_includes                     == true) ? "true" : "false");
     printf ("     p_unparse_line_directives                   = %s \n",(p_unparse_line_directives              == true) ? "true" : "false");

  // DQ (4/14/2013): Added options to permit selection of either overloaded operator names or use of operator syntax
  // for function calls in the unparsed code.  The default is to reproduce the same use as in the input code.
     printf ("     p_unparse_function_calls_using_operator_syntax = %s \n",(p_unparse_function_calls_using_operator_syntax == true) ? "true" : "false");
     printf ("     p_unparse_function_calls_using_operator_names  = %s \n",(p_unparse_function_calls_using_operator_names  == true) ? "true" : "false");

     printf ("     p_unparse_instruction_addresses             = %s \n",(p_unparse_instruction_addresses        == true) ? "true" : "false");
     printf ("     p_unparse_raw_memory_contents               = %s \n",(p_unparse_raw_memory_contents          == true) ? "true" : "false");
     printf ("     p_unparse_binary_file_format                = %s \n",(p_unparse_binary_file_format           == true) ? "true" : "false");

     string outputLanguageName = get_outputLanguageOptionName(p_outputLanguage);

     printf ("     p_outputLanguage                            = %s output language \n",outputLanguageName.c_str());

     printf ("     p_sourceFileNameWithPath                    = %s \n",p_sourceFileNameWithPath.c_str());
     printf ("     p_sourceFileNameWithoutPath                 = %s \n",p_sourceFileNameWithoutPath.c_str());
     printf ("     p_unparse_output_filename                   = %s \n",p_unparse_output_filename.c_str());

     printf ("     p_useBackendOnly                            = %s \n",(p_useBackendOnly == true) ? "true" : "false");
     printf ("     p_compileOnly                               = %s \n",(p_compileOnly  == true) ? "true" : "false");

     printf ("     p_savedFrontendCommandLine                  = %s \n",p_savedFrontendCommandLine.c_str());

     printf ("     p_no_implicit_templates                     = %s \n",(p_no_implicit_templates == true) ? "true" : "false");
     printf ("     p_no_implicit_inline_templates              = %s \n",(p_no_implicit_inline_templates == true) ? "true" : "false");
     printf ("     p_skip_commentsAndDirectives                = %s \n",(p_skip_commentsAndDirectives == true) ? "true" : "false");
     printf ("     p_collectAllCommentsAndDirectives           = %s \n",(p_collectAllCommentsAndDirectives == true) ? "true" : "false");
     printf ("     p_unparseHeaderFiles                        = %s \n",(p_unparseHeaderFiles == true) ? "true" : "false");

     printf ("     p_preprocessorDirectivesAndCommentsList is %s pointer \n",(p_preprocessorDirectivesAndCommentsList != NULL) ? "VALID" : "NULL");

     printf ("     p_KCC_frontend                              = %s \n",(p_KCC_frontend                         == true) ? "true" : "false");
     printf ("     p_new_frontend                              = %s \n",(p_new_frontend                         == true) ? "true" : "false");
     printf ("     p_disable_edg_backend                       = %s \n",(p_disable_edg_backend                  == true) ? "true" : "false");
     printf ("     p_disable_sage_backend                      = %s \n",(p_disable_sage_backend                 == true) ? "true" : "false");
     printf ("     p_testingLevel                              = %d \n",p_testingLevel);

     printf ("     p_preinit_il                                = %s \n",(p_preinit_il                           == true) ? "true" : "false");
     printf ("     p_enable_cp_backend                         = %s \n",(p_enable_cp_backend                    == true) ? "true" : "false");

     printf ("     p_markGeneratedFiles                        = %s \n",(p_markGeneratedFiles == true) ? "true" : "false");
     printf ("     p_negative_test                             = %s \n",(p_negative_test == true) ? "true" : "false");
     printf ("     p_strict_language_handling                  = %s \n",(p_strict_language_handling == true) ? "true" : "false");
     printf ("     p_wave                                      = %s \n",(p_wave == true) ? "true" : "false");
     printf ("     p_embedColorCodesInGeneratedCode            = %s \n",(p_embedColorCodesInGeneratedCode == true) ? "true" : "false");
     printf ("     p_generateSourcePositionCodes               = %s \n",(p_generateSourcePositionCodes == true) ? "true" : "false");
     printf ("     p_sourceFileUsesCppFileExtension            = %s \n",(p_sourceFileUsesCppFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortranFileExtension        = %s \n",(p_sourceFileUsesFortranFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran77FileExtension      = %s \n",(p_sourceFileUsesFortran77FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran90FileExtension      = %s \n",(p_sourceFileUsesFortran90FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesFortran95FileExtension      = %s \n",(p_sourceFileUsesFortran95FileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesPHPFileExtension            = %s \n",(p_sourceFileUsesPHPFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesJavaFileExtension           = %s \n",(p_sourceFileUsesJavaFileExtension == true) ? "true" : "false");
     printf ("     p_sourceFileUsesBinaryFileExtension         = %s \n",(p_sourceFileUsesBinaryFileExtension == true) ? "true" : "false");
     printf ("     p_read_executable_file_format_only          = %s \n",(p_read_executable_file_format_only == true) ? "true" : "false");
     printf ("     p_read_instructions_only                    = %s \n",(p_read_instructions_only == true) ? "true" : "false");

     printf ("     p_unparse_tokens                            = %s \n",(p_unparse_tokens == true) ? "true" : "false");
     printf ("     p_unparse_tokens_testing                    = %d \n",p_unparse_tokens_testing);

  // DQ (11/12/2014): Addded to support test modes for token unparsing.
     printf ("     p_unparse_using_leading_and_trailing_token_mappings = %s \n",(p_unparse_using_leading_and_trailing_token_mappings == true) ? "true" : "false");

     printf ("     p_detect_dangling_pointers                  = %d \n",p_detect_dangling_pointers);

     printf ("     p_skipAstConsistancyTests                   = %s \n",(p_skipAstConsistancyTests == true) ? "true" : "false");

  // Rasmussen (9/10/2022): Replaced experimental_fortran_frontend with experimental_flang_frontend (removing ATerm usage).
     printf ("     p_experimental_flang_frontend               = %s \n",(p_experimental_flang_frontend == true) ? "true" : "false");

  // DQ (4/17/2015): Adding multifile handling support for commandline generation.
     printf ("     p_multifile_support                         = %s \n",(p_multifile_support == true) ? "true" : "false");

  // DQ (12/11/2015): Option to use the token stream mapping and local tests of the
  // token sequence, to improve the source position information stored in the AST.
     printf ("     p_use_token_stream_to_improve_source_position_info = %s \n",(p_use_token_stream_to_improve_source_position_info == true) ? "true" : "false");

  // DQ (12/23/2015): Suppress variable declaration normalizations
     printf ("     p_suppress_variable_declaration_normalization = %s \n",(p_suppress_variable_declaration_normalization == true) ? "true" : "false");
   }


// DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented
// as a static member variable instead of non-static member variable.  See test2015_141.c
// for where this is required.
bool
SgFile::get_skip_unparse_asm_commands()
   {
     return p_skip_unparse_asm_commands;
   }

// DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented
// as a static member variable instead of non-static member variable. See test2015_141.c
// for where this is required.
void
SgFile::set_skip_unparse_asm_commands( bool b )
   {
     p_skip_unparse_asm_commands = b;
   }


// DQ (5/23/2015): Added support for p_header_file_unparsing_optimization to be implemented
// as a static member variable instead of non-static member variable.
bool
SgFile::get_header_file_unparsing_optimization()
   {
     return p_header_file_unparsing_optimization;
   }

// DQ (5/23/2015): Added support for p_header_file_unparsing_optimization to be implemented
// as a static member variable instead of non-static member variable.
void
SgFile::set_header_file_unparsing_optimization( bool b )
   {
     p_header_file_unparsing_optimization = b;
   }

SOURCE_APPLICATION_FILE_END


SOURCE_APPLICATION_SOURCE_FILE_START

void
SgSourceFile::initialization()
   {
  // Deprecate, then delete [Rasmussen 2024.04.28]
     ROSE_ABORT();

  // DQ (3/2/2022): The SgSourceFile node has a number of new data members that were not previously initialized.

  // Initialization
     p_globalScope                                = NULL;
     p_temp_holding_scope                         = NULL;
     p_package                                    = NULL;
     p_import_list                                = NULL;
     p_class_list                                 = NULL;
     p_isHeaderFile                               = false;
     p_isHeaderFileIncludedMoreThanOnce           = false;
     p_headerFileReport                           = NULL;
     p_associated_include_file                    = NULL;
     p_processedToIncludeCppDirectivesAndComments = false;
     p_isDynamicLibrary                           = false;
     p_firstStatement                             = NULL;
     p_lastStatement                              = NULL;
   }


// DQ (1/20/2021): Changed the API to use a pointer to a std::map<SgNode*,TokenStreamSequenceToNodeMapping*> instead of a reference.
void
SgSourceFile::set_tokenSubsequenceMap(std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* tokenStreamSequenceMap)
   {
  // DQ (1/19/2021): This is a newer version of this function that only inserts the input map into
  // a map container that is using the SgSourceFile instead of the file_id as a key (to the map).

     if (Rose::tokenSubsequenceMapOfMapsBySourceFile.find(this) == Rose::tokenSubsequenceMapOfMapsBySourceFile.end())
        {
          Rose::tokenSubsequenceMapOfMapsBySourceFile.insert(std::pair<SgSourceFile*,std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* >(this,tokenStreamSequenceMap));
        }
       else
        {
          printf ("Error: entry for SgSourceFile = %p is already present in Rose::tokenSubsequenceMapOfMapsBySourceFile \n",this);
          ROSE_ASSERT(false);
        }
   }


// DQ (9/26/2018): Added so that we can call the display function for TokenStreamSequenceToNodeMapping (for debugging).
#include "tokenStreamMapping.h"

std::map<SgNode*,TokenStreamSequenceToNodeMapping*> &
SgSourceFile::get_tokenSubsequenceMap()
   {
  // DQ (1/23/2021): Newer version, uses the "this" pointer as a key so that multiple SgSourceFile IR nodes
  // can use the same file (reading the same filename).
     std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* result = NULL;

     if (Rose::tokenSubsequenceMapOfMapsBySourceFile.find(this) != Rose::tokenSubsequenceMapOfMapsBySourceFile.end())
        {
          result = Rose::tokenSubsequenceMapOfMapsBySourceFile[this];
        }
       else
        {
       // DQ (2/19/2021): Disable this as an error since the AST read (after the AST write) will not have this data structure.
       // We are not trying to currently support the token-based unparsing after an AST write and AST read.
       // DQ (1/30/2021): Added an assertion.
       // ROSE_ASSERT(false);
        }

     return *result;
   }

void
SgSourceFile::set_token_unparse_frontier(std::map<SgStatement*,FrontierNode*> & tokenStreamSequenceMap)
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // We could later make this a map of maps using the SgSourceFile IR node as the key (or the Sg_File_Info fileId value (which is tied to the filename)).

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::map<SgStatement*,FrontierNode*> & frontierMap = this->get_token_unparse_frontier();

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgStatement*,FrontierNode*>::iterator i = tokenStreamSequenceMap.begin();
     while (i != tokenStreamSequenceMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_token_unparse_frontier(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

std::map<SgStatement*,FrontierNode*> &
SgSourceFile::get_token_unparse_frontier()
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.

  // DQ (9/28/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): index = %d filename = %s \n",index,this->getFileName().c_str());
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): Rose::frontierNodesMapOfMaps.size() = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::frontierNodesMapOfMaps.find(index) == Rose::frontierNodesMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::frontierNodesMapOfMaps: (before) size = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif
          std::map<SgStatement*,FrontierNode*>* frontierNodesMap = new std::map<SgStatement*,FrontierNode*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::frontierNodesMapOfMaps.insert(std::pair<int,std::map<SgStatement*,FrontierNode*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::frontierNodesMapOfMaps: (after) size = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::frontierNodesMapOfMaps.find(index) != Rose::frontierNodesMapOfMaps.end());
     ROSE_ASSERT(Rose::frontierNodesMapOfMaps[index] != NULL);

     std::map<SgStatement*,FrontierNode*>* result = Rose::frontierNodesMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }


void
SgSourceFile::set_token_unparse_frontier_adjacency(std::map<SgNode*,PreviousAndNextNodeData*> & tokenStreamSequenceMap)
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // We could later make this a map of maps using the SgSourceFile IR node as the key (or the Sg_File_Info fileId value (which is tied to the filename)).

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::map<SgNode*,PreviousAndNextNodeData*> & frontierMap = this->get_token_unparse_frontier_adjacency();

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier_adjacency(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgNode*,PreviousAndNextNodeData*>::iterator i = tokenStreamSequenceMap.begin();
     while (i != tokenStreamSequenceMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_token_unparse_frontier_adjacency(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier_adjacency(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

std::map<SgNode*,PreviousAndNextNodeData*> &
SgSourceFile::get_token_unparse_frontier_adjacency()
   {
     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier_adjacency(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::previousAndNextNodeMapOfMaps.find(index) == Rose::previousAndNextNodeMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgNode*,PreviousAndNextNodeData*> object to the Rose::previousAndNextNodeMapOfMaps: (before) size = %zu \n",Rose::previousAndNextNodeMapOfMaps.size());
#endif
          std::map<SgNode*,PreviousAndNextNodeData*>* frontierNodesMap = new std::map<SgNode*,PreviousAndNextNodeData*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::previousAndNextNodeMapOfMaps.insert(std::pair<int,std::map<SgNode*,PreviousAndNextNodeData*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgNode*,PreviousAndNextNodeData*> object to the Rose::previousAndNextNodeMapOfMaps: (after) size = %zu \n",Rose::previousAndNextNodeMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::previousAndNextNodeMapOfMaps.find(index) != Rose::previousAndNextNodeMapOfMaps.end());
     ROSE_ASSERT(Rose::previousAndNextNodeMapOfMaps[index] != NULL);

     std::map<SgNode*,PreviousAndNextNodeData*>* result = Rose::previousAndNextNodeMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }

// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
void
SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(std::multimap<int,SgStatement*> & X)
   {
  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::multimap<int,SgStatement*> & frontierMap = this->get_redundantlyMappedTokensToStatementMultimap();

#if 0
     mprintf ("In SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::multimap<int,SgStatement*>::iterator i = X.begin();
     while (i != X.end())
        {
       // ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               ROSE_ASSERT(i->second != NULL);
#if 0
               mprintf ("SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): This is a redundant entry in the Map: i->first = %d i->second = %p = %s \n",i->first,i->second,i->second->class_name().c_str());
#endif
            // DQ (11/1/2018): Since this is a multimap, this might be OK (debugging move tool tests).
            // ROSE_ASSERT(false);
             }
            else
             {
#if 0
               mprintf ("SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): new entry in the map: i->first = %d i->second = %p = %s \n",i->first,i->second,i->second->class_name().c_str());
#endif
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
std::multimap<int,SgStatement*> &
SgSourceFile::get_redundantlyMappedTokensToStatementMultimap()
   {
     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_redundantlyMappedTokensToStatementMultimap(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::redundantlyMappedTokensToStatementMapOfMultimaps.find(index) == Rose::redundantlyMappedTokensToStatementMapOfMultimaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::redundantlyMappedTokensToStatementMapOfMultimaps: (before) size = %zu \n",Rose::redundantlyMappedTokensToStatementMapOfMultimaps.size());
#endif
          std::multimap<int,SgStatement*>* frontierNodesMap = new std::multimap<int,SgStatement*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::redundantlyMappedTokensToStatementMapOfMultimaps.insert(std::pair<int,std::multimap<int,SgStatement*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::redundantlyMappedTokensToStatementMapOfMultimaps: (after) size = %zu \n",Rose::redundantlyMappedTokensToStatementMapOfMultimaps.size());
#endif
        }

     ROSE_ASSERT(Rose::redundantlyMappedTokensToStatementMapOfMultimaps.find(index) != Rose::redundantlyMappedTokensToStatementMapOfMultimaps.end());
     ROSE_ASSERT(Rose::redundantlyMappedTokensToStatementMapOfMultimaps[index] != NULL);

     std::multimap<int,SgStatement*>* result = Rose::redundantlyMappedTokensToStatementMapOfMultimaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }


// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
void
SgSourceFile::set_redundantTokenEndingsSet(std::set<int> & X)
   {
  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::set<int> & frontierMap = this->get_redundantTokenEndingsSet();

#if 0
     mprintf ("In SgSourceFile::set_redundantTokenEndingsSet(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::set<int>::iterator i = X.begin();
     while (i != X.end())
        {
       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(*i) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_redundantTokenEndingsSet(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_redundantTokenEndingsSet(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
std::set<int> &
SgSourceFile::get_redundantTokenEndingsSet()
   {
     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::redundantTokenEndingsMapOfSets.find(index) == Rose::redundantTokenEndingsMapOfSets.end())
        {
#if 0
          mprintf ("Adding a new std::set<int> object to the Rose::redundantTokenEndingsMapOfSets: (before) size = %zu \n",Rose::redundantTokenEndingsMapOfSets.size());
#endif
          std::set<int>* frontierNodesMap = new std::set<int>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::redundantTokenEndingsMapOfSets.insert(std::pair<int,std::set<int>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::set<int> object to the Rose::redundantTokenEndingsMapOfSets: (after) size = %zu \n",Rose::redundantTokenEndingsMapOfSets.size());
#endif
        }

     ROSE_ASSERT(Rose::redundantTokenEndingsMapOfSets.find(index) != Rose::redundantTokenEndingsMapOfSets.end());
     ROSE_ASSERT(Rose::redundantTokenEndingsMapOfSets[index] != NULL);

     std::set<int>* result = Rose::redundantTokenEndingsMapOfSets[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }

void
SgSourceFile::set_representativeWhitespaceStatementMap(std::map<SgScopeStatement*,SgStatement*> & representativeWhitespaceStatementMap)
   {
  // DQ (11/20/2015): Provide a statement to use as a key in the token sequence map to get representative whitespace.
  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::map<SgScopeStatement*,SgStatement*> & frontierMap = this->get_representativeWhitespaceStatementMap();

#if 0
     mprintf ("In SgSourceFile::set_representativeWhitespaceStatementMap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgScopeStatement*,SgStatement*>::iterator i = representativeWhitespaceStatementMap.begin();
     while (i != representativeWhitespaceStatementMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (6/3/2019): Testing (unparse heaaders active, but token-based unparsing inactive) with an alternative implementation.

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_representativeWhitespaceStatementMap(): This is a redundant entry in the Map \n");
               mprintf ("   --- filename = %s \n",getFileName().c_str());
               mprintf ("   --- i->first  = %p = %s \n",i->first,i->first->class_name().c_str());
               mprintf ("   --- i->second = %p = %s \n",i->second,i->second->class_name().c_str());
             }
            else
             {
               frontierMap.insert(*i);
             }
          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_representativeWhitespaceStatementMap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }


std::map<SgScopeStatement*,SgStatement*> &
SgSourceFile::get_representativeWhitespaceStatementMap()
   {
  // DQ (11/20/2015): Provide a statement to use as a key in the token sequence map to get representative whitespace.
  // DQ (11/20/2015): Not sure I want this to be copy by value, but OK for now.

     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_representativeWhitespaceStatementMap(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::representativeWhitespaceStatementMapOfMaps.find(index) == Rose::representativeWhitespaceStatementMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgScopeStatement*,SgStatement*> object to the Rose::representativeWhitespaceStatementMapOfMaps: (before) size = %zu \n",Rose::representativeWhitespaceStatementMapOfMaps.size());
#endif
          std::map<SgScopeStatement*,SgStatement*>* frontierNodesMap = new std::map<SgScopeStatement*,SgStatement*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::representativeWhitespaceStatementMapOfMaps.insert(std::pair<int,std::map<SgScopeStatement*,SgStatement*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgScopeStatement*,SgStatement*> object to the Rose::representativeWhitespaceStatementMapOfMaps: (after) size = %zu \n",Rose::representativeWhitespaceStatementMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::representativeWhitespaceStatementMapOfMaps.find(index) != Rose::representativeWhitespaceStatementMapOfMaps.end());
     ROSE_ASSERT(Rose::representativeWhitespaceStatementMapOfMaps[index] != NULL);

     std::map<SgScopeStatement*,SgStatement*>* result = Rose::representativeWhitespaceStatementMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }

void
SgSourceFile::set_macroExpansionMap(std::map<SgStatement*,MacroExpansion*> & macroExpansionMap)
   {
  // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.
  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).

     std::map<SgStatement*,MacroExpansion*> & frontierMap = this->get_macroExpansionMap();

#if 0
     mprintf ("In SgSourceFile::set_macroExpansionMap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgStatement*,MacroExpansion*>::iterator i = macroExpansionMap.begin();
     while (i != macroExpansionMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_macroExpansionMap(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_macroExpansionMap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }


std::map<SgStatement*,MacroExpansion*> &
SgSourceFile::get_macroExpansionMap()
   {
  // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.

     ASSERT_not_null(this);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_macroExpansionMapOfMaps(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::macroExpansionMapOfMaps.find(index) == Rose::macroExpansionMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,MacroExpansion*> object to the Rose::macroExpansionMapOfMaps: (before) size = %zu \n",Rose::macroExpansionMapOfMaps.size());
#endif
          std::map<SgStatement*,MacroExpansion*>* frontierNodesMap = new std::map<SgStatement*,MacroExpansion*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::macroExpansionMapOfMaps.insert(std::pair<int,std::map<SgStatement*,MacroExpansion*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,MacroExpansion*> object to the Rose::macroExpansionMapOfMaps: (after) size = %zu \n",Rose::macroExpansionMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::macroExpansionMapOfMaps.find(index) != Rose::macroExpansionMapOfMaps.end());
     ROSE_ASSERT(Rose::macroExpansionMapOfMaps[index] != NULL);

     std::map<SgStatement*,MacroExpansion*>* result = Rose::macroExpansionMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }


SOURCE_APPLICATION_SOURCE_FILE_END


SOURCE_INCLUDE_FILE_START
SOURCE_INCLUDE_FILE_END


SOURCE_HEADER_FILE_REPORT_START

// DQ (9/26/2018): Added so that we can call the display function for TokenStreamSequenceToNodeMapping (for debugging).
#include "tokenStreamMapping.h"

void
SgHeaderFileReport::display( const string & label) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("\nIn HeaderFileReport::display(): label = %s \n",label.c_str());

     ASSERT_not_null(this);

     printf ("In HeaderFileReport::display(): p_source_file = %p \n",p_source_file);
     ROSE_ASSERT(p_source_file != NULL);
     printf ("   --- source filename = %s \n",p_source_file->getFileName().c_str());
     printf ("   --- isHeaderFile = %s \n",p_source_file->get_isHeaderFile() ? "true" : "false");
     printf ("   --- isHeaderFileIncludedMoreThanOnce = %s \n",p_source_file->get_isHeaderFileIncludedMoreThanOnce() ? "true" : "false");

  // DQ (11/15/2018): removed the include list from SgSourceFile so that we could support traversals on the inlcude tree.
     printf ("   --- associated_include_file = %p \n",p_source_file->get_associated_include_file());
     ROSE_ASSERT(p_source_file->get_associated_include_file() != NULL);
     printf ("   --- associated_include_file include_file_list size = %zu \n",p_source_file->get_associated_include_file()->get_include_file_list().size());

     printf ("In HeaderFileReport::display(): p_include_file_list.size() = %zu \n",p_include_file_list.size());

     Rose_STL_Container<SgSourceFile*>::const_iterator i = p_include_file_list.begin();
     while (i != p_include_file_list.end())
        {
          SgSourceFile* includedFile = *i;
          ROSE_ASSERT(includedFile != NULL);

          printf ("   --- includedFile: name = %s \n",includedFile->getFileName().c_str());
          printf ("   --- --- # of statements in global scope = %zu \n",includedFile->get_globalScope()->get_declarations().size());
          printf ("   --- --- isHeaderFile = %s \n",includedFile->get_isHeaderFile() ? "true" : "false");
          printf ("   --- --- isHeaderFileIncludedMoreThanOnce = %s \n",includedFile->get_isHeaderFileIncludedMoreThanOnce() ? "true" : "false");

       // DQ (11/15/2018): removed the include list from SgSourceFile so that we could support traversals on the inlcude tree.
          printf ("   --- --- associated_include_file = %p \n",includedFile->get_associated_include_file());
          ROSE_ASSERT(includedFile->get_associated_include_file() != NULL);
          printf ("   --- --- associated_include_file include_file_list size = %zu \n",includedFile->get_associated_include_file()->get_include_file_list().size());

          i++;
        }
   }

SOURCE_HEADER_FILE_REPORT_END


SOURCE_APPLICATION_BINARY_COMPOSITE_START

const SgAsmGenericFile*
SgBinaryComposite::get_binaryFile() const
   {
     ASSERT_require(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

SgAsmGenericFile*
SgBinaryComposite::get_binaryFile()
   {
     ASSERT_require(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

void
SgBinaryComposite::set_binaryFile(SgAsmGenericFile* file)
   {
     ASSERT_require(p_genericFileList->get_files().empty() == true);
     p_genericFileList->get_files().push_back(file);
   }

SOURCE_APPLICATION_BINARY_COMPOSITE_END


SOURCE_APPLICATION_JVM_COMPOSITE_START
SOURCE_APPLICATION_JVM_COMPOSITE_END


SOURCE_APPLICATION_UNKNOWN_FILE_START
SgUnknownFile::SgUnknownFile(vector<string> &argv, SgProject* project)
   : SgUnknownFile()
   {
      doSetupForConstructor(argv, project);
   }

SOURCE_APPLICATION_UNKNOWN_FILE_END


SOURCE_APPLICATION_FILE_LIST_START
SOURCE_APPLICATION_FILE_LIST_END

SOURCE_APPLICATION_DIRECTORY_START
int
SgDirectory::numberOfFiles() const
   {
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles().size();
   }

SgFile*
SgDirectory::get_file(int i) const
   {
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles()[i];
   }

int
SgDirectory::numberOfDirectories() const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories().size();
   }

SgDirectory*
SgDirectory::get_directory(int i) const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories()[i];
   }

void
SgDirectory::post_construction_initialization()
   {
  // Make sure these data members start out as NULL.
     assert(p_fileList == NULL);
     assert(p_directoryList == NULL);

  // Initialize pointers to valid opjects with empty lists.
     p_fileList      = new SgFileList();
     p_directoryList = new SgDirectoryList();

     assert(p_fileList != NULL);
     assert(p_directoryList != NULL);

     p_fileList->set_parent(this);
     p_directoryList->set_parent(this);
   }

SOURCE_APPLICATION_DIRECTORY_END

SOURCE_APPLICATION_DIRECTORY_LIST_START
SOURCE_APPLICATION_DIRECTORY_LIST_END


SOURCE_JAVA_IMPORT_STATEMENT_LIST_START
SOURCE_JAVA_IMPORT_STATEMENT_LIST_END


SOURCE_JAVA_CLASS_DECLARATION_LIST_START
SOURCE_JAVA_CLASS_DECLARATION_LIST_END


SOURCE_APPLICATION_PROJECT_START

//! (static data) global concept of verbose level which controls useful output from the compiler
int SgProject::p_verbose = 0;

//! global to tell mangler to turn off short mangled name optimization. Default is false. (ie, by default short name mangling is enabled)
bool SgProject::p_mangled_noshortname = false;

//! global to output the command line that goes to the backend compiler. Default is false.
bool SgProject::p_showBackendCommandLine = false;

// DQ (4/4/2020): Adding support for unparse headers feature specific diagnostics.
int SgProject::p_unparseHeaderFilesDebug = 0;

void
SgProject::post_construction_initialization()
{
 // DQ (4/11/2017): Some implementations of ROSE tools are just calling the SgProject constructor directly, these
 // need to call ROSE_INITIALIZE.  Here is a reasonable point to make that call.
    ROSE_INITIALIZE;

 // Initialize the file list
    if (p_fileList_ptr == nullptr)
    {
       p_fileList_ptr = new SgFileList();
       ASSERT_not_null(p_fileList_ptr);
       p_fileList_ptr->set_parent(this);
    }

 // Initialize the directory list
    if (p_directoryList == nullptr)
    {
       p_directoryList = new SgDirectoryList();
       ASSERT_not_null(p_directoryList);
       p_directoryList->set_parent(this);
    }

 // Initialise the global scope for multiple file handling
    if (p_globalScopeAcrossFiles == nullptr)
    {
       Sg_File_Info* fi_gsaf = Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode();
       p_globalScopeAcrossFiles = new SgGlobal(fi_gsaf);
       fi_gsaf->set_parent(p_globalScopeAcrossFiles);
       p_globalScopeAcrossFiles->set_parent(this);
    }

 // Set the verbose level during SgProject construction (helps debug Intel Pin usage).
 // Note, this is the static global version, not SgFile::p_verbose, not clear why we need two [Rasmussen 2024.05.13]
    if (p_verbose > 0) {
       mprintf ("Note: Verbose was already set to non-zero value = %d (valid range is 0...10) \n",p_verbose);
       ASSERT_require(p_verbose <= 10);
    }
    else {
       p_verbose = 0;
    }
}

//! WARNING: this constructor invokes EDG front end (parse) and creates AST. Use frontend() instead.
SgProject::SgProject(int argc, char** argv, bool frontendConstantFolding)
   : SgProject()
   {
     ASSERT_not_null(this);

  // DQ (9/18/2011): Added support to use frontend specific constant folding (applies to C/C++ using EDG).
  // All other languges have no specific constant folding options in their frontends.  We use to support
  // the original expression tree in the AST, and this provided both the constant folded value and
  // the original expression tree, but this was a problem for analysis (which tended to mix them together).
     p_frontendConstantFolding = frontendConstantFolding;

     std::vector<std::string> argvList(argv, argv + argc);
     int errorCode = parse(argvList);
     set_frontendErrorCode(errorCode);
   }

//! WARNING: this constructor invokes EDG front end (parse) and creates AST. Use frontend() instead.
SgProject::SgProject ( const std::vector<std::string>& argv, bool frontendConstantFolding )
   : SgProject()
   {
     ASSERT_not_null(this);

  // DQ (9/18/2011): Added support to use frontend specific constant folding (applies to C/C++ using EDG).
  // All other languges have no specific constant folding options in their frontends.  We use to support
  // the original expression tree in the AST, and this provided both the constant folded value and
  // the original expression tree, but this was a problem for analysis (which tended to mix them together).
     p_frontendConstantFolding = frontendConstantFolding;

     int errorCode = parse(argv);
     set_frontendErrorCode(errorCode);
   }

// DQ (2/1/2007): Added new operator so that w could depricate the inconsistant usage of
// SgFile& in get_file() member function.  The get_file() member function is now deprecated.
SgFile*
SgProject::operator[](unsigned int i)
   {
  // Since we use an STL vector internally we can use the vector::operator[] directly.
     assert(p_fileList_ptr != NULL);
     assert(i < (unsigned)numberOfFiles());
     return p_fileList_ptr->get_listOfFiles()[i];
   }

// DQ (6/13/2013): Access function for retriving a SgFile object from the list stored internally,
// but using the filename with full path.  This is part of the new Java performance support and
// a design change that first builds all of the SgFile IR nodes and then calls the frontend for
// each of them.  This permits a more sophisticated level of command line multiple file support.
SgFile* SgProject::operator[](std::string filename)
   {
  // Since we use an STL vector internally we can use the vector::operator[] directly.
     ASSERT_not_null(p_fileList_ptr);
     ASSERT_require(numberOfFiles() > 0);

     SgFilePtrList::iterator i = p_fileList_ptr->get_listOfFiles().begin();
     while (i != p_fileList_ptr->get_listOfFiles().end())
        {
          ROSE_ASSERT(*i != NULL);
       // Find the matching SgFile object using the get_sourceFileNameWithPath()
          if (filename == (*i)->get_sourceFileNameWithPath())
             {
               return *i;
             }

          i++;
        }
     return nullptr;
   }

std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<string> & l )
   {
     return os;
   }

SgFilePtrList &
SgProject::get_fileList() const
   {
     ASSERT_not_null(this);
     return p_fileList_ptr->get_listOfFiles();
   }

void
SgProject::set_fileList( SgFilePtrList & fileList )
   {
     ASSERT_not_null(this);
     set_isModified(true);

     p_fileList_ptr->get_listOfFiles() = fileList;
   }

int
SgProject::numberOfFiles() const
   {
  // This function does not return a meaningful result until all the files have been processed
     ASSERT_not_null(p_fileList_ptr);
     return p_fileList_ptr->get_listOfFiles().size();
   }

int
SgProject::numberOfDirectories() const
   {
     ASSERT_not_null(p_directoryList);
     return p_directoryList->get_listOfDirectories().size();
   }

SgFile &
SgProject::get_file(int i) const
   {
  // error checking
     ASSERT_require(i >= 0);
     ASSERT_require(i < numberOfFiles());
     ASSERT_not_null(p_fileList_ptr);

     SgFile* targetFile = p_fileList_ptr->get_listOfFiles()[i];
     ASSERT_not_null(targetFile);

     return *targetFile;
   }

void
SgProject::set_file(SgFile &file)
   {
     ASSERT_not_null(p_fileList_ptr);
     p_fileList_ptr->get_listOfFiles().push_back(&file);

  // DQ (1/25/2010): Set the parent of the file to point to the list (this is a change and may break some code).
  // But it is consistant within ROSE for how we handle list objects in the IR.
     file.set_parent(p_fileList_ptr);

     ASSERT_require(numberOfFiles() > 0);
   }

SgFilePtrList
SgProject::get_files() const
{
  return p_fileList_ptr->get_listOfFiles();
}

SgFilePtrList
SgProject::get_files_with_errors() const
{
  SgFilePtrList files_with_errors;

  for (SgFile* file : p_fileList_ptr->get_listOfFiles())
  {
      bool has_errors =
          file->get_javacErrorCode()            != 0 ||
          file->get_frontendErrorCode()         != 0 ||
          file->get_midendErrorCode()           != 0 ||
          file->get_unparserErrorCode()         != 0 ||
          file->get_backendCompilerErrorCode()  != 0;
      if (has_errors)
      {
          files_with_errors.push_back(file);
      }
  }

  return files_with_errors;
}

SgFilePtrList
SgProject::get_files_without_errors() const
{
  SgFilePtrList files_without_errors;

  for (SgFile* file : p_fileList_ptr->get_listOfFiles())
  {
      bool has_no_errors =
          file->get_javacErrorCode()            == 0 &&
          file->get_frontendErrorCode()         == 0 &&
          file->get_midendErrorCode()         == 0 &&
          file->get_unparserErrorCode()         == 0 &&
          file->get_backendCompilerErrorCode()  == 0;
      if (has_no_errors)
      {
          files_without_errors.push_back(file);
      }
  }

  return files_without_errors;
}

void
SgProject::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
     extern void unparseProject( SgProject* project, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */);
     unparseProject( this, unparseFormatHelp, unparseDelegate);
   }

void
SgProject::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.resetSourcePositionToGeneratedCode( unparseFormatHelp );
        }
   }

Rose_STL_Container<string>
SgProject::getAbsolutePathFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }

int
SgProject::get_verbose(void)
   {
     return p_verbose;
   }

void
SgProject::set_verbose(int x)
   {
     p_verbose = x;
   }

bool
SgProject::get_mangled_noshortname (void)
   {
     return p_mangled_noshortname;
   }

void
SgProject::set_mangled_noshortname ( bool x )
   {
     p_mangled_noshortname = x;
   }

bool
SgProject::get_showBackendCommandLine (void)
   {
     return p_showBackendCommandLine;
   }

void
SgProject::set_showBackendCommandLine ( bool show )
   {
     p_showBackendCommandLine = show;
   }


std::string
SgProject::get_applicationRootDirectory () const
   {
     ASSERT_not_null(this);
     return p_applicationRootDirectory;
   }

//! Jim Leek 2023/03/17: Modified to check that the application root is sane
//! Assumes we have boost::filesystem availible from sage3basic.h
void
SgProject::set_applicationRootDirectory ( std::string applicationRootDirectory )
  {
    ASSERT_not_null(this);

    p_applicationRootDirectory = applicationRootDirectory;

    set_isModified(true);
    boost::filesystem::path rootPath = boost::filesystem::weakly_canonical(applicationRootDirectory);

    if(!boost::filesystem::is_directory(rootPath)) {
      printf("ERROR: applicationRootDirectory %s does not exist\n", rootPath.c_str());
      ROSE_ABORT();
    }


    auto fileList = this->get_fileList_ptr()->get_listOfFiles();
    for(auto file : fileList) {
      boost::filesystem::path filePath = boost::filesystem::weakly_canonical(file->getFileName());
      if(! (filePath.native().substr(0, rootPath.native().size()) == rootPath)) {
        printf("ERROR: file: %s\n", filePath.c_str());
        printf("         does not seem to be in applicationRootDirectory: %s\n", rootPath.c_str());
    ROSE_ABORT();
      }
    }

  return;
}

// DQ (4/4/2020): Adding support for unparse headers feature specific diagnostics.
// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
int
SgProject::get_unparseHeaderFilesDebug (void)
   {
     return p_unparseHeaderFilesDebug;
   }

// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
void
SgProject::set_unparseHeaderFilesDebug ( int x )
   {
     p_unparseHeaderFilesDebug = x;
   }



bool
SgProject::get_skip_translation_from_edg_ast_to_rose_ast (void) const
   {
  // look at how the files are set
     bool returnSkipTranslation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTranslation = returnSkipTranslation && (bool) file.get_skip_translation_from_edg_ast_to_rose_ast();
        }
     return returnSkipTranslation;
   }

bool
SgProject::get_skip_transformation (void) const
   {
  // look at how the files are set
     bool returnSkipTransformation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTransformation = returnSkipTransformation && (bool) file.get_skip_transformation();
        }
     return returnSkipTransformation;
   }

bool
SgProject::get_skip_unparse (void) const
   {
  // look at how the files are set
     bool returnSkipUnparse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipUnparse = returnSkipUnparse && (bool) file.get_skip_unparse();
        }
     return returnSkipUnparse;
   }

bool
SgProject::get_useBackendOnly (void) const
   {
  // look at how the files are set
     bool returnUseBackendOnly = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnUseBackendOnly = returnUseBackendOnly && (bool) file.get_useBackendOnly();
        }
     return returnUseBackendOnly;
   }

// DQ (4/6/2010): Added to support parsing only option.
bool
SgProject::get_exit_after_parser(void) const
   {
  // look at how the files are set
     bool returnExitAfterParse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnExitAfterParse = returnExitAfterParse && (bool) file.get_exit_after_parser();
        }
     return returnExitAfterParse;
   }

bool
SgProject::get_skipfinalCompileStep (void) const
   {
  // look at how the files are set
     bool returnSkipFinalCompileStep = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipFinalCompileStep = returnSkipFinalCompileStep && (bool) file.get_skipfinalCompileStep();
        }
     return returnSkipFinalCompileStep;
   }

void
SgProject::set_C_only       (bool value)
   {
     ASSERT_not_null(this);
     p_C_only = value;
   }

void
SgProject::set_Cxx_only     (bool value)
   {
     ASSERT_not_null(this);
     p_Cxx_only = value;
   }

void
SgProject::set_Fortran_only (bool value)
   {
     ASSERT_not_null(this);
     p_Fortran_only = value;
   }

bool
SgProject::get_C_only (void) const
   {
     bool result = p_C_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C_only();
        }
     return result;
   }

bool
SgProject::get_C89_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C89_only();
        }
     return result;
   }

bool
SgProject::get_C89_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C89_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C90_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C90_only();
        }
     return result;
   }

bool
SgProject::get_C90_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C90_gnu_only();
        }
     return result;
   }


bool
SgProject::get_C99_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_only();
        }
     return result;
   }

bool
SgProject::get_C99_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C11_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C11_only();
        }
     return result;
   }

bool
SgProject::get_C11_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C11_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C17_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C17_only();
        }
     return result;
   }

bool
SgProject::get_C17_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C17_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C23_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C23_only();
        }
     return result;
   }

bool
SgProject::get_C23_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C23_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C2y_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C2y_only();
        }
     return result;
   }

bool
SgProject::get_C2y_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C2y_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx_only (void) const
   {
     bool result = p_Cxx_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx_only();
        }
     return result;
   }

bool
SgProject::get_Cxx98_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx98_only();
        }
     return result;
   }

bool
SgProject::get_Cxx98_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx98_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx03_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx03_only();
        }
     return result;
   }

bool
SgProject::get_Cxx03_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx03_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx11_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx11_only();
        }
     return result;
   }

bool
SgProject::get_Cxx11_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx11_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx14_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx14_only();
        }
     return result;
   }

bool
SgProject::get_Cxx14_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx14_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx17_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx17_only();
        }
     return result;
   }

bool
SgProject::get_Cxx17_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx17_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx20_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx20_only();
        }
     return result;
   }

bool
SgProject::get_Cxx20_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx20_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx23_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx23_only();
        }
     return result;
   }

bool
SgProject::get_Cxx23_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx23_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx26_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx26_only();
        }
     return result;
   }

bool
SgProject::get_Cxx26_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx26_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Fortran_only (void) const
   {
     bool result = p_Fortran_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Fortran_only();
        }
     return result;
   }

bool
SgProject::get_F77_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F77_only();
        }
     return result;
   }

bool
SgProject::get_F90_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F90_only();
        }
     return result;
   }

bool
SgProject::get_F95_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F95_only();
        }
     return result;
   }

bool
SgProject::get_F2003_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2003_only();
        }
     return result;
   }

bool
SgProject::get_F2008_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2008_only();
        }
     return result;
   }

bool
SgProject::get_F2018_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2018_only();
        }
     return result;
   }

bool
SgProject::get_CoArrayFortran_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_CoArrayFortran_only();
        }
     return result;
   }

bool
SgProject::get_PHP_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_PHP_only();
        }
     return result;
   }

bool
SgProject::get_Python_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Python_only();
        }
     return result;
   }

void
SgProject::set_Java_only(bool value)
   {
     ASSERT_not_null(this);
     p_Java_only = value;
   }

bool
SgProject::get_Java_only(void) const
   {
  // look at how the files are set.
     bool result = p_Java_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile &file = get_file(i);
          result = result || (bool) file.get_Java_only();
        }
     return result;
   }

void
SgProject::set_Java_classpath (std::list<std::string> param)
   {
     p_Java_classpath = param;
   }

std::list<std::string>
SgProject::get_Java_classpath (void) const
   {
     return p_Java_classpath;
   }

void
SgProject::set_Java_sourcepath (std::list<std::string> param)
   {
     p_Java_sourcepath = param;
   }

std::list<std::string>
SgProject::get_Java_sourcepath (void) const
   {
     return p_Java_sourcepath;
   }

void
SgProject::set_Java_destdir (std::string param)
   {
     p_Java_destdir = param;
   }

std::string
SgProject::get_Java_destdir (void) const
   {
    if (p_Java_destdir == "") {
      return Rose::getWorkingDirectory();
    }
    return p_Java_destdir;
   }

void
SgProject::set_Java_source_destdir (std::string param)
   {
     p_Java_source_destdir = param;
   }

std::string
SgProject::get_Java_source_destdir (void) const
   {
    if (p_Java_source_destdir == "") {
      return Rose::getWorkingDirectory();
    }
    return p_Java_source_destdir;
  }

bool
SgProject::get_Csharp_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Csharp_only();
        }
     return result;
   }

bool
SgProject::get_Ada_only (void) const
   {
  // look at how the files are set
     bool result = p_Ada_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Ada_only();
        }
     return result;
   }

void
SgProject::set_Ada_only (bool value)
   {
     ASSERT_not_null(this);
     p_Ada_only = value;
   }

void
SgProject::set_Jovial_only(bool value)
   {
     ASSERT_not_null(this);
     p_Jovial_only = value;
   }

bool
SgProject::get_Jovial_only(void) const
   {
     bool result = p_Jovial_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile &file = get_file(i);
          result = result || (bool) file.get_Jovial_only();
        }
     return result;
   }

void
SgProject::set_Jvm_only(bool value)
   {
     ASSERT_not_null(this);
     p_Jvm_only = value;
   }

bool
SgProject::get_Jvm_only (void) const
   {
     bool result = p_Jvm_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile &file = get_file(i);
          result = result || (bool) file.get_Jvm_only();
        }
     return result;
   }

void
SgProject::skipfinalCompileStep(bool value)
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          get_file(i).set_skipfinalCompileStep(value);
        }
   }


int
SgProject::get_detect_dangling_pointers(void) const
   {
  // look at how the files are set
     int result = 0;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result | file.get_detect_dangling_pointers();
        }

     return result;
   }


void
SgProject::display ( const std::string & label ) const
   {
  // DQ (4/4/2020): Fixing this to not use the mprintf, since when called by the user it should output data.
  // I think this wasa a bit over zellous use of "mprintf" via search and replace.

     printf ("In SgProject::display(%s) \n",label.c_str());

     printf ("   p_verbose                                 = %d \n",p_verbose);
     printf ("   p_unparseHeaderFilesDebug                 = %d \n",p_unparseHeaderFilesDebug);

     printf ("   p_outputFileName                          = %s \n",p_outputFileName.c_str());

     printf ("   p_sourceFileNameList.size()               = %" PRIuPTR " \n", p_sourceFileNameList.size());
     printf ("   p_sourceFileNameList                      = \n      %s \n",Rose::StringUtility::listToString(p_sourceFileNameList).c_str());

     printf ("   p_objectFileNameList.size()               = %" PRIuPTR " \n", p_objectFileNameList.size());
     printf ("   p_objectFileNameList                      = \n      %s \n",Rose::StringUtility::listToString(p_objectFileNameList).c_str());

     printf ("   p_libraryFileList.size()                  = %" PRIuPTR " \n", p_libraryFileList.size());
     printf ("   p_libraryFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_libraryFileList).c_str());

     printf ("   p_librarySpecifierList.size()             = %" PRIuPTR " \n", p_librarySpecifierList.size());
     printf ("   p_librarySpecifierList                    = \n      %s \n",Rose::StringUtility::listToString(p_librarySpecifierList).c_str());

     printf ("   p_libraryDirectorySpecifierList.size()    = %" PRIuPTR " \n", p_libraryDirectorySpecifierList.size());
     printf ("   p_libraryDirectorySpecifierList           = \n      %s \n",Rose::StringUtility::listToString(p_libraryDirectorySpecifierList).c_str());

     printf ("   p_includeDirectorySpecifierList.size()    = %" PRIuPTR " \n", p_includeDirectorySpecifierList.size());
     printf ("   p_includeDirectorySpecifierList           = \n      %s \n",Rose::StringUtility::listToString(p_includeDirectorySpecifierList).c_str());

     printf ("   p_compileOnly                             = %s \n",(p_compileOnly == true) ? "true" : "false");
     printf ("   p_prelink                                 = %s \n",(p_prelink     == true) ? "true" : "false");

     printf ("   p_template_instantiation_mode             = %d \n",p_template_instantiation_mode);

     printf ("   p_ast_merge                               = %s \n",(p_ast_merge == true) ? "true" : "false");
     printf ("   p_projectSpecificDatabaseFile             = %s \n",p_projectSpecificDatabaseFile.c_str());
     printf ("   p_compilationPerformanceFile              = %s \n",p_compilationPerformanceFile.c_str());

     printf ("   p_includePathList.size()                  = %" PRIuPTR " \n", p_includePathList.size());
     printf ("   p_includePathList                         = \n      %s \n",Rose::StringUtility::listToString(p_includePathList).c_str());

     printf ("   p_excludePathList.size()                  = %" PRIuPTR " \n", p_excludePathList.size());
     printf ("   p_excludePathList                         = \n      %s \n",Rose::StringUtility::listToString(p_excludePathList).c_str());

     printf ("   p_includeFileList.size()                  = %" PRIuPTR " \n", p_includeFileList.size());
     printf ("   p_includeFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_includeFileList).c_str());

     printf ("   p_excludeFileList.size()                  = %" PRIuPTR " \n", p_excludeFileList.size());
     printf ("   p_excludeFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_excludeFileList).c_str());

     printf ("   p_preincludeFileList.size()               = %" PRIuPTR " \n", p_preincludeFileList.size());
     printf ("   p_preincludeFileList                      = \n      %s \n",Rose::StringUtility::listToString(p_preincludeFileList).c_str());

     printf ("   p_preincludeDirectoryList.size()          = %" PRIuPTR " \n", p_preincludeDirectoryList.size());
     printf ("   p_preincludeDirectoryList                 = \n      %s \n",Rose::StringUtility::listToString(p_preincludeDirectoryList).c_str());

  // DQ (2/4/2009): Moved from SgFile to SgProject.
     printf ("   p_binary_only()                           = %s \n",(p_binary_only == true) ? "true" : "false");

  // DQ (9/15/2013): Added debugging support for a previously missed data member.
     printf ("   p_frontendConstantFolding                 = %s \n",(p_frontendConstantFolding == true) ? "true" : "false");

  // DQ (9/15/2013): Added debugging support for a new data member.
     printf ("   p_unparse_in_same_directory_as_input_file = %s \n",(p_unparse_in_same_directory_as_input_file == true) ? "true" : "false");

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error.
     printf ("   p_noclobber_output_file              = %s \n",(p_noclobber_output_file == true) ? "true" : "false");

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error if it results in a different file.
     printf ("   p_noclobber_if_different_output_file = %s \n",(p_noclobber_if_different_output_file == true) ? "true" : "false");

  // Pei-Hung (8/6/2014): This option appends PID into the output name to avoid file collision in parallel compilation.
     printf ("   p_appendPID = %s \n",(p_appendPID == true) ? "true" : "false");

     printf ("In this project: numberOfFiles() = %d \n",numberOfFiles());
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.display("called from SgProject::display()");
        }
   }

const SgStringList &
SgProject::get_includePathList () const
   {
     assert (this != NULL);
     return p_includePathList;
   }

SgStringList &
SgProject::get_includePathList ()
   {
     assert (this != NULL);
     return p_includePathList;
   }

void
SgProject::set_includePathList ( const SgStringList & includePathList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_includePathList = includePathList;
   }


const SgStringList &
SgProject::get_excludePathList () const
   {
     assert (this != NULL);
     return p_excludePathList;
   }

SgStringList &
SgProject::get_excludePathList ()
   {
     assert (this != NULL);
     return p_excludePathList;
   }

void
SgProject::set_excludePathList ( const SgStringList & excludePathList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_excludePathList = excludePathList;
   }

const SgStringList &
SgProject::get_includeFileList () const
   {
     assert (this != NULL);
     return p_includeFileList;
   }

SgStringList &
SgProject::get_includeFileList ()
   {
     assert (this != NULL);
     return p_includeFileList;
   }

void
SgProject::set_includeFileList ( const SgStringList & includeFileList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_includeFileList = includeFileList;
   }


const SgStringList &
SgProject::get_excludeFileList () const
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

SgStringList &
SgProject::get_excludeFileList ()
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

void
SgProject::set_excludeFileList ( const SgStringList & excludeFileList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_excludeFileList = excludeFileList;
   }

bool
SgProject::get_unparse_tokens (void) const
   {
  // DQ (8/3/2018): Added support for evaluation of options at the project level (which are normally associated with files).

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_unparse_tokens();
        }

     return result;
   }


SOURCE_APPLICATION_PROJECT_END


SOURCE_OPTIONS_START
SOURCE_OPTIONS_END


SOURCE_UNPARSE_INFO_START

extern void printSgVariant(std::ostream&,int);

// DQ (1/11/2004): Remove this static member and make it a member pointer
// Declaration of static member to support unparsing complex structures
SgTypePtrList SgUnparse_Info::p_structureTagProcessingList;

/*! \brief Debugging support

     Debugging support to test correctness of the implementation the SgUnparse_Info
     object as an inherited attribute in the unparser.
 */
bool SgUnparse_Info::p_forceDefaultConstructorToTriggerError = false;

bool
SgUnparse_Info::get_forceDefaultConstructorToTriggerError()
   {
     return p_forceDefaultConstructorToTriggerError;
   }

void
SgUnparse_Info::set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError)
   {
     p_forceDefaultConstructorToTriggerError = forceDefaultConstructorToTriggerError;
   }

/*! \brief Extern C support when using braces.

     When using braced extern C we need to avoid nesting of these structures in the generated code.
 */
// DQ (8/15/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).
bool SgUnparse_Info::p_extern_C_with_braces = false;

bool
SgUnparse_Info::get_extern_C_with_braces()
   {
     return p_extern_C_with_braces;
   }

void
SgUnparse_Info::set_extern_C_with_braces( bool extern_C_with_braces)
   {
     p_extern_C_with_braces = extern_C_with_braces;
   }


// Default constructor defined here because the automatically generated constructor
// would not be generated with the error checking that I require to debug the use of
// the SgUnparse_Info object as an inherited attribute in the unparser.
SgUnparse_Info::SgUnparse_Info ()
   : SgSupport()
   {
     static int counter = 0;
     counter++;

#ifdef DEBUG
     mprintf ("In SgUnparse_Info::SgUnparse_Info () sage_class_name() = %s counter = %d \n",sage_class_name(),counter);
#endif

  // Supporting error checking for test of SgUnparse_Info as an inherited attribute in the unparser
     if (p_forceDefaultConstructorToTriggerError == true)
        {
          mprintf ("SgUnparse_Info constructor called in inappropriate location (part of debugging code) counter = %d \n",counter);
       // DQ (11/9/2009): This can be allowed to be uncommented!
          ROSE_ABORT();
        }

  // Test the variant virtual function
     assert(Unparse_InfoTag == variant());
     post_construction_initialization();

     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Test the isSgUnparse_Info() function since it has been problematic
     assert(isSgUnparse_Info(this) != NULL);

  // Initialize the nesting level to 0 (for python).
     p_nestingLevel = 0;
   }

// DQ (1/5/2008): I think this is a redundant function with the one in sageInterface.C
std::string
getSgVariant ( int variant )
   {
  // Return a string associated with the input variant!
  // check to make sure we have the correct variant and a valid string
     assert(variant == $GRAMMAR_NAMETerminalNames[variant].variant);

     return $GRAMMAR_NAMETerminalNames[variant].name;
   }

SgUnparse_Info::SgUnparse_Info ( const SgUnparse_Info & X )
   : SgSupport()
   {
     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     *this = X;

     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Copy nesting level (for python).
     p_nestingLevel = X.p_nestingLevel;

  // DQ (1/10/2014): Added to support token based unparsing.
     ROSE_ASSERT(p_current_source_file == X.p_current_source_file);
   }

SgUnparse_Info & SgUnparse_Info::operator= ( const SgUnparse_Info & X )
   {
     p_unparse_attribute      = X.p_unparse_attribute;
     p_access_attribute       = X.p_access_attribute;
     p_nested_expression      = X.p_nested_expression;
     p_operator_name          = X.p_operator_name;
     p_var_name               = X.p_var_name;
     p_declstatement_ptr      = X.p_declstatement_ptr;
     p_declaration_of_context = X.p_declaration_of_context;
     p_current_context        = X.p_current_context;
     p_array_index_list       = X.p_array_index_list;

  // DQ (11/6/2004): aded initialization of namespace context
     p_current_namespace      = X.p_current_namespace;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = X.p_outputCodeGenerationFormatDelimiters;

     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size()   == UNPARSE_TYPE_LAST);

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList = X.p_qualifiedNameList;

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = X.p_current_function_call;

  // DQ (5/22/2007): Added to support name qualification and access to the new hidden
  // type, declaration and class elaboration lists stored in the scopes.
     p_current_scope = X.p_current_scope;

  // DQ (5/11/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;

  // DQ (5/21/2011): New support for name qualification.
     p_reference_node_for_qualification = X.p_reference_node_for_qualification;

  // DQ (9/15/2012): Added mechanism to specify the language more directly.
  // Required to know when to unparse boolean values as integer for C and C99/C++
     p_language = X.p_language;

  // DQ (1/10/2014): Added to support token based unparsing.
     p_current_source_file = X.p_current_source_file;

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template
  // arguments as used in symbol table lookup.
     p_use_generated_name_for_template_arguments = X.p_use_generated_name_for_template_arguments;

  // DQ (12/26/2019): When supporting multiple files, the defining declaration in a named type must refer to the
  // defining declaration associated with the appropriate file (to be unparsed correctly).
     p_declstatement_associated_with_type = X.p_declstatement_associated_with_type;

     p_user_defined_literal = X.p_user_defined_literal;

  // DQ (8/15/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).
  // p_extern_C_with_braces = X.p_extern_C_with_braces;

  // DQ (8/24/2020): debugging Cxx_tests/test2020_44.C need to communicate when to suppress extra parenthesis use around SgFunctionType arguments.
     p_context_for_added_parentheses = X.p_context_for_added_parentheses;
     return *this;
   }

bool
SgUnparse_Info::checkBit(unparse_type_num bit) const
   {
     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     return p_unparse_attribute[bit];
   }

void
SgUnparse_Info::setBit(unparse_type_num bit)
   {
     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = true;
   }

void
SgUnparse_Info::unsetBit(unparse_type_num bit)
   {
     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = false;
   }

void
SgUnparse_Info::post_construction_initialization()
   {
  // DQ (11/4/2003): Modified initialization from "0" to "NULL"
  // and "" for non-integer values

     assert (this != NULL);

  // Clear all bit flags
     for (int i = 0; i < UNPARSE_TYPE_LAST; i++)
        {
          p_unparse_attribute.push_back(false);
        }
     assert (p_unparse_attribute.size() > 0);

     p_access_attribute       = a_unset_access;
     p_nested_expression      = false;
     p_operator_name          = "";
     p_var_name               = "";
     p_declstatement_ptr      = NULL;
     p_declaration_of_context = NULL;
     p_current_context        = NULL;
     p_array_index_list       = "";

  // DQ (1/12/2003): If calling constructor then empty the list
  // constructors (except copy constructor) are only call in the
  // initiation of a unparser traversal (precisely where there
  // is no context yet build up).

     if (p_structureTagProcessingList.empty() != true)
        {
       // empty the list (using STL list's assignment operator)
          SgTypePtrList emptyList;
          p_structureTagProcessingList = emptyList;
        }

  // DQ (11/6/2004): Added initialization of namespace context (error reported valgrind)
     p_current_namespace = NULL;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = false;

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList.clear();

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = NULL;

  // DQ (6/2/2007): Added initialization of new data member.
     p_current_scope = NULL;

  // DQ (5/21/2011): New support for name qualification.
     p_reference_node_for_qualification = NULL;

  // DQ (5/11/2011): New support for name qualification.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;

  // DQ (12/26/2019): Added initialization.
     p_nestingLevel = 0;

  // DQ (12/26/2019): Added initialization.
     p_language = SgFile::e_default_language;

  // DQ (1/10/2014): Added to support token based unparsing.
     p_current_source_file = NULL;

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template
  // arguments as used in symbol table lookup.
     p_use_generated_name_for_template_arguments = false;

  // DQ (12/26/2019): Added initialization.
     p_user_defined_literal = false;

  // DQ (12/26/2019): When supporting multiple files, the defining declaration in a named type must refer to the
  // defining declaration associated with the appropriate file (to be unparsed correctly).
     p_declstatement_associated_with_type = NULL;

  // DQ (8/15/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).

  // DQ (8/24/2020): debugging Cxx_tests/test2020_44.C need to communicate when to suppress extra parenthesis use around SgFunctionType arguments.
     p_context_for_added_parentheses = false;
   }

bool
SgUnparse_Info::isUnsetAccess() const
   { return p_access_attribute == a_unset_access; }

void
SgUnparse_Info::set_isUnsetAccess()
   { p_access_attribute = a_unset_access; }

bool
SgUnparse_Info::isPrivateAccess() const
   { return p_access_attribute == a_private_access; }

void
SgUnparse_Info::set_isPrivateAccess()
   { p_access_attribute = a_private_access; }

bool
SgUnparse_Info::isProtectedAccess() const
   { return p_access_attribute == a_protected_access; }

void
SgUnparse_Info::set_isProtectedAccess()
   { p_access_attribute = a_protected_access; }

bool
SgUnparse_Info::isPublicAccess() const
   { return p_access_attribute == a_public_access; }

void
SgUnparse_Info::set_isPublicAccess()
   { p_access_attribute = a_public_access; }

// DQ (8/12/2020): Adding a default value for when it is not set explicitly.
bool
SgUnparse_Info::isDefaultAccess() const
   { return p_access_attribute == a_default_access; }

void
SgUnparse_Info::set_isDefaultAccess()
   { p_access_attribute = a_default_access; }



bool
SgUnparse_Info::isPointerToSomething() const
   { return checkBit(b_isPointerToSomething); }

void
SgUnparse_Info::set_isPointerToSomething()
   { setBit(b_isPointerToSomething); }

void
SgUnparse_Info::unset_isPointerToSomething()
   { unsetBit(b_isPointerToSomething); }

bool
SgUnparse_Info::isReferenceToSomething() const
   { return checkBit(b_isReferenceToSomething); }

void
SgUnparse_Info::set_isReferenceToSomething()
   { setBit(b_isReferenceToSomething); }

void
SgUnparse_Info::unset_isReferenceToSomething()
   { unsetBit(b_isReferenceToSomething); }

bool
SgUnparse_Info::inVarDecl() const
   { return checkBit(b_inVarDecl); }

void
SgUnparse_Info::set_inVarDecl()
   { setBit(b_inVarDecl); }

void
SgUnparse_Info::unset_inVarDecl()
   { unsetBit(b_inVarDecl); }

bool
SgUnparse_Info::inArgList() const
   { return checkBit(b_inArgList); }

void
SgUnparse_Info::set_inArgList()
   { setBit(b_inArgList); }

void
SgUnparse_Info::unset_inArgList()
   { unsetBit(b_inArgList); }

bool
SgUnparse_Info::SkipSemiColon() const
   { return checkBit(b_SkipSemiColon); }

void
SgUnparse_Info::set_SkipSemiColon()
   { setBit(b_SkipSemiColon); }

void
SgUnparse_Info::unset_SkipSemiColon()
   { unsetBit(b_SkipSemiColon); }

bool
SgUnparse_Info::inEnumDecl() const
   { return checkBit(b_inEnumDecl); }

void
SgUnparse_Info::set_inEnumDecl()
   { setBit(b_inEnumDecl); }

void
SgUnparse_Info::unset_inEnumDecl()
   { unsetBit(b_inEnumDecl); }

bool
SgUnparse_Info::inTemplateList() const
   { return checkBit(b_inTemplateList); }

void
SgUnparse_Info::set_inTemplateList()
   { setBit(b_inTemplateList); }

void
SgUnparse_Info::unset_inTemplateList()
   { unsetBit(b_inTemplateList); }

bool
SgUnparse_Info::SkipBaseType() const
   { return checkBit(b_SkipBaseType); }

void
SgUnparse_Info::set_SkipBaseType()
   { setBit(b_SkipBaseType); }

void
SgUnparse_Info::unset_SkipBaseType()
   { unsetBit(b_SkipBaseType); }

bool
SgUnparse_Info::inAggregateInitializer() const
   { return checkBit(b_inAggregateInitializer); }

void
SgUnparse_Info::set_inAggregateInitializer()
   { setBit(b_inAggregateInitializer); }

void
SgUnparse_Info::unset_inAggregateInitializer()
   { unsetBit(b_inAggregateInitializer); }

bool
SgUnparse_Info::isWithType() const
   { return checkBit(b_isWithType); }

void
SgUnparse_Info::set_isWithType()
   { setBit(b_isWithType); }

void
SgUnparse_Info::unset_isWithType()
   { unsetBit(b_isWithType); }

bool
SgUnparse_Info::inConditional() const
   { return checkBit(b_inConditional); }

void
SgUnparse_Info::set_inConditional()
   { setBit(b_inConditional); }

void
SgUnparse_Info::unset_inConditional()
   { unsetBit(b_inConditional); }

// DQ (1/23/03) Modified use of SkipDefinition to separate the functionality across
// different types of definitions (Enum, Function, and Class definitions).
bool
SgUnparse_Info::SkipDefinition() const
   { // return checkBit(b_SkipDefinition);
     return checkBit(b_SkipEnumDefinition) &&
            checkBit(b_SkipFunctionDefinition) &&
            checkBit(b_SkipClassDefinition);
   }

void
SgUnparse_Info::set_SkipDefinition()
   {
  // setBit(b_SkipDefinition);
     setBit(b_SkipEnumDefinition);
     setBit(b_SkipFunctionDefinition);
     setBit(b_SkipClassDefinition);
   }

void
SgUnparse_Info::unset_SkipDefinition()
   {
  // unsetBit(b_SkipDefinition);
     unsetBit(b_SkipEnumDefinition);
     unsetBit(b_SkipFunctionDefinition);
     unsetBit(b_SkipClassDefinition);
   }

bool
SgUnparse_Info::SkipClassSpecifier() const
   { return checkBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::set_SkipClassSpecifier()
   { setBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::unset_SkipClassSpecifier()
   { unsetBit(b_SkipClassSpecifier); }

bool
SgUnparse_Info::inEmbeddedDecl() const
   { return checkBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::set_inEmbeddedDecl()
   { setBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::unset_inEmbeddedDecl()
   { unsetBit(b_inEmbeddedDecl); }

bool
SgUnparse_Info::SkipGlobal() const
   { return checkBit(b_SkipGlobal); }

void
SgUnparse_Info::set_SkipGlobal()
   { setBit(b_SkipGlobal); }

void
SgUnparse_Info::unset_SkipGlobal()
   { unsetBit(b_SkipGlobal); }

bool
SgUnparse_Info::SkipAtomic() const
   { return checkBit(b_SkipAtomic); }

void
SgUnparse_Info::set_SkipAtomic()
   { setBit(b_SkipAtomic); }

void
SgUnparse_Info::unset_SkipAtomic()
   { unsetBit(b_SkipAtomic); }

bool
SgUnparse_Info::PrintName() const
   { return checkBit(b_PrintName); }

void
SgUnparse_Info::set_PrintName()
   {
  // DQ (7/30/2012): I like this simpler semantics better.
     setBit(b_PrintName);
   }

void
SgUnparse_Info::unset_PrintName()
   { unsetBit(b_PrintName); }

bool
SgUnparse_Info::CheckAccess() const
   { return checkBit(b_CheckAccess); }

void
SgUnparse_Info::set_CheckAccess()
   { setBit(b_CheckAccess); }

void
SgUnparse_Info::unset_CheckAccess()
   { unsetBit(b_CheckAccess); }

bool
SgUnparse_Info::SkipFunctionQualifier() const
   { return checkBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::set_SkipFunctionQualifier()
   { setBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::unset_SkipFunctionQualifier()
   { unsetBit(b_SkipFunctionQualifier); }

bool
SgUnparse_Info::isArrayType() const
   { return checkBit(b_isArrayType); }

void
SgUnparse_Info::set_isArrayType()
   { setBit(b_isArrayType); }

void
SgUnparse_Info::unset_isArrayType()
   { unsetBit(b_isArrayType); }

bool
SgUnparse_Info::inRhsExpr() const
   { return checkBit(b_inRhsExpr); }

void
SgUnparse_Info::set_inRhsExpr()
   { setBit(b_inRhsExpr); }

void
SgUnparse_Info::unset_inRhsExpr()
   { unsetBit(b_inRhsExpr); }

bool
SgUnparse_Info::SkipParen() const
   { return checkBit(b_SkipParen); }

void
SgUnparse_Info::set_SkipParen()
   { setBit(b_SkipParen); }

void
SgUnparse_Info::unset_SkipParen()
   { unsetBit(b_SkipParen); }

bool
SgUnparse_Info::isTypeSecondPart() const
   { return checkBit(b_isTypeSecondPart); }

void
SgUnparse_Info::set_isTypeSecondPart()
   { setBit(b_isTypeSecondPart); unsetBit(b_isTypeFirstPart); }

void
SgUnparse_Info::unset_isTypeSecondPart()
   { unsetBit(b_isTypeSecondPart); }

bool
SgUnparse_Info::isTypeFirstPart() const
   { return checkBit(b_isTypeFirstPart); }

void
SgUnparse_Info::set_isTypeFirstPart()
   { setBit(b_isTypeFirstPart); unsetBit(b_isTypeSecondPart); }

void
SgUnparse_Info::unset_isTypeFirstPart()
   { unsetBit( b_isTypeFirstPart); }

std::string
SgUnparse_Info::get_operator_name()
   { return p_operator_name; }

void
SgUnparse_Info::set_operator_name(const std::string& on)
   {
     p_operator_name = on;
   }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipInitializer() const
   { return checkBit(b_SkipInitializer); }

void
SgUnparse_Info::set_SkipInitializer()
   { setBit(b_SkipInitializer); }

void
SgUnparse_Info::unset_SkipInitializer()
   { unsetBit(b_SkipInitializer); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipComments() const
   { return checkBit(b_SkipComments); }

void
SgUnparse_Info::set_SkipComments()
   { setBit(b_SkipComments); }

void
SgUnparse_Info::unset_SkipComments()
   { unsetBit(b_SkipComments); }

//! (09/03/03) MS: Added to make whitespace optional
bool
SgUnparse_Info::SkipWhitespaces() const
   { return checkBit(b_SkipWhitespaces); }

void
SgUnparse_Info::set_SkipWhitespaces()
   { setBit(b_SkipWhitespaces); }

void
SgUnparse_Info::unset_SkipWhitespaces()
   { unsetBit(b_SkipWhitespaces); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipCPPDirectives() const
   { return checkBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::set_SkipCPPDirectives()
   { setBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::unset_SkipCPPDirectives()
   { unsetBit(b_SkipCPPDirectives); }

bool
SgUnparse_Info::SkipEnumDefinition() const
   { return checkBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::set_SkipEnumDefinition()
   { setBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::unset_SkipEnumDefinition()
   { unsetBit(b_SkipEnumDefinition); }

bool
SgUnparse_Info::SkipFunctionDefinition() const
   { return checkBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::set_SkipFunctionDefinition()
   { setBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::unset_SkipFunctionDefinition()
   { unsetBit(b_SkipFunctionDefinition); }

bool
SgUnparse_Info::SkipClassDefinition() const
   { return checkBit(b_SkipClassDefinition); }

void
SgUnparse_Info::set_SkipClassDefinition()
   { setBit(b_SkipClassDefinition); }

void
SgUnparse_Info::unset_SkipClassDefinition()
   { unsetBit(b_SkipClassDefinition); }

bool
SgUnparse_Info::AddSemiColonAfterDeclaration() const
   { return checkBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::set_AddSemiColonAfterDeclaration()
   { setBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::unset_AddSemiColonAfterDeclaration()
   { unsetBit(b_AddSemiColonAfterDeclaration); }

bool
SgUnparse_Info::SkipBasicBlock() const
   { return checkBit(b_SkipBasicBlock); }

void
SgUnparse_Info::set_SkipBasicBlock()
   { setBit(b_SkipBasicBlock); }

void
SgUnparse_Info::unset_SkipBasicBlock()
   { unsetBit(b_SkipBasicBlock); }

// DQ (3/18/2004): Added to support unparsing of class templates in variables but
// not in in instatiated template declarations (unless the template is transformed
// in which case another test is used).
bool
SgUnparse_Info::outputClassTemplateName() const
   { return checkBit(b_outputClassTemplateName); }

void
SgUnparse_Info::set_outputClassTemplateName()
   { setBit(b_outputClassTemplateName); }

void
SgUnparse_Info::unset_outputClassTemplateName()
   { unsetBit(b_outputClassTemplateName); }

// DQ (5/27/2005): support (see documentation above, in header file enum value)
bool
SgUnparse_Info::outputCompilerGeneratedStatements() const
   { return checkBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::set_outputCompilerGeneratedStatements()
   { setBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::unset_outputCompilerGeneratedStatements()
   { unsetBit(b_outputCompilerGeneratedStatements); }


// DQ (4/5/2006): Added support for constant folded values to be optionally output
bool
SgUnparse_Info::SkipConstantFoldedExpressions() const
   { return checkBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::set_SkipConstantFoldedExpressions()
   { setBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::unset_SkipConstantFoldedExpressions()
   { unsetBit(b_SkipConstantFoldedExpressions); }


// DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
bool
SgUnparse_Info::forceQualifiedNames() const
   { return checkBit(b_forceQualifiedNames); }

void
SgUnparse_Info::set_forceQualifiedNames()
   { setBit(b_forceQualifiedNames); }

void
SgUnparse_Info::unset_forceQualifiedNames()
   { unsetBit(b_forceQualifiedNames); }

bool
SgUnparse_Info::skipCheckAccess() const
   { return checkBit(b_skipCheckAccess); }

void
SgUnparse_Info::set_skipCheckAccess()
   { setBit(b_skipCheckAccess); }

void
SgUnparse_Info::unset_skipCheckAccess()
   { unsetBit(b_skipCheckAccess); }

// DQ (10/11/2006): Added to support new implementation of name qualification
bool
SgUnparse_Info::SkipQualifiedNames() const
   { return checkBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::set_SkipQualifiedNames()
   { setBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::unset_SkipQualifiedNames()
   { unsetBit(b_SkipQualifiedNames); }

bool
SgUnparse_Info::requiresGlobalNameQualification() const
   { return checkBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::set_requiresGlobalNameQualification()
   { setBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::unset_requiresGlobalNameQualification()
   { unsetBit(b_requiresGlobalNameQualification); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
bool
SgUnparse_Info::useTypeAttributes() const
   { return checkBit(b_useTypeAttributes); }

void
SgUnparse_Info::set_useTypeAttributes()
   { setBit(b_useTypeAttributes); }

void
SgUnparse_Info::unset_useTypeAttributes()
   { unsetBit(b_useTypeAttributes); }

// DQ (12/26/2007): Added support to restrict formatting of Fortran code.
// This allows us to put statements on the same line as if-stmt, where-stmt, etc.
// Plus it allows us to skip the insertion of leading 6 spaces in fixed format output.
bool
SgUnparse_Info::SkipFormatting() const
   { return checkBit(b_SkipFormatting); }

void
SgUnparse_Info::set_SkipFormatting()
   { setBit(b_SkipFormatting); }

void
SgUnparse_Info::unset_SkipFormatting()
   { unsetBit(b_SkipFormatting); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
bool
SgUnparse_Info::supressStrippedTypeName() const
   { return checkBit(b_supressStrippedTypeName); }

void
SgUnparse_Info::set_supressStrippedTypeName()
   { setBit(b_supressStrippedTypeName); }

void
SgUnparse_Info::unset_supressStrippedTypeName()
   { unsetBit(b_supressStrippedTypeName); }


SgName&
SgUnparse_Info::get_name()
   { return p_var_name; }

void
SgUnparse_Info::set_name(const SgName& name)
   { p_var_name = name; set_PrintName(); }

void
SgUnparse_Info::unset_name()
   {
     unset_PrintName();
     p_var_name=0;
   }

SgDeclarationStatement*
SgUnparse_Info::get_decl_stmt()
   { return p_declstatement_ptr; }

void
SgUnparse_Info::set_decl_stmt(SgDeclarationStatement* stmt )
   { p_declstatement_ptr = stmt; }

void
SgUnparse_Info::unset_decl_stmt()
   { p_declstatement_ptr=0; }

int
SgUnparse_Info::get_nested_expression()
   { return p_nested_expression; }

void
SgUnparse_Info::set_nested_expression()
   { p_nested_expression++; }

void
SgUnparse_Info::unset_nested_expression()
   { p_nested_expression--; }

// DQ (11/21/2021): Adding support for types to be unparsed with the context of the correct declaration to support multi-file handling.
void
SgUnparse_Info::unset_declaration_of_context()
   { p_declaration_of_context = NULL; }

void
SgUnparse_Info::unset_current_context()
   { p_current_context = NULL; }

SgName
SgUnparse_Info::get_array_index_list()
{ return p_array_index_list; }

void
SgUnparse_Info::set_array_index_list(SgExpression *e, SgUnparse_Info finfo )
   {
     mprintf ("ERROR: not implemented in SAGE3! \n");
     ROSE_ABORT();
   }

void
SgUnparse_Info::unset_array_index_list()
   { p_array_index_list=0; }

// FMZ : Added to support to generated XX.rose_mod file for a module
//       (based on fortran unparser).
bool
SgUnparse_Info::outputFortranModFile() const
   { return checkBit(b_outputFortranModFile); }

void
SgUnparse_Info::set_outputFortranModFile()
   { setBit(b_outputFortranModFile); }

void
SgUnparse_Info::unset_outputFortranModFile()
   { unsetBit(b_outputFortranModFile); }


// DQ (4/13/2013): Added support to mark overloaded operators as prefix operators so they can be unparsed before the lhs.
bool
SgUnparse_Info::isPrefixOperator() const
   { return checkBit(b_prefixOperator); }

void
SgUnparse_Info::set_prefixOperator()
   { setBit(b_prefixOperator); }

void
SgUnparse_Info::unset_prefixOperator()
   { unsetBit(b_prefixOperator); }

// DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
bool SgUnparse_Info::supressArrayBound() const
   { return checkBit(b_supressArrayBound); }

void SgUnparse_Info::set_supressArrayBound()
   { setBit(b_supressArrayBound); }

void SgUnparse_Info::unset_supressArrayBound()
   { unsetBit(b_supressArrayBound); }


// DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
bool SgUnparse_Info::supressImplicitThisOperator() const
   { return checkBit(b_supressImplicitThisOperator); }

void SgUnparse_Info::set_supressImplicitThisOperator()
   { setBit(b_supressImplicitThisOperator); }

void SgUnparse_Info::unset_supressImplicitThisOperator()
   { unsetBit(b_supressImplicitThisOperator); }

// DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
bool SgUnparse_Info::unparsedPartiallyUsingTokenStream() const
   { return checkBit(b_unparsedPartiallyUsingTokenStream); }

void SgUnparse_Info::set_unparsedPartiallyUsingTokenStream()
   { setBit(b_unparsedPartiallyUsingTokenStream); }

void SgUnparse_Info::unset_unparsedPartiallyUsingTokenStream()
   { unsetBit(b_unparsedPartiallyUsingTokenStream); }

// DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
bool SgUnparse_Info::skipCompilerGeneratedSubExpressions() const
   { return checkBit(b_skipCompilerGeneratedSubExpressions); }

void SgUnparse_Info::set_skipCompilerGeneratedSubExpressions()
   { setBit(b_skipCompilerGeneratedSubExpressions); }

void SgUnparse_Info::unset_skipCompilerGeneratedSubExpressions()
   { unsetBit(b_skipCompilerGeneratedSubExpressions); }

// DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
bool SgUnparse_Info::parentStatementListBeingUnparsedUsingPartialTokenSequence() const
   { return checkBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

void SgUnparse_Info::set_parentStatementListBeingUnparsedUsingPartialTokenSequence()
   { setBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

void SgUnparse_Info::unset_parentStatementListBeingUnparsedUsingPartialTokenSequence()
   { unsetBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

// DQ (2/8/2016): Adding support for C++11 specific initialization lists.
bool
SgUnparse_Info::get_cxx11_initialization_list() const
   { return checkBit(b_cxx11_initialization_list); }

void
SgUnparse_Info::set_cxx11_initialization_list()
   { setBit(b_cxx11_initialization_list); }

void
SgUnparse_Info::unset_cxx11_initialization_list()
   { unsetBit(b_cxx11_initialization_list); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
bool
SgUnparse_Info::inTypedefDecl() const
   { return checkBit(b_inTypedefDecl); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
void
SgUnparse_Info::set_inTypedefDecl()
   { setBit(b_inTypedefDecl); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
void
SgUnparse_Info::unset_inTypedefDecl()
   { unsetBit(b_inTypedefDecl); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
bool
SgUnparse_Info::SkipNameQualification() const
   { return checkBit(b_SkipNameQualification); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
void
SgUnparse_Info::set_SkipNameQualification()
   { setBit(b_SkipNameQualification); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
void
SgUnparse_Info::unset_SkipNameQualification()
   { unsetBit(b_SkipNameQualification); }

// DQ (12/26/2019): unparsing for defining declarations in named types defined in multiple translation units (multi-file support).
bool
SgUnparse_Info::useAlternativeDefiningDeclaration() const
   { return checkBit(b_useAlternativeDefiningDeclaration); }

void
SgUnparse_Info::set_useAlternativeDefiningDeclaration()
   { setBit(b_useAlternativeDefiningDeclaration); }

void
SgUnparse_Info::unset_useAlternativeDefiningDeclaration()
   { unsetBit(b_useAlternativeDefiningDeclaration); }

// DQ (1/6/2021): Adding support to detect use of unparseToString() functionality.  This is required to avoid premature saving of state
// regarding the static previouslyUnparsedTokenSubsequences which is required to support multiple statements (e.g. a variable declarations
// with containing multiple variables which translates (typically) to multiple variable declarations (each with one variable) within the AST).
bool
SgUnparse_Info::usedInUparseToStringFunction() const
   { return checkBit(b_usedInUparseToStringFunction); }

void
SgUnparse_Info::set_usedInUparseToStringFunction()
   { setBit(b_usedInUparseToStringFunction); }

void
SgUnparse_Info::unset_usedInUparseToStringFunction()
   { unsetBit(b_usedInUparseToStringFunction); }


void
SgUnparse_Info::display ( const std::string & label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("\nInside of SgUnparse_Info::display(%s) \n",label.c_str());

  // DQ: Note that this provides better formatting of the output!
     printf ("isPointerToSomething                   = %s \n",( isPointerToSomething() == true ) ? "true" : "false");
     printf ("isReferenceToSomething                 = %s \n",( isReferenceToSomething() == true ) ? "true" : "false");
     printf ("inVarDecl                              = %s \n",( inVarDecl() == true ) ? "true" : "false");
     printf ("inArgList                              = %s \n",( inArgList() == true ) ? "true" : "false");
     printf ("SkipSemiColon                          = %s \n",( SkipSemiColon() == true ) ? "true" : "false");
     printf ("inEnumDecl                             = %s \n",( inEnumDecl() == true ) ? "true" : "false");
     printf ("inTemplateList                         = %s \n",( inTemplateList() == true ) ? "true" : "false");
     printf ("SkipBaseType                           = %s \n",( SkipBaseType() == true ) ? "true" : "false");
     printf ("inAggregateInitializer                 = %s \n",( inAggregateInitializer() == true ) ? "true" : "false");
     printf ("isWithType                             = %s \n",( isWithType() == true ) ? "true" : "false");
     printf ("inConditional                          = %s \n",( inConditional() == true ) ? "true" : "false");
     printf ("SkipDefinition                         = %s \n",( SkipDefinition() == true ) ? "true" : "false");
     printf ("SkipClassSpecifier                     = %s \n",( SkipClassSpecifier() == true ) ? "true" : "false");
     printf ("inEmbeddedDecl                         = %s \n",( inEmbeddedDecl() == true ) ? "true" : "false");
     printf ("SkipGlobal                             = %s \n",( SkipGlobal() == true ) ? "true" : "false");
     printf ("SkipAtomic                             = %s \n",( SkipAtomic() == true ) ? "true" : "false");
     printf ("PrintName                              = %s \n",( PrintName() == true ) ? "true" : "false");
     printf ("CheckAccess                            = %s \n",( CheckAccess() == true ) ? "true" : "false");
     printf ("SkipFunctionQualifier                  = %s \n",( SkipFunctionQualifier() == true ) ? "true" : "false");
     printf ("isArrayType                            = %s \n",( isArrayType() == true ) ? "true" : "false");
     printf ("inRhsExpr                              = %s \n",( inRhsExpr() == true ) ? "true" : "false");
     printf ("SkipParen                              = %s \n",( SkipParen() == true ) ? "true" : "false");
     printf ("isTypeSecondPart                       = %s \n",( isTypeSecondPart() == true ) ? "true" : "false");
     printf ("isTypeFirstPart                        = %s \n",( isTypeFirstPart() == true ) ? "true" : "false");
     printf ("SkipInitializer                        = %s \n",( SkipInitializer() == true ) ? "true" : "false");
     printf ("SkipComments                           = %s \n",( SkipComments() == true ) ? "true" : "false");
     printf ("SkipCPPDirectives                      = %s \n",( SkipCPPDirectives() == true ) ? "true" : "false");
     printf ("SkipEnumDefinition                     = %s \n",( SkipEnumDefinition() == true ) ? "true" : "false");
     printf ("SkipFunctionDefinition                 = %s \n",( SkipFunctionDefinition() == true ) ? "true" : "false");
     printf ("SkipClassDefinition                    = %s \n",( SkipClassDefinition() == true ) ? "true" : "false");
     printf ("AddSemiColonAfterDeclaration           = %s \n",( AddSemiColonAfterDeclaration() == true ) ? "true" : "false");
     printf ("SkipWhitespaces                        = %s \n",( SkipWhitespaces() == true ) ? "true" : "false");
     printf ("SkipBasicBlock                         = %s \n",( SkipBasicBlock() == true ) ? "true" : "false");
     printf ("outputClassTemplateName                = %s \n",( outputClassTemplateName() == true ) ? "true" : "false");
     printf ("outputCompilerGeneratedStatements      = %s \n",( outputCompilerGeneratedStatements() == true ) ? "true" : "false");
     printf ("SkipConstantFoldedExpressions          = %s \n",( SkipConstantFoldedExpressions() == true ) ? "true" : "false");
     printf ("forceQualifiedNames                    = %s \n",( forceQualifiedNames() == true ) ? "true" : "false");
     printf ("SkipQualifiedNames                     = %s \n",( SkipQualifiedNames() == true ) ? "true" : "false");
     printf ("skipCheckAccess                        = %s \n",( skipCheckAccess() == true ) ? "true" : "false");
     printf ("requiresGlobalNameQualification        = %s \n",( requiresGlobalNameQualification() == true ) ? "true" : "false");
     printf ("supressArrayBound                      = %s \n",( supressArrayBound() == true ) ? "true" : "false");
     printf ("supressImplicitThisOperator            = %s \n",( supressImplicitThisOperator() == true ) ? "true" : "false");
     printf ("unparsedPartiallyUsingTokenStream      = %s \n",( unparsedPartiallyUsingTokenStream() == true ) ? "true" : "false");
     printf ("skipCompilerGeneratedSubExpressions    = %s \n",( skipCompilerGeneratedSubExpressions() == true ) ? "true" : "false");

     printf ("parentStatementListBeingUnparsedUsingPartialTokenSequence = %s \n",( parentStatementListBeingUnparsedUsingPartialTokenSequence() == true ) ? "true" : "false");

  // DQ (2/3/2019): Ading support to know when we are in a typedef.
     printf ("inTypedefDecl                          = %s \n",( inTypedefDecl() == true ) ? "true" : "false");

  // DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
     printf ("SkipNameQualification                  = %s \n",( SkipNameQualification() == true ) ? "true" : "false");

     switch (p_access_attribute)
        {
          case a_unset_access:
               printf ("p_access                               = unset access \n");
               break;
          case a_private_access:
               printf ("p_access                               = private access \n");
               break;
          case a_protected_access:
               printf ("p_access                               = protected access \n");
               break;
          case a_public_access:
               printf ("p_access                               = public access \n");
               break;
          default:
               printf ("Error: default reached in switch \n");
               assert(false);
        }

  // DQ (1/26/2006): Modified to handle 64 bit machines
     printf ("p_structureTagProcessingList.size()    = %" PRIuPTR " \n", p_structureTagProcessingList.size());
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          printf ("--- structure tag pointer = %p class name = %s \n",*i,(*i)->sage_class_name());

          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               printf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     printf ("p_nested_expression                    = %d \n",p_nested_expression);
     printf ("p_operator_name                        = %s \n", p_operator_name.c_str());
     printf ("p_var_name                             = %s \n",(p_var_name.is_null() == false) ? p_var_name.str() : "EmPtY sTrInG");

     printf ("p_declstatement_ptr                    = %p = %s \n",p_declstatement_ptr,p_declstatement_ptr != NULL ? p_declstatement_ptr->class_name().c_str() : "null");
     if (p_declstatement_ptr != NULL)
        {
          printf ("   --- firstNondefiningDeclaration = %p \n",p_declstatement_ptr->get_firstNondefiningDeclaration());
          printf ("   --- definingDeclaration         = %p \n",p_declstatement_ptr->get_definingDeclaration());
        }

     printf ("p_declaration_of_context               = %p \n",p_declaration_of_context);
     printf ("p_current_context                      = %p \n",p_current_context);
     printf ("p_array_index_list                     = %s \n",(p_array_index_list.is_null() == false) ? p_array_index_list.str() : "EmPtY sTrInG");
     printf ("p_current_namespace                    = %p \n",p_current_namespace);
     printf ("p_outputCodeGenerationFormatDelimiters = %s \n",p_outputCodeGenerationFormatDelimiters ? "true" : "false");

     printf ("p_current_function_call                = %p \n",p_current_function_call);
     printf ("p_current_scope                        = %p = %s \n",p_current_scope,p_current_scope != NULL ? p_current_scope->class_name().c_str() : "EmPtY sTrInG");

  // DQ (5/21/2011): Added support for name qualification...
     printf ("p_reference_node_for_qualification     = %p = %s \n",p_reference_node_for_qualification,p_reference_node_for_qualification != NULL ? p_reference_node_for_qualification->class_name().c_str() : "EmPtY sTrInG");

     printf ("p_language (value)                     = %d \n",p_language);

  // DQ (9/24/2013): Added function to output the name of the language for the generated code.
     printf ("p_language (name)                      = %s \n",SgFile::get_outputLanguageOptionName(p_language).c_str());

  // DQ (1/10/2015): Added support for debugging the SgUnparse_Info object.
     printf ("p_current_source_file                  = %p = %s \n",p_current_source_file,p_current_source_file != NULL ? p_current_source_file->class_name().c_str() : "EmPtY sTrInG");

  // DQ (10/23/2018): Output the name of the file to support debugging of the token based unparsing.
     if (p_current_source_file != NULL)
        {
          printf ("   --- p_current_source_file = %s \n",p_current_source_file->getFileName().c_str());
        }

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template
  // arguments as used in symbol table lookup.
     printf ("p_use_generated_name_for_template_arguments = %s \n",p_use_generated_name_for_template_arguments ? "true" : "false");

  // DQ (8/15/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).
     printf ("p_extern_C_with_braces                 = %s \n",p_extern_C_with_braces ? "true" : "false");

  // DQ (8/24/2020): debugging Cxx_tests/test2020_44.C need to communicate when to suppress extra parenthesis use around SgFunctionType arguments.
     printf ("p_context_for_added_parentheses        = %s \n",p_context_for_added_parentheses ? "true" : "false");
   }

string
SgUnparse_Info::displayString ( const std::string & label ) const
   {
  // using namespace std;
     std::string returnString = std::string("Inside of SgUnparse_Info::display( ") + label + std::string(" )\n");

#define STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) \
     returnString += std::string("     ") + std::string(#XX) + std::string(" = ") + std::string((XX() == true) ? "true" : "false") + std::string(" \n");

     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)

  // DQ (2/3/2019): Adding support to know when we are in a typedef.
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTypedefDecl)

  // DQ (8/15/2020): Record when we are in an extern "C" so that we can avoid nesting (see Cxx_tests/test2020_28.C).
  // STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(extern_C_with_braces)

     switch (p_access_attribute)
        {
          case a_unset_access:
               returnString += std::string("p_access = unset access \n");
               break;
          case a_private_access:
               returnString += std::string("p_access = private access \n");
               break;
          case a_protected_access:
               returnString += std::string("p_access = protected access \n");
               break;
          case a_public_access:
               returnString += std::string("p_access = public access \n");
               break;
          default:
               printf("Error: default reached in switch \n");
               assert(false);
        }

     returnString += std::string("p_structureTagProcessingList.size() = ") +
                     Rose::StringUtility::numberToString(p_structureTagProcessingList.size()) + std::string("\n");
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          returnString += std::string("--- structure tag pointer = ") +
                          Rose::StringUtility::numberToString((void*)(*i)) +
                          std::string("= class name = ") + std::string((*i)->sage_class_name()) + std::string("\n");
          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               returnString += std::string("     Class name = ") + std::string(classType->get_name().str()) + std::string("\n");
             }
        }

     return returnString;
   }

void
SgUnparse_Info::addStructureTag ( SgNamedType* structureTag )
   {
  // push the pointer to the back of the list
     p_structureTagProcessingList.push_back(structureTag);
   }

SgTypePtrList &
SgUnparse_Info::getStructureTagList ()
   {
  // Access function for internal STL list
     return p_structureTagProcessingList;
   }

void
SgUnparse_Info::inc_nestingLevel() {
    p_nestingLevel += 1;
}

void
SgUnparse_Info::dec_nestingLevel() {
    p_nestingLevel -= 1;
    if (p_nestingLevel < 0) {
        cerr << "warning: SgUnparse_Info.p_nestingLevel decremented below zero." << endl;
    }
}


// DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
SgStatement* SgUnparse_Info::p_previouslyUnparsedStatement              = NULL;
bool         SgUnparse_Info::p_previousStatementUnparsedFromTokenStream = false;

// DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
SgStatement* SgUnparse_Info::get_previouslyUnparsedStatement()
   {
     return p_previouslyUnparsedStatement;
   }

// DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
void SgUnparse_Info::set_previouslyUnparsedStatement( SgStatement* previouslyUnparsedStatement )
   {
     p_previouslyUnparsedStatement = previouslyUnparsedStatement;
   }

// DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
bool SgUnparse_Info::get_previousStatementUnparsedFromTokenStream()
   {
     return p_previousStatementUnparsedFromTokenStream;
   }

// DQ (6/5/2021): Support for debugging, we want to debug the transitions between token-based unparsing and unparsing from the AST.
void SgUnparse_Info::set_previousStatementUnparsedFromTokenStream( bool previousStatementUnparsedFromTokenStream )
   {
     p_previousStatementUnparsedFromTokenStream = previousStatementUnparsedFromTokenStream;
   }


SOURCE_UNPARSE_INFO_END

HEADER_TYPEDEF_SEQ_START
      // Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
      //! This is the const STL container access function for the STL list of typedef types using the type pointing to this SgTypedefSeq.
          const SgTypePtrList & get_typedefs() const;

      // Get the list of input types (types of the parameters list) to this function type
      //! This is the non-const STL container access function for the STL list of typedef types using the type pointing to this SgTypedefSeq.
          SgTypePtrList & get_typedefs();

      //! Append new typedef to typedef type list
          void append_typedef( SgType* what);

      //! Insert new typedef to typedef type list
          void insert_typedef(const SgTypePtrList::iterator& where, SgType* what);

HEADER_TYPEDEF_SEQ_END

SOURCE_TYPEDEF_SEQ_START
const SgTypePtrList &
$CLASSNAME::get_typedefs() const
   { return p_typedefs; }

SgTypePtrList &
$CLASSNAME::get_typedefs()
   { return p_typedefs; }

void
$CLASSNAME::append_typedef( SgType* what)
   {
     insert_typedef(p_typedefs.end(),what);
   }

void
$CLASSNAME::insert_typedef(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_typedefs.insert(where,what);
   }
SOURCE_TYPEDEF_SEQ_END


HEADER_FUNCTION_PARAMETER_TYPE_LIST_START
      //! Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
          const SgTypePtrList & get_arguments() const;

      //! Get the list of input types (types of the parameters list) to this function type
          SgTypePtrList & get_arguments();

       // WAS: void append_argument(const SgTypePtr& what);
       // WAS: void insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)

      //! Append new argument to argument type list
          void append_argument( SgType* what);

      //! Insert new argument to argument type list
          void insert_argument(const SgTypePtrList::iterator& where, SgType* what);

       // DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFunctionParameterTypeList();

HEADER_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_FUNCTION_PARAMETER_TYPE_LIST_START
const SgTypePtrList &
$CLASSNAME::get_arguments() const
   { return p_arguments; }

SgTypePtrList &
$CLASSNAME::get_arguments()
   { return p_arguments; }

void
$CLASSNAME::append_argument( SgType* what)
   {
     insert_argument(p_arguments.end(),what);
   }

void
$CLASSNAME::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_arguments.insert(where,what);
   }

// DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFunctionParameterTypeList::SgFunctionParameterTypeList()
   {
  // Build the default constructor (nothing to build here since the only data member is an STL list)
   }

SOURCE_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_TEMPLATE_PARAMETER_START

void SgTemplateParameter::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);
   }

// Different constructors for use in building the different types of parameters possible
SgTemplateParameter::SgTemplateParameter ( SgType* parameter, SgType* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType        = type_parameter;
     p_type                 = parameter;
     p_defaultTypeParameter = defaultParameter;

     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;

     p_initializedName                     = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgExpression* parameter, SgExpression* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType              = nontype_parameter;

  // DQ (11/28/2011): These were not initialized properly.
  // p_expression                 = NULL;
  // p_defaultExpressionParameter = NULL;
     p_expression                 = parameter;
     p_defaultExpressionParameter = defaultParameter;

     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;

     p_initializedName                     = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType                       = template_parameter;
     p_templateDeclaration                 = parameter;
     p_defaultTemplateDeclarationParameter = defaultParameter;

     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;

     p_initializedName                     = NULL;
   }

// DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
bool
SgTemplateParameter::is_matching_type    (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::type_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

bool
SgTemplateParameter::is_matching_nontype (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::nontype_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

bool
SgTemplateParameter::is_matching_template(const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::template_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

// DQ (5/19/2014): This is added to symmetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
bool
SgTemplateParameter::is_matching_template_pack_expansion (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
  // There is not associated value for the SgTemplateParameter enums, so this function should always return SgTemplateParameter::is_matching_kind().
     return is_matching_kind(X,Y);
   }

bool
SgTemplateParameter::is_matching_kind (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == Y.get_parameterType());
   }


SgName
SgTemplateParameter::get_mangled_name (void) const
   {
     ASSERT_not_null(this);

#if 0
  // mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p get_argumentType() = %d unparseToString() = %s \n",this,get_argumentType(),unparseToString().c_str());
     mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p get_argumentType() = %d \n",this,get_argumentType());
     mprintf ("In SgTemplateParameter::get_mangled_name(): unparseToString() = %s \n",unparseToString().c_str());
#endif

     ostringstream mangled_name;
     switch (get_parameterType())
        {
          case SgTemplateParameter::type_parameter:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               mangled_name << type->get_mangled().str();
               break;
             }

          case SgTemplateParameter::nontype_parameter:
             {
               const SgExpression* expr = get_expression();
               if (expr != NULL)
                  {
                    mangled_name << mangleExpression(expr);
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);
                    mangled_name << get_initializedName()->get_name().str();
                  }
               break;
             }

          case SgTemplateParameter::template_parameter:
             {
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
               mangled_name << templateDeclaration->get_mangled_name().str();
               break;
             }

          default:
             {
            // mangled_name << "UNKNOWN";
               mprintf ("ERROR: In SgTemplateParameter::get_mangled_name(): default reached in switch: get_parameterType() = %d \n",get_parameterType());
               ROSE_ASSERT(false);
               break;
             }
        }

#if 0
     mprintf ("In SgTemplateParameter::get_mangled_name(): mangled_name = %s \n",mangled_name.str());
#endif

     string str_mangled_name (mangled_name.str());

  // DQ (9/24/2012): Added test for template syntax in the generated mangled name (convert to std::string so we can simplify the test).
     if ( str_mangled_name.find('<') != string::npos )
        {
          mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p = %s mangled template argument name = %s \n",this,this->class_name().c_str(),str_mangled_name.c_str());
        }
     ROSE_ASSERT(str_mangled_name.find('<') == string::npos);

     return str_mangled_name;
   }


SOURCE_TEMPLATE_PARAMETER_END


SOURCE_TEMPLATE_ARGUMENT_START

void SgTemplateArgument::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;
   }

// Different constructors for use in building the different types of arguments possible
SgTemplateArgument::SgTemplateArgument ( SgType* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = type_argument;
     p_type                = argument;
     p_explicitlySpecified = explicitlySpecified;

     p_expression          = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;
   }

SgTemplateArgument::SgTemplateArgument ( SgExpression* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = nontype_argument;
     p_expression          = argument;
     p_explicitlySpecified = explicitlySpecified;

     p_type                = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;

  // DQ (8/24/2006): Set the parent
     argument->set_parent(this);
   }

// DQ (8/24/2006): This is the more correct version to have.
SgTemplateArgument::SgTemplateArgument ( SgTemplateDeclaration* argument, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType        = template_template_argument;
     p_templateDeclaration = argument;
     p_explicitlySpecified = explicitlySpecified;

  // DQ (11/22/2011): These are no longer set in the post_construction_initialization() function.
     p_expression          = NULL;
     p_type                = NULL;

  // DQ (8/24/2006): Set the parent ???  (make sure it is not already set!)
  // This is likely a shared IR node, so we don't want to set the parent here!
#if PRINT_DEVELOPER_WARNINGS
     mprintf ("Skipping setting of parent on SgTemplateDeclaration in SgTemplateArgument \n");
#endif
   }

// DQ (7/3/2013): Added new type of template argument type to support varadic template arguments.
SgTemplateArgument::SgTemplateArgument ( bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = start_of_pack_expansion_argument;
     p_expression          = NULL;
     p_explicitlySpecified = explicitlySpecified;

     p_type                = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;
   }

#define DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME 0

// RV (2/2/2006): Added mangling of template arguments.
SgName
SgTemplateArgument::get_mangled_name (void) const
   {
     ASSERT_not_null(this);

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
  // mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p get_argumentType() = %d unparseToString() = %s \n",this,get_argumentType(),unparseToString().c_str());
     mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p get_argumentType() = %d \n",this,get_argumentType());
  // mprintf ("In SgTemplateArgument::get_mangled_name(): unparseToString() = %s \n",unparseToString().c_str());
#endif

     ostringstream mangled_name;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): type = %p = %s = %s \n",type,type->class_name().c_str(),type->unparseToString().c_str());
#endif
               SgName mangled_type = type->get_mangled();

               SgNode* parent = this->get_parent();
               ROSE_ASSERT(parent != NULL);

            // DQ (9/21/2012): We need to support defining a mangled name that uses the name of the declaration where the template
            // argument is used.  E.g. In "template <class T> X<T> foo();", the return type "X<T>" shuld have a uniquely mangled
            // name from that of a similar return type in any other function.  The template declaration support will define an
            // instantiation of "X<T>" which must be seperate from all other tempalte functions having a similar return type.
            // This is the say that te restrict sharing of "X<T>" by supporting a mangled name that forces each functions reference
            // to such a type to be different.
               ROSE_ASSERT(this->get_parent() != NULL);

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               ROSE_ASSERT(parent != NULL);
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: this->get_parent() = %p = %s \n",this->get_parent(),this->get_parent()->class_name().c_str());
#endif
               SgTemplateInstantiationDecl* templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(parent);
               if (templateClassInstantiationDeclaration != NULL)
                  {
                 // DQ (12/26/2012): I think that to generate a unique mangled name we need to alwasy reference the same declaration, so set this and enforce that it is a valid pointer.
                    templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(templateClassInstantiationDeclaration->get_firstNondefiningDeclaration());
                    ROSE_ASSERT(templateClassInstantiationDeclaration != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: templateClassInstantiationDeclaration = %p name = %s \n",templateClassInstantiationDeclaration,templateClassInstantiationDeclaration->get_name().str());
#endif
                    mangled_type += Rose::StringUtility::numberToString(templateClassInstantiationDeclaration);

                 // DQ (12/26/2012): This assert fails for copyAST_tests/copytest2007_40.C, but I think it is unreasonable
                 // to expect it to always be true.  So I have made it a warning for now.
                    if (templateClassInstantiationDeclaration != templateClassInstantiationDeclaration->get_firstNondefiningDeclaration())
                       {
                         mprintf ("Warning: In SgTemplateArgument::get_mangled_name(): templateClassInstantiationDeclaration used for mangled name was not the firstNondefiningDeclaration \n");
                       }
                    ROSE_ASSERT(templateClassInstantiationDeclaration == templateClassInstantiationDeclaration->get_firstNondefiningDeclaration());
                  }
                 else
                  {
                 // DQ (8/19/2014): I am not clear how important it is to warn about this issue.
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("WARNING: In SgTemplateArgument::get_mangled_name(): parent declaration is not handled: this->get_parent() = %p = %s \n",parent,parent->class_name().c_str());
#endif
                  }

               mangled_name << mangled_type.str();
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: mangled_type = %s \n",mangled_type.str());
#endif
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();

            // assert(expr != NULL);
            // mangled_name << mangleExpression(expr);
               if (expr != NULL)
                  {
                    mangled_name << mangleExpression(expr);
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);
                    mangled_name << get_initializedName()->get_name().str();
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::nontype_argument: get_initializedName()->get_name() = %s \n",get_initializedName()->get_name().str());
#endif
                  }
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
            // DQ (12/22/2011): The new design has a SgTemplateClassDeclaration derived from a SgClassDeclaration (and
            // the same for SgTemplateFunctionDeclaration, etc.) So we have to change this to support the new design.
            // Now we have to use a common base class which would be the SgDeclarationStatement.
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::template_template_argument: = %p = %s \n",templateDeclaration,templateDeclaration->class_name().c_str());
#endif

               SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("Mangling of template template argument to template type not well tested yet mangled name = %s \n",mangled_templateDeclaration.str());
#endif
               mangled_name << mangled_templateDeclaration.str();
               break;
             }

       // DQ (5/19/2014): Added support for varadic template argument.
          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
               mangled_name << "start_of_pack_expansion_argument";
               break;
             }

          default:
             {
               mprintf ("ERROR: In SgTemplateArgument::get_mangled_name(): default reached in switch: get_argumentType() = %d \n",get_argumentType());
               ROSE_ASSERT(false);
               break;
             }
        }

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
     mprintf ("In SgTemplateArgument::get_mangled_name(): mangled_name = %s \n",mangled_name.str().c_str());
#endif

     string str_mangled_name (mangled_name.str());

  // DQ (9/24/2012): Added test for template syntax in the generated mangled name (convert to std::string so we can simplify the test).
     if ( str_mangled_name.find('<') != string::npos )
        {
          mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p = %s mangled template argument name = %s \n",this,this->class_name().c_str(),str_mangled_name.c_str());
        }
     ROSE_ASSERT(str_mangled_name.find('<') == string::npos);

     return str_mangled_name;
   }

// DQ (6/9/2007): Some template arguments have a concept of scope, this is required to get the name qualification correct.
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
  // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)
     const SgNode* parentNode = this;
     ASSERT_not_null(parentNode);

     while ( (isSgScopeStatement(parentNode) == NULL) && (parentNode->get_parent() != NULL) )
        {
          ASSERT_not_null(parentNode);
          parentNode = parentNode->get_parent();
          ASSERT_not_null(parentNode);
        }

     ASSERT_not_null(parentNode);

  // Check to see if we made it back to the root (current root is SgProject).
  // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).
     if ( isSgScopeStatement(parentNode) == NULL &&
          dynamic_cast<const SgType*>(parentNode) == NULL &&
          dynamic_cast<const SgSymbol*>(parentNode) == NULL )
        {
          mprintf ("Error in SgTemplateArgument::get_scope(): could not trace back to SgScopeStatement node this = %p = %s parentNode = %p = %s \n",this,this->class_name().c_str(),parentNode,parentNode->class_name().c_str());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(parentNode);
          if (templateInstantiation != NULL)
             {
               mprintf ("templateInstantiation->get_name() = %s \n",templateInstantiation->get_name().str());
               templateInstantiation->get_startOfConstruct()->display("Error in SgTemplateArgument::get_scope()");
             }

          if (parentNode->get_parent() == nullptr)
             {
               mprintf ("Error: parent not set for parentNode = %p = %s \n",parentNode,parentNode->class_name().c_str());
             }

          ASSERT_not_null(parentNode->get_parent());

          return nullptr;
        }
       else
        {
          if (dynamic_cast<const SgType*>(parentNode) != nullptr || dynamic_cast<const SgSymbol*>(parentNode) != nullptr)
             {
               mprintf ("Error: can't locate an associated SgStatement from SgTemplateArgument = %p \n",this);
               return nullptr;
             }
        }

  // Make sure we have a SgStatement node
     const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     ASSERT_not_null(scopeStatement);

     return const_cast<SgScopeStatement*>(scopeStatement);
   }

std::string
SgTemplateArgument::template_argument_kind () const
   {
     std::string kindOfTemplateArgument;

     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               ASSERT_not_null(type);
               const SgNamedType* namedType = isSgNamedType(type);
               if (namedType)
                  {
                    ASSERT_not_null(namedType->get_declaration());
                  }
               kindOfTemplateArgument = "type_argument";
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               if (get_expression() == nullptr)
                  {
                    mprintf ("NOTE: In SgTemplateArgument::template_argument_kind(): case SgTemplateArgument::nontype_argument: get_expression() == NULL: what is this? \n");
                    mprintf (" --- get_type()                = %p \n",get_type());
                    mprintf (" --- get_initializedName()     = %p \n",get_initializedName());
                    mprintf (" --- get_templateDeclaration() = %p \n",get_templateDeclaration());
                  }

               kindOfTemplateArgument = "nontype_argument";
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               kindOfTemplateArgument = "template_template_argument";
               break;
             }

          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
               kindOfTemplateArgument = "start_of_pack_expansion_argument";
               break;
             }

          default:
             {
               mprintf ("Error in SgTemplateArgument::template_kind(): default reached! \n");
               assert (false);
               break;
             }
        }

     return kindOfTemplateArgument;
   }

bool
SgTemplateArgument::isTemplateArgumentFromAnonymousClass() const
   {
     bool isAnonymous = false;

#define DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS 0

     bool hasLambdaFollowed = false;

     if (SgClassType * ctype = isSgClassType (this->get_type()))
        {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
          mprintf ("ctype != NULL \n");
#endif
          if (SgNode* pnode = ctype->get_declaration()->get_parent())
             {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
               mprintf ("pnode != NULL \n");
#endif
               if (isSgLambdaExp(pnode))
                  {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
                    mprintf ("Found a SgLambdaExp parent for the class: set hasLambdaFollowed = true  \n");
#endif
                    hasLambdaFollowed = true;
                  }
             }

          SgClassType* classType = ctype;
          if (classType != NULL)
             {
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
               mprintf ("In isAnonymousClass(): case SgTemplateArgument::type_argument: classDeclaration = %p = %s classDeclaration->get_name() = %s \n",
                    classDeclaration,classDeclaration->class_name().c_str(),classDeclaration->get_name().str());
#endif
               bool isUnnamed = (string(classDeclaration->get_name()).substr(0,14) == "__anonymous_0x");
               isAnonymous = isUnnamed;
             }

          if (isAnonymous == true)
             {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS || 0
               mprintf ("isAnonymous == true: set hasLambdaFollowed = true \n");
#endif
            // DQ (1/21/2018): This is mixing logic for explicitlySpecified with something Liao introduced
            // which checks for a trailing lambda function.  So we should fix this up later.
               hasLambdaFollowed = true;
             }
        }

#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
     mprintf ("Leaving SgTemplateArgument::isTemplateArgumentFromAnonymousClass(): isAnonymous = %s hasLambdaFollowed = %s \n",isAnonymous ? "true" : "false",hasLambdaFollowed ? "true" : "false");
#endif

     return (isAnonymous == true) || (hasLambdaFollowed == true);
   }


SgName
SgTemplateArgument::get_qualified_name_prefix() const
   {
  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTemplateArgument*>(this));

#if 0
  // DQ (5/3/2024): Debugging non-terminating name qualification for unit testing.
     printf ("In SgTemplateArgument::get_qualified_name_prefix(): this = %p SgNode::get_globalQualifiedNameMapForTypes().size() = %zu \n",this,SgNode::get_globalQualifiedNameMapForTypes().size());
#endif

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
       // DQ (5/3/2024): Debugging non-terminating name qualification for unit testing.
          printf ("Setting nameQualifier: length: %zu \n",nameQualifier.get_length());
#endif
#if 0
       // DQ (5/3/2024): Debugging non-terminating name qualification for unit testing.
          printf ("In SgTemplateArgument::get_qualified_name_prefix(): this = %p length: %zu SgNode::get_globalQualifiedNameMapForTypes().size() = %zu \n",
               this,nameQualifier.get_length(),SgNode::get_globalQualifiedNameMapForTypes().size());
#endif
        }
       else
        {
#if 0
       // DQ (5/3/2024): Debugging non-terminating name qualification for unit testing.
          printf ("In SgTemplateArgument::get_qualified_name_prefix(): this = %p not found in globalQualifiedNameMapForTypes \n",this);
#endif
        }

#if 0
  // DQ (5/23/2024): This tracks the size of the qualified names.
     static long int max_size = 4000;
     if (nameQualifier.get_length() > max_size)
        {
       // printf ("nameQualifier.get_length() = %zu \n",nameQualifier.get_length());
          max_size = nameQualifier.get_length();
        }
#endif
#if 1
  // DQ (5/3/2024): Debugging non-terminating name qualification for unit testing.
  // printf ("Leaving SgTemplateArgument::get_qualified_name_prefix(): nameQualifier = %s \n",nameQualifier.str());

     if (nameQualifier.get_length() > 10000)
        {
          this->display("Exiting because the type has exceeded a reasonable length");
          printf ("Exiting because the type has exceeded a reasonable length: %u \n",nameQualifier.get_length());
          flush(cout);
          ROSE_ASSERT(false);
        }
#endif

     return nameQualifier;
   }

SgName
SgTemplateArgument::get_qualified_name_prefix_for_type() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTemplateArgument*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
        }
     return nameQualifier;
   }

// DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
bool
SgTemplateArgument::is_matching_type    (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::type_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_nontype (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::nontype_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_template(const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::template_template_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

// DQ (5/19/2014): Added support for matching on this kind of template argument (only applies to SgTemplateArgument and not SgTemplateParemeter).
bool
SgTemplateArgument::is_matching_template_pack_expansion (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::start_of_pack_expansion_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_kind (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == Y.get_argumentType());
   }


// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTemplateArgument::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTemplateArgument::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgTemplateArgument::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTemplateArgument::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgTemplateArgument::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTemplateArgument::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

bool
SgTemplateArgument::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgTemplateArgument::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

int
SgTemplateArgument::get_name_qualification_length_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgTemplateArgument::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

// DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTemplateArgument::get_type_elaboration_required_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgTemplateArgument::set_type_elaboration_required_for_type(bool type_elaboration_required_for_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

// DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTemplateArgument::get_global_qualification_required_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgTemplateArgument::set_global_qualification_required_for_type(bool global_qualification_required_for_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }

void
SgTemplateArgument::display( const std::string & label) const
   {
  // DQ (5/22/2016): Adding display function for debugging.

     ASSERT_not_null(this);

  // DQ (5/12/2024): Added debugging information.
     printf ("In SgTemplateArgument::display(label = %s): get_argumentType() = %s \n",label.c_str(),this->template_argument_kind().c_str()); 

     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
            // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
               printf ("In SgTemplateArgument::display(): type = %p = %s = %s \n",type,type->class_name().c_str(),type->unparseToString().c_str());
               Rose_STL_Container<SgType*> typeChain = type->getInternalTypes();

            // Debugging output.
            // mprintf (" --- Output of type chain for template argument \n");
               printf (" --- Output of type chain for template argument \n");
               for (size_t i = 0; i < typeChain.size(); i++)
                  {
                    SgType* element_type = typeChain[i];

                 // DQ (5/12/2024): Added debugging support.
                    string name;
                    SgNamedType* namedType = isSgNamedType(element_type);
                    if (namedType != NULL)
                       {
                      // printf (" ------ name = %s \n",namedType->get_name().str());
                         name = namedType->get_name().str();
                       }

                    printf ("   --- element_type = %p = %s name = %s \n",element_type,element_type->class_name().c_str(),name.c_str());

                    SgModifierType* modifierType = isSgModifierType(element_type);
                    if (modifierType != NULL)
                       {
                      // modifierType->get_typeModifier().display("X type chain");
                         string s = modifierType->get_typeModifier().displayString();
                         printf ("   ------ type chain modifier: %s \n",s.c_str());
                       }
                  }
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();

            // DQ (12/28/2018): This is a better implementation (it was here, but commented out).
               if (expr != NULL)
                  {
                    printf ("SgTemplateArgument::nontype_argument: expr = %s \n",expr->unparseToString().c_str());
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);

                 // DQ (12/28/2018): original version of code, fixed to output the name.
                    printf ("SgTemplateArgument::nontype_argument: initializedName = %s \n",get_initializedName()->get_name().str());
                  }
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
               printf ("In SgTemplateArgument::display(): case SgTemplateArgument::template_template_argument: = %p = %s \n",templateDeclaration,templateDeclaration->class_name().c_str());
               SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();
               printf ("case SgTemplateArgument::template_template_argument: mangled_templateDeclaration = %s \n",mangled_templateDeclaration.str());
               break;
             }

          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
               assert(get_expression() != NULL);
               printf ("WARNING: In SgTemplateArgument::display(): handling of display for varadic template argument is incomplete! \n");
               printf ("In SgTemplateArgument::display(): case SgTemplateArgument::start_of_pack_expansion_argument: varadic_template_argument \n");

            // DQ (12/28/2018): Add support to handle this case.
               const SgExpression* expr = get_expression();
               printf ("SgTemplateArgument::start_of_pack_expansion_argument: expr = %s \n",expr->unparseToString().c_str());

               break;
             }

          default:
             {
               printf ("ERROR: In SgTemplateArgument::display(): default reached in switch: get_argumentType() = %d \n",get_argumentType());
               ROSE_ASSERT(false);
               break;
             }
        }
   }

std::string
SgTemplateArgument::unparseToStringSupport()
   {
  // DQ (3/10/2018): This is a function mostly used for debugging.
     ASSERT_not_null(this);

     SgUnparse_Info *info = new SgUnparse_Info();
     ROSE_ASSERT(info != NULL);

     info->set_language(SgFile::e_Cxx_language);

  // DQ (4/28/2017): For template arguments we never want to output the definitions of classes, and enums.
     info->set_SkipClassDefinition();
     info->set_SkipEnumDefinition();
     info->set_use_generated_name_for_template_arguments(true);

     std::string returnName = this->unparseToString(info);

     delete info;
     info = NULL;

     return returnName;
   }

SOURCE_TEMPLATE_ARGUMENT_END


SOURCE_TEMPLATE_PARAMETER_LIST_START
SOURCE_TEMPLATE_PARAMETER_LIST_END


SOURCE_TEMPLATE_ARGUMENT_LIST_START
SOURCE_TEMPLATE_ARGUMENT_LIST_END


SOURCE_GRAPHNODE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphNode::p_index_counter = 0;


// tps : todo : remove this soon
void
SgGraphNode::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }


void
SgGraphNode::post_construction_initialization()
   {
  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;
   }

SOURCE_GRAPHNODE_END


SOURCE_GRAPHEDGE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphEdge::p_index_counter = 0;

// tps : todo : remove me
void
SgGraphEdge::append_properties( int addr, const std::string & prop )
   {
  // DQ (4/29/2009): Unclear what this comment (below) means...
  // implemented directly until we can fix how the statementList is built
     p_properties[addr] = prop;
   }

void
SgGraphEdge::post_construction_initialization()
   {
  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;
   }

SOURCE_GRAPHEDGE_END


SOURCE_GRAPH_START

// DQ (4/29/2009): Declaration of space for static data member.
int SgGraph::p_index_counter = 0;

// tps : todo : remove me -----------------------------------------
void
SgGraph::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }

int
SgGraph::hashCode( const char* p, int len) const // hash a character array
   {
     assert(this != NULL);
     unsigned int h = 0;
     for (int i=0; i < len; i++)
        {
          h = (h<<5) | (h>>27);    // 5-bit cyclic shift
          h += (unsigned int)p[i]; // add in next character
        }
     return (int)h;
   }
// -----------------------------------------------------



// DQ (4/28/2009): Added support to have internal list nodes built automatically in the SgGraph constructor.
void
SgGraph::post_construction_initialization()
   {
     assert(this != NULL);

  // Setup an internal graph_id
     p_index = p_index_counter++;
   }


std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphNode* node) {
  string value="";
  map < int , string> node_p = node->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}

std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge) {
  string value="";
  map < int , string> node_p = edge->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}


void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphNode* node,
         std::string value) {
  node->append_properties(property, value);
}

void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge,
         std::string value) {
  edge->append_properties(property, value);
}




void
SgGraph::checkIfGraphNodeExists(const string& trg_mnemonic, std::vector<SgGraphNode*>& nodes) {
  rose_graph_string_integer_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_string_integer_hash_multimap::const_iterator, rose_graph_string_integer_hash_multimap::const_iterator>
    iter = p_string_to_node_index_multimap.equal_range(trg_mnemonic);
  it1 = iter.first;
  it2 = iter.second;
  SgGraphNode* node = NULL;
  for (;it1!=it2; ++it1) {
    int index =  it1->second;
    node = p_node_index_to_node_map.find(index)->second;
    nodes.push_back(node);
  }
}

SOURCE_GRAPH_END


SOURCE_DIRECTED_GRAPH_EDGE_START


SgDirectedGraphEdge::SgDirectedGraphEdge(std::string label, std::string type, int n, SgGraphNode* from, SgGraphNode* to)

   {
    p_name = label;
    p_node_A = from;
    p_node_B=to;
   }

SOURCE_DIRECTED_GRAPH_EDGE_END

SOURCE_INCIDENCE_UNDIRECTED_GRAPH_START
SOURCE_INCIDENCE_UNDIRECTED_GRAPH_END

SOURCE_INCIDENCE_DIRECTED_GRAPH_START

void
SgIncidenceDirectedGraph::post_construction_initialization()
   {
     assert(this != NULL);

   }

bool
SgIncidenceDirectedGraph::checkIfGraphEdgeExists(SgGraphNode* src) {
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  rose_graph_integer_edge_hash_multimap::const_iterator it = edges.find(src->get_index());

  return (it != edges.end());
}

std::set <SgGraphEdge*>
SgIncidenceDirectedGraph::getEdge(SgGraphNode* src) {
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    //    SgGraphNode* source = it1->first;
    SgGraphEdge* edge = isSgGraphEdge(it1->second);
    medges.insert(edge);
  }
  return medges;
}

void
SgIncidenceDirectedGraph::getSuccessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const
{
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  assert(node);
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    assert(edge);
    if (edge) {
      SgGraphNode* target = isSgGraphNode(edge->get_to());
      assert(target);
      if (target) {
         vec.push_back(target);
      }
    } else {
      printf("This is not a DirectedGraphEdge.\n");
      assert(edge);
    }
  }
}

void
SgIncidenceDirectedGraph::getPredecessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const
{
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesIn();
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    //fails
    //    get_edgesIn()->get_edges().equal_range(node);
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    if (edge) {
      SgGraphNode* source = isSgGraphNode(edge->get_from());
      if (source) {
        vec.push_back(source);
      }
    }
  }
}


set<SgDirectedGraphEdge*>
SgIncidenceDirectedGraph::getDirectedEdge(SgGraphNode* src, SgGraphNode* trg) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgDirectedGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);

 // DQ (3/19/2016): Klocworks reports this as an issue, since "edge" could be NULL.  Fix by adding an addertion.
    ROSE_ASSERT(edge != NULL);

    SgGraphNode* target = isSgGraphNode(edge->get_to());
    if (target==trg)
      medges.insert(edge);
  }
  return medges;
}


bool
SgIncidenceDirectedGraph::checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg) {
  if (src==NULL)
    return false;
  if (trg==NULL)
    return false;

  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();

  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);

 // DQ (3/19/2016): Klocworks reports this as an issue, since "edge" could be NULL.  Fix by adding an addertion.
    ROSE_ASSERT(edge != NULL);

    SgGraphNode* target = edge->get_to();
    if (target==trg)
      return true;
  }
  return false;
}


SOURCE_INCIDENCE_DIRECTED_GRAPH_END


SOURCE_NAME_GROUP_START
const SgStringList &
SgNameGroup::get_name_list() const
   {
     return p_name_list;
   }

SgStringList &
SgNameGroup::get_name_list()
   {
     return p_name_list;
   }
SOURCE_NAME_GROUP_END


SOURCE_COMMON_BLOCK_OBJECT_START
SOURCE_COMMON_BLOCK_OBJECT_END


SOURCE_DIMENSION_OBJECT_START
SOURCE_DIMENSION_OBJECT_END


SOURCE_DATA_STATEMENT_GROUP_START

const SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list() const
   {
     return p_object_list;
   }

SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list()
   {
     return p_object_list;
   }

const SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list() const
   {
     return p_value_list;
   }

SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list()
   {
     return p_value_list;
   }

SOURCE_DATA_STATEMENT_GROUP_END

SOURCE_DATA_STATEMENT_OBJECT_START
SOURCE_DATA_STATEMENT_OBJECT_END

SOURCE_DATA_STATEMENT_VALUE_START

void
SgDataStatementValue::post_construction_initialization()
   {
   }

SOURCE_DATA_STATEMENT_VALUE_END


SOURCE_FORMAT_ITEM_START
SOURCE_FORMAT_ITEM_END


SOURCE_FORMAT_ITEM_LIST_START

const SgFormatItemPtrList &
SgFormatItemList::get_format_item_list() const
   {
     return p_format_item_list;
   }

SgFormatItemPtrList &
SgFormatItemList::get_format_item_list()
   {
     return p_format_item_list;
   }

void
SgFormatItemList::set_format_item_list ( const SgFormatItemPtrList & formatItemList )
   {
     p_format_item_list = formatItemList;
   }


SOURCE_FORMAT_ITEM_LIST_END

SOURCE_OPENCL_ACCESS_MODE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isReadOnly() const { return p_modifier == e_read_only; }
void $CLASSNAME::setReadOnly()      { p_modifier = e_read_only; }

bool $CLASSNAME::isWriteOnly() const { return p_modifier == e_write_only; }
void $CLASSNAME::setWriteOnly()      { p_modifier = e_write_only; }

bool $CLASSNAME::isReadWrite() const { return p_modifier == e_read_write; }
void $CLASSNAME::setReadWrite()      { p_modifier = e_read_write; }

std::ostream & operator<< ( std::ostream & os, const $CLASSNAME & m)
   {
      os << m.get_modifier();
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isReadOnly() = ")  + std::string(isReadOnly()  ? "true " : "false ");
     s += std::string("isWriteOnly() = ") + std::string(isWriteOnly() ? "true " : "false ");
     s += std::string("isReadWrite() = ") + std::string(isReadWrite() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
  // DQ (6/25/2020): If we call display, then we mean for it to be displayed, not hidden.
     printf ("In $CLASSNAME::display(%s) \n",label.c_str());
     printf ("%s \n",displayString().c_str());
   }


SOURCE_OPENCL_ACCESS_MODE_MODIFIER_END


SOURCE_TYPE_TABLE_START

/* \brief Hash table of types (table is stored on global scope).

   Hash table of types (table is stored on global scope and includes types
   from all scopes). Types are placed into and retrieved from this data
   base (simple hash table) of SgTypes.
 */
SgTypeTable::SgTypeTable ()
   {
  // DQ (2/19/2007): Use a much larger size symbol table for the function types (the input value is the hash table size, which should be a prime number)!
     p_type_table = new SgSymbolTable(1001);
     ROSE_ASSERT(p_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_type_table->set_parent(this);
   }

void
SgTypeTable::print_typetable(std::ostream& os)
   {
  // mprintf ("ERROR: Sage $CLASSNAME::print_functypetable function called! \n");
  // abort();

     os << endl << "...TypeTbl..." << endl;
  // p_type_table.print(os);

     ROSE_ASSERT(p_type_table != NULL);
  // p_type_table->print(os);
     p_type_table->print("Called from $CLASSNAME::print_typetable");
   }

void
SgTypeTable::insert_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_type_table != NULL);
     ROSE_ASSERT (t != NULL);

  // DQ (7/22/2010): We might want to reuse the SgFunctionTypeSymbol or change the name of it to SgTypeSymbol
     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);

  // DQ (7/26/2010): Set the parent of the type to it symbol.
  // This is a new idea and will allow the parent pointer to be valid for all types and also
  // point to something meaningful.  This is another benefit of using the type table idea.
     t->set_parent(newSymbol);

     p_type_table->insert(n, newSymbol);
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgTypeTable::remove_type(const SgName& n)
   {
     ROSE_ASSERT (p_type_table != NULL);
     p_type_table->remove_function_type(n);
   }

SgType*
SgTypeTable::lookup_type(const SgName& n)
   {
     ROSE_ASSERT (p_type_table != NULL);

     SgSymbol *symbol = p_type_table->find_function_type(n);
     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);

     SgType* returnType = NULL;
     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
        }
     return returnType;
   }

SOURCE_TYPE_TABLE_END
