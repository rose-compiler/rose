// Support functions for definition of C++ grammar (SAGE 3)

HEADER_START
  // This is part of the SgSupport class definition

  // DQ (4/13/2004): Make the copy constructor parameter a const ref instead of just ref parameter
  // previously was protected so it couldn't be used (too easily).
     private:
          $CLASSNAME(const $CLASSNAME &); /* private so it can't be used. */
          $CLASSNAME & operator= ( const $CLASSNAME & X );

        private:
                friend class boost::serialization::access;
                template<class S>
                void serialize(S &s, const unsigned /*version*/) {
                        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgNode);
                        // No data members are serialized at this time, but this serialization function needs to be
                        // defined because SgSupport is an indirect base class of SgBinaryComposite, which is
                        // serializable.
                }
HEADER_END


// ****************************************************
// ************ Support for Graph IR nodes ************ 
// ****************************************************
HEADER_GRAPH_PREDECLARATION_START

#if 0
// Required for Boost Spanning Tree support.
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/kruskal_min_spanning_tree.hpp>
#endif
/*!
    Doxygen documentation for graph class (should maybe be put with the rest of the
doxygen documentation in docs/testDoxygen directory instead).


*/
HEADER_GRAPH_PREDECLARATION_END

HEADER_OMP_CLAUSE_START
	/*!\brief  OpenMP default clause values
       */

       // Liao (5/30/2009): Added support for reduction clauses within an OpenMP directive
	enum omp_default_option_enum{
	  e_omp_default_unknown =0,
	  //4 values for default clause
	  //C/C++ default values
	  e_omp_default_none,
	  e_omp_default_shared,
	  //Fortran default values
	  e_omp_default_private,
	  e_omp_default_firstprivate,
	  e_omp_default_last
	};

        enum omp_schedule_kind_enum{
          e_omp_schedule_unknown = 0,
          e_omp_schedule_static,
          e_omp_schedule_dynamic,
          e_omp_schedule_guided,
          e_omp_schedule_auto,
          e_omp_schedule_runtime,
          e_omp_schedule_last
        };

        enum omp_reduction_operator_enum
        {
            e_omp_reduction_unknown,
            // reduction operations
            //8 operand for C/C++
             //  shared 3 common operators for both C and Fortran
            e_omp_reduction_plus, //+
            e_omp_reduction_mul,  //*
            e_omp_reduction_minus, // -
        
            e_omp_reduction_bitand, // &
            e_omp_reduction_bitor,  // |
            e_omp_reduction_bitxor,  // ^
            e_omp_reduction_logand,  // &&
            e_omp_reduction_logor,   // ||
        
            e_omp_reduction_and, // .and.
            e_omp_reduction_or, // .or.
            e_omp_reduction_eqv,   // fortran .eqv.
            e_omp_reduction_neqv,   // fortran .neqv.
            e_omp_reduction_max,
            e_omp_reduction_min,
            e_omp_reduction_iand,
            e_omp_reduction_ior,
            e_omp_reduction_ieor,
            e_omp_reduction_last
        };

        enum omp_dependence_type_enum
        {
            e_omp_depend_unknown,
            e_omp_depend_in,
            e_omp_depend_out,
            e_omp_depend_inout,
            e_omp_depend_last
        };
       
        // Liao 1/22/2012: experimental support for OpenMP Accelerator model 
        enum omp_map_operator_enum
        {
          e_omp_map_unknown,
          e_omp_map_alloc,
          e_omp_map_to,
          e_omp_map_from,
          e_omp_map_tofrom,
          e_omp_map_last
        };

        // Liao, 11/11/2015: experimental support for data distribution policies
        enum omp_map_dist_data_enum
        {
          e_omp_map_dist_data_unknown,
          e_omp_map_dist_data_duplicate,
          e_omp_map_dist_data_block,
          e_omp_map_dist_data_cyclic,
          e_omp_map_dist_data_last
        };

        // Support thread affinity clause  proc_bind(master|close|spread)
        enum omp_proc_bind_policy_enum
        {
          e_omp_proc_bind_policy_unknown,
          e_omp_proc_bind_policy_master,
          e_omp_proc_bind_policy_close,
          e_omp_proc_bind_policy_spread,
          e_omp_proc_bind_policy_last
        };

        enum omp_atomic_clause_enum
        {
          e_omp_atomic_clause_unknown,
          e_omp_atomic_clause_read,
          e_omp_atomic_clause_write,
          e_omp_atomic_clause_update,
          e_omp_atomic_clause_capture
        };



HEADER_OMP_CLAUSE_END
HEADER_GRAPH_START

      /*! \brief Edge Type 

          Values used to indicate types of edges used for program analysis.
       */
          enum GraphEdgeType
             {
            // DQ (4/29/2009): Added an error value 
               e_type_error, /*!< error value */  
               none,         /*!< none ??? */
               cfg,          /*!< edge used for Control Flow Graph */
               usage,        /*!< usage??? */
               e_last_type   /*!< last value (unused, serves as upper bound on values) */
             };

      /*! \brief Graph Properties

          Values used to indicate types of graphs used for program analysis.
       */
          enum GraphProperties
             {
            // DQ (4/29/2009): Added an error value 
               e_property_error,    /*!< error value */  
               name,                /*!< name of the node */  
               type,                /*!< name of the node */
               nodest_jmp,          /*!< this a jump without dest */
               itself_call,         /*!< this call calls itself */
               nodest_call,         /*!< call without dest */
               interrupt,           /*!< interrupt (int) */
               eval,                /*!< dfa : evaluation */
               regs,                /*!< dfa : registers */
               done,                /*!< dfa : indicates that this node has successfully been visited */
               dfa_standard,        /*!< dfa_standard_node color */  // dfa_standard_node color
               dfa_resolved_func,   /*!< a function that has been resolved by dfa */
               dfa_unresolved_func, /*!< a function that cant be resolved by dfa */
               dfa_variable,        /*!< defines the variable found by dfa */
               dfa_conditional_def, /*!< specifies the nodes that are defines but also conditional instructions */
               edgeLabel,           /*!< ??? */  
               visitedCounter,      /*!< counts the amount of a node being visited during dfa */
               variable,            /*!< stores the string of the variable */
               dfa_bufferoverflow,  /*!< indicates buffer overflow */
               e_last_property      /*!< last value (unused, serves as upper bound on values) */
             };



#if 0

  // DQ (4/29/2009): Boost graph Type
 //! Boost Graph Type used to represent ROSE graphs within Boost Graph Algorithms.
     typedef boost::adjacency_list < boost::vecS, boost::vecS, boost::undirectedS, boost::no_property, boost::property < boost::edge_weight_t, int > > BoostGraphType;

 //! Supporting graph types required by Boost Graph Library.
     typedef boost::graph_traits < BoostGraphType >::edge_descriptor   BoostEdgeDescriptor;

  // DQ (4/29/2009): We might need this in the future, but not now!
  // typedef boost::graph_traits < BoostGraphType >::vertex_descriptor BoostVertexDescriptor;

#endif


 //! Simple edge type used to input data to Boost algorithms
     typedef std::pair<int, int> BoostEdgeType;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
  // We need this local type so that the member access functions for data members of this type can be resolved.
  // typedef std::vector<SgGraph::BoostEdgeType> SgBoostEdgeList;
     typedef std::vector<BoostEdgeType> SgBoostEdgeList;
  // typedef SgBoostEdgeList* SgBoostEdgeListPtr;

  // DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
     typedef std::vector<int> SgBoostEdgeWeightList;
  // typedef SgBoostEdgeWeightList* SgBoostEdgeWeightListPtr;

     int hashCode( const char* p, int len) const; // hash a character array
  // void initialize_graph_id();
     void append_properties( int addr, const std::string & prop );

 //! Support for adding SgGraphNode to SgGraph.
     SgGraphNode* addNode( const std::string & name = "", SgNode* sg_node = NULL);

 //! Add support for externally build SgGraphNode objects
     SgGraphNode* addNode( SgGraphNode* node );

 //! Support for adding SgGraphEdge to SgGraph.
     SgGraphEdge* addEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgGraphEdge* addEdge( SgGraphEdge* edge );

     void post_construction_initialization() $ROSE_OVERRIDE;

 //! Support for Boost Minimum Spanning Tree.
  // std::vector <BoostEdgeDescriptor> generateSpanningTree();
     std::vector <SgGraphEdge*> generateSpanningTree();

     // tps (4/30/2009): Added properties for nodes and edges
     // todo: this will be replaced with AstAttributes once the graph conversion is done.
   	  std::string getProperty(SgGraph::GraphProperties property, SgGraphNode* node);
	  std::string getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge);
	  void setProperty(SgGraph::GraphProperties property, SgGraphNode* node, std::string value);
	  void setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge, std::string value);

 	// tps (4/30/2009): The following are functions on the graph that were used before 
 	// in the old graph implementation
  	//std::set<SgGraphEdge*> getEdge(SgGraphNode* src, SgGraphNode* trg);
        void checkIfGraphNodeExists(const std::string& trg_mnemonic, std::vector<SgGraphNode*>& nodes);
//SgGraphNode* checkIfGraphNodeExists(std::string& trg_mnemonic);
        


 //! Check if the node is present in the graph.
     bool exists( SgGraphNode* node );

 //! Check if the edge is present in the graph.
     bool exists( SgGraphEdge* edge );


 //! Builds a set of edges that are associated with a specific node.
     std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );

  //! Integer index version of "std::set<SgGraphEdge*> computeEdgeSet( SgGraphNode* node );"
     std::set<int> computeEdgeSet( int node_index );

 //! Build set of node index pairs associated with node index (one of the value of the pair will be equal to the input node_index).
     std::set< std::pair<int,int> > computeNodeIndexPairSet( int node_index );

 //! Builds a set of node index values associated with a label.
     std::set<SgGraphNode*> computeNodeSet( const std::string & label );

 //! Builds a set of all nodes in the graph.
     std::set<SgGraphNode*> computeNodeSet();

  //! Integer index version of "std::set<SgGraphNode*> computeNodeSet( const std::string & label );"
     std::set<int> computeNodeIndexSet( const std::string & label );

  // Number of nodes in graph.
     size_t numberOfGraphNodes() const;

  // Number of edges in graph.
     size_t numberOfGraphEdges() const;

     void display_node_index_to_edge_multimap() const;
     void display_node_index_to_node_map() const;
     void display_edge_index_to_edge_map() const;
     void display_node_index_pair_to_edge_multimap() const;
     void display_string_to_node_index_multimap() const;
     void display_string_to_edge_index_multimap() const;

#ifdef ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY
     void display_nodes() const;
     void display_edges() const;
#endif

//! Resize the internal hash tables based on the number of nodes (hash_maps and hash_multimaps for edges are made larger by multiplying by the value "numberOfEdges" ).
     void resize_hash_maps( size_t numberOfNodes, size_t numberOfEdges = 10 );

  //! Report the size in bytes of the graph (includes all edges and ndes from all hash_maps and hash_multimaps).
     size_t memory_usage();

HEADER_GRAPH_END


HEADER_GRAPH_POSTDECLARATION_START


// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
// We need this global type so that the member access functions (defined outside the class)
// for data members of this type can be resolved.
typedef SgGraph::SgBoostEdgeList SgBoostEdgeList;
typedef SgBoostEdgeList* SgBoostEdgeListPtr;

// DQ (4/29/2009): Added support for boost edges to be used in boost graph library algorithms.
typedef SgGraph::SgBoostEdgeWeightList SgBoostEdgeWeightList;
typedef SgBoostEdgeWeightList* SgBoostEdgeWeightListPtr;


// Supporting graph type required by Boost Graph Library.
// typedef boost::graph_traits < SgGraph::BoostGraphType >::edge_descriptor BoostEdgeDescriptor;


HEADER_GRAPH_POSTDECLARATION_END


HEADER_GRAPHNODE_START
     void append_properties( int addr, const std::string & prop );	

     void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_GRAPHNODE_END


HEADER_GRAPHEDGE_START
     void append_properties( int addr, const std::string & prop );

     void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_GRAPHEDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraphEdge(std::string name, std::string type, int n, SgGraphNode* from, SgGraphNode* to);

          SgGraphNode* get_from() { return p_node_A; }
          SgGraphNode* get_to()   { return p_node_B; }
HEADER_DIRECTED_GRAPH_EDGE_END

#if 0
HEADER_DIRECTED_GRAPH_NODE_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraphNode(std::string name, std::string type, int n);

       // DQ (4/23/2009): Added to debug use of new Graph node interfaces.
          SgDirectedGraphNode(std::string);
          SgDirectedGraphNode();
HEADER_DIRECTED_GRAPH_NODE_END


HEADER_DIRECTED_GRAPH_START
     public:
       // DQ (8/18/2008): This is part of the OLD interface introduced for backward compatability!
          SgDirectedGraph(std::string, std::string);
HEADER_DIRECTED_GRAPH_END
#endif

HEADER_GRAPH_NODE_START
HEADER_GRAPH_NODE_END


HEADER_GRAPH_NODE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<std::string,SgGraphNode*, rose_hash::hash_string, rose_hash::eqstr_string> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_NODE_LIST_END


HEADER_GRAPH_EDGE_LIST_START
     public:
          typedef rose_hash::unordered_multimap<SgGraphNode*,SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node> local_hash_multimap_type;
          typedef local_hash_multimap_type::iterator iterator;
HEADER_GRAPH_EDGE_LIST_END


HEADER_UNDIRECTED_GRAPH_EDGE_START
          SgGraphNode* get_node1() { return p_node_A; }
          SgGraphNode* get_node2() { return p_node_B; }
HEADER_UNDIRECTED_GRAPH_EDGE_END


HEADER_DIRECTED_GRAPH_EDGE_START
HEADER_DIRECTED_GRAPH_EDGE_END


HEADER_INCIDENCE_UNDIRECTED_GRAPH_START
HEADER_INCIDENCE_UNDIRECTED_GRAPH_END


HEADER_INCIDENCE_DIRECTED_GRAPH_START
  // tps (4/30/2009): The following are functions on the graph that were used before 
  // in the old graph implementation
  	  std::set<SgGraphEdge*> getEdge(SgGraphNode* src);
  	  bool checkIfGraphEdgeExists(SgGraphNode* src);

     void post_construction_initialization() $ROSE_OVERRIDE;

 //! Support for adding SgGraphEdge to SgGraph.
     SgDirectedGraphEdge* addDirectedEdge( SgGraphNode* a, SgGraphNode* b, const std::string & name = "");

 //! Add support for externally build SgGraphNode objects
     SgDirectedGraphEdge* addDirectedEdge( SgDirectedGraphEdge* edge  );

 //! Remove an edge from graph
     bool removeDirectedEdge( SgDirectedGraphEdge* edge  );
     
	// tps (4/30/2009): Added to support functionality for DirectedGraphs		   
     void getSuccessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const;
     void getPredecessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const;
     std::set<SgDirectedGraphEdge*> getDirectedEdge(SgGraphNode* src, SgGraphNode* trg);
     bool checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg);

  // DQ (8/18/2009): Added support for construction of sets of edges.
     std::set<SgDirectedGraphEdge*> computeEdgeSetIn( SgGraphNode* node );
     std::set<int> computeEdgeSetIn( int node_index );
     std::set<SgDirectedGraphEdge*> computeEdgeSetOut( SgGraphNode* node );
     std::set<int> computeEdgeSetOut( int node_index );

HEADER_INCIDENCE_DIRECTED_GRAPH_END


HEADER_BIDIRECTIONAL_GRAPH_START
HEADER_BIDIRECTIONAL_GRAPH_END


HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_STRING_KEYED_BIDIRECTIONAL_GRAPH_END


HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_START
HEADER_INTEGER_KEYED_BIDIRECTIONAL_GRAPH_END



// *********************************************************
// ************ Support for Type Modifier nodes ************
// *********************************************************
HEADER_MODIFIER_START
          SgModifier ( const SgModifier & X );
          SgModifier & operator= ( const SgModifier & X );

       // bit handling support used by many derived classes
          bool checkBit ( unsigned int bit, const SgBitVector & bitVector ) const;
          void setBit   ( unsigned int bit,       SgBitVector & bitVector ) const;
          void unsetBit ( unsigned int bit,       SgBitVector & bitVector ) const;

HEADER_MODIFIER_END


HEADER_MODIFIER_NODES_START
          SgModifierNodes();
      // ~SgModifierNodes();

          void post_construction_initialization() $ROSE_OVERRIDE;

       // DQ (2/12/2007): This function is not used.
       // SgModifierType* match(SgType*, unsigned int);

       // DQ (2/4/2006): Added mechamism to clear all bits
       // void reset();

HEADER_MODIFIER_NODES_END

HEADER_CV_TYPE_MODIFIER_START

       // const_volatile specifiers (const, volatile)

      /*! \brief Const Volatile Modifier 

          Must be either const, volatile, or neither.

          \internal Bit values can support multiple values in a single enum type
       */
          enum cv_modifier_enum
             {
               e_unknown,        /*!< Unknown value (error value) */
               e_default,        /*!< Default value (default) */
               e_const,          /*!< Const qualifier */
               e_volatile,       /*!< Volatile qualifier */
               e_const_volatile, /*!< Const and Volatile qualifier */

            // DQ (8/11/2011): Added support for Java "transient" modifier.
               e_java_transient, /*!< Java transient qualifier (specifies no serialization of declaration) */

               e_last_modifier /*!< last value (unused, serves as upper bound on values) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

       // DQ (3/21/2005): the default setting is non-const and non-volatile
          bool isDefault() const;
          void setDefault();

          bool isConst() const;
          void setConst();

       // DQ (3/21/2005): We could have a design with no unset function since the cv data is not a bit vector
       // the design reflects that a CV modifier is either const or volatile or neither.
       // Thus unsetting const would be to set the default value.
          void unsetConst();

          bool isVolatile() const;
          void setVolatile();
       // DQ (3/21/2005): See comment for unsetConst() above
          void unsetVolatile();

       // DQ (8/11/2011): Java support.
          bool isJavaTransient() const;
          void setJavaTransient();
          void unsetJavaTransient();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgConstVolatileModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_CV_TYPE_MODIFIER_END

HEADER_STORAGE_MODIFIER_START

       // storage specifiers (auto, static, register, extern, mutable)

       // C++ grammar defines storage modifier to be only: auto, static, register, extern, mutable

       // DQ (4/6/2004): Added to provide uniform support for storage modifiers
      /*! \brief Storage Modifiers (only one value can be specified)

          Storage modifiers are used to specify location or properties of declarations.
          For example, static variables in functions are stored in global scope, register 
          variables are a hint to store the value in a CPU register (mosty ignored by 
          modern compilers).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum storage_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_extern        = 2,  /*!< extern storage modifier */
               e_static        = 3,  /*!< static storage modifier */
               e_auto          = 4,  /*!< auto storage value */
               e_unspecified   = 5,  /*!< previous (old) default value, not included in C++ grammar definition of storage modifier */
               e_register      = 6,  /*!< register storage modifier */
               e_mutable       = 7,  /*!< mutable storage modifier */
               e_typedef       = 8,  /*!< not used, not included in C++ grammar definition of storage modifier */
               e_asm           = 9,  /*!< not used, not included in C++ grammar definition of storage modifier */
#ifdef FORTRAN_SUPPORTED
            // included for later FORTRAN support
               e_local         = 10, /*!< Auto or static at back end's preference */
               e_common        = 11, /*!< A COMMON block */
               e_associated    = 12, /*!< Variable is part of an association */
               e_intrinsic     = 13, /*!< Intrinsic function or subroutine */
               e_pointer_based = 14, /*!< Pointee of a POINTER definition */
#endif

            // Rasmussen (02/04/2018): Fortran contiguous array storage attribute
               e_contiguous    = 15, /*!< Contiguous array memory-storage attribute */

            // TV (04/08/2010): Support for CUDA storage modifiers
               e_cuda_global         = 16, /*!< CUDA, in device's global memory */
               e_cuda_constant       = 17, /*!< CUDA, in device's constant memory */
               e_cuda_shared         = 18, /*!< CUDA, in device's shared memory */
               e_cuda_dynamic_shared = 19, /*!< CUDA, in device's shared memory, dynamically allocated */

           // Rasmussen (03/13/2018): New CUDA storage modifiers
               e_cuda_device_memory  = 20, /*!< CUDA, in device's global memory */
               e_cuda_managed        = 21, /*!< CUDA, memory managed between host and device */
               e_cuda_pinned         = 22, /*!< CUDA, in device's texture memory (read only)  */
               e_cuda_texture        = 23, /*!< CUDA, in host's page-locked memory */

               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isExtern() const;
          void setExtern();

          bool isStatic() const;
          void setStatic();

          bool isAuto() const;
          void setAuto();

          bool isUnspecified() const;
          void setUnspecified();

          bool isRegister() const;
          void setRegister();

          bool isMutable() const;
          void setMutable();

       // This is not used (but is present in the EDG AST)
          bool isTypedef() const;
          void setTypedef();

       // This is not used (but is present in the EDG AST)
          bool isAsm() const;
          void setAsm();

#if 0
       // DQ (11/18/2007): We store this information differently now!
#ifdef FORTRAN_SUPPORTED
       // These remaining access functions are specific to FORTRAN
          bool isLocal() const;
          void setLocal();

          bool isCommon() const;
          void setCommon();

          bool isAssociated() const;
          void setAssociated();

          bool isIntrinsic() const;
          void setIntrinsic();

          bool isPointerBased() const;
          void setPointerBased();
#endif
#endif

       // Rasmussen (02/06/2018): Fortran contiguous array storage attribute
          bool isContiguous() const;
          void setContiguous();

       // TV (04/08/2010): Support for CUDA storage modifiers

          bool isCudaGlobal() const;
          void setCudaGlobal();

          bool isCudaConstant() const;
          void setCudaConstant();

          bool isCudaShared() const;
          void setCudaShared();

          bool isCudaDynamicShared() const;
          void setCudaDynamicShared();

       // Rasmussen (03/13/2018): New CUDA storage modifiers

          bool isCudaDeviceMemory() const;
          void setCudaDeviceMemory();

          bool isCudaManaged() const;
          void setCudaManaged();

          bool isCudaPinned() const;
          void setCudaPinned();

          bool isCudaTexture() const;
          void setCudaTexture();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_STORAGE_MODIFIER_END

HEADER_ACCESS_MODIFIER_START

       // access specifiers (private, protected, public)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Access Modifiers (only one value can be specified)

          \internal Only one value can be specified (at least in C and C++)

          \note Added an undefined value for Fortran 90 support.
       */
          enum access_modifier_enum
             {
               e_unknown   = 0,        /*!< error value */
               e_private   = 1,        /*!< private access (local to class members) */
               e_protected = 2,        /*!< protected access (local to class members and membrs of derived classes) */
               e_public    = 3,        /*!< public access (access within enclosing namespace) */
               e_default   = e_public, /*!< default value (public access) */  /*NO_STRINGIFY*/
               e_undefined = 4,        /*!< fortran default value */
               e_last_modifier         /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgAccessModifier ( const SgAccessModifier & X );

       // Assignment Operator
          SgAccessModifier & operator= ( const SgAccessModifier & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isPrivate() const;
          void setPrivate();

          bool isProtected() const;
          void setProtected();

          bool isPublic() const;
          void setPublic();

       // DQ (11/24/2007): Added support for Fortran staements to have undefined access (default in modules should not be public (or private))
          bool isUndefined() const;
          void setUndefined();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgAccessModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ACCESS_MODIFIER_END

HEADER_FUNCTION_MODIFIER_START

      /*! \brief Function Modifiers (bitvector implementation permits multiple values to be specified)

          Function modifiers (inline, virtual, pure-virtual, explicit).

          \internal Many values can be specified (when the gnu attributes are included), so the implementation uses an STL bit vector.
       */
          enum function_modifier_enum
             {
            // Multiple values can be specified at one time
            // (e.g. inline and explicit (works in g++!))
               e_unknown            = 0, /*!< error value */
               e_default            = 1, /*!< default value */
               e_inline             = 2, /*!< inlined function */
               e_virtual            = 3, /*!< virtual function */
               e_pure_virtual       = 4, /*!< pure virtual function */
               e_explicit           = 5, /*!< explicit function (avoids type resolution through auto type promotion of function arguments) */
            // e_bind               = 6, /*!< Fortran bind attribute for functions (see also type modifier) */
               e_pure               = 7, /*!< Fortran pure attribute for functions (see also type modifier) */
               e_elemental          = 8, /*!< Fortran elemental attribute for functions (see also type modifier) */
               e_recursive          = 9, /*!< Fortran recursive attribute for functions (see also type modifier) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__constructor__            = 10,/*!< GNU specific attribute for (GNU extension) (a separately stored value permits the priority to be specified). */
               e_gnu_attribute__destructor__             = 11,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__pure__                   = 12,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weak__                   = 13,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 14,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 15,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 16,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__malloc__                 = 17,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__naked__                  = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_instrument_function__ = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__no_check_memory_usage__  = 20,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noinline__               = 21,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__always_inline__          = 22,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nothrow__                = 23,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 24,/*!< GNU specific attribute for (GNU extension) */

            // TV (04/08/2010): Support for CUDA functions modifiers
               e_cuda_device                 = 25, /*!< CUDA device function called from device */
               e_cuda_kernel                 = 26, /*!< CUDA kernel */
               e_cuda_host                   = 27, /*!< CUDA host function */
               
            // Rasmussen (03/13/2018): New CUDA function modifiers
               e_cuda_global_function        = 28, /*!< CUDA device function called from host */
               e_cuda_grid_global            = 29, /*!< CUDA device function called from host */

            // TV (05/03/2010): Support for OpenCL functions modifiers             
               e_opencl_kernel               = 30, /*!< OpenCL kernel */
               e_opencl_vec_type_hint        = 31, /*!< OpenCL */
               e_opencl_work_group_size_hint = 32, /*!< OpenCL */
               e_opencl_work_group_size_req  = 33, /*!< OpenCL */

            // DQ (8/11/2011): Added support for Java specific function modifiers.
               e_java_native                 = 34, /*!< Java native keyword used for JNI function specification */
               e_java_synchronized           = 35, /*!< Java synchronized keyword used to only allow one thread at a time into a particular section of code */
               e_java_strictfp               = 36, /*!< Java strictfp keyword used to specify strict floating point evaluation by JVM */
               e_java_initializer            = 37, /*!< Java initializer keyword used to specify that this "synthetic" function is, in fact, an initializer block */

            // DQ (4/13/2019): Added C++11 options for function modifiers.
               e_marked_default            = 38, /*!< marked using "= default" syntax (different from default enum value) */
               e_marked_delete             = 39, /*!< marked using "= delete" syntax */

            // Rasmussen (10/26/2019): Jovial function modifier
               e_reentrant                 = 40, /*!< re-entrant function */

               e_last_modifier     /*!< last value (upper bound on range of values, used in error checking) */
             };
             
          // TV (05/03/2010)

             struct opencl_work_group_size_t {
             	unsigned long int x, y, z;
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isInline() const;
          void setInline();
          void unsetInline();

          bool isVirtual() const;
          void setVirtual();
          void unsetVirtual();

          bool isPureVirtual() const;
          void setPureVirtual();
          void unsetPureVirtual();

          bool isExplicit() const;
          void setExplicit();
          void unsetExplicit();
#if 0
       // DQ (11/21/2007): support for Fortran bind attribute on functions
          bool isBind() const;
          void setBind();
          void unsetBind();
#endif
       // DQ (11/21/2007): support for Fortran pure attribute on functions
          bool isPure() const;
          void setPure();
          void unsetPure();

       // DQ (11/30/2007): support for Fortran elemental attribute on functions
          bool isElemental() const;
          void setElemental();
          void unsetElemental();

       // DQ (11/30/2007): support for Fortran recursive attribute on functions
          bool isRecursive() const;
          void setRecursive();
          void unsetRecursive();

       // Rasmussen (10/26/2019): support for Jovial reentrant attribute on functions
          bool isReentrant() const;
          void setReentrant();
          void unsetReentrant();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeConstructor() const;
          void setGnuAttributeConstructor();
          void unsetGnuAttributeConstructor();

          bool isGnuAttributeDestructor() const;
          void setGnuAttributeDestructor();
          void unsetGnuAttributeDestructor();

          bool isGnuAttributePure() const;
          void setGnuAttributePure();
          void unsetGnuAttributePure();

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeMalloc() const;
          void setGnuAttributeMalloc();
          void unsetGnuAttributeMalloc();

          bool isGnuAttributeNaked() const;
          void setGnuAttributeNaked();
          void unsetGnuAttributeNaked();

          bool isGnuAttributeNoInstrumentFunction() const;
          void setGnuAttributeNoInstrumentFunction();
          void unsetGnuAttributeNoInstrumentFunction();

          bool isGnuAttributeNoCheckMemoryUsage() const;
          void setGnuAttributeNoCheckMemoryUsage();
          void unsetGnuAttributeNoCheckMemoryUsage();

          bool isGnuAttributeNoInline() const;
          void setGnuAttributeNoInline();
          void unsetGnuAttributeNoInline();

          bool isGnuAttributeAlwaysInline() const;
          void setGnuAttributeAlwaysInline();
          void unsetGnuAttributeAlwaysInline();

          bool isGnuAttributeNoThrow() const;
          void setGnuAttributeNoThrow();
          void unsetGnuAttributeNoThrow();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

       // TV (04/08/2010): Support for CUDA functions modifiers
       
          bool isCudaDevice() const;
          void setCudaDevice();
          void unsetCudaDevice();

          bool isCudaKernel() const;
          void setCudaKernel();
          void unsetCudaKernel();

          bool isCudaHost() const;
          void setCudaHost();
          void unsetCudaHost();
          
       // Rasmussen (03/13/2018): New CUDA function modifiers

          bool isCudaGlobalFunction() const;
          void setCudaGlobalFunction();
          void unsetCudaGlobalFunction();

          bool isCudaGridGlobal() const;
          void setCudaGridGlobal();
          void unsetCudaGridGlobal();

       // TV (05/03/2010): Support for OpenCL functions modifiers
       
          bool isOpenclKernel() const;
          void setOpenclKernel();
          void unsetOpenclKernel();
          
          bool hasOpenclVecTypeHint() const;
          void setOpenclVecTypeHint();
          void unsetOpenclVecTypeHint();
          
          bool hasOpenclWorkGroupSizeHint() const;
          void setOpenclWorkGroupSizeHint();
          void unsetOpenclWorkGroupSizeHint();
          
          bool hasOpenclWorkGroupSizeReq() const;
          void setOpenclWorkGroupSizeReq();
          void unsetOpenclWorkGroupSizeReq();


       // DQ (8/11/2011): Added support for Java specific function modifiers.
          bool isJavaNative() const;
          void setJavaNative();
          void unsetJavaNative();

          bool isJavaSynchronized() const;
          void setJavaSynchronized();
          void unsetJavaSynchronized();

          bool isJavaStrictfp() const;
          void setJavaStrictfp();
          void unsetJavaStrictfp();

          bool isJavaInitializer() const;
          void setJavaInitializer();
          void unsetJavaInitializer();


       // DQ (4/13/2019): Added C++11 options for function modifiers.
          bool isMarkedDefault() const;
          void setMarkedDefault();
          void unsetMarkedDefault();

       // DQ (4/13/2019): Added C++11 options for function modifiers.
          bool isMarkedDelete() const;
          void setMarkedDelete();
          void unsetMarkedDelete();


          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgFunctionModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_FUNCTION_MODIFIER_END

HEADER_UPC_ACCESS_MODIFIER_START

       // UPC access specifiers (unspecified, shared, strict, relaxed)

      /*! \brief UPC Access Modifiers (only one value can be specified)

          Unified Parallel C modifiers (shared, strict, relaxed).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum upc_access_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown,       /*!< error value */
               e_default,       /*!< default value */
            // DQ and Liao (6/13/2008): "shared" can be used with "strict" and "relaxed" so it must be handled separately.
            // e_upc_shared,    /*!< UPC shared */
               e_upc_strict,    /*!< UPC strict */
               e_upc_relaxed,   /*!< UPC relaxed */
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

       // bool isUPC_Shared() const;
       // void setUPC_Shared();

          bool isUPC_Strict() const;
          void setUPC_Strict();

          bool isUPC_Relaxed() const;
          void setUPC_Relaxed();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgUPC_AccessModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechanism to clear all bits
          void reset();

HEADER_UPC_ACCESS_MODIFIER_END


HEADER_SPECIAL_FUNCTION_MODIFIER_START

       // special_function specifiers (constructor, destructor, conversion, operator)

      /*! \brief Special Function Modifiers (only one value can be specified)

          Modifier information about (constructor, destructor, conversion operator (cast operator), and operator (general overloaded operators)).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum special_function_modifier_enum
             {
               e_unknown            = 0,         /*!< error value */
               e_default            = 1,         /*!< Not a special function (default) */
               e_none               = e_default, /*!< Not a special function (default) */	/*NO_STRINGIFY*/
               e_constructor        = 2,         /*!< A constructor */
               e_destructor         = 3,         /*!< A destructor */
               e_conversion         = 4,         /*!< A conversion operator function */
               e_operator           = 5,         /*!< Any other operator function */
               e_uld_operator       = 6,         /*!< ULD operator function (operators on literals) */
               e_lambda_entry_point = 7,   /*!< C++11 lambda support */
               e_last_modifier            /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isNotSpecial() const;
          void setNotSpecial();
          void unsetNotSpecial();

          bool isConstructor() const;
          void setConstructor();
          void unsetConstructor();

          bool isDestructor() const;
          void setDestructor();
          void unsetDestructor();

          bool isConversion() const;
          void setConversion();
          void unsetConversion();

          bool isOperator() const;
          void setOperator();
          void unsetOperator();

          bool isUldOperator() const;
          void setUldOperator();
          void unsetUldOperator();

          bool isLambdaEntryPoint() const;
          void setLambdaEntryPoint();
          void unsetLambdaEntryPoint();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgSpecialFunctionModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_SPECIAL_FUNCTION_MODIFIER_END

HEADER_DECLARATION_MODIFIER_START
       // Support for: storage specifiers, type specifiers, function specifiers,
       //              friend, typedef, export, throw

      /*! \brief Declaration Modifiers (only one value can be specified)

          Modifier information about (friend, typedef, export, and throw).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum declaration_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown       = 0,  /*!< Unknown value (error) */
               e_default       = 1,  /*!< Default value */
               e_friend        = 2,  /*!< Friend qualifier */
               e_typedef       = 3,  /*!< Typedef qualifier (not clear if this is used, I don't think typedef is a modifier) */
               e_export        = 4,  /*!< Export qualifier */
               e_throw         = 5,  /*!< Exception handling support (throw) */
               e_bind          = 6,  /*!< Fortran bind attribute for declarations (functions, variable, and classes) */
               e_final         = 7,  /*!< PHP, Java, and C++11 support for specification to not be extended */
               e_override      = 8,  /*!< C++11 support for specification to not be extended */

            // DQ (8/11/2011): Added support for Java "abstract" declaration modifier.
               e_java_abstract = 9,  /*!< abstract keyword for Java functions, classes and interfaces */

            // Rasmussen (2/26/2020): Added support for Jovial modifiers
               e_jovial_def = 10,         /*!< Definition specification for Jovial declarations */
               e_jovial_ref = 11,         /*!< Reference specification for Jovial declarations */
               e_jovial_static = 12,      /*!< Explicitly marked as STATIC in Jovial */

               e_ms_declspec_align        = 13, /*!< Microsoft declspec() attributes */
               e_ms_declspec_allocate     = 14, /*!< Microsoft declspec() attributes */
               e_ms_declspec_appdomain    = 15, /*!< Microsoft declspec() attributes */
               e_ms_declspec_code_seg     = 16, /*!< Microsoft declspec() attributes */
               e_ms_declspec_deprecated   = 17, /*!< Microsoft declspec() attributes */
               e_ms_declspec_dllimport    = 18, /*!< Microsoft declspec() attributes */
               e_ms_declspec_dllexport    = 19, /*!< Microsoft declspec() attributes */
               e_ms_declspec_jitintrinsic = 20, /*!< Microsoft declspec() attributes */
               e_ms_declspec_naked        = 21, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noalias      = 22, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noinline     = 23, /*!< Microsoft declspec() attributes */
               e_ms_declspec_noreturn     = 24, /*!< Microsoft declspec() attributes */
               e_ms_declspec_nothrow      = 25, /*!< Microsoft declspec() attributes */
               e_ms_declspec_novtable     = 26, /*!< Microsoft declspec() attributes */
               e_ms_declspec_process      = 27, /*!< Microsoft declspec() attributes */
               e_ms_declspec_property     = 28, /*!< Microsoft declspec() attributes */
               e_ms_declspec_restrict     = 29, /*!< Microsoft declspec() attributes */
               e_ms_declspec_safebuffers  = 30, /*!< Microsoft declspec() attributes */
               e_ms_declspec_selectany    = 31, /*!< Microsoft declspec() attributes */
               e_ms_declspec_thread       = 32, /*!< Microsoft declspec() attributes */
               e_ms_declspec_uuid         = 33, /*!< Microsoft declspec() attributes */

               e_last_modifier       /*!< last modifier value (upper bound on range of values, used in error checking) */
             };

      /*! \brief GNU attribute for visability (only one value can be specified)

          visability values are: default, hidden, protected or internal visibility.

          \internal Only one value can be specified (at least in C and C++)
       */
          enum gnu_declaration_visability_enum
             {
               e_unknown_visibility     = 0,  /*!< Unknown value (error) */
               e_error_visibility       = 1,  /*!< Error value (error) */
               e_unspecified_visibility = 2,  /*!< Unspecified visibility (not the default value) */
               e_hidden_visibility      = 3,  /*!< hidden visibility */
               e_protected_visibility   = 4,  /*!< protected visibility */
               e_internal_visibility    = 5,  /*!< internal visibility (not clear if this is used, I don't think typedef is a modifier) */
               e_default_visibility     = 6,  /*!< default visibility */
               e_last_visibility_attribute /*!< last visibility attribute (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          SgDeclarationModifier ( const SgDeclarationModifier & X );

       // Assignment Operator
          SgDeclarationModifier & operator= ( const SgDeclarationModifier & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          SgTypeModifier    & get_typeModifier();
          SgAccessModifier  & get_accessModifier();
          SgStorageModifier & get_storageModifier();

          const SgTypeModifier    & get_typeModifier() const;
          const SgAccessModifier  & get_accessModifier() const;
          const SgStorageModifier & get_storageModifier() const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isFriend() const;
          void setFriend();
          void unsetFriend();

          bool isTypedef() const;
          void setTypedef();
          void unsetTypedef();

          bool isExport() const;
          void setExport();
          void unsetExport();

          bool isThrow() const;
          void setThrow();
          void unsetThrow();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // PHP, Java, and C++11 specific attribute
          bool isFinal() const;
          void setFinal();
          void unsetFinal();

       // C++11 specific attribute
          bool isOverride() const;
          void setOverride();
          void unsetOverride();

       // DQ (8/11/2011): Added Java specific "abstract" attribute.
          bool isJavaAbstract() const;
          void setJavaAbstract();
          void unsetJavaAbstract();

       // Rasmussen (2/26/2020): Added Jovial Def and Ref specifications plus an explicitly static attribute
          bool isJovialDef() const;
          void setJovialDef();
          void unsetJovialDef();

          bool isJovialRef() const;
          void setJovialRef();
          void unsetJovialRef();

          bool isJovialStatic() const;
          void setJovialStatic();
          void unsetJovialStatic();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_align() const;
          void set_ms_declspec_align();
          void unset_ms_declspec_align();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_allocate() const;
          void set_ms_declspec_allocate();
          void unset_ms_declspec_allocate();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_appdomain() const;
          void set_ms_declspec_appdomain();
          void unset_ms_declspec_appdomain();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_code_seg() const;
          void set_ms_declspec_code_seg();
          void unset_ms_declspec_code_seg();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_deprecated() const;
          void set_ms_declspec_deprecated();
          void unset_ms_declspec_deprecated();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_dllimport() const;
          void set_ms_declspec_dllimport();
          void unset_ms_declspec_dllimport();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_dllexport() const;
          void set_ms_declspec_dllexport();
          void unset_ms_declspec_dllexport();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_jitintrinsic() const;
          void set_ms_declspec_jitintrinsic();
          void unset_ms_declspec_jitintrinsic();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_naked() const;
          void set_ms_declspec_naked();
          void unset_ms_declspec_naked();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noalias() const;
          void set_ms_declspec_noalias();
          void unset_ms_declspec_noalias();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noinline() const;
          void set_ms_declspec_noinline();
          void unset_ms_declspec_noinline();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_noreturn() const;
          void set_ms_declspec_noreturn();
          void unset_ms_declspec_noreturn();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_nothrow() const;
          void set_ms_declspec_nothrow();
          void unset_ms_declspec_nothrow();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_novtable() const;
          void set_ms_declspec_novtable();
          void unset_ms_declspec_novtable();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_process() const;
          void set_ms_declspec_process();
          void unset_ms_declspec_process();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_property() const;
          void set_ms_declspec_property();
          void unset_ms_declspec_property();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_restrict() const;
          void set_ms_declspec_restrict();
          void unset_ms_declspec_restrict();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_safebuffers() const;
          void set_ms_declspec_safebuffers();
          void unset_ms_declspec_safebuffers();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_selectany() const;
          void set_ms_declspec_selectany();
          void unset_ms_declspec_selectany();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_thread() const;
          void set_ms_declspec_thread();
          void unset_ms_declspec_thread();

       // DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
          bool is_ms_declspec_uuid() const;
          void set_ms_declspec_uuid();
          void unset_ms_declspec_uuid();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgDeclarationModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_DECLARATION_MODIFIER_END

HEADER_TYPE_MODIFIER_START

       // type specifier (elaborated-type-specifier, cv-qualifier, restrict)

       // DQ (9/7/2007): Added Fortran specific values to handle Fortran attribute specifiers.
       // DQ (4/6/2004): Added to provide uniform support for type modifiers
      /*! \brief Type Modifiers (multiple values can be specified at one time)

          Type modifier information about used for C/C++ and Fortran 77/90/2003.
          For Fortran values, each rerpesents a Fortran attribute specifier from section 5.1 
          of the Fortran 2003 standard.

          \internal These are used in a SgBitVector so that multiple values may be specified.
       */
          enum type_modifier_enum
             {
               e_unknown        = 0, /*!< Unknown value (error) */
               e_default        = 1, /*!< Unknown value (default) */
               e_restrict       = 2, /*!< Restrict qualifier (for C/C++) */

            // Fortran specific modifiers (in Fortran these are called attribute specifiers)
            // Note that public and private access attributes are mapped to the C/C++ access modifiers in SgDeclarationModifier
            // e_public_access  = 3, /*!< public qualifier (for Fortran 90) */
            // e_private_access = 4, /*!< private qualifier (for Fortran 90) */
               e_allocatable    = 3, /*!< allocatable attribute specifier (for Fortran 90) */
               e_asynchronous   = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
               e_bind           = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
               e_data           = 6, /*!< data attribute specifier (for Fortran 77) */
               e_dimension      = 7, /*!< dimension attribute specifier (for Fortran 77) */
            // This should map to the C/C++ extern modifier in SgStorageModifier
            // e_external       = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
               e_intent_in      = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
               e_intent_out     = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
               e_intent_inout   = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
               e_intrinsic      = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
               e_optional       = 12,/*!< optional attribute specifier (for Fortran 90) */

            // DQ (8/28/2010): Added support for Fortran 90 type attributes (bind already present, and access-spec handled by C/C++ access modifiers in SgDeclarationModifier
               e_extends       = 13,/*!< optional attribute specifier (for Fortran 90) */
               e_abstract      = 14,/*!< optional attribute specifier (for Fortran 90) */

            // This should map to const in the SgConstVolatileModifier
            // e_parameter      = xx,/*!< parameter attribute specifier (for Fortran 77) */

            // This should be mapped to the SgPointerType in C/C++
            // e_pointer        = xx,/*!< pointer attribute specifier (for Fortran 90) */
            // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
            // e_protected      = xx,/*!< protected attribute specifier (for Fortran 2003) */
               e_save           = 15,/*!< save attribute specifier (for Fortran 77) */
               e_target         = 16,/*!< target attribute specifier (for Fortran 90) */
               e_value          = 17,/*!< value attribute specifier (for Fortran 2003) */
            // This should map to volatile in the SgConstVolatileModifier
            // e_volatile       = xx,/*!< volatile attribute specifier (for Fortran 2003) */

            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__unused__             = 18,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__packed__             = 19,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__         = 20,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__  = 21,/*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__noreturn__           = 22,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__const__              = 23,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__cdecl__              = 24,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__stdcall__            = 25,/*!< GNU specific attribute for function type (GNU extension) */

            // DQ (1/3/2009): New GNU attributes not previously supported in ROSE
               e_gnu_attribute__warn_unused_result__ = 26,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__nonnull__            = 27,/*!< GNU specific attribute for function type (GNU extension) */
               e_gnu_attribute__sentinel__           = 28,/*!< GNU specific attribute for function type (GNU extension) */

            // TV (02/27/2012): Address space modifer
               e_address_space__                     = 29,/*!< address space modifier, get_address_space_value() give the associated param */

            // TV (02/27/2012): OpenCL related Modifier
               e_ocl_global__                        = 30,/*!< OpenCL specific address space modifier */
               e_ocl_local__                         = 31,/*!< OpenCL specific address space modifier */
               e_ocl_constant__                      = 32,/*!< OpenCL specific address space modifier */

            // TV (03/03/2012): Address space modifer
               e_vector_type__                       = 33,/*!< GCC vector type attribute and other vector extentions */

            // DQ (1/24/2016): New GNU attributes not previously supported in ROSE (added to support custom device specification on types).
            // This is part of an experiment to support a new feature in CUDA that would allow device specification in the function parameter type.
            // I am not certain that it should not already exist, but we don't have it implemented in ROSE.  EDG appears to drop the "__device__"
            // keyword, so I am trying to capture it as an attribute.
               e_gnu_attribute__device__             = 34,/*!< Using GNU support for general attributes in the contect of parameter type (ROSE extension using GNU attribute extension) */

            // Rasmussen (3/1/2020): numeric type specifiers for Jovial
               e_round                               = 35,/*!< Jovial rounding specifier */
               e_truncate                            = 36,/*!< Jovial truncation specifier */
               e_truncate_towards_zero               = 37,/*!< Jovial truncation towards zero specifier */

            // Last attribute enum (used for internal bounds checking)
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // DQ (12/4/2007): Added support for gnu attributes representing machine modes (for types)
      /*! \brief GNU Extension Machine Mode type modifiers (only a single value can be specified at one time)

          Machine modes type modifier (required for rather exotic levels of source-to-source transformation in Linux.
          See http://gcc.gnu.org/onlinedocs/gccint/Machine-Modes.html#Machine-Modes for lots of details.

          \internal These are used in an enum type (and I expect that this makes the storage over head small since the range is explicit).
       */
          enum gnu_extension_machine_mode_enum
             {
               e_gnu_extension_machine_mode_unknown     = 0, /*!< Unknown value (error) */
               e_gnu_extension_machine_mode_unspecified = 1, /*!< Unknown value (default) */
               e_gnu_extension_machine_mode_BImode      = 2, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QImode      = 3, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HImode      = 4, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PSImode     = 5, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SImode      = 6, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_PDImode     = 7, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DImode      = 8, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TImode      = 9, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_OImode      = 10, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QFmode      = 11, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HFmode      = 12, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQFmode     = 13, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SFmode      = 14, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DFmode      = 15, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XFmode      = 16, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SDmode      = 17, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DDmode      = 18, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TDmode      = 19, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TFmode      = 20, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QQmode      = 21, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HQmode      = 22, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SQmode      = 23, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DQmode      = 24, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TQmode      = 25, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UQQmode     = 26, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHQmode     = 27, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USQmode     = 28, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDQmode     = 29, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTQmode     = 30, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HAmode      = 31, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SAmode      = 32, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DAmode      = 33, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TAmode      = 34, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UHAmode     = 35, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_USAmode     = 36, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UDAmode     = 37, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_UTAmode     = 38, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CCmode      = 39, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_BLKmode     = 40, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_VOIDmode    = 41, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_QCmode      = 42, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_HCmode      = 43, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_SCmode      = 44, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_DCmode      = 45, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_XCmode      = 46, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_TCmode      = 47, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CQImode     = 48, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CHImode     = 49, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CSImode     = 50, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CDImode     = 51, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_CTImode     = 52, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_gnu_extension_machine_mode_COImode     = 53, /*!< GNU specific attribute for fmachine mode (GNU extension) */
               e_last_machine_mode /*!< last machine mode value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

       // Convert a single type_modifier_enum to an initializer
       // SgTypeModifier ( const SgTypeModifier::type_modifier_enum & m );

          void post_construction_initialization() $ROSE_OVERRIDE;

          SgUPC_AccessModifier     & get_upcModifier();
          SgConstVolatileModifier  & get_constVolatileModifier();
          SgElaboratedTypeModifier & get_elaboratedTypeModifier();

       // RV (2/2/2006): Added 'const' versions of above member functions.
          const SgUPC_AccessModifier     & get_upcModifier(void) const;
          const SgConstVolatileModifier  & get_constVolatileModifier(void) const;
          const SgElaboratedTypeModifier & get_elaboratedTypeModifier(void) const;

          bool isUnknown() const;
          void setUnknown();
          void unsetUnknown();

          bool isDefault() const;
          void setDefault();
          void unsetDefault();

          bool isRestrict() const;
          void setRestrict();
          void unsetRestrict();

       // Fortran specific attribute
          bool isAllocatable() const;
          void setAllocatable();
          void unsetAllocatable();

       // Fortran specific attribute
          bool isBind() const;
          void setBind();
          void unsetBind();

       // Fortran specific attribute
          bool isAsynchronous() const;
          void setAsynchronous();
          void unsetAsynchronous();

       // Fortran specific attribute
          bool isData() const;
          void setData();
          void unsetData();

       // Fortran specific attribute
          bool isDimension() const;
          void setDimension();
          void unsetDimension();

       // Fortran specific attribute
          bool isIntent_in() const;
          void setIntent_in();
          void unsetIntent_in();

       // Fortran specific attribute
          bool isIntent_out() const;
          void setIntent_out();
          void unsetIntent_out();

       // Fortran specific attribute
          bool isIntent_inout() const;
          void setIntent_inout();
          void unsetIntent_inout();

       // Fortran specific attribute
          bool isIntrinsic() const;
          void setIntrinsic();
          void unsetIntrinsic();

       // Fortran specific attribute
          bool isOptional() const;
          void setOptional();
          void unsetOptional();

       // Fortran specific attribute
          bool isSave() const;
          void setSave();
          void unsetSave();

       // Fortran specific attribute
          bool isTarget() const;
          void setTarget();
          void unsetTarget();

       // Fortran specific attribute
          bool isValue() const;
          void setValue();
          void unsetValue();

       // Fortran specific attribute
          bool isExtends() const;
          void setExtends();
          void unsetExtends();

       // Fortran specific attribute
          bool isAbstract() const;
          void setAbstract();
          void unsetAbstract();

       // DQ (1/3/2009): Added GNU specific attributes
          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributePacked() const;
          void setGnuAttributePacked();
          void unsetGnuAttributePacked();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeNoReturn() const;
          void setGnuAttributeNoReturn();
          void unsetGnuAttributeNoReturn();

          bool isGnuAttributeConst() const;
          void setGnuAttributeConst();
          void unsetGnuAttributeConst();

          bool isGnuAttributeCdecl() const;
          void setGnuAttributeCdecl();
          void unsetGnuAttributeCdecl();

          bool isGnuAttributeStdcall() const;
          void setGnuAttributeStdcall();
          void unsetGnuAttributeStdcall();

          bool isGnuAttributeWarnUnusedResult() const;
          void setGnuAttributeWarnUnusedResult();
          void unsetGnuAttributeWarnUnusedResult();

          bool isGnuAttributeNonnull() const;
          void setGnuAttributeNonnull();
          void unsetGnuAttributeNonnull();

          bool isGnuAttributeSentinel() const;
          void setGnuAttributeSentinel();
          void unsetGnuAttributeSentinel();

          bool haveAddressSpace() const;
          void setAddressSpace();
          void unsetAddressSpace();

          bool isOpenclGlobal() const;
          void setOpenclGlobal();
          void unsetOpenclGlobal();

          bool isOpenclLocal() const;
          void setOpenclLocal();
          void unsetOpenclLocal();

          bool isOpenclConstant() const;
          void setOpenclConstant();
          void unsetOpenclConstant();

          bool isVectorType() const;
          void setVectorType();
          void unsetVectorType();

          bool isGnuAttributeDevice() const;
          void setGnuAttributeDevice();
          void unsetGnuAttributeDevice();

       // Jovial specific attribute
          bool isRound() const;
          void setRound();
          void unsetRound();

       // Jovial specific attribute
          bool isTruncate() const;
          void setTruncate();
          void unsetTruncate();

       // Jovial specific attribute
          bool isTruncateTowardsZero() const;
          void setTruncateTowardsZero();
          void unsetTruncateTowardsZero();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgTypeModifier & m );
          friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

       // DQ (11/28/2015): We need a better way to support equivalents and difference in the SgTypeModifier.
          bool isIdentity() const;

HEADER_TYPE_MODIFIER_END

HEADER_ELABORATED_TYPE_MODIFIER_START
       // elaborated-type-specifier (class, struct, union, enum, typename, typename template)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Elaborated Type Modifiers (only one value can be specified)

          Modifier information about (class,struct, union, enum, and typename).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum elaborated_type_modifier_enum
             {
            // Only one value can be specified ???
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value (default) */
               e_class    = 2, /*!< class type */
               e_struct   = 3, /*!< struct type */
               e_union    = 4, /*!< union type */
               e_enum     = 5, /*!< enum type */
               e_typename = 6, /*!< typename type */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isClass() const;
          void setClass();

          bool isStruct() const;
          void setStruct();

          bool isUnion() const;
          void setUnion();

          bool isEnum() const;
          void setEnum();

          bool isTypename() const;
          void setTypename();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgElaboratedTypeModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_ELABORATED_TYPE_MODIFIER_END

HEADER_LINKAGE_MODIFIER_START

       // linkage-specification (extern, extern "C", extern "C++", extern "Fortran")

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Linkage Modifiers (only one value can be specified)

          Modifier information about (C linkage, C++ linkage, Fortran linkage, and Fortran 90 linkage).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum linkage_modifier_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_C_linkage         = 2, /*!< C linkage */
               e_Cpp_linkage       = 3, /*!< C++ linkage */
               e_fortran_linkage   = 4, /*!< FORTRAN linkage (not really used yet) */
               e_fortran90_linkage = 5, /*!< FORTRAN 90 linkage (not really used yet) */
               e_last_modifier        /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isC_Linkage() const;
          void setC_Linkage();

          bool isCppLinkage() const;
          void setCppLinkage();

          bool isFortranLinkage() const;
          void setFortranLinkage();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgLinkageModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_LINKAGE_MODIFIER_END

HEADER_BASECLASS_MODIFIER_START
       // base-class-specifier (virtual, access specifiers)

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
      /*! \brief Baseclass Modifiers (only one value can be specified)

          Modifier information about (virtual or not).

          \internal Only one value can be specified (at least in C and C++)
       */
          enum baseclass_modifier_enum
             {
            // Only one value can be specified (at least in C, what about C++)
               e_unknown = 0,  /*!< error value */
               e_default = 1,  /*!< default value */
               e_virtual = 2,  /*!< virtual value */
               e_last_modifier /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          SgAccessModifier & get_accessModifier();
          const SgAccessModifier & get_accessModifier() const;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isVirtual() const;
          void setVirtual();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgBaseClassModifier & m );
		  friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);

       // DQ (2/4/2006): Added mechamism to clear all bits
          void reset();

HEADER_BASECLASS_MODIFIER_END

// *****************************************************
// ************ Support for ADA Constraints ************
// *****************************************************
HEADER_ADA_TYPE_CONSTRAINT_START
          SgAdaTypeConstraint (const SgAdaTypeConstraint& X);
          SgAdaTypeConstraint& operator= (const SgAdaTypeConstraint& X);
          virtual std::string displayString() const { ROSE_ASSERT(false); };
HEADER_ADA_TYPE_CONSTRAINT_END


HEADER_ADA_RANGE_CONSTRAINT_START
  void post_construction_initialization() $ROSE_OVERRIDE;
  std::string displayString() const $ROSE_OVERRIDE;
  void display ( std::string label ) const;
  friend std::ostream & operator<< ( std::ostream& os, const SgAdaRangeConstraint& c);
  //~ friend bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs);
HEADER_ADA_RANGE_CONSTRAINT_END



HEADER_ATTRIBUTE_SUPPORT_START

     /* name Persistant Attribute Mechanism 

         This is the persistant attribute mechanism for attaching attributes to IR nodes across
         multiple passes. Note that these attributes are persistant in that they are preserved
         if the AST is written out to a file and read in from a file.  However, virtual function
         in the user-defined class derived from the AstAttribute must be defined for the attribute
         to be defined across the boundary of File I/O (simple pack and unpack functions).  More
         sophisticated mechanisms are available within the AstAttributeMechanism object
         (e.g iterating though attributes, etc; get_attributeMechanism() is available if direct
         access is required, however mostly only internal tools use this lower level support).

         \internal This used to be a public data member, but has been changed to be a protected
         pointer instead.  The functional interface of the AstAttributeMechanism is presevered
         but some of the names and the syntax for calling the interface have changed. The
         pointer to the AstAttributeMechanism is now generated by ROSETTA.
      */
     /* */
     //! Add a new attribute represented by the named string.
         virtual void addNewAttribute(std::string s,AstAttribute* a) $ROSE_OVERRIDE;
     //! Returns attribute of name 's'.
         virtual AstAttribute* getAttribute(std::string s) const $ROSE_OVERRIDE;
     //! Replace existing attribute of name 's' with new AstAttribute.
         virtual void updateAttribute(std::string s,AstAttribute* a) $ROSE_OVERRIDE;  // formerly called: replace in AstAttributeMechanism
     /*! \brief This is a wrapper function with the following semantics:
         if no attribute of name 's' exists then \b addNewAttribute(s,a); is called,
         otherwise \b updateAttribute(s,a); is called.
      */
         virtual void setAttribute(std::string s,AstAttribute* a) $ROSE_OVERRIDE;
     //! Remove attribute of name 's' if present.
         virtual void removeAttribute(std::string s) $ROSE_OVERRIDE;
     //! Tests if attribute of name 's' is present.
         virtual bool attributeExists(std::string s) const $ROSE_OVERRIDE;
     //! Returns the number of attributes on this IR node.
         virtual int numberOfAttributes() const $ROSE_OVERRIDE;

     /*! \fn AstAttributeMechanism* $CLASSNAME::get_attributeMechanism() const;
         \brief \b FOR \b INTERNAL \b USE Access function; if an attribute exists then 
                a pointer to it is returned, else error.

         This is an access function used for getting the interally held pointer to a valid 
         AstAttributeMechanism. It provides access to lower level functionality of the 
         AstAttributeMechanism, put is mostly of use to internal tools.
      */
     /*! \fn void $CLASSNAME::set_attributeMechanism(AstAttributeMechanism* a);
         \brief \b FOR \b INTERNAL \b USE Access function; sets poiner to value AstAttributeMechanism.

         This is an access function used for setting the interally held pointer to a valid 
         AstAttributeMechanism.
      */
     /* */


HEADER_ATTRIBUTE_SUPPORT_END


HEADER_NAME_GROUP_START
          const SgStringList & get_name_list() const;
          SgStringList & get_name_list();
HEADER_NAME_GROUP_END


HEADER_COMMON_BLOCK_OBJECT_START
HEADER_COMMON_BLOCK_OBJECT_END


HEADER_DIMENSION_OBJECT_START
HEADER_DIMENSION_OBJECT_END


HEADER_DATA_STATEMENT_GROUP_START

          const SgDataStatementObjectPtrList & get_object_list() const;
          SgDataStatementObjectPtrList & get_object_list();

          const SgDataStatementValuePtrList & get_value_list() const;
          SgDataStatementValuePtrList & get_value_list();

HEADER_DATA_STATEMENT_GROUP_END

HEADER_DATA_STATEMENT_OBJECT_START
HEADER_DATA_STATEMENT_OBJECT_END

HEADER_DATA_STATEMENT_VALUE_START

      //! Support for Fortran data statement
          enum data_statement_value_enum
             {
               e_unknown           = 0, /*!< error value */
               e_default           = 1, /*!< default value */
               e_explict_list      = 2, /*!< list of value expressions */
               e_implicit_list     = 3, /*!< repeat-count * value */
               e_implied_do        = 4, /*!< implied do loop initializer */
               e_last_initializer_form  /*!< last value (upper bound on range of values, used in error checking) */
             };

          void post_construction_initialization() $ROSE_OVERRIDE;

HEADER_DATA_STATEMENT_VALUE_END


HEADER_FORMAT_ITEM_START
HEADER_FORMAT_ITEM_END


HEADER_FORMAT_ITEM_LIST_START

          const SgFormatItemPtrList & get_format_item_list() const;
          SgFormatItemPtrList & get_format_item_list();
          void set_format_item_list ( const SgFormatItemPtrList & formatItemList );

HEADER_FORMAT_ITEM_LIST_END


HEADER_TYPE_TABLE_START
          $CLASSNAME ();
          void insert_type(const SgName&, SgType *);

          SgType* lookup_type (const SgName&);

       // DQ (7/22/2010): Added to support AST merge.
          void remove_type(const SgName&);

          void print_typetable(std::ostream& os = std::cout);

HEADER_TYPE_TABLE_END


SOURCE_ATTRIBUTE_SUPPORT_START

#if 0
// DQ (4/10/2006): Removed in favor of implementation at SgNode using
// a pointer and the interface represented directly at the SgNode
AstAttributeMechanism & 
$CLASSNAME::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          mprintf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          assert(false);
        }

     return *p_attribute;
   }
#endif

void
$CLASSNAME::addNewAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          assert(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->add(s,a);
   }

void
$CLASSNAME::setAttribute( std::string s, AstAttribute* a )
   {
     if (get_attributeMechanism() == NULL)
        {
          set_attributeMechanism( new AstAttributeMechanism() );
          assert(get_attributeMechanism() != NULL);
        }
     get_attributeMechanism()->set(s,a);
   }

AstAttribute*
$CLASSNAME::getAttribute(std::string s) const
   {
     //assert(get_attributeMechanism() != NULL); // Liao, bug 130 6/4/2008
     if (attributeExists(s)==false) return NULL;
     AstAttribute* returnValue = get_attributeMechanism()->operator[](s);
     assert(returnValue != NULL);
     return returnValue;
   }

void
$CLASSNAME::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     assert(get_attributeMechanism() != NULL);
     get_attributeMechanism()->replace(s,a);
   }

void
$CLASSNAME::removeAttribute(std::string s)
   {
     if (get_attributeMechanism())
         get_attributeMechanism()->remove(s);

  // DQ (1/2/2006): If we have no more attributes then remove the attribute container
     int remainingCount = numberOfAttributes();
  // mprintf ("In AstTextAttributesHandling::visit(): remaining number of attributes = %d \n",remainingCount);
     if (remainingCount == 0)
        {
          delete get_attributeMechanism();
          set_attributeMechanism(NULL);
        }
   }

bool
$CLASSNAME::attributeExists(std::string s) const
   {
     bool returnValue = false;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->exists(s);
     return returnValue;
   }

int
$CLASSNAME::numberOfAttributes() const
   {
     int returnValue = 0;
     if (get_attributeMechanism() != NULL)
          returnValue = get_attributeMechanism()->size();
     return returnValue;
   }

SOURCE_ATTRIBUTE_SUPPORT_END


SOURCE_MODIFIER_START

SgModifier::SgModifier ( const SgModifier & X )
   {
  // DQ (4/13/2004): Nothing to do here, but this function prevents the SgSupport copy 
  // constructor from being called and we would like to keep that copy constructor 
  // private so that we can enforce error checking via the type system.
   }

SgModifier & 
SgModifier::operator= ( const SgModifier & X )
   {
     return *this;
   }

bool
SgModifier::checkBit ( unsigned int bit, const SgBitVector & bitVector ) const 
   {
     assert (bit < bitVector.size());
     return bitVector[bit];
   }

void
SgModifier::setBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     assert (bit < bitVector.size());
     bitVector[bit] = true;
   }

void
SgModifier::unsetBit ( unsigned int bit, SgBitVector & bitVector ) const
   {
     assert (bit < bitVector.size());
     bitVector[bit] = false;
   }

SOURCE_MODIFIER_END

SOURCE_ADA_TYPE_CONSTRAINT_START

SgAdaTypeConstraint::SgAdaTypeConstraint ( const SgAdaTypeConstraint & X )
   : SgSupport()
   { 
     /* see comment in SgModifier */ 
   }

SgAdaTypeConstraint& 
SgAdaTypeConstraint::operator= ( const SgAdaTypeConstraint& X )
   {
     return *this;
   }

SOURCE_ADA_TYPE_CONSTRAINT_END


SOURCE_MODIFIER_NODES_START

#if 1
// These are generated
SgModifierNodes::SgModifierNodes()
   {
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // p_next = (SgModifierNodes*)0L;
  // MK: Call the following function instead
     post_construction_initialization();
   }

#if 0
SgModifierNodes::~SgModifierNodes()
   {
     // delete nodes[];
     delete p_next;
   }
#endif
#endif

void
SgModifierNodes::post_construction_initialization()
   {
  // nodes = new (SgModifierType*)[4];
  // p_nodes[0] = p_nodes[1] = p_nodes[2] = p_nodes[3] = (SgModifierType*)0L;
  // MK: p_nodes is an STL vector now, it needs to be initilized differently
     for (int i= 0; i<4; i++)
          p_nodes.push_back((SgModifierType*) NULL);
     p_next = (SgModifierNodes*) NULL;
   }

#if 0
// DQ (4/13/2004): Commented out as a test to see if we need this function
SgModifierType*
SgModifierNodes::match(SgType* base, unsigned int f)
   {
     for (int j = 0; j < 4; j++)
        {
          if (!p_nodes[j])
             {
               SgModifierType* newType = new SgModifierType(base, f);
               assert(newType != NULL);

               p_nodes[j] = newType;
               assert(p_nodes[j] != NULL);

               return p_nodes[j];
            // return nodes[j] = new SgModifierType(base, f);
             }
          assert(p_nodes[j] != NULL);
          if (p_nodes[j]->bitfield() == f)
             {
               return p_nodes[j];
             }
        }

     if (!p_next)
        {
          p_next = new SgModifierNodes();
          assert(p_next != NULL);
        }

     return p_next->match(base, f);
   }
#endif

SOURCE_MODIFIER_NODES_END


SOURCE_CV_TYPE_MODIFIER_START

$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isConst() const { return p_modifier == e_const || p_modifier == e_const_volatile; }
void $CLASSNAME::setConst()      { p_modifier = (p_modifier == e_volatile) ? e_const_volatile : e_const; }
void $CLASSNAME::unsetConst()    { p_modifier = (p_modifier == e_const_volatile) ? e_volatile : e_default; }

bool $CLASSNAME::isVolatile() const { return p_modifier == e_volatile || p_modifier == e_const_volatile; }
void $CLASSNAME::setVolatile()      { p_modifier = (p_modifier == e_const) ? e_const_volatile : e_volatile; }
void $CLASSNAME::unsetVolatile()    { p_modifier = (p_modifier == e_const_volatile) ? e_const : e_default; }

// DQ (8/11/2011): Added support for Java "transient" keyword to disable serialization.
bool $CLASSNAME::isJavaTransient() const { return p_modifier == e_java_transient; }
void $CLASSNAME::setJavaTransient()      { p_modifier = e_java_transient; }
void $CLASSNAME::unsetJavaTransient()    { setDefault(); }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")       + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")       + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isConst() = ")         + std::string(isConst()    ? "true " : "false ");
     s += std::string("isVolatile() = ")      + std::string(isVolatile() ? "true " : "false ");

     s += std::string("isJavaTransient() = ") + std::string(isJavaTransient() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
#if 0
     mprintf ("   isUnknown()         = %s \n",isUnknown()  ? "true" : "false");
     mprintf ("   isDefault()         = %s \n",isDefault()  ? "true" : "false");
     mprintf ("   isConst()           = %s \n",isConst()    ? "true" : "false");
     mprintf ("   isVolatile()        = %s \n",isVolatile() ? "true" : "false");
#else
     mprintf ("%s \n",displayString().c_str());
#endif
   }

std::ostream & operator<< ( std::ostream & os, const SgConstVolatileModifier & m) 
   {
     os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
	return
	       (lhs.isUnknown()  == rhs.isUnknown() ) &&
	       (lhs.isDefault()  == rhs.isDefault() ) &&
	       (lhs.isConst()    == rhs.isConst()   ) &&
	       (lhs.isVolatile() == rhs.isVolatile()) ;
   }


// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_CV_TYPE_MODIFIER_END


SOURCE_STORAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isExtern() const { return p_modifier == e_extern; }
void $CLASSNAME::setExtern()      { p_modifier = e_extern; }

bool $CLASSNAME::isStatic() const { return p_modifier == e_static; }
void $CLASSNAME::setStatic()      { p_modifier = e_static; }

bool $CLASSNAME::isAuto() const { return p_modifier == e_auto; }
void $CLASSNAME::setAuto()      { p_modifier = e_auto; }

bool $CLASSNAME::isUnspecified() const { return p_modifier == e_unspecified; }
void $CLASSNAME::setUnspecified()      { p_modifier = e_unspecified; }

// This is not used (but is present in the EDG AST)
bool $CLASSNAME::isTypedef() const { return p_modifier == e_typedef; }
void $CLASSNAME::setTypedef()      { p_modifier = e_typedef; }

bool $CLASSNAME::isRegister() const { return p_modifier == e_register; }
void $CLASSNAME::setRegister()      { p_modifier = e_register; }

bool $CLASSNAME::isMutable() const { return p_modifier == e_mutable; }
void $CLASSNAME::setMutable()      { p_modifier = e_mutable; }

bool $CLASSNAME::isAsm() const { return p_modifier == e_asm; }
void $CLASSNAME::setAsm()      { p_modifier = e_asm; }

#ifdef FORTRAN_SUPPORTED
// These remaining access functions are specific to FORTRAN
bool $CLASSNAME::isLocal() const { return p_modifier == e_local; }
void $CLASSNAME::setLocal()      { p_modifier = e_local; }

bool $CLASSNAME::isCommon() const { return p_modifier == e_common; }
void $CLASSNAME::setCommon()      { p_modifier = e_common; }

bool $CLASSNAME::isAssociated() const { return p_modifier == e_associated; }
void $CLASSNAME::setAssociated()      { p_modifier = e_associated; }

bool $CLASSNAME::isIntrinsic() const { return p_modifier == e_intrinsic; }
void $CLASSNAME::setIntrinsic()      { p_modifier = e_intrinsic; }

bool $CLASSNAME::isPointerBased() const { return p_modifier == e_pointer_based; }
void $CLASSNAME::setPointerBased()      { p_modifier = e_pointer_based; }
#endif

// Rasmussen (02/04/2018): Fortran contiguous array storage attribute
bool SgStorageModifier::isContiguous() const { return p_modifier == e_contiguous; }
void SgStorageModifier::setContiguous()      {        p_modifier  = e_contiguous; }

// TV (08/04/2010): Support for CUDA storage modifiers

bool SgStorageModifier::isCudaGlobal() const { return p_modifier == e_cuda_global; }
void SgStorageModifier::setCudaGlobal()      { p_modifier = e_cuda_global; }

bool SgStorageModifier::isCudaConstant() const { return p_modifier == e_cuda_constant; }
void SgStorageModifier::setCudaConstant()      { p_modifier = e_cuda_constant; }

bool SgStorageModifier::isCudaShared() const { return p_modifier == e_cuda_shared; }
void SgStorageModifier::setCudaShared()      { p_modifier = e_cuda_shared; }

bool SgStorageModifier::isCudaDynamicShared() const { return p_modifier == e_cuda_dynamic_shared; }
void SgStorageModifier::setCudaDynamicShared()      { p_modifier = e_cuda_dynamic_shared; }

// Rasmussen (03/13/2018): New CUDA storage modifiers

bool SgStorageModifier::isCudaDeviceMemory() const { return p_modifier == e_cuda_device_memory; }
void SgStorageModifier::setCudaDeviceMemory()      {        p_modifier  = e_cuda_device_memory; }

bool SgStorageModifier::isCudaManaged()      const { return p_modifier == e_cuda_managed; }
void SgStorageModifier::setCudaManaged()           {        p_modifier  = e_cuda_managed; }

bool SgStorageModifier::isCudaPinned()       const { return p_modifier == e_cuda_pinned; }
void SgStorageModifier::setCudaPinned()            {        p_modifier  = e_cuda_pinned; }

bool SgStorageModifier::isCudaTexture()      const { return p_modifier == e_cuda_texture; }
void SgStorageModifier::setCudaTexture()           {        p_modifier  = e_cuda_texture; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isExtern() = ")       + std::string(isExtern()       ? "true " : "false ");
     s += std::string("isStatic() = ")       + std::string(isStatic()       ? "true " : "false ");
     s += std::string("isAuto() = ")         + std::string(isAuto()         ? "true " : "false ");
     s += std::string("isUnspecified() = ")  + std::string(isUnspecified()  ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isRegister() = ")     + std::string(isRegister()     ? "true " : "false ");
     s += std::string("isMutable() = ")      + std::string(isMutable()      ? "true " : "false ");
     s += std::string("isAsm() = ")          + std::string(isAsm()          ? "true " : "false ");
#ifdef FORTRAN_SUPPORTED
     s += std::string("isLocal() = ")        + std::string(isLocal()        ? "true " : "false ");
     s += std::string("isCommon() = ")       + std::string(isCommon()       ? "true " : "false ");
     s += std::string("isAssociated() = ")   + std::string(isAssociated()   ? "true " : "false ");
     s += std::string("isIntrinsic() = ")    + std::string(isIntrinsic()    ? "true " : "false ");
     s += std::string("isPointerBased() = ") + std::string(isPointerBased() ? "true " : "false ");
#endif
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()        == rhs.isUnknown() ) &&
	       (lhs.isDefault()        == rhs.isDefault() ) &&
	       (lhs.isExtern()         == rhs.isExtern()  ) &&
	       (lhs.isStatic()         == rhs.isStatic()  ) &&
	       (lhs.isAuto()           == rhs.isAuto()  ) &&
	       (lhs.isUnspecified()    == rhs.isUnspecified()  ) &&
	       (lhs.isRegister()       == rhs.isRegister()  ) &&
	       (lhs.isMutable()        == rhs.isMutable()  ) &&
	       (lhs.isTypedef()        == rhs.isTypedef()  ) &&
	       (lhs.isAsm()            == rhs.isAsm()  ) &&
	       (lhs.isContiguous()     == rhs.isContiguous()  ) &&
	       (lhs.isCudaGlobal()     == rhs.isCudaGlobal()  ) &&
	       (lhs.isCudaConstant()   == rhs.isCudaConstant()) &&
	       (lhs.isCudaShared()     == rhs.isCudaShared()  ) &&
	       (lhs.isCudaManaged()    == rhs.isCudaManaged() ) &&
	       (lhs.isCudaPinned()     == rhs.isCudaPinned()  ) &&
	       (lhs.isCudaTexture()    == rhs.isCudaTexture() ) &&
	       (lhs.isCudaDynamicShared() == rhs.isCudaDynamicShared() ) &&
	       (lhs.isCudaDeviceMemory()  == rhs.isCudaDeviceMemory()  ) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_STORAGE_MODIFIER_END

SOURCE_ACCESS_MODIFIER_START

// Copy constructor
SgAccessModifier::SgAccessModifier ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
   }

SgAccessModifier &
SgAccessModifier::operator= ( const SgAccessModifier & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
SgAccessModifier::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool SgAccessModifier::isUnknown() const { return p_modifier == e_unknown; }
void SgAccessModifier::setUnknown()      { p_modifier = e_unknown; }

bool SgAccessModifier::isDefault() const { return p_modifier == e_default; }
void SgAccessModifier::setDefault()      { p_modifier = e_default; }

bool SgAccessModifier::isPrivate() const { return p_modifier == e_private; }
void SgAccessModifier::setPrivate()      { p_modifier = e_private; }

bool SgAccessModifier::isProtected() const { return p_modifier == e_protected; }
void SgAccessModifier::setProtected()      { p_modifier = e_protected; }

bool SgAccessModifier::isPublic() const { return p_modifier == e_public; }
void SgAccessModifier::setPublic()      { p_modifier = e_public; }

bool SgAccessModifier::isUndefined() const { return p_modifier == e_undefined; }
void SgAccessModifier::setUndefined()      { p_modifier = e_undefined; }

string
SgAccessModifier::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isPrivate() = ")   + std::string(isPrivate()   ? "true " : "false ");
     s += std::string("isProtected() = ") + std::string(isProtected() ? "true " : "false ");
     s += std::string("isPublic() = ")    + std::string(isPublic()    ? "true " : "false ");
     s += std::string("isUndefined() = ") + std::string(isUndefined() ? "true " : "false ");
     s += ")";
     return s;
   }

void
SgAccessModifier::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgAccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   } 

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()  == rhs.isUnknown() ) &&
	       (lhs.isDefault()  == rhs.isDefault() ) &&
	       (lhs.isPrivate()  == rhs.isPrivate() ) &&
	       (lhs.isProtected()== rhs.isProtected()) &&
	       (lhs.isPublic()   == rhs.isPublic()  ) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void SgAccessModifier::reset()
   {
     setDefault();
   }

SOURCE_ACCESS_MODIFIER_END


SOURCE_FUNCTION_MODIFIER_START
// Copy constructor
SgFunctionModifier::$CLASSNAME ( const SgFunctionModifier & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

SgFunctionModifier &
SgFunctionModifier::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
SgFunctionModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgFunctionModifier::isUnknown() const { return checkBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::setUnknown()      { setBit(e_unknown,p_modifierVector); }
void SgFunctionModifier::unsetUnknown()    { unsetBit(e_unknown,p_modifierVector); }

bool SgFunctionModifier::isDefault() const { return checkBit(e_default,p_modifierVector); }
void SgFunctionModifier::setDefault()      { setBit(e_default,p_modifierVector); }
void SgFunctionModifier::unsetDefault()    { unsetBit(e_default,p_modifierVector); }

bool SgFunctionModifier::isInline() const { return checkBit(e_inline,p_modifierVector); }
void SgFunctionModifier::setInline()      { setBit(e_inline,p_modifierVector); }
void SgFunctionModifier::unsetInline()    { unsetBit(e_inline,p_modifierVector); }

bool SgFunctionModifier::isVirtual() const { return checkBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::setVirtual()      { setBit(e_virtual,p_modifierVector); }
void SgFunctionModifier::unsetVirtual()    { unsetBit(e_virtual,p_modifierVector); }

bool SgFunctionModifier::isPureVirtual() const { return checkBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::setPureVirtual()      { setBit(e_pure_virtual,p_modifierVector); }
void SgFunctionModifier::unsetPureVirtual()    { unsetBit(e_pure_virtual,p_modifierVector); }

bool SgFunctionModifier::isExplicit() const { return checkBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::setExplicit()      { setBit(e_explicit,p_modifierVector); }
void SgFunctionModifier::unsetExplicit()    { unsetBit(e_explicit,p_modifierVector); }

#if 0
bool SgFunctionModifier::isBind() const { return checkBit(e_bind,p_modifierVector); }
void SgFunctionModifier::setBind()      { setBit(e_bind,p_modifierVector); }
void SgFunctionModifier::unsetBind()    { unsetBit(e_bind,p_modifierVector); }
#endif

bool SgFunctionModifier::isPure() const { return checkBit(e_pure,p_modifierVector); }
void SgFunctionModifier::setPure()      { setBit(e_pure,p_modifierVector); }
void SgFunctionModifier::unsetPure()    { unsetBit(e_pure,p_modifierVector); }

bool SgFunctionModifier::isElemental() const { return checkBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::setElemental()      { setBit(e_elemental,p_modifierVector); }
void SgFunctionModifier::unsetElemental()    { unsetBit(e_elemental,p_modifierVector); }

bool SgFunctionModifier::isRecursive() const { return checkBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::setRecursive()      { setBit(e_recursive,p_modifierVector); }
void SgFunctionModifier::unsetRecursive()    { unsetBit(e_recursive,p_modifierVector); }

// Rasmussen (10/26/2019): Added Jovial specific attribute
bool SgFunctionModifier::isReentrant() const { return checkBit(e_reentrant,p_modifierVector); }
void SgFunctionModifier::setReentrant()      { setBit(e_reentrant,p_modifierVector); }
void SgFunctionModifier::unsetReentrant()    { unsetBit(e_reentrant,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeConstructor() const { return checkBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeConstructor()      { setBit(e_gnu_attribute__constructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeConstructor()    { unsetBit(e_gnu_attribute__constructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDestructor() const { return checkBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDestructor()      { setBit(e_gnu_attribute__destructor__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDestructor()    { unsetBit(e_gnu_attribute__destructor__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributePure() const { return checkBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributePure()      { setBit(e_gnu_attribute__pure__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributePure()    { unsetBit(e_gnu_attribute__pure__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeMalloc() const { return checkBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeMalloc()      { setBit(e_gnu_attribute__malloc__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeMalloc()    { unsetBit(e_gnu_attribute__malloc__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNaked() const { return checkBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNaked()      { setBit(e_gnu_attribute__naked__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNaked()    { unsetBit(e_gnu_attribute__naked__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInstrumentFunction() const { return checkBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInstrumentFunction()      { setBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInstrumentFunction()    { unsetBit(e_gnu_attribute__no_instrument_function__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoCheckMemoryUsage() const { return checkBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoCheckMemoryUsage()      { setBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoCheckMemoryUsage()    { unsetBit(e_gnu_attribute__no_check_memory_usage__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoInline() const { return checkBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoInline()      { setBit(e_gnu_attribute__noinline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoInline()    { unsetBit(e_gnu_attribute__noinline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeAlwaysInline() const { return checkBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeAlwaysInline()      { setBit(e_gnu_attribute__always_inline__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeAlwaysInline()    { unsetBit(e_gnu_attribute__always_inline__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeNoThrow() const { return checkBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeNoThrow()      { setBit(e_gnu_attribute__nothrow__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeNoThrow()    { unsetBit(e_gnu_attribute__nothrow__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgFunctionModifier::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__,p_modifierVector); }
void SgFunctionModifier::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__,p_modifierVector); }

// TV (04/08/2010): Support for CUDA functions modifiers
bool SgFunctionModifier::isCudaDevice() const { return checkBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::setCudaDevice()      { setBit(e_cuda_device,p_modifierVector); }
void SgFunctionModifier::unsetCudaDevice()    { unsetBit(e_cuda_device,p_modifierVector); }

bool SgFunctionModifier::isCudaKernel() const { return checkBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::setCudaKernel()      { setBit(e_cuda_kernel,p_modifierVector); }
void SgFunctionModifier::unsetCudaKernel()    { unsetBit(e_cuda_kernel,p_modifierVector); }

bool SgFunctionModifier::isCudaHost() const { return checkBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::setCudaHost()      { setBit(e_cuda_host,p_modifierVector); }
void SgFunctionModifier::unsetCudaHost()    { unsetBit(e_cuda_host,p_modifierVector); }

// Rasmussen (03/13/2018): New CUDA function modifiers
bool SgFunctionModifier::isCudaGlobalFunction() const { return checkBit(e_cuda_global_function,p_modifierVector); }
void SgFunctionModifier::setCudaGlobalFunction()      {          setBit(e_cuda_global_function,p_modifierVector); }
void SgFunctionModifier::unsetCudaGlobalFunction()    {        unsetBit(e_cuda_global_function,p_modifierVector); }

bool SgFunctionModifier::isCudaGridGlobal() const { return checkBit(e_cuda_grid_global,p_modifierVector); }
void SgFunctionModifier::setCudaGridGlobal()      {          setBit(e_cuda_grid_global,p_modifierVector); }
void SgFunctionModifier::unsetCudaGridGlobal()    {        unsetBit(e_cuda_grid_global,p_modifierVector); }

// TV (05/03/2010): Support for OpenCL functions modifiers       
bool SgFunctionModifier::isOpenclKernel() const { return checkBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::setOpenclKernel()      { setBit(e_opencl_kernel, p_modifierVector); }
void SgFunctionModifier::unsetOpenclKernel()    { unsetBit(e_opencl_kernel, p_modifierVector); }
          
bool SgFunctionModifier::hasOpenclVecTypeHint() const { return checkBit(e_opencl_vec_type_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclVecTypeHint()       { setBit(e_opencl_vec_type_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclVecTypeHint()     { unsetBit(e_opencl_vec_type_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeHint() const { return checkBit(e_opencl_work_group_size_hint, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeHint()       { setBit(e_opencl_work_group_size_hint,p_modifierVector); }
void SgFunctionModifier::unsetOpenclWorkGroupSizeHint()     { unsetBit(e_opencl_work_group_size_hint, p_modifierVector); }

bool SgFunctionModifier::hasOpenclWorkGroupSizeReq() const { return checkBit(e_opencl_work_group_size_req, p_modifierVector); }
void SgFunctionModifier::setOpenclWorkGroupSizeReq()       { setBit(e_opencl_work_group_size_req,p_modifierVector);}
void SgFunctionModifier::unsetOpenclWorkGroupSizeReq()     { unsetBit(e_opencl_work_group_size_req, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaNative() const { return checkBit(e_java_native, p_modifierVector); }
void SgFunctionModifier::setJavaNative()      { setBit(e_java_native, p_modifierVector); }
void SgFunctionModifier::unsetJavaNative()    { unsetBit(e_java_native, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaSynchronized() const { return checkBit(e_java_synchronized, p_modifierVector); }
void SgFunctionModifier::setJavaSynchronized()      { setBit(e_java_synchronized, p_modifierVector); }
void SgFunctionModifier::unsetJavaSynchronized()    { unsetBit(e_java_synchronized, p_modifierVector); }

// DQ (8/11/2011): Added support for Java specific function modifiers.
bool SgFunctionModifier::isJavaStrictfp() const { return checkBit(e_java_strictfp, p_modifierVector); }
void SgFunctionModifier::setJavaStrictfp()      { setBit(e_java_strictfp, p_modifierVector); }
void SgFunctionModifier::unsetJavaStrictfp()    { unsetBit(e_java_strictfp, p_modifierVector); }

// PC (07/24/2012): Added support for Java specific feature: Initializer blocks.
bool SgFunctionModifier::isJavaInitializer() const { return checkBit(e_java_initializer, p_modifierVector); }
void SgFunctionModifier::setJavaInitializer()      { setBit(e_java_initializer, p_modifierVector); }
void SgFunctionModifier::unsetJavaInitializer()    { unsetBit(e_java_initializer, p_modifierVector); }


// DQ (4/13/2019): Added C++11 options for function modifiers.
bool SgFunctionModifier::isMarkedDefault() const { return checkBit(e_marked_default, p_modifierVector); }
void SgFunctionModifier::setMarkedDefault()      { setBit(e_marked_default, p_modifierVector); }
void SgFunctionModifier::unsetMarkedDefault()    { unsetBit(e_marked_default, p_modifierVector); }

// DQ (4/13/2019): Added C++11 options for function modifiers.
bool SgFunctionModifier::isMarkedDelete() const { return checkBit(e_marked_delete, p_modifierVector); }
void SgFunctionModifier::setMarkedDelete()      { setBit(e_marked_delete, p_modifierVector); }
void SgFunctionModifier::unsetMarkedDelete()    { unsetBit(e_marked_delete, p_modifierVector); }




string
SgFunctionModifier::displayString() const
   {
     std::string s = "SgFunctionModifier(";
     s += std::string("isUnknown() = ")          + std::string(isUnknown()          ? "true " : "false ");
     s += std::string("isDefault() = ")          + std::string(isDefault()          ? "true " : "false ");
     s += std::string("isInline() = ")           + std::string(isInline()           ? "true " : "false ");
     s += std::string("isVirtual() = ")          + std::string(isVirtual()          ? "true " : "false ");
     s += std::string("isPureVirtual() = ")      + std::string(isPureVirtual()      ? "true " : "false ");
     s += std::string("isExplicit() = ")         + std::string(isExplicit()         ? "true " : "false ");
  // s += std::string("isBind() = ")             + std::string(isBind()             ? "true " : "false ");
     s += std::string("isPure() = ")             + std::string(isPure()             ? "true " : "false ");

  // DQ (2/26/2013): Bug report noticed that a set of these attributes were not properly support.
     s += std::string("isElemental() = ")                        + std::string(isElemental() ? "true " : "false ");
     s += std::string("isRecursive() = ")                        + std::string(isRecursive() ? "true " : "false ");
     s += std::string("isReentrant() = ")                        + std::string(isReentrant() ? "true " : "false ");
     s += std::string("isGnuAttributeConstructor() = ")          + std::string(isGnuAttributeConstructor() ? "true " : "false ");
     s += std::string("isGnuAttributeDestructor() = ")           + std::string(isGnuAttributeDestructor() ? "true " : "false ");
     s += std::string("isGnuAttributePure() = ")                 + std::string(isGnuAttributePure() ? "true " : "false ");
     s += std::string("isGnuAttributeWeak() = ")                 + std::string(isGnuAttributeWeak() ? "true " : "false ");
     s += std::string("isGnuAttributeUnused() = ")               + std::string(isGnuAttributeUnused() ? "true " : "false ");
     s += std::string("isGnuAttributeUsed() = ")                 + std::string(isGnuAttributeUsed() ? "true " : "false ");
     s += std::string("isGnuAttributeDeprecated() = ")           + std::string(isGnuAttributeDeprecated() ? "true " : "false ");
     s += std::string("isGnuAttributeMalloc() = ")               + std::string(isGnuAttributeMalloc() ? "true " : "false ");
     s += std::string("isGnuAttributeNaked() = ")                + std::string(isGnuAttributeNaked() ? "true " : "false ");
     s += std::string("isGnuAttributeNoInstrumentFunction() = ") + std::string(isGnuAttributeNoInstrumentFunction() ? "true " : "false ");
     s += std::string("isGnuAttributeNoCheckMemoryUsage() = ")   + std::string(isGnuAttributeNoCheckMemoryUsage() ? "true " : "false ");
     s += std::string("isGnuAttributeNoInline() = ")             + std::string(isGnuAttributeNoInline() ? "true " : "false ");
     s += std::string("isGnuAttributeAlwaysInline() = ")         + std::string(isGnuAttributeAlwaysInline() ? "true " : "false ");
     s += std::string("isGnuAttributeNoThrow() = ")              + std::string(isGnuAttributeNoThrow() ? "true " : "false ");
     s += std::string("isGnuAttributeWeakReference() = ")        + std::string(isGnuAttributeWeakReference() ? "true " : "false ");

     s += std::string("isJavaNative() = ")       + std::string(isJavaNative()       ? "true " : "false ");
     s += std::string("isJavaSynchronized() = ") + std::string(isJavaSynchronized() ? "true " : "false ");
     s += std::string("isJavaStrictfp() = ")     + std::string(isJavaStrictfp()     ? "true " : "false ");
     s += std::string("isJavaInitializer() = ")  + std::string(isJavaInitializer()  ? "true " : "false ");
     s += ")";
     return s;
   }

void
SgFunctionModifier::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv ) 
   {
  // DQ (1/26/2006): Modified to handle 64 bit machines
  // for (unsigned int i=0; i < bv.size(); i++)
  // for (vector<bool>::size_type i=0; i < bv.size(); i++)
     for (unsigned int i=0; i < bv.size(); i++)
          os << ((bv[i] == true) ? "T" : "F");
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
	       (lhs.isUnknown() == rhs.isUnknown() ) &&
	       (lhs.isDefault() == rhs.isDefault() ) &&
	       (lhs.isInline()  == rhs.isInline()  ) &&
	       // C++ specific
	       (lhs.isVirtual()     == rhs.isVirtual()    ) &&
	       (lhs.isPureVirtual() == rhs.isPureVirtual()) &&
	       // Fortran specific
	       (lhs.isExplicit()  == rhs.isExplicit() ) &&
	       (lhs.isPure()      == rhs.isPure()     ) &&
	       (lhs.isElemental() == rhs.isElemental()) &&
	       (lhs.isRecursive() == rhs.isRecursive()) &&
	       (lhs.isReentrant() == rhs.isReentrant()) &&
	       // GNU specific
	       (lhs.isGnuAttributeConstructor() == rhs.isGnuAttributeConstructor()) &&
	       (lhs.isGnuAttributeDestructor()  == rhs.isGnuAttributeDestructor() ) &&
	       (lhs.isGnuAttributePure()        == rhs.isGnuAttributePure()       ) &&
	       (lhs.isGnuAttributeWeak()        == rhs.isGnuAttributeWeak()       ) &&
	       (lhs.isGnuAttributeUnused()      == rhs.isGnuAttributeUnused()     ) &&
	       (lhs.isGnuAttributeUsed()        == rhs.isGnuAttributeUsed()       ) &&
	       (lhs.isGnuAttributeDeprecated()  == rhs.isGnuAttributeDeprecated() ) &&
	       (lhs.isGnuAttributeMalloc()      == rhs.isGnuAttributeMalloc()     ) &&
	       (lhs.isGnuAttributeNaked()       == rhs.isGnuAttributeNaked()      ) &&
	       (lhs.isGnuAttributeNoInstrumentFunction() == rhs.isGnuAttributeNoInstrumentFunction()) &&
	       (lhs.isGnuAttributeNoCheckMemoryUsage() == rhs.isGnuAttributeNoCheckMemoryUsage()) &&
	       (lhs.isGnuAttributeNoInline()           == rhs.isGnuAttributeNoInline()          ) &&
	       (lhs.isGnuAttributeAlwaysInline()       == rhs.isGnuAttributeAlwaysInline()      ) &&
	       (lhs.isGnuAttributeNoThrow()            == rhs.isGnuAttributeNoThrow()           ) &&
	       (lhs.isGnuAttributeWeakReference()      == rhs.isGnuAttributeWeakReference()     ) &&
	       // Cuda specific
	       (lhs.isCudaDevice()         == rhs.isCudaDevice()) &&
	       (lhs.isCudaKernel()         == rhs.isCudaKernel()) &&
	       (lhs.isCudaHost()           == rhs.isCudaHost()  ) &&
	       (lhs.isCudaGlobalFunction() == rhs.isCudaGlobalFunction()) &&
	       (lhs.isCudaGridGlobal()     == rhs.isCudaGridGlobal()) &&
	       // OpenCL specific
	       (lhs.isOpenclKernel()             == rhs.isOpenclKernel()            ) &&
	       (lhs.hasOpenclVecTypeHint()       == rhs.hasOpenclVecTypeHint()      ) &&
	       (lhs.hasOpenclWorkGroupSizeHint() == rhs.hasOpenclWorkGroupSizeHint()) &&
	       (lhs.hasOpenclWorkGroupSizeReq()  == rhs.hasOpenclWorkGroupSizeReq() ) &&
	       (lhs.isJavaNative()               == rhs.isJavaNative()              ) &&
	       (lhs.isJavaSynchronized()         == rhs.isJavaSynchronized()        ) &&
	       (lhs.isJavaStrictfp()             == rhs.isJavaStrictfp()            ) &&
	       (lhs.isJavaInitializer()          == rhs.isJavaInitializer()         ) &&
		   true;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void SgFunctionModifier::reset()
   {
  // Unset each bit separately
     unsetUnknown();
     unsetInline();
     unsetVirtual();
     unsetPureVirtual();
     unsetExplicit();
  // unsetBind();
     unsetPure();

     unsetJavaNative();
     unsetJavaSynchronized();
     unsetJavaStrictfp();
     unsetJavaInitializer();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }
   
SOURCE_FUNCTION_MODIFIER_END

SOURCE_ADA_RANGE_CONSTRAINT_START
void SgAdaRangeConstraint::post_construction_initialization() {};

std::string SgAdaRangeConstraint::displayString() const
{
  ROSE_ASSERT(get_range());
  
  SgExpression* lb = get_range()->get_start();
  SgExpression* ub = get_range()->get_end();
  
  ROSE_ASSERT(lb && ub);
  
  std::string res(lb->unparseToString());
  
  res += "..";
  res += ub->unparseToString();
  
  return res;
}

void SgAdaRangeConstraint::display ( std::string label ) const
{
  mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
  mprintf ("%s \n",displayString().c_str());
}
              
          
std::ostream & operator<< ( std::ostream& os, const SgAdaRangeConstraint& c)
{
  return os << c.displayString();
}

SOURCE_ADA_RANGE_CONSTRAINT_END



SOURCE_UPS_ACCESS_MODIFIER_START
// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

// bool $CLASSNAME::isUPC_Shared() const { return p_modifier == e_upc_shared; }
// void $CLASSNAME::setUPC_Shared()      { p_modifier = e_upc_shared; }

bool $CLASSNAME::isUPC_Strict() const { return p_modifier == e_upc_strict; }
void $CLASSNAME::setUPC_Strict()      { p_modifier = e_upc_strict; }

bool $CLASSNAME::isUPC_Relaxed() const { return p_modifier == e_upc_relaxed; }
void $CLASSNAME::setUPC_Relaxed()      { p_modifier = e_upc_relaxed; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
  // s += std::string("isUPC_Shared() = ")  + std::string(isUPC_Shared()  ? "true " : "false ");
     s += std::string("isUPC_Strict() = ")  + std::string(isUPC_Strict()  ? "true " : "false ");
     s += std::string("isUPC_Relaxed() = ") + std::string(isUPC_Relaxed() ? "true " : "false ");

  // DQ (6/13/2008): Added support for layout and shared use with "strict" or "relaxed"
     s += std::string("get_isShared() = ")  + std::string(get_isShared() ? "true " : "false ");
     s += std::string("get_layout() = ")  + Rose::StringUtility::numberToString(get_layout());

     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgUPC_AccessModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()     == rhs.isUnknown()    ) &&
	       (lhs.isDefault()     == rhs.isDefault()    ) &&
	       (lhs.isUPC_Strict()  == rhs.isUPC_Strict() ) &&
	       (lhs.isUPC_Relaxed() == rhs.isUPC_Relaxed()) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_UPS_ACCESS_MODIFIER_END


SOURCE_SPECIAL_FUNCTION_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifierVector = X.p_modifierVector;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool $CLASSNAME::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void $CLASSNAME::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void $CLASSNAME::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool $CLASSNAME::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void $CLASSNAME::setDefault()       { setBit(e_default,p_modifierVector); }
void $CLASSNAME::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool $CLASSNAME::isNotSpecial() const  { return checkBit(e_none,p_modifierVector); }
void $CLASSNAME::setNotSpecial()       { setBit(e_none,p_modifierVector); }
void $CLASSNAME::unsetNotSpecial()     { unsetBit(e_none,p_modifierVector); }

bool $CLASSNAME::isConstructor() const { return checkBit(e_constructor,p_modifierVector); }
void $CLASSNAME::setConstructor()      { setBit(e_constructor,p_modifierVector); }
void $CLASSNAME::unsetConstructor()    { unsetBit(e_constructor,p_modifierVector); }

bool $CLASSNAME::isDestructor() const  { return checkBit(e_destructor,p_modifierVector); }
void $CLASSNAME::setDestructor()       { setBit(e_destructor,p_modifierVector); }
void $CLASSNAME::unsetDestructor()     { unsetBit(e_destructor,p_modifierVector); }

bool $CLASSNAME::isConversion() const  { return checkBit(e_conversion,p_modifierVector); }
void $CLASSNAME::setConversion()       { setBit(e_conversion,p_modifierVector); }
void $CLASSNAME::unsetConversion()     { unsetBit(e_conversion,p_modifierVector); }

bool $CLASSNAME::isOperator() const    { return checkBit(e_operator,p_modifierVector); }
void $CLASSNAME::setOperator()         { setBit(e_operator,p_modifierVector); }
void $CLASSNAME::unsetOperator()       { unsetBit(e_operator,p_modifierVector); }

bool $CLASSNAME::isUldOperator() const    { return checkBit(e_uld_operator,p_modifierVector); }
void $CLASSNAME::setUldOperator()         { setBit(e_uld_operator,p_modifierVector); }
void $CLASSNAME::unsetUldOperator()       { unsetBit(e_uld_operator,p_modifierVector); }

bool $CLASSNAME::isLambdaEntryPoint() const    { return checkBit(e_lambda_entry_point,p_modifierVector); }
void $CLASSNAME::setLambdaEntryPoint()         { setBit(e_lambda_entry_point,p_modifierVector); }
void $CLASSNAME::unsetLambdaEntryPoint()       { unsetBit(e_lambda_entry_point,p_modifierVector); }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")     + std::string(isUnknown()     ? "true " : "false ");
     s += std::string("isDefault() = ")     + std::string(isDefault()     ? "true " : "false ");
     s += std::string("isNotSpecial() = ")  + std::string(isNotSpecial()  ? "true " : "false ");
     s += std::string("isConstructor() = ") + std::string(isConstructor() ? "true " : "false ");
     s += std::string("isDestructor() = ")  + std::string(isDestructor()  ? "true " : "false ");
     s += std::string("isConversion() = ")  + std::string(isConversion()  ? "true " : "false ");
     s += std::string("isOperator() = ")    + std::string(isOperator()    ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgSpecialFunctionModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()     == rhs.isUnknown()    ) &&
	       (lhs.isDefault()     == rhs.isDefault()    ) &&
	       (lhs.isNotSpecial()  == rhs.isNotSpecial() ) &&
	       (lhs.isConstructor() == rhs.isConstructor()) &&
	       (lhs.isDestructor()  == rhs.isDestructor() ) &&
	       (lhs.isConversion()  == rhs.isConversion() ) &&
	       (lhs.isOperator()    == rhs.isOperator()   ) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetNotSpecial();
     unsetConstructor();
     unsetDestructor();
     unsetConversion();
     unsetOperator();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();
   }

SOURCE_SPECIAL_FUNCTION_MODIFIER_END

SOURCE_DECLARATION_MODIFIER_START

// Copy constructor
SgDeclarationModifier::SgDeclarationModifier ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
   }

SgDeclarationModifier &
SgDeclarationModifier::operator= ( const SgDeclarationModifier & X )
   {
     p_modifierVector  = X.p_modifierVector;
     p_typeModifier    = X.p_typeModifier;
     p_accessModifier  = X.p_accessModifier;
     p_storageModifier = X.p_storageModifier;
     return *this;
   }

void
SgDeclarationModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgDeclarationModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgDeclarationModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgDeclarationModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgDeclarationModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgDeclarationModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgDeclarationModifier::isFriend() const  { return checkBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::setFriend()       { setBit(e_friend,p_modifierVector); }
void SgDeclarationModifier::unsetFriend()     { unsetBit(e_friend,p_modifierVector); }

bool SgDeclarationModifier::isTypedef() const  { return checkBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::setTypedef()       { setBit(e_typedef,p_modifierVector); }
void SgDeclarationModifier::unsetTypedef()     { unsetBit(e_typedef,p_modifierVector); }

bool SgDeclarationModifier::isExport() const  { return checkBit(e_export,p_modifierVector); }
void SgDeclarationModifier::setExport()       { setBit(e_export,p_modifierVector); }
void SgDeclarationModifier::unsetExport()     { unsetBit(e_export,p_modifierVector); }

bool SgDeclarationModifier::isThrow() const  { return checkBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::setThrow()       { setBit(e_throw,p_modifierVector); }
void SgDeclarationModifier::unsetThrow()     { unsetBit(e_throw,p_modifierVector); }

bool SgDeclarationModifier::isBind() const { return checkBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::setBind()      { setBit(e_bind,p_modifierVector); }
void SgDeclarationModifier::unsetBind()    { unsetBit(e_bind,p_modifierVector); }

bool SgDeclarationModifier::isFinal() const { return checkBit(e_final,p_modifierVector); }
void SgDeclarationModifier::setFinal()      { setBit(e_final,p_modifierVector); }
void SgDeclarationModifier::unsetFinal()    { unsetBit(e_final,p_modifierVector); }

// DQ (8/11/2014): C++11 specific attribute
bool SgDeclarationModifier::isOverride() const { return checkBit(e_override,p_modifierVector); }
void SgDeclarationModifier::setOverride()      { setBit(e_override,p_modifierVector); }
void SgDeclarationModifier::unsetOverride()    { unsetBit(e_override,p_modifierVector); }

// DQ (8/11/2011): Added support for Java "abstract" declaration modifier.
bool SgDeclarationModifier::isJavaAbstract() const { return checkBit(e_java_abstract,p_modifierVector); }
void SgDeclarationModifier::setJavaAbstract()      { setBit(e_java_abstract,p_modifierVector); }
void SgDeclarationModifier::unsetJavaAbstract()    { unsetBit(e_java_abstract,p_modifierVector); }

// Rasmussen (2/26/2020): Added support for Jovial modifiers
bool SgDeclarationModifier::isJovialDef() const { return checkBit(e_jovial_def,p_modifierVector); }
void SgDeclarationModifier::setJovialDef()      { setBit(e_jovial_def,p_modifierVector); }
void SgDeclarationModifier::unsetJovialDef()    { unsetBit(e_jovial_def,p_modifierVector); }

bool SgDeclarationModifier::isJovialRef() const { return checkBit(e_jovial_ref,p_modifierVector); }
void SgDeclarationModifier::setJovialRef()      { setBit(e_jovial_ref,p_modifierVector); }
void SgDeclarationModifier::unsetJovialRef()    { unsetBit(e_jovial_ref,p_modifierVector); }

bool SgDeclarationModifier::isJovialStatic() const { return checkBit(e_jovial_static,p_modifierVector); }
void SgDeclarationModifier::setJovialStatic()      { setBit(e_jovial_static,p_modifierVector); }
void SgDeclarationModifier::unsetJovialStatic()    { unsetBit(e_jovial_static,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_align() const { return checkBit(e_ms_declspec_align,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_align()      { setBit(e_ms_declspec_align,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_align()    { unsetBit(e_ms_declspec_align,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_allocate() const { return checkBit(e_ms_declspec_allocate,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_allocate()      { setBit(e_ms_declspec_allocate,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_allocate()    { unsetBit(e_ms_declspec_allocate,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_appdomain() const { return checkBit(e_ms_declspec_appdomain,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_appdomain()      { setBit(e_ms_declspec_appdomain,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_appdomain()    { unsetBit(e_ms_declspec_appdomain,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_code_seg() const { return checkBit(e_ms_declspec_code_seg,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_code_seg()      { setBit(e_ms_declspec_code_seg,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_code_seg()    { unsetBit(e_ms_declspec_code_seg,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_deprecated() const { return checkBit(e_ms_declspec_deprecated,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_deprecated()      { setBit(e_ms_declspec_deprecated,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_deprecated()    { unsetBit(e_ms_declspec_deprecated,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_dllimport() const { return checkBit(e_ms_declspec_dllimport,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_dllimport()      { setBit(e_ms_declspec_dllimport,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_dllimport()    { unsetBit(e_ms_declspec_dllimport,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_dllexport() const { return checkBit(e_ms_declspec_dllexport,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_dllexport()      { setBit(e_ms_declspec_dllexport,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_dllexport()    { unsetBit(e_ms_declspec_dllexport,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_jitintrinsic() const { return checkBit(e_ms_declspec_jitintrinsic,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_jitintrinsic()      { setBit(e_ms_declspec_jitintrinsic,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_jitintrinsic()    { unsetBit(e_ms_declspec_jitintrinsic,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_naked() const { return checkBit(e_ms_declspec_naked,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_naked()      { setBit(e_ms_declspec_naked,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_naked()    { unsetBit(e_ms_declspec_naked,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noalias() const { return checkBit(e_ms_declspec_noalias,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noalias()      { setBit(e_ms_declspec_noalias,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noalias()    { unsetBit(e_ms_declspec_noalias,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noinline() const { return checkBit(e_ms_declspec_noinline,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noinline()      { setBit(e_ms_declspec_noinline,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noinline()    { unsetBit(e_ms_declspec_noinline,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_noreturn() const { return checkBit(e_ms_declspec_noreturn,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_noreturn()      { setBit(e_ms_declspec_noreturn,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_noreturn()    { unsetBit(e_ms_declspec_noreturn,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_nothrow() const { return checkBit(e_ms_declspec_nothrow,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_nothrow()      { setBit(e_ms_declspec_nothrow,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_nothrow()    { unsetBit(e_ms_declspec_nothrow,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_novtable() const { return checkBit(e_ms_declspec_novtable,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_novtable()      { setBit(e_ms_declspec_novtable,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_novtable()    { unsetBit(e_ms_declspec_novtable,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_process() const { return checkBit(e_ms_declspec_process,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_process()      { setBit(e_ms_declspec_process,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_process()    { unsetBit(e_ms_declspec_process,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_property() const { return checkBit(e_ms_declspec_property,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_property()      { setBit(e_ms_declspec_property,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_property()    { unsetBit(e_ms_declspec_property,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_restrict() const { return checkBit(e_ms_declspec_restrict,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_restrict()      { setBit(e_ms_declspec_restrict,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_restrict()    { unsetBit(e_ms_declspec_restrict,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_safebuffers() const { return checkBit(e_ms_declspec_safebuffers,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_safebuffers()      { setBit(e_ms_declspec_safebuffers,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_safebuffers()    { unsetBit(e_ms_declspec_safebuffers,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_selectany() const { return checkBit(e_ms_declspec_selectany,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_selectany()      { setBit(e_ms_declspec_selectany,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_selectany()    { unsetBit(e_ms_declspec_selectany,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_thread() const { return checkBit(e_ms_declspec_thread,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_thread()      { setBit(e_ms_declspec_thread,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_thread()    { unsetBit(e_ms_declspec_thread,p_modifierVector); }

// DQ (8/16/2014): Adding non-C++ standard Microsoft specific attributes.
bool SgDeclarationModifier::is_ms_declspec_uuid() const { return checkBit(e_ms_declspec_uuid,p_modifierVector); }
void SgDeclarationModifier::set_ms_declspec_uuid()      { setBit(e_ms_declspec_uuid,p_modifierVector); }
void SgDeclarationModifier::unset_ms_declspec_uuid()    { unsetBit(e_ms_declspec_uuid,p_modifierVector); }






string
SgDeclarationModifier::displayString() const
   {
     std::string s = "SgDeclarationModifier(";
     s += std::string("isUnknown() = ")      + std::string(isUnknown()      ? "true " : "false ");
     s += std::string("isDefault() = ")      + std::string(isDefault()      ? "true " : "false ");
     s += std::string("isFriend() = ")       + std::string(isFriend()       ? "true " : "false ");
     s += std::string("isTypedef() = ")      + std::string(isTypedef()      ? "true " : "false ");
     s += std::string("isExport() = ")       + std::string(isExport()       ? "true " : "false ");
     s += std::string("isThrow() = ")        + std::string(isThrow()        ? "true " : "false ");
     s += std::string("isBind() = ")         + std::string(isBind()         ? "true " : "false ");
     s += std::string("isFinal() = ")        + std::string(isFinal()        ? "true " : "false ");
     s += std::string("isJavaAbstract() = ") + std::string(isJavaAbstract() ? "true " : "false ");
     s += std::string("isJovialDef() = ")    + std::string(isJovialDef()    ? "true " : "false ");
     s += std::string("isJovialRef() = ")    + std::string(isJovialRef()    ? "true " : "false ");
     s += std::string("isJovialStatic() = ") + std::string(isJovialStatic() ? "true " : "false ");
     s += std::string("\n     ") + get_typeModifier().displayString()   + " ";
     s += std::string("\n     ") + get_accessModifier().displayString() + " ";
     s += std::string("\n     ") + get_storageModifier().displayString();
     s += ")";
     return s;
   }

void
SgDeclarationModifier::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgDeclarationModifier & m) 
   {
      os << m.get_modifierVector(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
          (lhs.get_typeModifier()    == rhs.get_typeModifier()   ) &&
          (lhs.get_accessModifier()  == rhs.get_accessModifier() ) &&
          (lhs.get_storageModifier() == rhs.get_storageModifier()) &&
	       (lhs.isUnknown()           == rhs.isUnknown()) &&
	       (lhs.isDefault()           == rhs.isDefault()) &&
	       (lhs.isFriend()            == rhs.isFriend() ) &&
	       (lhs.isTypedef()           == rhs.isTypedef()) &&
	       (lhs.isExport()            == rhs.isExport() ) &&
	       (lhs.isThrow()             == rhs.isThrow()  ) &&
	       (lhs.isBind()              == rhs.isBind()   ) &&
	       (lhs.isFinal()             == rhs.isFinal()  ) &&
	       (lhs.isJavaAbstract()      == rhs.isJavaAbstract() ) &&
	       (lhs.isJovialDef()         == rhs.isJovialDef() ) &&
	       (lhs.isJovialRef()         == rhs.isJovialRef() ) &&
	       (lhs.isJovialStatic()      == rhs.isJovialStatic() ) &&
          true;
   }

SgTypeModifier &
SgDeclarationModifier::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

SgAccessModifier &
SgDeclarationModifier::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

SgStorageModifier &
SgDeclarationModifier::get_storageModifier ()
   {
     assert (this != NULL);
     return p_storageModifier;
   }

const SgTypeModifier &
SgDeclarationModifier::get_typeModifier () const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

const SgAccessModifier &
SgDeclarationModifier::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgStorageModifier &
SgDeclarationModifier::get_storageModifier () const
   {
     assert (this != NULL);
     return p_storageModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void
SgDeclarationModifier::reset()
   {
     unsetUnknown();
     unsetFriend();
     unsetTypedef();
     unsetExport();
     unsetThrow();
     unsetBind();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_typeModifier().reset();
     get_accessModifier().reset();
     get_storageModifier().reset();
   }

SOURCE_DECLARATION_MODIFIER_END

SOURCE_TYPE_MODIFIER_START

// Copy constructor
SgTypeModifier::SgTypeModifier ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
   }

SgTypeModifier &
SgTypeModifier::operator= ( const SgTypeModifier & X )
   {
     p_modifierVector         = X.p_modifierVector;
     p_constVolatileModifier  = X.p_constVolatileModifier;
     p_upcModifier            = X.p_upcModifier;
     p_elaboratedTypeModifier = X.p_elaboratedTypeModifier;
     return *this;
   }

void
SgTypeModifier::post_construction_initialization()
   {
     p_modifierVector = SgBitVector(e_last_modifier,false);
     setDefault();
   }

bool SgTypeModifier::isUnknown() const  { return checkBit(e_unknown,p_modifierVector); }
void SgTypeModifier::setUnknown()       { setBit(e_unknown,p_modifierVector); }
void SgTypeModifier::unsetUnknown()     { unsetBit(e_unknown,p_modifierVector); }

bool SgTypeModifier::isDefault() const  { return checkBit(e_default,p_modifierVector); }
void SgTypeModifier::setDefault()       { setBit(e_default,p_modifierVector); }
void SgTypeModifier::unsetDefault()     { unsetBit(e_default,p_modifierVector); }

bool SgTypeModifier::isRestrict() const { return checkBit(e_restrict,p_modifierVector); }
void SgTypeModifier::setRestrict()      { setBit(e_restrict,p_modifierVector); }
void SgTypeModifier::unsetRestrict()    { unsetBit(e_restrict,p_modifierVector); }

#if 0
               e_allocatable    = 3, /*!< allocatable attribute specifier (for Fortran 90) */
               e_asynchronous   = 4, /*!< asynchronous attribute specifier (for Fortran 2003) */
               e_bind           = 5, /*!< bind attribute specifier (for Fortran 2003, this is closely related to the SgLinkageModifier) */
               e_data           = 6, /*!< data attribute specifier (for Fortran 77) */
               e_dimension      = 7, /*!< dimension attribute specifier (for Fortran 77) */
            // This should map to the C/C++ extern modifier in SgStorageModifier
            // e_external       = x, /*!< external attribute specifier (for Fortran 77, this is less related to the SgLinkageModifier than the SgStorageModifier) */
               e_intent_in      = 8, /*!< intent(in) attribute specifier (for Fortran 90) */
               e_intent_out     = 9, /*!< intent(out) attribute specifier (for Fortran 90) */
               e_intent_inout   = 10,/*!< intent(inout) attribute specifier (for Fortran 90) */
               e_intrinsic      = 11,/*!< intrinsic attribute specifier (for Fortran 90) */
               e_optional       = 12,/*!< optional attribute specifier (for Fortran 90) */
            // This should map to const in the SgConstVolatileModifier
            // e_parameter      = xx,/*!< parameter attribute specifier (for Fortran 77) */

            // This should be mapped to the SgPointerType in C/C++
            // e_pointer        = xx,/*!< pointer attribute specifier (for Fortran 90) */
            // Note that protected access attribute is mapped to the C/C++ protected access modifiers in SgDeclarationModifier
            // e_protected      = xx,/*!< protected attribute specifier (for Fortran 2003) */
               e_save           = 13,/*!< save attribute specifier (for Fortran 77) */
               e_target         = 14,/*!< target attribute specifier (for Fortran 90) */
               e_value          = 15,/*!< value attribute specifier (for Fortran 2003) */
#endif

// Fortran specific attribute
bool SgTypeModifier::isAllocatable() const  { return checkBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::setAllocatable()       { setBit(e_allocatable,p_modifierVector); }
void SgTypeModifier::unsetAllocatable()     { unsetBit(e_allocatable,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAsynchronous() const  { return checkBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::setAsynchronous()       { setBit(e_asynchronous,p_modifierVector); }
void SgTypeModifier::unsetAsynchronous()     { unsetBit(e_asynchronous,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isBind() const  { return checkBit(e_bind,p_modifierVector); }
void SgTypeModifier::setBind()       { setBit(e_bind,p_modifierVector); }
void SgTypeModifier::unsetBind()     { unsetBit(e_bind,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isData() const  { return checkBit(e_data,p_modifierVector); }
void SgTypeModifier::setData()       { setBit(e_data,p_modifierVector); }
void SgTypeModifier::unsetData()     { unsetBit(e_data,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isDimension() const  { return checkBit(e_dimension,p_modifierVector); }
void SgTypeModifier::setDimension()       { setBit(e_dimension,p_modifierVector); }
void SgTypeModifier::unsetDimension()     { unsetBit(e_dimension,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_in() const  { return checkBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::setIntent_in()       { setBit(e_intent_in,p_modifierVector); }
void SgTypeModifier::unsetIntent_in()     { unsetBit(e_intent_in,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_out() const  { return checkBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::setIntent_out()       { setBit(e_intent_out,p_modifierVector); }
void SgTypeModifier::unsetIntent_out()     { unsetBit(e_intent_out,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntent_inout() const  { return checkBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::setIntent_inout()       { setBit(e_intent_inout,p_modifierVector); }
void SgTypeModifier::unsetIntent_inout()     { unsetBit(e_intent_inout,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isIntrinsic() const  { return checkBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::setIntrinsic()       { setBit(e_intrinsic,p_modifierVector); }
void SgTypeModifier::unsetIntrinsic()     { unsetBit(e_intrinsic,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isOptional() const  { return checkBit(e_optional,p_modifierVector); }
void SgTypeModifier::setOptional()       { setBit(e_optional,p_modifierVector); }
void SgTypeModifier::unsetOptional()     { unsetBit(e_optional,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isSave() const  { return checkBit(e_save,p_modifierVector); }
void SgTypeModifier::setSave()       { setBit(e_save,p_modifierVector); }
void SgTypeModifier::unsetSave()     { unsetBit(e_save,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isTarget() const  { return checkBit(e_target,p_modifierVector); }
void SgTypeModifier::setTarget()       { setBit(e_target,p_modifierVector); }
void SgTypeModifier::unsetTarget()     { unsetBit(e_target,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isValue() const  { return checkBit(e_value,p_modifierVector); }
void SgTypeModifier::setValue()       { setBit(e_value,p_modifierVector); }
void SgTypeModifier::unsetValue()     { unsetBit(e_value,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isExtends() const  { return checkBit(e_extends,p_modifierVector); }
void SgTypeModifier::setExtends()       { setBit(e_extends,p_modifierVector); }
void SgTypeModifier::unsetExtends()     { unsetBit(e_extends,p_modifierVector); }

// Fortran specific attribute
bool SgTypeModifier::isAbstract() const  { return checkBit(e_abstract,p_modifierVector); }
void SgTypeModifier::setAbstract()       { setBit(e_abstract,p_modifierVector); }
void SgTypeModifier::unsetAbstract()     { unsetBit(e_abstract,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeUnused() const  { return checkBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeUnused()       { setBit(e_gnu_attribute__unused__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeUnused()     { unsetBit(e_gnu_attribute__unused__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributePacked() const  { return checkBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::setGnuAttributePacked()       { setBit(e_gnu_attribute__packed__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributePacked()     { unsetBit(e_gnu_attribute__packed__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeDeprecated() const  { return checkBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeDeprecated()       { setBit(e_gnu_attribute__deprecated__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeDeprecated()     { unsetBit(e_gnu_attribute__deprecated__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeTransparentUnion() const  { return checkBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeTransparentUnion()       { setBit(e_gnu_attribute__transparent_union__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeTransparentUnion()     { unsetBit(e_gnu_attribute__transparent_union__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNoReturn() const  { return checkBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNoReturn()       { setBit(e_gnu_attribute__noreturn__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNoReturn()     { unsetBit(e_gnu_attribute__noreturn__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeConst() const  { return checkBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeConst()       { setBit(e_gnu_attribute__const__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeConst()     { unsetBit(e_gnu_attribute__const__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeCdecl() const  { return checkBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeCdecl()       { setBit(e_gnu_attribute__cdecl__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeCdecl()     { unsetBit(e_gnu_attribute__cdecl__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeStdcall() const  { return checkBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeStdcall()       { setBit(e_gnu_attribute__stdcall__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeStdcall()     { unsetBit(e_gnu_attribute__stdcall__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeWarnUnusedResult() const  { return checkBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeWarnUnusedResult()       { setBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeWarnUnusedResult()     { unsetBit(e_gnu_attribute__warn_unused_result__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeNonnull() const  { return checkBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeNonnull()       { setBit(e_gnu_attribute__nonnull__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeNonnull()     { unsetBit(e_gnu_attribute__nonnull__,p_modifierVector); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgTypeModifier::isGnuAttributeSentinel() const  { return checkBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeSentinel()       { setBit(e_gnu_attribute__sentinel__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeSentinel()     { unsetBit(e_gnu_attribute__sentinel__,p_modifierVector); }

bool SgTypeModifier::haveAddressSpace() const { return checkBit(e_address_space__,p_modifierVector); }
void SgTypeModifier::setAddressSpace()        { setBit(e_address_space__,p_modifierVector); }
void SgTypeModifier::unsetAddressSpace()      { unsetBit(e_address_space__,p_modifierVector); }

bool SgTypeModifier::isOpenclGlobal() const { return checkBit(e_ocl_global__,p_modifierVector); }
void SgTypeModifier::setOpenclGlobal()      { setBit(e_ocl_global__,p_modifierVector); }
void SgTypeModifier::unsetOpenclGlobal()    { unsetBit(e_ocl_global__,p_modifierVector); }

bool SgTypeModifier::isOpenclLocal() const { return checkBit(e_ocl_local__,p_modifierVector); }
void SgTypeModifier::setOpenclLocal()      { setBit(e_ocl_local__,p_modifierVector); }
void SgTypeModifier::unsetOpenclLocal()    { unsetBit(e_ocl_local__,p_modifierVector); }

bool SgTypeModifier::isOpenclConstant() const { return checkBit(e_ocl_constant__,p_modifierVector); }
void SgTypeModifier::setOpenclConstant()      { setBit(e_ocl_constant__,p_modifierVector); }
void SgTypeModifier::unsetOpenclConstant()    { unsetBit(e_ocl_constant__,p_modifierVector); }

bool SgTypeModifier::isVectorType() const { return checkBit(e_vector_type__,p_modifierVector); }
void SgTypeModifier::setVectorType()      { setBit(e_vector_type__,p_modifierVector); }
void SgTypeModifier::unsetVectorType()    { unsetBit(e_vector_type__,p_modifierVector); }

// DQ (1/24/2016): Added GNU specific attributes for custom specification of CUDA device in function parameter types.
bool SgTypeModifier::isGnuAttributeDevice() const  { return checkBit(e_gnu_attribute__device__,p_modifierVector); }
void SgTypeModifier::setGnuAttributeDevice()       { setBit(e_gnu_attribute__device__,p_modifierVector); }
void SgTypeModifier::unsetGnuAttributeDevice()     { unsetBit(e_gnu_attribute__device__,p_modifierVector); }

// Rasmussen (3/1/2020): numeric type specifiers for Jovial
bool SgTypeModifier::isRound() const  { return checkBit(e_round,p_modifierVector); }
void SgTypeModifier::setRound()       { setBit(e_round,p_modifierVector); }
void SgTypeModifier::unsetRound()     { unsetBit(e_round,p_modifierVector); }

bool SgTypeModifier::isTruncate() const  { return checkBit(e_truncate,p_modifierVector); }
void SgTypeModifier::setTruncate()       { setBit(e_truncate,p_modifierVector); }
void SgTypeModifier::unsetTruncate()     { unsetBit(e_truncate,p_modifierVector); }

bool SgTypeModifier::isTruncateTowardsZero() const  { return checkBit(e_truncate_towards_zero,p_modifierVector); }
void SgTypeModifier::setTruncateTowardsZero()       { setBit(e_truncate_towards_zero,p_modifierVector); }
void SgTypeModifier::unsetTruncateTowardsZero()     { unsetBit(e_truncate_towards_zero,p_modifierVector); }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")                + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")                + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isRestrict() = ")               + std::string(isRestrict() ? "true " : "false ");
     s += std::string("gnu_extension_machine_mode = ") + Rose::StringUtility::numberToString((int)p_gnu_extension_machine_mode) + " ";
     s += std::string("gnu_attribute_alignment = ")    + Rose::StringUtility::numberToString((int)p_gnu_attribute_alignment)    + " ";
     s += std::string("gnu_attribute_sentinel = ")     + Rose::StringUtility::numberToString((int)p_gnu_attribute_sentinel)     + " ";
     s += std::string("address_space_value = ")        + Rose::StringUtility::numberToString((int)p_address_space_value)        + " ";
     s += std::string("vector_size = ")                + Rose::StringUtility::numberToString((int)p_vector_size)                + " ";
#if 0
     s += std::string("\n     ")                       + get_constVolatileModifier().displayString()                      + " ";
     s += std::string("\n     ")                       + get_upcModifier().displayString()                                + " ";
     s += std::string("\n     ")                       + get_elaboratedTypeModifier().displayString();
#else
     s += std::string("   ")                           + get_constVolatileModifier().displayString()                      + " ";
     s += std::string("   ")                           + get_upcModifier().displayString()                                + " ";
     s += std::string("   ")                           + get_elaboratedTypeModifier().displayString();
#endif
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream& operator<< (std::ostream& os, const SgTypeModifier& tm) 
   {
      os << tm.get_modifierVector(); 
     return os;
   }

// DQ (11/28/2015): We need a better way to support wrappers of types that are significant and not significant.
bool SgTypeModifier::isIdentity() const
   {
  // When this is true, the SgTypeModifier acts as a simple wrapper to a base type that is equivalent.
     bool identity = false;

#if 0
     mprintf ("In SgTypeModifier::isIdentity(): this = %p get_constVolatileModifier().isConst() = %s \n",this,get_constVolatileModifier().isConst() ? "true" : "false");
#endif

  // This needs to be an expanded set of fields later.
     identity = (get_constVolatileModifier().isConst() == false) && (get_constVolatileModifier().isVolatile() == false) && (isRestrict() == false);

#if 0
     mprintf ("In SgTypeModifier::isIdentity(): return identity = %s \n",identity ? "true" : "false");
#endif

     return identity;
   }


bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
   {
     return
          (lhs.get_upcModifier()            == rhs.get_upcModifier()           ) &&
          (lhs.get_constVolatileModifier()  == rhs.get_constVolatileModifier() ) &&
          (lhs.get_elaboratedTypeModifier() == rhs.get_elaboratedTypeModifier()) &&
          (lhs.isUnknown() == rhs.isUnknown()) &&
          (lhs.isDefault() == rhs.isDefault()) &&
       // C specific
          (lhs.isRestrict() == rhs.isRestrict()) &&
       // Fortran specific
          (lhs.isAllocatable()  == rhs.isAllocatable() ) &&
          (lhs.isBind()         == rhs.isBind()        ) &&
          (lhs.isAsynchronous() == rhs.isAsynchronous()) &&
          (lhs.isData()         == rhs.isData()        ) &&
          (lhs.isDimension()    == rhs.isDimension()   ) &&
          (lhs.isIntent_in()    == rhs.isIntent_in()   ) &&
          (lhs.isIntent_out()   == rhs.isIntent_out()  ) &&
          (lhs.isIntent_inout() == rhs.isIntent_inout()) &&
          (lhs.isIntrinsic()    == rhs.isIntrinsic()   ) &&
          (lhs.isOptional()     == rhs.isOptional()    ) &&
          (lhs.isSave()         == rhs.isSave()        ) &&
          (lhs.isTarget()       == rhs.isTarget()      ) &&
          (lhs.isValue()        == rhs.isValue()       ) &&
       // GNU specific
          (lhs.isGnuAttributeUnused()           == rhs.isGnuAttributeUnused()          ) &&
          (lhs.isGnuAttributePacked()           == rhs.isGnuAttributePacked()          ) &&
          (lhs.isGnuAttributeDeprecated()       == rhs.isGnuAttributeDeprecated()      ) &&
          (lhs.isGnuAttributeTransparentUnion() == rhs.isGnuAttributeTransparentUnion()) &&
          (lhs.isGnuAttributeNoReturn()         == rhs.isGnuAttributeNoReturn()        ) &&
          (lhs.isGnuAttributeConst()            == rhs.isGnuAttributeConst()           ) &&
          (lhs.isGnuAttributeCdecl()            == rhs.isGnuAttributeCdecl()           ) &&
          (lhs.isGnuAttributeStdcall()          == rhs.isGnuAttributeStdcall()         ) &&
          (lhs.isGnuAttributeWarnUnusedResult() == rhs.isGnuAttributeWarnUnusedResult()) &&
          (lhs.isGnuAttributeNonnull()          == rhs.isGnuAttributeNonnull()         ) &&
          (lhs.isGnuAttributeSentinel()         == rhs.isGnuAttributeSentinel()        ) &&
       // Address Space
          (lhs.haveAddressSpace()        == rhs.haveAddressSpace()        ) &&
          (lhs.get_address_space_value() == rhs.get_address_space_value() ) &&
       // OpenCL specific
          (lhs.isOpenclGlobal()   == rhs.isOpenclGlobal()    ) &&
          (lhs.isOpenclLocal()    == rhs.isOpenclLocal()    ) &&
          (lhs.isOpenclConstant() == rhs.isOpenclConstant() ) &&
       // Vector Type
          (lhs.isVectorType()    == rhs.isVectorType()    ) &&
          (lhs.get_vector_size() == rhs.get_vector_size() ) &&
          true;
   }

SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier ()
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier ()
   {
     assert (this != NULL);
     return p_upcModifier;
   }

SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier ()
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     unsetUnknown();
     unsetRestrict();

  // Set this bit to indicate the default value (we want a value of all zero bits to be an error)
     setDefault();

     get_constVolatileModifier().reset();
     get_upcModifier().reset();
     get_elaboratedTypeModifier().reset();
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgConstVolatileModifier &
$CLASSNAME::get_constVolatileModifier (void) const
   {
     assert (this != NULL);
     return p_constVolatileModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgUPC_AccessModifier &
$CLASSNAME::get_upcModifier (void) const
   {
     assert (this != NULL);
     return p_upcModifier;
   }

// RV (2/2/2006): Created this 'const' version of the member function.
const SgElaboratedTypeModifier &
$CLASSNAME::get_elaboratedTypeModifier (void) const
   {
     assert (this != NULL);
     return p_elaboratedTypeModifier;
   }

SOURCE_TYPE_MODIFIER_END


SOURCE_ELABORATED_TYPE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isClass() const { return p_modifier == e_class; }
void $CLASSNAME::setClass()      { p_modifier = e_class; }

bool $CLASSNAME::isStruct() const { return p_modifier == e_struct; }
void $CLASSNAME::setStruct()      { p_modifier = e_struct; }

bool $CLASSNAME::isUnion() const { return p_modifier == e_union; }
void $CLASSNAME::setUnion()      { p_modifier = e_union; }

bool $CLASSNAME::isEnum() const { return p_modifier == e_enum; }
void $CLASSNAME::setEnum()      { p_modifier = e_enum; }

bool $CLASSNAME::isTypename() const { return p_modifier == e_typename; }
void $CLASSNAME::setTypename()      { p_modifier = e_typename; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")  + std::string(isUnknown()  ? "true " : "false ");
     s += std::string("isDefault() = ")  + std::string(isDefault()  ? "true " : "false ");
     s += std::string("isClass() = ")    + std::string(isClass()    ? "true " : "false ");
     s += std::string("isStruct() = ")   + std::string(isStruct()   ? "true " : "false ");
     s += std::string("isUnion() = ")    + std::string(isUnion()    ? "true " : "false ");
     s += std::string("isEnum() = ")     + std::string(isEnum()     ? "true " : "false ");
     s += std::string("isTypename() = ") + std::string(isTypename() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgElaboratedTypeModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()  == rhs.isUnknown() ) &&
	       (lhs.isDefault()  == rhs.isDefault() ) &&
	       (lhs.isClass()    == rhs.isClass()   ) &&
	       (lhs.isStruct()   == rhs.isStruct()  ) &&
	       (lhs.isUnion()    == rhs.isUnion()   ) &&
	       (lhs.isEnum()     == rhs.isEnum()    ) &&
	       (lhs.isTypename() == rhs.isTypename()) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_ELABORATED_TYPE_MODIFIER_END

SOURCE_LINKAGE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isC_Linkage() const { return p_modifier == e_C_linkage; }
void $CLASSNAME::setC_Linkage()      { p_modifier = e_C_linkage; }

bool $CLASSNAME::isCppLinkage() const { return p_modifier == e_Cpp_linkage; }
void $CLASSNAME::setCppLinkage()      { p_modifier = e_Cpp_linkage; }

bool $CLASSNAME::isFortranLinkage() const { return p_modifier == e_fortran_linkage; }
void $CLASSNAME::setFortranLinkage()      { p_modifier = e_fortran_linkage; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")        + std::string(isUnknown()        ? "true " : "false ");
     s += std::string("isDefault() = ")        + std::string(isDefault()        ? "true " : "false ");
     s += std::string("isC_Linkage() = ")      + std::string(isC_Linkage()      ? "true " : "false ");
     s += std::string("isCppLinkage() = ")     + std::string(isCppLinkage()     ? "true " : "false ");
     s += std::string("isFortranLinkage() = ") + std::string(isFortranLinkage() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgLinkageModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.isUnknown()        == rhs.isUnknown()       ) &&
	       (lhs.isDefault()        == rhs.isDefault()       ) &&
	       (lhs.isC_Linkage()      == rhs.isC_Linkage()     ) &&
	       (lhs.isCppLinkage()     == rhs.isCppLinkage()    ) &&
	       (lhs.isFortranLinkage() == rhs.isFortranLinkage()) &&
		   true;
}

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
   }

SOURCE_LINKAGE_MODIFIER_END

SOURCE_BASECLASS_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier       = X.p_modifier;
     p_accessModifier = X.p_accessModifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isVirtual() const { return p_modifier == e_virtual; }
void $CLASSNAME::setVirtual()      { p_modifier = e_virtual; }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ") + std::string(isUnknown() ? "true " : "false ");
     s += std::string("isDefault() = ") + std::string(isDefault() ? "true " : "false ");
     s += std::string("isVirtual() = ") + std::string(isVirtual() ? "true " : "false ");
     s += std::string("\n     ") + get_accessModifier().displayString();
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }

std::ostream & operator<< ( std::ostream & os, const SgBaseClassModifier & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

bool operator== (const $CLASSNAME& lhs, const $CLASSNAME& rhs)
{
	return
	       (lhs.get_accessModifier() == rhs.get_accessModifier()) &&
	       (lhs.isUnknown() == rhs.isUnknown()) &&
	       (lhs.isDefault() == rhs.isDefault()) &&
	       (lhs.isVirtual() == rhs.isVirtual()) &&
		   true;
}

SgAccessModifier &
$CLASSNAME::get_accessModifier ()
   {
     assert (this != NULL);
     return p_accessModifier;
   }

const SgAccessModifier &
$CLASSNAME::get_accessModifier () const
   {
     assert (this != NULL);
     return p_accessModifier;
   }

// DQ (2/4/2006): Added mechamism to clear all bits
void $CLASSNAME::reset()
   {
     setDefault();
     get_accessModifier().reset();
   }

SOURCE_BASECLASS_MODIFIER_END






HEADER_SYMBOL_TABLE_PREDECLARATION_START

std::ostream & operator<< ( std::ostream & os, const std::vector<bool> & bv );

// forward class declaration to support case sensitive/insensitive symbol tables.
class rose_hash_multimap;

/*! \brief Name equality operator support for symbol tables within ROSE.
 */
struct eqstr
   {
  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     const rose_hash_multimap* hash_multimap;

  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     eqstr(const rose_hash_multimap* p) : hash_multimap(p) {}

  // The definition of this function requires the reference to the member function 
  // rose_hash_multimap::get_case_insensitive_semantics() so it must be seen after 
  // the rose_hash_multimap class definition.
     bool operator()(const SgName & s1, const SgName & s2) const;
   };

/*! \brief Hash name support for symbol tables within ROSE.
 */
struct hash_Name
   {
  // DQ (12/22/2005): Added constructor to support case insensitive name semantics
     const rose_hash_multimap* hash_multimap;

  // CH (4/8/2010): Use boost::unordered instead     
  // CH (4/13/2010): Use boost::hash<string> instead  
  // rose_hash::hash<const char*> hasher;
     rose_hash::hash<std::string> hasher;

     public:
       // DQ (12/22/2005): Added constructor to support case insensitive name semantics
          hash_Name(const rose_hash_multimap* p) : hash_multimap(p) {}

       // The definition of this function requires the reference to the member function 
       // rose_hash_multimap::get_case_insensitive_semantics() so it must be seen after 
       // the rose_hash_multimap class definition.
          size_t operator()(const SgName & name) const;
   };

/*! \brief Hash table support for symbol tables within ROSE.

       This hash table support is used by the symbol tables within ROSE.  There is one global
    symbol table for all function symbols and then there symbol tables for each scope 
    (implemented in the SgScopeDeclaration).

    \internal Trivia: The first version was developed by Alin Jula, and as payment I bought him dinner 
                      when Ken Kennedy visited LLNL (summer of 2005).

 */

// tps (11/19/2009) : Constructor of hash_multimap in MSVS is different
// CH (4/8/2010): Use boost::unordered instead

class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>
   {
     protected:
          SgNode * parent;
          bool case_insensitive_semantics;

     public:
       // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
#if 0
       // DQ (11/27/2010): Older version of code before adding support for case insensitive behavior.
          rose_hash_multimap(bool case_insensitive_semantics = false)
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(), parent(NULL)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(boost::unordered_detail::default_bucket_count,hash_Name(),eqstr(case_insensitive_semantics)), parent(NULL)
             {}

         rose_hash_multimap(int sz, bool case_insensitive_semantics = false)
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz), parent(NULL)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz,hash_Name(),eqstr(case_insensitive_semantics)), parent(NULL)
             {}

          rose_hash_multimap(const rose_hash_multimap & rhs)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(/*(rose_hash_multimap)*/rhs), parent(rhs.parent)
             {}
#else
       // DQ (11/27/2010): Newer version of code after adding support for case insensitive behavior.
          rose_hash_multimap()
          // : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(boost::unordered_detail::default_bucket_count,hash_Name(this),eqstr(this)), parent(NULL), case_insensitive_semantics(false)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(17,hash_Name(this),eqstr(this)), parent(NULL), case_insensitive_semantics(false)
             {}

         rose_hash_multimap(int sz)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(sz,hash_Name(this),eqstr(this)), parent(NULL), case_insensitive_semantics(false)
             {}

          rose_hash_multimap(const rose_hash_multimap & rhs)
             : rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>(/*(rose_hash_multimap)*/rhs), parent(rhs.parent), case_insensitive_semantics(rhs.case_insensitive_semantics)
             {}
#endif
          void set_parent(SgNode * new_parent) 
             {
               parent = new_parent;
             }

          SgNode* get_parent() const
             {
               return parent;
             }

       // DQ (11/28/2010): Added support to set/unset case sensitivity in symbol table handling.
          void set_case_insensitive_semantics(bool b) 
             {
               case_insensitive_semantics = b;
             }

       // DQ (11/28/2010): Added support to set/unset case sensitivity in symbol table handling.
          bool get_case_insensitive_semantics() const
             {
               return case_insensitive_semantics;
             }

          void delete_elements()
             {
#if 0
            // DQ (2/19/2007): I am not sure why this is commented out (has been since it was introduced summer of 2005)
               hash_multimap<SgName, SgSymbol*, hash_Name, eqstr>::iterator it;
               for (it = begin(); it != end(); ++it)
                  {
                    delete (*it).second;
                    (*it).second = NULL;
                  }
#endif
             }

         ~rose_hash_multimap()
             {
               delete_elements();

            // DQ (12/22/2005): Added initialization of parent pointer as suggested by Jochen
               parent = NULL;
             }

     // JH (01/01/2006) friend class declarations to get direct access to data member for the ast file IO
        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_hash_multimap*>;
   };


std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it );

HEADER_SYMBOL_TABLE_PREDECLARATION_END


HEADER_SYMBOL_TABLE_START

       // AJ (10/21/2004): Added support STL based implementation of hash table.
       // I have replaced the p_table in the SgSymbolTable from a SgSymbolHashMultimap 
       // to the STL hash_multimap<SgName,SgSymbol*,..>. The hash function for SgName 
       // uses the native STL hash function for char* . The methods of SgSymbolTable 
       // were adjusted (where necessary) to accomodate the STL hash_multimap table. 
       // What we have now is the old interaface of SgSymbolTable working with STL 
       // hash_multimap AND the STL interaface through the hash_multimap table.

       // DQ (1/30/2007): Added many member functions back into ROSE, now that we both 
       // better appriciate why they are required and we are overhaling the symbol 
       // table interface generally.
       // Comment from 9/7/2006):
       // Many member functions were removed because they are (with few exceptions, 
       // where they have been recently restored) infreqently used and too 
       // much funcionality to support robustly.  Now that we use STL internally
       // and we make the STL hash map available, users have all possible access.

       // typedefs to STL container used internally
          typedef rose_hash_multimap BaseHashType;
          typedef BaseHashType::iterator hash_iterator;

       // Default constructor (builds the hash table using a default size: 17 typically)
          SgSymbolTable();

       //! Added to support scopes that have more symbols (e.g. SgGlobal, and the function type table)
          SgSymbolTable(int sz);

       // Destructors are automatically generated by ROSETTA and so should not be explicitly represented
       // ~SgSymbolTable();

       // General function used to build AST
          void insert ( const SgName & name, SgSymbol *sp );

#if 1
       // DQ (11/27/2010): Changing the return type to "bool"
       // DQ (1/31/2007): Depricated (is not well named and should return bool)
       // int  find   ( const SgName & name, SgSymbol *sp, bool case_insensitive = false ) ROSE_DEPRECATED_FUNCTION;
          bool find   ( const SgName & name, SgSymbol *sp ) ROSE_DEPRECATED_FUNCTION;
#endif

       // DQ (1/31/2007): New functions that will replace the depricated find() member function
       // Note that this is log n in complexity
          bool exists ( const SgName &, SgSymbol *sp ) const; //! Complexity O(log n), checks for existence of symbol before matching against names.

       // DQ (1/31/2007): This is log n in complexity
          bool exists ( const SgName & name) const;               //! Complexity O(log n)

       // DQ (1/31/2007): This is linear in complexity (expensive)
          bool exists ( const SgSymbol *sp ) const;           //! Complexity O(n)

       // DQ (2/6/2007): find functions that take the declarations that are internally associated with SgSymbol IR nodes.
          SgSymbol* find( const SgInitializedName* initializedName); //! Complexity O(n)
          SgSymbol* find( const SgFunctionType* functionType);       //! Complexity O(n)
          SgSymbol* find( const SgStatement* statement);             //! Complexity O(n)

       // DQ (1/30/2007): Added general remove function for an explicitly identified SgSymbol
          void remove ( const SgSymbol* symbol );  //! Complexity O(log n)

       // DQ (1/30/2007): Added general remove functions for all SgSymbol IR nodes.
       // This function will remove all symbols with the specified name (even ones of
       // different types, see rest of comment).
       // This function is a bit dangerous except for function types since only for the 
       // function type table are the names unique.  For non-function type symbol 
       // tables classes and typedefs can have the same name (e.g. "typedef struct X {} X;")
       // so removing the name might have unexpected results!
          void remove_function_type ( const SgName & name); //! Complexity O(log n)

#if 0
       // DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
       // This removes all the symbols matching the name or name and type of symbol
       // These can be dangerous where there are the names in the symbol table are 
       // not unique and especially when using multiple un-names declarations of 
       // the same type or symbol.
          void remove_function      ( const SgName & );
          void remove_class         ( const SgName & );
          void remove_enum          ( const SgName & );
          void remove_typedef       ( const SgName & );
          void remove_label         ( const SgName & );
          void remove_var           ( const SgName & );
          void remove_enum_field    ( const SgName & );
          void remove_function_type ( const SgName & );
          void remove_namespace     ( const SgName & );
#endif

#if 0
       // DQ (11/27/2010): Removing these to avoid updating them to have consistant case handling support (deprecated 4-5 years ago).

       // Used by SgScopeStatement::lookup_symbol(const SgName& n)
          SgSymbol* findany(const SgName &) ROSE_DEPRECATED_FUNCTION;

       // Used only for global function type table
          SgFunctionTypeSymbol* findfunctype(const SgName&) ROSE_DEPRECATED_FUNCTION;

       // Used by Qing's AST Interface code
          SgVariableSymbol*  findvar(const SgName &) ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     findclass(const SgName &) ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfunc(const SgName&) ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfunc(const SgName&, const SgType*) ROSE_DEPRECATED_FUNCTION;
#endif

       // DQ (1/30/2007): New interface member functions using name.
       // These function search first against the name and then iteratively continue through 
       // the internal STL container to look for an entry that match the name and the type of
       // the SgSymbol.  This is optimially fast only for the case where there are unique names.
       // SgSymbol* find_any(const SgName & name);                   //! Complexity O(log n) for first match against name, then O(n)
          SgSymbol* find_any(const SgName & name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList); //! Complexity O(log n) for first match against name, then O(n)

          SgVariableSymbol*  find_variable(const SgName & name);               //! Complexity O(log n) for first match against name, then O(n)

// #ifndef ROSE_USE_SWIG_SUPPORT
#ifndef SWIG
       // DQ (3/10/2013): These functions are left undefined in the final link step for SWIG support, so remove it from SWIG processing for now.

       // DQ (12/27/2011): Added support for template declarations in the AST.
       // SgTemplateVariableSymbol* find_template_variable(const SgName & name);
          SgVariableSymbol*         find_nontemplate_variable(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
#endif
          SgClassSymbol*     find_class(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
       // This is important in handling the viability of symbols through base classes when private base 
       // class derivation is used.
       // SgAliasSymbol* find_alias(const SgName & nm);

       // DQ (8/10/2013): I have needed to change the API to support more than just template arguments (adding support for template parameters).
       // DQ (8/8/2013): I have needed to change the API to support more than just classes.
       // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* X_templateArgumentsList, SgClassSymbol* classSymbol);
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* X_templateArgumentsList, SgSymbol* symbol);
       // bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
          bool hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
          bool hasMatchingTemplateParametersOrNoTemplateParameters(SgTemplateParameterPtrList* templateParameterList, SgSymbol* symbol);
          bool hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol);
       // template <class T> bool hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(T* templateParametersOrArgumentsList, SgSymbol* symbol);
          template <class T> bool hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(std::vector<T*>* templateParametersOrArgumentsList, SgSymbol* symbol);

          SgClassSymbol* find_class(const SgName & name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
       // This is important in handling the viability of symbols through base classes when private base 
       // class derivation is used.
       // SgAliasSymbol* find_alias(const SgName & name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

          SgNonrealSymbol*   find_nonreal(const SgName & name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList);

          SgFunctionSymbol* find_function(const SgName& name);                //! Complexity O(log n) for first match against name, then O(n)
       // SgFunctionSymbol* find_function(const SgName&, const SgType* name); //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol* find_function(const SgName&, const SgType* name, SgTemplateArgumentPtrList* templateArgumentList = NULL);

          SgFunctionTypeSymbol* find_function_type(const SgName& name);        //! Complexity O(log n) for first match against name, then O(n)

       // Additional find functions (using name)
          SgTypedefSymbol*   find_typedef(const SgName & name);    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum(const SgName & name);       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label(const SgName & name);      //! Complexity O(log n) for first match against name, then O(n)
          SgJavaLabelSymbol* find_java_label(const SgName & name); //! Complexity O(log n) for first match against name, then O(n)
                                                                   // charles4: added 09/12/2011 for Java
          SgNamespaceSymbol* find_namespace(const SgName & name);  //! Complexity O(log n) for first match against name, then O(n)

#if 0
       // DQ (8/13/2013): Since function templates, member function templates, and class templates are symbols not derived from SgTemplateSymbol, 
       // this function is not very useful since it returns a SgTemplateSymbol.  This was a part of the older pre-EDG4x API.
       // DQ (8/10/2013): Added support for specification of template parameters (for member and non-member function overloading) and template arguments (for class specialization).
       // SgTemplateSymbol*  find_template(const SgName & name);
          SgTemplateSymbol*  find_template(const SgName & name, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList);
#endif
       // DQ (5/19/2013): Find the aliasSymbol for which the (aliasSymbol->get_base() == sp).
          SgAliasSymbol*     find_aliased_symbol(const SgName & nm, SgSymbol *sp);

       // DQ (12/26/2011): Added more refined level of support for template declarations in the AST.
       // SgTemplateClassSymbol* find_template_class (const SgName & nm);

#if 0
       // DQ (11/27/2010): Removing these to avoid updating them to have consistant case handling support (deprecated 4-5 years ago).
          SgSymbol*          findfirstany() ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  findfirstvar() ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     findfirstclass() ROSE_DEPRECATED_FUNCTION;
          SgFunctionSymbol*  findfirstfunction() ROSE_DEPRECATED_FUNCTION;
#endif
       // DQ (1/30/2007): New interface member functions: get the first symbol using type of SgSymbol
          SgSymbol*          find_any();      //! Complexity O(log n) for first match against name, then O(n)
          SgVariableSymbol*  find_variable(); //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*     find_class();    //! Complexity O(log n) for first match against name, then O(n)
          SgFunctionSymbol*  find_function(); //! Complexity O(log n) for first match against name, then O(n)

       // DQ (2/19/2007): this is equivalent to the STL "begin()" function because 
       // SgFunctionTypeSymbol objects are placed into the global function type table.
       // SgFunctionTypeSymbol*  find_function_type();

          SgTypedefSymbol*   find_typedef();    //! Complexity O(log n) for first match against name, then O(n)
          SgEnumSymbol*      find_enum();       //! Complexity O(log n) for first match against name, then O(n)
          SgEnumFieldSymbol* find_enum_field(); //! Complexity O(log n) for first match against name, then O(n)
          SgLabelSymbol*     find_label();      //! Complexity O(log n) for first match against name, then O(n)
          SgNamespaceSymbol* find_namespace();  //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateSymbol*  find_template();   //! Complexity O(log n) for first match against name, then O(n)

       // DQ (12/27/2011): Added support for template declarations in the AST.
       // DQ (12/12/2011): New functions to support template declarations in the AST.
       // SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type);
      //! Complexity O(log n) for first match against name, then O(n)
       // SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList);
          SgTemplateFunctionSymbol* find_template_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList);

          SgTemplateVariableSymbol* find_template_variable(const SgName& name, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentsList);

       // DQ (8/10/2013): Adding template parameter support for overloaded templates (note that the 
       // template arguments for specialization are not required since partial template function 
       // specialization is not allowed in C++ and any requirement for specialized functions could 
       // only be for instantiatied template functions which would use a different symbol lookup function.
       // SgFunctionSymbol* find_nontemplate_function(const SgName& name, const SgType* type);
          SgFunctionSymbol* find_nontemplate_function(const SgName& name, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (12/27/2011): Added support for template declarations in the AST.
      //! Complexity O(log n) for first match against name, then O(n)
       // SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type);
       // SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList);
          SgTemplateMemberFunctionSymbol* find_template_member_function(const SgName& name, const SgType* type, SgTemplateParameterPtrList* templateList);
       // SgMemberFunctionSymbol*         find_nontemplate_member_function(const SgName& name, const SgType* type);
          SgMemberFunctionSymbol*         find_nontemplate_member_function(const SgName& name, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (9/9/2012): We need to pass the template parameters to help disambiguate the symblos using more than just the names.
       // SgTemplateClassSymbol* find_template_class   (const SgName& name);                     //! Complexity O(log n) for first match against name, then O(n)
          SgTemplateClassSymbol* find_template_class (const SgName & nm, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList );

       // DQ (3/8/2017): Adding support for template typedef declarations and their symbol table handling.
       // SgTemplateTypedefSymbol* find_template_typedef (const SgName & nm, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateArgumentList );
          SgTemplateTypedefSymbol* find_template_typedef (const SgName & nm);

       // SgClassSymbol*         find_nontemplate_class(const SgName& name);                     //! Complexity O(log n) for first match against name, then O(n)
          SgClassSymbol*         find_nontemplate_class(const SgName& name, SgTemplateArgumentPtrList* templateArgumentsList); //! Complexity O(log n) for first match against name, then O(n)

#if 0
       // DQ (11/27/2010): Removing these to avoid updating them to have consistant case handling support (deprecated 4-5 years ago).
          SgSymbol*          nextany() ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  nextvar() ROSE_DEPRECATED_FUNCTION;
          SgClassSymbol*     nextclass() ROSE_DEPRECATED_FUNCTION;
#endif
       // Get the next symbol of a specific type, return NULL if not available.
       // These functions use state information set by the find functions (either
       // the versions using the name or not using a name as a parameter).
          SgSymbol*          next_any();        //! Complexity O(n)
          SgVariableSymbol*  next_variable();   //! Complexity O(n)
          SgClassSymbol*     next_class();      //! Complexity O(n)
          SgFunctionSymbol*  next_function();   //! Complexity O(n)
          SgTypedefSymbol*   next_typedef();    //! Complexity O(n)
          SgEnumSymbol*      next_enum();       //! Complexity O(n)
          SgEnumFieldSymbol* next_enum_field(); //! Complexity O(n)
          SgLabelSymbol*     next_label();      //! Complexity O(n)
          SgNamespaceSymbol* next_namespace();  //! Complexity O(n)
          SgTemplateSymbol*  next_template();   //! Complexity O(n)
#if 0
       // DQ (11/27/2010): Removing these to avoid updating them to have consistant case handling support (deprecated 4-5 years ago).
       // for both global function and member functions
          SgFunctionSymbol*  nextfunc() ROSE_DEPRECATED_FUNCTION;
#endif
#if 0
       // DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
       // The next for functions have been placed back into the Sage III interface.
          SgVariableSymbol*  findfirstvar();
          SgVariableSymbol*  nextvar();
          SgSymbol*          nextany();
          SgSymbol*          findfirstany();
#endif
#if 0
       // DQ (11/27/2010): Removing these to avoid updating them to have consistant case handling support (deprecated 4-5 years ago).
       // This is a cute operator to use, but since it can't specify a type of SgSymbol it is not so useful in practice.
          SgSymbol* operator[](const SgName &) ROSE_DEPRECATED_FUNCTION;
#endif
      //! Computes the number of symbols of a specific name
          int count(const SgName &) const;

      //! Computes the number of alias symbols of a specific name (used in name qualification support).
          int count_aliases(const SgName &) const;

      //! Outputs symbol table information (useful for debugging)
          void print( std::string label, VariantT nodeType = V_SgSymbol );
          void print();
       // void print( std::string label );

       // Output to ostream (this function is not implemented)
       // void print(std::ostream&);

      //! Computes the number of symbols in the symbol table (forced to count them, I think, internal STL detail).
          int size() const; //! Complexity O(n)

      //! generate an STL set of all symbols (supports AST merge, but may be temporary)
          std::set<SgNode*> get_symbols() const;

#if 0
// DQ (3/10/2007): This approach in the end, didn't work.  So I think this can be removed!
      //! Generate unique name for matching named symbols of the same type (support for AST merge)
          unsigned int generateUniqueNumberForMatchingSymbol( SgDeclarationStatement* symbolBasis ) const;
#endif

      //! Generates name from any IR node used to generate symbols (only works on specific IR nodes)
          SgName get_name( const SgNode* node) const;

       // DQ (11/28/2010): Added case sensitive/insensitive option to symbol table behavior.
      /*! \brief Query of scope symbol table behavior (is symbol table behavior case sensitive (C/C++) or case insensitive (Fortran).

          Note that a case insensitive symbol table can only be built that way from the SgSymbolTable constructor 
          and not be toggled back and forth at will.
       */
          bool isCaseInsensitive() const;
          void setCaseInsensitive(bool b);

       // DQ (3/30/2014): This is a mode introduced to match the C++ handling of symbols of base classes with that of Java.
       // This might be temporary, but is at least a part of how we are sorting out the differences between C++ and Java
       // for symbols data members in base classes.  In C++ these are represented as SgAliasSymbols in the derived classes
       // (permitting access issues to be addressed).  In Java this is less sophisticated and one has to seach the base
       // classes explicitly.  This mode permits the semantics of searching for symbols to be handled from the derived class
       // directly.  It might be a better design to have the Java symbol handling be a bit more like that of C++, but this
       // must be discussed in some detail before we go that far.
          static bool get_force_search_of_base_classes();
          static void set_force_search_of_base_classes( bool value );

       // DQ (7/12/2014): Adding support for static data member.
          static SgNodeSet & get_aliasSymbolCausalNodeSet();

       // DQ (8/3/2019): Display function for static data member.
          static void display_aliasSymbolCausalNodeSet();

     protected:

#if 0
       // DQ (8/21/2013): This function has been removed in favor of a single low-level (templated) supporting 
       // function that can optionally handle types (only used to support function lookups).
       // DQ (12/26/2011): Refactoring of code into templated support function.
       // template<class ReturnType> ReturnType* find_symbol_support (const SgName & nm);
          template<class ReturnType> ReturnType* find_symbol_support (const SgName & nm, SgTemplateParameterPtrList* templateParameters = NULL, SgTemplateArgumentPtrList* templateArguments = NULL);
#endif

       // DQ (4/14/2017): Test test2017_30.C demonstrates that we need to be able to force the filtering of symbols from templates
       // DQ (5/20/2013): Added refactoring of symbol lookup support so that we can handle new namespace support for symbols.
       // template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type);
       // template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList);
          template<class ReturnType> ReturnType* find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols);

#if 0
       // DQ (5/20/2013): Added support for better refactoring on the template code so we can use it to support other functions.
       // DQ (9/9/2012): Adding more template support (need version of function for template parameters (to disambiguate 
       // template names, similar to how we do so for template instantiations using the template argument list).
       // template<class ReturnType> ReturnType* find_template_symbol_support (const SgName & nm, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList);
          template<class ReturnType,class ReturnTypeDeclaration> ReturnType* find_template_symbol_support (const SgName & nm, SgTemplateParameterPtrList* templateParameters, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (8/12/2013): This function is redundant and is not replaced by the template function find_symbol_support<SgClassName>(nm,NULL,templateArgumentsList).
       // DQ (5/20/2013): Added refactoring of symbol lookup support so that we can handle new namespace support for symbols.
          template<class ReturnType> ReturnType* find_symbol_with_template_args_support ( const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList );
#endif

     public:
#if 0
       // DQ (5/21/2013): This function was moved from the symbol table to the SgScopeStatement so that we could 
       // make the symbol table access functions private as part of the new namespace symbol table handling.
       // DQ (3/13/2012): Added support for organizing how we match function declarations with function symbols.
          template<class T>
          SgFunctionSymbol* find_symbol_by_type_of_function (const SgName & name, const SgType* func_type);
#endif

          size_t maxCollisions();

HEADER_SYMBOL_TABLE_END


HEADER_SYMBOL_TABLE_POSTDECLARATION_START

HEADER_SYMBOL_TABLE_POSTDECLARATION_END


// HEADER SYMBOL_TABLE_POSTDECLARATION_START
// HEADER SYMBOL_TABLE_POSTDECLARATION_END


HEADER_BASECLASS_START
     public:
          void post_construction_initialization() $ROSE_OVERRIDE;

       // This function should be autogenerated
       // SgBaseClass(int specifier=0, SgClassDeclaration* ptr = NULL, int dir = 0);
          SgBaseClass(const SgBaseClass& ptr);
      // ~SgBaseClass();
          SgBaseClass& operator= (const SgBaseClass& ptr);
      //  int get_base_specifier() const;
      //  SgClassDeclaration* get_base_class() const;
      //  SgClassDeclaration* replace_base_class(SgClassDeclaration*);

          bool operator== (const SgBaseClass& ) const;
          bool operator< (const SgBaseClass&) const;

#if 0
       // DQ (1/21/2019): This should be an automatically generated access function.
       // DQ (4/25/2004): Part of new modifier interface
          SgBaseClassModifier & get_baseClassModifier();
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

#if 0
  // These are now autogenerated
     private:
          int p_specifier;
          int p_direct;
          SgClassDeclaration* p_ptr;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix() const;

HEADER_BASECLASS_END

HEADER_EXP_BASE_CLASS_START
     public:
          void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_EXP_BASE_CLASS_END

HEADER_NONREAL_BASE_CLASS_START
     public:
          void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_NONREAL_BASE_CLASS_END


HEADER_INITIALIZED_NAME_START

     public:

      /*! \brief Preinitialization Enum (only one value can be specified)

          Initialization information which I forget the details of ...

          \internal Only one value can be specified (at least in C and C++)
       */
          enum preinitialization_enum
             {
            // When used as entries in the preinitialization list we record extra data require to reset instantiated template names
               e_unknown_preinitialization = 0, /*!< default value */
               e_virtual_base_class        = 1, /*!< virtual base class value */
               e_nonvirtual_base_class     = 2, /*!< nonvirtual base class value */
               e_data_member               = 3, /*!< data member value */
               e_delegation_constructor    = 4, /*!< delegation constructor (C++11 feature) */
               e_last_preinitialization         /*!< last value (upper bound on range of values, used in error checking) */
             };

      /*! \brief Register names (x86 specific GNU names).

          \internal These are all machine-specific.
       */
          enum asm_register_name_enum
             {
               e_invalid_register = 0,  /*!< error value */
               e_memory_register,       /*!< memory */
               e_register_a,
               e_register_b,
               e_register_c,
               e_register_d,            /*!< eax, ebx, ecx, edx */
               e_register_si,
               e_register_di,
               e_register_bp,
               e_register_sp,           /*!< esi, edi, ebp, esp */
               e_register_r8,
               e_register_r9,
               e_register_r10,
               e_register_r11,          /*!< x86-64 extra integer registers */
               e_register_r12,
               e_register_r13,
               e_register_r14,
               e_register_r15,
               e_register_st0,
               e_register_st1,
               e_register_st2,
               e_register_st3,          /*!< 80387 floating point stack */
               e_register_st4,
               e_register_st5,
               e_register_st6,
               e_register_st7,
               e_register_mm0,
               e_register_mm1,
               e_register_mm2,
               e_register_mm3,          /*!< MMX registers */
               e_register_mm4,
               e_register_mm5,
               e_register_mm6,
               e_register_mm7,
               e_register_f0,
               e_register_f1,
               e_register_f2,
               e_register_f3,           /*!< SSE/SSE2 registers */
               e_register_f4,
               e_register_f5,
               e_register_f6,
               e_register_f7,
               e_register_f8,
               e_register_f9,
               e_register_f10,
               e_register_f11,          /*!< x86-64 extra SSE registers */
               e_register_f12,
               e_register_f13,
               e_register_f14,
               e_register_f15,
               e_register_flags,
               e_register_fpsr,
               e_register_dirflag,      /*!< control registers */
               e_unrecognized_register, /*!< used to represent an unrecognized register. */
               e_last_register
             };

       // DQ (1/3/2009): This might imply that we need a variable modifier (SgVariableModifier 
       // (as a new IR node, but for now implement these directly since they are GNU specific 
       // attributes (extensions)).
          enum gnu_variable_attribute_enum
             {
            // DQ (12/4/2007): Added support for GNU specific attributes
               e_gnu_attribute__weak__                   = 0, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__                 = 1, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__used__                   = 2, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__             = 3, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nocommon__               = 4, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__      = 5, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__weakref__                = 6,/*!< GNU specific attribute for (GNU extension) */

            // DQ (12/30/2013): Added support fo packing for variables (e.g. field values), instead of just there types.
            // Also, fixed bug where packed was same enum value as weakref
               e_gnu_attribute__packed__                 = 7,/*!< GNU specific attribute for (GNU extension) */

            // DQ (1/6/2014): Added support for GNU noreturn attribute
               e_gnu_attribute__noreturn__               = 8,/*!< GNU specific attribute for (GNU extension) */

               e_ms_declspec_parameter_appdomain    =  9, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_deprecated   = 10, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_dllimport    = 11, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_dllexport    = 12, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_novtable     = 13, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_process      = 14, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_property     = 15, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_restrict     = 16, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_selectany    = 18, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_thread       = 19, /*!< Microsoft declspec() attributes */
               e_ms_declspec_parameter_uuid         = 20, /*!< Microsoft declspec() attributes */

               e_last_gnu_variable_attribute /*!< last value (upper bound on range of values, used in error checking) */
             };

        // driscoll6 (8/4/11): support for excess specifiers in python (*args and **kwargs)
          enum excess_specifier_enum
             {
               e_excess_specifier_none = 0,
               e_excess_specifier_positionals,
               e_excess_specifier_keywords,
               e_excess_specifier_last /* sentry */
             };

          bool checkBit ( unsigned int bit ) const;
          void setBit ( unsigned int bit );
          void unsetBit ( unsigned int bit );

          bool isGnuAttributeWeak() const;
          void setGnuAttributeWeak();
          void unsetGnuAttributeWeak();

          bool isGnuAttributeUnused() const;
          void setGnuAttributeUnused();
          void unsetGnuAttributeUnused();

          bool isGnuAttributeUsed() const;
          void setGnuAttributeUsed();
          void unsetGnuAttributeUsed();

          bool isGnuAttributeDeprecated() const;
          void setGnuAttributeDeprecated();
          void unsetGnuAttributeDeprecated();

          bool isGnuAttributeNoCommon() const;
          void setGnuAttributeNoCommon();
          void unsetGnuAttributeNoCommon();

          bool isGnuAttributeTransparentUnion() const;
          void setGnuAttributeTransparentUnion();
          void unsetGnuAttributeTransparentUnion();

          bool isGnuAttributeWeakReference() const;
          void setGnuAttributeWeakReference();
          void unsetGnuAttributeWeakReference();

       // DQ (12/30/2013): Added support fo packing for variables (e.g. field values), instead of just there types.
       // The differences are represented in test codes: test2013_104.c and test2013_113.c.
          bool isGnuAttributePacked() const;
          void setGnuAttributePacked();
          void unsetGnuAttributePacked();

       // DQ (1/6/2014): Added support for noreturn attribute on function parameters (appies only for function pointers used as function parameters).
          bool isGnuAttributeNoReturn() const;
          void setGnuAttributeNoReturn();
          void unsetGnuAttributeNoReturn();

#if 0
 // DQ (8/17/2014): Associated Microsoft attributes that are valid in a function parameter.
    appdomain
    deprecated
    dllimport
    dllexport
    novtable
    process
    restrict
    selectany
    thread
    uuid(" ComObjectGUID ")
#endif

          bool is_ms_declspec_parameter_appdomain() const;
          void set_ms_declspec_parameter_appdomain();
          void unset_ms_declspec_parameter_appdomain();

          bool is_ms_declspec_parameter_deprecated() const;
          void set_ms_declspec_parameter_deprecated();
          void unset_ms_declspec_parameter_deprecated();

          bool is_ms_declspec_parameter_dllimport() const;
          void set_ms_declspec_parameter_dllimport();
          void unset_ms_declspec_parameter_dllimport();

          bool is_ms_declspec_parameter_dllexport() const;
          void set_ms_declspec_parameter_dllexport();
          void unset_ms_declspec_parameter_dllexport();

          bool is_ms_declspec_parameter_novtable() const;
          void set_ms_declspec_parameter_novtable();
          void unset_ms_declspec_parameter_novtable();

          bool is_ms_declspec_parameter_process() const;
          void set_ms_declspec_parameter_process();
          void unset_ms_declspec_parameter_process();

          bool is_ms_declspec_parameter_restrict() const;
          void set_ms_declspec_parameter_restrict();
          void unset_ms_declspec_parameter_restrict();

          bool is_ms_declspec_parameter_selectany() const;
          void set_ms_declspec_parameter_selectany();
          void unset_ms_declspec_parameter_selectany();

          bool is_ms_declspec_parameter_thread() const;
          void set_ms_declspec_parameter_thread();
          void unset_ms_declspec_parameter_thread();

          bool is_ms_declspec_parameter_uuid() const;
          void set_ms_declspec_parameter_uuid();
          void unset_ms_declspec_parameter_uuid();

          void post_construction_initialization() $ROSE_OVERRIDE;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
       // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const $ROSE_OVERRIDE;
          virtual bool cfgIsIndexInteresting(unsigned int index) const $ROSE_OVERRIDE;
          virtual unsigned int cfgFindChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) $ROSE_OVERRIDE;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) $ROSE_OVERRIDE;
#endif

          SgStorageModifier & get_storageModifier();

       // DQ (8/10/2010): Added const version of this function!
          const SgStorageModifier & get_storageModifier() const;

      //  These are automatically generated! (not an option currently)
      //  SgInitializedName();
      // ~SgInitializedName();
          SgInitializedName(
               const SgName& name, 
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgDeclarationStatement *declptr = 0,
//  QY 11/2/04  removed itemptr 
//               SgInitializedName *itemptr = 0,
               SgInitializedName *prev_decl_item = 0 ) ROSE_DEPRECATED_FUNCTION;

       // DQ (8/4/2006): New constructor that explicitly includes the Sg_File_Info and SgScopeStatement (recently added data members)
          SgInitializedName ( Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr, 
                              SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr );

#ifdef BUILD_X_VERSION_TERMINALS
          SgInitializedName(
               const SgName& name, 
               SgType *typeptr,
               SgInitializer* iptr = 0,
               SgX_DeclarationStatement *declptr = 0,
//               SgInitializedName *itemptr = 0,
               SgInitializedName *prev_decl_item = 0 );
#endif

       // DQ (10/13/2014): Adding a default constructor for compatability with what was previously the API before the newer aterm support.
          SgInitializedName() ROSE_DEPRECATED_FUNCTION;

          SgInitializedName(const SgInitializedName& ptr);

          SgInitializedName& operator= (const SgInitializedName& ptr);

          bool operator== (const SgInitializedName& ) const;
          bool operator< (const SgInitializedName&) const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): This custom function to match the version that would be automatically by ROSETTA, but we 
       // want to have a custom version of set_name(SgName name) that permits names to be reset (unloaded from the 
       // symbol table are reloaded into the symbol table).
       // SgName get_name() const;

       // DQ (10/9/2007): Use the ROSETTA generated version to test failure
       // DQ (10/5/2007): Put back into place afterhaving been removed by accident in 12/xx/2004
       // AJ (10/21/2004): Added function to support changing names of symbols, note that void set_name(SgName name) 
       // would be the automatically generated function.
       // void set_name(SgName name);
       // int set_name(SgName new_name);

          SgType *get_type() const;
          void set_type(SgType *t);

          SgInitializer *get_initializer() const;
          void set_initializer(SgInitializer* i);

#ifdef BUILD_X_VERSION_TERMINALS
       // Modified from SAGE (added access functions for X version of DeclarationStatement data member
          SgX_DeclarationStatement *get_X_declaration() const;
          void set_X_declaration(SgX_DeclarationStatement* decl);
#endif

          SgDeclarationStatement *get_declaration() const;
         // void set_declaration(SgDeclarationStatement* decl);

          SgDeclarationStatement *get_definition() const;
          void set_definition(SgDeclarationStatement* def);

       // DQ (8/2/2004): Force an explicit function matching the virtual function defined in SgNode
       // Sg_File_Info* get_file_info() const;

      //! Returns the name with appropriate qualified names representing nested scopes
          SgName get_qualified_name() const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

       // DQ (11/6/2006): use this to return the startOfConstruct source position.
       //   virtual Sg_File_Info* get_file_info(void) const;
       //   virtual void set_file_info(Sg_File_Info* X);

       // DQ (2/6/2007): Added support to get the symbol from the declaration (via the symbol table in the scope)
      //! Get the associated SgSymbol from the symbol table located in the scope, without considering possible prev_decl_item. Internal use only. Users should use search_for_symbol_from_symbol_table() instead.
          SgSymbol* get_symbol_from_symbol_table() const;

       // PC (10/1/2009): Added support to get the symbol from the correct associated declaration
       //! User interface for retrieving the associated symbol. It searches through the possible chain of prev_decl_item.
          SgSymbol* search_for_symbol_from_symbol_table() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (12/16/2013): Added support for name qualification on SgInitializedName for use in preinitialization lists.
          SgName get_qualified_name_prefix() const;

       // DQ (3/21/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length_for_type);

       // DQ (3/31/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required_for_type);

       // DQ (3/31/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required_for_type);

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix_for_type() const;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);

HEADER_INITIALIZED_NAME_END


HEADER_NAME_START
       // We need to define the default constructor explicitly 
       // (else p_char is not initialized properly to NULL)
          SgName();
          SgName(const char* str);
          SgName(const std::string& str);
          SgName(const SgName& n);

      // ~SgName();

          int operator!=(const SgName& n1) const;
          int operator==(const SgName& n1) const;
          int operator< (const SgName& n1) const;

       // DQ (11/27/2010): Added to support case sensitive and case insensitive semantics.
          static bool caseInsensitiveEquality ( const SgName & x, const SgName & y );

       // Added to support assignments to string variables.
          operator std::string () const;

       // DQ (11/28/2009): Fixed return value of function to be "bool" instead of "int"
          bool is_null(void) const;
          void replace_space(char t);
          SgName& operator<<(const std::string& str);

          static SgName itoname(int val);

          SgName& operator<<(int val);
          SgName& operator=(const SgName& n1);
          SgName& tail(int n); // keep std::string after n
          SgName& head(int n); // keep first n chars

          const char* str() const;
          std::string& getString();
          const std::string& getString() const;

       // In places where the str() member function is called it is toe get the 
       // length of the std::string in p_char so it makes since to provide a member 
       // function to get the length instead of making a the str() function a 
       // const member function!
          unsigned int get_length() const;

       // DQ: We made this a const function to work with the Sage Symbol Table implementation 
       // But it is a bad idea to have it since it causes problems where it is used.
       // EXAMPLE: char* char_pointer = tempSgName;
       // this code fragment causes a new SgName object to be build and the pointer to 
       // the std::string in the new object is returned then the SgName object goes out of 
       // scope and then reading the std::string causes a purify FMR error!
       // It might be that it should not be a const function (this is likely the 
       // real source of the problem), but I would like to remove it anyway for 
       // now to simplify the debugging!
       // operator char*() const;

       // To handle "assert(p_name != NULL);" where p_name is a SgName
       // object, STL requires that the "operator==()" be defined
       // (STL builds the "operator!=()" from the "operator==()"
          bool operator== (const int) const { return false; }

          void display( const std::string& label ) const;

       // DQ (9/9/2004): Supporting function for building qualified names (specialied std::string concatination)
          static SgName assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName);

       // DQ (9/9/2004): friend function (string concatination)
          ROSE_DLL_API friend SgName operator+(const SgName & n1, const SgName & n2);

       // DQ (11/15/2004): Added to support general string operations (first used in the unparser)
          SgName & operator+= (const SgName & n1);

          SgName invertCase() const;

HEADER_NAME_END


HEADER_NAME_POSTDECLARATION_START
// extern const SgName defaultName("defaultName");

// DQ (10/5/2007): We no longer need this!
// extern const SgName SgdefaultName;

HEADER_NAME_POSTDECLARATION_END


HEADER_QUALIFIED_NAME_START
HEADER_QUALIFIED_NAME_END


HEADER_ATTRIBUTE_START
       // SgAttribute(char* str);
          int isSame(const std::string& str);

       // DQ (12/6/2016): This needs to match being const as in the derived class (this also eliminates a compiler warning).
       // virtual bool isPragma() { return 0; } // MS02/22/02
          virtual bool isPragma() const { return 0; }

       // char *get_name() const;

      protected:
       // char* p_name;

HEADER_ATTRIBUTE_END


HEADER_BIT_ATTRIBUTE_START
       // SgBitAttribute(char *str);

//        int isAttributeSet(unsigned long int bit) const;
//        void setAttribute(unsigned long int bit);
//        void unsetAttribute(unsigned long int bit);
//        int isPragma() const;

  // private:
  //      unsigned long int p_bitflag;

HEADER_BIT_ATTRIBUTE_END


HEADER_FUNCTION_DECLARATION_ATTRIBUTE_START
       // SgFuncDecl_attr();
       // void set_suppress_atomic();
       // int get_suppress_atomic() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFuncDecl_attr();

     private:
       // enum { e_suppressatomic = 0x00000001 };

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_END

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
// int get_suppress_atomic(SgFunctionDeclaration *); 
// void set_suppress_atomic(SgFunctionDeclaration *);

HEADER_FUNCTION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFuncDecl_attr::SgFuncDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END



HEADER_CLASS_DECLARATION_ATTRIBUTE_START
       /* local attribute class to suppress the printing of global keyword */
//        SgClassDecl_attr();
//        void set_suppress_global();
//        int get_suppress_global() const;

       // JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgClassDecl_attr();

     private:
//        enum { e_suppress_global = 0x00000001 };

HEADER_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_CLASS_DECLARATION_ATTRIBUTE_START

// JH (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgClassDecl_attr::SgClassDecl_attr()
   : SgBitAttribute(NULL,0)
   {
  // Build the default constructor (nothing to build here since no data members)
   }

SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE.
//
       /* local attribute class to suppress the printing of global keyword */
          SgTemplateInstDecl_attr();
          void set_suppress_global();
          int get_suppress_global() const;

     private:

      /*! What is this enum value for???  Shouldn't there be a name? */
          enum
             {
               e_suppress_global = 0x00000001 /*!< What is the point of having a single value here? */
             };

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//int get_suppress_globalSgClassDeclaration *);
//void set_suppress_global(SgClassDeclaration *); 

HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_START
//
// [DT] -- 5/11/2000 -- This is based on HEADER_CLASS_DECLARATION_ATTRIBUTE_POSTDECLARATION.
//
int get_suppress_global(SgTemplateInstantiationDecl *);
void set_suppress_global(SgTemplateInstantiationDecl *); 

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_POSTDECLARATION_END


HEADER_PRAGMA_START
       // SgPragma(char *name);

          void post_construction_initialization() $ROSE_OVERRIDE;

          std::string get_pragma() const;
          bool samePragma(const std::string& str);
          bool isPragma() const $ROSE_OVERRIDE;
          bool gotPrinted() const;
          void setPrinted(bool s = true);

       // DQ (8/3/2004): added function to match virtual function in SgNode
          Sg_File_Info* get_file_info() const $ROSE_OVERRIDE;

HEADER_PRAGMA_END


HEADER_FILE_INFORMATION_START

      /*! \brief Enum type containing classifications if IR nodes.

          This is part of the classification mechanism for IR nodes within ROSE.
          Compiler generated code is not output in the code generation phase,
          but some compiler generated IR nodes must be output so such nodes are explicitly 
          marked within the classification process (implemented in ASTFixes.C).
             - Examples of transformation IR nodes include:
                -# Any relocated AST subtrees
                -# Any new IR nodes
             - Examples of compiler-generated IR nodes include:
                -# Any implicit or unnecessary casts not explicitly represented in the source code
                -# Instantiated templates
             - Examples of compiler-generated code marked for output (in code generation phase) include:
                -# Any transformed template instantiations
                -# required templates assigned to specific files (see ROSE prelinking details)
             - Examples of shared IR nodes include:
                -# All types (not implemented yet)
                -# All IR nodes shared across originally separate ASTs (see AST Merge Mechanism)
             - Examples of frontend specific IR nodes include:
                -# float __builtin_acosf (float __builtin__x);
                -# #define __builtin_va_start va_start
                -# All functions and variables defined in "rose_edg_required_macros_and_functions.h"

          \internal We need constructors taking a value of this type.
       */
          enum classifier
             {
               e_transformation                          = 0x1,  /*!< classify as a transformation */
               e_compiler_generated                      = 0x2,  /*!< classify as compiler generated */
               e_output_in_code_generation               = 0x4,  /*!< classify as required when generating code in unparser (orthogonal concept to transformation and compiler generated) */
               e_shared                                  = 0x8,  /*!< classify as a shared IR node (part of evolving support for AST merging) */
               e_frontend_specific                       = 0x10, /*!< classify as frontend specific (e.g. gnu compatable function from rose_edg_required_macros_and_functions.h) */
               e_source_position_unavailable_in_frontend = 0x20, /*!< classify as explictly unabailable from front-end */
               e_comment_or_directive                    = 0x40, /*!< classify as a comment or directive (not a part of the language grammar) */
               e_token                                   = 0x80, /*!< classify as a token from the parser (not a part of the language grammar) */
            // DQ (4/24/2013): Added support for default arguments.
               e_default_argument                        = 0x100,/*!< classify as a default arguement to function call expression */
            // DQ (4/24/2013): Added support for implicit cast.
               e_implicit_cast                           = 0x200 /*!< classify as a implicit cast */
             };

       // ~Sg_File_Info();

       // DQ (5/10/2006): Remove these to simplify implementation.
          Sg_File_Info();
       // Sg_File_Info(const char* filename, int line = 0, int col = 0) ROSE_DEPRECATED_FUNCTION;
          Sg_File_Info(const std::string & filename, int line = 0, int col = 0);

       // DQ (2/15/2003): added copy constructor
          Sg_File_Info(const Sg_File_Info & X);

       // DQ (11/6/2008): Added to support construction of objects using Dwarf information.
          Sg_File_Info( int file_id, int line, int column );

          void post_construction_initialization() $ROSE_OVERRIDE;

       // ROSE-1499, ROSE-1639 (added const to char*)
          void check_file_id(const char * label, bool assertion=true) const;

       // DQ (11/6/2008): Added support for extending the internal static filename to integer id map
      //! Access function to permit files referenced in Dwarf to be mapped to integers using the same scheme as for source code.
          static int addFilenameToMap ( const std::string & filename );

      //! Returns the number of entries in the filename map
          static int numberOfSourceFiles();

          void set_filename (const char* filename) ROSE_DEPRECATED_FUNCTION;
          void set_filenameString ( const std::string & filename );
          void set_line (int line);
          void set_col ( int n );
          void display (const std::string label ) const;
          void display () const;
          std::string displayString (const std::string & label = "") const;
          //void output (std::ostream& os) ROSE_DEPRECATED_FUNCTION;

       // DQ (6/11/2007): output static data for debugging
          static void display_static_data( const std::string label );

          const char* get_filename() const ROSE_DEPRECATED_FUNCTION;
          const std::string& get_filenameString() const;
          int   get_line() const;
          int   get_col() const;

       // DQ (2/28/2019): Support for multi-file handling.
      //! Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.
          int   get_line(int file_id) const;

          void set_file_id ( int file_id );
          int  get_file_id () const;

          std::string get_raw_filename() const;
          int  get_raw_line() const;
          int  get_raw_col() const;

       // DQ (12/18/2012): Added support for physical filename and line number data.
          void set_physical_filename ( const std::string & filename );
          std::string get_physical_filename() const;
          void set_physical_file_id ( int physical_file_id );
          int  get_physical_file_id () const;
          void set_physical_line (int line);
          int  get_physical_line() const;
          void set_physical_source_position_to_match_logical_source_position();

       // DQ (2/28/2019): Support for multi-file handling.
      //! Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.
          int  get_physical_line(int file_id) const;

       // DQ (2/28/2019): This is required because the physical id returned can be dependent on the file id when this is a shared IR node.
          int  get_physical_file_id (int file_id) const;

       // DQ (1/23/2013): Added source position sequence information. This work supports the handling of default arguments and addresses
       // new future capabilities to ROSE.
          void set_source_sequence_number (unsigned int n);
          unsigned int get_source_sequence_number() const;

       // DQ (12/22/2006): This copies the line number and column number information and verifies that 
       // the file name is the same (it does not reset any fo the classification flags).  This is more
       // useful than the assignment operator for updating information and is used in the file:
       // fixupSourcePositionInformation.C
          void updateSourcePosition ( Sg_File_Info* update );

       // DQ (6/20/2005): There are a number of reasons why an IR node might not have a position in the source code
       // this function abstracts that query process.
          bool hasPositionInSource() const;

       // DQ (6/21/2005): check if this file info object is from the same file

       // DQ (9/5/2008): Switched back to using SgFile instead of SgSourceFile.
       // bool isSameFile(SgFile* file) const;
       // bool isSameFile(SgSourceFile* file) const;
          bool isSameFile(SgFile* file) const;

       // DQ (1/18/2006): Added new function with more useful interface.
          bool isSameFile(Sg_File_Info* fileInfo) const;
       // DQ (11/1/2006): Alternative use case.
          bool isSameFile(const Sg_File_Info & fileInfo) const;

      //! Access function for classification bit field
       // bool isOriginal() const;
          bool isTransformation() const;
       // bool isDeclaration() const ROSE_DEPRECATED_FUNCTION;
       // bool isInitialization() const ROSE_DEPRECATED_FUNCTION;

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          bool isCompilerGenerated() const;
          bool isCompilerGeneratedNodeToBeUnparsed() const ROSE_DEPRECATED_FUNCTION;
          bool isOutputInCodeGeneration() const;
          bool isShared() const;
          bool isFrontendSpecific() const;
       // bool isUnused1() const;

          bool isSourcePositionUnavailableInFrontend() const;
          void unsetSourcePositionUnavailableInFrontend();
          void setSourcePositionUnavailableInFrontend();

       // DQ (12/23/2006): Added to support the Sg_File_Info objects used by comments and CPP directives 
       // (since their parents are NULL, becuase the PreprocessingInfo class is not dirived from a SgNode 
       // the parent point can't be used to point to it).
          bool isCommentOrDirective() const;
          void unsetCommentOrDirective();
          void setCommentOrDirective();

       // DQ (12/23/2006): Added to support Rama and Andreas's work on handling of token streams within the AST.
       // (The Sg_File_Info objects used have NULL parent pointers, becuase the token class is not dirived from a SgNode.
          bool isToken() const;
          void unsetToken();
          void setToken();

       // DQ (4/24/2013): Added support for marking as default argument.  Note that compiler generated is not specific 
       // enough because even implicit casts would then be confused as default arguments.
          bool isDefaultArgument() const;
          void unsetDefaultArgument();
          void setDefaultArgument();

       // DQ (4/26/2013): Added support for marking as implicit casts.  Note that compiler generated is not 
       // as specific as we want (though it has worked for a long time, we want a more precise mechanism).
          bool isImplicitCast() const;
          void unsetImplicitCast();
          void setImplicitCast();

      //! Set/unset functions for classification bit field
       // void unsetOriginal();
       // void setOriginal();
          void unsetTransformation();
          void setTransformation();
       // void unsetDeclaration();
       // void setDeclaration();
       // void unsetInitialization();
       // void setInitialization();

      //! Mark as compiler generated but as required to be output by unparser (e.g. required template instatiations)
          void unsetCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;
          void setCompilerGeneratedNodeToBeUnparsed() ROSE_DEPRECATED_FUNCTION;

      //! Mark as to be output by the unparser (code generator)
          void unsetOutputInCodeGeneration();
          void setOutputInCodeGeneration();

      //! Support for shared IR nodes (shared via AST merge mechanism)
          void unsetShared();
          void setShared();

       // DQ (5/6/2006): Added to support gnu compatability mode (incomplete within EDG and 
       // which we make complete through the declaration of builtin functions as required).
          void unsetFrontendSpecific();
          void setFrontendSpecific();

       // MK (8/2/05) : Added support for unparsing set, to allow shared nodes to only be unparsed by
       //               the appropriate files
      //! Add files to the set that should be able to unparse the node
          void addFileToUnparse(int file_id); 
      //! Should this node be unparsed by this file?
          bool shouldUnparse(int file_id);

       // DQ (2/21/2005): Added support for specification of compiler generated code (done in front-end translation)
          void unsetCompilerGenerated();
          void setCompilerGenerated();

       // DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
          static Sg_File_Info* generateDefaultFileInfo();

          static Sg_File_Info* generateDefaultFileInfoForTransformationNode();

       // DQ (1/11/2006): Added static function whicl allows specification of transformation with assignement to 
       // a specific file (where it would be unparsed). This function will call setOutputInCodeGeneration().
          static Sg_File_Info* generateFileInfoForTransformationNode( int file_id );
          static Sg_File_Info* generateFileInfoForTransformationNode( std::string filename );

          static Sg_File_Info* generateDefaultFileInfoForCompilerGeneratedNode();


      //! Get whole bit field fr modifier set
          unsigned int get_classificationBitField(void) const;
          void set_classificationBitField( unsigned int );

          void set_isPartOfTransformation( bool isPartOfTransformation ) ROSE_DEPRECATED_FUNCTION;
          bool get_isPartOfTransformation() ROSE_DEPRECATED_FUNCTION;

          void register_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION; /* register interest */
          void deregister_node(SgLocatedNode* node) ROSE_DEPRECATED_FUNCTION;

       // functions added by Dan Quinlan (suggested by Gary Lee)
       // int   getCurrentLine () const ROSE_DEPRECATED_FUNCTION;
       // std::string getCurrentFilename () const ROSE_DEPRECATED_FUNCTION;

       // int   getReferenceCount() ROSE_DEPRECATED_FUNCTION;
       // void  incrementReferenceCount() ROSE_DEPRECATED_FUNCTION;
       // void  decrementReferenceCount() ROSE_DEPRECATED_FUNCTION;

       // DQ (7/4/2005): Added to test internal consistancy
          bool ok() const;
       // bool consistancyCheck() const;

       // MK (8/2/05) : Added functions to interface with fileid maps, in order to eventually
       //               restrict access to the maps themselves
       // PC and AS (8/29/06) : made function return a const string reference as this will
       // eliminate the temporary string within the lifetime of the function.
          static const std::string& getFilenameFromID( int id );
          static int getIDFromFilename( std::string filename );

       // DQ (11/2/2006): Added simple assignment operator.
          Sg_File_Info & operator= ( const Sg_File_Info & X );

       // DQ (9/26/2004): Added operator== to permit testing of reused definitions of defining declarations!
          friend bool operator== ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/6/2004): Added operator!= to permit testing of reused definitions of defining declarations!
          friend bool operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y );
       // DQ (10/25/2004): Added operator> to permit testing of strting vs. ending file info object (assert starting < ending)
          friend bool operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y );
          friend bool operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y );

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember fileidtoname_map.
          static std::map<int, std::string> & get_fileidtoname_map();
       //! Access function for map of file names.
          static void set_fileidtoname_map(std::map<int, std::string> & X);

        // DQ (2/23/2010): Added static access function for static data members (ROSETTA generates only not statuc access functions).
       //! Access function for static datamember nametofileid_map.
         static std::map<std::string, int> & get_nametofileid_map();
       //! Access function for map of file names.
         static void set_nametofileid_map(std::map<std::string,int> & X);

       // MK (7/22/05) This enum is used by the file id mechanism
       /*! \brief Enum to hold previously common default values for filename used by the default and static SgNULL_File constructors.

           \internal These values can and likely should disappear in the future.
        */
          enum p_fileflags {
               COPY_FILE_ID                                 = -1, /*!< default value (equivalent to filename with "COPY") */
               NULL_FILE_ID                                 = -2, /*!< value equivalent to filename with "NULL_FILE" */
               TRANSFORMATION_FILE_ID                       = -3, /*!< value for all nodes marked as part of a translation */
               COMPILER_GENERATED_FILE_ID                   = -4, /*!< value for compiler generated IR nodes (NOT marked for output) */
               COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID = -5, /*!< value for compiler generated IR nodes (marked for output, deprecated value) */
            // MK (8/2/05) : Added new enum value to facilitate interface to maps. If we try
            //               to retrieve the fileid for a filename which isn't in the map, we return
            //               BAD_FILE_ID to indicate this.
               BAD_FILE_ID = -6   /*!< value returned if there is no file id mapped to given filename */
             };



       // DQ (2/27/2019): Adding support for access function to list of fileIds and line numbers associated with 
       // support for multi-file sharing of IR nodes and the support to know there source position information 
       // from each file.
       // const SgFileIdList & get_fileIDsToUnparse () const;
       // SgFileIdList & get_fileIDsToUnparse ();

#if 0
       // DQ (12/20/2005): These have been placed into ROSETTA

       // MK (7/22/05) These maps are used by the file id mechanism
      //! STL map object to hold file id's to strings
          static std::map<int, std::string> p_fileidtoname_map;
      //! STL map to hold reverse map of p_fileidtoname_map
          static std::map<std::string, int> p_nametofileid_map;

       // MK (7/22/05) These maps are used by the file id mechanism
      //! This allows us to generate unique file ids for every filename we see.
          static int p_max_file_id;
#endif

HEADER_FILE_INFORMATION_END

HEADER_APPLICATION_FILE_PREDECLARATION_START
// DQ (4/23/2006): Declaration of friend functions outside of class required by g++ 4.1.0!
// void alternativeSageEdgInterfaceConstruction( SgFile *file );
HEADER_APPLICATION_FILE_PREDECLARATION_END

HEADER_APPLICATION_FILE_START

private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
             s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgSupport);
             // Most data members are not serialized yet, but this is here because SgFile is a base class of
             // SgBinaryComposite whose fields are serialized.
        }

public:

       /*! \brief Enum type used to specify output of Fortran as fixed for free format.

           \internal Has no effect on C/C++ code generation.
        */
          enum outputFormatOption_enum 
             {
               e_unknown_output_format,    /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_fixed_form_output_format, /*!< value used to specify output of Fortran as fixed format */
               e_free_form_output_format   /*!< value used to specify output of Fortran as free format */
             };


       /*! \brief Enum type used to specify output language (option used for testing unparsers).

           \internal This is only for testing the unparsers and some language constructs will not unparse. 
                     This is also a way to play with some language translation ideas, but most useful one 
                     will require a specialized tranlator to be built.
        */
       // enum outputLanguageOption_enum
          enum languageOption_enum 
             {
               e_error_language,   /*!< error value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_default_language, /*!< default value (uses filename extension to determine the output format, f77: fixed, F90 and later: free) */
               e_C_language,       /*!< value used to specify output of C (for testing C unparser) */
               e_Cxx_language,     /*!< value used to specify output of C++ (for testing C++ unparser) */
               e_Binary_language,  /*!< value used to specify output of Binary ISA */
               e_Fortran_language, /*!< value used to specify output of Fortran (for testing the Fortran unparser) */
               e_Java_language,    /*!< value used to specify output of Java (for testing Java unparser) */
               e_X10_language,     /*!< value used to specify output of X10 (for testing X10 unparser) */
               e_Promela_language, /*!< value used to specify output of Promela for uses with SPIN (unsupported option) */
               e_PHP_language,     /*!< value used to specify output of PHP    */
               e_Python_language,  /*!< value used to specify output of Python */
               e_Csharp_language,  /*!< value used to specify output of Csharp */
               e_Ada_language,     /*!< value used to specify output of Ada    */
               e_Jovial_language,  /*!< value used to specify output of Jovial */
               e_Cobol_language,   /*!< value used to specify output of Cobol  */
               e_last_language     /*!< upper bound on the range of values supported for the outputLanguageOption_enum */
             };

public:
          enum standard_enum 
             {
               e_default_standard,
               e_c89_standard,
               e_c90_standard,
               e_c99_standard,
               e_c11_standard,
               e_c14_standard,
               e_c18_standard,
               e_upc_standard,
               e_cxx98_standard,
               e_cxx03_standard,
               e_cxx11_standard,
               e_cxx14_standard,
               e_cxx17_standard,
               e_cxx20_standard,
               e_upcxx_standard,
               e_f77_standard,
               e_f90_standard,
               e_f95_standard,
               e_f03_standard,
               e_f08_standard,
               e_f18_standard
             };

public:
          enum standard_enum get_standard(void) const;
          void set_standard(enum standard_enum e_std);
          void set_default_standard(void);

       // DQ (1/10/2019): Add way to output a string to report standard in debug messages.
          std::string display_standard(enum standard_enum e_std);

          bool is_gnu_standard(void) const;
          void set_gnu_standard();
          void unset_gnu_standard();

          bool get_C89_only (void) const;
          void set_C89_only (void);

          bool get_C89_gnu_only (void) const;
          void set_C89_gnu_only (void);

          bool get_C90_only (void) const;
          void set_C90_only (void);

          bool get_C90_gnu_only (void) const;
          void set_C90_gnu_only (void);

          bool get_C99_only (void) const;
          void set_C99_only (void);

          bool get_C99_gnu_only (void) const;
          void set_C99_gnu_only (void);

          bool get_C11_only (void) const;
          void set_C11_only (void);

          bool get_C11_gnu_only (void) const;
          void set_C11_gnu_only (void);

          bool get_C14_only (void) const;
          void set_C14_only (void);

          bool get_C14_gnu_only (void) const;
          void set_C14_gnu_only (void);

          bool get_C18_only (void) const;
          void set_C18_only (void);

          bool get_C18_gnu_only (void) const;
          void set_C18_gnu_only (void);

          bool get_UPC_only (void) const;
          void set_UPC_only (void);

          bool get_Cxx98_only (void) const;
          void set_Cxx98_only (void);

          bool get_Cxx98_gnu_only (void) const;
          void set_Cxx98_gnu_only (void);

          bool get_Cxx03_only (void) const;
          void set_Cxx03_only (void);

          bool get_Cxx03_gnu_only (void) const;
          void set_Cxx03_gnu_only (void);

          bool get_Cxx11_only (void) const;
          void set_Cxx11_only (void);

          bool get_Cxx11_gnu_only (void) const;
          void set_Cxx11_gnu_only (void);

          bool get_Cxx14_only (void) const;
          void set_Cxx14_only (void);

          bool get_Cxx14_gnu_only (void) const;
          void set_Cxx14_gnu_only (void);

          bool get_Cxx17_only (void) const;
          void set_Cxx17_only (void);

          bool get_Cxx17_gnu_only (void) const;
          void set_Cxx17_gnu_only (void);

          bool get_Cxx20_only (void) const;
          void set_Cxx20_only (void);

          bool get_Cxx20_gnu_only (void) const;
          void set_Cxx20_gnu_only (void);

          bool get_UPCxx_only (void) const;
          void set_UPCxx_only (void);

          bool get_F77_only     (void) const;
          void set_F77_only     (void);

          bool get_F90_only     (void) const;
          void set_F90_only     (void);

          bool get_F95_only     (void) const;
          void set_F95_only     (void);

          bool get_F2003_only   (void) const;
          void set_F2003_only   (void);

          bool get_F2008_only   (void) const;
          void set_F2008_only   (void);

          bool get_F2018_only   (void) const;
          void set_F2018_only   (void);

public:

      //! The only useful constructor (the argc and argv are the user's command line inputs and the
      //! errorCode is the return value assembled from the multiple error codes associated with the 
      //! different phases of the compilation.  The fileNameIndex is the index into the list of
      //! file names input on the user's command line.  We need a way to process them individually!
          SgFile ( int & argc, char** & argv,  SgProject* project = NULL );
          SgFile(std::vector<std::string>& argv,  SgProject* project = NULL);

       // SgFile ( int & argc, char** & argv, int & errorCode, int fileNameIndex, SgProject* project );
       //   virtual void doSetupForConstructor(const std::vector<std::string>& argv, int& errorCode, int fileNameIndex, SgProject* project);
       //AS(10/04/08) Changed semantics of doSetupForConstructor to not call frontend
          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project);

      //! Default constructor (not meant to be used)
      //  SgFile() ROSE_DEPRECATED_FUNCTION;

      //! Destructor
      // ~SgFile();

      //! Initialization support for constructors
          void initialization ();

      //! Unparsing support for generating C++ code from the internal Abstract Syntax Tree (AST)
      //  void unparsestdout();

      //! Unparsing support for generating C++ code from the internal Abstract Syntax Tree (AST)
      //  void unparse ( std::ostream & os );

       // Root of the Abstract Syntax Tree (AST) representing this file 
       // (a Sg global declaration scope statement).
       // SgGlobal & root() ROSE_DEPRECATED_FUNCTION;

      //! Root of the Abstract Syntax Tree (AST) representing this file 
       // DQ (7/19/2005): Added to support future name change from "root"
       // SgGlobal* get_globalScope() const;

       // DQ (9/5/2008): Support for older name of the SgGlobal in SgSourceFile
       // SgGlobal* get_root() const;

       // DQ (3/18/2006): Modified the unparse function interface to permit specification of default 
       // arguments to control code generation formatting and use of alternative code generation 
       // approaches (copy based code generation).
       // void unparse ();
      //! Generate the C++ file representing the AST
          void unparse ( UnparseFormatHelp *unparseHelp = NULL, UnparseDelegate* unparseDelagate = NULL );

       // DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information) 
       // to be relative to the generated code instead of the original input code.  This is useful when 
       // we want to output references to the position of language constructs in the generated code
       // instead of the original input code.  Also useful for building references to locations in 
       // automatically generated code.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      //! Member function to compile the resulting output file from unparsing
      //  BP : 11/13/2001, modified to include compiler name
      //  int compileOutput ( int fileNameIndex, const std::string& compilerName );
         int compileOutput ( int fileNameIndex );

       // function to generate PDF output file for AST
       // void outputPDF();

      //! associated filename
          std::string getFileName() const;

      //! Move this function from ROSE into the AST restructuring tool
       // friend void roseDisplayMechanism( SgFile *file );

// #ifndef ROSE_USE_SWIG_SUPPORT
#ifndef SWIG
       // DQ (3/10/2013): This function is left undefined in the final link step for SWIG support, so remove it from SWIG processing for now.
          friend void alternativeSageEdgInterfaceConstruction( SgFile *file );
#endif

      //! Move this function from ROSE into the AST restructuring tool
       // int callFrontEnd ( int & argc, char** & argv , SgFile & file, int fileNameIndex );
       // int callFrontEnd ( int & argc, char** & argv );

       // Get the commandline from where it is stored internally
          virtual int callFrontEnd();

      //! Fixups to be run when the whole project has been created (this attaches preprocessing information).
       // GB (9/4/2009)
          void secondaryPassOverSourceFile();

       // DQ (9/2/2008): Added to factor out detail fo building the AST in callFrontEnd().
          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! Move this function from ROSE into the AST restructuring tool
          void processRoseCommandLineOptions ( std::vector<std::string>& argv );

       // DQ (6/21/2005): Added support for backend specific command-line options to be recognized in ROSE 
       // (required to control template instantiation).  Does not modify input parameters.
          void processBackendSpecificCommandLineOptions ( const std::vector<std::string>& argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all rose related options from a command line
          static void stripRoseCommandLineOptions ( std::vector<std::string> & argv );

       // DQ (6/17/2005): I think that this should be a static function and perhaps moved to SgProject instead of in SgFile
      //! function that removes all EDG related options from a command line
          static void stripEdgCommandLineOptions ( std::vector<std::string> & argv );

       // DQ (4/2/2011): Added Fortran specific support to filter command line options from the backend compiler's command line.
      //! function that removes all OFP related options from a command line
          static void stripFortranCommandLineOptions ( std::vector<std::string> & argv );

       // BP : 11/13/2001, modified to take compiler name
          void build_EDG_CommandLine ( std::vector<std::string> & inputCommandLine, std::vector<std::string>& argv, int fileNameIndex );

       // TV: 02/15/12, CLANG also need a command line builder
          void build_CLANG_CommandLine ( std::vector<std::string> & inputCommandLine, std::vector<std::string>& argv, int fileNameIndex );

      //! Move this function from ROSE into the AST restructuring tool
      //  friend void pdfPrintAbstractSyntaxTreeEDG  ( SgFile *file, bool writeOutHeaderFiles = false );
      //  friend void pdfPrintAbstractSyntaxTreeEDG  ( SgFile *file );
      //  friend void pdfPrintAbstractSyntaxTreeSage ( SgFile *file, bool writeOutHeaderFiles = false );

       // Move this function from ROSE into the AST restructuring tool (placed here os it can be called)
          static void usage ( int status );

      //! Move this function from ROSE into the AST restructuring tool
          std::string getWorkingDirectory ();
          std::string getSourceDirectory  ();

      //! Generate an output filename from the source file name (xxx.C -> rose_xxx.C -> xxx.o -> xxx)
          std::string generateOutputFileName() const;

       // DQ (9/24/2013): I think this is more useful as a static function (and I need it this way in the unparser).
      //! Support for C preprocessed files (Fortran only).
       // std::string generate_C_preprocessor_intermediate_filename( std::string filename );
          static std::string generate_C_preprocessor_intermediate_filename( std::string filename );

       // The unparser and vendor compiler needs access to many variables
       // that are protected (Later this should be a member function).
       // friend void unparseFile ( SgFile & file );
       // friend int compileOutput ( int & argc, char** & argv, SgFile & file );
       // BP : 11/13/2001, modified to include compiler name
          std::vector<std::string> buildCompilerCommandLineOptions ( std::vector<std::string> & argv, int fileNameIndex, const std::string& compilerName );
       // BP : 11/13/2001, modified to include compiler name
       // int compileOutput ( std::vector<std::string> & argv, int fileNameIndex, const std::string& compilerName );
          int compileOutput ( std::vector<std::string> & argv, int fileNameIndex );

          void display ( const std::string & label ) const;

      //! Test if project is compiled with -prelink as signal that we are prelinking and we have 
      //! to process the generated code instead of the user's application (to see and instatiate 
      //! all templates).
          bool isPrelinkPhase() const;

      //! Get the SgProject IR node if available (template instantiation information is stored there)
          SgProject* get_project();

       // DQ (1/17/2006): Build an explicit copy constructor that returns an error internally
          SgFile ( const SgFile & X );

       // DQ (1/18/2006): Added function to be match virtual function on SgNode
       // (so that the SgFile's Sg_File_Info object could be accessed).
       // Sg_File_Info* get_file_info(void) const;

      //! Sets up the source file name (there should only be one source file in the 
      //! commandline to a SgFile, there can be multiple ones to a SgProject).
      //    void setupSourceFilename ( const std::vector<std::string>& argv );

      //! Access function calling get_startOfConstruct(), provided to support older interface.
          Sg_File_Info* get_file_info() const $ROSE_OVERRIDE;

      //! Access function calling set_startOfConstruct(), provided to support older interface.
          void set_file_info( Sg_File_Info* fileinfo );

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This function is called at several locations to build SgSourceFiles of different types (languages).
          void initializeSourcePosition( const std::string & sourceFilename );

       // DQ (2/5/2009): This is now a data member at SgProject and SgFile.
       // DQ (2/4/2009): Added the data member to the SgProject and tha access function to the SgFile,
       // it was previously reversed.
       // bool get_binary_only (void) const;

       // DQ (6/13/2013): Added to support to call the frontend after all SgFiles are built up.
          void runFrontend(int & nextErrorCode);

#if 0
// DQ (9/5/2008): Moved to SgSourceFile
#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
#endif

       // DQ (9/24/2013): Added function to output the name of the language for the generated code.
       // static std::string get_outputLanguageOptionName ( outputLanguageOption_enum lang );
          static std::string get_outputLanguageOptionName ( languageOption_enum lang );

       // DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented 
       // as a static member variable instead of non-static member variable.  See test2015_141.c 
       // for whare this is required.
          static void set_skip_unparse_asm_commands( bool b );
          static bool get_skip_unparse_asm_commands();

HEADER_APPLICATION_FILE_END

HEADER_APPLICATION_SOURCE_FILE_START
#ifndef ROSE_SKIP_COMPILATION_OF_WAVE
     public:
       // King84 (2010.09.22): Added support for getting the preprocessed token stream and the raw token stream.
          typedef boost::wave::cpplexer::lex_token<>  token_type;
          typedef std::list<token_type>             LexTokenList;
     protected:
          LexTokenList rawTokenStream;
     public:
          LexTokenList& get_rawTokenStream() { return rawTokenStream; }
#else
     public:
#endif

       // SgSourceFile ( int & argc, char** & argv, int & errorCode, int fileNameIndex = 0, SgProject* project = NULL );
          SgSourceFile(std::vector<std::string>& argv, SgProject* project = NULL);
          virtual int callFrontEnd() $ROSE_OVERRIDE;
       // SgSourceFile ( const SgSourceFile & X );

      //! Default constructor (not meant to be used)
       // SgSourceFile() ROSE_DEPRECATED_FUNCTION;

          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine ) $ROSE_OVERRIDE;
// #ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT // Liao 6/25/2010, support enable-only-c and haskell

      //! Divide up the handling of different languages
          int build_Fortran_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

      //! Support for processing Java source files.
          int build_Java_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
// #endif
          int build_C_and_Cxx_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_PHP_AST();
          int build_Python_AST();
          int build_X10_AST(const std::vector<std::string>& p_argv);

       // DQ (8/25/2017): Adding multiple langauge support (function definitions in src/frontend/SageIII/sage_support/sage_support.cpp).
          int build_Csharp_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_Ada_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_Jovial_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );
          int build_Cobol_AST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine );

          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project) $ROSE_OVERRIDE;

       // DQ (12/19/2008): Added support for translation source position information using CPP linemarkers (this is specific to Fortran).
          void processCppLinemarkers();

       // DQ (12/13/2012): Added support for more translation source position information using CPP linemarkers (this is not specific to Fortran).
       // void gatherASTSourcePositionsBasedOnDetectedLineDirectives();
          void fixupASTSourcePositionsBasedOnDetectedLineDirectives(std::set<int> equivalentFilenames);

       // DQ (9/5/2008): Support for older name of the SgGlobal in SgSourceFile
       // SgGlobal* get_root() const;

       // DQ (12/23/2008): This sets up the Sg_File_Info in the SgFile and initializes it with the correct name etc.
       // This should be the only place where the SgGlobal (global scope object) is built.
          void initializeGlobalScope();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (10/28/2013): Abstract access to the new token subsequence map (currently for statements).
       // map<SgNode*,TokenStreamSequenceToNodeMapping*> tokenStreamSequenceMap;
          void set_tokenSubsequenceMap(std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenStreamSequenceMap);
          std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & get_tokenSubsequenceMap();

       // DQ (11/27/2013): Added support for definition of the token unparsing frontier in the AST.
       // void set_token_unparse_frontier(std::vector<FrontierNode*> & tokenStreamSequenceMap);
       // std::vector<FrontierNode*> & get_token_unparse_frontier();
          void set_token_unparse_frontier(std::map<SgStatement*,FrontierNode*> & tokenStreamSequenceMap);
          std::map<SgStatement*,FrontierNode*> & get_token_unparse_frontier();

       // DQ (11/27/2013): Added support for adjacency of nodes in the unparsing frontier in the AST.
          void set_token_unparse_frontier_adjacency(std::map<SgNode*,PreviousAndNextNodeData*> & tokenStreamSequenceMap);
          std::map<SgNode*,PreviousAndNextNodeData*> & get_token_unparse_frontier_adjacency();

       // DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
          void set_redundantlyMappedTokensToStatementMultimap(std::multimap<int,SgStatement*> & X);
          std::multimap<int,SgStatement*> & get_redundantlyMappedTokensToStatementMultimap();

       // DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
          std::set<int> & get_redundantTokenEndingsSet();
          void set_redundantTokenEndingsSet(std::set<int> & X);

       // DQ (9/28/2018): Removed static keyword (I don't think we wnat this to be a static function.
       // DQ (11/20/2015): Added support for retrieving representative whitespace in unparsing transformations when using the token-based unparsing.
       // static void set_representativeWhitespaceStatementMap(std::map<SgScopeStatement*,SgStatement*> & representativeWhitespaceStatementMap);
       // static std::map<SgScopeStatement*,SgStatement*> & get_representativeWhitespaceStatementMap();
          void set_representativeWhitespaceStatementMap(std::map<SgScopeStatement*,SgStatement*> & representativeWhitespaceStatementMap);
          std::map<SgScopeStatement*,SgStatement*> & get_representativeWhitespaceStatementMap();

       // DQ (9/28/2018): Removed static keyword (I don't think we wnat this to be a static function.
       // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.
       // static void set_macroExpansionMap(std::map<SgStatement*,MacroExpansion*> & macroExpansionMap);
       // static std::map<SgStatement*,MacroExpansion*> & get_macroExpansionMap();
          void set_macroExpansionMap(std::map<SgStatement*,MacroExpansion*> & macroExpansionMap);
          std::map<SgStatement*,MacroExpansion*> & get_macroExpansionMap();

#if 0
       // DQ (9/12/2009): Adding support for new name qualification (not ready yet).
       // typedef std::vector<SgNode*> NumberToStatementType;
       // void buildStatementNumbering( NumberToStatementType & numberToStatementContainer );
          void buildStatementNumbering();
#endif

HEADER_APPLICATION_SOURCE_FILE_END


HEADER_INCLUDE_FILE_START
HEADER_INCLUDE_FILE_END


HEADER_HEADER_FILE_REPORT_START
     private:
       // Define these as private so that we can control and/or eliminate their use.
       // SgHeaderFileReport( const SgHeaderFileReport & X );
       // SgHeaderFileReport & operator= ( const SgHeaderFileReport & X );

     public:
          void display( const std::string & label) const;

       // SgHeaderFileReport( SgSourceFile* sourceFile );

HEADER_HEADER_FILE_REPORT_END


HEADER_APPLICATION_BINARY_FILE_START
        private:
                friend class boost::serialization::access;

                template<class S>
                void serialize(S &s, const unsigned /*version*/) {
                     s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgFile);
                     s & BOOST_SERIALIZATION_NVP(p_genericFileList);
                     s & BOOST_SERIALIZATION_NVP(p_interpretations);
                }

     public:
       // SgBinaryComposite ( int & argc, char** & argv, int & errorCode, int fileNameIndex = 0, SgProject* project = NULL );
          SgBinaryComposite(std::vector<std::string>& argv,  SgProject* project = NULL);
       // SgBinaryComposite ( const SgBinaryFile & X );

          virtual int callFrontEnd() $ROSE_OVERRIDE;
      //  Default constructor (not meant to be used)
      //  JJW (9/5/2008): the normal constructor has defaults for all of its arguments, so this is ambiguous
      //  SgBinaryComposite() ROSE_DEPRECATED_FUNCTION;

          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project) $ROSE_OVERRIDE;

          virtual int buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine ) $ROSE_OVERRIDE;

      //! However, now we have a list of them to support library archives which contain multiple object files (*.o's).
          const SgAsmGenericFile* get_binaryFile() const;
          SgAsmGenericFile* get_binaryFile();
          void set_binaryFile( SgAsmGenericFile* file );

       //! This is refactored code, called once for a binary executable, and called on each object file for a library archive.
          void buildAsmAST( std::string executableFileName );
HEADER_APPLICATION_BINARY_FILE_END

HEADER_APPLICATION_UNKNOWN_FILE_START
     public:
          SgUnknownFile(std::vector<std::string>& argv, SgProject* project = NULL);

          virtual int callFrontEnd() $ROSE_OVERRIDE;
          virtual void doSetupForConstructor(const std::vector<std::string>& argv, SgProject* project) $ROSE_OVERRIDE;

HEADER_APPLICATION_UNKNOWN_FILE_END



HEADER_APPLICATION_FILE_LIST_START
     public:

HEADER_APPLICATION_FILE_LIST_END


HEADER_APPLICATION_DIRECTORY_START
     public:
          int numberOfFiles() const;
          SgFile* get_file(int i) const;

          int numberOfDirectories() const;
          SgDirectory* get_directory(int i) const;

          void post_construction_initialization() $ROSE_OVERRIDE;

HEADER_APPLICATION_DIRECTORY_END


HEADER_APPLICATION_DIRECTORY_LIST_START
     public:

HEADER_APPLICATION_DIRECTORY_LIST_END


HEADER_JAVA_IMPORT_STATEMENT_LIST_START
     public:

HEADER_JAVA_IMPORT_STATEMENT_LIST_END


HEADER_JAVA_CLASS_DECLARATION_LIST_START
     public:

HEADER_JAVA_CLASS_DECLARATION_LIST_END


HEADER_APPLICATION_PROJECT_START


      /*! Template Instantiation Options */
          enum template_instantiation_enum
             {
               e_unknown  = 0, /*!< error value */
               e_default  = 1, /*!< default value */
               e_none     = 2, /*!< no template instantiation */
               e_used     = 3, /*!< instantiate only templates that are used */
               e_all      = 4, /*!< instantiate all possible templates */
               e_local    = 5, /*!< instantiate only used templates and instantiate them as local entities */
               e_last          /*!< last value (used for error checking) */
             };

      //! The only useful constructors (constant folding in the frontend is false by default).
          SgProject ( const std::vector<std::string>& argv, bool frontendConstantFolding = false);
          SgProject ( int argc, char** argv, bool frontendConstantFolding = false);

#if 0
      // DQ (10/16/2005): Depreicated a long time ago, removed it now!
      //! Deprecated old constructor (test use of gnu attribute (requires gnu 3.1+))
       // SgProject ( int &argc, char** argv, int & errorCode);
          SgProject ( int &argc, char** argv, int & errorCode) ROSE_DEPRECATED_FUNCTION;
#endif

       // DQ (4/10/2017): Adding support for use of Saywer for command line handling.
      //! Use of Saywer support for command line handling (work in progress).
          std::vector<std::string> parseCommandLine(std::vector<std::string> argv);

       // DQ (4/10/2017): Adding support for use of Saywer for command line handling.
       // Sawyer::CommandLine::SwitchGroup commandLineSwitches();

      //! Use of Saywer support for specification of ROSE specific command line switches (work in progress).
          Sawyer::CommandLine::SwitchGroup frontendAllSwitches();
          Sawyer::CommandLine::SwitchGroup backendAllSwitches();

      //! process command line and store options in the SgProject object. This options are used by parse und unparse.
          void processCommandLine(const std::vector<std::string>& argv);
          void processCommandLine(int argc, char** argv) { processCommandLine(std::vector<std::string>(argv, argv + argc)); }

      //! parse input file(s)
          int parse();

      //! processes command line and parses all files.
      //! Error code can be accessed using get_frontendErrorCode()
          int parse (const std::vector<std::string>& argv);
          int parse (int argc, char** argv) { return parse(std::vector<std::string>(argv, argv + argc)); }

     public:

      //! default constructor (not meant to be used)
          SgProject();

      //! Copy constructor (shallow copy, does not do deep copy of the AST)
          SgProject( const SgProject & project );

      //! Destructor
      // ~SgProject();

      //! The total number of files in this project (equal to the number of source files specified on the command line)
          int numberOfFiles() const;

      //! Total number of directories in the project.
          int numberOfDirectories() const;

      //! Access function for retriving a SgFile object from the list stored internally
      //! This function is depricated and "operator[unsigned int]" should be used instead.
          SgFile & get_file ( int i ) const ROSE_DEPRECATED_FUNCTION;

      //! Access function for putting a new SgFile object into the list stored internally
      //! This function is depricated and "get_fileList->push_back(SgFile*)" should be used instead.
          void set_file ( SgFile & file ) ROSE_DEPRECATED_FUNCTION;

      //! Intended for use with the -rose:keep_going commandline option.
      //! \returns A list of files that encountered an error within either
      //!          the frontend, unparser, or backend compilation.
          SgFilePtrList get_files() const;
          SgFilePtrList get_files_with_errors() const;
          SgFilePtrList get_files_without_errors() const;

      //! Access function for retriving a SgFile object from the list stored internally
          SgFile* operator[]( unsigned int i );

      //! Access function for retriving a SgFile object from the list stored internally, but using the filename with full path.
          SgFile* operator[]( std::string filename );

      //! function to generate output for all files in the project (arguments control code generation)
       // void unparse();
          void unparse ( UnparseFormatHelp *unparseFormatHelp = NULL, UnparseDelegate* unparseDelegate = NULL );

       // DQ (5/8/2010): Added support for resetting the source position information.
          void resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp = NULL );

      // DQ (10/14/2010): Removing reference to macros defined in rose_config.h.
      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to compile the output from unparsing the project
       // BP : 11/13/2001, modified to take compiler name
       // int compileOutput( char *compilerName = CXX_COMPILER_NAME );
       // int compileOutput( const std::string& compilerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );
          int compileOutput();
          int RunFrontend();

      // DQ (10/14/2010): Removing reference to macros defined in rose_config.h.
      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to preform linking!
       // int link ( std::string linkerName = CXX_COMPILER_NAME );
       // int link ( std::string linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );
          int link ( std::string linkerName );

      // DQ (10/14/2010): Removing reference to macros defined in rose_config.h.
      // DQ (8/29/2005): Added support for classification of back-end compilers (independent of the name invoked to execute them)
      //! function to preform linking!
       // int link ( int argc, char** argv, std::string linkerName = CXX_COMPILER_NAME );
       // int link ( const std::vector<std::string>& argv, std::string linkerName = BACKEND_CXX_COMPILER_NAME_WITH_PATH );
          int link ( const std::vector<std::string>& argv, std::string linkerName );

       // function to generate PDF output file for AST
       // void outputPDF();

      //! global concept of verbose level which controls useful output from the compiler (values greater than zero increase output level)
          static int p_verbose;

      //! Save the command line arguments (argc and argv) for the project (these are needed to process transformations)
       // static int project_argc;
       // static char** project_argv;

       // DQ (9/2/2008): Removed this redundant function
       // DQ: Get list of file names in project (generated from the list of SgFile nodes)
       // I think this is redundant with the other lists of filenames!
       // Rose_STL_Container<std::string> getFileNames() const;

      //! This function generates a list of files resolved to absolute paths (symbolic links should not be resolved).
          Rose_STL_Container<std::string> getAbsolutePathFileNames() const;

      //! DQ: Modified to accept a value on the command line (no longer a boolean variable)
      //! value of 0 means quiet and higher values output more information, default value 
      //! is zero (quiet).
          static int get_verbose (void);
          static void set_verbose (int);

       // DQ: bool values on the SgFile nodes which can be queried on the SgProject
       // nodes (must be the same across all SgFile nodes in the project).
          bool get_skip_translation_from_edg_ast_to_rose_ast (void) const;
          bool get_skip_transformation (void) const;
          bool get_skip_unparse (void) const;
          bool get_useBackendOnly (void) const;

       // DQ (4/6/2010): Added to support parsing only option.
          bool get_exit_after_parser(void) const;

       // DQ (12/28/2010): Added to support skipping compilation in backendCompilesUsingOriginalInputFile()
          bool get_skipfinalCompileStep (void) const;

          void set_C_only       (bool value);
          bool get_C_only   (void) const;

          bool get_C89_only (void) const;
          bool get_C89_gnu_only (void) const;
          bool get_C90_only (void) const;
          bool get_C90_gnu_only (void) const;
          bool get_C99_only (void) const;
          bool get_C99_gnu_only (void) const;
          bool get_C11_only (void) const;
          bool get_C11_gnu_only (void) const;
          bool get_C14_only (void) const;
          bool get_C14_gnu_only (void) const;

          void set_Cxx_only     (bool value);
          bool get_Cxx_only (void) const;

          bool get_Cxx98_only (void) const;
          bool get_Cxx98_gnu_only (void) const;
          bool get_Cxx03_only (void) const;
          bool get_Cxx03_gnu_only (void) const;
          bool get_Cxx11_only (void) const;
          bool get_Cxx11_gnu_only (void) const;
          bool get_Cxx14_only (void) const;
          bool get_Cxx14_gnu_only (void) const;
          bool get_Cxx17_only (void) const;
          bool get_Cxx17_gnu_only (void) const;

          void set_Fortran_only (bool value);
          bool get_Fortran_only (void) const;

          bool get_F77_only     (void) const;
          bool get_F90_only     (void) const;
          bool get_F95_only     (void) const;
          bool get_F2003_only   (void) const;
          bool get_F2008_only   (void) const;
          bool get_F2018_only   (void) const;
          bool get_CoArrayFortran_only (void) const;


          bool get_PHP_only(void) const;

          bool get_Python_only(void) const;

          bool get_Java_only (void) const;
          void set_Java_only (bool value);
          std::list<std::string> get_Java_classpath (void) const;
          void set_Java_classpath (std::list<std::string> param);
          std::list<std::string> get_Java_sourcepath (void) const;
          void set_Java_sourcepath (std::list<std::string> param);
          std::string get_Java_destdir (void) const;
          void set_Java_destdir (std::string param);
          std::string get_Java_source_destdir (void) const;
          void set_Java_source_destdir (std::string param);

          bool get_X10_only (void) const;
          void set_X10_only (bool value);

       // DQ (8/25/2017): Added more language support.
          bool get_Csharp_only (void) const;
       // void set_Csharp_only (bool value);

       // DQ (8/25/2017): Added more language support.
          bool get_Ada_only (void) const;
       // void set_Ada_only (bool value);

       // DQ (8/25/2017): Added more language support.
          bool get_Jovial_only (void) const;
       // void set_Jovial_only (bool value);

       // DQ (8/25/2017): Added more language support.
          bool get_Cobol_only (void) const;
       // void set_Cobol_only (bool value);

       // DQ (2/4/2009): This is now a data member at the SgProject and so is automatically generated asa member function.
       // bool get_binary_only (void) const;

          void display ( const std::string & label ) const;

          void initialization();

          friend std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<std::string> & l );

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

          void skipfinalCompileStep(bool value);

          SgStringList & get_includePathList();
          const SgStringList & get_includePathList() const;
          void set_includePathList(const SgStringList & includePathList);

          SgStringList & get_excludePathList();
          const SgStringList & get_excludePathList() const;
          void set_excludePathList(const SgStringList & excludePathList);

          SgStringList & get_includeFileList();
          const SgStringList & get_includeFileList() const;
          void set_includeFileList(const SgStringList & includeFileList);

          SgStringList & get_excludeFileList();
          const SgStringList & get_excludeFileList() const;
          void set_excludeFileList(const SgStringList & excludeFileList);

       // negara1 (07/29/2011)
          std::string findIncludedFile(PreprocessingInfo* preprocessingInfo);

          int get_detect_dangling_pointers(void) const;

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
#else
       // DQ (1/21/2010): In this case we want to support the previous interface so that we can transition easily.
          SgFilePtrList & get_fileList() const;
          void set_fileList(SgFilePtrList & fileList);
#endif

       // DQ (8/3/2018): Added support for evaluation of options at the project level (which are normally associated with files).
          bool get_unparse_tokens (void) const;
       // void set_unparse_tokens (bool value);



HEADER_APPLICATION_PROJECT_END


HEADER_OPTIONS_START
  // In general we avoid the definition of member function within the class declaration!
  // This is a minor divergence upon this policy.

     friend class Sg_Options& Sg_options();
     public:
          inline std::ostream& default_output()      { return *p_default_output;}
          inline void set_default_output(std::ostream& os){ p_default_output = &os;}

          inline std::ostream& debug_output()        { return *p_debug_output;}
          inline void set_debug_output(std::ostream& os)  { p_debug_output = &os;}

          inline std::ostream& error_output()        { return *p_error_output;}
          inline void set_error_output(std::ostream& os)  { p_error_output = &os;}

          inline std::ostream& logging_output()      { return *p_logging_output;}
          inline void set_logging_output(std::ostream& os){ p_logging_output = &os;}

          inline int debug_level()         {return p_debug_level;}
          inline void set_debug_level(int l) { p_debug_level = l; }

          inline int logging_level() {return p_logging_level;}
          inline void set_logging(std::ostream& log_file, int level) 
             { p_logging_level = level; p_logging_output = &log_file; }
#if 0
  // We need a option to permit the generated constructors to be protected or private
     private:
          Sg_Options(); /* to stop anyone but Sg_options() instantiating it */
#endif

HEADER_OPTIONS_END


HEADER_UNPARSE_INFO_START
       // This class defines it's data explicitly so that the explicitly defined 
       // member access functions will be used and none will be generated!

       // Default constructor defined here because the automatically generated constructor
       // would not be generated with the error checking that I require to debug the use of
       // the SgUnparse_Info object as an inherited attribute in the unparser.
          SgUnparse_Info ();

          SgUnparse_Info ( const SgUnparse_Info & X );
          SgUnparse_Info & operator= ( const SgUnparse_Info & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

       // DQ (4/16/2003): Notes on how to improve the unparser:
       // Rather than having an inherited attribute that stores some context information 
       // and clearer approach would be to have an inherited attribute that stored all 
       // the context information.  The SgUnparse_Info object should be abandoned for 
       // the use of a persistant attribute built using an initial traversal (to set them)
       // over the entire tree.  Such a traversal would have to visit every node of 
       // the AST, because the unparser has to visit every node.

       // DQ (12/6/2003) Need to use a vector<bool> type to store flags so that we can include
       // more flags that permited in a 32bit long integer.  We used long long for a while, but 
       // this does not work with the 3.x gnu g++ compiler (and C++ does not allow enum values to
       // be more than long (32 bits on many machines, Intel x86).  Modifying the implementation
       // to use an STL vector<bool> type permits an unlimited number of flags (for future growth).

      /*! \brief Options available for unparsing the AST to generate source code

          These options can be set or unset and are passed from each unparse function to any 
          called unparse functions.  Sometimes a new unparse info object is generated, always 
          using the copy constructor, so that the options can be modified for unparsing 
          different parts of the AST.

          \internal This is implemented as a bit vector since it is over 32 bits.
       */
          enum unparse_type_num
             {
            //! DQ (11/4/2003): Build a default value to support initialization
               b_enum_defaultValue            = 0, /*!< default value */
            //! to postponing the printing of name for ptr of function or array etc
               b_isPointerToSomething         = 1, /*!< postponing the printing of name for ptr of function or array etc */
               b_isReferenceToSomething       = 2, /*!< postponing the printing of name for ptr of function or array etc */
            //! if it is in Variable Declaration, output either , or ; for SgExprStmt
               b_inVarDecl                    = 3, /*!< if it is in Variable Declaration, output either , or ; for SgExprStmt */
            //! in a function header, output type+ symbol 
               b_inArgList                    = 4, /*!< in a function header, output type+ symbol */
            //! no ';' for declaration statement
               b_SkipSemiColon                = 5, /*!< no ';' for declaration statement */
            //! to setup for printing of enum var in a VariableDeclaration
               b_inEnumDecl                   = 6, /*!< setup for printing of enum var in a VariableDeclaration */
            //! not really being used (yet)
               b_inTemplateList               = 7, /*!< not really being used (yet) */
            //! suppress printing of the base type
               b_SkipBaseType                 = 8, /*!< suppress printing of the base type */
            //! for skip "=" if in aggregate initializer
               b_inAggregateInitializer       = 9, /*!< skip "=" if in aggregate initializer */
            //! for print both type & sym name
               b_isWithType                   = 10, /*!< print both type and sym name */
            //! it is in conditional expr
               b_inConditional                = 11, /*!< is in conditional expr (context information) */
            //! skip printing definition part of a declaration
               b_SkipDefinition               = 12, /*!< skip output of definitions (sets b_SkipEnumDefinition, b_SkipFunctionDefinition, and b_SkipClassDefinition */
            //! need to put in either class/struct/union keyword 
               b_SkipClassSpecifier           = 13, /*!< skip the class specifier (modifier) */
            //! printing something within a variable declaration
               b_inEmbeddedDecl               = 14, /*!< printing something within a variable declaration */
            //! suppress the printing of global and atomic
               b_SkipGlobal                   = 15, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
               b_SkipAtomic                   = 16, /*!< suppress the printing of global and atomic (hold over from CC++, I think (not used) */
            //! used by set/unsetName and set/unsetPrintName to bring down the
            //! Name to lower tree structure
               b_PrintName                    = 17, /*!< used by set/unsetName and set/unsetPrintName to bring down the Name to lower tree structure */
            //! to set the need to check if need access specifier (avoids redundently specific access modifiers)
               b_CheckAccess                  = 18, /*!< set the need to check if need access specifier */
            //! to skip function qualifiers
               b_SkipFunctionQualifier        = 19, /*!< skip function qualifiers */
            //! to show that the type above current one is an array
               b_isArrayType                  = 20, /*!< show that the type above current one is an array */
            //! to indicate that this is at the right hand side of a binary op
               b_inRhsExpr                    = 21, /*!< indicate that this is at the right hand side of a binary op */
            //! to flag the skipping of () printing in a function call
            //! this is for a bug in g++ that can not handle (P::dval->B::mfcall)()
            //! skipping the toplevel only
               b_SkipParen                    = 22, /*!< skip over output of matching "(" and ")" */
            //! for the case that this maybe a function type, separate the outputing of
            //! the type info into 2 parts, the return type part and the arg type
            //! by default this is always set to 0
               b_isTypeSecondPart             = 23, /*!< unparse only second part of type */
               b_isTypeFirstPart              = 24, /*!< unparse only first part of type */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipInitializer              = 25, /*!< skip output of initializers */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipComments                 = 26, /*!< ignore all comments in unparsing */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipCPPDirectives            = 27, /*!< ignore all C preprocessor directives (except #pragma which is in the AST) */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipEnumDefinition           = 28, /*!< skip over enum definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipFunctionDefinition       = 29, /*!< skip over the function definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_SkipClassDefinition          = 30, /*!< skip over the class definition, if available */
            //! Added by DQ to permit reuse of unparser code in generation 
            //! of declarations in rewrite mechanism
               b_AddSemiColonAfterDeclaration = 31, /*!< add ';' after declaration */
            //! MS: 09/03/02 Added by MS to make unparsing of white space optional
            //! currently only used in unparseToCompleteString (by removing whitespaces)
            //! I only added it here to follow the design but suggest to use varibles of type bool,
            //! and extend the ROSETTA code to add these attributes, and generate the access functions -
            //! unfortunately the naming scheme does not comply with ROSETTA's naming scheme for access functions.
               b_SkipWhitespaces              = 32, /*!< ignore any unrequired white space */
            //! DQ (11/3/2003): made all bit flags 64 bit long so that we could add a few
            //! more entries.  Added bit flag to control generation of prefix scope
            //! statements. This permits unparsing SgForStmt, SgWhileStmt, SgSwitchStmt,
            //! etc., without their body so that we can capture the full context of the 
            //! declarations associated with such statements.  In the case of SgSwitchStmt
            //! it also permits replacement of case statements which are specific to
            //! SgSwitchStmt basic blocks and no other basic blocks.  This verifies the 
            //! correctness of transformation specified.
               b_SkipBasicBlock               = 33, /*!< skip over the unparsing of the basic block */

           //! Templates that are modified need to be output, but all other output of a class 
           //! template only supports the output of the class template name (but in template 
           //! form, e.g. "Rose_STL_Container<int>").  If the template has not been transformed then we have 
           //! to control where it is output.  The default can't be to output the template 
           //! everywhere and then restrict it's use since the unparser can't turn that on, 
           //! so we have to restrict it everywhere and turn it on in several places.
               b_outputClassTemplateName      = 34, /*!< outputClassTemplateName */

            // DQ (5/27/2005): Added support for getting comments and directives output before any inserted 
            // compiler generated statements.
           //! Control output of compiler-generated statements (typically template specialization declarations).
           //! this allows the unparing of comments and preprocessor declarations before the compiler-generated
           //! statements appearing with any non-compiler-generated statement.
               b_outputCompilerGeneratedStatements = 35, /*!< outputCompilerGeneratedStatements */

            // DQ (4/5/2006): Added support for constant folded values to be optionally output
           //! Control output of constant folded values.
               b_SkipConstantFoldedExpressions = 36, /*!< SkipConstantFoldedExpressions */

            // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
               b_forceQualifiedNames           = 37, /*!< Force qualified names. */

            // DQ (10/11/2006): This is added to support a default where all qualified names are output.
           //! Control output of qualified names (not always wanted).
               b_SkipQualifiedNames           = 38, /*!< skip qualified names (e.g. names of defining declarations). */

           //! Control access specifiers use in generated code (public, protected, private).
               b_skipCheckAccess               = 39, /*!< Skip access specifier (different from b_CheckAccess, above) */

               b_requiresGlobalNameQualification = 40,/*!< Requires global qualifier on generated name. */

            // DQ (8/10/2006):
            // b_isAsmOutputOperand            = 40, /*!< Mark as output operand */

               b_useTypeAttributes             = 41,/*!< Fortran allows type attributes to be used in declarations (for example to dimension a collection of arrays). */

               b_SkipFormatting                = 42,/*!< Fortran code generation requires that we skip some formatting (e.g. column 7 formatting, even if fixed format output). */

            // FMZ: Added for generate fortran xxx.rose_mod file
               b_outputFortranModFile      = 43, /*!< Fortran mod file generation */

            // DQ (1/16/2011): Fortran support required.
               b_supressStrippedTypeName = 44, /*!< Unparsing of Fortran types with multiple attributes requires skipping the stripped base type name if it has already been output. */

            // DQ (4/13/2013): Added support to unparse code using overloaded operator names or operator syntax (to match the input code).
               b_prefixOperator = 45, /*!< Part of support to unparse code using overloaded operator names or operator syntax (to match the input code); this marks prefix operators to be unparsed before the LHS s output. */

            // DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
               b_supressArrayBound = 46, /*!< Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax for secondary (prototype) declarations (e.g. int array[];). */

            // DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
               b_supressImplicitThisOperator = 47, /*!< Supress output of SgThisExp (required to support lambda function code generation). */

            // DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
               b_unparsedPartiallyUsingTokenStream = 48, /*!< Record that the statement was partially unparsed using the token stream. */

            // DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
               b_skipCompilerGeneratedSubExpressions = 49, /*!< Supress compiler generated subexpressions (used to output fields in the 2nd parameter of the offsetof() function family. */

            // DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
               b_parentStatementListBeingUnparsedUsingPartialTokenSequence = 50, /*!< Controls output formatting (CR's) in mixing unparsing from token stream with unparsing from the AST. */

            // DQ (2/8/2016): Adding support for C++11 specific initialization lists.
               b_cxx11_initialization_list = 51, /*!< Indicate when we are in a C++11 specific initialization list. */

            // DQ (2/3/2019): Need to know when we are unparsing the base type within a typedef so that member pointers can be output with parenthesis (see Cxx11_tests/test2019_77.C).
           //! to setup unparsing of base types in typedef declarations (for SgPointerMemberType) which requires extra parenthesis.
               b_inTypedefDecl             = 52, /*!< setup unparsing of base types in typedef declarations (for SgPointerMemberType) which requires extra parenthesis */

            // DQ (4/13/2019): Generated strings of template instantiations need to sometimes exclude the initial name qualification to avoid it being redundantly generated, see Cxx11_tests/test2019_350.C).
               b_SkipNameQualification     = 53, /*!< Skip the use of name qualification (used in generating strings of template instantiations) */

            // DQ (12/26/2019): Use an alternative defining declaration in unparsing of named type, see Cxx11_tests/test2019_518a.C and test2019_518b.C).
            // Required to support multiple file handling, and its unparsing.
               b_useAlternativeDefiningDeclaration = 54, /*!< Skip the use of name qualification (used in generating strings of template instantiations) */

            //! DQ (12/6/2003): Added last value to use a upper bound in loops
               UNPARSE_TYPE_LAST /*!< last value used for debugging */
             };

      /*! Access modifiers for use with SgUnparseInfo (only) */
          enum access_attr_enum
             {
               a_unset_access     = 1, /*!< default value */
               a_private_access   = 2, /*!< private access value */
               a_protected_access = 3, /*!< protected access value */
               a_public_access    = 4  /*!< public access value */
             };

     private:

       // DQ (1/3/2009): This is similar code to what is in SgModifier::checkBit, setBit, unsetBit; so it could be refactored.
          bool checkBit(unparse_type_num bit) const;
          void setBit(unparse_type_num bit);
          void unsetBit(unparse_type_num bit);

     public:

       // access function to SgUnparse_Info 
          bool isUnsetAccess() const;
          void set_isUnsetAccess();
          bool isPrivateAccess() const;
          void set_isPrivateAccess();
          bool isProtectedAccess() const;
          void set_isProtectedAccess();
          bool isPublicAccess() const;
          void set_isPublicAccess();

          bool isPointerToSomething() const;
          void set_isPointerToSomething();
          void unset_isPointerToSomething();

          bool isReferenceToSomething() const;
          void set_isReferenceToSomething();
          void unset_isReferenceToSomething();
	 
          bool inVarDecl() const;
          void set_inVarDecl();
          void unset_inVarDecl();
	 
          bool inArgList() const;
          void set_inArgList();
          void unset_inArgList();
	 
          bool SkipSemiColon() const;
          void set_SkipSemiColon();
          void unset_SkipSemiColon();

          bool inEnumDecl() const;
          void set_inEnumDecl();
          void unset_inEnumDecl();

          bool inTemplateList() const;
          void set_inTemplateList();
          void unset_inTemplateList();

          bool SkipBaseType() const;
          void set_SkipBaseType();
          void unset_SkipBaseType();

          bool inAggregateInitializer() const;
          void set_inAggregateInitializer();
          void unset_inAggregateInitializer();

          bool isWithType() const;
          void set_isWithType();
          void unset_isWithType();

          bool inConditional() const;
          void set_inConditional();
          void unset_inConditional();

          bool SkipDefinition() const;
          void set_SkipDefinition();
          void unset_SkipDefinition();

          bool SkipClassSpecifier() const;
          void set_SkipClassSpecifier();
          void unset_SkipClassSpecifier();

          bool inEmbeddedDecl() const;
          void set_inEmbeddedDecl();
          void unset_inEmbeddedDecl();

          bool SkipGlobal() const;
          void set_SkipGlobal();
          void unset_SkipGlobal();

          bool SkipAtomic() const;
          void set_SkipAtomic();
          void unset_SkipAtomic();

          bool PrintName() const;
          void set_PrintName();
          void unset_PrintName();

          bool CheckAccess() const;
          void set_CheckAccess();
          void unset_CheckAccess();

          bool SkipFunctionQualifier() const;
          void set_SkipFunctionQualifier();
          void unset_SkipFunctionQualifier();

          bool isArrayType() const;
          void set_isArrayType();
          void unset_isArrayType();

          bool inRhsExpr() const;
          void set_inRhsExpr();
          void unset_inRhsExpr();

          bool SkipParen() const;
          void set_SkipParen();
          void unset_SkipParen();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Tests the setting of the flag to permit output of 2nd part of type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          bool isTypeSecondPart() const;

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Sets flag to permit output of 2nd part of type.

          This sets the flag for output of the 2nd part of a type and unsets the flag for the 1st part of the type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          void set_isTypeSecondPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Unsets the flag to permit output of 2nd part of type.

          This only unsets the flag for the output of the 2nd part of a type (no change to the flag for the 1st part of the type).

          \internal This and the isTypeFirstPart flag can both be false or only one can be true.
       */
          void unset_isTypeSecondPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Tests the setting of the flag to permit output of 1st part of type.

          \internal This and the isTypeFirstPart flag are mutually exclusive.
       */
          bool isTypeFirstPart() const;

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Sets flag to permit output of 1st part of type.

          This sets the flag for output of the 1st part of a type and unsets the flag for the 2nd part of the type.

          \internal This and the isTypeSecondPart flag are mutually exclusive.
       */
          void set_isTypeFirstPart();

       // DQ (5/10/2015): Added documentation for how these are tested, set and unset.
      /*! \brief Unsets the flag to permit output of 1st part of type.

          This only unsets the flag for the output of the 1st part of a type (not change to the flag for the 2nd part of the type).

          \internal This and the isTypeSecondPart flag can both be false or only one can be true.
       */
          void unset_isTypeFirstPart();

          bool SkipInitializer() const;
          void set_SkipInitializer();
          void unset_SkipInitializer();

          bool SkipComments() const;
          void set_SkipComments();
          void unset_SkipComments();

       // MS: 09/03/03
          bool SkipWhitespaces() const;
          void set_SkipWhitespaces();
          void unset_SkipWhitespaces();

          bool SkipCPPDirectives() const;
          void set_SkipCPPDirectives();
          void unset_SkipCPPDirectives();

          bool SkipEnumDefinition() const;
          void set_SkipEnumDefinition();
          void unset_SkipEnumDefinition();

          bool SkipFunctionDefinition() const;
          void set_SkipFunctionDefinition();
          void unset_SkipFunctionDefinition();

          bool SkipClassDefinition() const;
          void set_SkipClassDefinition();
          void unset_SkipClassDefinition();

          bool AddSemiColonAfterDeclaration() const;
          void set_AddSemiColonAfterDeclaration();
          void unset_AddSemiColonAfterDeclaration();

       // DQ (11/04/03): Added to support unparsing control flow (SgForStmt, SgSwitch,
       //                etc.) to make prefix more precise. Can't add case to anything 
       //                but switch, and capture declarations in for loops, for example.
          bool SkipBasicBlock() const;
          void set_SkipBasicBlock();
          void unset_SkipBasicBlock();

       // DQ (3/18/2004): Added to support unparsing of class templates in variables but 
       // not in in instatiated template declarations (unless the template is transformed 
       // in which case another test is used).
          bool outputClassTemplateName() const;
          void set_outputClassTemplateName();
          void unset_outputClassTemplateName();

       // DQ (5/27/2005): support (see documentation above)
          bool outputCompilerGeneratedStatements() const;
          void set_outputCompilerGeneratedStatements();
          void unset_outputCompilerGeneratedStatements();

       // DQ (4/5/2006): Added support for constant folded values to be optionally output
      //! Control output of constant folded values, the default is to ignore constant 
      //! folded values and unparse the original code (as if no constant folding were done).
      //! (default is unset)
          bool SkipConstantFoldedExpressions() const;
          void set_SkipConstantFoldedExpressions();
          void unset_SkipConstantFoldedExpressions();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool forceQualifiedNames() const;
          void set_forceQualifiedNames();
          void unset_forceQualifiedNames();

       // DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
          bool skipCheckAccess() const;
          void set_skipCheckAccess();
          void unset_skipCheckAccess();

       // DQ (10/11/2006): Added to support new implementation of name qualification
          bool SkipQualifiedNames() const;
          void set_SkipQualifiedNames();
          void unset_SkipQualifiedNames();

          bool requiresGlobalNameQualification() const;
          void set_requiresGlobalNameQualification();
          void unset_requiresGlobalNameQualification();

       // DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
          bool useTypeAttributes() const;
          void set_useTypeAttributes();
          void unset_useTypeAttributes();

          bool SkipFormatting() const;
          void set_SkipFormatting();
          void unset_SkipFormatting();

          bool supressStrippedTypeName() const;
          void set_supressStrippedTypeName();
          void unset_supressStrippedTypeName();

          std::string get_operator_name();
          void set_operator_name(const std::string& on);

          SgName& get_name();
          void set_name(const SgName& name);
          void unset_name();

          SgDeclarationStatement* get_decl_stmt();
          void set_decl_stmt(SgDeclarationStatement* stmt );
          void unset_decl_stmt();

          int get_nested_expression();
          void set_nested_expression();
          void unset_nested_expression();

       // DQ (4/13/2013): Added support to mark output of overloaded operators an prefix operators.
          bool isPrefixOperator() const;
          void set_prefixOperator();
          void unset_prefixOperator();

       // DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
          bool supressArrayBound() const;
          void set_supressArrayBound();
          void unset_supressArrayBound();

       // DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
          bool supressImplicitThisOperator() const;
          void set_supressImplicitThisOperator();
          void unset_supressImplicitThisOperator();

       // DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
          bool unparsedPartiallyUsingTokenStream() const;
          void set_unparsedPartiallyUsingTokenStream();
          void unset_unparsedPartiallyUsingTokenStream();

       // DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
          bool skipCompilerGeneratedSubExpressions() const;
          void set_skipCompilerGeneratedSubExpressions();
          void unset_skipCompilerGeneratedSubExpressions();

       // DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
          bool parentStatementListBeingUnparsedUsingPartialTokenSequence() const;
          void set_parentStatementListBeingUnparsedUsingPartialTokenSequence();
          void unset_parentStatementListBeingUnparsedUsingPartialTokenSequence();

       // DQ (2/8/2016): Adding support for C++11 specific initialization lists.
          bool get_cxx11_initialization_list() const;
          void set_cxx11_initialization_list();
          void unset_cxx11_initialization_list();

       // DQ (2/3/2019): unparsing for base type in typedefs when base type is a member pointer.
          bool inTypedefDecl() const;
          void set_inTypedefDecl();
          void unset_inTypedefDecl();

       // DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
          bool SkipNameQualification() const;
          void set_SkipNameQualification();
          void unset_SkipNameQualification();

       // DQ (12/26/2019): unparsing for defining declarations in named types defined in multiple translation units (multi-file support).
          bool useAlternativeDefiningDeclaration() const;
          void set_useAlternativeDefiningDeclaration();
          void unset_useAlternativeDefiningDeclaration();


#if 0
   // MK: These access functions are now automatically generated!
          SgNamedType *get_current_context();
          void set_current_context(SgNamedType *t);
#endif
          void unset_current_context();

          SgName get_array_index_list();

          void set_array_index_list(SgExpression *e, SgUnparse_Info finfo );
          void unset_array_index_list();

       // Support for processing of recursive references to structure tags within the data
       // structures that they define.
          void addStructureTag ( SgNamedType* structureTag );

      //! Access function for internal STL list of structure tags
          SgTypePtrList & getStructureTagList ();

       // DQ (1/9/2007): Modified to make const
          void display ( const std::string & label = "") const;
          std::string displayString ( const std::string & label ) const;

      /*! \brief Added to debug use of the default constructor 

          Added to debug use of the default constructor (to restrict it from being used so that
          we could detect where it is being used in place of the copy constructor which should
          be used to implement the SgUnparse_Info object correctly as an inherited attribute
          within the ROSE unparser.
       */
       // static bool forceDefaultConstructorToTriggerError;

       // DQ (9/6/2004): Support for list of scopes required to qualify names (e.g. types, data members, member functions, etc.)
       // SgSymbolPtrList & get_listOfScopeSymbols();
       // void set_listOfScopeSymbols ( const SgSymbolPtrList & l );

       // DQ (1/31/2006): moved static bool forceDefaultConstructorToTriggerError to be built by ROSETTA
          static bool get_forceDefaultConstructorToTriggerError();
          static void set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError);

       // FMZ (5/8/2008) Added to support to generate fortran XX.rose_mod file for a module
       // the code will based on fortran unparser code
          bool outputFortranModFile() const;
          void set_outputFortranModFile();
          void unset_outputFortranModFile();

       // driscoll6 (6/6/2011) Mutators for p_nestingLevel
          void inc_nestingLevel();
          void dec_nestingLevel();

HEADER_UNPARSE_INFO_END


HEADER_UNPARSE_POSTDECLARATION_START
//! extern declarations used by the unparser (a default object for many to reference)
// extern SgUnparse_Info SgNO_UNPARSE_INFO;

// support function declarations for unparsing
//extern void printSgVariant ( std::ostream& os, int x );
extern std::string getSgVariant ( int x);

HEADER_UNPARSE_POSTDECLARATION_END

HEADER_TEMPLATE_PARAMETER_START
     public:

       // DQ (8/10/2013): We need to unify how to reference the enum values between template parameters and template arguments.
       // enum SgTemplateArgument::template_argument_enum;
       // typedef SgTemplateArgument::template_argument_enum template_parameter_enum;

      /*! Different uses of a template parameter */
          enum template_parameter_enum
             {
               parameter_undefined = 0, /*!< undefined (error) */
               type_parameter      = 1, /*!< type parameter */
               nontype_parameter   = 2, /*!< nontype parameter */
               template_parameter  = 3  /*!< template parameter */
             };

          void post_construction_initialization() $ROSE_OVERRIDE;

       // Different constructors for use in building the different types of parameters possible
          SgTemplateParameter ( SgType* parameter               , SgType* defaultParameter );
          SgTemplateParameter ( SgExpression* parameter         , SgExpression* defaultParameter );
          SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter );

       // DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
          static bool is_matching_type    (const SgTemplateParameter & X, const SgTemplateParameter & Y);
          static bool is_matching_nontype (const SgTemplateParameter & X, const SgTemplateParameter & Y);
          static bool is_matching_template(const SgTemplateParameter & X, const SgTemplateParameter & Y);

       // DQ (5/19/2014): This is added to symetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
          static bool is_matching_template_pack_expansion (const SgTemplateParameter & X, const SgTemplateParameter & Y);

          static bool is_matching_kind    (const SgTemplateParameter & X, const SgTemplateParameter & Y);

          SgName get_mangled_name (void) const;

HEADER_TEMPLATE_PARAMETER_END

HEADER_TEMPLATE_ARGUMENT_START
     public:

      /*! Different uses of a template argument */
          enum template_argument_enum
             {
               argument_undefined               = 0, /*!< undefined (error) */
               type_argument                    = 1, /*!< type parameter */
               nontype_argument                 = 2, /*!< nontype parameter */
               template_template_argument       = 3, /*!< template template parameter */
               start_of_pack_expansion_argument = 4  /*!< start of pack expansion parameter */
             };

          void post_construction_initialization() $ROSE_OVERRIDE;

       // Different constructors for use in building the different types of parameters possible
          SgTemplateArgument ( SgType*                      parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgExpression*                parameter, bool explicitlySpecified );
       // SgTemplateArgument ( SgTemplateInstantiationDecl* parameter, bool explicitlySpecified );
          SgTemplateArgument ( SgTemplateDeclaration*       parameter, bool explicitlySpecified );

       // DQ (7/3/2013): Added new type of template argument type to support varadic template arguments.
          SgTemplateArgument ( bool explicitlySpecified );

       // RV (2/2/2006): Added mangling for template arguments.
      //! Returns the template argument in mangled form.
          SgName get_mangled_name (void) const;

      //! Some template arguments have an associated scope (e.g. named types, and template template arguments)
          SgScopeStatement* get_scope () const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (11/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the template argument type.
          SgName get_qualified_name_prefix() const;

       // DQ (7/24/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix_for_type() const;

       // DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
          static bool is_matching_type    (const SgTemplateArgument & X, const SgTemplateArgument & Y);
          static bool is_matching_nontype (const SgTemplateArgument & X, const SgTemplateArgument & Y);
          static bool is_matching_template(const SgTemplateArgument & X, const SgTemplateArgument & Y);

       // DQ (5/19/2014): This is added to symetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
          static bool is_matching_template_pack_expansion (const SgTemplateArgument & X, const SgTemplateArgument & Y);

          static bool is_matching_kind    (const SgTemplateArgument & X, const SgTemplateArgument & Y);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);

       // DQ (5/22/2016): Adding display function for debugging.
          void display( const std::string & label) const;

       // DQ (3/10/2018): Adding debugging support.
          std::string unparseToStringSupport();

       // DQ (2/10/2019): Adding debugging support.
          std::string template_argument_kind () const;

       // DQ (2/10/2019): Refactored support for template unparsing.
          bool isTemplateArgumentFromAnonymousClass() const;

       // DQ (2/11/2019): Refactored support for logic to control when template arguments are unparsed.
       // Temporarily this code is located in the unparseCxx_expressions.C file.
          void outputTemplateArgument(bool & skip_unparsing, bool & stop_unparsing);

HEADER_TEMPLATE_ARGUMENT_END


HEADER_TEMPLATE_PARAMETER_LIST_START
HEADER_TEMPLATE_PARAMETER_LIST_END

HEADER_TEMPLATE_ARGUMENT_LIST_START

       // DQ (2/10/2019): I think this IR node is no longer used.
       // DQ (3/10/2018): Adding debugging support.
       // std::string unparseToStringSupport();

HEADER_TEMPLATE_ARGUMENT_LIST_END

HEADER_OPENCL_ACCESS_MODE_MODIFIER_START

       // TV (05/03/2010): OpenCL Access Mode Support

          enum access_mode_modifier_enum
             {
               e_unknown       = 0,  /*!< error value */
               e_default       = 1,  /*!< default value */
               e_read_only     = 2,  /*!< read only access mode modifier */
               e_write_only    = 3,  /*!< write only access mode modifier */
               e_read_write    = 4,  /*!< read-write access mode modifier */
               
               e_last_modifier  /*!< last value (upper bound on range of values, used in error checking) */
             };

       // Copy constructor
          $CLASSNAME ( const $CLASSNAME & X );

       // Assignment Operator
          $CLASSNAME & operator= ( const $CLASSNAME & X );

          void post_construction_initialization() $ROSE_OVERRIDE;

          bool isUnknown() const;
          void setUnknown();

          bool isDefault() const;
          void setDefault();

          bool isReadOnly() const;
          void setReadOnly();

          bool isWriteOnly() const;
          void setWriteOnly();

          bool isReadWrite() const;
          void setReadWrite();

          std::string displayString() const;
          void display ( std::string label ) const;
          friend std::ostream & operator<< ( std::ostream & os, const SgStorageModifier & m );
          
HEADER_OPENCL_ACCESS_MODE_MODIFIER_END



// *************************************************
// *************************************************
//                  Source Code
// *************************************************
// *************************************************


SOURCE_START
  // No functions defined for the GrammarSource
SOURCE_END


SOURCE_SYMBOL_TABLE_START

// This function was moved to be defined outside of eqstr so that we could 
// reference the data member rose_hash_multimap::case_insensitive_semantics.
bool
eqstr::operator()(const SgName & s1, const SgName & s2) const
   {
  // DQ (11/27/2010): This is where we can implement the case insensitive support in ROSE.
  // return s1.getString() == s2.getString();
  // return s1 == s2;

     ROSE_ASSERT(hash_multimap != NULL);
  // mprintf ("@@@@@ hash_multimap->get_case_insensitive_semantics() = %s s1 = %s s2 = %s \n",(hash_multimap->get_case_insensitive_semantics() == true) ? "true" : "false",s1.str(),s2.str());
  // ROSE_ASSERT(hash_multimap->get_case_insensitive_semantics() == true);

     if (hash_multimap->get_case_insensitive_semantics() == true)
        {
          return SgName::caseInsensitiveEquality(s1,s2);
        }
       else
        {
       // This is the SgName::operator==(const SgName & s1, const SgName & s2) member function
          return s1 == s2;
        }
   }

size_t
hash_Name::operator()(const SgName & name) const
   {
  // CH (4/8/2010): Use boost::unordered instead
  // return hasher(name.str());

     ROSE_ASSERT(hash_multimap != NULL);
  // mprintf ("In hash_Name::operator(): hash_multimap->get_case_insensitive_semantics() = %s name = %s \n",hash_multimap->get_case_insensitive_semantics() ? "true" : "false",name.str());

  // ROSE_ASSERT(hash_multimap->get_case_insensitive_semantics() == true);

     if (hash_multimap->get_case_insensitive_semantics() == true)
        {
       // We need to compute the hash on the normalized form of the name (pick lower case).
          std::string s = name;

       // Convert string to lower case.
          std::transform(s.begin(), s.end(),s.begin(),::tolower);
       // mprintf ("In hash_Name::operator(): transformed name = %s to lower case s = %s \n",name.str(),s.c_str());

       // Return hashed value on the normalized (lower case) string.
          return hasher(s.c_str());
        }
       else
        {
          return hasher(name.str());
        }
   }

// DQ (2/19/2007): Added mechanism to turn off expensive error checking!
#define SYMBOL_TABLE_ERROR_CHECKING 0

// DQ (7/24/2005): Make this a constant in the function if it is not used elsewhere!
// #define SYMTBL_INIT_SZ 16

// DQ (11/27/2010): Added support for case sensitive and case insensitive symbol table (internal name matching).
// SgSymbolTable::SgSymbolTable(bool case_insensitive)
SgSymbolTable::SgSymbolTable()
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!
     int symbolTableSize = 17;

  // CH (4/8/2010): Use boost::unordered instead
#if 0
     mprintf ("WARNING: Symbol table built using default constructor in SgSymbolTable(). \n");
     p_table = new BaseHashType();
#else
     p_table = new BaseHashType(symbolTableSize);
#endif
     assert (p_table != NULL);
   }

// DQ (2/19/2007): I have put it back into use as a way of 
// customizing the size of the underlying hash tables to be
// larger for certain scopes (e.g global scope usually has a 
// lot more symbols.

// DQ (11/27/2010): Added support for case sensitive and case insensitive symbol table (internal name matching).
// DQ (1/31/2007): This function is not used!
// SgSymbolTable::SgSymbolTable(int symbolTableSize)
// SgSymbolTable::SgSymbolTable(int symbolTableSize, bool case_insensitive)
SgSymbolTable::SgSymbolTable(int symbolTableSize)
   : p_no_name(true)
   {
  // This should always be a non-null pointer (and never shared)!

  // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
  // p_table = new SgSymbolHashMultiMap(sz);

// CH (4/8/2010): Use boost::unordered instead
//#ifdef _MSCx_VER
#if 0
     mprintf ("WARNING: Symbol table built using default constructor in SgSymbolTable(int symbolTableSize). \n");
     p_table = new BaseHashType();
#else
     p_table = new BaseHashType(symbolTableSize);
#endif
     assert (p_table != NULL);
   }

bool
SgSymbolTable::isCaseInsensitive() const
   {
  // Case sensitive symbol tables are used for C/C++ and case insensitive scopes are for Fortran.
  // Note that a case insensitive symbol table can only be built that way from the constructor 
  // and not be toggled back and forth at will.

     ROSE_ASSERT(p_table != NULL);
     return p_table->get_case_insensitive_semantics();
   }

void
SgSymbolTable::setCaseInsensitive(bool b)
   {
  // Case sensitive symbol tables are used for C/C++ and case insensitive scopes are for Fortran.
  // Note that a case insensitive symbol table can only be built that way from the constructor 
  // and not be toggled back and forth at will.

     ROSE_ASSERT(p_table != NULL);

  // Make it NOT an error to redundantly set the case sensitivity/insensitivity.
     bool changingCaseSensitivity = b != p_table->get_case_insensitive_semantics();
     if (changingCaseSensitivity == true)
        {
          if (p_table->empty() == false)
             {
               mprintf ("Error: Can't change case sensitivity of non-empty symbol table.\n");
               mprintf ("   Solution: set the case sensitivity/insensitivity earlier in processing (immediately after the call to build the scope) \n");
             }
          ROSE_ASSERT(p_table->empty() == true);

          p_table->set_case_insensitive_semantics(b);
        }
   }

std::ostream & operator<< ( std::ostream & os, const rose_hash_multimap::iterator & rhm_it )
   {
  // DQ (1/19/2006): Error reported by Michelle Strout when compiled with g++ 4.0.2 on 64 bit machines
  // os << " pair (" << (*rhm_it).first.str() << "," << (int)((*rhm_it).second) << ")";
  // os << " pair (" << (*rhm_it).first.str() << "," << ((*rhm_it).second) << ")";
  // JJW (7/10/2008): The iterator may not be valid, so don't try to print what it points to
     os << "<iterator>";
     return os;
   }

SgName
SgSymbolTable::get_name( const SgNode* node) const
   {
  // DQ (2/20/2007): This function is used to get the name for the different types of declarations used to build symbols.

     SgName name;

     switch (node->variantT())
        {
       // We could implement a function on the selective nodes that generated the symbol 
       // name (the name used for the input of associated symbols in the symbol table).
          case V_SgLabelStatement:
             {
               const SgLabelStatement* labelStatement = isSgLabelStatement(node); 
               if (labelStatement->get_label() != NULL)
                  {
                    name = labelStatement->get_label();
                  }
                 else
                  {
                 // name = Rose::StringUtility::numberToString(labelStatement->get_numeric_label()->get_name());
                    assert(labelStatement->get_numeric_label() != NULL);
                    name = labelStatement->get_numeric_label()->get_name();
                  }
               break;
             }

          case V_SgJavaLabelStatement: // charles4: 09/13/2011 added for Java support
             {
               const SgJavaLabelStatement* labelStatement = isSgJavaLabelStatement(node); 
               ROSE_ASSERT (labelStatement->get_label() != NULL);
               name = labelStatement->get_label();
               break;
             }

          case V_SgClassDeclaration:
          case V_SgDerivedTypeStatement:
          case V_SgModuleStatement:
          case V_SgJavaPackageDeclaration:
          case V_SgJovialTableStatement:
             {
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(node);
               name = classDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               const SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(node);
            // Note that get_name() returns a name with arguments such as "class_template<int>" while get_templateName() returns the template name withouth arguments.
            // name = templateInstantiationDeclaration->get_templateName();
            // mprintf ("In SgSymbolTable::find(const SgStatement*): case V_SgTemplateInstantiationDecl, using get_name() = %s instead of get_templateName() = %s \n",
            //      templateInstantiationDeclaration->get_name().str(),templateInstantiationDeclaration->get_templateName().str());
            // mprintf ("Base class get_name() = %s \n",templateInstantiationDeclaration->SgClassDeclaration::get_name().str());
               name = templateInstantiationDeclaration->get_name();
               break;
             }

          case V_SgEnumDeclaration:
             {
               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(node); 
               name = enumDeclaration->get_name();
               break;
             }

          case V_SgFunctionDeclaration:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgMemberFunctionDeclaration:
             {
               const SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(node);
            // mprintf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // mprintf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // mprintf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               
               name = functionDeclaration->get_name();
               break;
             }

       // DQ (2/14/2007): Note that for template-based declarations there is a process where within the post-processing of 
       // the AST the names are updated from the EDG form (e.g. "template_name___Lnnn"), to the template specialization 
       // form (e.g. "template_name<int>"). Since the symbol references only one of the declarations, if there are defining 
       // declarations and non-defining declarations, the name can be changed in the declaration but not in the associated symbol.
       // Details of this situation require more clarification.
          case V_SgTemplateInstantiationFunctionDecl:
             {
               const SgTemplateInstantiationFunctionDecl* functionDeclaration = isSgTemplateInstantiationFunctionDecl(node);
            // mprintf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // mprintf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // mprintf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(),
            // get_templateName returns the name of the template which is required for code generation (where for
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               const SgTemplateInstantiationMemberFunctionDecl* functionDeclaration = isSgTemplateInstantiationMemberFunctionDecl(node);
            // mprintf ("functionDeclaration                                    = %p \n",functionDeclaration);
            // mprintf ("functionDeclaration->get_definingDeclaration()         = %p \n",functionDeclaration->get_definingDeclaration());
            // mprintf ("functionDeclaration->get_firstNondefiningDeclaration() = %p \n",functionDeclaration->get_firstNondefiningDeclaration());               

            // DQ (2/14/2007): The name used to insert symbols into the symbol table is the one returned by get_name(), 
            // get_templateName returns the name of the template which is required for code generation (where for 
            // functions the specialization is not required or not allowed).
            // name = functionDeclaration->get_templateName();
               name = functionDeclaration->get_name();
               break;
             }

          case V_SgNamespaceDeclarationStatement:
             {
               const SgNamespaceDeclarationStatement* namespaceDeclarationStatement = isSgNamespaceDeclarationStatement(node); 
               name = namespaceDeclarationStatement->get_name();
               break;
             }

       // DQ (8/30/2009): Added namespace alias support.
          case V_SgNamespaceAliasDeclarationStatement:
             {
               const SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = isSgNamespaceAliasDeclarationStatement(node); 
               name = namespaceAliasDeclarationStatement->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
       // DQ (11/23/2011): Added more support for template declaration IR nodes.
          case V_SgTemplateFunctionDeclaration:
             {
               const SgTemplateFunctionDeclaration* templateDeclaration = isSgTemplateFunctionDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
          case V_SgTemplateMemberFunctionDeclaration:
             {
               const SgTemplateMemberFunctionDeclaration* templateDeclaration = isSgTemplateMemberFunctionDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

       // DQ (12/26/2011): Template declarations have to have their own cases now.
       // DQ (6/11/2011): Added support for new template declaration IR nodes.
          case V_SgTemplateClassDeclaration:
             {
               const SgTemplateClassDeclaration* templateDeclaration = isSgTemplateClassDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }
#if 0
       // DQ (12/26/2011): This is not a required case to handle since a variable declaration dos not have a name.
          case V_SgTemplateVariableDeclaration:
             {
               const SgTemplateVariableDeclaration* templateDeclaration = isSgTemplateVariableDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }
#endif
       // DQ (12/26/2011): This is no longer a base class for SgTemplateClassDeclaration and other templae declaration IR nodes.
       // It is used only for the EDG 3.3 compatable support for template declarations.
          case V_SgTemplateDeclaration:
             {
               const SgTemplateDeclaration* templateDeclaration = isSgTemplateDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
               const SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(node);
               name = typedefDeclaration->get_name();
               break;
             }

       // DQ (11/5/2014): Adding support for templated typedef.
          case V_SgTemplateInstantiationTypedefDeclaration:
             {
               const SgTemplateInstantiationTypedefDeclaration* templateInstantiationDeclaration = isSgTemplateInstantiationTypedefDeclaration(node); 
               name = templateInstantiationDeclaration->get_name();
               break;
             }

       // DQ (11/4/2014): Adding support for templated typedef.
          case V_SgTemplateTypedefDeclaration:
             {
               const SgTemplateTypedefDeclaration* templateDeclaration = isSgTemplateTypedefDeclaration(node); 
               name = templateDeclaration->get_name();
               break;
             }

          case V_SgFunctionType:
             {
               const SgFunctionType* functionType = isSgFunctionType(node);

            // DQ (3/19/2016): Klocworks reports this as an issue, since functionType could be NULL.
            // So I am adding an assertion to see if this is a reasonalbe solution.  I am not clear 
            // why all of the other cases in this function are not flagged as issues by Klocworks.
               ROSE_ASSERT(functionType != NULL);

               name = functionType->get_mangled();
               break;
             }

          case V_SgInitializedName:
             {
               const SgInitializedName* initializedName = isSgInitializedName(node);
               name = initializedName->get_name();
               break;
             }

          case V_SgNonrealDecl:
             {
               const SgNonrealDecl* nrdecl = isSgNonrealDecl(node);
               name = nrdecl->get_name();
               break;
             }

          default:
             {
               mprintf ("SgSymbolTable::get_name(SgNode*) undefined for %s \n",node->class_name().c_str());
               assert(false);
             }
        }

#if 0
     mprintf ("SgSymbolTable::get_name(SgNode*) node = %p = %s name = %s \n",node,node->class_name().c_str(),name.str());
#endif

     return name;
   }


/* ************************************************************************
                               INSERT FUNCTIONS
   ************************************************************************/

void
SgSymbolTable::insert ( const SgName & nm , SgSymbol *sp )
   {
  // For simplicity, there is only a single insert member function to put a symbol into the symbol table.

#if 0
     mprintf ("********** In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s \n",
          nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),sp,sp->class_name().c_str());
#endif

  // DQ (2/14/2007): Added assertion!
     assert(this != NULL);

  // DQ (2/19/2007): Added additional assertion!
     assert (p_table != NULL);

  // DQ (2/14/2007): Added assertion!
     assert (sp != NULL);

#if 0
  // This outputs a message for every use of the insert function (for non function type symbols) useful for tracing through bugs
     SgNode* symbolBasis = sp->get_symbol_basis();
#if 0
  // DQ (12/3/3011): This does not work since the sp->get_mangled_name() can't always be called...
     mprintf ("+++++++++++ In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s mangled_name = %s \n",
          nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
             sp,sp->class_name().c_str(),symbolBasis,symbolBasis != NULL ? symbolBasis->class_name().c_str() : "NULL",
             sp->get_mangled_name().str());
#else
     mprintf ("+++++++++++ In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s \n",
          nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
             sp,sp->class_name().c_str(),symbolBasis,symbolBasis != NULL ? symbolBasis->class_name().c_str() : "NULL");
#endif

#if 0
  // DQ (7/24/2012): Note that this can fail (e.g. test2004_77.C) since SgAliassymbols are not considered in this test, I think.
  // DQ (12/3/2011): If this is a symbol for a member function declaration, then it should be a SgMemberFunctionSymbol, and not a SgFunctionSymbol.
     if (symbolBasis != NULL && isSgMemberFunctionDeclaration(symbolBasis) != NULL)
        {
          if (isSgMemberFunctionSymbol(sp) == NULL)
             {
               mprintf ("Error: symbol for SgMemberFunctionDeclaration is not a SgMemberFunctionSymbol (sp = %p = %s) \n",sp,sp->class_name().c_str());
             }
          ROSE_ASSERT(isSgMemberFunctionSymbol(sp) != NULL);
        }
#endif
#endif

#if 0
  // DQ (12/3/2011): Disable symbols with the same name (temporary testing/debugging).
     if (exists(nm) == true)
        {
       // We what to check on what kind of symbol this is.
          SgSymbol* s = find_function(nm);
          mprintf ("In SgSymbolTable::insert(%s,%p = %s) found an overloaded function (symbol = %p = %s) \n",nm.str(),sp,sp->class_name().c_str(),s,(s != NULL) ? s->class_name().c_str() : "empty string");
       // ROSE_ASSERT(s == NULL);
        }
  // ROSE_ASSERT(exists(nm) == false);
#endif

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
#if SYMBOL_TABLE_ERROR_CHECKING
  // SgFunctionTypeSymbol does not have a valid get_symbol_basis(), so skip this case!
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
          if (sp->get_symbol_basis() == NULL)
             {
               mprintf ("Error (sp->get_symbol_basis() == NULL): name = %s sp = %p = %s \n",nm.str(),sp,sp->class_name().c_str());
             }
          assert(sp->get_symbol_basis() != NULL);
#if 0
       // This outputs a message for every use of the insert function (for non function type symbols) useful for tracing through bugs
          mprintf ("In SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s sp->get_symbol_basis() = %p = %s \n",
             nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),
             sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
#endif
        }

  // DQ (3/10/2007): This is a simpler assertion equivalent to the one above but without generating any error output 
     ROSE_ASSERT(isSgFunctionTypeSymbol(sp) != NULL || sp->get_symbol_basis() != NULL);
#endif

#if 0
  // DQ (12/3/2011): Adding debugging support to output p_symbolSet.
     mprintf ("Output the internal symbol set used for fast existence testing (p_symbolSet size = %" PRIuPTR "): \n",p_symbolSet.size());
     int counter = 0;
     SgNodeSet::iterator i = p_symbolSet.begin();
     while (i != p_symbolSet.end())
        {
          SgSymbol* temp_symbol = isSgSymbol(*i);
          ROSE_ASSERT(temp_symbol != NULL);

          SgNode* symbolBasis = temp_symbol->get_symbol_basis();
       // mprintf ("--- p_symbolSet[counter=%d] = %p = %s : name = %s symbolBasis = %p mangled_name = %s \n",counter,temp_symbol,temp_symbol->class_name().c_str(),temp_symbol->get_name().str(),symbolBasis,temp_symbol->get_mangled_name().str());
          mprintf ("--- p_symbolSet[counter=%d] = %p = %s : name = %s symbolBasis = %p \n",counter,temp_symbol,temp_symbol->class_name().c_str(),temp_symbol->get_name().str(),symbolBasis);
          i++;
          counter++;
        }
     mprintf ("DONE: Output the internal symbol set used for fast existence testing (p_symbolSet size = %" PRIuPTR ") \n",p_symbolSet.size());

#if 0
  // DQ (12/3/2011): Debugging code...
     if (p_symbolSet.size() > 1)
        {
          mprintf ("Exiting when there is a single symbol in p_symbolSet \n");
          ROSE_ASSERT(false);
        }
#endif
#endif

  // DQ (3/10/2007): Test for if the symbol exists
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
          SgType* t = sp->get_type();
          ROSE_ASSERT(t != NULL);
          mprintf ("ERROR: p_symbolSet.find(sp) != p_symbolSet.end(): base type = %p = %s \n",t,t->class_name().c_str());
        }
     ROSE_ASSERT(p_symbolSet.find(sp) == p_symbolSet.end());

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // #if 1
  // DQ (12/3/2011): Turning on symbol table checking.
#if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/19/2007): These is no need to do both of these since exists(sp) is more complete test!
  // DQ (2/25/2007): except that it is helpful to know which one fails.
     assert(exists(nm,sp) == false);
     assert(exists(sp)    == false);

  // DQ (2/14/2007): error checking (make sure that no two symbols are represented by the same basis declaration). 
  // But skip such tests on the SgFunctionTypeSymbol (only used for the function type table)
     if (isSgFunctionTypeSymbol(sp) == NULL)
        {
       // set<SgNode*> existingSymbolBasisDeclarations;
          map<SgNode*, rose_hash_multimap::iterator > existingSymbolBasisDeclarations;

          SgNode* sp_associatedDeclaration = sp->get_symbol_basis();
          assert(sp_associatedDeclaration != NULL);

          rose_hash_multimap::iterator i = get_table()->begin();
          while (i != get_table()->end())
             {
            // test if symbol is in set
               SgNode* associatedDeclaration = i->second->get_symbol_basis();
               assert(associatedDeclaration != NULL);

            // Check if this declaration has previously been used with another symbol!
               if (existingSymbolBasisDeclarations.find( sp_associatedDeclaration ) == existingSymbolBasisDeclarations.end())
                  {
                 // Add this declaration to the list associated with symbols in the table
                 // existingSymbolBasisDeclarations.insert( associatedDeclaration );
                    existingSymbolBasisDeclarations[associatedDeclaration] = i;
                  }
                 else
                  {
                    mprintf ("Error in symbol table located in parent = %p = %s \n",get_parent(),get_parent()->class_name().c_str());
                    assert(get_parent() != NULL);
                    get_parent()->get_file_info()->display("Error in symbol table");

                    string associatedDeclarationName = SageInterface::get_name(sp_associatedDeclaration);

                 // DQ (2/15/2007): Output the name of the symbol being inserted, the declaration associated with it, 
                 // and the name of the symbol previously inserted with the same associated declaration.
                    mprintf ("Symbol sp = %p = %s already associated with declaration = %p = %s (name = %s) in symbol table i = %p = %s \n",
                         sp,sp->class_name().c_str(),sp_associatedDeclaration,sp_associatedDeclaration->class_name().c_str(),
                         associatedDeclarationName.c_str(),existingSymbolBasisDeclarations[sp_associatedDeclaration]->second,existingSymbolBasisDeclarations[sp_associatedDeclaration]->second->class_name().c_str());
                    associatedDeclaration->get_file_info()->display("Dual use of associatedDeclaration in source: debug");

                    mprintf ("existingSymbolBasisDeclarations[sp_associatedDeclaration]->first = %s second = %p \n",
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->first.str(),
                         existingSymbolBasisDeclarations[sp_associatedDeclaration]->second);
                    assert(false);
                  }

               i++;
             }
        }
#endif

  // Now, finally insert it into the symbol table
  // std::pair<const SgName,SgSymbol*>  npair(nm,sp);
  // p_table->insert(npair);
     p_table->insert(std::pair<const SgName,SgSymbol*>(nm,sp));

  // DQ (5/11/2006): set the parent to avoid NULL pointers
     sp->set_parent(this);

  // DQ (3/10/2007): Insert this symbol into p_symbolSet which we use for fast tests of existance in the 
  // symbol table when we don't use the name.  This helps detect where symbols have been entered using one 
  // name and either reentered using an second name or the name changed and the symbol had not been properly 
  // unloaded and reloaded into the symbol table.  Since the names are not stored in the symbol, but computed 
  // from associated declaration this is an easy error to make and we detect this by backing up the test for 
  // if a symbol exists using a name with a test for if the symbol exists using ANY possible name (a search 
  // for the symbol independent of the name).  To avoid this being a linear search of the symbol table (too 
  // slow) we implement a set of symbols to permit fast tests for existence.
     p_symbolSet.insert(sp);

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // #if 1
  // DQ (12/3/2011): Turning on symbol table checking.
#if SYMBOL_TABLE_ERROR_CHECKING
  // Error checking
     assert(exists(nm)    == true);
     assert(exists(nm,sp) == true);
     assert(exists(sp)    == true);
#endif

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // #if 1
#if SYMBOL_TABLE_ERROR_CHECKING
   // Liao 11/12/2012: Fortran numeric label symbol is different: a label "05" is stored as a numeric value of 5 so naive comparison will fail.
   // we have to handle this case specially.
   SgLabelSymbol * ls = isSgLabelSymbol(sp); 
   bool special_handled = false;
   if (ls != NULL)
   {
     SgStatement* fortran_stmt = ls->get_fortran_statement();
     if (fortran_stmt != NULL)
     {
       int label_value = atoi (nm.getString().c_str());
       assert (label_value == ls->get_numeric_label_value());
       special_handled = true;
     }
   } 
    
  // DQ (12/3/2011): Turning on symbol table checking.
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/14/2007): Added error checking!
     if (!special_handled && (nm != sp->get_name()))
        {
          mprintf ("Warning: symbol name does not match name used to input associated symbol into symbol table! sp = %p = %s nm = \"%s\" sp->get_name() = \"%s\" \n",sp,sp->class_name().c_str(),nm.str(),sp->get_name().str());

          assert(sp->get_symbol_basis() != NULL);
          assert(sp->get_symbol_basis()->get_file_info() != NULL);

          sp->get_symbol_basis()->get_file_info()->display("Error in source: debug");
          assert(false);
        }
#endif


#if 0
  // We can't test this because where symbols are inserted (EDG/SageIII translation) the scopes are not set yet (done in AST post-processing).
  // DQ (2/14/2007): Added error checking!
     SgStatement* statement = isSgStatement(sp->get_symbol_basis());
     if (statement != NULL)
        {
       // mprintf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
       // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
          SgSymbol* symbolFromTable = statement->get_symbol_from_symbol_table();
          assert(symbolFromTable != NULL);
          assert(symbolFromTable == sp);
        }
       else
        {
          SgInitializedName* initializedName = isSgInitializedName(sp->get_symbol_basis());
          if (initializedName != NULL)
             {
            // mprintf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
            // SgNode* symbolBasis = p_iterator->second->get_symbol_basis();
               SgSymbol* symbolFromTable = initializedName->get_symbol_from_symbol_table();
               assert(symbolFromTable != NULL);
               assert(symbolFromTable == sp);
             }
            else
             {
               mprintf ("Unknown symbol_base for input symbol sp = %p = %s sp->get_symbol_basis() = %p = %s \n",sp,sp->class_name().c_str(),sp->get_symbol_basis(),sp->get_symbol_basis()->class_name().c_str());
               assert(false);
             }
        }
#endif

#if 0
  // DQ (1/27/2019): Adding test to check the symbol basis (failing for Cxx11_tests/test2019_31.C).
     SgNode* symbolBasis = sp->get_symbol_basis();
     if (isSgClassSymbol(sp) != NULL || isSgAliasSymbol(sp) != NULL)
        {
          ROSE_ASSERT(symbolBasis != NULL);
        }

  // DQ (1/27/2019): Adding test to check the symbol basis (failing for Cxx11_tests/test2019_31.C).
  // Get a quick pointer into the symbol table using the name (log n complexity)
     p_iterator = p_table->find(nm);

  // Once we have p_iterator set via the name we don't typically have more than one iteration
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,nm))
        {
          assert(p_iterator->second != NULL);
#if 0
          mprintf ("In loop: p_iterator->second = %p statement = %p \n",p_iterator->second,statement);
          mprintf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
#endif

       // This is a virtual function call (not defined for function type symbols)
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();

          if (isSgAliasSymbol(p_iterator->second) != NULL)
             { 
               ROSE_ASSERT(symbolBasis != NULL);
             }

          p_iterator++;
        }
#endif

#if 0
     mprintf ("********** Leaving SgSymbolTable::insert(%s,%p) into SgSymbolTable = %p = %s of scope = %p = %s sp = %p = %s \n",
          nm.str(),sp,this,this->class_name().c_str(),this->get_parent(),this->get_parent()->class_name().c_str(),sp,sp->class_name().c_str());
#endif
   }


/* ************************************************************************
                               REMOVE FUNCTIONS
   ************************************************************************/

// DQ (2/6/2007): This is too dangerous for use in ROSE (deletes all 
// possible SgSymbols that match the input name independent of type).
// It is however currently used in the global function type symbol table
// so we have named this function to make its purpose more clear.
// This function is not likely called except where complex function type 
// symbol table editing is required.  Since SgFunctionTypeSymbols are
// shared removing such symbols is a rather dangerous actvity!
void
SgSymbolTable::remove_function_type( const SgName & name )
   {
  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     assert (p_table != NULL);

  // CH (4/8/2010): Use boost::unordered instead     
     list<rose_hash_multimap::iterator> deleteList;
     rose_hash_multimap::iterator it = get_table()->find(name);

  // DQ (11/27/2010): Adding support for case insensitive name lookup (using the rose_hash_multimap's key equality function).
  // while (it != get_table()->end() && (*it).first == name)
     while (it != get_table()->end() && get_table()->key_eq()((*it).first,name))
        {
          assert(it->second->variantT() == V_SgFunctionTypeSymbol);

          deleteList.push_back(it);
          it++;
        }
#if 0
     mprintf ("In SgSymbolTable::remove_function_type( const SgName & name ): name = %s deleteList.size() = %" PRIuPTR " \n",name.str(),deleteList.size());
#endif

  // Now remove the copy of the symbol from the symbol table and insert the shared symbol
  // CH (4/8/2010): Use boost::unordered instead
     list<rose_hash_multimap::iterator>::iterator i = deleteList.begin();

     while (i != deleteList.end())
        {
       // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase((*i)->second);"
       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // mprintf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
       // get_table()->erase(*i);

       // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
          p_symbolSet.erase((*i)->second);

       // Remove the existing symbol (associated with the function declaration we will be deleting from the AST.
       // mprintf ("Erasing symbol %p from symbol table %p in scope = %p \n",(*i)->second,this,this->get_parent());
          get_table()->erase(*i);

          i++;
        }

   }


SgSymbol*
SgSymbolTable::find( const SgInitializedName* initializedName)
   {
     assert(p_table != NULL);
     assert(initializedName != NULL);

#define DEBUG_FIND_INITIALIZED_NAME_SYMBOL 0

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
     mprintf ("Inside of SgSymbolTable::find( const SgInitializedName* ): initializedName = %p = %s \n",initializedName,SageInterface::get_name(initializedName).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = initializedName->get_name();

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
     mprintf ("Inside of SgSymbolTable::find( const SgInitializedName* ): name = %s \n",name.str());
#endif

  // Find the first symbol in the multimap
     p_iterator = p_table->find(name);

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
     mprintf ("Inside of SgSymbolTable::find( const SgInitializedName* ): name = %s this->count(name) = %d \n",name.str(),this->count(name));
#endif

  // Iterate through the matching symbols in the multimap
  // while (p_iterator != p_table->end() && (*p_iterator).first == name)
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name))
        {
          assert(p_iterator->second != NULL);
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
          mprintf ("In loop: p_iterator->second = %p symbolBasis = %p initializedName = %p \n",p_iterator->second,symbolBasis,initializedName);
          mprintf ("In loop: symbolBasis->variantT() = %d statement->variantT() = %d \n",symbolBasis->variantT(),initializedName->variantT());
#endif
          assert(symbolBasis != NULL);
          if (isSgInitializedName(symbolBasis) != NULL)
             {
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
               mprintf ("found a SgInitializedName \n");
#endif
               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == initializedName)
                  {
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
                    mprintf ("returnSymbol->get_symbol_basis() == initializedName returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
#endif
                    return returnSymbol;
                  }
                 else
                  {
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
                    mprintf ("returnSymbol->get_symbol_basis() != initializedName \n");
#endif
                  }
             }
            else
             {
#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
               mprintf ("Some other symbol was found (no matching variants) \n");
#endif
             }

          p_iterator++;
        }

#if DEBUG_FIND_INITIALIZED_NAME_SYMBOL
     mprintf ("Leaving SgSymbolTable::find( const SgInitializedName* ): return NULL \n");
#endif

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgFunctionType* functionType)
   {
     assert(p_table != NULL);
     assert(functionType != NULL);

#if 0
     mprintf ("Inside of SgSymbolTable::find( const SgFunctionType* ): functionType = %p = %s \n",functionType,SageInterface::get_name(functionType).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = functionType->get_mangled();

     p_iterator = p_table->find(name);
  // while (p_iterator != p_table->end() && (*p_iterator).first == name)
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name))
        {
       // DQ (3/19/2016): This is an issue for Klocworks.
       // if (isSgSymbol((*p_iterator).second)->variantT() == functionType->variantT())
          SgSymbol* symbol = isSgSymbol((*p_iterator).second);
          ROSE_ASSERT(symbol != NULL);
          if (symbol->variantT() == functionType->variantT())
             {
               returnSymbol = p_iterator->second;
               if (returnSymbol->get_symbol_basis() == functionType)
                    return returnSymbol;
             }

          p_iterator++;
        }

  // DQ (2/13/2007): Fixed bug that returns a valid pointer even when there was no match to the input statement!
  // return returnSymbol;
     return NULL;
   }

SgSymbol*
SgSymbolTable::find( const SgStatement* statement)
   {
     assert(p_table != NULL);
     assert(statement != NULL);

#define DEBUG_FIND_SYMBOL_FROM_STATEMENT 0

#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
     mprintf ("Inside of SgSymbolTable::find( const SgStatement* ): statement = %p = %s = %s \n",statement,statement->class_name().c_str(),SageInterface::get_name(statement).c_str());
#endif

     SgSymbol* returnSymbol = NULL;

     SgName name = get_name(statement);
  // Liao 11/28/2012: a declaration can have empty name "". But it will have a symbol with a mangled name starting with "__unnamed_".
  // A ResetEmptyNames process to handle this should be used before this find is called.
  // I cannot assert this since this function can be called before the empty name is reset. 
  //   ROSE_ASSERT (name.getString().length() !=0);
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
     mprintf ("Inside of SgSymbolTable::find( const SgStatement* ): name = %s \n",name.str());
#endif

  // Get a quick pointer into the symbol table using the name (log n complexity)
     p_iterator = p_table->find(name);

  // Once we have p_iterator set via the name we don't typically have more than one iteration
  // while (p_iterator != p_table->end() && (*p_iterator).first == name)
     while (p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,name))
        {
          assert(p_iterator->second != NULL);
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: p_iterator->second = %p statement = %p \n",p_iterator->second,statement);
          mprintf ("In loop: p_iterator->second = %p = %s statement = %p = %s \n",p_iterator->second,p_iterator->second->class_name().c_str(),statement,statement->class_name().c_str());
#endif

       // This is a virtual function call (not defined for function type symbols)
          SgNode* symbolBasis = p_iterator->second->get_symbol_basis();

#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: statement->variantT() = %d = %s \n",
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name.c_str());
#endif
       // DQ (1/27/2019): Test this to see if we can generate a dot graph to debug the problem.
          ROSE_ASSERT(symbolBasis != NULL);

       // if (symbolBasis != NULL)
       //    {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
          mprintf ("In loop: symbolBasis->variantT() = %d = %s statement->variantT() = %d = %s \n",
               symbolBasis->variantT(),Cxx_GrammarTerminalNames[symbolBasis->variantT()].name.c_str(),
               statement->variantT(),Cxx_GrammarTerminalNames[statement->variantT()].name.c_str());
#endif
          ROSE_ASSERT(symbolBasis != NULL);

          if (symbolBasis->variantT() == statement->variantT())
             {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
               mprintf ("matching variants \n");
#endif
               returnSymbol = p_iterator->second;

            // This is a very precise test which might be a problem because of defining and non-defining versions 
            // of declarations (we might be able to always use the non-defining declaration in these cases.  The 
            // switch which computes the names could normalize this aspect.
               if (returnSymbol->get_symbol_basis() == statement)
                  {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
                    mprintf ("returnSymbol->get_symbol_basis() == statement returnSymbol = %p = %s \n",returnSymbol,returnSymbol->class_name().c_str());
#endif
                    return returnSymbol;
                  }
                 else
                  {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
                    mprintf ("returnSymbol->get_symbol_basis() != statement (returnSymbol->get_symbol_basis() = %p statement = %p) \n",returnSymbol->get_symbol_basis(),statement);
#endif
                  }
             }
            else
             {
#if DEBUG_FIND_SYMBOL_FROM_STATEMENT
               mprintf ("Some other symbol was found (no matching variants) \n");
#endif
             }

#if 0
             }
            else
             {
               mprintf ("################## In SgSymbolTable::find( const SgStatement* statement): symbolBasis == NULL \n");
               mprintf ("   --- statement = %p = %s = %s \n",statement,statement->class_name().c_str(),SageInterface::get_name(statement).c_str());
             }
#endif
          p_iterator++;
        }
     return NULL;
   }


void
SgSymbolTable::remove( const SgSymbol* symbol )
   {
  // This is used for the handled of non function type symbol tables, and is more useful when the 
  // symbols don't have unique names.

  // This is non-destructive (does not delete the symbol, only removes it from the symbol table).

     assert (p_table != NULL);

  // DQ (11/20/2012): Make error checking dependent upon SYMBOL_TABLE_ERROR_CHECKING macro.
  // #if 1
#if SYMBOL_TABLE_ERROR_CHECKING
  // This is an expensive linear time search of the symbol table!
     assert(exists(symbol) == true);
#endif

  // This is a virtual function call
     SgName name = symbol->get_name();
#if 0
  // mprintf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) from SgSymbolTable = %p \n",symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),this);
     SgNode* symbolBasis = symbol->get_symbol_basis();
     assert(symbolBasis != NULL);
     mprintf ("In SgSymbolTable::remove(SgSymbol* symbol = %p = %s = %s) symbol_basis = %p = %s = %s from SgSymbolTable = %p \n",
          symbol,symbol->class_name().c_str(),SageInterface::get_name(symbol).c_str(),
          symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str(),this);
#endif
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSCx_VER
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator elementToDelete = get_table()->end();
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator it = get_table()->find(name);
//#else
     rose_hash_multimap::iterator elementToDelete = get_table()->end();
     rose_hash_multimap::iterator it = get_table()->find(name);
//#endif
  // while ( (it != get_table()->end()) && (elementToDelete == get_table()->end()) && ((*it).first == name) )
     while ( (it != get_table()->end()) && (elementToDelete == get_table()->end()) && get_table()->key_eq()((*it).first,name) )
        {
       // mprintf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
       // Make sure that we find the correct element
          if (it->second == symbol)
             {
            // mprintf ("Found iterator for symbol = %p \n",symbol);
               elementToDelete = it;
             }
          it++;
        }
#if 0
  // #if SYMBOL_TABLE_ERROR_CHECKING
  // DQ (2/11/2007): This is part of making the symbol table use more precise.
     if (elementToDelete == get_table()->end())
        {
          mprintf ("Error: could not find symbol name = %s in symbol table (restart search using symbol pointer) \n",name.str());

       // DQ (2/19/2007): Added assertion to exit on error!  Enforcing this allows us to
       // make sure that the complexity is not linear in the size of the symbol table!
          assert(false);

          rose_hash_multimap::iterator i = get_table()->begin();
          while ( (i != get_table()->end()) && (elementToDelete == get_table()->end()) )
             {
            // mprintf ("Looking for symbol to remove (Make sure that we find the correct element) \n");
            // Make sure that we find the correct element
               if (i->second == symbol)
                  {
                 // mprintf ("Found iterator for symbol = %p \n",symbol);
                    elementToDelete = i;
                  }
               i++;
             }

          if (elementToDelete != get_table()->end())
             {
               mprintf ("Warning: found symbol = %p = %s stored under a different name = %s \n",symbol,symbol->class_name().c_str(),elementToDelete->first.str());
               mprintf ("Location of problem in source code: \n");
               SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(symbol->get_symbol_basis());
               if (declarationStatement != NULL)
                  {
                    mprintf ("declarationStatement = %p = %s \n",declarationStatement,declarationStatement->class_name().c_str());
                    declarationStatement->get_startOfConstruct()->display("location of problem: debug");
                  }
               assert(false);
             }
        }
#endif

#if 0
  // DQ (2/13/2007): Now we really have an error to report
  // Make sure we found the input element to be removed!
     if (elementToDelete == get_table()->end())
        {
          mprintf ("Error: could not find symbol = %p name = %s in symbol table (failed to find symbol pointer under any name) \n",symbol,name.str());
          assert(false);
        }
#endif
     assert(elementToDelete != get_table()->end());

  // DQ (5/9/2007): Moved to after the call to "p_symbolSet.erase(elementToDelete->second);"
  // get_table()->erase(elementToDelete);

  // DQ (3/10/2007): Remove the symbol from the symbol set used to test for if the symbol exists
  // p_symbolSet.erase(symbol);
     p_symbolSet.erase(elementToDelete->second);

     get_table()->erase(elementToDelete);
   }


/* ************************************************************************
                               FIND FUNCTIONS
   ************************************************************************/

// DQ (11/27/2010): Change return type to "bool".
// DQ (2/10/2007): This is a depricated function
// int (changed the return type)
bool
SgSymbolTable::find(const SgName & nm, SgSymbol *sp)
   {
     assert(p_table != NULL);

  // if(!p_table)
  //      return NULL;

  // DQ (5/22/2006): Made this a local variable
  // hash_iterator p_iterator = p_table->find(nm);
     p_iterator = p_table->find(nm);
  // while (p_iterator != p_table->end() && (*p_iterator).first == nm)
  // while (p_iterator != p_table->end() && p_iterator->first == nm)
     while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
        {
          p_name    = nm;
          p_no_name = false;
       // if( ((SgSymbol *)(*p_iterator).second) == sp )
          if( p_iterator->second == sp )
               return true;
          p_iterator++;
        }

     return false;
   }

SgAliasSymbol*
SgSymbolTable::find_aliased_symbol(const SgName & nm, SgSymbol *sp)
   {
  // DQ (5/19/2013): This function finds the symbol for which the alias is sp, not the symbol to be returned being sp.
     assert(p_table != NULL);

     ROSE_ASSERT(sp != NULL);

#if 0
     mprintf ("In SgSymbolTable::find_aliased_symbol(): We are only using the name = %s sp = %p = %s (not any template arguments or template parameters) \n",nm.str(),sp,sp->class_name().c_str());
#endif

     p_iterator = p_table->find(nm);

     while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
        {
          p_name    = nm;
          p_no_name = false;

          ROSE_ASSERT(p_iterator->second != NULL);
#if 0
          mprintf ("In SgSymbolTable::find_aliased_symbol(): in loop: nm = %s p_iterator->second = %p = %s \n",nm.str(),p_iterator->second,p_iterator->second->class_name().c_str());
#endif

       // if( p_iterator->second == sp )
          SgAliasSymbol* aliasSymbol = isSgAliasSymbol(p_iterator->second);
          if ( (aliasSymbol != NULL) && (aliasSymbol->get_alias() == sp) )
             {
               return aliasSymbol;
             }

          p_iterator++;
        }

     return NULL;
   }


// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm ) const
   {
     assert(p_table != NULL);
     return p_table->find(nm) != p_table->end();
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgSymbol *sp ) const
   {
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // return p_symbolSet.find(sp) != p_symbolSet.end();
     return p_symbolSet.find(const_cast<SgSymbol*>(sp)) != p_symbolSet.end();
   }

// DQ (1/31/2007): New functions that will replace the depricated find() member function
bool
SgSymbolTable::exists ( const SgName & nm, SgSymbol *sp ) const
   {
  // DQ (3/10/2007): We can now use the stored p_symbolSet (STL set of SgNode*) to do this test more efficiently.
  // Since we if we find the symbol it exists, we can test the name separately
  // bool returnValue = false;

  // Test if the symbol is in the set, else the name is not relavant to the existence
     if (p_symbolSet.find(sp) != p_symbolSet.end())
        {
       // Now look to make sure that we have an entry with the correct name (and pointer value)
          hash_iterator p_iterator = p_table->find(nm);
       // while (p_iterator != p_table->end() && p_iterator->first == nm)
          while (p_iterator != p_table->end() && get_table()->key_eq()(p_iterator->first,nm))
             {
               if ( p_iterator->second == sp )
                  {
                 // This allows us to short-circuit the rest of the iterations
                    return true;
                  }

               p_iterator++;
             }
        }

     return false;
   }

/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any(const SgName &);
      SgVariableSymbol*  find_variable(const SgName &);
      SgClassSymbol*     find_class(const SgName &);
      SgFunctionSymbol*  find_function(const SgName&);
      SgFunctionSymbol*  find_function_type(const SgName&, const SgType*);
      SgTypedefSymbol*   find_typedef(const SgName &);
      SgEnumSymbol*      find_enum(const SgName &);
      SgEnumFieldSymbol* find_enum_field(const SgName &);
      SgLabelSymbol*     find_label(const SgName &) const;
      SgJavaLabelSymbol* find_label(const SgName &) const; // charles4: added 9/12/2011 for Java
      SgNamespaceSymbol* find_namespace(const SgName &);
*/

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgSymbol*
SgSymbolTable::findany(const SgName &nm)
   {
     return find_any(nm);
   }
#endif

// SgSymbol* SgSymbolTable::find_any(const SgName & nm)
SgSymbol*
SgSymbolTable::find_any(const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // DQ (6/24/2013): This special case requires some special support in find_symbol_support.
  // return find_symbol_support<SgSymbol>(nm,templateParameterList,templateArgumentList);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgSymbol>(nm,NULL,templateParameterList,templateArgumentList,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgTypedefSymbol*
SgSymbolTable::find_typedef(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgTypedefSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgTypedefSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumSymbol*
SgSymbolTable::find_enum(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgEnumSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgEnumSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgEnumFieldSymbol*
SgSymbolTable::find_enum_field(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // return find_symbol_support<SgEnumFieldSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgEnumFieldSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgVariableSymbol*
SgSymbolTable::findvar(const SgName & nm)
   {
     return find_variable(nm);
   }
#endif

SgVariableSymbol*
SgSymbolTable::find_variable(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
#if 0
     SgVariableSymbol* s = find_symbol_support<SgVariableSymbol>(nm,NULL,NULL);

  // DQ (5/23/2013): Report when we are not being strict in the symbol that we return.
     if (isSgTemplateVariableSymbol(s) != NULL)
        {
          mprintf ("WARNING: returing a SgTemplateVariableSymbol from find_symbol_support<SgVariableSymbol>(nm = %s); \n",nm.str());
        }

     return s;
#endif
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgVariableSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgClassSymbol*
SgSymbolTable::findclass(const SgName &nm)
   {
     return find_class(nm);
   }
#endif

SgClassSymbol*
SgSymbolTable::find_class(const SgName & nm)
   {
  // DQ (8/21/2013): Modified to use single supporting templated lower level function.
  // SgClassSymbol* s = find_symbol_support<SgClassSymbol>(nm,NULL,NULL);
     bool filterTemplateSymbols = false;
     SgClassSymbol* s = find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);

  // DQ (5/23/2013): Report when we are not being strict in the symbol that we return.
     if (isSgTemplateClassSymbol(s) != NULL)
        {
          mprintf ("WARNING: returing a SgTemplateClassSymbol from find_symbol_support<SgClassSymbol>(nm = %s); \n",nm.str());
        }

     return s;
   }

#if 0
// DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
// This is important in handling the viability of symbols through base classes when private base 
// class derivation is used.
SgAliasSymbol*
SgSymbolTable::find_alias(const SgName & nm)
   {
#if 0
     mprintf ("In SgSymbolTable::find_alias(): nm = %s \n",nm.str());
#endif
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgAliasSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }
#endif


#define DEBUG_MATCHING_TEMPLATE_ARGUMENTS 0

bool
SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
   {
  // DQ (8/8/2013): I don't think that we need to handle the case of where there is both a valid SgTemplateParameterPtrList and SgTemplateArgumentPtrList.
     bool returnValue = false;

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("In TOP SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(): templateParameterList = %p templateArgumentsList = %p \n",templateParameterList,templateArgumentsList);
#endif

     if (templateParameterList != NULL)
        {
       // Note that this should be a template case if template parameters were specified.

       // DQ (8/19/2013): template classes need to use both the template parameter list and the template argument list.
          returnValue = hasMatchingTemplateParametersOrNoTemplateParameters(templateParameterList,symbol);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("In SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(): after evaluation of templateParameterList: templateParameterList = %p templateArgumentsList = %p returnValue = %s \n",templateParameterList,templateArgumentsList,returnValue ? "true" : "false");
#endif

          if (returnValue == true && templateArgumentsList != NULL)
             {
            // Since this function can be called when searching on the most general case of SgSymbol, we have to 
            // permit this case to be evaluated.  However, since it only make sense for SgTemplateClassSymbol we 
            // can return "true" for all other cases.
            // This case should only be for template class symbols (case of partial specialization).
            // SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);
               if (isSgTemplateClassSymbol(symbol) != NULL)
                  {
                    returnValue = hasMatchingTemplateArgumentsOrNoTemplateArguments(templateArgumentsList,symbol);
                  }
                 else
                  {
                 // DQ (5/22/2016): Isn't this an error to not also test the template arguments for non-class templates.
#if 0
                    mprintf ("WARNING: Isn't this an error to not also test the template arguments for non-class templates. \n");
#endif
                 // return "returnValue == true" for all other cases.
                  }
             }
        }
       else
        {
       // This is not a template and is either an instantiation of a template or non-instantiation (normal class, function, etc.).
          returnValue = hasMatchingTemplateArgumentsOrNoTemplateArguments(templateArgumentsList,symbol);
        }

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("In SgSymbolTable::hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments() templateParameterList = %p templateArgumentsList = %p returnValue = %s \n",templateParameterList,templateArgumentsList,returnValue ? "true" : "false");
#endif

     return returnValue;
   }

bool
SgSymbolTable::hasMatchingTemplateParametersOrNoTemplateParameters(SgTemplateParameterPtrList* templateParameterList, SgSymbol* symbol)
   {
  // This is an overloaded function.

  // This function hides the details of calling the template version of the function.
  // return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateParameterPtrList>(templateParameterList,symbol);
     return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateParameter>(templateParameterList,symbol);
   }

bool
SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
   {
  // This is an overloaded function.

  // This is the refactored version of the previous function API.
  // This function hides the details of calling the template version of the function.
  // return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateArgumentPtrList>(templateArgumentsList,symbol);
     return hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments<SgTemplateArgument>(templateArgumentsList,symbol);
   }

// DQ (8/10/2013): Base template for specializations specific to template arguments and template parameters.
template <class T> std::vector<T*> getTemplateParametersOrArgumentsList(SgSymbol* symbol)
   {
     return std::vector<T*>();
   }

template <>
std::vector<SgTemplateArgument*> getTemplateParametersOrArgumentsList<SgTemplateArgument>(SgSymbol* symbol)
   {
  // Template specialization for handling template arguments.

  // DQ (8/11/2013): This function uses the STL copy operation and might have a more efficient implementation.
     std::vector<SgTemplateArgument*> returnList;

     ROSE_ASSERT(symbol != NULL);
#if 0
     mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
     switch(symbol->variantT())
        {
          case V_SgClassSymbol:
             {
               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);
               ROSE_ASSERT(classSymbol != NULL);

               SgClassDeclaration* classDeclaration = classSymbol->get_declaration();
               ROSE_ASSERT(classDeclaration != NULL);
               SgTemplateInstantiationDecl* templateClassInstantiation = isSgTemplateInstantiationDecl(classDeclaration);
               if (templateClassInstantiation != NULL)
                  {
                    returnList = templateClassInstantiation->get_templateArguments();
                  }
               break;
             }

          case V_SgFunctionSymbol:
             {
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);
               ROSE_ASSERT(functionSymbol != NULL);

               SgFunctionDeclaration* functionDeclaration = functionSymbol->get_declaration();
               ROSE_ASSERT(functionDeclaration != NULL);
               SgTemplateInstantiationFunctionDecl* templateFunctionInstantiation = isSgTemplateInstantiationFunctionDecl(functionDeclaration);
               if (templateFunctionInstantiation != NULL)
                  {
                    returnList = templateFunctionInstantiation->get_templateArguments();
                  }
               break;
             }

        // DQ (8/12/2013): Added case for SgMemberFunctionSymbol
          case V_SgMemberFunctionSymbol:
             {
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);
               ROSE_ASSERT(memberFunctionSymbol != NULL);

               SgMemberFunctionDeclaration* memberFunctionDeclaration = memberFunctionSymbol->get_declaration();
               ROSE_ASSERT(memberFunctionDeclaration != NULL);
               SgTemplateInstantiationMemberFunctionDecl* templateMemberFunctionInstantiation = isSgTemplateInstantiationMemberFunctionDecl(memberFunctionDeclaration);
               if (templateMemberFunctionInstantiation != NULL)
                  {
                    returnList = templateMemberFunctionInstantiation->get_templateArguments();
                  }
               break;
             }

        // DQ (8/19/2013): Added case for SgTemplateClassSymbol
          case V_SgTemplateClassSymbol:
             {
               SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);
               ROSE_ASSERT(templateClassSymbol != NULL);

               ROSE_ASSERT(templateClassSymbol->get_declaration() != NULL);

            // SgTemplateClassDeclaration* templateClassDeclaration = templateClassSymbol->get_declaration();
               SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(templateClassSymbol->get_declaration());
            // ROSE_ASSERT(templateClassDeclaration != NULL);

               if (templateClassDeclaration != NULL)
                  {
                    returnList = templateClassDeclaration->get_templateSpecializationArguments();
                  }
               break;
             }

          case V_SgTemplateVariableSymbol:
             {
               SgTemplateVariableSymbol* vsym = isSgTemplateVariableSymbol(symbol);
               ROSE_ASSERT(vsym != NULL);

               SgInitializedName* iname = vsym->get_declaration();
               ROSE_ASSERT(iname != NULL);

               SgTemplateVariableDeclaration * tplvdecl = isSgTemplateVariableDeclaration(iname->get_parent());
               ROSE_ASSERT(tplvdecl != NULL);

               returnList = tplvdecl->get_templateSpecializationArguments();
               break;
             }

       // DQ (9/12/2016): Providing better implementation for template typedef symbol support.
       // DQ (11/10/2014): Providing an initial implementation for template typedef symbol support.
          case V_SgTemplateTypedefSymbol:
             {
#if 0
               mprintf ("WARNING: returning NULL in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
               SgTemplateTypedefSymbol* templateTypedefSymbol = isSgTemplateTypedefSymbol(symbol);
               ROSE_ASSERT(templateTypedefSymbol != NULL);

               ROSE_ASSERT(templateTypedefSymbol->get_declaration() != NULL);

               SgTemplateTypedefDeclaration* templateTypedefDeclaration = isSgTemplateTypedefDeclaration(templateTypedefSymbol->get_declaration());
            // ROSE_ASSERT(templateTypedefDeclaration != NULL);

               if (templateTypedefDeclaration != NULL)
                  {
                 // returnList = templateTypedefDeclaration->get_templateArguments();
                    returnList = templateTypedefDeclaration->get_templateSpecializationArguments();
                  }
               break;
             }

#if 0
       // We have to support these sorts of declarations in the name qualifiaction.
          SgClassDeclaration*              classDeclaration     = isSgClassDeclaration(declaration);
          SgVariableDeclaration*           variableDeclaration  = isSgVariableDeclaration(declaration);
          SgFunctionDeclaration*           functionDeclaration  = isSgFunctionDeclaration(declaration);
          SgTypedefDeclaration*            typedefDeclaration   = isSgTypedefDeclaration(declaration);
          SgTemplateDeclaration*           templateDeclaration  = isSgTemplateDeclaration(declaration);
          SgEnumDeclaration*               enumDeclaration      = isSgEnumDeclaration(declaration);
          SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(declaration);
#endif

       // DQ (4/10/2017): Added case for other symbols (but we only return the empty list for this case).
          case V_SgLabelSymbol:

       // DQ (8/19/2013): Added case for other symbols (but we only return the empty list for this case).
          case V_SgVariableSymbol:
          case V_SgTypedefSymbol:
          case V_SgEnumSymbol:
          case V_SgEnumFieldSymbol:
          case V_SgNamespaceSymbol:
             {
            // This function requires this case so that it can be called within very general contexts.
            // However, for this case we only return the empty template parameter list.

               break;
             }

          case V_SgNonrealSymbol:
             {
#if 0
               mprintf ("In SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): Case of SgNonrealSymbol\n");
#endif
               SgNonrealSymbol * nrsym = isSgNonrealSymbol(symbol);
               ROSE_ASSERT(nrsym != NULL);
               SgNonrealDecl * nrdecl = isSgNonrealDecl(nrsym->get_declaration());
               ROSE_ASSERT(nrdecl != NULL);
               returnList = nrdecl->get_tpl_args();
               break;
             }

          case V_SgTemplateSymbol:
             {
               mprintf ("Case of SgTemplateSymbol not handled yet in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>() \n");
               ROSE_ASSERT(false);
               break;
             }

          default:
             {
               mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateArgument>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return returnList;
   }

template <>
std::vector<SgTemplateParameter*> getTemplateParametersOrArgumentsList<SgTemplateParameter>(SgSymbol* symbol)
   {
  // Template specialization for handling template parameters.

  // DQ (8/11/2013): This function uses the STL copy operation and might have a more efficient implementation.
     std::vector<SgTemplateParameter*> returnList;

     ROSE_ASSERT(symbol != NULL);

#if 0
     mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif

     switch(symbol->variantT())
        {
          case V_SgTemplateClassSymbol:
             {
               SgTemplateClassSymbol* templateClassSymbol = isSgTemplateClassSymbol(symbol);
               ROSE_ASSERT(templateClassSymbol != NULL);

               SgClassDeclaration* classDeclaration = templateClassSymbol->get_declaration();
               ROSE_ASSERT(classDeclaration != NULL);
               SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(classDeclaration);
               if (templateClassDeclaration != NULL)
                  {
                    returnList = templateClassDeclaration->get_templateParameters();
                  }
               break;
             }

          case V_SgTemplateFunctionSymbol:
             {
               SgTemplateFunctionSymbol* templateFunctionSymbol = isSgTemplateFunctionSymbol(symbol);
               ROSE_ASSERT(templateFunctionSymbol != NULL);

               SgFunctionDeclaration* functionDeclaration = templateFunctionSymbol->get_declaration();
               ROSE_ASSERT(functionDeclaration != NULL);
               SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(functionDeclaration);
               if (templateFunctionDeclaration != NULL)
                  {
#if 0
                    mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): Get the template parameter lise from templateFunctionDeclaration = %p = %s name = %s \n",
                         templateFunctionDeclaration,templateFunctionDeclaration->class_name().c_str(),templateFunctionDeclaration->get_name().str());
#endif
                    returnList = templateFunctionDeclaration->get_templateParameters();
                  }
                 else
                  {
                    mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
               break;
             }

        // DQ (8/12/2013): Added case for SgTemplateMemberFunctionSymbol
          case V_SgTemplateMemberFunctionSymbol:
             {
               SgTemplateMemberFunctionSymbol* templateMemberFunctionSymbol = isSgTemplateMemberFunctionSymbol(symbol);
               ROSE_ASSERT(templateMemberFunctionSymbol != NULL);

               SgMemberFunctionDeclaration* memberFunctionDeclaration = templateMemberFunctionSymbol->get_declaration();
               ROSE_ASSERT(memberFunctionDeclaration != NULL);
               SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(memberFunctionDeclaration);
               if (templateMemberFunctionDeclaration != NULL)
                  {
#if 0
                    mprintf ("In getTemplateParametersOrArgumentsList<SgTemplateParameter>(): Get the template parameter lise from templateFunctionDeclaration = %p = %s name = %s \n",
                         templateMemberFunctionDeclaration,templateMemberFunctionDeclaration->class_name().c_str(),templateMemberFunctionDeclaration->get_name().str());
#endif
                    returnList = templateMemberFunctionDeclaration->get_templateParameters();
                  }
                 else
                  {
                    mprintf ("Error: Default reached in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
               break;
             }

          case V_SgTemplateVariableSymbol:
             {
               SgTemplateVariableSymbol* vsym = isSgTemplateVariableSymbol(symbol);
               ROSE_ASSERT(vsym != NULL);

               SgInitializedName* iname = vsym->get_declaration();
               ROSE_ASSERT(iname != NULL);

               SgTemplateVariableDeclaration * tplvdecl = isSgTemplateVariableDeclaration(iname->get_parent());
               ROSE_ASSERT(tplvdecl != NULL);

               returnList = tplvdecl->get_templateParameters();
               break;
             }

       // DQ (11/10/2014): Providing an initial implementation for template typedef symbol support.
          case V_SgTemplateTypedefSymbol:
             {
#if 1
            // DQ (3/5/2017): Converted to use message logging, but the mechanism is not supported here yet.
               mprintf ("WARNING: returning NULL in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
#endif
               break;
             }
#if 0
       // We have to support these sorts of declarations in the name qualifiaction.
          SgClassDeclaration*              classDeclaration     = isSgClassDeclaration(declaration);
          SgVariableDeclaration*           variableDeclaration  = isSgVariableDeclaration(declaration);
          SgFunctionDeclaration*           functionDeclaration  = isSgFunctionDeclaration(declaration);
          SgTypedefDeclaration*            typedefDeclaration   = isSgTypedefDeclaration(declaration);
          SgTemplateDeclaration*           templateDeclaration  = isSgTemplateDeclaration(declaration);
          SgEnumDeclaration*               enumDeclaration      = isSgEnumDeclaration(declaration);
          SgNamespaceDeclarationStatement* namespaceDeclaration = isSgNamespaceDeclarationStatement(declaration);
#endif
       // DQ (8/19/2013): Added case for other symbols (but we only return the empty list for this case).
          case V_SgClassSymbol:
          case V_SgVariableSymbol:
          case V_SgFunctionSymbol:
          case V_SgMemberFunctionSymbol:
          case V_SgTypedefSymbol:
          case V_SgEnumSymbol:
          case V_SgEnumFieldSymbol:
          case V_SgNamespaceSymbol:
             {
            // This function requires this case so that it can be called within very general contexts.
            // However, for this case we only return the empty template parameter list.

               break;
             }

          case V_SgNonrealSymbol:
             {
#if 0
               mprintf ("In SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): Case of SgTemplateSymbol\n");
#endif
               SgNonrealSymbol * nrsym = isSgNonrealSymbol(symbol);
               ROSE_ASSERT(nrsym != NULL);
               SgNonrealDecl * nrdecl = isSgNonrealDecl(nrsym->get_declaration());
               ROSE_ASSERT(nrdecl != NULL);
               returnList = nrdecl->get_tpl_params();
               break;
             }

          case V_SgTemplateSymbol:
             {
               mprintf ("Case of SgTemplateSymbol not handled yet in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>() \n");
               ROSE_ASSERT(false);
               break;
             }

          default:
             {
               mprintf ("Exiting in SgSymbolTable::getTemplateParametersOrArgumentsList<SgTemplateParameter>(): symbol = %p = %s \n",symbol,symbol->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return returnList;
   }


// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgClassSymbol* classSymbol)
// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
// bool SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(SgTemplateArgumentPtrList* templateArgumentsList, SgSymbol* symbol)
template <class T>
bool 
SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(std::vector<T*>* templateParametersOrArgumentsList, SgSymbol* symbol)
   {
  // DQ (8/8/2013): I needed to change the API to be more generic to support template for functions (and not just classes).

  // DQ (1/30/2013): Note that this function only supports the evaluation of template arguments for classes (and structs, and unions),
  // but not for any types of functions.  Not clear if this is a problem for the future or not, but usually there is more symmetry required.

  // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.
     bool returnValue = false;

     ROSE_ASSERT(symbol != NULL);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
     mprintf ("\nIn SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(): templateParametersOrArgumentsList = %p symbol = %p = %s \n",templateParametersOrArgumentsList,symbol,symbol->class_name().c_str());
#endif

  // DQ (8/8/2013): Added requirement that this be a SgClassSymbol, this will detect where we are using this more generally.
  // ROSE_ASSERT(isSgClassSymbol(symbol) != NULL);

     if (templateParametersOrArgumentsList != NULL)
        {
          std::vector<T*> templateParametersOrArgumentsListFromSymbol = getTemplateParametersOrArgumentsList<T>(symbol);

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("In SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments(): templateParametersOrArgumentsList->size() = %" PRIuPTR " templateParametersOrArgumentsListFromSymbol.size() = %" PRIuPTR " \n",
               templateParametersOrArgumentsList->size(),templateParametersOrArgumentsListFromSymbol.size());
#endif
       // Output a message for this case, but don't make it an error.
          if (templateParametersOrArgumentsListFromSymbol.empty() == false)
             {
            // ROSE_ASSERT(templateArgumentsList->size() == templateClassInstantiation->get_templateArguments().size());
            // ROSE_ASSERT(templateArgumentsList->size() == templateArgumentsListFromSymbol.size());
#if 0
               if (templateParametersOrArgumentsList->size() != templateParametersOrArgumentsListFromSymbol.size())
                  {
                    mprintf ("NOTE: In SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): symbol = %p = %s = %s templateParametersOrArgumentsList->size() = %" PRIuPTR " templateParametersOrArgumentsListFromSymbol.size() = %" PRIuPTR " \n",
                            symbol,symbol->class_name().c_str(),symbol->get_name().str(),templateParametersOrArgumentsList->size(),templateParametersOrArgumentsListFromSymbol.size());
                  }
#endif
            // DQ (9/19/2013): I now think this should not be an error, since it would not permit the general case where this function is used.
            // ROSE_ASSERT(templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size());
             }

       // if (templateParametersOrArgumentsListFromSymbol.empty() == false)
          if ( (templateParametersOrArgumentsListFromSymbol.empty() == false) && (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size()) )
             {
            // Check if they are the same size...

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
               mprintf ("In SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): symbol = %p = %s templateParametersOrArgumentsList->size() = %" PRIuPTR " templateClassInstantiation->get_templateArguments().size() = %" PRIuPTR " \n",
                       symbol,symbol->class_name().c_str(),templateParametersOrArgumentsList->size(),templateParametersOrArgumentsListFromSymbol.size());
               for (size_t i = 0; i < templateParametersOrArgumentsList->size(); i++)
                  {
                    mprintf ("----- (*templateParametersOrArgumentsList)[%" PRIuPTR "] = %p templateClassInstantiation->get_templateArguments()[%" PRIuPTR "] = %p \n",i,(*templateParametersOrArgumentsList)[i],i,templateParametersOrArgumentsListFromSymbol[i]);
                  }
#endif
               if (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size())
                  {
                 // Check if they are the same STL vector values...
#if 0
                 // DQ (8/10/2013): We need to get the associated template parameters or template arguments to test the STL vectors.
                    mprintf ("Exiting in SgSymbolTable::hasMatchingTemplateParametersOrArgumentsOrNoTemplateParametersOrArguments() \n");
                    ROSE_ASSERT(false);
#endif
                 // if (*templateParametersOrArgumentsList == templateClassInstantiation->get_templateArguments())
                    if (*templateParametersOrArgumentsList == templateParametersOrArgumentsListFromSymbol)
                       {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): The template argument vectors are equal \n");
#endif
                         returnValue = true;
                       }

                 // DQ (8/23/2012): If these are SgTemplateType arguments then consider them the same for now.
                 // It is less clear how to handle template arguments because the names can change in different parts of the 
                 // template declaration, so for now we will rely on the instantiated templates name and the number of arguments 
                 // if they are all SgTemplateType template arguments.
                    if (returnValue == false)
                       {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): Double check if we had set returnValue to false based on SgTemplateType template arguments (if so, then return true) \n");
#endif

                      // DQ (12/30/2018): I think a better name for this variable would be "is_matching_template_type_boolean".
                         bool isTemplateType = true;
#if 0
                      // DQ (12/30/2018): This is the original code.
                         for (size_t i = 0; i < templateParametersOrArgumentsList->size(); i++)
#else
                      // DQ 12/30/2018): We only want to test up to the first template parameter or argument that is not matching.
                      // Alternatively a "while" loop might be more clear.
                         for (size_t i = 0; ((isTemplateType == true) && (i < templateParametersOrArgumentsList->size())); i++)
#endif
                            {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                              printf("----- (*templateParametersOrArgumentsList)[%zd]        = %p = %s\n", i, (*templateParametersOrArgumentsList)[i],        (*templateParametersOrArgumentsList)[i]->unparseToString().c_str()        );
                              printf("----- templateParametersOrArgumentsListFromSymbol[%zd] = %p = %s\n", i, templateParametersOrArgumentsListFromSymbol[i], templateParametersOrArgumentsListFromSymbol[i]->unparseToString().c_str() );
#endif

                           // SgTemplateArgument* templateArgumentLocal      = isSgTemplateArgument((*templateParametersOrArgumentsList)[i]);
                           // SgTemplateArgument* templateArgumentFromSymbol = isSgTemplateArgument(templateParametersOrArgumentsListFromSymbol[i]);
                              T* templateParameterOrArgumentLocal      = (*templateParametersOrArgumentsList)[i];
                              T* templateParameterOrArgumentFromSymbol = templateParametersOrArgumentsListFromSymbol[i];
                              ROSE_ASSERT(templateParameterOrArgumentLocal != NULL);
                              ROSE_ASSERT(templateParameterOrArgumentFromSymbol != NULL);
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                           // mprintf ("----- templateArgumentLocal->get_argumentType() = %d templateArgumentFromSymbol->get_argumentType() = %d \n",templateParameterOrArgumentLocal->get_argumentType(),templateParameterOrArgumentFromSymbol->get_argumentType());
#endif
                           // DQ (6/17/2013): The get_argumentType() can be either of these.
                           //    type_argument               = 1, /*!< type parameter */
                           //    nontype_argument            = 2, /*!< nontype parameter */
                           //    template_template_argument  = 3  /*!< template template parameter */

                           // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                           // Note that this predicate function does not test if the types are equivalent.
                           // if (templateArgumentLocal->get_argumentType() == SgTemplateArgument::type_argument && templateArgumentFromSymbol->get_argumentType() == SgTemplateArgument::type_argument)
                              if (T::is_matching_type(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                 {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("----- Template parameters or arguments match in parameter or argument type: \n");
                                   mprintf ("-----    --- templateParameterOrArgumentLocal->get_type()      = %p = %s \n",templateParameterOrArgumentLocal->get_type(),     templateParameterOrArgumentLocal->get_type()->class_name().c_str());
                                   mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_type() = %p = %s \n",templateParameterOrArgumentFromSymbol->get_type(),templateParameterOrArgumentFromSymbol->get_type()->class_name().c_str());
#endif
                                   isTemplateType = SageInterface::isEquivalentType(templateParameterOrArgumentLocal->get_type(),templateParameterOrArgumentFromSymbol->get_type());
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("-----    --- SageInterface::isEquivalentType() returns: isTemplateType = %s \n",(isTemplateType == true) ? "true" : "false");
#endif
                                 }
                                else
                                 {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                   mprintf ("-----    --- T::is_matching_type() == false \n");
#endif
                                // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                                // DQ (6/17/2013): This newer code does a better job of resolving if template arguments are equivalent (more can be done still).
                                // if (templateArgumentLocal->get_argumentType() == SgTemplateArgument::nontype_argument && templateArgumentFromSymbol->get_argumentType() == SgTemplateArgument::nontype_argument)
                                   if (T::is_matching_nontype(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                      {
                                     // Test for equivalence of nontype arguments (e.g. values).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("WARNING: These are both nontype template arguments (which we are considering to be the same withouth enough testing \n");
#endif
                                     // ROSE_ASSERT(templateParameterOrArgumentLocal->get_expression() != NULL);
                                     // ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_expression() != NULL);
                                        ROSE_ASSERT(templateParameterOrArgumentLocal->get_expression() != NULL || templateParameterOrArgumentLocal->get_initializedName() != NULL);
                                        ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_expression() != NULL || templateParameterOrArgumentFromSymbol->get_initializedName() != NULL);
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("-----    --- templateParameterOrArgumentLocal->get_expression()      = %p \n",templateParameterOrArgumentLocal->get_expression());
                                        mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_expression() = %p \n",templateParameterOrArgumentFromSymbol->get_expression());
#endif
                                     // DQ (8/11/2013): We have added a SgInitializedName pointer to SgTemplateArgument (so it now matches the SgTemplateParameter, 
                                     // and because it was needed for more complex template arguments, analigous to test2013_303.C)
                                        if (templateParameterOrArgumentLocal->get_expression() == templateParameterOrArgumentFromSymbol->get_expression())
                                           {
                                          // DQ (8/11/2013): Note that these might have been equal because they were both NULL.
                                          // isTemplateType = true;
                                             if (templateParameterOrArgumentLocal->get_expression() != NULL)
                                                {
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- templateParameterOrArgumentLocal->get_initializedName()      = %p type = %p \n",
                                                       templateParameterOrArgumentLocal->get_initializedName(),templateParameterOrArgumentLocal->get_initializedName()->get_type());
                                                  mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_initializedName() = %p type = %p \n",
                                                       templateParameterOrArgumentFromSymbol->get_initializedName(),templateParameterOrArgumentFromSymbol->get_initializedName()->get_type());
#endif
                                                  ROSE_ASSERT(templateParameterOrArgumentLocal->get_initializedName() != NULL);
                                                  ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_initializedName() != NULL);

                                               // DQ (12/8/2015): FIXME: This is not a good enough test, this can be improved.
                                                  if (templateParameterOrArgumentLocal->get_initializedName() == templateParameterOrArgumentFromSymbol->get_initializedName())
                                                     {
                                                       isTemplateType = true;
                                                     }
                                                    else
                                                     {
                                                    // DQ (8/19/2013): The possible problem here is that two SgInitializedName objects might be the same and yet be different pointers.
                                                    // So this might still not be a good enough test.  An alternative might be to double check the name and the scope as what might be 
                                                    // a better test.
#if 0

                                                       printf("-----    --- initializedName objects where not the same (checking the names saved as strings in each SgInitializedName object) \n");
#endif
                                                    // DQ (12/8/2015): Check if the names are the same (independent of the SgIntializedName object pointers).
                                                       std::string str1 = templateParameterOrArgumentLocal->get_initializedName()->get_name().str();
                                                       std::string str2 = templateParameterOrArgumentFromSymbol->get_initializedName()->get_name().str();
                                                    // if (templateParameterOrArgumentLocal->get_initializedName()->get_name().str() != templateParameterOrArgumentFromSymbol->get_initializedName()->get_name().str())
                                                       if (str1 != str2)
                                                          {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS || 0
                                                            mprintf ("-----    --- --- These are NOT the same initializedName values and should have resolved to be the same pointer value if there were the same initializedName! (really?) \n");
                                                            mprintf ("WARNING: initializedName associated with same different initializedName was not checked... (might be different initializedName with the same name and type) \n");
                                                            mprintf ("templateParameterOrArgumentLocal->get_initializedName() = %s templateParameterOrArgumentFromSymbol->get_initializedName() = %s \n",str1.c_str(),str2.c_str());
#endif
                                                          }


                                                    // DQ (2/16/2014): test2014_17.C demonstrates that the SgInitializedName pointers need not match for this to be the same template parameter.
                                                    // I think it is enough that they are the same type, but it migh also be required that the names match as well (but I don't think this is 
                                                    // required for C++).
                                                    // isTemplateType = false;

                                                    // DQ (12/8/2015): Using newly implemented function for type equivalence.
                                                    // DQ (12/8/2015): FIXME: This is not a good enough test, this can be improved.
                                                    // DQ (12/15/2015): This causes a problem for SgTemplateType and SgMemberFunctionType and demonstrates the problem for debugging.
                                                       if (templateParameterOrArgumentLocal->get_initializedName()->get_type()->isEquivalentType(templateParameterOrArgumentFromSymbol->get_initializedName()->get_type()) == true)
                                                          {
                                                            isTemplateType = true;
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                            mprintf ("-----    --- --- These are NOT the same initializedName pointers, but they match in type! \n");
#endif
                                                         // DQ (7/7/2014): If these are not the same name then there is no match (see test2014_78.C).
                                                         // TV (06/21/2018): TODO look into this more...
                                                            if (false && templateParameterOrArgumentLocal->get_initializedName()->get_name() != templateParameterOrArgumentFromSymbol->get_initializedName()->get_name())
                                                               {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                              // DQ (7/7/2014): For now output debugging informationfor this case.
                                                                 mprintf ("These names failed to match: \n");
                                                                 mprintf (" --- templateParameterOrArgumentLocal->get_initializedName()->get_name()      = %s \n",templateParameterOrArgumentLocal->get_initializedName()->get_name().str());
                                                                 mprintf (" --- templateParameterOrArgumentFromSymbol->get_initializedName()->get_name() = %s \n",templateParameterOrArgumentFromSymbol->get_initializedName()->get_name().str());
#endif
#if 0
                                                              // Extra information to track down the example code.
                                                                 templateParameterOrArgumentLocal->get_initializedName()->get_file_info()->display("templateParameterOrArgumentLocal: debug");
                                                                 templateParameterOrArgumentFromSymbol->get_initializedName()->get_file_info()->display("templateParameterOrArgumentLocal: debug");
#endif

                                                                 isTemplateType = false;
                                                               }
                                                         // DQ (2/16/2014): I am not certain that the names have to match, but assert this for now as part of testing!
                                                         // ROSE_ASSERT (templateParameterOrArgumentLocal->get_initializedName()->get_name() == templateParameterOrArgumentFromSymbol->get_initializedName()->get_name());
                                                          }
                                                         else
                                                          {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                            mprintf ("-----    --- --- These are NOT the same initializedName pointers OR the same type! \n");
#endif
                                                            isTemplateType = false;
                                                          }
                                                     }
                                                }
                                           }
                                          else
                                           {
                                          // DQ (12/8/2015): FIXME: These pointers to different expressions are nearly always the same expression after evaluation.
                                          // Different pointer values mean different expressions (I hope this is always true).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS || 0
                                             mprintf ("-----    --- --- These are NOT the same expresion values and should have resolved to be the same pointer value if there were the same expression! (really?) \n");
                                             mprintf ("WARNING: value associated with same different expressions was not checked... (might be different constants with the same value) \n");
                                             std::string str1 = templateParameterOrArgumentLocal->get_expression()->unparseToString();
                                             std::string str2 = templateParameterOrArgumentFromSymbol->get_expression()->unparseToString();
                                             mprintf ("unparsed expressions: %s and %s \n",str1.c_str(),str2.c_str());
#endif
                                           }
                                      }
                                     else
                                      {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                        mprintf ("-----    --- T::is_matching_nontype() == false \n");
#endif
                                     // DQ (8/10/2013): Test for if the template parameter or arguments type matches (type, nontype, template_template).
                                     // if (templateArgumentLocal->get_argumentType() == SgTemplateArgument::template_template_argument && templateArgumentFromSymbol->get_argumentType() == SgTemplateArgument::template_template_argument)
                                        if (T::is_matching_template(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                           {
                                          // Test for equivalence of template_template arguments.
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("WARNING: These are both template template template arguments (which we are considering to be the same without enough testing \n");
#endif
                                             ROSE_ASSERT(templateParameterOrArgumentLocal->get_templateDeclaration() != NULL);
                                             ROSE_ASSERT(templateParameterOrArgumentFromSymbol->get_templateDeclaration() != NULL);
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("-----    --- templateParameterOrArgumentLocal->get_templateDeclaration()      = %p \n",templateParameterOrArgumentLocal->get_templateDeclaration());
                                             mprintf ("-----    --- templateParameterOrArgumentFromSymbol->get_templateDeclaration() = %p \n",templateParameterOrArgumentFromSymbol->get_templateDeclaration());
#endif
                                             if (templateParameterOrArgumentLocal->get_templateDeclaration() == templateParameterOrArgumentFromSymbol->get_templateDeclaration())
                                                {
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
                                               // Different pointer values mean different expressions (I hope this is always true).
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- --- These are NOT the same template declaration values and should have resolved to be the same pointer value if there were the same template template declaration argument value \n");
#endif
                                                }
                                           }
                                          else
                                           {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                             mprintf ("-----    --- T::is_matching_template() == false \n");
#endif
                                          // ROSE_ASSERT(templateArgumentLocal->get_argumentType() != templateArgumentFromSymbol->get_argumentType());
                                          // DQ (5/19/2014): Output more debugging information.
                                             if (T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                                {
#if 0
                                                  mprintf ("Error: templateParameterOrArgumentLocal      = %p = %s \n",templateParameterOrArgumentLocal,templateParameterOrArgumentLocal->class_name().c_str());
                                                  mprintf ("Error: templateParameterOrArgumentFromSymbol = %p = %s \n",templateParameterOrArgumentFromSymbol,templateParameterOrArgumentFromSymbol->class_name().c_str());
#endif
                                                  SgTemplateArgument* templateArgumentLocal        = isSgTemplateArgument(templateParameterOrArgumentLocal);
                                                  SgTemplateArgument* templateArgumentFromSymbol   = isSgTemplateArgument(templateParameterOrArgumentFromSymbol);
                                                  SgTemplateParameter* templateParameterLocal      = isSgTemplateParameter(templateParameterOrArgumentLocal);
                                                  SgTemplateParameter* templateParameterFromSymbol = isSgTemplateParameter(templateParameterOrArgumentFromSymbol);
                                                  if (templateArgumentLocal != NULL)
                                                     {
                                                       ROSE_ASSERT(templateArgumentFromSymbol != NULL);
#if 0
                                                       mprintf ("templateArgumentLocal->get_argumentType()      = %d \n",templateArgumentLocal->get_argumentType());
                                                       mprintf ("templateArgumentFromSymbol->get_argumentType() = %d \n",templateArgumentFromSymbol->get_argumentType());
#endif
                                                     }
                                                    else
                                                     {
                                                       ROSE_ASSERT(templateParameterLocal != NULL);
                                                       ROSE_ASSERT(templateParameterFromSymbol != NULL);
#if 0
                                                       mprintf ("templateParameterLocal->get_parameterType()      = %d \n",templateParameterLocal->get_parameterType());
                                                       mprintf ("templateParameterFromSymbol->get_parameterType() = %d \n",templateParameterFromSymbol->get_parameterType());
#endif
                                                     }
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("----- T::is_matching_kind() == false: \n");
#endif
                                                }

                                          // DQ (5/19/2014): /include/boost/chrono/duration.hpp contains a new kind of template argument that maps to what EDG calls tak_start_of_pack_expansion.
                                          // This support is not yet implemented in ROSE (version 1.50 of Boost and version 4.9 of EDG are required to detect this).
                                          // returning "isTemplateType = false;" for now.
                                          // ROSE_ASSERT(T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == false);
                                             if (T::is_matching_template_pack_expansion(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == true)
                                                {
#if 0
                                                  mprintf ("----- SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): This is the case of a template_pack_expansion: not yet supported (edg calls this tak_start_of_pack_expansion) \n");
#endif
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("----- SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): This is the case of a template_pack_expansion: not yet supported (edg calls this tak_start_of_pack_expansion) \n");
#endif
                                               // DQ (12/28/2018): Return true if both a marked as template pack.
                                                  isTemplateType = true;
                                                }
                                               else
                                                {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                                                  mprintf ("-----    --- T::is_matching_template_pack_expansion() == false \n");
#endif
                                                  ROSE_ASSERT(T::is_matching_kind(*templateParameterOrArgumentLocal,*templateParameterOrArgumentFromSymbol) == false);

                                               // DQ (12/28/2018): Return false.
                                                  isTemplateType = false;
                                                }

                                          // DQ (12/28/2018): We want to set this differently in the two branches above.
                                          // These are not the same type: so return false.
                                          // isTemplateType = false;
                                           }
                                      }
                                 }
                            }

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                         mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): we are relying on only the existence of all SgTemplateType template arguments to decide that this is a match isTemplateType = %s \n",
                              isTemplateType ? "true" : "false");
#endif
                         returnValue = isTemplateType;
                       }
                  }
             }
            else
             {
            // DQ (8/22/2012): Consider if this make sense...yes, if it is not a template instantiation then matching is based on name in a specific scope only.
            // DQ (5/8/2016): Actually it is based on the name and the template parameters (I think the number of template parameters only, but I am not certain).
#if 1
            // DQ (5/8/2016): If the list is not empty then it had a different number of arguments and so it can't be the same (return false)
               if (templateParametersOrArgumentsListFromSymbol.empty() == false)
                  {
                 // && (templateParametersOrArgumentsList->size() == templateParametersOrArgumentsListFromSymbol.size())
                 // Check if they are the same size...
                 // DQ (5/8/2016): If the list is not empty then it had a different number of arguments and so it can't be the same (return false)
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                    mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsListFromSymbol.empty() == false: different size list: (return false) \n");
#endif
                    returnValue = false;
                  }
                 else
                  {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
                    mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsListFromSymbol.empty() == true (return true) \n");
#endif
                    returnValue = true;
                  }
#else

#error "DEAD CODE!"

#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
               mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateClassInstantiation == NULL (return true) \n");
#endif
               returnValue = true;
#endif
             }
        }
       else
        {
#if DEBUG_MATCHING_TEMPLATE_ARGUMENTS
          mprintf ("WARNING: SgSymbolTable::hasMatchingTemplateArgumentsOrNoTemplateArguments(): templateParametersOrArgumentsList == NULL (return true) \n");
#endif
          returnValue = true;
        }

     return returnValue;
   }


SgClassSymbol*
SgSymbolTable::find_class(const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList)
   {
  // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.

  // DQ (5/20/2013): Using the find_template_symbol_support() function with templateParameterList == NULL;
  // s = find_symbol_support<SgTemplateClassSymbol>(nm);
  // SgTemplateParameterPtrList* templateParameterList = NULL;
  // return find_template_symbol_support<SgClassSymbol,SgClassDeclaration>(nm,templateParameterList,templateArgumentsList);

  // return find_symbol_with_template_args_support<SgClassSymbol>(nm,templateArgumentsList);
  // return find_symbol_support<SgClassSymbol>(nm,NULL,templateArgumentsList);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,templateArgumentsList,filterTemplateSymbols);
   }

#if 0
SgAliasSymbol*
SgSymbolTable::find_alias(const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList)
   {
#if 0
     mprintf ("In SgSymbolTable::find_alias(): nm = %s \n",nm.str());
#endif

     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgAliasSymbol>(nm,NULL,NULL,templateArgumentsList,filterTemplateSymbols);
   }
#endif

SgNonrealSymbol*
SgSymbolTable::find_nonreal(const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgNonrealSymbol>(nm,NULL,templateParameterList,templateArgumentsList,filterTemplateSymbols);
   }



#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgFunctionTypeSymbol*
SgSymbolTable::findfunctype(const SgName &nm)
   {
     return find_function_type(nm);
   }
#endif

SgFunctionTypeSymbol*
SgSymbolTable::find_function_type(const SgName & nm)
   {
  // return find_symbol_support<SgFunctionTypeSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgFunctionTypeSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

SgLabelSymbol*
SgSymbolTable::find_label(const SgName & nm)
   {
  // return find_symbol_support<SgLabelSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgLabelSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

//
// charles4: added this function for the Java case...
//
SgJavaLabelSymbol*
SgSymbolTable::find_java_label(const SgName & nm)
   {
  // return find_symbol_support<SgJavaLabelSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgJavaLabelSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

// DQ (1/30/2007): Added these back into ROSE.
SgNamespaceSymbol* 
SgSymbolTable::find_namespace ( const SgName & nm )
   {
  // return find_symbol_support<SgNamespaceSymbol>(nm);
     bool filterTemplateSymbols = false;
     return find_symbol_with_type_support<SgNamespaceSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName & nm, const SgType* t)
   {
     return find_function(nm,t);
   }
#endif


// SgFunctionSymbol* SgSymbolTable::find_function (const SgName & nm, const SgType* t)
SgFunctionSymbol*
SgSymbolTable::find_function (const SgName & nm, const SgType* type, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(type != NULL);

     bool filterTemplateSymbols = false;
     SgFunctionSymbol *s = find_symbol_with_type_support<SgFunctionSymbol>(nm,type,NULL,templateArgumentList,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or 
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (8/13/2013): We should not be returning a template symbol from this function (verify this).
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

// DQ (12/27/2011): Added more support for template declarations in the AST.
// DQ (12/12/2011): New functions to support template declarations in the AST.
// SgTemplateSymbol* SgFunctionSymbol* SgSymbolTable::find_nontemplate_function(const SgName& nm, const SgType* t)
SgFunctionSymbol*
SgSymbolTable::find_nontemplate_function(const SgName& nm, const SgType* t, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(t != NULL);

     bool filterTemplateSymbols = true;
     SgFunctionSymbol *s = find_symbol_with_type_support<SgFunctionSymbol>(nm,t,NULL,templateArgumentList,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or 
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (5/23/2013): Added assertion on retuned symbol.
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

// DQ (7/31/2013): Adding support for template parameters and template specialization.
// SgTemplateFunctionSymbol* SgSymbolTable::find_template_function(const SgName& nm, const SgType* t)
// SgTemplateFunctionSymbol* SgSymbolTable::find_template_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateSpecializationArgumentList)
SgTemplateFunctionSymbol*
SgSymbolTable::find_template_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateParameterList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(t != NULL);

#if 0
     mprintf ("In SgSymbolTable::find_template_function(): nm = %s t = %p templateParameterList = %p size = %zu \n",nm.str(),t,templateParameterList,templateParameterList->size());
#endif

     bool filterTemplateSymbols = false;
     SgTemplateFunctionSymbol *s = find_symbol_with_type_support<SgTemplateFunctionSymbol>(nm,t,templateParameterList,NULL,filterTemplateSymbols);

     return s;
   }

SgTemplateVariableSymbol*
SgSymbolTable::find_template_variable(const SgName& nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList)
   {
#if 0
     mprintf ("In SgSymbolTable::find_template_variable(): nm = %s templateParameterList = %p size = %zu \n",nm.str(),templateParameterList,templateParameterList->size());
#endif

     bool filterTemplateSymbols = false;
     SgTemplateVariableSymbol *s = find_symbol_with_type_support<SgTemplateVariableSymbol>(nm,NULL,templateParameterList,templateArgumentsList,filterTemplateSymbols);

     return s;
   }


// DQ (12/27/2011): Added more support for template declarations in the AST.
// SgMemberFunctionSymbol* SgSymbolTable::find_nontemplate_member_function(const SgName& nm, const SgType* t)
SgMemberFunctionSymbol*
SgSymbolTable::find_nontemplate_member_function(const SgName& nm, const SgType* t, SgTemplateArgumentPtrList* templateArgumentList)
   {
     SgMemberFunctionSymbol *s = NULL;

  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(t != NULL);

     bool filterTemplateSymbols = true;
     s = find_symbol_with_type_support<SgMemberFunctionSymbol>(nm,t,NULL,templateArgumentList,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or 
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (8/13/2013): We should not be returning a template symbol from this function (verify this).
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }


// SgTemplateMemberFunctionSymbol* SgSymbolTable::find_template_member_function(const SgName& nm, const SgType* t)
// SgTemplateMemberFunctionSymbol* SgSymbolTable::find_template_member_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateList, SgTemplateArgumentPtrList* templateSpecializationArgumentList)
SgTemplateMemberFunctionSymbol*
SgSymbolTable::find_template_member_function(const SgName& nm, const SgType* t, SgTemplateParameterPtrList* templateParameterList)
   {
  // DQ (8/22/2013): We need to allow for functions to be searched for by name if the type is unavailable.
  // ROSE_ASSERT(t != NULL);

     bool filterTemplateSymbols = false;
     SgTemplateMemberFunctionSymbol *s = find_symbol_with_type_support<SgTemplateMemberFunctionSymbol>(nm,t,templateParameterList,NULL,filterTemplateSymbols);

     return s;
   }


// DQ (12/26/2011): Adding revised support for template declarations in the AST.
// SgClassSymbol* SgSymbolTable::find_nontemplate_class (const SgName & nm)
SgClassSymbol*
SgSymbolTable::find_nontemplate_class (const SgName & nm, SgTemplateArgumentPtrList* templateArgumentsList)
   {
     bool filterTemplateSymbols = true;
     SgClassSymbol* s = find_symbol_with_type_support<SgClassSymbol>(nm,NULL,NULL,templateArgumentsList,filterTemplateSymbols);

  // DQ (8/12/2013): The semantics of find_symbol_with_template_args_support() was to never 
  // return a SgTemplateClassSymbol where as the semantics of find_symbol_support() is to 
  // return anything that is a derived class from SgClassSymbol, which can be a SgTemplateClassSymbol.
  // So this is an error in EDG/ROSE function: retrieveAssociatedClassSymbol().
  // Need to fix this tomorrow morning (make the function optionally strict so that we can 
  // reuse the same minimal templated support.
     ROSE_ASSERT(isSgTemplateClassSymbol(s) == NULL);

     return s;
   }


// SgTemplateClassSymbol* SgSymbolTable::find_template_class (const SgName & nm)
SgTemplateClassSymbol*
SgSymbolTable::find_template_class (const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
   {
//   ROSE_ASSERT(templateParameterList != NULL); // TV: when we are looking for the original declaration of a template from potential specialization (we only have the name)

     bool filterTemplateSymbols = false;
     SgTemplateClassSymbol *s = find_symbol_with_type_support<SgTemplateClassSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList,filterTemplateSymbols);

     return s;
   }

// DQ (3/8/2017): Adding support for SgTemplateTypedefSymbol handling.
// SgTemplateClassSymbol* SgSymbolTable::find_template_class (const SgName & nm)
// SgTemplateTypedefSymbol* SgSymbolTable::find_template_typedef (const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList )
SgTemplateTypedefSymbol* 
SgSymbolTable::find_template_typedef (const SgName & nm)
   {
  // ROSE_ASSERT(templateParameterList != NULL);

     SgTemplateParameterPtrList* templateParameterList              = NULL;
     SgTemplateArgumentPtrList*  templateSpecializationArgumentList = NULL;

     bool filterTemplateSymbols = false;
  // SgTemplateTypedefSymbol *s = find_symbol_with_type_support<SgTemplateTypedefSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList);
     SgTemplateTypedefSymbol *s = find_symbol_with_type_support<SgTemplateTypedefSymbol>(nm,NULL,templateParameterList,templateSpecializationArgumentList,filterTemplateSymbols);

     return s;
   }


#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
SgFunctionSymbol*
SgSymbolTable::findfunc(const SgName & nm)
   {
     return find_function(nm);
   }
#endif


SgFunctionSymbol*
SgSymbolTable::find_function(const SgName & nm)
   {
     bool filterTemplateSymbols = false;
     SgFunctionSymbol* s = find_symbol_with_type_support<SgFunctionSymbol>(nm,NULL,NULL,NULL,filterTemplateSymbols);

  // DQ (8/22/2013): We have to allow this function to return either SgTemplateFunctionSymbol or 
  // SgTemplateMemberFunctionSymbol when not enough information (type == NULL or templateArgumentList == NULL).
  // DQ (8/13/2013): We should not be returning a template symbol from this function (verify this).
  // ROSE_ASSERT(isSgTemplateFunctionSymbol(s) == NULL && isSgTemplateMemberFunctionSymbol(s) == NULL);

     return s;
   }

#if 0
// DQ (8/21/2013): It might be a mistake to remove this symbol lookup function since there may still be
// some SgTemplateSymbol IR nodes to handle unusual template cases.  This neds to be checked.

// SgTemplateSymbol* SgSymbolTable::find_template(const SgName & nm)
SgTemplateSymbol*
SgSymbolTable::find_template(const SgName & nm, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList)
   {
  // DQ (8/13/2013): Since function templates, member function templates, and class templates are symbols not derived from SgTemplateSymbol, 
  // this function is not very useful since it returns a SgTemplateSymbol.  This was a part of the older pre-EDG4x API.

  // DQ (8/12/2013): I think this is the wrong function to call.
     mprintf ("ERROR: This function is not specific enough, please select find_template_class(), or find_template_function(), or find_template_member_function() \n");
     ROSE_ASSERT(false);

  // DQ (5/20/2013): New use of template function to abstract the specific type and refactor support for symbol table handling.
  // return find_symbol_support<SgTemplateSymbol>(nm);
     SgTemplateSymbol* s = find_symbol_support<SgTemplateSymbol>(nm,templateParameterList,templateSpecializationArgumentList);

     return s;
   }
#endif

#define DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING 0

template<class ReturnType>
bool
templateParameterAndArgumentErrorChecking(SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
   {
  // DQ (8/11/2013): This function implements error checking on when template arguments and template parameters can be used relative to specific IR nodes
  // (template declarations, template instantiations, and non-template instantiations (normal functions and classes).

  // This function implements error checking for the functions: SgSymbolTable::find_symbol_support() and SgSymbolTable::find_symbol_with_type_support().
  // It is used within an assertion at the top of these template functions.

     bool returnValue = true;

     VariantT returnTypeVariant = (VariantT)ReturnType::static_variant;

  // DQ (8/17/2013): We need to permit ReturnType to be a SgSymbol so that we can support more general queries in the symbol table.
  // if (templateParameterList != NULL || templateArgumentList != NULL)
     if ((returnTypeVariant != V_SgSymbol) && (templateParameterList != NULL || templateArgumentList != NULL))
        {
          if (templateParameterList != NULL)
             {
            // ROSE_ASSERT((VariantT)ReturnType::static_variant == V_SgTemplateClassDeclaration || (VariantT)ReturnType::static_variant == V_SgTemplateFunctionDeclaration || (VariantT)ReturnType::static_variant == V_SgTemplateMemberFunctionDeclaration);
               returnValue = (returnTypeVariant == V_SgTemplateClassSymbol || returnTypeVariant == V_SgTemplateFunctionSymbol || returnTypeVariant == V_SgTemplateMemberFunctionSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
               mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList != NULL && templateArgumentList == NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
             }

          if (templateParameterList != NULL && templateArgumentList != NULL)
             {
            // This is the only allowed case (since functions template can be partially specialized.
            // ROSE_ASSERT((VariantT)ReturnType::static_variant == V_SgTemplateClassDeclaration);
               returnValue = (returnTypeVariant == V_SgTemplateClassSymbol || returnTypeVariant == V_SgTemplateVariableSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
               mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList != NULL && templateArgumentList != NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
             }
            else
             {
               if (templateArgumentList != NULL)
                  {
                 // ROSE_ASSERT((VariantT)ReturnType::static_variant == V_SgTemplateInstantiationDecl || (VariantT)ReturnType::static_variant == V_SgTemplateInstantiationFunctionDecl || (VariantT)ReturnType::static_variant == V_SgTemplateInstantiationMemberFunctionDecl);
                    returnValue = (returnTypeVariant == V_SgClassSymbol || returnTypeVariant == V_SgFunctionSymbol || returnTypeVariant == V_SgMemberFunctionSymbol || returnTypeVariant == V_SgNonrealSymbol);
#if DEBUG_TEMPLATE_PARAMETERS_AND_ARGUMENTS_ERROR_CHECKING
                    mprintf ("In templateParameterAndArgumentErrorChecking(): templateParameterList == NULL && templateArgumentList != NULL: returnValue = %s \n",returnValue ? "true" : "false");
#endif
                  }
             }
        }

     return returnValue;
   }


#define DEBUG_SYMBOL_FILTER 0

// DQ (4/14/2017): Test test2017_30.C demonstrates that we need to be able to force the filtering of symbols from templates
// and that they only way to do this is with an extra paramter to force this to happen.  Since the lack of information triggers 
// the more general semantics to return any symbol (which is fine as a simple API, but inconsistant with when this is called
// indirectly from the lookup_nontemplate_function_symbol() function (for example).
// template<class ReturnSymbolType> ReturnSymbolType* symbolFilter(ReturnSymbolType* symbol, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
template<class ReturnSymbolType>
ReturnSymbolType*
symbolFilter(ReturnSymbolType* symbol, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols)
   {
  // DQ (8/13/2013): This function filters types of IR nodes that could not be considered given the rules 
  // for what IR nodes apply when template parameters lists and template argument lists are provided.

     if (symbol != NULL)
        {
          VariantT symbolVariant = symbol->variantT();

#if DEBUG_SYMBOL_FILTER
          mprintf ("In symbolFilter(): symbolVariant = %d ReturnSymbolType variant = %d templateParameterList = %p templateArgumentList = %p \n",(int)symbolVariant,(int)ReturnSymbolType::static_variant,templateParameterList,templateArgumentList);
          mprintf ("   --- symbol = %p = %s \n",symbol,symbol->class_name().c_str());
          mprintf ("   --- symbol->get_name() = %s \n",symbol->get_name().str());
          mprintf ("   --- V_SgClassSymbol = %d \n",(int)V_SgClassSymbol);
          mprintf ("   --- V_SgFunctionSymbol = %d V_SgMemberFunctionSymbol = %d \n",(int)V_SgFunctionSymbol,(int)V_SgMemberFunctionSymbol);
          mprintf ("   --- V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
               (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
          mprintf ("   --- filterTemplateSymbols = %s \n",filterTemplateSymbols ? "true" : "false");
#if 0
       // Not all language constructs associated with a symbol are a SgDeclarationStatement.
       // SgDeclarationStatement* declaration = symbol->get_declaration();
          SgLocatedNode* declaration = symbol->get_declaration();

          mprintf ("   --- declaration = %p \n",declaration);

          if (declaration != NULL)
             {
               mprintf ("   --- declaration = %p = %s \n",declaration,declaration->class_name().c_str());

            // The source positions is not always set (e.g. during AST construction).
               if (declaration->get_file_info() != NULL)
                  {
                    SgStatement* statement = isSgStatement(declaration);
                    if (statement != NULL)
                       {
                         ROSE_ASSERT(statement->get_file_info() != NULL);
                         statement->get_file_info()->display("symbol declaration location (statement)");
                       }
                      else
                       {
                         if (declaration->get_file_info() != NULL)
                            {
                              declaration->get_file_info()->display("symbol declaration location (non-statement)");
                            }
                           else
                            {
                              mprintf ("WARNING: In symbolFilter(): statement == NULL: declaration->get_file_info() == NULL \n");
                            }
                       }
                  }
                 else
                  {
                    mprintf ("WARNING: In symbolFilter(): declaration->get_file_info() == NULL \n");
                  }
             }
            else
             {
               mprintf ("WARNING: In symbolFilter(): declaration == NULL \n");
             }
#endif
#endif

          if (templateParameterList != NULL)
             {
            // DQ (8/13/2013): If a template parameter list AND template argument list WERE provided then we only want to find class templates,
            // so if this is NOT a template reset it to NULL. Note that the previous cast will have eliminated function symbols
               if ( (templateArgumentList != NULL) && (symbolVariant == V_SgClassSymbol) )
                  {
#if DEBUG_SYMBOL_FILTER
                    mprintf ("Reset symbol to NULL: (templateParameterList != NULL && templateArgumentList != NULL): V_SgClassSymbol = %d \n",(int)V_SgClassSymbol);
#endif
                    symbol = NULL;
                  }

            // DQ (8/13/2013): If a template parameter list WAS provided and a template argument list was NOT provided then we only want to find function templates, 
            // so if this is NOT a template reset it to NULL. Note that the previous cast will have eliminated class symbols.
               if ( (templateArgumentList == NULL) && (symbolVariant == V_SgFunctionSymbol || symbolVariant == V_SgMemberFunctionSymbol) )
                  {
#if DEBUG_SYMBOL_FILTER
                    mprintf ("Reset symbol to NULL: (templateParameterList != NULL && templateArgumentList == NULL): V_SgFunctionSymbol = %d V_SgMemberFunctionSymbol = %d \n",(int)V_SgFunctionSymbol,(int)V_SgMemberFunctionSymbol);
#endif
                    symbol = NULL;
                  }
             }
            else
             {
               if (templateArgumentList != NULL)
                  {
                 // DQ (8/13/2013): If a template parameter list was NOT provided then we only want to find non-templates, 
                 // so if this IS a template reset it to NULL.
                    if ( symbolVariant == V_SgTemplateFunctionSymbol || symbolVariant == V_SgTemplateMemberFunctionSymbol || symbolVariant == V_SgTemplateClassSymbol )
                       {
                      // This can't be a template since there is no templateParameterList
#if DEBUG_SYMBOL_FILTER
                         mprintf ("Reset symbol to NULL: (templateParameterList == NULL): V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
                              (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
#endif
                         symbol = NULL;
                       }
                  }
                 else
                  {
                 // DQ (4/14/2017): Added support to disallow template symbolds explicitly.
                    if (filterTemplateSymbols == true)
                       {
                      // DQ (4/14/2017): This can't be a template symbol since we explicitly disallow it using a function parameter to control this.
#if DEBUG_SYMBOL_FILTER
                         mprintf ("Reset symbol to NULL: (filterTemplateSymbols == true && templateParameterList == NULL && templateArgumentList == NULL): V_SgTemplateFunctionSymbol = %d V_SgTemplateMemberFunctionSymbol = %d V_SgTemplateClassSymbol = %d \n",
                              (int)V_SgTemplateFunctionSymbol,(int)V_SgTemplateMemberFunctionSymbol,(int)V_SgTemplateClassSymbol);
#endif
                      // DQ (4/14/2017): Check if this is a template symbol (if so then set symbol to NULL to avoid returning a template symbol).
                         if ( symbolVariant == V_SgTemplateFunctionSymbol || symbolVariant == V_SgTemplateMemberFunctionSymbol || 
                              symbolVariant == V_SgTemplateClassSymbol    || symbolVariant == V_SgTemplateTypedefSymbol        || 
                              symbolVariant == V_SgTemplateVariableSymbol )
                            {
                              symbol = NULL;
                            }
                       }
                      else
                       {
                      // DQ (4/14/2017): Original case before adding explicit control to avoid symbols associated with template declarations.

                      // If both templateParameterList == NULL and templateArgumentList == NULL, then we have not provided enough 
                      // information and are looking up symbols based only on name (and maybe type) and need to find the first match 
                      // based on only this limited information.  Basically, we want to provide the best possible match when less
                      // than enough information is available to make a precise match.
#if DEBUG_SYMBOL_FILTER
                         mprintf ("DO NOT Reset symbol to NULL: (templateParameterList == NULL && templateArgumentList == NULL): not enough information provided for a precise match \n");
#endif
                       }
                  }
             }
        }

#if DEBUG_SYMBOL_FILTER
     mprintf ("Leaving symbolFilter(): symbol = %p templateParameterList = %p templateArgumentList = %p filterTemplateSymbols = %s \n",
          symbol,templateParameterList,templateArgumentList,filterTemplateSymbols ? "true" : "false");
#endif

     return symbol;
   }

bool
isSubset(const std::vector<SgNode*>& a_vector, const std::set<SgNode*>& b_set)
   {
  // DQ (7/12/2014): I am not aware of a faster algorithm for this. Using the shorter 
  // vector (from the SgAliasSymbol) first will generally reduce the complexity for 
  // order Na * log Nb instead of log Nb.  The value of Na would be the number of 
  // causal nodes for any SgAliasSymbol (typically one) and Nb would be the number 
  // of causal SgNode objects (e.g. SgUsingDirectiveStatement, SgUsingDeclarationStatement, 
  // SgBaseClass, etc.). 

#define DEBUG_IS_SUBSET 0

#if DEBUG_IS_SUBSET
     mprintf ("In isSubset(): a_vector.size() = %zu b_set.size() = %zu \n",a_vector.size(),b_set.size());
#endif

     for (std::vector<SgNode*>::const_iterator i = a_vector.begin(); i != a_vector.end(); i++)
        {
          bool found = false;
#if 0
          for (std::set<SgNode*>::const_iterator j = b_set.begin(); j != b_set.end(); j++)
             {
               if (*i == *j)
                  {
                    found = true;
                    break;
                  }
             }
#else
          std::set<SgNode*>::const_iterator j = find(b_set.begin(),b_set.end(),*i);
          found = (j != b_set.end());
#endif
#if DEBUG_IS_SUBSET
          mprintf ("In isSubset(): loop: found = %s *i = %p = %s \n",found ? "true" : "false",*i,(*i)->class_name().c_str());
#endif
          if (!found)
             {
#if DEBUG_IS_SUBSET
               mprintf ("Leaving isSubset(): returning false \n");
#endif
               return false;
             }
        }

#if DEBUG_IS_SUBSET
     mprintf ("Leaving isSubset(): returning true \n");
#endif

     return true;
   }


#define DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS 0

// DQ (4/14/2017): Added explicit control to filer symbols associated with templates (see test2017_30.C for where this is required).
// DQ (7/31/2013): Added support for template parameters and template specialization.
// template<class ReturnType> ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type)
// template<class ReturnType> ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList)
template<class ReturnType>
ReturnType* SgSymbolTable::find_symbol_with_type_support (const SgName & nm, const SgType* type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList, bool filterTemplateSymbols)
   {
  // Templated function to support retrival of different types of symbols from the symbol table.
  // This refactors a lot of code (some now and more later).

  // This low level templated function only makes sense for where the ReturnType is either of: 
  //    SgFunctionSymbol, SgMemberFunctionSymbol, SgTemplateFunctionSymbol, SgTemplateMemberFunctionSymbol.

  // DQ (5/20/2013): Newer implementation of the symbol table handling to account for the template type, SgRenameSymbol, and SgAliasSymbols (in that order).

     assert(p_table != NULL);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
     mprintf ("---------------------------------------------------------------------------------- \n");
     mprintf ("In find_symbol_with_type_support(nm = %s, type = %p = %s, templateParameterList = %p, templateArgumentList = %p, filterTemplateSymbols = %s) \n",
          nm.str(),type,(type != NULL) ? type->class_name().c_str() : "null",templateParameterList,templateArgumentList,filterTemplateSymbols ? "true" : "false");
#endif

     ROSE_ASSERT(templateParameterAndArgumentErrorChecking<ReturnType>(templateParameterList,templateArgumentList) == true);

  // bool restrictToSpecificType = true;

  // p_iterator = p_table->find(nm);
  // hash_iterator save_original_iterator = p_iterator;

  // Find the sublist that match the name.
     std::pair<hash_iterator, hash_iterator> range = p_table->equal_range(nm);
     std::pair<hash_iterator, hash_iterator> save_original_range = range;

  // First look through only the local (non-aliased) symbols.

  // while(p_iterator != p_table->end())
     for (hash_iterator i = range.first; i != range.second; ++i)
        {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("Check for SgAliasSymbol in SgSymbolTable::find_symbol_with_type_support(const SgName & nm = %s) \n",nm.str());
#endif
          p_iterator = i;

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: p_iterator->second = %p = %s \n",nm.str(),p_iterator->second,p_iterator->second->class_name().c_str());
#endif

       // DQ (8/13/2013): Note that the effect of this is that if ReturnType == SgFunctionSymbol then symbol will be 
       // valid for both SgFunctionSymbol and SgMemberFunctionSymbol.  However, since SgTemplateFunctionSymbol is derived 
       // from SgFunctionSymbol and SgTemplateMemberFunctionSymbol is derived from SgMemberFunctionSymbol, the same is
       // not true for template function and template member function relationship.  A SgTemplateMemberFunctionSymbol
       // is NOT derived from a SgTemplateFunctionSymbol and thus a SgTemplateMemberFunctionSymbol dynamic_cast to a 
       // SgTemplateFunctionSymbol will be a NULL pointer (where for non-templates is will be a valid pointer.
       // The solution is to always know if you want to find the class, function, or member functions symbol for 
       // either a template or non-template.  Note that template instanitations are handled using SgFunctionSymbol
       // and SgMemberFunctionSymbols (since they are functions), however, they require template arguments to be 
       // properly resolved.  Template declarations similarly require template parameters.  Since partial specialization
       // of functions and member functions is not allowed in C++, template functions and template member functions
       // don't use template arguments to there resolution.  Since template classes can be partially specialized, both 
       // template parameters and template arguments are required for their resolution.
          ReturnType* symbol = dynamic_cast<ReturnType*>(p_iterator->second);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: (BEFORE symbolFilter) symbol = %p = %s \n",nm.str(),symbol,(symbol != NULL) ? symbol->class_name().c_str() : "null");
#endif
       // DQ (8/13/2013): Added function to filter out types of symbols that would be found from 
       // a dynamic cast but which we are not interested in given the rules where template parameter 
       // lists and template argument lists apply.
       // DQ (4/14/2017): Added explicit control to filter template symbols.
          symbol = symbolFilter<ReturnType>(symbol,templateParameterList,templateArgumentList,filterTemplateSymbols);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
          mprintf ("In loop over target symbols associated with nm = %s: (AFTER symbolFilter) symbol = %p = %s \n",nm.str(),symbol,(symbol != NULL) ? symbol->class_name().c_str() : "null");
#endif

       // DQ (8/21/2013): This is an additional filter that was not previously used (and copied from the 
       // find_symbol_support() function).
       // DQ (6/24/2013): We catch the case of SgAliasSymbol in the tailing test of the symbol table, 
       // there we properly resolve it to its base symbol.  When this template is instatiated using 
       // SgSymbol we have to worry about this detail, else the initialization of symbol above can never
       // result in a SgAliasSymbol. So this is a result of writting very general code. Not sure how to
       // make this a compile-time test so that we could avoid the overhead of using this dynamic cast.
       // One performance alternative would be to have a specialization of this template for the general
       // case of SgSymbol, but that should be considered later when we are sure that this is the final 
       // working implementation (so we will leave the code it is most re-factored state for now).
       // if (isSgAliasSymbol(symbol) != NULL)
          if ( (symbol != NULL) && (symbol->variantT() == (VariantT)SgAliasSymbol::static_variant) )
             {
               symbol = NULL;
             }

#if 0
       // DQ (5/20/2013): Note that this is somewhat expensive and redundant, just checking.
          if (symbol != NULL && get_table()->key_eq()(symbol->get_name(),nm) == false)
             {
            // I think that the function name is provided in mangled from and the name from the symbol would be in non-mangled form.
               mprintf ("Note: In find_symbol_with_type_support(): symbol->get_name() != nm: symbol->get_name() = %s nm = %s \n",symbol->get_name().str(),nm.str());
             }
#endif
#if 0
       // DQ (8/21/2013): This fails for the case of Fortran labels that are numeric and converted to a numeric 
       // value and thus loose leading 0's.  This function was not previously used for labels so this was not 
       // noticed.  An example is in:
       //    --- tests/nonsmoke/functional/CompileTests/Fortran_tests/gfortranTestSuite/gfortran.dg/endfile_2.f90
       // where the numeric label "0023" is used but stored in the SgLabelDeclaration as a numeric value "23"
       // and thus the string "0023" fails to match with the string "23" in this assertion.  The fundamental
       // problem is that we ask the symbol for the name and this causes the name to be computed from the
       // numeric label.  Basically this is a problem that might best be solved by not tryig to compare
       // the string generated from the numeric label to the name generated in the fortran frontend using
       // the text string for the label.

       // This may be an expensive assert.
          ROSE_ASSERT(symbol == NULL || get_table()->key_eq()(symbol->get_name(),nm) == true);
#endif

       // if (isSgFunctionSymbol(p_iterator->second) && (*p_iterator).first==nm)
       // if (isSgFunctionSymbol(p_iterator->second) && get_table()->key_eq()((*p_iterator).first,nm))
       // if (symbol != NULL && get_table()->key_eq()((*p_iterator).first,nm))
       // if ( (symbol != NULL) && (symbol->get_declaration()->get_type() == type) && get_table()->key_eq()(sym->get_name(),nm))
       // if ( (symbol != NULL) && (symbol->get_declaration()->get_type() == type) )
          if ( (symbol != NULL) && ( (type == NULL) || ( (type != NULL) && (symbol->get_declaration()->get_type() == type) ) ) )
             {
               p_name    = nm;
               p_no_name = false;
            // return (SgFunctionSymbol *) p_iterator->second;
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In SgSymbolTable::find_symbol_with_type_support(): name = %s type = %p = %s symbol = %p = %s \n",nm.str(),type,(type != NULL) ? type->class_name().c_str() : "null",symbol,symbol->class_name().c_str());
#endif

            // DQ (8/7/2013): Added support for template function overloading using template parameters.
            // Note: We are handling the template arguments into the hasMatchingTemplateArgumentsOrNoTemplateArguments() 
            // as template specialization arguments which may be incorrect.

            // mprintf ("We are handling the template arguments into the hasMatchingTemplateArgumentsOrNoTemplateArguments() as template specialization arguments which may be incorrect \n");

            // return symbol;
            // DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based 
            // on the arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is 
            // being constructed).
            // break;
               if (hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(templateParameterList,templateArgumentList,symbol) == true)
                  {
                 // return classSymbol;
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Found a match: return symbol = %p = %s nm = %s \n",symbol,symbol->class_name().c_str(),nm.str());
#endif
                 // DQ (8/8/2013): I think we should return the symbol rather than break.
                 // DQ (9/9/2012): We could either call "break" to get out of the loop, or directly "return s".
                 // break;
                    return symbol;
                  }
                 else
                  {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): The template arguments are NOT the same for symbol = %p = %s (keep searching) nm = %s \n",symbol,symbol->class_name().c_str(),nm.str());
#endif
                 // DQ (9/9/2012): If this is not a match, then we have to set s == NULL so that we will not accidentally returning the WRONG sysmbol at the end of the loop.
                    symbol = NULL;
                  }
             }
            else
             {
            // DQ (10/11/2008): Added support to find renamed functions (common in Fortran 90)
            // F90 permits interface statements to effectively rename functions is scope, 
            // SgRenameSymbol IR nodes are used to represent the renamed functions.  This
            // renaming using an interface is different from the aliasing and combined renaming 
            // that is possible within the "use" statement.
               if ( p_iterator->second->variantT() == V_SgRenameSymbol)
                  {
                 // mprintf ("Found a SgRenameSymbol: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());

                    p_name    = nm;
                    p_no_name = false;
                    SgRenameSymbol* renameSymbol = isSgRenameSymbol(p_iterator->second);
                    ROSE_ASSERT(renameSymbol != NULL);

                 // DQ (10/11/2008): Moved SgRenameSymbol to be derived from SgFunctionSymbol.
                 // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(renameSymbol->get_original_symbol());
                 // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(renameSymbol);

                 // DQ (5/24/2013): This should have been expressed in terms of renameSymbol->get_original_symbol().
                 // ReturnType* original_renamed_symbol = dynamic_cast<ReturnType*>(p_iterator->second);
                    ReturnType* original_renamed_symbol = dynamic_cast<ReturnType*>(renameSymbol->get_original_symbol());
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                    mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Need filtering for SgRenameSymbol cases \n");
#endif
                 // assert(functionSymbol != NULL);
                 // return functionSymbol;
                    ROSE_ASSERT(original_renamed_symbol != NULL);
                    return original_renamed_symbol;
                  }
             }

       // p_iterator++;
        }

  // DQ (9/30/2008): If we have not found a symbol from the current scope, search for symbols 
  // injected from other scopes using the Fortran "use" statment (or in a future implementation 
  // the C++ "using" directive or "using" declaration).
  // p_iterator = save_original_iterator;
  // while(p_iterator != p_table->end() && (*p_iterator).first==nm)
  // while(p_iterator != p_table->end() && get_table()->key_eq()((*p_iterator).first,nm))

  // Reset the range so we can look for SgAliasSymbols.
     range = save_original_range;

  // Iterate through the list that match the name to find the one that is a SgTemplateSymbol and has a matching SgType pointer.
     for (hash_iterator i = range.first; i != range.second; ++i)
        {
          p_iterator = i;

       // mprintf ("Looking for aliased symbols: p_iterator->second->class_name() = %s p_iterator->second->get_name() = %s \n",p_iterator->second->class_name().c_str(),p_iterator->second->get_name().str());
          SgAliasSymbol* aliasedSymbol = isSgAliasSymbol(p_iterator->second);
          if (aliasedSymbol != NULL)
             {
            // DQ (10/9/2008): Resolve the last link in any chain of alias symbols
            // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(aliasedSymbol->get_alias());
            // SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(aliasedSymbol->get_base());
               ReturnType* original_aliased_symbol = dynamic_cast<ReturnType*>(aliasedSymbol->get_base());
            // mprintf ("Looking for functionSymbol = %p \n",functionSymbol);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In loop over target ALIASED symbols associated with nm = %s (BEFORE symbolFilter) original_aliased_symbol = %p = %s \n",nm.str(),original_aliased_symbol,(original_aliased_symbol != NULL) ? original_aliased_symbol->class_name().c_str() : "null");
#endif
            // DQ (8/13/2013): Added function to filter out types of symbols that would be found from 
            // a dynamic cast but which we are not interested in given the rules where template parameter 
            // lists and template argument lists apply.
            // DQ (4/14/2017): Added explicit control to filter template symbols.
               original_aliased_symbol = symbolFilter<ReturnType>(original_aliased_symbol,templateParameterList,templateArgumentList,filterTemplateSymbols);

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
               mprintf ("In loop over target ALIASED symbols associated with nm = %s (AFTER symbolFilter) original_aliased_symbol = %p = %s \n",nm.str(),original_aliased_symbol,(original_aliased_symbol != NULL) ? original_aliased_symbol->class_name().c_str() : "null");
#endif

            // DQ (10/10/2008): The current problem is that this is NULL when the base of an aliased symbol is a SgRenameSymbol.
            // assert(functionSymbol != NULL);

            // Liao 9/15/2016
            // Allow template function type match. They may have arguments of template types
            SgFunctionType* f1 = NULL; 
            if (original_aliased_symbol != NULL && isSgFunctionSymbol(original_aliased_symbol))
              f1= isSgFunctionType(isSgFunctionSymbol(original_aliased_symbol)->get_declaration()->get_type());
            SgFunctionType* f2 = NULL; 
            if (type != NULL)
              f2 = isSgFunctionType (const_cast <SgType*> (type));

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
            mprintf ("In loop over target ALIASED symbols associated with nm = %s compare types = %p and %p \n",nm.str(),f1, f2);
#endif

            bool equavilentFunctionType= ( (f1!= NULL && f2!= NULL) && (SageInterface::isEquivalentFunctionType(f1, f2)) );

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
            mprintf ("  -- equavilentFunctionType = %s\n", equavilentFunctionType ? "true" : "false");
#endif

            // if ( functionSymbol != NULL )
            // if ( original_aliased_symbol != NULL )
            // if ( (original_aliased_symbol != NULL) && (original_aliased_symbol->get_declaration()->get_type() == type))
            // if ( (original_aliased_symbol != NULL) && ( (type == NULL) || (type != NULL) && (original_aliased_symbol->get_declaration()->get_type() == type) ) )
               if ( (original_aliased_symbol != NULL) && ( (type == NULL) || ((type != NULL) && (original_aliased_symbol->get_declaration()->get_type() == type || equavilentFunctionType)) ) )
                  {
                 // mprintf ("Found a valid functionSymbol = %p = %s \n",functionSymbol,functionSymbol->get_name().str());
                    p_name    = nm;
                    p_no_name = false;
                 // return functionSymbol;


                 // return original_aliased_symbol;

                 // DQ (8/7/2013): Added support for template function overloading using template parameters. 
                 // DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based 
                 // on the arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is 
                 // being constructed).
                 // break;
                    if (hasMatchingTemplateParametersArgumentsOrNoTemplateParametersArguments(templateParameterList,templateArgumentList,original_aliased_symbol) == true)
                       {
                      // return classSymbol;
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::find_symbol_with_type_support(): Found a match: return original_aliased_symbol = %p = %s nm = %s \n",original_aliased_symbol,original_aliased_symbol->class_name().c_str(),nm.str());
#endif
                      // DQ (8/8/2013): I think we should return the symbol rather than break.
                      // DQ (9/9/2012): We could either call "break" to get out of the loop, or directly "return s".
                      // break;
#if 1
                      // DQ (7/12/2014): To support better symbol handling for name qualification. At this point were 
                      // we have identified the target aliased symbol, we need to check if the associated reason for 
                      // it being an alias symbol has been seen in the AST yet.  The cause for the alias symbol is a
                      // causal node that is stored in the SgAliasSymbol (new modification to SgAliasSymbol).  The list
                      // of possible causal nodes for alias symbols to be inserted is held in a static member of the 
                      // SgSymbolTable (new modification to SgSymbolTable).
                      // if (aliasSymbolCausalNodeSet.find(original_aliased_symbol->get_causal_nodes().begin(),original_aliased_symbol->get_causal_nodes().end()) != aliasSymbolCausalNodeSet.end())
                         bool foundCausalNode = isSubset(aliasedSymbol->get_causal_nodes(),get_aliasSymbolCausalNodeSet());
                         if (foundCausalNode == true)
                            {
                           // DQ (1/23/2019): I think that this support is specific to the references to a symbol before 
                           // a using directive that would make is visible vs after the using directive.  Unfortunately it
                           // is not sufficent to support when a class is derivied from another class and private derivation 
                           // would cause alis symbols to be seen or not seen in the subsequent coass derivations (see 
                           // Cxx_tests/test2019_21.C).
                           // NOTE: the set defined by get_aliasSymbolCausalNodeSet() is only maintained in the name qualification 
                           // support and so it is useless within the 
                           // FixupAstSymbolTablesToSupportAliasedSymbols::injectSymbolsFromReferencedScopeIntoCurrentScope() 
                           // function.  So to fix this we have added to code in this function to insert the causal nodes into
                           // the required set.  It might be that this set should be cleared before starting the namequalification 
                           // phase.

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                              mprintf ("Found causal node for SgAliasSymbol: aliasedSymbol = %p = %s original_aliased_symbol = %p = %s \n",
                                   aliasedSymbol,aliasedSymbol->class_name().c_str(),original_aliased_symbol,original_aliased_symbol->class_name().c_str());
                              ROSE_ASSERT(aliasedSymbol->get_alias() != NULL);
                              mprintf (" --- aliasedSymbol = %p aliasedSymbol->get_alias() = %p = %s \n",aliasedSymbol,aliasedSymbol->get_alias(),aliasedSymbol->get_alias()->class_name().c_str());
                              mprintf (" --- aliasedSymbol->get_causal_nodes().size() = %" PRIuPTR " \n",aliasedSymbol->get_causal_nodes().size());
                              mprintf (" --- get_aliasSymbolCausalNodeSet().size()    = %" PRIuPTR " \n",get_aliasSymbolCausalNodeSet().size());
#endif
                              return original_aliased_symbol;
                            }
                           else
                            {
                           // DQ (7/12/2014): If we didn't find the causal node then we can't consider the alias to exist 
                           // yet in the traversal of the AST represented by the symbol table query at this point.
                              original_aliased_symbol = NULL;

#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                              mprintf ("associated causal nodes not seen yet in traversal of AST: \n");
                              ROSE_ASSERT(aliasedSymbol->get_alias() != NULL);
                              mprintf (" --- aliasedSymbol = %p aliasedSymbol->get_alias() = %p = %s \n",aliasedSymbol,aliasedSymbol->get_alias(),aliasedSymbol->get_alias()->class_name().c_str());
                              mprintf (" --- aliasedSymbol->get_causal_nodes().size() = %zu \n",aliasedSymbol->get_causal_nodes().size());
                              mprintf (" --- get_aliasSymbolCausalNodeSet().size()    = %zu \n",get_aliasSymbolCausalNodeSet().size());
                              for (std::vector<SgNode*>::iterator i = aliasedSymbol->get_causal_nodes().begin(); i != aliasedSymbol->get_causal_nodes().end(); i++)
                                 {
                                   mprintf ("   --- causal node = %p = %s \n",*i,(*i)->class_name().c_str());
                                 }
#endif
                            }
#else
                      // DQ (7/12/2014): Older original version of code.
                         return original_aliased_symbol;
#endif
                       }
                      else
                       {
#if DEBUG_FIND_SYMBOL_WITH_TEMPLATE_ARGUMENTS
                         mprintf ("In SgSymbolTable::find_symbol_with_type_support(): The template arguments are NOT the same for original_aliased_symbol = %p = %s (keep searching) nm = %s \n",original_aliased_symbol,original_aliased_symbol->class_name().c_str(),nm.str());
#endif
                      // DQ (9/9/2012): If this is not a match, then we have to set s == NULL so that we will not accidentally returning the WRONG sysmbol at the end of the loop.
                         original_aliased_symbol = NULL;
                       }
                  }
             }
        }

#if 1
     if (this->get_force_search_of_base_classes() == true)
        {
       // DQ (3/28/2014): If we reach this point, then in the case of Java, we have to search the 
       // base class definitions (since the representation of Java base class does not presently 
       // inject the base class symbols into the derived class symbol table.  There are pros and 
       // const to this design.  But this function will at least make the API semantics that same.
          SgNode* parentNode = this->get_parent();
          ROSE_ASSERT(parentNode != NULL);
          SgClassDefinition* classDefinition = isSgClassDefinition(parentNode);
          if (classDefinition != NULL)
             {
#if 0
               mprintf ("Found SgClassDefinition as parent of SgSymbolTable \n");
#endif
               SgBaseClassPtrList & base_classes = classDefinition->get_inheritances();

               SgBaseClassPtrList::iterator i = base_classes.begin();
               while (i != base_classes.end())
                  {
                    SgBaseClass* baseClass = *i;
                    ROSE_ASSERT(baseClass != NULL);
                    SgClassDeclaration* baseClassDeclaration = baseClass->get_base_class();
                    ROSE_ASSERT(baseClassDeclaration != NULL);
#if 0
                    mprintf ("   --- baseClassDeclaration = %p = %s = %s \n",baseClassDeclaration,baseClassDeclaration->class_name().c_str(),baseClassDeclaration->get_name().str());
#endif
                    SgClassDeclaration* baseClassDeclaration_defining = isSgClassDeclaration(baseClassDeclaration->get_definingDeclaration());

                 // DQ: Note that we have to implement conditional lookup based on base class permissions, plus the access permissions of base class members.
                    if (baseClassDeclaration_defining != NULL)
                       {
                         SgClassDefinition* baseClassDefinition = baseClassDeclaration_defining->get_definition();
                         ROSE_ASSERT(baseClassDefinition != NULL);

                         ROSE_ASSERT(baseClassDefinition->get_symbol_table() != NULL);

                      // DQ (4/14/2017): Added explicit support to filter symbols associated with templates.
                      // Make a recursive call on the symbol table associated with the base class.
                         ReturnType* symbol = baseClassDefinition->get_symbol_table()->find_symbol_with_type_support<ReturnType>(nm,type,templateParameterList,templateArgumentList,filterTemplateSymbols);
#if 0
                         mprintf ("   --- baseClassDefinition = %p symbol = %p \n",baseClassDefinition,symbol);
#endif
#if 0
                         mprintf ("Exiting as a test! \n");
                         ROSE_ASSERT(false);
#endif
                         if (symbol != NULL)
                            {
                              return symbol;
                            }
                       }

                    i++;
#if 0
                    mprintf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
#if 0
               mprintf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }
        }
#endif

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          find_any();
      SgVariableSymbol*  find_variable();
      SgClassSymbol*     find_class();
      SgFunctionSymbol*  find_function();
      SgFunctionSymbol*  find_function_type();
      SgTypedefSymbol*   find_typedef();
      SgEnumSymbol*      find_enum();
      SgEnumFieldSymbol* find_enum_field();
      SgLabelSymbol*     find_label();
      SgNamespaceSymbol* find_namespace();
*/

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::findfirstany()
   {
     return find_any();
   }
#endif

SgSymbol*
SgSymbolTable::find_any()
   {
     assert(p_table != NULL);
     p_iterator = p_table->begin();
     p_no_name  = true;
     if(p_iterator != p_table->end())
          return (SgSymbol *) p_iterator->second;

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::findfirstvar()
   {
     return find_variable();
   }
#endif

SgVariableSymbol*
SgSymbolTable::find_variable()
   {
     assert(p_table != NULL);

     p_iterator = p_table->begin();
     p_no_name  = true;   
     while(p_iterator != p_table->end()) 
        {
       // if(isSgVariableSymbol((*p_iterator).second)) 
       //      return ((SgVariableSymbol *)(*p_iterator).second);
          if (p_iterator->second->variantT() == V_SgVariableSymbol) 
               return (SgVariableSymbol *) p_iterator->second;
          p_iterator++;
        }

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::findfirstclass()
   {
     return find_class();
   }
#endif

SgClassSymbol*
SgSymbolTable::find_class()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgClassSymbol((*p_iterator).second)) 
            //      return ((SgClassSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgClassSymbol) 
                    return (SgClassSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::findfirstfunction()
   {
     return find_function();
   }
#endif

SgFunctionSymbol*
SgSymbolTable::find_function()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionSymbol) 
                    return (SgFunctionSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (1/30/2007): Added to make the interface consistant
// This function is not required since SgFunctionTypeSymbols
// are stored into their own function table.  So this is 
// equivalent to STL function "begin()".
SgFunctionSymbol*
SgSymbolTable::find_function_type()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;  
          while(p_iterator != p_table->end()) 
             {
            // if(isSgFunctionSymbol((*p_iterator).second)) 
            //      return ((SgFunctionSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgFunctionTypeSymbol) 
                    return (SgFunctionTypeSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }
#endif

SgTypedefSymbol*
SgSymbolTable::find_typedef()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTypedefSymbol((*p_iterator).second)) 
            //      return ((SgTypedefSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTypedefSymbol) 
                    return (SgTypedefSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumSymbol*
SgSymbolTable::find_enum()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumSymbol((*p_iterator).second)) 
            //      return ((SgEnumSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumSymbol) 
                    return (SgEnumSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgEnumFieldSymbol*
SgSymbolTable::find_enum_field()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgEnumFieldSymbol((*p_iterator).second)) 
            //      return ((SgEnumFieldSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgEnumFieldSymbol) 
                    return (SgEnumFieldSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::find_label()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgLabelSymbol((*p_iterator).second)) 
            //      return ((SgLabelSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgLabelSymbol) 
                    return (SgLabelSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::find_namespace()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgNamespaceSymbol((*p_iterator).second)) 
            //      return ((SgNamespaceSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgNamespaceSymbol) 
                    return (SgNamespaceSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::find_template()
   {
     assert(p_table != NULL);
     if (p_table)
        {
          p_iterator = p_table->begin();
          p_no_name  = true;
          while (p_iterator != p_table->end()) 
             {
            // if (isSgTemplateSymbol((*p_iterator).second))
            //      return ((SgTemplateSymbol *)(*p_iterator).second);
               if (p_iterator->second->variantT() == V_SgTemplateSymbol)
                    return (SgTemplateSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }


/* ************************************************************************
   DQ (1/30/2007): Added remove functions for each sort of SgSymbol IR node
   ************************************************************************
      SgSymbol*          next_any();
      SgVariableSymbol*  next_variable();
      SgClassSymbol*     next_class();
      SgFunctionSymbol*  next_function();
      SgTypedefSymbol*   next_typedef();
      SgEnumSymbol*      next_enum();
      SgEnumFieldSymbol* next_enum_field();
      SgLabelSymbol*     next_label();
      SgNamespaceSymbol* next_namespace();
*/

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgSymbol*
SgSymbolTable::nextany()
   {
     return next_any();
   }
#endif

SgSymbol*
SgSymbolTable::next_any()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
          while( p_iterator != p_table->end() )
             {
            // if( p_no_name || (*p_iterator).first == p_name )
               if( p_no_name || get_table()->key_eq()((*p_iterator).first,p_name) )
                    return (SgSymbol *) p_iterator->second;
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
SgVariableSymbol*
SgSymbolTable::nextvar()
   {
     return next_variable();
   }
#endif

SgVariableSymbol*
SgSymbolTable::next_variable()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while (p_iterator != p_table->end() && (p_no_name || (*p_iterator).first==p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgVariableSymbol((*p_iterator).second))
                    return ((SgVariableSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (1/30/2007): Added these back into ROSE.
SgClassSymbol*
SgSymbolTable::nextclass()
   {
     return next_class();
   }
#endif

SgClassSymbol*
SgSymbolTable::next_class()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++; // go to next one

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgClassSymbol((*p_iterator).second))
                    return ((SgClassSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (1/30/2007): Added these back into ROSE.
SgFunctionSymbol*
SgSymbolTable::nextfunc()
   {
     return next_function();
   }
#endif

SgFunctionSymbol*
SgSymbolTable::next_function()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgFunctionSymbol((*p_iterator).second))
                    return ((SgFunctionSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTypedefSymbol*
SgSymbolTable::next_typedef()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgTypedefSymbol((*p_iterator).second))
                    return ((SgTypedefSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }


// DQ (1/30/2007): Added this as a new member function.
SgEnumSymbol*
SgSymbolTable::next_enum()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgEnumSymbol((*p_iterator).second))
                    return ((SgEnumSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

// DQ (1/30/2007): Added this as a new member function.
SgEnumFieldSymbol*
SgSymbolTable::next_enum_field()
   {
     assert(p_table != NULL);
     if(p_table)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if(isSgEnumFieldSymbol((*p_iterator).second))
                    return ((SgEnumFieldSymbol *)(*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgLabelSymbol*
SgSymbolTable::next_label()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgLabelSymbol((*p_iterator).second))
                    return ((SgLabelSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgNamespaceSymbol*
SgSymbolTable::next_namespace()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgNamespaceSymbol((*p_iterator).second))
                    return ((SgNamespaceSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }

SgTemplateSymbol*
SgSymbolTable::next_template()
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
          p_iterator++;

       // DQ (10/8/2007): Is there a use of find that would be O(log n) and be a faster way to return the next matching entry?
       // while( p_iterator != p_table->end() && (p_no_name || (*p_iterator).first == p_name))
          while (p_iterator != p_table->end() && (p_no_name || get_table()->key_eq()((*p_iterator).first,p_name)))
             {
               if (isSgTemplateSymbol((*p_iterator).second))
                    return ((SgTemplateSymbol *) (*p_iterator).second);
               p_iterator++;
             }
        }

     return NULL;
   }


#if 0
// DQ (11/27/2010): Removed deprecated function (depricated three years ago).
// DQ (1/30/2007): Added these back into ROSE.
SgSymbol*
SgSymbolTable::operator[](const SgName & nm)
   {
     assert(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i=p_table->find(nm);
          hash_iterator i=p_table->find(nm);
          if (i != p_table->end())
               return (*i).second;
        }

     return NULL;
   }
#endif

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::size() const
   {
     assert(p_table != NULL);
     return p_table->size();
   }

// AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
int
SgSymbolTable::count(const SgName & nm) const
   {
  // DQ (1/30/2007): assertion added
     assert(p_table != NULL);
     return p_table->count(nm);
   }

int
SgSymbolTable::count_aliases(const SgName & nm) const
   {
     assert(p_table != NULL);

  // This is the fastest way (that I know of) to iterate over just those entries that match the key.
     std::pair<hash_iterator,hash_iterator> range = p_table->equal_range(nm);

     hash_iterator start = range.first;
     hash_iterator last  = range.second;

     int count = 0;
     hash_iterator i = start;
     while (i != last)
        {
       // Count only the alias symbols.
           if (isSgAliasSymbol((*i).second) != NULL)
               count++;

          i++;
        }

     return count;
   }

void
SgSymbolTable::print() // Liao 5/5/2011. Added this to support calling this from gdb
  {
    print ("default settings", V_SgSymbol);
  }

void
SgSymbolTable::print( std::string label, VariantT nodeType )
   {
     mprintf ("Printing out the data within the symbol table (p_table = %p,label = %s size = %d): \n",p_table,label.c_str(),size());

     mprintf ("Internal static data: p_no_name: %s p_name = %s \n",(p_no_name == true) ? "true" : "false",p_name.str());

  // These are just static data used internally for some of the symbol lookup functions (symbol tables are not given names).
  // mprintf ("SymbolTable has a name: %s \n",(p_no_name == true) ? "NO: it has no name" : "YES: it does have a name");
  // if (p_no_name == false)
  //      mprintf ("SymbolTable name = %s \n",p_name.str());

  // DQ (2/16/2006): This is a SgScopeStatement except for the SgSymbolTable used in the global function type symbol table
  // SgScopeStatement* parentNode = isSgScopeStatement(get_parent());
     SgNode* parentNode = get_parent();
     assert(parentNode != NULL);
     mprintf ("Symbol table has parent = %p = %s \n",parentNode,parentNode->class_name().c_str());

  // DQ (6/23/2005): It is not a problem for the global function table to not have a name!
  //   else
  //      assert (p_name.str() == NULL);

     assert(p_table != NULL);
     if (p_table != NULL)
        {
       // AJ (10/21/2004): Adjusted implementation to use new STL hash map interface
       // SgSymbolHashBase::iterator i = p_table->begin();
          hash_iterator i = p_table->begin();

          int idx = 0;
          while (i != p_table->end())
             {
            // DQ: removed SgName casting operator to char*
            // cout << "[" << idx << "] " << (*i).first;
            // cout << "[" << idx << "] " << (*i).first.str();
               assert ( isSgSymbol( (*i).second ) != NULL );

            // mprintf ("Symbol number: %d (pair.first (SgName) = %s) pair.second (SgSymbol) sage_class_name() = %s \n",
            //      idx,(*i).first.str(),(*i).second->sage_class_name());

               SgSymbol* symbol = isSgSymbol((*i).second);
               assert ( symbol != NULL );
               SgType* type = symbol->get_type();

            // DQ (5/7/2004): modified to allow for get_type() to return NULL
            // assert ( type != NULL );

               SgNamedType* namedType = isSgNamedType(type);
               SgName nameOfType;
               if (namedType != NULL)
                  {
                    nameOfType = namedType->get_name();
                 // char* nameString = namedType->get_name().str();
                 // mprintf ("Type is: (named type) = %s \n",nameString);
                  }
                 else
                  {
                 // DQ (5/7/2004): modified to allow for get_type() to return NULL
                    if (type != NULL)
                       {
                      // mprintf ("Type is: type->sage_class_name() = %s \n",type->sage_class_name());
                         nameOfType = type->sage_class_name();
                       }
                      else
                       {
                      // mprintf ("Type is: No type found in symbol (likely a possible error!) \n");
                         switch(symbol->variantT())
                            {
                              case V_SgNamespaceSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgNamespaceSymbol)";
                                   break;
                                 }

                              case V_SgTemplateSymbol:
                                 {
                                // This is a normal case where the type will be a null pointer!
                                   nameOfType = "symbol's type is NULL (normal for SgTemplateSymbol)";
                                   break;
                                 }

                              default:
                                 {
                                // This is likely an error, I think
                                   nameOfType = "unknown type name (likely a possible error!)";
                                   break;
                                 }
                            }
                       }
                  }

               bool outputSymbolInfo = (nodeType == V_SgSymbol) || (symbol->variantT() == nodeType);

            // Output of symbol information
               SgNode* symbolBasis = i->second->get_symbol_basis();
               if (symbolBasis != NULL)
                  {
                    assert(symbolBasis != NULL);

                    if (outputSymbolInfo == true)
                       {
                         SgAliasSymbol* aliasSymbol = isSgAliasSymbol((*i).second);
                         if (aliasSymbol != NULL)
                            {
                               ROSE_ASSERT(aliasSymbol->get_alias() != NULL);
                              mprintf ("Symbol %4d: name = %s SgSymbol = %p = %s (alias to %s) type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                                      idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),aliasSymbol->get_alias()->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                                   nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());
                            }
                           else
                            {
                              mprintf ("Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = %p = %s = %s \n",
                                   idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                                   nameOfType.str(),symbolBasis,symbolBasis->class_name().c_str(),SageInterface::get_name(symbolBasis).c_str());
                            }
                       }
                  }
                 else
                  {
                    if (outputSymbolInfo == true)
                       {
                         mprintf ("Warning Symbol %4d: name = %s SgSymbol = %p = %s type = %p = %s = %s get_symbol_basis() = NULL \n",
                              idx,(*i).first.str(),(*i).second,(*i).second->class_name().c_str(),type,(type != NULL) ? type->class_name().c_str() : "NULL" ,
                              nameOfType.str());
                       }
                  }

#if 1
            // DQ (12/3/2011): Refactored code.
               SgSymbol* symbolFromTable = (*i).second;
               SgName mangledName = symbolFromTable->get_mangled_name();
#else
               SgName mangledName;
               SgSymbol* symbolFromTable = (*i).second;

#error "DEAD CODE"

               assert(symbolFromTable != NULL);
               switch(symbolFromTable->variantT())
                  {
                    case V_SgFunctionSymbol:
                       {
                         SgFunctionSymbol* symbol = isSgFunctionSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgMemberFunctionSymbol:
                       {
                         SgMemberFunctionSymbol* symbol = isSgMemberFunctionSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();
                         mangledName = functionDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgClassSymbol:
                       {
                         SgClassSymbol* symbol = isSgClassSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgClassDeclaration* classDeclaration = symbol->get_declaration();
                         mangledName = classDeclaration->get_mangled_name();
                         break;
                       }

#error "DEAD CODE"

                    case V_SgEnumFieldSymbol:
                       {
                         SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgInitializedName* enumFieldName = symbol->get_declaration();
                         mangledName = enumFieldName->get_mangled_name();
                         break;
                       }
                    case V_SgEnumSymbol:
                       {
                         SgEnumSymbol* symbol = isSgEnumSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgEnumDeclaration* enumDeclaration = symbol->get_declaration();
                         mangledName = enumDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgFunctionTypeSymbol:
                       {
                         SgFunctionTypeSymbol* symbol = isSgFunctionTypeSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         mangledName = symbol->get_name();
                         mprintf ("A SgFunctionTypeSymbol also has a pointer to a SgType = %p \n",symbol->get_type());
                         break;
                       }

#error "DEAD CODE"

                    case V_SgLabelSymbol:
                       {
                         SgLabelSymbol* symbol = isSgLabelSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgLabelStatement* labelStatement = symbol->get_declaration();

                      // DQ (12/24/2007): Modified to reflect new implementation for Fortran numeric labels.
                      // mangledName = labelStatement->get_label();
                         if (labelStatement == NULL)
                            {
                              assert(symbol->get_numeric_label_value() >= 0);
                              mangledName = Rose::StringUtility::numberToString(symbol->get_numeric_label_value());
                            }
                           else
                            {
                              mangledName = labelStatement->get_label();
                            }
                         break;
                       }

#error "DEAD CODE"

                    case V_SgNamespaceSymbol:
                       {
                         SgNamespaceSymbol* symbol = isSgNamespaceSymbol(symbolFromTable);
                         assert(symbol != NULL);
#if 0
                         SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
                         mangledName = namespaceDeclaration->get_mangled_name();
                         mprintf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
#else
                         if (symbol->get_isAlias() == true)
                            {
                              SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = symbol->get_aliasDeclaration();
                              mangledName = namespaceAliasDeclarationStatement->get_mangled_name();
                              mprintf ("A SgNamespaceSymbol has an ALIAS with name = %s \n",symbol->get_name().str());
                            }
                           else
                            {
                              SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
                              mangledName = namespaceDeclaration->get_mangled_name();
                              mprintf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
                            }
#endif
                         break;
                       }

#error "DEAD CODE"

                    case V_SgTemplateSymbol:
                       {
                         SgTemplateSymbol* symbol = isSgTemplateSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgTemplateDeclaration* templateDeclaration = symbol->get_declaration();
                         mangledName = templateDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgTypedefSymbol:
                       {
                         SgTypedefSymbol* symbol = isSgTypedefSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgTypedefDeclaration* typedefDeclaration = symbol->get_declaration();
                         mangledName = typedefDeclaration->get_mangled_name();
                         break;
                       }
                    case V_SgVariableSymbol:
                       {
                         SgVariableSymbol* symbol = isSgVariableSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         SgInitializedName* initializedName = symbol->get_declaration();
                         mangledName = initializedName->get_mangled_name();
                         break;
                       }

#error "DEAD CODE"

                    case V_SgAliasSymbol:
                       {
                         SgAliasSymbol* symbol = isSgAliasSymbol(symbolFromTable);
                         assert(symbol != NULL);
                         mangledName = symbol->get_name();
                         break;
                       }
                     
                    default:
                       {
                         mangledName = "unknown mangled name";
                         mprintf ("Error: SgSymbol not handled (%s) \n",symbolFromTable->class_name().c_str());

                      // DQ (6/8/2007): Make this case fail so we can detect this error.
                         assert(false);
                       }
                  }
#endif

               if (outputSymbolInfo == true)
                  {
                    mprintf ("   Symbol's associated mangled name = %s \n",mangledName.str());

                 // This is useful for the output of the function types when the global function type symbol table is output.
                 // handle case of function symbol (unparse the funtion type)
                    SgFunctionTypeSymbol *f = isSgFunctionTypeSymbol((*i).second);
                    if (f != NULL)
                       {
#if 1
                      // f->get_type()->unparse(); cout << endl;
                         std::cout << "     function: " << f->get_type()->unparseToString() << endl;
#else
                      // mprintf ("ERROR: unparse function for symbol type not implemented in SAGE3! \n");
                      // ROSE_ABORT();
#endif
                       }
                  }

            // Increment the symbol table's symbol iterator
               i++;

            // Increment the symbol counter (used for output)
               idx++;
             }
        }
       else
        {
       // DQ (6/27/2005): I think this is an error (we should always have a valid symbol table)
          mprintf ("Pointer to symbol table is NULL \n");
          assert(false);
        }
   }


set<SgNode*>
SgSymbolTable::get_symbols() const
   {
  // DQ (2/15/2007): generate a set of SgNode* so that we can use them for set difference against the delete list in AST merge.
     set<SgNode*> returnSet;

     assert(p_table != NULL);
// CH (4/8/2010): Use boost::unordered instead     
//#ifdef _MSCx_VER
//     rose_hash::unordered_multimap<SgName, SgSymbol*>::iterator i = get_table()->begin();
//#else
     rose_hash_multimap::iterator i = get_table()->begin();
//#endif
     while (i != p_table->end())
        {
          assert(i->second != NULL);
          returnSet.insert(i->second);

          i++;
        }

     return returnSet;
   }


size_t
SgSymbolTable::maxCollisions() 
   {
     ROSE_ASSERT(p_table != NULL);

     unsigned nbuckets = p_table->bucket_count();
     size_t maxColl = 0;
     for (unsigned i = 0; i < nbuckets; ++i)
        {
          if(p_table->bucket_size(i)>maxColl)
               maxColl = p_table->bucket_size(i);
        }

     return maxColl;
   }

// DQ (3/30/2014): Declaration of space for static data member.
bool SgSymbolTable::p_force_search_of_base_classes = false;

// DQ (7/12/2014): Declaration of space for static data member.
SgNodeSet SgSymbolTable::p_aliasSymbolCausalNodeSet;

bool
SgSymbolTable::get_force_search_of_base_classes()
   {
     return p_force_search_of_base_classes;
   }

void
SgSymbolTable::set_force_search_of_base_classes( bool value )
   {
     p_force_search_of_base_classes = value;
   }

// DQ (7/12/2014): Access function for static data member.
SgNodeSet &
SgSymbolTable::get_aliasSymbolCausalNodeSet()
   {
     return p_aliasSymbolCausalNodeSet;
   }


// DQ (8/3/2019): Display function for static data member.
void
SgSymbolTable::display_aliasSymbolCausalNodeSet()
   {
     SgNodeSet::iterator i = p_aliasSymbolCausalNodeSet.begin();
     while (i != p_aliasSymbolCausalNodeSet.end())
        {
          mprintf ("SgSymbolTable::p_aliasSymbolCausalNodeSet: *i = %p = %s \n",*i,(*i)->class_name().c_str());

          i++;
        }
   }




SOURCE_SYMBOL_TABLE_END


SOURCE_BASECLASS_START

void
SgBaseClass::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // DQ (4/25/2004): Note that because of limitiations in the ordering of output 
  // class declarations in ROSETTA, I was unable make this SgBaseClassModifier a 
  // data member and was forced to handle it as a pointer).
     p_baseClassModifier = new SgBaseClassModifier();
     assert ( p_baseClassModifier != NULL);

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;
   }

#if 0
// This function should be autogenerated
SgBaseClass::SgBaseClass(int specifier ,SgClassDeclaration* ptr, int dir)
   : p_specifier(specifier), p_ptr(ptr), p_isDirectBaseClass(dir)
   {
   }
#endif

SgBaseClass::SgBaseClass(const SgBaseClass& X)
   {
  // these are the old names
  // p_specifier = ptr.p_specifier;
  // p_ptr       = ptr.p_ptr;
  // p_base_specifier = X.p_base_specifier;
     p_base_class     = X.p_base_class;

  // DQ (6/21/2005): Commented out since it is not used, we might want it later!
  // DQ: initialize all values
     p_isDirectBaseClass = 0;

     assert ( X.p_baseClassModifier != NULL);
     p_baseClassModifier = new SgBaseClassModifier( *(X.p_baseClassModifier) );
     assert ( p_baseClassModifier != NULL);

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;
   }

#if 0
// generated automatically
SgBaseClass::~SgBaseClass()
   {
  /* delete p_ptr; */
   }
#endif

SgBaseClass &
SgBaseClass::operator= (const SgBaseClass & X)
   {
  // Old names
  // p_specifier = ptr.p_specifier;
  // p_direct    = ptr.p_direct; 
  // p_ptr       = ptr.p_ptr;

  // p_base_specifier     = X.p_base_specifier;
     p_base_class         = X.p_base_class;

  // DQ (6/21/2005): Renamed to make this more clear
     p_isDirectBaseClass  = X.p_isDirectBaseClass;

     assert (p_baseClassModifier   != NULL);
     assert (X.p_baseClassModifier != NULL);
     *p_baseClassModifier = *X.p_baseClassModifier;

  // DQ (5/12/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;

     return *this;
   }

#if 0
// These are automatically generated now!
int
SgBaseClass::get_base_specifier() const
   { return p_specifier; }

SgClassDeclaration*
SgBaseClass::get_base_class() const
   { return p_ptr; }
#endif

#if 0
// DQ: I don't think this is used anywhere
SgClassDeclaration*
replace_base_class(SgClassDeclaration *);
#endif

// I assume these relational member functions are added to permit use with STL
bool
SgBaseClass::operator== (const SgBaseClass& ) const
   { return false; }

bool
SgBaseClass::operator< (const SgBaseClass&) const
   { return false; }

#if 0
// DQ (1/21/2019): This should be an automatically generated access function.
// DQ (4/25/2004): Part of new modifier interface
SgBaseClassModifier & 
SgBaseClass::get_baseClassModifier()
   {
     assert ( p_baseClassModifier != NULL);
     return *p_baseClassModifier;
   }
#endif

SgName
SgBaseClass::get_qualified_name_prefix() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgBaseClass
  //    SgTemplateArgument

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgBaseClass*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
       // mprintf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
        }

  // mprintf ("nameQualifier for SgBaseClass = %s = %s \n",class_name().c_str(),nameQualifier.str());

     return nameQualifier;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA 
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int 
SgBaseClass::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgBaseClass::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool 
SgBaseClass::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgBaseClass::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool 
SgBaseClass::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgBaseClass::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }


SOURCE_BASECLASS_END

SOURCE_EXP_BASE_CLASS_START
void
SgExpBaseClass::post_construction_initialization()
   {
   }
SOURCE_EXP_BASE_CLASS_END

SOURCE_NONREAL_BASE_CLASS_START
void
SgNonrealBaseClass::post_construction_initialization()
   {
   }
SOURCE_NONREAL_BASE_CLASS_END

SOURCE_X_INITIALIZED_NAME_START

// Include this code only if we are building a derived grammar (not a root grammar)
$CLASSNAME::$CLASSNAME 
   ( const SgName& name, SgType *typeptr, SgInitializer* iptr,
     SgX_DeclarationStatement *declptr ) 
   //   SgInitializedName *itemptr,
   //  SgInitializedName *prev_itemptr ) 
   : p_name(name), p_typeptr(typeptr), p_initptr(iptr), 
     p_is_initializer(1), p_declptr(NULL), p_X_declptr(declptr),
     p_prev_decl_item(prev_itemptr)
   {}

void
$CLASSNAME::set_X_declaration(SgX_DeclarationStatement * decl)
   { p_X_declptr = decl; }

SOURCE_X_INITIALIZED_NAME_END


SOURCE_INITIALIZED_NAME_START

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgInitializedName::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // assert(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

// PC (10/1/2009): Added support to get the symbol from the correct associated declaration
SgSymbol*
SgInitializedName::search_for_symbol_from_symbol_table() const
   {
     SgInitializedName* aPrevDeclItem = p_prev_decl_item;
     while(aPrevDeclItem != NULL && aPrevDeclItem->p_prev_decl_item != NULL)
        {
       // DQ (11/19/2011): This loop will not terminate if (aPrevDeclItem->p_prev_decl_item == aPrevDeclItem).
       // This should not happen but this mistake has happened and this assertion helps it be caught instead 
       // of be an infinite loop.
          ROSE_ASSERT(aPrevDeclItem->p_prev_decl_item != aPrevDeclItem);

          aPrevDeclItem = aPrevDeclItem->p_prev_decl_item;
        }

     SgSymbol* symbol=0;
     if (aPrevDeclItem != NULL)
          symbol = aPrevDeclItem->get_symbol_from_symbol_table();
     else
          symbol = get_symbol_from_symbol_table();

 	 // MS: for SgInitializedName in a forward declaration this always fails because no symbol exists. Therefore
	 // this assert can be put back, once symbols for such variables are available.
     // assert(symbol != NULL);
     return symbol;
   }

// DQ (10/13/2014): Adding a default constructor for compatability with what was previously the API before the newer aterm support.
SgInitializedName::SgInitializedName() ROSE_DEPRECATED_FUNCTION
   : p_name(""),
     p_microsoft_uuid_string(""),
     p_typeptr(NULL),
     p_initptr(NULL),
     p_prev_decl_item(NULL),
     p_is_initializer(true),
     p_declptr(NULL),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
  // This constructor has been added to support the previous API, I would like to depricate it.
   }

SgStorageModifier &
SgInitializedName::get_storageModifier()
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

const SgStorageModifier &
SgInitializedName::get_storageModifier() const
   {
     assert (this != NULL);
     assert (p_storageModifier != NULL);
     return *p_storageModifier;
   }

SgName
SgInitializedName::get_qualified_name() const
   {
  // DQ (8/22/2005): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus 
  // it should not be called before the parent pointers are set (within the AST fixup after 
  // the Sage III AST is fully constructed).

  // mprintf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     assert(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // mprintf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }


SgName
SgInitializedName::get_qualified_name_prefix() const
   {
  // DQ (12/16/2013): Added support for name qualification on SgInitializedName for use in preinitialization lists.

     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgInitializedName*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
#if 0
          mprintf ("In SgInitializedName::get_qualified_name_prefix(): Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }

#if 0
     mprintf ("In SgInitializedName::get_qualified_name_prefix(): nameQualifier for SgInitializedName = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }

 
SgName
SgInitializedName::get_qualified_name_prefix_for_type() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgInitializedName*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
          mprintf ("SgInitializedName::get_qualified_name_prefix_for_type(): Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }

#if 0
     mprintf ("SgInitializedName::get_qualified_name_prefix_for_type(): nameQualifier for SgInitializedName = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }


void
SgInitializedName::post_construction_initialization()
   {
  // Liao 11/5/2010, for debugging purpose
  // if (p_name.getString() == string("a0")) 
  //      abort();
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // mprintf ("In SgInitializedName::post_construction_initialization() this = %p \n",this);

     p_storageModifier = new SgStorageModifier();
     assert (p_storageModifier != NULL);
     p_storageModifier->setDefault();

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism = NULL;

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope = NULL;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
       // mprintf ("In SgInitializedName::post_construction_initialization(): resetting parent of valid initializer (p_initptr = %p) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // DQ (1/3/2009): Added support for GNU variable attributes (std::strings will default to null, so they are not setup).
     p_gnu_attribute_modifierVector          = SgBitVector(e_last_gnu_variable_attribute,false);
     p_gnu_attribute_initialization_priority = 0;

  // DQ (3/1/2013): Changed default value to -1 and type to signed short so that we could reserve negative values to be a marked for not explicitly specified.
     p_gnu_attribute_alignment               = -1;

  // Borrow the enum definition (and default value from SgDeclarationModifier).
     p_gnu_attribute_visability              = SgDeclarationModifier::e_unknown_visibility;

  // FMZ added for coarray
     p_isCoArray = false;

  // DQ (10/26/2010): These were not properly initialized.
     p_shapeDeferred          = false;
     p_initializationDeferred = false;
     p_protected_declaration  = false;

  // DQ (2/5/2014): I just noticed that the initialization of these were missing.
     p_name_qualification_length_for_type = 0;
     p_type_elaboration_required_for_type = false;
     p_global_qualification_required_for_type = false;

  // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
     p_hasArrayTypeWithEmptyBracketSyntax = false;

  // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
     p_using_C11_Alignas_keyword                     = false;
     p_constant_or_type_argument_for_Alignas_keyword = NULL;

  // DQ (8/2/2014): Adding support for C++11 auto keyword.
     p_using_auto_keyword = false;
     p_auto_decltype = NULL;

  // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
     p_using_device_keyword = false;

  // DQ (6/10/2012): Testing for test2012_102.C.
  // mprintf ("In SgInitializedName::post_construction_initialization(): this = %p \n",this);
   }

// This constructor is specific to the creation of SgInitializedName objects used as initializers
SgInitializedName::SgInitializedName (
  const SgName& name, SgType *typeptr, SgInitializer* iptr,
  SgDeclarationStatement *declptr, 
  SgInitializedName *prev_itemptr
) ROSE_DEPRECATED_FUNCTION :
     p_name(name),
     p_microsoft_uuid_string(""),
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(NULL),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName(
  Sg_File_Info* fileInfo, const SgName& name, SgType *typeptr, SgInitializer* iptr, 
     SgDeclarationStatement *declptr, SgScopeStatement* scope, SgInitializedName *prev_itemptr
) :
     p_name(name),
     p_microsoft_uuid_string(""),
     p_typeptr(typeptr),
     p_initptr(iptr),
     p_prev_decl_item(prev_itemptr),
     p_is_initializer(true),
     p_declptr(declptr),
     p_storageModifier(NULL),
     p_scope(scope),
     p_preinitialization(e_unknown_preinitialization),
     p_isCoArray(false),
     p_register_name_code(SgInitializedName::e_invalid_register),
     p_excess_specifier(SgInitializedName::e_excess_specifier_none),
     p_register_name_string(""),
     p_requiresGlobalNameQualificationOnType(false),
     p_shapeDeferred(false),
     p_initializationDeferred(false),
     p_gnu_attribute_modifierVector(e_last_gnu_variable_attribute,false),
     p_gnu_attribute_initialization_priority(0),
     p_gnu_attribute_named_weak_reference(""),
     p_gnu_attribute_named_alias(""),
     p_gnu_attribute_cleanup_function(""),
     p_gnu_attribute_section_name(""),
     p_gnu_attribute_alignment(-1),
     p_gnu_attribute_visability(SgDeclarationModifier::e_unknown_visibility),
     p_protected_declaration(false),
     p_name_qualification_length(0),
     p_type_elaboration_required(false),
     p_global_qualification_required(false),
     p_name_qualification_length_for_type(false),
     p_type_elaboration_required_for_type(0),
     p_global_qualification_required_for_type(false),
     p_hasArrayTypeWithEmptyBracketSyntax(false),
     p_using_C11_Alignas_keyword(false),
     p_constant_or_type_argument_for_Alignas_keyword(NULL),
     p_using_auto_keyword(false),
     p_auto_decltype(NULL),
     p_using_device_keyword(false),
     p_is_braced_initialized(false),
     p_using_assignment_copy_constructor_syntax(false),
     p_needs_definitions(false),
     p_is_parameter_pack(false),
     p_is_pack_element(false)
   {
     p_startOfConstruct = fileInfo; 
     post_construction_initialization();
   }

SgInitializedName::SgInitializedName (const SgInitializedName& ptr)
   {
     p_name           = ptr.p_name;

     p_typeptr        = ptr.p_typeptr;
     p_initptr        = ptr.p_initptr;

  // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
     if (p_initptr != NULL)
        {
          mprintf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in copy constructor) \n",p_initptr);
          p_initptr->set_parent(this);
        }

  // p_prev_itemptr   = ptr.p_prev_itemptr; 
     p_is_initializer = ptr.p_is_initializer;
     p_declptr        = ptr.p_declptr;
  // p_itemptr        = ptr.p_itemptr;

  // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
  // p_fileInfo       = ptr.p_fileInfo;
  // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;

  // DQ (12/17/2006): See if we can enforce this!
  // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
     assert(ptr.p_startOfConstruct != NULL);
     p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
     assert(p_startOfConstruct != NULL);

  // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
     p_startOfConstruct->set_parent(this);

  // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
     p_scope          = ptr.p_scope;

  // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
     p_preinitialization = ptr.p_preinitialization;

  // DQ (4/28/2004): Added storage modifier support (replacing the old interface)
     assert (ptr.p_storageModifier != NULL);
     p_storageModifier = new SgStorageModifier ( *(ptr.p_storageModifier) );
     assert (p_storageModifier != NULL);

  // DQ (6/20/2006): Set the parent of the SgStorageModifier
     p_storageModifier->set_parent(this);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
     p_attributeMechanism = NULL;

  // DQ (7/31/2006): Added support for asm declarations on variables (using GNU register codes)
     p_register_name_code = SgInitializedName::e_invalid_register;

  // DQ (8/9/2006): Added support for asm declarations on variables (using strings)
  // Note: don't copy the register string (I think this is best, but it is debatable)
     p_register_name_string = "";

  // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
     p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

  // DQ (1/3/2009): Added support for GNU variable attribues
     p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
     p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
     p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
     p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
     p_isCoArray                             = ptr.p_isCoArray;

  // DQ (10/26/2010): Previously uninitialized data members.
     p_shapeDeferred          = ptr.p_shapeDeferred;
     p_initializationDeferred = ptr.p_initializationDeferred;
     p_protected_declaration  = ptr.p_protected_declaration;

  // DQ (2/5/2014): I just noticed that the initialization of these were missing.
     p_name_qualification_length_for_type     = ptr.p_name_qualification_length_for_type;
     p_type_elaboration_required_for_type     = ptr.p_type_elaboration_required_for_type;
     p_global_qualification_required_for_type = ptr.p_global_qualification_required_for_type;


  // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
     p_hasArrayTypeWithEmptyBracketSyntax     = ptr.p_hasArrayTypeWithEmptyBracketSyntax;

  // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
     p_using_C11_Alignas_keyword                     = ptr.p_using_C11_Alignas_keyword;
     p_constant_or_type_argument_for_Alignas_keyword = ptr.p_constant_or_type_argument_for_Alignas_keyword;

  // DQ (8/2/2014): Adding support for C++11 auto keyword.
     p_using_auto_keyword                     = ptr.p_using_auto_keyword;
     p_auto_decltype                          = ptr.p_auto_decltype;

  // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
     p_using_device_keyword                   = ptr.p_using_device_keyword;
   }

SgInitializedName&
SgInitializedName::operator= (const SgInitializedName& ptr) 
   {
     assert(this != NULL);

  /* check they are not the same name */
     if (this != &ptr)
        {
          p_name = ptr.p_name;

          p_typeptr        = ptr.p_typeptr;
          p_initptr        = ptr.p_initptr;

       // DQ (12/17/2006): Added semantics that constructors (which are structural) should set the parents of their inputs.
          if (p_initptr != NULL)
             {
            // mprintf ("In SgInitializedName constructor: resetting parent of valid initializer (p_initptr = %p) (likely sharing violation in operator=) \n",p_initptr);
#if 0
            // DQ (12/22/2006): Don't allow the parent of the input SgInitializedName to be modified, but make sure that it is set!
            // p_initptr->set_parent(this);
               if (p_initptr->get_parent() == NULL)
                  {
                    p_initptr->set_parent(this);
                  }
#else
            // DQ (12/22/2006): Interestingly, the inliner is dependent upon this working this way!  We should maybe look into this later.
               p_initptr->set_parent(this);
#endif
               assert(p_initptr->get_parent() != NULL);

            // mprintf ("Exiting as a test! operator= \n");
            // assert(false);
             }

       // p_prev_itemptr   = ptr.p_prev_itemptr;
          p_is_initializer = ptr.p_is_initializer;
          p_declptr        = ptr.p_declptr;
       // p_itemptr        = ptr.p_itemptr; 

       // DQ (1/18/2006): Avoid reusing Sg_File_Info objects
       // p_fileInfo       = ptr.p_fileInfo;

       // DQ (6/23/2006): Added assertion to detect errors
       // assert(ptr.p_file_info != NULL);
       // p_file_info      = (ptr.p_file_info != NULL) ? new Sg_File_Info(*ptr.p_file_info) : NULL;
       // assert(p_file_info != NULL);
          assert(ptr.p_startOfConstruct != NULL);
       // p_startOfConstruct = (ptr.p_startOfConstruct != NULL) ? new Sg_File_Info(*ptr.p_startOfConstruct) : NULL;
          p_startOfConstruct = new Sg_File_Info(*ptr.p_startOfConstruct);
          assert(p_startOfConstruct != NULL);

       // DQ (12/17/2006): Fixup the parent of the new or borrowed Sg_File_Info object.
          p_startOfConstruct->set_parent(this);

       // DQ (11/19/2004): Added to support explicit scopes for variables within variable declarations.
          p_scope          = ptr.p_scope;

       // DQ (3/1/2005): Added to avoid valgrind warning about uninitialized use
          p_preinitialization = ptr.p_preinitialization;

          assert (p_storageModifier != NULL);
          *p_storageModifier = *(ptr.p_storageModifier);

       // DQ (4/10/2006): Removed in favor of implementation at SgNode using
       // a pointer and the interface represented directly at the SgNode
       // DQ (1/17/2006): Moved attribute mechanism to specific IR nodes
          p_attributeMechanism = NULL;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_code = ptr.p_register_name_code;

       // DQ (7/31/2006): Added support for asm declarations on variables
          p_register_name_string = ptr.p_register_name_string;

       // DQ (10/10/2007): Added support for initialization of this data member (reported as uninitialized by valgrind).
          p_requiresGlobalNameQualificationOnType = ptr.p_requiresGlobalNameQualificationOnType;

       // DQ (1/3/2009): Added support for GNU variable attribues
          p_gnu_attribute_modifierVector          = ptr.p_gnu_attribute_modifierVector;
          p_gnu_attribute_initialization_priority = ptr.p_gnu_attribute_initialization_priority;
          p_gnu_attribute_alignment               = ptr.p_gnu_attribute_alignment;
          p_gnu_attribute_visability              = ptr.p_gnu_attribute_visability;
          p_isCoArray                             = ptr.p_isCoArray;

       // DQ (2/5/2014): I just noticed that the initialization of these were missing.
          p_name_qualification_length_for_type     = ptr.p_name_qualification_length_for_type;
          p_type_elaboration_required_for_type     = ptr.p_type_elaboration_required_for_type;
          p_global_qualification_required_for_type = ptr.p_global_qualification_required_for_type;

       // DQ (2/2/2014): The secondary declaration for an array may be specified using empty bracket sysntax.
          p_hasArrayTypeWithEmptyBracketSyntax = ptr.p_hasArrayTypeWithEmptyBracketSyntax;

       // DQ (7/27/2014): Added support for C11 "_Alignas" keyword (alternative alignment specification).
          p_using_C11_Alignas_keyword                     = ptr.p_using_C11_Alignas_keyword;
          p_constant_or_type_argument_for_Alignas_keyword = ptr.p_constant_or_type_argument_for_Alignas_keyword;

       // DQ (8/2/2014): Adding support for C++11 auto keyword.
          p_using_auto_keyword                     = ptr.p_using_auto_keyword;

       // DQ (1/24/2016): Adding support to mark this to use the __device__ keyword.
          p_using_device_keyword                   = ptr.p_using_device_keyword;
        }
       else
        {
       // DQ (6/23/2006): Added debugging message to track this issue.
          mprintf ("SgInitializedName::operator=(): Attempt to copy self to self \n");
        }

  // assert(p_file_info != NULL);
     assert(p_startOfConstruct != NULL);

     return *this;
   }

bool
SgInitializedName::operator== (const SgInitializedName& ) const
   { return false; }

bool
SgInitializedName::operator< (const SgInitializedName&) const
   { return false; }

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (12/9/2004): This is how an automatically generated function!
SgName
SgInitializedName::get_name() const
   {
     assert (this != NULL);
     return p_name;
   }
#endif

#if 0
void
SgInitializedName::set_name ( SgName name )
   {
     assert (this != NULL);
     
     p_name = name;
   }
#endif

#if 0
// DQ (10/9/2007): Use the ROSETTA generated version to test failure

// DQ (10/5/2007): This was a mistake to comment out, we want this functionality.  It is likely that
// similar function ality should be provided for all other names declarations that generate symbols
// for the symbol table.
// DQ (12/9/2004): This is now an automatically generated function!
// AJ (10/21/2004): Added support for changing the symbol name associated with an SgInitializedName
// by updating the symbol table
int
SgInitializedName::set_name(SgName new_name) 
   {
  // This function could likely be simpler now that we have better symbol table support.

     set_isModified(true);

  // find the appropriate symbol table.
     SgNode * node = this;

  // DQ (12/9/2004): This should likely call the get_scope function (which is more robust than traversing 
  // parents, there is a reason why we are forced to include the scope explicitly on some IR nodes, 
  // see test2004_133.C for details).
     while((node!=NULL) && ( isSgScopeStatement(node)==NULL))
          node = node->get_parent();

     assert(node!=NULL);

     SgScopeStatement * scope_stmt = isSgScopeStatement(node);

     assert(scope_stmt != NULL);
     assert(scope_stmt->get_symbol_table() != NULL);
     assert(scope_stmt->get_symbol_table()->get_table() != NULL);

     SgDeclarationStatement * parent_declaration = get_declaration();

     assert(parent_declaration != NULL);

  // Find the symbols associated with p_name 
     std::pair<SgSymbolTable::hash_iterator,SgSymbolTable::hash_iterator> pair_it = 
          scope_stmt->get_symbol_table()->get_table()->equal_range(p_name);

     SgSymbolTable::hash_iterator found_it=scope_stmt->get_symbol_table()->get_table()->end();

     for(SgSymbolTable::hash_iterator it = pair_it.first; it != pair_it.second; ++it)
        {
          switch(parent_declaration->getVariant())
             {
               case V_SgVariableDeclaration:
                  {
                    if (isSgVariableSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgClassDeclaration:
                  {
                    if (isSgClassSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               case V_SgFunctionDeclaration:
                  {
                    if (isSgFunctionSymbol((*it).second)!=NULL)
                         found_it = it;
                    break;
                  }
               default:
                  {
                  }
             };
        }

  // there is no Variable,Class or Function symbol associated with p_name 
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          mprintf ("Warning: There is no Variable,Class or Function symbol associated with p_name \n");
          return 0;
        }

     SgSymbol * associated_symbol = (*found_it).second;

  // erase the name from there
     scope_stmt->get_symbol_table()->get_table()->erase(found_it);

  // insert the new_name in the symbol table
     found_it = scope_stmt->get_symbol_table()->get_table()->insert(pair<SgName,SgSymbol*> ( new_name,associated_symbol));

  // if insertion failed
     if (found_it == scope_stmt->get_symbol_table()->get_table()->end())
        {
          mprintf ("Warning: insertion of new symbol failed \n");
          return 0;
        }

  // Set the p_name to the new_name
     mprintf ("Reset p_name = %s to new_name = %s \n",p_name.str(),new_name.str());
     p_name = new_name;

  // Invalidate the p_iterator, p_no_name and p_name data members in the Symbol table

     return 1;
   }
#endif

SgType*
SgInitializedName::get_type() const
   {
     assert(this != NULL);
     return p_typeptr;
   }

void
SgInitializedName::set_type(SgType *t)
   {
     assert(this != NULL);

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     p_typeptr = t;
   }

SgInitializer*
SgInitializedName::get_initializer() const 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     assert(this != NULL);
     if (p_is_initializer)
          return p_initptr;
       else
          return NULL;
   }

void
SgInitializedName::set_initializer(SgInitializer* i) 
   {
  // DQ (12/17/2006): These should be able to be generated by ROSETTA!
  // The semantics of p_is_initializer appears to not be required.

     assert(this != NULL);

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     p_initptr        = i;
     p_is_initializer = 1;
   }


// DQ (3/31/2006): New version from Rich (fixes bug where empty mangled name was generated)
SgName
SgInitializedName::get_mangled_name (void) const
   {
     SgName mangled_name; // return value

  // Case 1: Function parameters.
  // Generate names for parameters such that
  //   int foo (int x, int y) { return x + y; }
  //   int foo (int, int);
  //   int foo (int a, int b);
  // all generate the same unique names for equivalent parameters.
     const SgFunctionParameterList* func_params = isSgFunctionParameterList (get_declaration ());
     if (func_params)
        {
       // Find position (parameter number) in parameter list
          const SgInitializedNamePtrList& func_args = func_params->get_args ();
          SgInitializedNamePtrList::const_iterator i;
          size_t param_num = 0;
          for (i = func_args.begin (); i != func_args.end () && *i != this; ++i)
               param_num++;
          if (i != func_args.end ()) // found position
             {
            // Compute a mangled prefix from the function declaration.
               ostringstream s;
               const SgFunctionDeclaration* func_decl = isSgFunctionDeclaration (func_params->get_parent ());
               if (func_decl)
                    s << func_decl->get_mangled_name ().str ();
               s << "__ARG" << param_num+1;  // Append argument number (1-based)
               mangled_name = SgName (s.str ());
             }
         // else, an error (see below).
        }
       else // Case 2: Not a function parameter
        {
          SgScopeStatement* scope = get_scope ();
          if (scope == NULL)
             {
               mprintf ("SgInitializedName = %p = %s \n",this,get_name().str());
               get_file_info()->display("Error scope of SgInitializedName == NULL");
             }
          assert (scope != NULL);

          SgName qual_name = mangleQualifiers (scope);

          SgName name = get_name();
          if (name.get_length() > 0) // not empty
             {
               mangled_name = joinMangledQualifiers (qual_name, get_name ());
             }
            else
             {
            // name is empty
               if (isSgCatchOptionStmt (scope)) // e.g., 'try {...} catch (int) {...}
                  {
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("CATCHARG"));
                  }
                 else
                  {
                 // mprintf ("Must be a padding declaration (e.g. int:16) \n");
                    mangled_name = joinMangledQualifiers (qual_name, SgName ("PADDING_VARIABLE"));
                  }
             }
        }

     if (!mangled_name.get_length ()) // Error: could not come up with a name.
        {
          mprintf ("Error in SgInitializedName::get_mangled_name(void): zero length mangled name generated (see if this is realistic)\n");
          SgScopeStatement* scope = get_scope ();
          assert (scope);
          mprintf ("  Surrounding scope is '%s'\n", scope->sage_class_name ());
          const SgDeclarationStatement* decl = get_declaration ();
          mprintf ("  Decl is '%s'\n", decl ? decl->sage_class_name () : "(none)");
          const SgDeclarationStatement* def = get_definition ();
          mprintf ("  Def is '%s'\n", def ? def->sage_class_name () : "(none)");
          const SgNode* par = decl ? decl->get_parent () : 0;
          mprintf ("  Parent(decl) is '%s'\n", par ? par->sage_class_name () : "(none)");

       // DQ (2/21/2007): I think this is OK for un-named function parameters, leave as a warning for now!.
       // assert(false);
       }

     return mangled_name;
   }


// QY 11/3/04
SgDeclarationStatement*
SgInitializedName::get_declaration() const
   {
     assert (this != NULL);
  // DQ (6/13/2005): This function assumes that the parents have been set!
  // so it should not be used in the EDG/Sage translation!
  // assert(get_parent() != NULL);

#if 1
  // DQ (6/21/2006): Return to using this version of the code
  // DQ (6/21/2005): This is trying to traverse back through the scopes which might not make sense
     for (SgNode* r = get_parent(); r != NULL; r = r->get_parent())
        {
          SgDeclarationStatement* d = isSgDeclarationStatement(r);

       // DQ (6/21/2005): I think this should always be true!
       // assert(d != NULL);

          if (d != NULL)
             {
               return d;
             }
        }

     return NULL;
#else
  // DQ (6/18/2006): Since we store the declaration we should use the explictly stored 
  // value instead of anything generated from parents (structure can be problematic for C++).
     return get_declptr();
#endif
   }

SgDeclarationStatement*
SgInitializedName::get_definition() const
   {
  // mprintf ("Why does SgInitializedName::get_definition() return a declaration! \n");
  // DQ (6/21/2005): Because the SgVariableDefinition is derived from a SgDeclarationStatement 
  // and we return a SgVariableDefinition

  // DQ (6/21/2005): Is this always true? NO!
  // assert(isSgVariableDefinition(get_declptr()) != NULL);

     return get_declptr(); 
   }

/*
void
SgInitializedName::set_declaration(SgDeclarationStatement * decl)
   { 
     //p_declptr = decl; 
     set_parent(decl);
   }
*/

void
SgInitializedName::set_definition(SgDeclarationStatement * def)
   { 
#if DEBUG_SAGE_ACCESS_FUNCTIONS
  // DQ (6/12/2007): New access function tests using DEBUG_SAGE_ACCESS_FUNCTIONS and 
  // DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION in sage3.h indicate this is required.
     if (get_declptr() != NULL)
        {
          mprintf ("Note: overwriting SgInitializedName::get_declptr() = %p with NULL before assignment to def = %p \n",get_declptr(),def);
          set_declptr(NULL);
        }
#endif

  // DQ (4/14/2015): Added call to set_isModified() function to record change to this IR node.
     set_isModified(true);

     set_declptr(def);
   }

bool
SgInitializedName::checkBit ( unsigned int bit ) const
   {
     assert (bit < e_last_gnu_variable_attribute);
  // return p_gnu_attribute_modifierVector[bit];
     return (p_gnu_attribute_modifierVector[bit] == true);
   }

void
SgInitializedName::setBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = true;
   }

void
SgInitializedName::unsetBit ( unsigned int bit )
   {
     assert (bit < e_last_gnu_variable_attribute);
     p_gnu_attribute_modifierVector[bit] = false;
   }


// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeak() const { return checkBit(e_gnu_attribute__weak__); }
void SgInitializedName::setGnuAttributeWeak()      { setBit(e_gnu_attribute__weak__); }
void SgInitializedName::unsetGnuAttributeWeak()    { unsetBit(e_gnu_attribute__weak__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUnused() const { return checkBit(e_gnu_attribute__unused__); }
void SgInitializedName::setGnuAttributeUnused()      { setBit(e_gnu_attribute__unused__); }
void SgInitializedName::unsetGnuAttributeUnused()    { unsetBit(e_gnu_attribute__unused__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeUsed() const { return checkBit(e_gnu_attribute__used__); }
void SgInitializedName::setGnuAttributeUsed()      { setBit(e_gnu_attribute__used__); }
void SgInitializedName::unsetGnuAttributeUsed()    { unsetBit(e_gnu_attribute__used__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeDeprecated() const { return checkBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::setGnuAttributeDeprecated()      { setBit(e_gnu_attribute__deprecated__); }
void SgInitializedName::unsetGnuAttributeDeprecated()    { unsetBit(e_gnu_attribute__deprecated__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeNoCommon() const { return checkBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::setGnuAttributeNoCommon()      { setBit(e_gnu_attribute__nocommon__); }
void SgInitializedName::unsetGnuAttributeNoCommon()    { unsetBit(e_gnu_attribute__nocommon__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeTransparentUnion() const { return checkBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::setGnuAttributeTransparentUnion()      { setBit(e_gnu_attribute__transparent_union__); }
void SgInitializedName::unsetGnuAttributeTransparentUnion()    { unsetBit(e_gnu_attribute__transparent_union__); }

// DQ (1/3/2009): Added GNU specific attributes
bool SgInitializedName::isGnuAttributeWeakReference() const { return checkBit(e_gnu_attribute__weakref__); }
void SgInitializedName::setGnuAttributeWeakReference()      { setBit(e_gnu_attribute__weakref__); }
void SgInitializedName::unsetGnuAttributeWeakReference()    { unsetBit(e_gnu_attribute__weakref__); }

// DQ (12/30/2013): Added support for packing on variables (instead of just on the types).
bool SgInitializedName::isGnuAttributePacked() const  { return checkBit(e_gnu_attribute__packed__); }
void SgInitializedName::setGnuAttributePacked()       { setBit(e_gnu_attribute__packed__); }
void SgInitializedName::unsetGnuAttributePacked()     { unsetBit(e_gnu_attribute__packed__); }

// DQ (12/30/2013): Added support for packing on variables (instead of just on the types).
bool SgInitializedName::isGnuAttributeNoReturn() const  { return checkBit(e_gnu_attribute__noreturn__); }
void SgInitializedName::setGnuAttributeNoReturn()       { setBit(e_gnu_attribute__noreturn__); }
void SgInitializedName::unsetGnuAttributeNoReturn()     { unsetBit(e_gnu_attribute__noreturn__); }

#if 0
 // DQ (8/17/2014): Associated Microsoft attributes that are valid in a function parameter.
    appdomain
    deprecated
    dllimport
    dllexport
    novtable
    process
    restrict
    selectany
    thread
    uuid(" ComObjectGUID ")
#endif

bool SgInitializedName::is_ms_declspec_parameter_appdomain() const  { return checkBit(e_ms_declspec_parameter_appdomain); }
void SgInitializedName::set_ms_declspec_parameter_appdomain()       { setBit(e_ms_declspec_parameter_appdomain); }
void SgInitializedName::unset_ms_declspec_parameter_appdomain()     { unsetBit(e_ms_declspec_parameter_appdomain); }

bool SgInitializedName::is_ms_declspec_parameter_deprecated() const  { return checkBit(e_ms_declspec_parameter_deprecated); }
void SgInitializedName::set_ms_declspec_parameter_deprecated()       { setBit(e_ms_declspec_parameter_deprecated); }
void SgInitializedName::unset_ms_declspec_parameter_deprecated()     { unsetBit(e_ms_declspec_parameter_deprecated); }

bool SgInitializedName::is_ms_declspec_parameter_dllimport() const  { return checkBit(e_ms_declspec_parameter_dllimport); }
void SgInitializedName::set_ms_declspec_parameter_dllimport()       { setBit(e_ms_declspec_parameter_dllimport); }
void SgInitializedName::unset_ms_declspec_parameter_dllimport()     { unsetBit(e_ms_declspec_parameter_dllimport); }

bool SgInitializedName::is_ms_declspec_parameter_dllexport() const  { return checkBit(e_ms_declspec_parameter_dllexport); }
void SgInitializedName::set_ms_declspec_parameter_dllexport()       { setBit(e_ms_declspec_parameter_dllexport); }
void SgInitializedName::unset_ms_declspec_parameter_dllexport()     { unsetBit(e_ms_declspec_parameter_dllexport); }

bool SgInitializedName::is_ms_declspec_parameter_novtable() const  { return checkBit(e_ms_declspec_parameter_novtable); }
void SgInitializedName::set_ms_declspec_parameter_novtable()       { setBit(e_ms_declspec_parameter_novtable); }
void SgInitializedName::unset_ms_declspec_parameter_novtable()     { unsetBit(e_ms_declspec_parameter_novtable); }

bool SgInitializedName::is_ms_declspec_parameter_process() const  { return checkBit(e_ms_declspec_parameter_process); }
void SgInitializedName::set_ms_declspec_parameter_process()       { setBit(e_ms_declspec_parameter_process); }
void SgInitializedName::unset_ms_declspec_parameter_process()     { unsetBit(e_ms_declspec_parameter_process); }

bool SgInitializedName::is_ms_declspec_parameter_restrict() const  { return checkBit(e_ms_declspec_parameter_restrict); }
void SgInitializedName::set_ms_declspec_parameter_restrict()       { setBit(e_ms_declspec_parameter_restrict); }
void SgInitializedName::unset_ms_declspec_parameter_restrict()     { unsetBit(e_ms_declspec_parameter_restrict); }

bool SgInitializedName::is_ms_declspec_parameter_selectany() const  { return checkBit(e_ms_declspec_parameter_selectany); }
void SgInitializedName::set_ms_declspec_parameter_selectany()       { setBit(e_ms_declspec_parameter_selectany); }
void SgInitializedName::unset_ms_declspec_parameter_selectany()     { unsetBit(e_ms_declspec_parameter_selectany); }

bool SgInitializedName::is_ms_declspec_parameter_thread() const  { return checkBit(e_ms_declspec_parameter_thread); }
void SgInitializedName::set_ms_declspec_parameter_thread()       { setBit(e_ms_declspec_parameter_thread); }
void SgInitializedName::unset_ms_declspec_parameter_thread()     { unsetBit(e_ms_declspec_parameter_thread); }

bool SgInitializedName::is_ms_declspec_parameter_uuid() const  { return checkBit(e_ms_declspec_parameter_uuid); }
void SgInitializedName::set_ms_declspec_parameter_uuid()       { setBit(e_ms_declspec_parameter_uuid); }
void SgInitializedName::unset_ms_declspec_parameter_uuid()     { unsetBit(e_ms_declspec_parameter_uuid); }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
int
SgInitializedName::get_name_qualification_length() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgInitializedName::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool 
SgInitializedName::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgInitializedName::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

// DQ (3/31/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool 
SgInitializedName::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgInitializedName::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA 
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgInitializedName::get_name_qualification_length_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgInitializedName::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

bool 
SgInitializedName::get_type_elaboration_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgInitializedName::set_type_elaboration_required_for_type ( bool type_elaboration_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

bool 
SgInitializedName::get_global_qualification_required_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgInitializedName::set_global_qualification_required_for_type ( bool global_qualification_required_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }

SOURCE_INITIALIZED_NAME_END


SOURCE_NAME_START

// Added to support assignments to string variables.
SgName::operator std::string () const
   {
     return p_char;
   }

// DQ (10/5/2007): We no longer need this!
// Definition of defaultName (use a default parameter)
// const SgName SgdefaultName("defaultName");

SgName::SgName()
   : p_char("")
   { }

unsigned int
SgName::get_length() const
   {
     assert(this != NULL);
     return p_char.size();
   }

SgName::SgName(const char * str): p_char(str ? str : "")
   {
  // Nothing to do here!
   }

// DQ (9/9/2004): Added support for conversion of strings to SgName
// I always wanted this and it was a pain that it didn't exist previously!
SgName::SgName(const std::string & str): p_char(str) {}

#if 0
SgName::SgName(const std::string & str)
   {
  // DQ (2/22/2019): Old version of code ": p_char(str) {}"
     p_char = "";
     if (str.empty() == false)
        {
          p_char = str;
        }
   }
#endif

SgName::SgName(const SgName& n): p_char(n.p_char)
   {
#if 0
  // DQ (1/25/2011): Added check...plus message...
     if (p_char.empty() == true)
        {
          mprintf ("WARNING: SgName copy constructor called for empty string \n");
        }
       else
        {
          mprintf ("In SgName copy constructor name = %s \n",p_char.c_str());
        }
#endif
   }

// SgName::SgName(const char *str, int n): p_char(str, n) {} // get first n chars in the string

int
SgName::operator!=(const SgName& n1) const 
   {
     assert(this != NULL);
     return p_char != n1.p_char;
   }

int
SgName::operator==(const SgName& n1) const
   {
     assert(this != NULL);

     return p_char == n1.p_char;
   }

#ifdef _MSC_VER
#define strncasecmp _strnicmp
#endif
// DQ (11/27/2010): Added support for case insensitive name matching.
bool
SgName::caseInsensitiveEquality ( const SgName & x, const SgName & y )
   {
  // This function checks a case insensitive match of x against y.
  // This is required because Fortran is case insensitive.

     size_t x_length = x.p_char.length();
     size_t y_length = y.p_char.length();

     return (x_length == y_length) ? strncasecmp(x.p_char.c_str(),y.p_char.c_str(),x_length) == 0 : false;
   }


int
SgName::operator<(const SgName& n1) const
   {
     assert(this != NULL);

     return p_char < n1.p_char;
   }

bool
SgName::is_null(void) const
   {
     assert(this != NULL);
     return p_char.empty();
   }

void
SgName::replace_space(char t)
   {
     assert(this != NULL);

     int len = p_char.size();
     for(int i=0; i < len; i++)
        {
       // if last one
          if(p_char[i]==' ') 
             {
               if(i==len-1) 
                    p_char.resize(p_char.size() - 1);
                 else 
                    p_char[i]=t;
             }
        }
   }

SgName&
SgName::operator<<(const std::string& str)
   {
     assert (this != NULL);

     p_char += str;
     return *this;
   }

SgName
SgName::itoname(int val)
   {
     std::ostringstream os;
     os << val;
     return SgName(os.str());
   }

SgName&
SgName::operator<<(int val)
   {
     assert(this != NULL);

     SgName str = itoname(val);
     p_char += str.p_char;
     return *this;
   }

SgName&
SgName::operator=(const SgName& n1)
   { 
     assert(this != NULL);
     this->p_char = n1.p_char;
     return *this;
   }

SgName&
SgName::tail(int n) // keep string after n
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? "" : p_char.substr(n);
     return *this;
   }

SgName&
SgName::head(int n) // keep first n chars
   {
     assert(this != NULL);
     p_char = (unsigned int)n >= p_char.size() ? p_char : p_char.substr(0, n);
     return *this;
   }

const char* SgName::str() const {
     assert(this != NULL);
  return p_char.c_str();
}

std::string&
SgName::getString()
   {
     assert(this != NULL);
     return p_char;
   }

const std::string&
SgName::getString() const
   {
     assert(this != NULL);
     return p_char;
   }


void SgName::display( const std::string& label ) const
   {
     assert(this != NULL);

     std::cout << label << ": " << p_char << "\n";
   }

// DQ (9/9/2004): friend function
SgName
operator+(const SgName & n1, const SgName & n2)
   {
     return SgName(n1.p_char + n2.p_char);
   }

// DQ (11/15/2004): Added to support general string operations (first used in the unparser)
SgName & 
SgName::operator+= (const SgName & n1)
   {
     assert(this != NULL);
     p_char += n1.p_char;
     return *this;
   }

SgName
SgName::assembleQualifiedName(const SgName & scopeQualifiedName, const SgName & localName)
   {
  // DQ (22/2005): Neede to add global scope specifier to handle some pathological cases (see test2005_144.C).
  // DQ (9/9/2004): Supporting function for building qualified names (specialied string concatination)
  // Previous code caused "::" to be inserted too often (e.g. where scope->get_qualified_name() was empty, as in global scope)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();

  // DQ (9/9/2004): We can't assert this since "" evaluates to is_null() being true!
  // assert(scopeQualifiedName.is_null() == false);

     SgName returnName;
  // DQ (9/9/2004): So these are redundent tests! (which was pleasant news to me!)
  // if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName == "") )
     if ( (scopeQualifiedName.is_null() == true) || (scopeQualifiedName.getString() == "") )
        {
          returnName = localName;
#if 0
       // DQ (11/29/2004): It seems that any assignment of "" to a SgName forces it to be evaluated so that is_null() == true
       // DQ (11/29/2004): Added checking for is_null() so that returnName would always be a valid name
          if (localName.is_null() == true)
               returnName = "";
            else
               returnName = localName;
#endif
        }
       else 
        {
          std::string scopeDelimiter;
          if (SageInterface::is_Java_language())
              scopeDelimiter = ".";
          else
              scopeDelimiter = "::";

       // Trap out the case of global scope to avoid building "::::"
          if ( scopeQualifiedName == scopeDelimiter )
             {
            // Avoid building "::::"
               returnName = scopeQualifiedName.getString() + localName.getString();
             }
            else
             {
               returnName = scopeQualifiedName.getString() + scopeDelimiter + localName.getString();
             }
        }

  // returnName = scopeQualifiedName << "::" << localName.str();
  // assert(returnName.is_null() == false);
      
     return returnName;
   }

SgName
SgName::invertCase() const
   {
     string s = p_char;

     char* str = &(s[0]);
     while(*str)
        {
          if(isupper(*str)) 
               *str = tolower(*str);  
            else
               if(islower(*str)) 
                    *str = toupper(*str); 
          str++; 
        }

  // mprintf ("In SgName::invertCase() s = %s return_name = %s \n",this->str(),s.c_str());

     return s;
   }



SOURCE_NAME_END


SOURCE_QUALIFIED_NAME_START
SOURCE_QUALIFIED_NAME_END


SOURCE_ATTRIBUTE_START

int
SgAttribute::isSame(const std::string& str)
   {
     return p_name == str;
   }

SOURCE_ATTRIBUTE_END


SOURCE_BIT_ATTRIBUTE_START
SOURCE_BIT_ATTRIBUTE_END


SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_START
SOURCE_FUNCTION_DECLARATION_ATTRIBUTE_END


SOURCE_CLASS_DECLARATION_ATTRIBUTE_START
SOURCE_CLASS_DECLARATION_ATTRIBUTE_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_START
SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_ATTRIBUTE_END


SOURCE_PRAGMA_START

std::string
SgPragma::get_pragma() const
   { return get_name(); }

bool
SgPragma::samePragma(const std::string& str)
   { return get_name() == str; }

bool
SgPragma::isPragma() const
   { return 1; }

bool
SgPragma::gotPrinted() const
   { return p_printed; }

void
SgPragma::setPrinted(bool s)
   { p_printed=s; }

void
SgPragma::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

     p_printed = false;
   }

// DQ (11/6/2006): This is not generated due to the name change of "file_info" to "startOfConstruct" (uncommented)
// DQ (1/18/2006): This is not generated due to the name change of "fileInfo" to "file_info"
Sg_File_Info*
SgPragma::get_file_info() const
   {
  // return p_fileInfo;
     return p_startOfConstruct;
   }

SOURCE_PRAGMA_END


SOURCE_FILE_INFORMATION_START

// int Sg_File_Info::p_cur_line ROSE_DEPRECATED_VARIABLE  = 0;
// std::string Sg_File_Info::p_cur_file  ROSE_DEPRECATED_VARIABLE = "";

// MK (7/22/05) : Added support for file ids. Here we initialize the static file maps, etc
// int Sg_File_Info::p_max_file_id = 0;
std::map<std::string, int> Sg_File_Info::p_nametofileid_map;
std::map<int, std::string> Sg_File_Info::p_fileidtoname_map;


// DQ (7/4/2005): Added to test internal consistancy
bool
Sg_File_Info::ok() const
   {
     assert(this != NULL);

  // DQ (10/22/2007): Are these reasonable constraints when #line n "" are used?
     bool lineNumberOK      = p_line > 0;
     bool columnNumberOK    = p_col  > 0;

  // MK (7/22/05) We compare using p_fileid instead of p_filename now
  // bool filenameOK        = p_filename != NULL;
     bool filenameOK        = p_file_id != NULL_FILE_ID;

  // A compiler generated node has no defined association with a file, line number, or column number.
     bool compilerGenerated = isCompilerGenerated();

  // DQ (11/22/2006): Some nodes have no source position information and we have the live with this at points in the processing.
  // A node which was explicitly marked as a sourcePositionUnavailableInFrontendcompiler has no defined association with a file, line number, or column number.
     bool sourcePositionUnavailableInFrontend = isSourcePositionUnavailableInFrontend();

  // DQ (12/23/2006): If this is part of a transformation then it is OK by definition.
  // A node introduced as part of a transformation has no defined association with a file, line number, or column number.
     bool transformation  = isTransformation();

     bool physicalFileOK = (p_physical_file_id >= 0);

     if (physicalFileOK == false)
        {
          mprintf ("Note: In Sg_File_Info::ok(): p_physical_file_id = %d \n",p_physical_file_id);
        }

  // return  compilerGenerated || (lineNumberOK && filenameOK);
  // return  sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && filenameOK);
  // return  transformation || sourcePositionUnavailableInFrontend || compilerGenerated || (lineNumberOK && columnNumberOK && filenameOK);
     return  (lineNumberOK && columnNumberOK && filenameOK) || compilerGenerated || sourcePositionUnavailableInFrontend || transformation;
   }

void
Sg_File_Info::updateSourcePosition ( Sg_File_Info* update )
   {
  // DQ (12/22/2006): This copies the line number and column number information and verifies that 
  // the file name is the same (it does not reset any of the classification flags).  This is more
  // useful than the assignment operator for updating information and is used in the file:
  // fixupSourcePositionInformation.C.

     assert(update != NULL);

  // Must have matching file name (only have to compare file_id's)
     assert(p_file_id == update->p_file_id);

  // Update only the line number and column number after verifying that the filenames are the same.
     p_line = update->p_line;
     p_col  = update->p_col;

  // DQ (12/20/2012): Added support for physical source position (existing file_id and line data represents logical position data).
     ROSE_ASSERT(p_physical_file_id == update->p_physical_file_id);
     p_physical_line = update->p_physical_line;

  // DQ (1/23/2013): Added support for source sequence numbering information.
     p_source_sequence_number = update->p_source_sequence_number;
   }


// DQ (8/1/2005): use static function to return new Sg_File_Info object set to default values
// Static function to return new Sg_File_Info object set to default values
Sg_File_Info* Sg_File_Info::generateDefaultFileInfo()
   {
     Sg_File_Info* returnValue = new Sg_File_Info("NULL_FILE",0,0);
     assert(returnValue != NULL);

  // DQ (6/7/2007): This causes "NULL_FILE" filenames to be introduced into the AST.
  // Gergo pointed out this problems and removing such entries will simplify the tests
  // that are done in the traverseInputFile traversal.
  // mprintf ("Sg_File_Info::generateDefaultFileInfo(): This function is depricated and is an error to call! \n");
  // assert(false);

#if 0
     mprintf ("In Sg_File_Info::generateDefaultFileInfo() return = %p \n",returnValue);
#endif

     return returnValue;
   }

// Static function to return new Sg_File_Info object set to default values appropriate for transformations
// static Sg_File_Info* generateTransformationDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForTransformationNode()
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setTransformation();

  // DQ (1/11/2006): Added call to setOutputInCodeGeneration() because the default 
  // behavior is to output all transformations.  Other functions allow transformations 
  // to be specified that would not be output (useful for when including new header files).
     returnValue->setOutputInCodeGeneration();

     returnValue->set_file_id( TRANSFORMATION_FILE_ID );

#if 0
     mprintf ("In Sg_File_Info::generateDefaultFileInfoForTransformationNode() return = %p \n",returnValue);
#endif

     return returnValue;
   }


// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( int file_id )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_file_id( file_id );

#if 0
     mprintf ("In Sg_File_Info::generateFileInfoForTransformationNode(file_id = %d) return = %p \n",file_id,returnValue);
#endif

     return returnValue;
   }


// DQ (1/11/2006): Added version of function where filename (file_id) can 
// be explicitly set to be the non-default value.
Sg_File_Info* Sg_File_Info::generateFileInfoForTransformationNode( string filename )
   {
  // IR nodes using this function's return value will be marked as transformations
     Sg_File_Info* returnValue = generateDefaultFileInfoForTransformationNode();

     returnValue->set_filenameString( filename );

#if 0
     mprintf ("In Sg_File_Info::generateFileInfoForTransformationNode(filename = %s) return = %p \n",filename.c_str(),returnValue);
#endif

     return returnValue;
   }


// Static function to return new Sg_File_Info object set to default values appropriate for compiler generated code
// static Sg_File_Info* generateCompilerGeneratedDefaultFileInfo()
Sg_File_Info* Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode()
   {
  // IR nodes using this function's return value will be marked as compiler generated (but not output, unless also marked as such)
     Sg_File_Info* returnValue = generateDefaultFileInfo();
     returnValue->setCompilerGenerated();

     returnValue->set_file_id( COMPILER_GENERATED_FILE_ID );

#if 0
     mprintf ("In Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode() return = %p \n",returnValue);
#endif

     return returnValue;
   }


// DQ (11/2/2006): Added operator= member function to simple assignment (used in fixupSourcePositionInformation.C
// to modify Sg_File_Info objects so that they better reflect the original source code).
Sg_File_Info &
Sg_File_Info::operator= ( const Sg_File_Info & X )
   {
#if 0
     mprintf ("In Sg_File_Info::operator=(): get_parent() = %p = %s \n",get_parent(),(get_parent() != NULL) ? get_parent()->class_name().c_str() : "null");
     mprintf ("In Sg_File_Info::operator=(): this = %p &X = %p \n",this,&X);
#endif

     p_file_id                  = X.p_file_id;
     p_line                     = X.p_line;
     p_col                      = X.p_col;
     p_classificationBitField   = X.p_classificationBitField;
     p_fileIDsToUnparse         = X.p_fileIDsToUnparse;
     p_fileLineNumbersToUnparse = X.p_fileLineNumbersToUnparse;

  // DQ (12/20/2012): Added support for physical source position (existing file_id and line data represents logical position data).
     p_physical_file_id = X.p_physical_file_id;
     p_physical_line    = X.p_physical_line;

  // DQ (1/23/2013): Added support for source sequence numbering information.
     p_source_sequence_number = X.p_source_sequence_number;

  // Record that this source position information was updated.
     set_isModified(true);

     return *this;
   }


// DQ (9/26/2004): Added operator== friend function to permit testing of reused definitions of defining declarations!
bool
operator== ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool returnValue = false;

  // Make this most efficent by putting the least likely match first 
  // (col, line, file) and the most expensive test (file) last.
     if (X.get_col() == Y.get_col())
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.get_line() == Y.get_line())
          if (X.get_physical_line() == Y.get_physical_line())
             {
	       // MK (7/22/05) : Replaced string comparisons with file_id comparisons
	       /*
               if ( string(X.get_filename()) == string(Y.get_filename()))
                  {
                    returnValue = true;
                  }
	       */
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_file_id == Y.p_file_id)
               if (X.p_physical_file_id == Y.p_physical_file_id)
                  {
                    returnValue = true;
                  }
             }
        }

     return returnValue;
   }


// DQ (10/6/2004): Added operator!= friend function to permit testing of reused definitions of defining declarations!
bool
operator!= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     return operator==(X,Y) ? false : true;
   }


// DQ (10/25/2004): Added relational operators to permit testing of strting vs. ending file info object (assert starting < ending)
bool
operator>  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // mprintf ("In operator > (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // mprintf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // mprintf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
       // if (X.p_line > Y.p_line)
          if (X.p_physical_line > Y.p_physical_line)
             {
            // mprintf ("TRUE: X.p_line = %d > X.p_line = %d \n",X.p_line,X.p_line);
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col > Y.p_col)
                       {
                      // mprintf ("TRUE: X.p_col = %d > Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // mprintf ("Sorry operator> (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator<  ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
  // mprintf ("In operator < (Sg_File_Info,Sg_File_Info): X.isSameFile(Y) = %s \n",X.isSameFile(Y) ? "true" : "false");
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // mprintf ("X.p_line = %d Y.p_line = %d \n",X.p_line,Y.p_line);
       // mprintf ("X.p_col  = %d Y.p_col  = %d \n",X.p_col,Y.p_col);
       // if (X.p_line < Y.p_line)
          if (X.p_physical_line < Y.p_physical_line)
             {
            // mprintf ("TRUE: X.p_line = %d < Y.p_line = %d \n",X.p_line,Y.p_line);
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col < Y.p_col)
                       {
                      // mprintf ("TRUE: X.p_col = %d < Y.p_col = %d \n",X.p_col,Y.p_col);
                         result = true;
                       }
                  }
             }
        }

  // mprintf ("Sorry operator< (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator>= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.p_line > Y.p_line)
          if (X.p_physical_line > Y.p_physical_line)
             {
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col >= Y.p_col)
                         result = true;
                  }
             }
        }

  // mprintf ("Sorry operator>= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


bool
operator<= ( const Sg_File_Info & X, const Sg_File_Info & Y )
   {
     bool result = false;
     if (X.isSameFile(Y) == true)
        {
       // DQ (9/17/2013): We always want to use the physical source position.
       // if (X.p_line < Y.p_line)
          if (X.p_physical_line < Y.p_physical_line)
             {
               result = true;
             }
            else
             {
            // DQ (9/17/2013): We always want to use the physical source position.
            // if (X.p_line == Y.p_line)
               if (X.p_physical_line == Y.p_physical_line)
                  {
                    if (X.p_col <= Y.p_col)
                         result = true;
                  }
             }
        }

  // mprintf ("Sorry operator<= (const Sg_File_Info & X, const Sg_File_Info & Y) not implemented! \n");
  // assert(false);
  // return true;

     return result;
   }


//Liao 4/16/2010. The default value for display(label) cannot be instantiated from gdb,
// which is very annoying during debugging. I added the empty parameter one to better support debugging.
void
Sg_File_Info::display() const
   {
     display ("");
   }


void
Sg_File_Info::display( const std::string label ) const
   {
     assert(this != NULL);

     mprintf ("Inside of Sg_File_Info::display(%s) of this pointer = %p \n",label.c_str(), this);
     mprintf ("     isTransformation                      = %s \n",isTransformation()                      == true ? "true (part of a transformation)" : "false");
     mprintf ("     isCompilerGenerated                   = %s \n",isCompilerGenerated()                   == true ? "true (no position information)" : "false");
     mprintf ("     isOutputInCodeGeneration              = %s \n",isOutputInCodeGeneration()              == true ? "true (output in code generator)" : "false");
     mprintf ("     isShared                              = %s \n",isShared()                              == true ? "true (shared within merged AST)" : "false");
     mprintf ("     isFrontendSpecific                    = %s \n",isFrontendSpecific()                    == true ? "true (part of ROSE support for gnu compatability)" : "false");
     mprintf ("     isSourcePositionUnavailableInFrontend = %s \n",isSourcePositionUnavailableInFrontend() == true ? "true (source position unavailable in frontend)" : "false");
     mprintf ("     isCommentOrDirective                  = %s \n",isCommentOrDirective()                  == true ? "true (this is a comment or CPP directive)" : "false");
     mprintf ("     isToken                               = %s \n",isToken()                               == true ? "true (this is from the token stream woven into the AST)" : "false");
     mprintf ("     isDefaultArgument                     = %s \n",isDefaultArgument()                     == true ? "true (root of default argument)" : "false");
     mprintf ("     isImplicitCast                        = %s \n",isImplicitCast()                        == true ? "true (implicit instead of explicit cast)" : "false");

  // if (isCompilerGenerated() == false)
     if (!isTransformation() && !isCompilerGenerated())
        {
          mprintf ("     (computed) filename = %s \n",get_filename());
          mprintf ("     (computed) line     = %d  column = %d \n",get_line(),get_col());
        }
       else // Liao, 11/12/2012, more information for debugging
        {
          mprintf ("     Filename and line, column info should be invalid for transformation or compiler generated objects\n");
          mprintf ("     we print their values anyway for your reference\n");
          mprintf ("     (computed) filename = %s \n",get_filename());
          mprintf ("     (computed) line     = %d  column = %d \n",get_line(),get_col());
        }

  // DQ (6/17/2005): Way to get extra debugging information, if the
  // substring "debug" is found then extra information is output
  // if (label == "debug")
     if (label.find("debug") != std::string::npos)
        {
          mprintf ("     (internal) file_id   = %d \n",get_file_id());
          mprintf ("     (internal) filename  = %s \n",get_raw_filename().c_str());
          mprintf ("     (internal  line      = %d  column   = %d \n",p_line,p_col);
        }

     mprintf ("     (computed) physical_file_id    = %d = %s \n",get_physical_file_id(),get_physical_filename().c_str());
     mprintf ("     (computed) physical_line       = %d \n",p_physical_line);

  // DQ (1/23/2013): Added support for source sequence numbering information.
     mprintf ("     source_sequence_number         = %d \n",p_source_sequence_number);

  // DQ (5/16/2005): output these values, but I think they might be removed 
  // later since I don't see the point of storing this information!
  // mprintf ("     isDeclaration    = %s \n",isDeclaration()    == true ? "true" : "false");
  // mprintf ("     isInitialization = %s \n",isInitialization() == true ? "true" : "false");
   }

string
Sg_File_Info::displayString(const std::string & label ) const
   {
     assert(this != NULL);

     std::string s;
     s += std::string("Inside of Sg_File_Info::displayString(") + label + std::string (") \n");
     s += std::string("isTransformation    = ") + std::string(isTransformation()    ? "true " : "false ") + std::string(" ");
     s += std::string("isCompilerGenerated = ") + std::string(isCompilerGenerated() ? "true " : "false ") + std::string(" ");
     if (!isTransformation() && !isCompilerGenerated())
        {
          s += std::string("line number = ")   + Rose::StringUtility::numberToString(get_line()) + std::string(" ");
          s += std::string("column number = ") + Rose::StringUtility::numberToString(get_col())  + std::string(" ");
          s += std::string("filename = ")      + std::string(get_filename()) + std::string(" ");
        }

     return s;
   }

void
Sg_File_Info::display_static_data( const std::string label )
   {
  // DQ (6/11/2007): output static data for debugging

     mprintf ("Inside of Sg_File_Info::display_static_data(%s) \n",label.c_str());

  // mprintf ("p_cur_line = %d \n",p_cur_line);
  // mprintf ("p_cur_file = %s \n",p_cur_file.c_str());

  // mprintf ("p_max_file_id = %d \n",p_max_file_id);

     mprintf ("p_nametofileid_map: \n");
     for (std::map<std::string,int>::iterator i = p_nametofileid_map.begin(); i != p_nametofileid_map.end(); i++)
        {
          mprintf ("name = %s id = %d \n",i->first.c_str(),i->second);
        }

     mprintf ("p_fileidtoname_map: \n");
     for (std::map<int,std::string>::iterator i = p_fileidtoname_map.begin(); i != p_fileidtoname_map.end(); i++)
        {
          mprintf ("id = %d name = %s \n",i->first,i->second.c_str());
        }
   }

// Since we make the arguments in the other constructor 
// have default values this constructor is redundant/ambiguous
// Sg_File_Info::Sg_File_Info() {}

Sg_File_Info::Sg_File_Info()
   : p_file_id(COPY_FILE_ID), p_line(0), p_col(0),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     ROSE_ASSERT(this != NULL);
     post_construction_initialization();
   }

// DQ (4/19/2006): Added constructor to take std::string as part of move
// away from C style strings to C++ style strings.
Sg_File_Info::Sg_File_Info ( const std::string & filename, int line, int col )
   : p_file_id(NULL_FILE_ID), p_line(line), p_col(col),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     if (filename != "NULL_FILE")
        {
          set_filenameString(filename);
        }

     set_physical_source_position_to_match_logical_source_position();

     post_construction_initialization();
   }

// DQ (2/15/2003): added copy constructor
Sg_File_Info::Sg_File_Info(const Sg_File_Info & X)
   : p_file_id(X.p_file_id),
     p_line(X.p_line),
     p_col(X.p_col),
     p_classificationBitField(X.p_classificationBitField),
     p_physical_file_id(X.p_physical_file_id),
     p_physical_line(X.p_physical_line),
     p_source_sequence_number(X.p_source_sequence_number),
     p_fileIDsToUnparse(X.p_fileIDsToUnparse),
     p_fileLineNumbersToUnparse(X.p_fileLineNumbersToUnparse)
   {
     post_construction_initialization();
   }

// DQ (11/6/2008): added constructor to support building objects from Dwarf 
// information (which uses a pre-resolved integer file_id instead of a string)
Sg_File_Info::Sg_File_Info( int file_id, int line, int column )
   : p_file_id(file_id),
     p_line(line),
     p_col(column),
     p_classificationBitField(0),
     p_physical_file_id(NULL_FILE_ID),
     p_physical_line(0),
     p_source_sequence_number(0),
     p_fileIDsToUnparse(),
     p_fileLineNumbersToUnparse()
   {
     post_construction_initialization();
   }

void
Sg_File_Info::post_construction_initialization()
   {
     ROSE_ASSERT(this != NULL);
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // ROSE-1499 check that p_file_id is valid
     check_file_id("Sg_File_Info::post_construction_initialization");
   }

// ROSE-1499, ROSE-1639 (added const to char*)
void Sg_File_Info::check_file_id(const char * label, bool assertion) const {
  if ( ( (p_file_id >= 0) && (p_fileidtoname_map.count(p_file_id) == 0) ) || ( (p_file_id < -6) || ( p_file_id > (int)p_fileidtoname_map.size() ) ) ) {
    printf("ERROR from %s:\n", label);
    printf("  Sg_File_Info::this = %p\n", this);
    printf("  p_file_id = %d\n", p_file_id);
    printf("  p_nametofileid_map.size() = %zu\n", p_nametofileid_map.size());
    printf("  p_fileidtoname_map.size() = %zu\n", p_fileidtoname_map.size());
    printf("  isTransformation() = %d\n", isTransformation());
    printf("  isCompilerGenerated() = %d\n", isCompilerGenerated());
    printf("  isFrontendSpecific() = %d\n", isFrontendSpecific());
  }
  if (assertion) {
     ROSE_ASSERT((p_file_id < 0) || (p_fileidtoname_map.count(p_file_id) > 0));
     ROSE_ASSERT((p_file_id > -7) && (p_file_id < (int)p_fileidtoname_map.size()));
  }
}

int 
Sg_File_Info::get_file_id () const
   {
  // DQ (10/27/2007): This is custom generated so that it can be consistant with the get_filename() member function
     assert (this != NULL);

     check_file_id("Sg_File_Info::get_file_id");

  // initialize to bad value
     int returnValue = -99;

     if (isTransformation() == true)
        {
       // returnValue = undefinedValue;
          returnValue = TRANSFORMATION_FILE_ID;
        }
       else
        {
       // DQ (11/1/2007): This does not allow for isSameFile() to compare properly when testing for "rose_edg_required_macros_and_functions.h"
          if ( isCompilerGenerated() == true )
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the file_id of the associated file ("rose_edg_required_macros_and_functions.h")
            // returnValue = undefinedValue;
               if ( isFrontendSpecific() == true )
                  {
#define FAIL_ON_ROSE_1532 0
#if FAIL_ON_ROSE_1532
                    if (p_fileidtoname_map.count(p_file_id) == 0 && p_file_id == COMPILER_GENERATED_FILE_ID) {
                      printf("ERROR: Sg_File_Info::get_file_id(this = %p):\n", this);
                      printf("  isFrontendSpecific() == true => p_file_id == file_id_of(\"rose_edg_required_macros_and_functions.h\")\n");
                      printf("  BUT:  p_file_id = %d\n", p_file_id);
                      printf("  HERE: p_file_id == COMPILER_GENERATED_FILE_ID\n");
                      printf("  BYPASSED: seen for a SgInitializedName in the parameter list of __builtin_atan2\n");
                      ROSE_ASSERT(false);
                    }
#endif
                 // ROSE-1499: check that p_file_id is valid
                    ROSE_ASSERT(p_file_id == COMPILER_GENERATED_FILE_ID || p_fileidtoname_map.count(p_file_id) > 0);
                 // In this case return the file_id of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnValue = p_file_id;
                  }
                 else
                  {
                    returnValue = COMPILER_GENERATED_FILE_ID;
                  }
             }
            else
             {
#define FAIL_ON_ROSE_1533 0
#if FAIL_ON_ROSE_1533
               if (p_fileidtoname_map.count(p_file_id) == 0 && p_file_id == NULL_FILE_ID) {
                 printf("ERROR: Sg_File_Info::get_file_id(this = %p):\n", this);
                 printf("  p_nametofileid_map.size() = %d\n", p_nametofileid_map.size());
                 printf("  p_fileidtoname_map.size() = %d\n", p_fileidtoname_map.size());
                 printf("  p_file_id should represent a valid file.\n", p_file_id);
                 printf("  HERE: p_file_id == NULL_FILE_ID\n");
                 printf("  BYPASSED: seen for a SgCtorInitializerList of foo1 in Cxx_tests/test2003_01.C (the SgCtorInitializerList is implicit).\n");
                 ROSE_ASSERT(false);
               }
#endif
            // ROSE-1499: check that p_file_id is valid
               ROSE_ASSERT(p_file_id == NULL_FILE_ID || p_file_id == COMPILER_GENERATED_FILE_ID || p_fileidtoname_map.count(p_file_id) > 0);
               returnValue = p_file_id;
             }
        }

  // DQ (12/18/2012): Added assertion.
     ROSE_ASSERT(returnValue != -99);

     return returnValue;
   }

void
Sg_File_Info::set_file_id( int file_id )
   {
     assert (this != NULL);
     set_isModified(true);

     check_file_id("Sg_File_Info::set_file_id");

#if 0
     mprintf ("In Sg_File_Info::set_file_id(file_id = %d) this = %p \n",file_id,this);
#endif

     p_file_id = file_id;
   }


int 
Sg_File_Info::get_physical_file_id() const
   {
  // DQ (12/18/2012): Added support for physical file position information.
     assert (this != NULL);

  // Initialize to error value.
     int return_physical_file_id = NULL_FILE_ID;

#if 0
  // Match the behavior (transformation, compiler generated, etc.) of the p_file_id.
     int file_id = get_file_id();
#else
  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     bool physicalFileOK = (p_physical_file_id >= 0);
     int file_id = get_file_id();
#endif

  // DQ (8/20/2018): Not clear why this language specific rule is a good idea.
  // PHL (01/06/2014) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
        {
          return file_id;
        }

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
#if 0
     if (file_id < 0)
#else
     if (physicalFileOK == false && file_id < 0)
#endif
        {
          return_physical_file_id = file_id;
        }
       else
        {
#if 0
          return_physical_file_id = p_physical_file_id;
#else
       // DQ (8/22/2018): Use the file_id for compiler generated nodes, because they don't have a valid source position.
#if 0
          mprintf ("In Sg_File_Info::get_physical_file_id(): isCompilerGenerated() = %s file_id = %d p_physical_file_id = %d \n",isCompilerGenerated() ? "true" : "false",file_id,p_physical_file_id);
#endif
          if (isCompilerGenerated() == true)
             {
               return_physical_file_id = file_id;
             }
            else
             {
               return_physical_file_id = p_physical_file_id;
             }
#endif
        }

     return return_physical_file_id;
   }


int 
Sg_File_Info::get_physical_file_id(int input_file_id) const
   {
  // DQ (12/18/2012): Added support for physical file position information.
     assert (this != NULL);

  // Initialize to error value.
     int return_physical_file_id = NULL_FILE_ID;

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     bool physicalFileOK = (p_physical_file_id >= 0);
     int local_file_id = get_file_id();

  // DQ (8/20/2018): Not clear why this language specific rule is a good idea.
  // PHL (01/06/2014) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
        {
          return local_file_id;
        }

#if 0
     mprintf ("In Sg_File_Info::get_physical_file_id(int): physicalFileOK = %s \n",physicalFileOK ? "true" : "false");
     mprintf (" --- local_file_id = %d \n",local_file_id);
#endif

  // DQ (8/20/2018): Fix this to not report generic "transformed" for any statement marked as a transformation when querying the physical file id.
  // This is (I think) required support for the unparsing of header files.
     if (physicalFileOK == false && local_file_id < 0)
        {
          return_physical_file_id = local_file_id;
        }
       else
        {
       // DQ (8/22/2018): Use the file_id for compiler generated nodes, because they don't have a valid source position.
#if 0
          mprintf ("In Sg_File_Info::get_physical_file_id(int): isCompilerGenerated() = %s local_file_id = %d p_physical_file_id = %d \n",isCompilerGenerated() ? "true" : "false",local_file_id,p_physical_file_id);
#endif
          if (isCompilerGenerated() == true)
             {
               return_physical_file_id = local_file_id;
             }
            else
             {
            // return_physical_file_id = p_physical_file_id;

               if (input_file_id == this->get_physical_file_id())
                  {
                    return_physical_file_id = p_physical_file_id;
                  }
                 else
                  {
                    SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),input_file_id);
                    if (pos != p_fileIDsToUnparse.end())
                       {
#if 1
                         mprintf ("Sg_File_Info::get_physical_file_id(int): input file is sharing this IR node: input_file_id = %d physical_file_id = %d \n",input_file_id,this->get_physical_file_id());
#endif
                         ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                         ROSE_ASSERT(index >= 0);
                         ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());

                      // DQ (12/23/2019): Added debugging info.
                         if (p_fileLineNumbersToUnparse.size() != p_fileIDsToUnparse.size())
                            {
                              mprintf ("Error: p_fileLineNumbersToUnparse.size() != p_fileIDsToUnparse.size() \n");
                              mprintf (" --- p_fileLineNumbersToUnparse.size() = %zu \n",p_fileLineNumbersToUnparse.size());
                              mprintf (" --- p_fileIDsToUnparse.size()         = %zu \n",p_fileIDsToUnparse.size());
                            }
                         ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
#if 1
                         mprintf (" --- index = %d shared input file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                         ROSE_ASSERT(input_file_id == p_fileIDsToUnparse[index]);
                         return_physical_file_id = p_fileIDsToUnparse[index];
#if 1
                         mprintf (" --- returning return_physical_file_id = %d \n",return_physical_file_id);
#endif
#if 0
                         mprintf ("Exiting as a test! \n");
                         ROSE_ASSERT(false);
#endif
                       }
                      else
                       {
                      // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                      // This is a reasonable default, if we don't want to make this an error.

                         return_physical_file_id = p_physical_file_id;
                       }
                  }
             }
        }

#if 0
     mprintf ("Leaving Sg_File_Info::get_physical_file_id(int): p_physical_file_id = %d \n",p_physical_file_id);
#endif

     return return_physical_file_id;
   }


void
Sg_File_Info::set_physical_file_id( int physical_file_id )
   {
     assert (this != NULL);

     set_isModified(true);

#if 0
     mprintf ("In Sg_File_Info::set_physical_file_id(physical_file_id = %d) this = %p \n",physical_file_id,this);
#endif

     p_physical_file_id = physical_file_id;

  // Make sure this is a previously handled file.
     if (p_physical_file_id >= 0)
        {
          ROSE_ASSERT(p_fileidtoname_map.find(p_physical_file_id) != p_fileidtoname_map.end());
        }
   }


void
Sg_File_Info::set_physical_source_position_to_match_logical_source_position()
   {
     assert (this != NULL);

     set_isModified(true);

     p_physical_file_id = p_file_id;
     p_physical_line    = p_line;

  // Make sure this is a previously handled file.
     if (p_physical_file_id >= 0)
        {
          ROSE_ASSERT(p_fileidtoname_map.find(p_physical_file_id) != p_fileidtoname_map.end());
        }
   }


int
Sg_File_Info::numberOfSourceFiles()
   {
     return p_nametofileid_map.size();
   }


int
Sg_File_Info::addFilenameToMap ( const std::string & filename )
   {
  // DQ (11/6/2008): Added support for extending the internal static filename to integer id map.
  // This static function is used the the Dwarf support to convert filenames to integer values and 
  // maintain a map similar to the Dwarf mapping of integers to filenames as a way to save space
  // in the represnetation of source position mappings of the instructions in the binary.

     int returnValue = 0;
     if (p_nametofileid_map.count(filename) == 0)
        {
          returnValue = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = returnValue;
          p_fileidtoname_map[returnValue] = filename;
        }
       else
        {
          returnValue = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());

     return returnValue;
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filename(const char* filename)
Sg_File_Info::set_filenameString ( const std::string & filename )
   {
     assert (this != NULL);

     check_file_id("Sg_File_Info::set_filenameString");

#if 0
     mprintf ("In Sg_File_Info::set_filenameString(filename = %s) this = %p \n",filename.c_str(),this);
#endif

  // DQ (6/6/2019): I think this is a more efficent implementation.
  // p_nametofileid_map has type: std::map<std::string, int>
  // if (p_nametofileid_map.count(filename) == 0)
     if (p_nametofileid_map.find(filename) == p_nametofileid_map.end())
        {
          p_file_id = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = p_file_id;
          p_fileidtoname_map[p_file_id] = filename;
        }
       else
        {
          p_file_id = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());

  // DQ (3/19/2017): Note that this is important for Fortran support (where IR nodes frequently 
  // start with (isSourcePositionUnavailableInFrontend() == true) and are fixed up afterward.
     if ( isSourcePositionUnavailableInFrontend() == true )
        {
#if 0
          mprintf ("In Sg_File_Info::set_filenameString(): reset isSourcePositionUnavailableInFrontend() to false: filename = %s \n",filename.c_str());
#endif
          unsetSourcePositionUnavailableInFrontend();
        }

  // DQ (8/31/2006): We can't enforce that this is an absolute path (test2001_04.C and test2004_60.C demonstrate why).
  // DQ (8/31/2006): Verify that this is a absolute path
  // string targetSubstring = "/";
  // string filenameString  = filename;
  // if (filenameString.substr(0,targetSubstring.size()) != targetSubstring)
  //      mprintf ("@@@@@@@@@@@@@@@@@@@@ In Sg_File_Info::Sg_File_Info(string,int,int): filename = %s @@@@@@@@@@@@@@@@@@@@\n",filenameString.c_str());
  // assert(filenameString.substr(0,targetSubstring.size()) == targetSubstring);

  // Detect use of AST Rewrite intermediate files (need to make sure they get absolute paths)
  // string targetSubstring2 = "rose_";
  // assert(filenameString.substr(0,targetSubstring2.size()) != targetSubstring2);
   }

void
Sg_File_Info::set_physical_filename ( const std::string & filename )
   {
     assert (this != NULL);

#if 0
     mprintf ("In Sg_File_Info::set_physical_filename(filename = %s) this = %p p_nametofileid_map.count(filename) = %" PRIuPTR " \n",filename.c_str(),this,p_nametofileid_map.count(filename));
#endif

  // DQ (6/6/2019): I think this is a more efficent implementation.
  // p_nametofileid_map has type: std::map<std::string, int>
  // if (p_nametofileid_map.count(filename) == 0)
     if (p_nametofileid_map.find(filename) == p_nametofileid_map.end())
        {
       // If the filename is not in the p_nametofileid_map then we need to add it.
          p_physical_file_id = p_nametofileid_map.size();
          p_nametofileid_map[filename]  = p_physical_file_id;
          p_fileidtoname_map[p_physical_file_id] = filename;
        }
       else
        {
       // If it is in the p_nametofileid_map then we just need to get the integer file id.
          p_physical_file_id = p_nametofileid_map[filename];
        }

     // ROSE-1499 check that the maps are the same size
     ROSE_ASSERT(p_nametofileid_map.size() == p_fileidtoname_map.size());
   }

void
// DQ (9/5/2006): renamed functions to swap the implementations
// Sg_File_Info::set_filenameString ( const std::string & filename )
Sg_File_Info::set_filename(const char* filename)
   {
     check_file_id("Sg_File_Info::set_filename");

  // DQ (9/5/2006): Modified implementation
  // set_filename(filename.c_str());
     assert(filename != NULL);
     set_filenameString(filename);
   }

const std::string &
Sg_File_Info::get_filenameString() const
   {
     assert (this != NULL);
     check_file_id("Sg_File_Info::get_filenameString");

     const std::string* returnString = NULL;

     if (isTransformation() == true)
        {
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
       else
        {
          if (isCompilerGenerated() == true)
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the filename of the associated file ("rose_edg_required_macros_and_functions.h")
            // This has been fixed to be consistant with the implementation of get_file_id().
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the filename of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnString = &getFilenameFromID(p_file_id);
                  }
                 else
                  {
                    static const std::string compilerGenerated_string = "compilerGenerated";
                    returnString = &compilerGenerated_string;
                  }
             }
            else
             {
               returnString = &getFilenameFromID(p_file_id);
             }
        }

     assert (returnString != NULL);

     return *returnString;
   }

const char*
Sg_File_Info::get_filename() const
   {

     check_file_id("Sg_File_Info::get_filename");

  // DQ (10/15/2005): This function is the C string version of the get_filename() 
  // function which has been depricated. At some point the get_filename() function 
  // will be eliminated and later reinfroduced as get_filename() (finally building
  // a C++ string implementation instead of a char* (C style string) based implementation).
     return get_filenameString().c_str();
   }

string
Sg_File_Info::get_raw_filename() const
   {
     assert (this != NULL);

  // return whatever name is in the map
     return getFilenameFromID(p_file_id);
   }

string
Sg_File_Info::get_physical_filename() const
   {
     assert (this != NULL);

#if 0
  // return whatever name is in the map
     return getFilenameFromID(p_physical_file_id);
#else
  // DQ (9/21/2013): The support to return the filename must account for when this is compiler generated, a transformations, part of the front-end, etc.
     const std::string* returnString = NULL;

     if (isTransformation() == true)
        {
          static const std::string transformation_string = "transformation";
          returnString = &transformation_string;
        }
       else
        {
          if (isCompilerGenerated() == true)
             {
            // DQ (11/1/2007): check if this is frontEndSpecific, and if so return the filename of the associated file ("rose_edg_required_macros_and_functions.h")
            // This has been fixed to be consistant with the implementation of get_file_id().
               if ( isFrontendSpecific() == true )
                  {
                 // In this case return the filename of the specific file which indicates this properly ("rose_edg_required_macros_and_functions.h").
                    returnString = &getFilenameFromID(p_physical_file_id);
                  }
                 else
                  {
                    static const std::string compilerGenerated_string = "compilerGenerated";
                    returnString = &compilerGenerated_string;
                  }
             }
            else
             {
               returnString = &getFilenameFromID(p_physical_file_id);
             }
        }

     assert (returnString != NULL);

     return *returnString;
#endif
   }

void
Sg_File_Info::set_line(int line)
   {
     assert (this != NULL);

     p_line = line;
     if (isTransformation() || isCompilerGenerated())
        {
          if (line !=0) // Liao, 11/12/2012. get_line() won't return the value being set!!
             {
               mprintf ("warning: Sg_File_Info::set_line() tried to set non-zero line number to a transformation or compiler generated file info obj.");
             }
        }
       else
        {
       // DQ (3/19/2017): Note that this is important for Fortran support (where IR nodes frequently 
       // start with (isSourcePositionUnavailableInFrontend() == true) and are fixed up afterward.
          if ( isSourcePositionUnavailableInFrontend() == true )
             {
#if 0
               mprintf ("In Sg_File_Info::set_line(): reset isSourcePositionUnavailableInFrontend() to false: line = %d \n",line);
#endif
               unsetSourcePositionUnavailableInFrontend();
             }
        }
   }

int
Sg_File_Info::get_line() const
   { 
     assert (this != NULL);

  // return p_line;
  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // mprintf ("Sg_File_Info::get_line called for transformation IR node (p_line = %d) \n",p_line);
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // mprintf ("Sg_File_Info::get_line called for compiler generated IR node (p_line = %d) \n",p_line);

            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
            // returnValue = undefinedValue;
            // returnValue = p_line;
               returnValue = undefinedValue;
             }
            else
             {
#if 0
            // DQ (3/18/2017): Original code.
               returnValue = p_line;
#else
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h 
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
            // if (isFrontendSpecific() == true || isSourcePositionUnavailableInFrontend() == true )
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    returnValue = p_line;
                  }
#endif
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }


// DQ (2/28/2019): Support for multi-file handling.
int
Sg_File_Info::get_line(int file_id) const
   {
  // Where this is a shared IR node across multiple files, return the line number location of the IR node for a specific file.

     assert (this != NULL);

     const int undefinedValue = 0;
     int returnValue = 0;

     if (isTransformation() == true)
        {
       // mprintf ("Sg_File_Info::get_line called for transformation IR node (p_line = %d) \n",p_line);
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
          if ( isCompilerGenerated() == true )
             {
            // DQ (6/14/2005): Temp code to permit identification of line number of template declaration!
               returnValue = undefinedValue;
             }
            else
             {
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h 
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
            // if (isFrontendSpecific() == true || isSourcePositionUnavailableInFrontend() == true )
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    if (file_id == this->get_physical_file_id())
                       {
                         returnValue = p_line;
                       }
                      else
                       {
                      // SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),this->get_physical_file_id());
                         SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),file_id);
                         if (pos != p_fileIDsToUnparse.end())
                            {
#if 0
                              mprintf ("Sg_File_Info::get_line(int): input file is sharing this IR node: input file_id = %d physical_file_id = %d \n",file_id,this->get_physical_file_id());
#endif
                              ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                              ROSE_ASSERT(index >= 0);
                              ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
                              ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
#if 0
                              mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                              ROSE_ASSERT(file_id == p_fileIDsToUnparse[index]);
                              returnValue = p_fileLineNumbersToUnparse[index];
#if 0
                              mprintf (" --- returning returnValue = %d \n",returnValue);
#endif
                            }
                           else
                            {
                           // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                           // This is a reasonable default, if we don't want to make this an error.

                              returnValue = p_line;
                            }
                       }
                  }
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }


int
Sg_File_Info::get_raw_line() const
   {
     assert (this != NULL);
     return p_line;
   }

void
Sg_File_Info::set_physical_line(int line)
   {
     assert (this != NULL);
     p_physical_line = line;
   }

int
Sg_File_Info::get_physical_line(int file_id) const
   {
     assert (this != NULL);

     int returnValue = 0;

  // DQ (2/28/2019): Physical source position information is not supported for Fortran yet (not debugged at least).
     if (SageInterface::is_Fortran_language() )
        {
          returnValue = Sg_File_Info::get_line();
        }
       else
        {
       // returnValue = p_physical_line;
          if (file_id == this->get_physical_file_id())
             {
               returnValue = p_physical_line;
             }
            else
             {
               SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),file_id);
               if (pos != p_fileIDsToUnparse.end())
                  {
#if 0
                    mprintf ("Sg_File_Info::get_physical_line(int): input file is sharing this IR node: input file_id = %d physical_file_id = %d \n",file_id,this->get_physical_file_id());
#endif
                    ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                    ROSE_ASSERT(index >= 0);
                    ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
                    ROSE_ASSERT(p_fileLineNumbersToUnparse.size() == p_fileIDsToUnparse.size());
#if 0
                    mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                    ROSE_ASSERT(file_id == p_fileIDsToUnparse[index]);
                    returnValue = p_fileLineNumbersToUnparse[index];
#if 0
                    mprintf (" --- returning returnValue = %d \n",returnValue);
#endif
                  }
                 else
                  {
                 // This case means that the file_id provided was incorrect, the IR node is not shared with that file.
                 // This is a reasonable default, if we don't want to make this an error.

                    returnValue = p_physical_line;
                  }
             }
        }

     return returnValue;
   }

int
Sg_File_Info::get_physical_line() const
   {
     assert (this != NULL);
     // PHL (11/25/2013) use get_line for Fortran frontend
     if (SageInterface::is_Fortran_language() )
     {
       return Sg_File_Info::get_line();
     }else{
       return p_physical_line;
     }
   }

// DQ (1/23/2013): Added source position sequence information.
// This work supports the handling of default arguments and addes
// new future capabilities to ROSE.
void
Sg_File_Info::set_source_sequence_number (unsigned int n)
   {
     assert (this != NULL);
     p_source_sequence_number = n;
   }

unsigned int
Sg_File_Info::get_source_sequence_number() const
   {
     assert (this != NULL);
     return p_source_sequence_number;
   }

int
Sg_File_Info::get_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
  // return p_col;

  // const int undefinedValue = INT_MAX-1;
     const int undefinedValue = 0;
     int returnValue = 0;
     if (isTransformation() == true)
        {
       // mprintf ("Sg_File_Info::get_col called for transformation IR node \n");
          returnValue = undefinedValue;
        }
       else
        {
       // DQ (8/17/2005): only undefinedValue when compiler generate (not when marked for output)
       // if ( isCompilerGenerated() == true || isCompilerGeneratedNodeToBeUnparsed() == true )
          if ( isCompilerGenerated() == true )
             {
            // mprintf ("Sg_File_Info::get_col called for compiler generated IR node \n");
               returnValue = undefinedValue;
             }
            else
             {
#if 0
            // DQ (3/18/2017): Original code.
               returnValue = p_col;
#else
            // DQ (3/18/2017): Add to the cases where we want to output an undefined value.
            // I think it is helpful to know the position in the rose_edg_required_macros_and_functions.h 
            // file (so don't output undefined value for case of isFrontendSpecific() == true).
            // if (isFrontendSpecific() == true || isSourcePositionUnavailableInFrontend() == true )
               if ( isSourcePositionUnavailableInFrontend() == true )
                  {
                    returnValue = undefinedValue;
                  }
                 else
                  {
                    returnValue = p_col;
                  }
#endif
             }
        }

     assert (returnValue >= 0);
     return returnValue;
   }

int
Sg_File_Info::get_raw_col() const
   {
     assert (this != NULL);
     assert (p_col >= 0);
     return p_col;
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
void
Sg_File_Info::set_isPartOfTransformation( bool isPartOfTransformation )
   {
     assert (this != NULL);
  // p_isPartOfTransformation = isPartOfTransformation;

     if (isPartOfTransformation == true)
          setTransformation();
       else
          unsetTransformation();
   }

// DQ (5/24/2005): This function is impemented using the newer classification mechanism
bool
Sg_File_Info::get_isPartOfTransformation()
   {
     assert (this != NULL);
  // return p_isPartOfTransformation;
     return isTransformation();
   }

void
Sg_File_Info::register_node(SgLocatedNode* node)
   {} /* register interest */

void
Sg_File_Info::deregister_node(SgLocatedNode* node)
   {}

// functions added by Dan Quinlan (suggested by Gary Lee)
void
Sg_File_Info::set_col( int n )
   {
     assert (this != NULL);
     p_col = n;
     assert (p_col >= 0);
   }

#if 0
int
Sg_File_Info::getCurrentLine () const
   { 
     assert (this != NULL);
     mprintf ("This is a depricated function: char* Sg_File_Info::getCurrentLine() const \n");
     return p_cur_line;
   }
#endif

#if 0
std::string
Sg_File_Info::getCurrentFilename () const
   {
     assert (this != NULL);
     mprintf ("This is a depricated function: char* Sg_File_Info::getCurrentFilename() const \n");
     return p_cur_file;
   }
#endif

bool
Sg_File_Info::hasPositionInSource() const
   {
     assert(this != NULL);
  // DQ (1/11/2006): Modified to not use the output function which mixed 
  // concepts of compiler generated with output (deprecated function).
  // bool result = ( ! ( isTransformation() || isCompilerGenerated() || isCompilerGeneratedNodeToBeUnparsed() ) );
     bool result = ( ! ( isTransformation() || isCompilerGenerated() || isOutputInCodeGeneration() ) );

     return result;
   }

// DQ (9/5/2008): Switched back to using SgFile instead of SgSourceFile.
// bool Sg_File_Info::isSameFile(SgFile* file) const
// bool Sg_File_Info::isSameFile(SgSourceFile* file) const
bool
Sg_File_Info::isSameFile(SgFile* file) const
   {
  // DQ (6/21/2005): check if this file info object is from the same file

  // This function abstracts the mechanism of comparing if a file info object is associated with a specific SgFile.
  // this function will be made more efficient later when we can abstract out the string comparision from the test.
  // Later we will implement a map from filename to unique "file number identifiers", this will permit significant
  // spaces saving in the IR by avoiding redundant storage of filename strings and also improve the efficiency of 
  // testing if two file info objects represent the same file (an integer equality test instead of string comparision).
  // File names are particularly long (since they include full path), so this will allow us to save a lot of space.

     assert(this != NULL);

     assert(file != NULL);

  // MK (7/22/05) : removing use of p_filename in favor of p_file_id
  // Generate names of the files 
     /*
     string inputFilename = file->getFileName();
     string currentFilename = get_filename();

     bool result = (currentFilename == inputFilename);
     */
#if 0
     SgScopeStatement * globalScope = (SgScopeStatement *)(file->get_root());
     assert(globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
#else
  // DQ (9/5/2008): Use the local Sg_File_Info instead of the one on the root (which is only available for a SgSourceFile)
     Sg_File_Info* fileInfo = file->get_startOfConstruct();
#endif
     assert(fileInfo != NULL);

  // DQ (9/17/2013): This function should always refer to physical file data.
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo->get_file_id());
  // bool result = (this->get_file_id() == fileInfo->get_file_id());
     bool result = (this->get_physical_file_id() == fileInfo->get_physical_file_id());

#if 0
     mprintf ("In Sg_File_Info::isSameFile(): \n");
     mprintf ("   --- this->get_physical_file_id()     = %d physical_filename = %s \n",this->get_physical_file_id(),this->get_physical_filename().c_str());
     mprintf ("   --- fileInfo->get_physical_file_id() = %d physical_filename = %s \n",fileInfo->get_physical_file_id(),fileInfo->get_physical_filename().c_str());
#endif

  // DQ (2/27/2019): Adding support for shared IR nodes, so that they can be traversed from AST for each of multiple files.
     if (result == false)
        {
       // Check is this could be a shared file info.
       // if (this->get_fileIDsToUnparse().empty() == false)
          if (p_fileIDsToUnparse.empty() == false)
             {
#if 0
               mprintf ("Sg_File_Info::isSameFile(SgFile*): p_fileIDsToUnparse.size() = %zu \n",p_fileIDsToUnparse.size());
#endif
            // if (find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),fileInfo->get_physical_file_id()) != p_fileIDsToUnparse.end())
               SgFileIdList::const_iterator pos = find(p_fileIDsToUnparse.begin(),p_fileIDsToUnparse.end(),fileInfo->get_physical_file_id());
               if (pos != p_fileIDsToUnparse.end())
                  {
#if 0
                    mprintf ("Sg_File_Info::isSameFile(SgFile*): input file is sharing this IR node: input file_id = %d \n",fileInfo->get_physical_file_id());
#endif
                    ptrdiff_t index = pos - p_fileIDsToUnparse.begin();
                    ROSE_ASSERT(index >= 0);
                    ROSE_ASSERT(index < (ptrdiff_t)p_fileIDsToUnparse.size());
#if 0
                    mprintf (" --- index = %d shared file id = %d \n",(int)index,p_fileIDsToUnparse[index]);
#endif
                 // result = true;
                    result = (fileInfo->get_physical_file_id() == p_fileIDsToUnparse[index]);
#if 0
                    mprintf (" --- returning result = %s \n",result ? "true" : "false");
#endif
                  }
             }
        }

     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(Sg_File_Info* fileInfo) const
   {
     assert(fileInfo != NULL);

  // DQ (9/17/2013): This function should always refer to physical file data.
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo->get_file_id());
  // bool result = (this->get_file_id() == fileInfo->get_file_id());
     bool result = (this->get_physical_file_id() == fileInfo->get_physical_file_id());

     return result;
   }

// DQ (1/18/2006): Added new function with more useful interface.
bool
Sg_File_Info::isSameFile(const Sg_File_Info & fileInfo) const
   {
  // DQ (9/17/2013): This function should always refer to physical file data.
  // DQ (10/27/2007): Make this consistant with new semantics of get_file_id() 
  // bool result = (p_file_id == fileInfo.get_file_id());
  // bool result = (this->get_file_id() == fileInfo.get_file_id());
     bool result = (this->get_physical_file_id() == fileInfo.get_physical_file_id());

     return result;
   }

//! Access functions for classification of File_Info objects
bool
Sg_File_Info::isTransformation() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_transformation);
   }

void
Sg_File_Info::setTransformation()
   {
     assert(this != NULL);
     p_classificationBitField |= e_transformation;
   }

void
Sg_File_Info::unsetTransformation()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_transformation;
   }

bool
Sg_File_Info::isCompilerGenerated() const
   {
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::isCompilerGenerated(): this = %p \n",this);
#endif

     return (p_classificationBitField & e_compiler_generated);
   }

void
Sg_File_Info::setCompilerGenerated()
   {
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::setCompilerGenerated(): this = %p \n",this);
#endif

     p_classificationBitField |= e_compiler_generated;
   }

void
Sg_File_Info::unsetCompilerGenerated()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_compiler_generated;
   }

// bool isCompilerGeneratedNodeToBeUnparsed() const;
bool
Sg_File_Info::isCompilerGeneratedNodeToBeUnparsed() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);

#if 0
  // DQ (6/17/2005): Allow these to be set separately so that setting a whole function to 
  // be unparsed will not make any expecific casts as compiler generated and not required!
  // If casts are the only issue then perhaps they should be marked explicitly as implicit 
  // or explicit (rather than compiler generated).
     bool result = (p_classificationBitField & e_output_in_code_generation);

  // error checking: if e_compiler_generated_node_to_be_unparsed then also e_compiler_generated
     if (result == true)
          assert(isCompilerGenerated() == true);

     return result;
#endif
   }

void
Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);

#if 0
     mprintf ("In Sg_File_Info::setCompilerGeneratedNodeToBeUnparsed(): this = %p \n",this);
#endif

     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetCompilerGeneratedNodeToBeUnparsed()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation; 
   }

bool
Sg_File_Info::isOutputInCodeGeneration() const
   {
  // Make sure that both bits are set!
     assert(this != NULL);
     return (p_classificationBitField & e_output_in_code_generation);
   }

void
Sg_File_Info::setOutputInCodeGeneration()
   {
  // Make sure that both bits are set!
  // setCompilerGenerated();
     assert(this != NULL);

#if 0
     mprintf ("In setOutputInCodeGeneration(): this = %p parent = %p \n",this,this->get_parent());
#endif

  // DQ (5/19/2013): Testing...debugging test2013_171.C.
  // ROSE_ASSERT(isSgNamespaceDefinitionStatement(this->get_parent()) == NULL);

     p_classificationBitField |= e_output_in_code_generation;
   }

void
Sg_File_Info::unsetOutputInCodeGeneration()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_output_in_code_generation;
   }

bool
Sg_File_Info::isShared() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_shared);
   }

void
Sg_File_Info::setShared()
   {
  // MK (8/3/05) : We always want to unparse the current file (this is a performance issue)
     assert(this != NULL);
  // DQ (10/27/2007): Make sure this is a valid file that we are trying to share.
  // I am unclear as to how important this is.
     int temp_file_id = this->get_file_id();
     if (temp_file_id < 0)
        {
          if (SgProject::get_verbose() > 0)
               mprintf ("Warning: trying to share file id = %d < 0 \n",temp_file_id);
        }

#if 0
  // DQ (2/27/2019): Disable this since it conflicts with using this as a mechanism to support additional files to support.
     if (isShared() == false)
        {
          p_fileIDsToUnparse.push_back(p_file_id);
        }
#endif

     p_classificationBitField |= e_shared;
   }

void
Sg_File_Info::unsetShared()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_shared;

#if 0
  // DQ (2/27/2019): Disable this since it conflicts with using this as a mechanism to support additional files to support.
  // MK (8/2/05) : Initialize the fileid set
     p_fileIDsToUnparse.clear();
#endif
   }

bool
Sg_File_Info::isFrontendSpecific() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_frontend_specific);
   }

void
Sg_File_Info::setFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField |= e_frontend_specific;
   }

void
Sg_File_Info::unsetFrontendSpecific()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_frontend_specific;
   }

bool
Sg_File_Info::isSourcePositionUnavailableInFrontend() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_source_position_unavailable_in_frontend);
   }

void
Sg_File_Info::setSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField |= e_source_position_unavailable_in_frontend;

#if 0
  // DQ (8/3/2012): We don't want to use this unless absolutely required; so output a message to support debugging.
     mprintf ("In Sg_File_Info::setSourcePositionUnavailableInFrontend() \n");
#endif
   }

void
Sg_File_Info::unsetSourcePositionUnavailableInFrontend()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_source_position_unavailable_in_frontend;

#if 0
  // DQ (8/3/2012): We don't want to use this unless absolutely required; so output a message to support debugging.
     mprintf ("In Sg_File_Info::unsetSourcePositionUnavailableInFrontend() \n");
#endif
   }

bool
Sg_File_Info::isCommentOrDirective() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_comment_or_directive);
   }

void
Sg_File_Info::setCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField |= e_comment_or_directive;
   }

void
Sg_File_Info::unsetCommentOrDirective()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_comment_or_directive;
   }

bool
Sg_File_Info::isToken() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_token);
   }

void
Sg_File_Info::setToken()
   {
     assert(this != NULL);
     p_classificationBitField |= e_token;
   }

void
Sg_File_Info::unsetToken()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_token;
   }

// DQ (4/24/2013): Added support for marking as default argument.  Note that compiler generated is not specific 
// enough because even implicit casts would then be confused as default arguments.
bool
Sg_File_Info::isDefaultArgument() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_default_argument);
   }

void
Sg_File_Info::unsetDefaultArgument()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_default_argument;
   }

void
Sg_File_Info::setDefaultArgument()
   {
     assert(this != NULL);
     p_classificationBitField |= e_default_argument;
   }

// DQ (4/26/2013): Added support for marking as implicit casts.  Note that compiler generated is not 
// as specific as we want (though it has worked for a long time, we want a more precise mechanism).
bool
Sg_File_Info::isImplicitCast() const
   {
     assert(this != NULL);
     return (p_classificationBitField & e_implicit_cast);
   }

void
Sg_File_Info::unsetImplicitCast()
   {
     assert(this != NULL);
     p_classificationBitField &= ~e_implicit_cast;
   }

void
Sg_File_Info::setImplicitCast()
   {
     assert(this != NULL);
     p_classificationBitField |= e_implicit_cast;
   }




// MK (8/2/05) : Implementation for function to handle unparsing of particular files
void
Sg_File_Info::addFileToUnparse(int file_id)
   { 
     assert(this != NULL);

#if 1
  // DQ (2/27/2019): Debugging how this is getting out of sync with the list of line numbers for multi-file handling.
     mprintf ("Error: In Sg_File_Info::addFileToUnparse(): I think this function should not be called \n");
     ROSE_ASSERT(false);
#endif

     p_fileIDsToUnparse.push_back(file_id);
   }

bool
Sg_File_Info::shouldUnparse(int file_id)
   {
     assert(this != NULL);
     return std::find(p_fileIDsToUnparse.begin(), p_fileIDsToUnparse.end(), file_id) != p_fileIDsToUnparse.end();
   }

unsigned int
Sg_File_Info::get_classificationBitField(void) const
   {
     assert(this != NULL);
     return p_classificationBitField;
   }

void
Sg_File_Info::set_classificationBitField( unsigned int bitflags )
   {
     assert(this != NULL);
     p_classificationBitField = bitflags;
   }

// MK (8/2/05): Added implementations for static functions to support interface to fileid maps
const string&
Sg_File_Info::getFilenameFromID(int id)
   {
  // This is a static function

     const std::string* name = NULL;
     switch(id)
        {
       // special cases
          case NULL_FILE_ID:
             {
               static const std::string null_file_string =  "NULL_FILE";
               name = &null_file_string;
               break;
             }
          case COPY_FILE_ID:
             {
               static const std::string copy_file_string  = "COPY";
               name = &copy_file_string;
               break;
             }
          case TRANSFORMATION_FILE_ID:
             {
               static const std::string transformation_string = "transformation";
               name = &transformation_string;
               break;
             }
          case COMPILER_GENERATED_FILE_ID:
             {
               static const std::string compilerGenerated_string = "compilerGenerated";
               name = &compilerGenerated_string;
               break;
             }
          case COMPILER_GENERATED_MARKED_FOR_OUTPUT_FILE_ID:
             {
            // name = "compilerGenerated";
               mprintf ("The concept of COMPILER_GENERATED and OUTPUT are now decoupled, so make this an error \n");
               assert(false);
               break;
             }
          case BAD_FILE_ID:
             {
               static const std::string badfile_string = "badfile";
               name = &badfile_string;
               break;
             }

       // normal case
          default:
             {
            // assert that the id is present in the map (else error)
            // assert(p_fileidtoname_map.count(id) != 0);
               bool failure = (p_fileidtoname_map.count(id) == 0);
               if (failure == true)
                  {
                    mprintf ("Error: bad id number for file id (id = %d) \n",id);

                    display_static_data("error in getFilenameFromID");

                 // Note: this causes an empty entry to be generated in p_fileidtoname_map for the id == p_max_file_id (value of max map size)
                 // std::cout << p_fileidtoname_map[id] << std::endl;
                 // mprintf ("Error: bad id number for file id (id = %d) \n",id);
                  }
               ROSE_ASSERT(failure == false);

            // get the filename from the map using the valid id
               name = &p_fileidtoname_map[id];
             }
        }

     return *name;
   }

int
Sg_File_Info::getIDFromFilename( std::string filename )
   {
  // This is a static function
#if 1
  // DQ (10/22/2007): Should this be commented out?

#if 0
     mprintf ("In Sg_File_Info::getIDFromFilename(): filename = %s \n",filename.c_str());
#endif

     if (p_nametofileid_map.count(filename) == 0)
        {
#if 0
          mprintf ("In Sg_File_Info::getIDFromFilename(): p_nametofileid_map.count(filename) == 0 \n");
          mprintf ("   --- filename = %s \n",filename.c_str());
#endif

          return BAD_FILE_ID;
        }
#endif

     return p_nametofileid_map[filename];
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<int, std::string> & 
Sg_File_Info::get_fileidtoname_map()
   {
     return p_fileidtoname_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_fileidtoname_map(std::map<int, std::string> & X)
   {
     p_fileidtoname_map = X;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
std::map<std::string, int> &
Sg_File_Info::get_nametofileid_map()
   {
     return p_nametofileid_map;
   }

// DQ (2/24/2010): These are static access functions where previously the ROSETTA generated ones were not static functions.
void
Sg_File_Info::set_nametofileid_map(std::map<std::string,int> & X)
   {
     p_nametofileid_map = X;
   }

#if 0
// DQ (2/27/2019): Adding support for access function to list of fileIds and line numbers associated with 
// support for multi-file sharing of IR nodes and the support to know there source position information 
// from each file.
const SgFileIdList &
Sg_File_Info::get_fileIDsToUnparse () const
   {
     ROSE_ASSERT (this != NULL);
     return p_fileIDsToUnparse;
   }

// DQ (2/27/2019): Adding support for access function to list of fileIds and line numbers associated with 
// support for multi-file sharing of IR nodes and the support to know there source position information 
// from each file.
// Note that we don't build a "set" function since the return by reference allows the operator= to be called
SgFileIdList &
Sg_File_Info::get_fileIDsToUnparse () 
   {
     ROSE_ASSERT (this != NULL);

  // DQ (4/14/2015): After discussion with Markus we agree that even non-const functions should not
  // have to set the isModified flag. As a rule only set_ access functions can set the isModified flag.
  // set_isModified(true);

     return p_fileIDsToUnparse;
   }
#endif

SOURCE_FILE_INFORMATION_END


SOURCE_APPLICATION_FILE_START

// DQ (5/23/2015): Add static data member declaration.
bool SgFile::p_skip_unparse_asm_commands = false;

// std::string SgFile::get_outputLanguageOptionName ( SgFile::outputLanguageOption_enum lang )
std::string
SgFile::get_outputLanguageOptionName ( SgFile::languageOption_enum lang )
   {
     string s;
     switch (lang)
        {
          case SgFile::e_error_language:   s = "error";   break;
          case SgFile::e_default_language: s = "default"; break;
          case SgFile::e_C_language:       s = "C";       break;
          case SgFile::e_Cxx_language:     s = "C++";     break;
          case SgFile::e_Binary_language:  s = "Binary";  break;
          case SgFile::e_Fortran_language: s = "Fortran"; break;
          case SgFile::e_Java_language:    s = "Java";    break;
          case SgFile::e_X10_language:     s = "X10";     break;
          case SgFile::e_PHP_language:     s = "PHP";     break;
          case SgFile::e_Python_language:  s = "Python";  break;
          case SgFile::e_Csharp_language:  s = "Csharp";  break;
          case SgFile::e_Ada_language:     s = "Ada";     break;
          case SgFile::e_Jovial_language:  s = "Jovial";  break;
          case SgFile::e_Cobol_language:   s = "Cobol";   break;
          case SgFile::e_Promela_language: s = "Promela"; break;

          default:
             {
               mprintf ("In SgFile::outputLanguageOption(): lang = %" PRIuPTR " \n",(size_t)lang);
            // mprintf ("In SgFile::outputLanguageOption(): lang = %d \n",lang);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

int SgFile::buildAST( std::vector<std::string> argv, std::vector<std::string> inputCommandLine )
   {
     mprintf ("Base class of virtual function, SgFile::buildAST(), called by mistake! \n");
     ROSE_ASSERT(false);

  // tps (12/11/2009): Windows error : needs a return value
     return 0;
   }

Sg_File_Info*
SgFile::get_file_info() const
   {
  // This redefines get_file_info() as it is implemented for a SgLocatedNode 
  // to use the "get_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     return get_startOfConstruct();
   }

void
SgFile::set_file_info( Sg_File_Info* fileinfo )
   {
  // This redefines set_file_info() as it is implemented for a SgLocatedNode 
  // to use the "set_startOfConstruct()" for consistancy with SgLocatedNode IR nodes.
     set_startOfConstruct(fileinfo);
   }

std::string
SgFile::getFileName () const
   {
  // Get the filename from the Sage III file object

     assert(this != NULL);

  // assert(get_fileInfo() != NULL);
#if 0
  // DQ (9/4/2008): Moved the global scope to the new SgSourceFile IR node.
     SgScopeStatement *globalScope = (SgScopeStatement *)(&(root()));
     assert (globalScope != NULL);
     Sg_File_Info* fileInfo = globalScope->get_file_info();
#else
     Sg_File_Info* fileInfo = p_startOfConstruct;
#endif
     assert (fileInfo != NULL);

#if 0
  // Original code
     std::string fileName = fileInfo->get_filenameString();
#else

#if 0
     mprintf ("In SgFile::getFileName(): using the raw (uninterpreted) filename instead! \n");
#endif

#if 0
  // DQ (8/15/2018): I think we want to original physical filename. since if it is transformed 
  // as a file we don't what the name "transformation".
     std::string fileName = fileInfo->get_physical_filename();
#else
  // DQ (8/16/2018): I think we want to original filename as constructed and reported by the 
  // get_raw_filename() function, since if the statement is transformed as a file we don't what 
  // the name "transformation".
     std::string fileName = fileInfo->get_raw_filename();
#endif
#endif

     return fileName;
   }

// function prototype
ROSEAttributesListPtr getPreprocessorDirectives( char *fileName);

// DQ (2/3/2004): Debugging segfault in use of il_header within ROSE
// #include "sageCommonSourceHeader.h"
// extern an_il_header il_header;

// Moved to sage_support.cpp: void SgFile::setupSourceFilename ( const vector<string>& argv )
// Moved to sage_support.cpp: void SgFile::doSetupForConstructor(const vector<string>& argv, int& errorCode, int fileNameIndex, SgProject* project)

SgFile::SgFile ( int & argc, char** & argv , SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     assert (argv && argc >= 0);

  // Note use of pointer arithmetic in the computation of "argv + argc", this is standard STL fair.
     doSetupForConstructor(vector<string>(argv, argv + argc),  project);
   }

SgFile::SgFile ( vector<string> & argv ,  SgProject* project )
// : p_numberOfCommandLineArguments(argc) , p_commandLineArgumentList(NULL)
   {
  // This constructor actually makes the call to EDG to build the AST (via callFrontEnd()).
     doSetupForConstructor(argv,  project);
   }


// DQ (1/17/2006): Added this (copy constructor) to be explicit 
// and avoid difficult bugs where it is compiler generated.
SgFile::SgFile ( const SgFile & X )
   {
     mprintf ("Error: calling private copy constructor! \n");
     ROSE_ASSERT(false);
   }

#include "Disassembler.h"

void
SgFile::initialization()
   {
     assert(this != NULL);

     p_verbose                 = 0;
  // version                   = false;
  // help                      = false;

  // DQ (12/8/2007): use "-Wall" to control output of warnings
     p_output_warnings         = false;

  // DQ (7/13/2004): Not previously initialized!
     p_C_only                  = false;
     p_upc_threads             = 0;

     p_Cxx_only                = false;

  // DQ (8/11/2007): Added support for Fortran
     p_Fortran_only            = false;

  // DQ (1/23/2009): Added CoArray Fortran support.
     p_CoArrayFortran_only     = false;

     p_PHP_only                = false;

     p_Python_only             = false;

  // DQ (8/25/2017): Added more language support.
     p_Csharp_only             = false;
     p_Ada_only                = false;
     p_Jovial_only             = false;
     p_Cobol_only              = false;

     p_requires_C_preprocessor = false;

  // DQ (2/5/2009): Putting this back now, so we have one at the SgProject and one at the SgFile.
  // DQ (2/4/2009): This was moved to the SgProject
     p_binary_only             = false;

  // DQ (2/5/2009): Support binary analysis of object files.
     p_isObjectFile            = false;

     p_inputFormat             = SgFile::e_unknown_output_format;
     p_outputFormat            = SgFile::e_unknown_output_format;
     p_backendCompileFormat    = SgFile::e_unknown_output_format;
     p_fortran_implicit_none   = false;
     p_openmp                  = false;
     p_openmp_parse_only       = true;
     p_openmp_ast_only         = false;
     p_openmp_lowering         = false;

  // DQ (12/8/2007): Added commandline support for cray pointers.
     p_cray_pointer_support = false;

  // DQ (12/11/2007): Added to support debugging of Fortran support in ROSE using OFP.
     p_output_parser_actions = false;

  // DQ (12/11/2007): Added to support debugging of Fortran support in ROSE using OFP.
     p_exit_after_parser = false;

     p_skip_parser = false;

  // DQ (1/4/2008): gFortran versions greater than 4.1 have bugs that prevent it from 
  // being used to to syntax checking on Fortran 2003 applications.  To allow Fortran
  // 2003 applications to be processed the syntax checking step done in ROSE using
  // that backend compiler (typically gfortran) needs to be skipped.  ROSE it self can
  // handle the Fortran 2003 code, but can not yet do sufficent syntax checking to
  // report errors in illegal Fortran 2003 code.
     p_skip_syntax_check = false;

  // After higher level ASTs are build optionally apply transformations
     p_skip_transformation     = false;
     p_skip_unparse            = false;

  // DQ (11/1/2011): Added support to skip translation of EDG AST to ROSE AST.
     p_skip_translation_from_edg_ast_to_rose_ast = false;

#if 1
  // The default should be to act like a C++ compiler
     p_skipfinalCompileStep    = false;
#else
     p_skipfinalCompileStep    = true;
#endif

  // p_new_unparser            = true;   // by default use the new unparser
     p_unparse_includes        = false;  // by default do NOT unparse include files into the source code
     p_unparse_line_directives = false;  // by default do NOT unparse #line directives into the source code

  // DQ (4/14/2013): Added options to permit selection of either overloaded operator names or use of operator syntax 
  // for function calls in the unparsed code.  The default is to reproduce the same use as in the input code.
     p_unparse_function_calls_using_operator_syntax = false;
     p_unparse_function_calls_using_operator_names  = false;

  // DQ (8/30/2008): Added support to tailor the unparsing of disassembled instructions and the binary file format.
     p_unparse_instruction_addresses = true;
     p_unparse_raw_memory_contents   = true;
     p_unparse_binary_file_format    = true;

  // DQ (8/27/2007): Support for alternative langauge code generation (unparsing), useful for testing specific language unparsers.
     p_outputLanguage          = SgFile::e_default_language;

     p_standard = e_default_standard;
     p_gnu_standard = false;

  // initialize p_useBackendOnly data member
     p_useBackendOnly = false;

     p_compileOnly             = false;

  // DQ (6/21/2005): initialize g++ specific template instantiation control flags
     p_no_implicit_templates        = false;
     p_no_implicit_inline_templates = false;

  // Added to permit all comments and CPP directives to be skipped (e.g. when unparsing all hearders)
     p_skip_commentsAndDirectives      = false;

  // DQ (4/19/2006): Added to control comment and directive handling (takes more time to process header files).
     p_collectAllCommentsAndDirectives = false;

  // negara1 (07/08/2011): Added to control whether header files should be unparsed.
     p_unparseHeaderFiles = false;

  // At construction this is a NULL pointer, it is updated later after construction of the AST.
     p_preprocessorDirectivesAndCommentsList = NULL; // new ROSEAttributesListContainer();
  // assert (p_preprocessorDirectivesAndCommentsList != NULL);
     assert (p_preprocessorDirectivesAndCommentsList == NULL);

  // DQ (4/10/2006): Removed in favor of implementation at SgNode using
  // a pointer and the interface represented directly at the SgNode
  // DQ (1/13/2006): Initialize new AstAttributeMechanism pointer (moved from SgNode)
     p_attributeMechanism = NULL;

     p_KCC_frontend            = false;

  // Alternatively we can call the new edg frontend to test the edg process
     p_new_frontend            = false;

  // controls call to the edg_main (disables all processing
  // and acts like a shell which calls the compiler)
     p_disable_edg_backend     = false;

  // Disable parsing of the EDG program tree into the SAGE program tree
     p_disable_sage_backend    = false;

  // Shorthand form for different levels of testing  (default is -1)
     p_testingLevel            = -1;

  // enable processing specific to templates
     p_preinit_il              = false;
     p_enable_cp_backend       = false;

  // p_outputGrammarTreeFiles  = false;  // default should be false (set to true while debugging)
  // p_outputGrammarTreeFilesForHeaderFiles = false; // default is to skip headers

  // Support for faster processing of pdf output (where we likely don't need the pdf output of the the EDG AST)
  // p_outputGrammarTreeFilesForEDG = false;

  // DQ (9/5/2006): Added mechanism to optionally watermark files generated by ROSE
     p_markGeneratedFiles = false;

  // DQ (9/19/2006): Allow testing of ROSE using input that is expected to fail (return passed if test failed)
     p_negative_test = false;

  // DQ (9/24/2006): Permit optional enforcement of ANSI standards
     p_strict_language_handling = false;
     
  // AS (9/29/2008): Use Wave 
     p_wave = false;

  // DQ (10/31/2006): Output information that can be used to colorize properties of generated code (useful for debugging).
     p_embedColorCodesInGeneratedCode = 0;

  // DQ (10/31/2006): Output separate file containing source position information for highlighting (useful for debugging).
     p_generateSourcePositionCodes = 0;

  // DQ (12/2/2006): This we be used (as in GNU) to set the languge mode (C++ files will turn on C++ language mode 
  // and only ".c" (C files) will turn on C language mode).
     p_sourceFileUsesCppFileExtension = false;

  // DQ (12/11/2007): Added default initialization of these values
     p_sourceFileUsesFortranFileExtension     = false;
     p_sourceFileUsesFortran77FileExtension   = false;
     p_sourceFileUsesFortran90FileExtension   = false;
     p_sourceFileUsesFortran95FileExtension   = false;
     p_sourceFileUsesFortran2003FileExtension = false;

  // DQ (1/23/2009): Added support for Co-Array Fortran (file extensions)
     p_sourceFileUsesCoArrayFortranFileExtension = false;     

     p_sourceFileUsesPHPFileExtension = false;

  // DQ (10/11/2010): Adding Java support.
     p_sourceFileUsesJavaFileExtension = false;

     p_sourceFileUsesBinaryFileExtension = false;

  // This will cause only the binary file format to be read and skipps instruction disassembly
     p_read_executable_file_format_only = false;

  // DQ (11/11/2008): Added to support visualization of only parts of the AST.
  // this will cause attributes to be added to IR nodes that will be skipped 
  // in the generation of DOT files.  This is helpful for debugging and in 
  // tutorial examples/presentations.
     p_visualize_executable_file_format_skip_symbols = false;

     p_visualize_dwarf_only      = false;

  // DQ (5/23/2015): This has been modified to be a static data member (for details see comments in ROSETTA/src/support.C).
  // I am not clear if static variables should be set in this function (but it appears that other static variables are
  // set there and if not here then where should they be set, unless we build a static initialization phase for code
  // generated by ROSETTA (which does not presently exist).
     p_skip_unparse_asm_commands = false;

     p_read_instructions_only    = false;

  // DQ (11/20/2010): Support for token handling.
     p_unparse_tokens = false;

  // DQ (1/30/2014): Support for testing of token unparsing.
     p_unparse_tokens_testing = 0;

  // DQ (11/12/2014): Addded to support test modes for token unparsing.
     p_unparse_using_leading_and_trailing_token_mappings = false;

  // DQ (9/26/2011): This was not initialized previosuly so I have added it.
     p_sourceFileTypeIsUnknown = false;

  // DQ (9/26/2011): New support for option to specify debugging support in ROSE to 
  // detect dangling pointers to IR nodes as part of the AST Consistancy tests. At 
  // some point this will default to always being on as an AST consistancy test.
     p_detect_dangling_pointers = 0;

  // DQ (2/17/2013): This permits skipping the AST consistancy test if the AstTests::runAllTests() 
  // function is called as part of the user's translator.
     p_skipAstConsistancyTests = false;

  // DQ (6/7/2013): Added support for using experimental fortran frontend.
  // Rasmussen (3/12/2018): Added support for CUDA Fortran within the experimental fortran frontend.
     p_experimental_fortran_frontend = false;
     p_experimental_cuda_fortran_frontend = false;

  // DQ (1/23/2016): Added support for OFP parsing and pretty printing of generated Aterm
  // (this is part of the internal testing of the new (experimental) Fortran support).
     p_experimental_fortran_frontend_OFP_test = false;

  // DQ (4/17/2015): Adding multifile handling support for commandline generation.
     p_multifile_support = false;

  // DQ (5/24/2015): Record if optimization was specified on the command line.
     p_optimization = false;

  // DQ (12/11/2015): Option to use the token stream mapping and local tests of the 
  // token sequence, to improve the source position information stored in the AST.
     p_use_token_stream_to_improve_source_position_info = false;

  // DQ (12/23/2015): Suppress variable declaration normalizations
     p_suppress_variable_declaration_normalization = false;

  // Matzke (12/05/2016): Added missing initialization
     p_frontendErrorCode = 0;
     p_unparserErrorCode = 0;
     p_midendErrorCode= 0; // Liao, 4/26/2017 add midend error code
     p_backendCompilerErrorCode = 0;

  // DQ (9/19/2019): Added these missing variable initializations.
     p_edg_il_to_graphviz                      = false;
     p_no_optimize_flag_for_frontend           = false;
     p_unparse_edg_normalized_method_ROSE_1392 = false;

  // DQ (9/19/2019): Support optimizations of header file unparsing (specifically restricting 
  // the number of header files for which we collect comments and CPP directives).
     p_header_file_unparsing_optimization             = false;
     p_header_file_unparsing_optimization_source_file = false;
     p_header_file_unparsing_optimization_header_file = false;
   }

#if 0
// DQ (9/4/2008): This is now in SgSourceFile (and built using ROSETTA with a different name)
SgGlobal &
SgFile::root() ROSE_DEPRECATED_FUNCTION
   {
     assert(p_root != NULL);
     return *p_root;
   }
#endif

#if 0
// DQ (7/19/2005): Added to support better naming of global scope (root is not very clear)
// get_root() set_root() and root() will be depricated.
SgGlobal*
SgFile::get_globalScope() const
   {
  // This variable name will be changed in the future (to globalScope)
     assert(p_root != NULL);
     return p_root;
   }
#endif

#if 0
// DQ (5/9/2008): Added to support for previous variable name for some backward compatability.
SgGlobal*
SgSourceFile::get_root() const
   {
  // This variable name will be changed in the future (to globalScope)
     assert(p_globalScope != NULL);
     return p_globalScope;
   }
#endif

enum SgFile::standard_enum SgFile::get_standard(void) const { return p_standard; }
void SgFile::set_standard(enum standard_enum e_std) { p_standard = e_std; }
void SgFile::set_default_standard(void) { p_standard = e_default_standard; }

// DQ (1/10/2019): Add way to output a string to report standard in debug messages.
std::string SgFile::display_standard(enum standard_enum e_std)
   {
     string s;

     switch (e_std)
        {
          case e_default_standard: s = "e_default_standard"; break;
          case e_c89_standard: s = "e_c89_standard"; break;
          case e_c90_standard: s = "e_c90_standard"; break;
          case e_c99_standard: s = "e_c99_standard"; break;
          case e_c11_standard: s = "e_c11_standard"; break;
          case e_c14_standard: s = "e_c14_standard"; break;
          case e_c18_standard: s = "e_c18_standard"; break;
          case e_upc_standard: s = "e_upc_standard"; break;
          case e_cxx98_standard: s = "e_cxx98_standard"; break;
          case e_cxx03_standard: s = "e_cxx03_standard"; break;
          case e_cxx11_standard: s = "e_cxx11_standard"; break;
          case e_cxx14_standard: s = "e_cxx14_standard"; break;
          case e_cxx17_standard: s = "e_cxx17_standard"; break;
          case e_cxx20_standard: s = "e_cxx20_standard"; break;
          case e_upcxx_standard: s = "e_upcxx_standard"; break;
          case e_f77_standard: s = "e_f77_standard"; break;
          case e_f90_standard: s = "e_f90_standard"; break;
          case e_f95_standard: s = "e_f95_standard"; break;
          case e_f03_standard: s = "e_f03_standard"; break;
          case e_f08_standard: s = "e_f08_standard"; break;
          case e_f18_standard: s = "e_f18_standard"; break;

          default:
             {
               printf ("Error default reached in switch: SgFile::display_standard(): e_std = %x \n",e_std);
               ROSE_ASSERT(false);
             }
        }

     return s;
   }

bool SgFile::is_gnu_standard(void) const { return p_gnu_standard; }
void SgFile::set_gnu_standard(void) { p_gnu_standard = true; }
void SgFile::unset_gnu_standard(void) { p_gnu_standard = false; }

bool SgFile::get_C89_only (void) const { return p_standard == e_c89_standard; }
void SgFile::set_C89_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c89_standard; }

bool SgFile::get_C89_gnu_only (void) const { return p_standard == e_c89_standard && p_gnu_standard; }
void SgFile::set_C89_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c89_standard; p_gnu_standard = true; }

bool SgFile::get_C90_only (void) const { return p_standard == e_c90_standard; }
void SgFile::set_C90_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c90_standard; }

bool SgFile::get_C90_gnu_only (void) const { return p_standard == e_c90_standard && p_gnu_standard; }
void SgFile::set_C90_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c90_standard; p_gnu_standard = true; }

bool SgFile::get_C99_only (void) const { return p_standard == e_c99_standard; }
void SgFile::set_C99_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c99_standard; }

bool SgFile::get_C99_gnu_only (void) const { return p_standard == e_c99_standard && p_gnu_standard; }
void SgFile::set_C99_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c99_standard; p_gnu_standard = true; }

bool SgFile::get_C11_only (void) const { return p_standard == e_c11_standard; }
void SgFile::set_C11_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c11_standard; }

bool SgFile::get_C11_gnu_only (void) const { return p_standard == e_c11_standard && p_gnu_standard; }
void SgFile::set_C11_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c11_standard; p_gnu_standard = true; }

bool SgFile::get_C14_only (void) const { return p_standard == e_c14_standard; }
void SgFile::set_C14_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c14_standard; }

bool SgFile::get_C14_gnu_only (void) const { return p_standard == e_c14_standard && p_gnu_standard; }
void SgFile::set_C14_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c14_standard; p_gnu_standard = true; }

bool SgFile::get_C18_only (void) const { return p_standard == e_c18_standard; }
void SgFile::set_C18_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c18_standard; }

bool SgFile::get_C18_gnu_only (void) const { return p_standard == e_c18_standard && p_gnu_standard; }
void SgFile::set_C18_gnu_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_c18_standard; p_gnu_standard = true; }

bool SgFile::get_UPC_only (void) const { return p_standard == e_upc_standard; }
void SgFile::set_UPC_only (void) { set_C_only(true); set_Cxx_only(false); p_standard = e_upc_standard; }

bool SgFile::get_Cxx98_only (void) const { return p_standard == e_cxx98_standard; }
void SgFile::set_Cxx98_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx98_standard; }

bool SgFile::get_Cxx98_gnu_only (void) const { return p_standard == e_cxx98_standard && p_gnu_standard; }
void SgFile::set_Cxx98_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx98_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx03_only (void) const { return p_standard == e_cxx03_standard; }
void SgFile::set_Cxx03_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx03_standard; }

bool SgFile::get_Cxx03_gnu_only (void) const { return p_standard == e_cxx03_standard && p_gnu_standard; }
void SgFile::set_Cxx03_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx03_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx11_only (void) const { return p_standard == e_cxx11_standard; }
void SgFile::set_Cxx11_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx11_standard; }

bool SgFile::get_Cxx11_gnu_only (void) const { return p_standard == e_cxx11_standard && p_gnu_standard; }
void SgFile::set_Cxx11_gnu_only (void) {set_C_only(false); set_Cxx_only(true); p_standard = e_cxx11_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx14_only (void) const { return p_standard == e_cxx14_standard; }
void SgFile::set_Cxx14_only (void) {set_C_only(false); set_Cxx_only(true);  p_standard = e_cxx14_standard; }

bool SgFile::get_Cxx14_gnu_only (void) const { return p_standard == e_cxx14_standard && p_gnu_standard; }
void SgFile::set_Cxx14_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx14_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx17_only (void) const { return p_standard == e_cxx17_standard; }
void SgFile::set_Cxx17_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx17_standard; }

bool SgFile::get_Cxx17_gnu_only (void) const { return p_standard == e_cxx17_standard && p_gnu_standard; }
void SgFile::set_Cxx17_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx17_standard; p_gnu_standard = true; }

bool SgFile::get_Cxx20_only (void) const { return p_standard == e_cxx20_standard; }
void SgFile::set_Cxx20_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx20_standard; }

bool SgFile::get_Cxx20_gnu_only (void) const { return p_standard == e_cxx20_standard && p_gnu_standard; }
void SgFile::set_Cxx20_gnu_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_cxx20_standard; p_gnu_standard = true; }

bool SgFile::get_UPCxx_only (void) const { return p_standard == e_upcxx_standard; }
void SgFile::set_UPCxx_only (void) { set_C_only(false); set_Cxx_only(true); p_standard = e_upcxx_standard; }

bool SgFile::get_F77_only     (void) const { return p_standard == e_f77_standard; }
void SgFile::set_F77_only     (void) { set_Fortran_only(true); p_standard = e_f77_standard; }

bool SgFile::get_F90_only     (void) const { return p_standard == e_f90_standard; }
void SgFile::set_F90_only     (void) { set_Fortran_only(true); p_standard = e_f90_standard; }

bool SgFile::get_F95_only     (void) const { return p_standard == e_f95_standard; }
void SgFile::set_F95_only     (void) { set_Fortran_only(true); p_standard = e_f95_standard; }

bool SgFile::get_F2003_only   (void) const { return p_standard == e_f03_standard; }
void SgFile::set_F2003_only   (void) { set_Fortran_only(true); p_standard = e_f03_standard; }

bool SgFile::get_F2008_only   (void) const { return p_standard == e_f08_standard; }
void SgFile::set_F2008_only   (void) { set_Fortran_only(true); p_standard = e_f08_standard; }

bool SgFile::get_F2018_only   (void) const { return p_standard == e_f18_standard; }
void SgFile::set_F2018_only   (void) { set_Fortran_only(true); p_standard = e_f18_standard; }

// int SgFile::compileOutput ( int fileNameIndex, const std::string& compilerName )
int
SgFile::compileOutput ( int fileNameIndex )
   {
  // Compile the output file from the unparing
     vector<string> argv = get_originalCommandLineArgumentList();
     assert(!argv.empty());
   
  // DQ (4/21/2006): I think we can now assert this! This is an unused function parameter!
     assert(fileNameIndex == 0);

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);

  // error checking
     assert (argv.size() > 1);

  // BP : 10/31/2001, strip out any rose options before passing the command line.
     stripRoseCommandLineOptions( argv );

     if (get_C_only() || get_Cxx_only() || get_Fortran_only() )
        {
          stripEdgCommandLineOptions( argv );     
        }

     if (get_Fortran_only())
        {
          stripFortranCommandLineOptions( argv );
        }

  // Call the compile
  // int errorCode = compileOutput ( argv, fileNameIndex, compilerName );
     int errorCode = compileOutput ( argv, fileNameIndex );

  // return the error code from the compilation
     return errorCode;
   }

// function prototype
// void pdfPrintAbstractSyntaxTreeSage ( SgFile & sageFile, bool writeOutHeaderFiles );

#if 0
void
SgFile::outputPDF ()
   {
  // Output the program tree
     mprintf ("In SgFile::outputPDF(): Dumping the program tree (AST) to a file \n");

  // Use Markus's new pdf generator
     AstPDFGeneration pdftest;
     pdftest.generateWithinFile(this);
   }
#endif

#if 0
void
roseDisplayMechanism( SgFile *file )
   {
  // This is the function called by EDG if set using the set_sage_transform_function() 
  // function. We use it to permit the EDG AST to be dumped out to a file.  This
  // step must be done before EDG's AST is deleted and so can't be done when other 
  // Sage/ROSE transformations are done (which is now after the EDG AST is released 
  // under the new (simplified) interface).

  // This function is called at the point where the EDG program tree has already 
  // been parsed into the C++ (modified Sage) grammar but the EDG AST still exists.

#if ROSE_INTERNAL_DEBUG
     if ( file->get_verbose() > 1 )
        {
       // Find out what file we are doing transformations upon
          mprintf ("In roseDisplayMechanism: globalSourceFileName = %s \n",file->getFileName());
        }
#endif

     if (file->get_outputGrammarTreeFiles() == true)
        {
       // Output the program tree
          mprintf ("## Dumping the program tree (AST) to a file ## \n");

       // Permit the AST for the  header files to be output
       // as well (this makes the output files very large)
          bool writeOutHeaderFiles = file->get_outputGrammarTreeFilesForHeaderFiles();

       // Added to speed up processing of large files when we just want the SAGE 3 AST
          bool writeOutEDG_AST = file->get_outputGrammarTreeFilesForEDG();

       // Output the source code file (as represented by the EDG AST) as a PDF file (with bookmarks)
       // Allow this to be off by default since the files generated are so large and most often we just want the SAGE 3 AST
          if (writeOutEDG_AST == true)
               pdfPrintAbstractSyntaxTreeEDG ( file, writeOutHeaderFiles );
            else
               mprintf ("Skipping output of EDG AST in PDF format (EDG output must be turned on explicitly using commandline option) \n");

       // Output the source code file (as represented by the SAGE AST) as a PDF file (with bookmarks)
       // pdfPrintAbstractSyntaxTreeSage ( file, writeOutHeaderFiles );

       // mprintf ("Exiting after testing pdf file output of source code! \n");
       // ROSE_ABORT();
        }
       else
        {
       // mprintf ("## Skip dumping the EDG program tree to a file ## \n");
        }
   }
#endif

// Moved to sage_support.cpp: int  SgFile::callFrontEnd ()
// Moved to sage_support.cpp: void SgFile::stripRoseCommandLineOptions ( vector<string>& argv )
// Moved to sage_support.cpp: void SgFile::processRoseCommandLineOptions ( vector<string> & argv )
// Moved to sage_support.cpp: void SgFile::stripEdgCommandLineOptions ( vector<string> & argv )
// Moved to sage_support.cpp: void SgFile::processBackendSpecificCommandLineOptions ( const vector<string>& argvOrig )
// Moved to sage_support.cpp: bool SgFile::isPrelinkPhase() const

SgProject*
SgFile::get_project()
   {
  // If the project is a parent of the current SgFile then we find it, else return NULL.

     SgNode* parent = get_parent();

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // assert(parent != NULL);

     SgProject* project = NULL;

  // DQ (7/12/2005): The parent is NULL if we have only built a single file (e.g. within the rewrite mechanism)
  // Just return NULL in this case!
     if (parent != NULL)
        {
          project = isSgProject(parent);
          while ( project == NULL && parent->get_parent() != NULL )
             {
               parent = parent->get_parent();
               assert(parent != NULL);
               project = isSgProject(parent);
             }
          assert ( project != NULL );
        }

     return project;
   }

// Moved to sage_support.cpp: void SgFile::build_EDG_CommandLine ( vector<string> & inputCommandLine, vector<string> & argv, int fileNameIndex )
// Moved to sage_support.cpp: void SgFile::usage ( int status )

#ifdef _MSC_VER
#include <direct.h> 	// getcwd()
#endif

 //! get the current directory
string
SgFile::getWorkingDirectory ()
   {
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

// CH (4/8/2010): "direct.h" in MSVC provides getcwd()     
//#ifdef _MSCx_VER
//#pragma message ("WARNING: support for Linux getcwd() unavailable in Microsoft Visual Studio.")
//	 mprintf ("Error: support for Linux getcwd() unavailable in Microsoft Visual Studio.");
//	 assert(false);
//     char* returnString = NULL;
//#else
     char* returnString = getcwd(currentDirectory,maxPathNameLength - 1);
//#endif
     assert (returnString != NULL);
     currentDirectory[maxPathNameLength - 1] = 0; // Just in case

  // The semantics of the getcwd is that these shuld be the same (see if they are)
  // mprintf ("In Rose::getWorkingDirectory: Current directory = %s \n",currentDirectory);
  // mprintf ("In Rose::getWorkingDirectory: Current directory = %s \n",returnString);

  // live with the possible memory leak for now
  // delete currentDirectory;
     currentDirectory = NULL;

     return returnString;
   }

 //! get the source directory
string
SgFile::getSourceDirectory ()
   {
#if 0
     int i = 0;  // index variable declaration

     const int maxPathNameLength = 1024;
     char* currentDirectory = new char [maxPathNameLength];
     for (i=0; i < maxPathNameLength; i++)
          currentDirectory[i] = '\0';  // set to NULL string

     mprintf ("SgFile::getSourceDirectory not implemented! \n");
     ROSE_ABORT();

     return "";
#endif

     string sourceFile = get_sourceFileNameWithPath();
     assert(sourceFile.empty() == false);
     return Rose::StringUtility::getPathFromFileName(sourceFile);
   }


string
SgFile::generateOutputFileName() const
   {
  // DQ (10/16/2005): This function abstracts the generation of an 
  // output file name from the source file name.

     std::string sourceFileName = get_sourceFileNameWithPath();

  // std::string baseFileName    = Rose::utility_stripPathFromFileName(sourceFileName.c_str());
     std::string baseFileName    = Rose::StringUtility::stripPathFromFileName(sourceFileName);

     std::string baseFileNameWithoutSuffix = Rose::StringUtility::stripFileSuffixFromFileName(baseFileName);

  // mprintf ("sourceFileName = %s oldFileName = %s\n",sourceFileName.c_str(),baseFileName.c_str());

     std::string objectFileName;

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);

#if 0
     mprintf ("sourceFileName = %s \n",sourceFileName.c_str());
     mprintf ("baseFileName = %s \n",baseFileName.c_str());
     mprintf ("baseFileNameWithoutSuffix = %s \n",baseFileNameWithoutSuffix.c_str());
#endif

#ifndef USE_ORIGINAL_SOURCE_FILE_NAME_IN_PRELINKING

  // DQ (8/12/2007): I think this was part of the prelinker which is not no longer used!
  // mprintf ("isPrelinkPhase() = %s \n",isPrelinkPhase() ? "true" : "false");
     assert(isPrelinkPhase() == false);

     if (isPrelinkPhase() == true)
        {
       // test for leading "rose_" prefix in name (it should be present)
          assert(baseFileName.find("rose_") == 0);
       // and remove it since we want the unmodified file name to be used as a name of the object file!
          baseFileName.erase(0,5);

       // test for leading "rose_" prefix in name (it should NOT be present now)
          assert(baseFileName.find("rose_") == std::string::npos);
        }
#else

#error "DEAD CODE"

#endif

  // DQ (4/2/2011): Added support for Java.
     if (get_Java_only() == true)
        {
       // Java output files are *.class files.
          objectFileName = baseFileNameWithoutSuffix + ".class";
        }
       else
        {
       // DQ (8/12/2007): Newer simpler code, made possible because of better internal support.  
       // This version is also now language independent and so supports the Fortran work.
          objectFileName = baseFileNameWithoutSuffix + ".o";
        }

  // mprintf ("At base of SgFile::generateOutputFileName(): objectFileName = %s \n",objectFileName.c_str());
  // display("In SgFile::generateOutputFileName()");

     return objectFileName;
   }


// Moved to sage_support.cpp: string SgFile::buildCompilerCommandLineOptions ( vector<string> & argv, int fileNameIndex, const string& compilerName )


// Forward declarations of classes used to control and tailor the code generation.
// class UnparseDelegate;
// class UnparseFormatHelp;

// DQ (3/18/2006): Modified interface to allow specification of pointer to user 
// defined UnparseFormatHelp object (to control code generation).
// DQ (8/20/2005): Removed default parameter from extern function declaration
// extern void unparseFile( SgFile&, UnparseDelegate* repl = NULL );
// Liao (2/8/2008): Removed default parameters due to conflicts with src/backend/unparser/unparser.h
// extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */, SgScopeStatement* unparseScope /* = NULL */);

void
// SgFile::unparse ()
SgFile::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
  // DQ (1/24/2010): This call to the timer has been moved to the unparseFile() function.
  // DQ (7/12/2005): Introduce tracking of performance of ROSE.
  // TimingPerformance timer ("AST Code Generation (unparsing):");

  // mprintf ("Inside of SgFile::unparse () ROSE_DEBUG = %d  \n",ROSE_DEBUG);

  // Not clear if we can or should eliminate this function.
  // mprintf ("This SgFile::unparse() function should no longer be called (I think)! \n");
  // assert(false);

  // Call the unparser mechanism
  // DQ (1/24/2010): Moved the extern declaration for unparseFile() to be local to this function (better code design).
     extern void unparseFile( SgFile* file, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */, SgScopeStatement* unparseScope /* = NULL */);
     unparseFile ( this, unparseFormatHelp, unparseDelegate, NULL );
   }

// Moved to sage_support.cpp: int SgFile::compileOutput ( vector<string>& argv, int fileNameIndex, const string& compilerNameOrig )


// DQ (5/8/2010): Added support to reset the Sg_File_Info (source code position information) 
// to be relative to the generated code instead of the original input code.  This is useful when 
// we want to output references to the position of language constructs in the generated code
// instead of the original input code.  Also useful for building references to locations in 
// automatically generated code.
void
SgFile::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     extern void resetSourcePositionToGeneratedCode( SgFile* file, UnparseFormatHelp *unparseHelp );
     resetSourcePositionToGeneratedCode( this, unparseFormatHelp );
   }

void
SgFile::display ( const std::string & label ) const
   {
  // This function prints out the member data values within the object
     mprintf ("\nIn SgFile::display(%s) \n",label.c_str());

  // DQ (1/17/2006): test this
  // assert(get_fileInfo() != NULL);
#if 0
  // DQ (9/4/2008): Moved p_root to SgSourceFile
     mprintf ("     p_root is %s pointer \n",(p_root != NULL) ? "VALID" : "NULL");
     assert (p_root != NULL);
#endif

  // mprintf ("Output the SgFile::p_file_info object = %p \n",get_file_info());
  // get_file_info()->display("Called from SgFile::display");
     mprintf ("Output the SgFile::p_startOfConstruct object = %p \n",get_startOfConstruct());
     assert (get_startOfConstruct() != NULL);
     get_startOfConstruct()->display("Called from SgFile::display");

     mprintf ("     p_verbose                                   = %s (value=%d) \n",(p_verbose > 1) ? "true" : "false",p_verbose);
     mprintf ("     p_output_warnings                           = %s \n",(p_output_warnings == true) ? "true" : "false");

     mprintf ("     p_C_only()                                  = %s \n",(p_C_only == true)   ? "true" : "false");
     mprintf ("     p_upc_threads                               = %s (value=%d) \n",  (p_upc_threads > 1) ? "true" : "false",p_upc_threads);

  // DQ (3/28/2013): Added support to specify C89 support, so that default can be C99 support (same as EDG3x branch).
     mprintf ("     p_Cxx_only()                                = %s \n",(p_Cxx_only == true) ? "true" : "false");
     mprintf ("     p_Java_only()                               = %s \n",(p_Java_only == true) ? "true" : "false");
     mprintf ("     p_Fortran_only()                            = %s \n",(p_Fortran_only == true) ? "true" : "false");
     mprintf ("     p_CoArrayFortran_only()                     = %s \n",(p_CoArrayFortran_only == true) ? "true" : "false");
     mprintf ("     p_PHP_only()                                = %s \n",(p_PHP_only == true) ? "true" : "false");
     mprintf ("     p_Python_only()                             = %s \n",(p_Python_only == true) ? "true" : "false");

  // DQ (8/25/2017): Added more language support.
     mprintf ("     p_Csharp_only()                             = %s \n",(p_Csharp_only == true) ? "true" : "false");
     mprintf ("     p_Ada_only()                                = %s \n",(p_Ada_only == true) ? "true" : "false");
     mprintf ("     p_Jovial_only()                             = %s \n",(p_Jovial_only == true) ? "true" : "false");
     mprintf ("     p_Cobol_only()                              = %s \n",(p_Cobol_only == true) ? "true" : "false");

     mprintf ("     p_requires_C_preprocessor                   = %s \n",(p_requires_C_preprocessor == true) ? "true" : "false");

  // DQ (2/5/2009): Putting this back now, so we have one at the SgProject and one at the SgFile.
     mprintf ("     p_binary_only()                             = %s \n",(p_binary_only == true) ? "true" : "false");
     mprintf ("     p_isObjectFile()                            = %s \n",(p_isObjectFile == true) ? "true" : "false");

     string inputFormatName;
     switch(p_inputFormat)
        {
          case SgFile::e_unknown_output_format:    inputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: inputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  inputFormatName = "free";  break;

          default:
             {
               mprintf ("Error: default reached p_inputFormat = %d \n",p_inputFormat);
               assert(false);
             }
        }

     mprintf ("     p_inputFormat                               = %s input format \n",inputFormatName.c_str());

     string outputFormatName;
     switch(p_outputFormat)
        {
          case SgFile::e_unknown_output_format:    outputFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: outputFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  outputFormatName = "free";  break;

          default:
             {
               mprintf ("Error: default reached p_outputFormat = %d \n",p_outputFormat);
               assert(false);
             }
        }

     mprintf ("     p_outputFormat                              = %s output format \n",outputFormatName.c_str());

     string backendCompileFormatName;
     switch(p_backendCompileFormat)
        {
          case SgFile::e_unknown_output_format:    backendCompileFormatName = "unknown";    break;
          case SgFile::e_fixed_form_output_format: backendCompileFormatName = "fixed"; break;
          case SgFile::e_free_form_output_format:  backendCompileFormatName = "free";  break;

          default:
             {
               mprintf ("Error: default reached p_backendCompileFormat = %d \n",p_backendCompileFormat);
               assert(false);
             }
        }

     mprintf ("     p_backendCompileFormat                      = %s output format \n",backendCompileFormatName.c_str());

     mprintf ("     p_fortran_implicit_none                     = %s \n",(p_fortran_implicit_none == true) ? "true" : "false");
     mprintf ("     p_openmp                                    = %s \n",(p_openmp == true) ? "true" : "false");
     mprintf ("     p_cray_pointer_support                      = %s \n",(p_cray_pointer_support == true) ? "true" : "false");
     mprintf ("     p_output_parser_actions                     = %s \n",(p_output_parser_actions == true) ? "true" : "false");
     mprintf ("     p_exit_after_parser                         = %s \n",(p_exit_after_parser == true) ? "true" : "false");

     mprintf ("     p_skip_syntax_check                         = %s \n",(p_skip_syntax_check      == true) ? "true" : "false");
     mprintf ("     p_skip_translation_from_edg_ast_to_rose_ast = %s \n",(p_skip_translation_from_edg_ast_to_rose_ast == true) ? "true" : "false");
     mprintf ("     p_skip_transformation                       = %s \n",(p_skip_transformation    == true) ? "true" : "false");
     mprintf ("     p_skip_unparse                              = %s \n",(p_skip_unparse           == true) ? "true" : "false");
     mprintf ("     p_skipfinalCompileStep                      = %s \n",(p_skipfinalCompileStep   == true) ? "true" : "false");

     mprintf ("     p_unparse_includes                          = %s \n",(p_unparse_includes                     == true) ? "true" : "false");
     mprintf ("     p_unparse_line_directives                   = %s \n",(p_unparse_line_directives              == true) ? "true" : "false");

  // DQ (4/14/2013): Added options to permit selection of either overloaded operator names or use of operator syntax 
  // for function calls in the unparsed code.  The default is to reproduce the same use as in the input code.
     mprintf ("     p_unparse_function_calls_using_operator_syntax = %s \n",(p_unparse_function_calls_using_operator_syntax == true) ? "true" : "false");
     mprintf ("     p_unparse_function_calls_using_operator_names  = %s \n",(p_unparse_function_calls_using_operator_names  == true) ? "true" : "false");

     mprintf ("     p_unparse_instruction_addresses             = %s \n",(p_unparse_instruction_addresses        == true) ? "true" : "false");
     mprintf ("     p_unparse_raw_memory_contents               = %s \n",(p_unparse_raw_memory_contents          == true) ? "true" : "false");
     mprintf ("     p_unparse_binary_file_format                = %s \n",(p_unparse_binary_file_format           == true) ? "true" : "false");

     string outputLanguageName = get_outputLanguageOptionName(p_outputLanguage);

     mprintf ("     p_outputLanguage                            = %s output language \n",outputLanguageName.c_str());

     mprintf ("     p_sourceFileNameWithPath                    = %s \n",p_sourceFileNameWithPath.c_str());
     mprintf ("     p_sourceFileNameWithoutPath                 = %s \n",p_sourceFileNameWithoutPath.c_str());
     mprintf ("     p_unparse_output_filename                   = %s \n",p_unparse_output_filename.c_str());

     mprintf ("     p_useBackendOnly                            = %s \n",(p_useBackendOnly == true) ? "true" : "false");
     mprintf ("     p_compileOnly                               = %s \n",(p_compileOnly  == true) ? "true" : "false");

     mprintf ("     p_savedFrontendCommandLine                  = %s \n",p_savedFrontendCommandLine.c_str());

     mprintf ("     p_no_implicit_templates                     = %s \n",(p_no_implicit_templates == true) ? "true" : "false");
     mprintf ("     p_no_implicit_inline_templates              = %s \n",(p_no_implicit_inline_templates == true) ? "true" : "false");
     mprintf ("     p_skip_commentsAndDirectives                = %s \n",(p_skip_commentsAndDirectives == true) ? "true" : "false");
     mprintf ("     p_collectAllCommentsAndDirectives           = %s \n",(p_collectAllCommentsAndDirectives == true) ? "true" : "false");
     mprintf ("     p_unparseHeaderFiles                        = %s \n",(p_unparseHeaderFiles == true) ? "true" : "false");

     mprintf ("     p_preprocessorDirectivesAndCommentsList is %s pointer \n",(p_preprocessorDirectivesAndCommentsList != NULL) ? "VALID" : "NULL");

     mprintf ("     p_KCC_frontend                              = %s \n",(p_KCC_frontend                         == true) ? "true" : "false");
     mprintf ("     p_new_frontend                              = %s \n",(p_new_frontend                         == true) ? "true" : "false");
     mprintf ("     p_disable_edg_backend                       = %s \n",(p_disable_edg_backend                  == true) ? "true" : "false");
     mprintf ("     p_disable_sage_backend                      = %s \n",(p_disable_sage_backend                 == true) ? "true" : "false");
     mprintf ("     p_testingLevel                              = %d \n",p_testingLevel);

     mprintf ("     p_preinit_il                                = %s \n",(p_preinit_il                           == true) ? "true" : "false");
     mprintf ("     p_enable_cp_backend                         = %s \n",(p_enable_cp_backend                    == true) ? "true" : "false");

#if 0
     mprintf ("     p_outputGrammarTreeFiles                    = %s \n",(p_outputGrammarTreeFiles               == true) ? "true" : "false");
     mprintf ("     p_outputGrammarTreeFilesForHeaderFiles      = %s \n",(p_outputGrammarTreeFilesForHeaderFiles == true) ? "true" : "false");
     mprintf ("     p_outputGrammarTreeFilesForEDG              = %s \n",(p_outputGrammarTreeFilesForEDG  == true) ? "true" : "false");
#endif

     mprintf ("     p_markGeneratedFiles                        = %s \n",(p_markGeneratedFiles == true) ? "true" : "false");
     mprintf ("     p_negative_test                             = %s \n",(p_negative_test == true) ? "true" : "false");
     mprintf ("     p_strict_language_handling                  = %s \n",(p_strict_language_handling == true) ? "true" : "false");
     mprintf ("     p_wave                                      = %s \n",(p_wave == true) ? "true" : "false");
     mprintf ("     p_embedColorCodesInGeneratedCode            = %s \n",(p_embedColorCodesInGeneratedCode == true) ? "true" : "false");
     mprintf ("     p_generateSourcePositionCodes               = %s \n",(p_generateSourcePositionCodes == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesCppFileExtension            = %s \n",(p_sourceFileUsesCppFileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesFortranFileExtension        = %s \n",(p_sourceFileUsesFortranFileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesFortran77FileExtension      = %s \n",(p_sourceFileUsesFortran77FileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesFortran90FileExtension      = %s \n",(p_sourceFileUsesFortran90FileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesFortran95FileExtension      = %s \n",(p_sourceFileUsesFortran95FileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesPHPFileExtension            = %s \n",(p_sourceFileUsesPHPFileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesJavaFileExtension           = %s \n",(p_sourceFileUsesJavaFileExtension == true) ? "true" : "false");
     mprintf ("     p_sourceFileUsesBinaryFileExtension         = %s \n",(p_sourceFileUsesBinaryFileExtension == true) ? "true" : "false");
     mprintf ("     p_read_executable_file_format_only          = %s \n",(p_read_executable_file_format_only == true) ? "true" : "false");
     mprintf ("     p_read_instructions_only                    = %s \n",(p_read_instructions_only == true) ? "true" : "false");

     mprintf ("     p_unparse_tokens                            = %s \n",(p_unparse_tokens == true) ? "true" : "false");
     mprintf ("     p_unparse_tokens_testing                    = %d \n",p_unparse_tokens_testing);

  // DQ (11/12/2014): Addded to support test modes for token unparsing.
     mprintf ("     p_unparse_using_leading_and_trailing_token_mappings = %s \n",(p_unparse_using_leading_and_trailing_token_mappings == true) ? "true" : "false");

     mprintf ("     p_detect_dangling_pointers                  = %d \n",p_detect_dangling_pointers);

     mprintf ("     p_skipAstConsistancyTests                   = %s \n",(p_skipAstConsistancyTests == true) ? "true" : "false");

  // DQ (6/8/2013): Added support for experimental fortran frontend.
     mprintf ("     p_experimental_fortran_frontend             = %s \n",(p_experimental_fortran_frontend == true) ? "true" : "false");
     mprintf ("     p_experimental_fortran_frontend_OFP_test    = %s \n",(p_experimental_fortran_frontend_OFP_test == true) ? "true" : "false");

  // Rasmussen (3/12/2018): Added support for CUDA Fortran within the experimental fortran frontend.
     mprintf ("     p_experimental_cuda_fortran_frontend        = %s \n",(p_experimental_cuda_fortran_frontend == true) ? "true" : "false");

  // DQ (4/17/2015): Adding multifile handling support for commandline generation.
     mprintf ("     p_multifile_support                         = %s \n",(p_multifile_support == true) ? "true" : "false");

  // DQ (12/11/2015): Option to use the token stream mapping and local tests of the 
  // token sequence, to improve the source position information stored in the AST.
     mprintf ("     p_use_token_stream_to_improve_source_position_info = %s \n",(p_use_token_stream_to_improve_source_position_info == true) ? "true" : "false");

  // DQ (12/23/2015): Suppress variable declaration normalizations
     mprintf ("     p_suppress_variable_declaration_normalization = %s \n",(p_suppress_variable_declaration_normalization == true) ? "true" : "false");

#if 0
// Order of data member entries in support.C, matched against the 
// initialization to make sure that all data members are initialized.
X startOfConstruct
X root
X verbose
X output_warnings
X C_only
X UPC_only
X upc_threads
X C99_only
X Cxx_only
X Fortran_only
X F77_only
X F90_only
X F95_only
X F2003_only
X PHP_only
X Python_only
X requires_C_preprocessor
X binary_only
X inputFormat
X outputFormat
X backendCompileFormat
X fortran_implicit_none
X fortran_openmp
X cray_pointer_support
X output_parser_actions
X exit_after_parser
X skip_syntax_check
X skip_transformation
X skip_unparse
X skipfinalCompileStep
X unparse_includes
X unparse_line_directives
X unparse_instruction_addresses
X unparse_raw_memory_contents
X unparse_binary_file_format
X outputLanguage
STRING  sourceFileNameWithPath
STRING  sourceFileNameWithoutPath
STRING  unparse_output_filename
X useBackendOnly
X compileOnly
STRING  savedFrontendCommandLine
X no_implicit_templates
X no_implicit_inline_templates
X skip_commentsAndDirectives
X collectAllCommentsAndDirectives
X unparseHeaderFiles
X preprocessorDirectivesAndCommentsList
X attributeMechanism
X KCC_frontend
X new_frontend
X disable_edg_backend
X disable_sage_backend
X testingLevel
X preinit_il
X enable_cp_backend
// X outputGrammarTreeFiles
// X outputGrammarTreeFilesForHeaderFiles
// X outputGrammarTreeFilesForEDG

X markGeneratedFiles
X negative_test
X strict_language_handling
X embedColorCodesInGeneratedCode
X generateSourcePositionCodes
X sourceFileUsesCppFileExtension
X sourceFileUsesFortranFileExtension
X sourceFileUsesFortran77FileExtension
X sourceFileUsesFortran90FileExtension
X sourceFileUsesFortran95FileExtension
X sourceFileUsesPHPFileExtension
X sourceFileUsesBinaryFileExtension
X binaryFile
X read_executable_file_format_only
X read_instructions_only
X aggressive
#endif

   }


// DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented 
// as a static member variable instead of non-static member variable.  See test2015_141.c 
// for whare this is required.
bool
SgFile::get_skip_unparse_asm_commands()
   {
     return p_skip_unparse_asm_commands;
   }

// DQ (5/23/2015): Added support for p_skip_unparse_asm_commands to be implemented 
// as a static member variable instead of non-static member variable. See test2015_141.c 
// for whare this is required.
void 
SgFile::set_skip_unparse_asm_commands( bool b )
   {
     p_skip_unparse_asm_commands = b;
   }


SOURCE_APPLICATION_FILE_END


SOURCE_APPLICATION_SOURCE_FILE_START

#if 0
SgSourceFile::SgSourceFile ()
   {
  // Default constructor

     assert (p_root == NULL);

  // DQ (9/4/2008): Setup of global scope moved from SgFile to SgSourceFile
  // DQ (8/31/2006): Generate a NULL_FILE (instead of SgFile::SgFile) so that we can 
  // enforce that the filename is always an absolute path (starting with "/").
  // Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("SgGlobal::SgGlobal",0,0);
     Sg_File_Info* globalScopeFileInfo = new Sg_File_Info("",0,0);
     assert (globalScopeFileInfo != NULL);

     p_root = new SgGlobal( globalScopeFileInfo );
     assert (p_root != NULL);

  // DQ (2/15/2006): Set the parent of the SgGlobal IR node
     p_root->set_parent(this);

  // DQ (8/21/2008): Set the end of the global scope (even if it is updated later)
  // mprintf ("In SgFile::initialization(): p_root->get_endOfConstruct() = %p \n",p_root->get_endOfConstruct());
     assert(p_root->get_endOfConstruct() == NULL);
     p_root->set_endOfConstruct(new Sg_File_Info("",0,0));
     assert(p_root->get_endOfConstruct() != NULL);
   }
#endif

void 
SgSourceFile::set_tokenSubsequenceMap(std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenStreamSequenceMap)
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // We could later make this a map of maps using the SgSourceFile IR node as the key (or the Sg_File_Info fileId value (which is tied to the filename)).

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::tokenSubsequenceMap = tokenStreamSequenceMap;

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*> & tokenMap = this->get_tokenSubsequenceMap();

#if 0
     mprintf ("In SgSourceFile::set_tokenSubsequenceMap(): (before): tokenMap.size() = %zu \n",tokenMap.size());
#endif

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*>::iterator i = tokenStreamSequenceMap.begin();
     while (i != tokenStreamSequenceMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

#if 1
       // DQ (6/3/2019): Testing (unparse heaaders active, but token-based unparsing inactive) with an alternative implementation.

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (tokenMap.find(i->first) != tokenMap.end())
             {
               mprintf ("In SgSourceFile::set_tokenSubsequenceMap(): This is a redundant entry in the tokenMap (not inserted)  \n");

            // DQ (6/3/2019): comment this out, but don't include this map.
            // ROSE_ASSERT(false);
             }
            else
             {
               tokenMap.insert(*i);
             }
#else
       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (tokenMap.find(i->first) != tokenMap.end())
             {
               mprintf ("This is a redundant entry in the tokenMap \n");
               ROSE_ASSERT(false);
             }

          tokenMap.insert(*i);
#endif

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_tokenSubsequenceMap(): (after): tokenMap.size() = %zu \n",tokenMap.size());
#endif

   }

// DQ (9/26/2018): Added so that we can call the display function for TokenStreamSequenceToNodeMapping (for debugging).
#include "tokenStreamMapping.h"

std::map<SgNode*,TokenStreamSequenceToNodeMapping*> &
SgSourceFile::get_tokenSubsequenceMap()
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.

#if 0
     mprintf ("$$$$$$$$$$$$$$$$$$$$ In SgSourceFile::get_tokenSubsequenceMap() $$$$$$$$$$$$$$$$$$$$$$ \n");
#endif

  // DQ (9/27/2018): To support multiple files with the token based unparsing, we need to have one map per file 
  // (to simplify the debugging if not fix a current bug in the use of the token based unparsing across multiple 
  // files, as is being tested with the header file unparsing).
  // return Rose::tokenSubsequenceMap;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_tokenSubsequenceMap(): index = %d filename = %s \n",index,this->getFileName().c_str());
  // mprintf ("In SgSourceFile::get_tokenSubsequenceMap(): index = %d \n",index);
     mprintf ("In SgSourceFile::get_tokenSubsequenceMap(): Rose::tokenSubsequenceMapOfMaps.size() = %zu \n",Rose::tokenSubsequenceMapOfMaps.size());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::tokenSubsequenceMapOfMaps.find(index) == Rose::tokenSubsequenceMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgNode*,TokenStreamSequenceToNodeMapping*> object to the Rose::tokenSubsequenceMapOfMaps: (before) size = %zu \n",Rose::tokenSubsequenceMapOfMaps.size());
#endif
          std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* tokenSubsequenceMap = new std::map<SgNode*,TokenStreamSequenceToNodeMapping*>();
          ROSE_ASSERT(tokenSubsequenceMap != NULL);

          Rose::tokenSubsequenceMapOfMaps.insert(std::pair<int,std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* >(index,tokenSubsequenceMap));
#if 0
          mprintf ("Adding a new std::map<SgNode*,TokenStreamSequenceToNodeMapping*> object to the Rose::tokenSubsequenceMapOfMaps: (after) size = %zu \n",Rose::tokenSubsequenceMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::tokenSubsequenceMapOfMaps.find(index) != Rose::tokenSubsequenceMapOfMaps.end());
     ROSE_ASSERT(Rose::tokenSubsequenceMapOfMaps[index] != NULL);

  // return *(Rose::tokenSubsequenceMapOfMaps[index]);
     std::map<SgNode*,TokenStreamSequenceToNodeMapping*>* result = Rose::tokenSubsequenceMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

#if 0
  // DQ (10/4/2018): Run a test each time this map is accessed: Output the tokenStreamSequenceMap:
#if 0
     mprintf ("In SgSourceFile::get_tokenSubsequenceMap(): Output TokenStreamSequenceToNodeMapping \n");
#endif

     std::map<SgNode*,TokenStreamSequenceToNodeMapping*>::iterator k = result->begin();
     while (k != result->end())
        {
#if 0
          mprintf ("k->first = %p = %s: \n",k->first,k->first->class_name().c_str());
#endif
       // DQ (9/28/2018): Adding assertion.
          ROSE_ASSERT(k->second->node != NULL);
#if 0
          k->second->display("token sequence");
#endif
          k++;
        }
#endif

     return *result;
   }


// void SgSourceFile::set_token_unparse_frontier(std::vector<FrontierNode*> & tokenStreamSequenceMap)
void 
SgSourceFile::set_token_unparse_frontier(std::map<SgStatement*,FrontierNode*> & tokenStreamSequenceMap)
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // We could later make this a map of maps using the SgSourceFile IR node as the key (or the Sg_File_Info fileId value (which is tied to the filename)).

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::frontierNodes = tokenStreamSequenceMap;

     std::map<SgStatement*,FrontierNode*> & frontierMap = this->get_token_unparse_frontier();

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgStatement*,FrontierNode*>::iterator i = tokenStreamSequenceMap.begin();
     while (i != tokenStreamSequenceMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_token_unparse_frontier(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

// std::vector<FrontierNode*> & SgSourceFile::get_token_unparse_frontier()
std::map<SgStatement*,FrontierNode*> &
SgSourceFile::get_token_unparse_frontier()
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.

  // DQ (9/28/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // return Rose::frontierNodes;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): index = %d filename = %s \n",index,this->getFileName().c_str());
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): Rose::frontierNodesMapOfMaps.size() = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::frontierNodesMapOfMaps.find(index) == Rose::frontierNodesMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::frontierNodesMapOfMaps: (before) size = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif
          std::map<SgStatement*,FrontierNode*>* frontierNodesMap = new std::map<SgStatement*,FrontierNode*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::frontierNodesMapOfMaps.insert(std::pair<int,std::map<SgStatement*,FrontierNode*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::frontierNodesMapOfMaps: (after) size = %zu \n",Rose::frontierNodesMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::frontierNodesMapOfMaps.find(index) != Rose::frontierNodesMapOfMaps.end());
     ROSE_ASSERT(Rose::frontierNodesMapOfMaps[index] != NULL);

     std::map<SgStatement*,FrontierNode*>* result = Rose::frontierNodesMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }


















void 
SgSourceFile::set_token_unparse_frontier_adjacency(std::map<SgNode*,PreviousAndNextNodeData*> & tokenStreamSequenceMap)
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // We could later make this a map of maps using the SgSourceFile IR node as the key (or the Sg_File_Info fileId value (which is tied to the filename)).

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::previousAndNextNodeMap = tokenStreamSequenceMap;

     std::map<SgNode*,PreviousAndNextNodeData*> & frontierMap = this->get_token_unparse_frontier_adjacency();

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier_adjacency(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgNode*,PreviousAndNextNodeData*>::iterator i = tokenStreamSequenceMap.begin();
     while (i != tokenStreamSequenceMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_token_unparse_frontier_adjacency(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_token_unparse_frontier_adjacency(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

std::map<SgNode*,PreviousAndNextNodeData*> &
SgSourceFile::get_token_unparse_frontier_adjacency()
   {
  // DQ (10/28/2013): Not sure I want this to be copy by value, but OK for now.
  // return Rose::previousAndNextNodeMap;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier_adjacency(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::previousAndNextNodeMapOfMaps.find(index) == Rose::previousAndNextNodeMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgNode*,PreviousAndNextNodeData*> object to the Rose::previousAndNextNodeMapOfMaps: (before) size = %zu \n",Rose::previousAndNextNodeMapOfMaps.size());
#endif
          std::map<SgNode*,PreviousAndNextNodeData*>* frontierNodesMap = new std::map<SgNode*,PreviousAndNextNodeData*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::previousAndNextNodeMapOfMaps.insert(std::pair<int,std::map<SgNode*,PreviousAndNextNodeData*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgNode*,PreviousAndNextNodeData*> object to the Rose::previousAndNextNodeMapOfMaps: (after) size = %zu \n",Rose::previousAndNextNodeMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::previousAndNextNodeMapOfMaps.find(index) != Rose::previousAndNextNodeMapOfMaps.end());
     ROSE_ASSERT(Rose::previousAndNextNodeMapOfMaps[index] != NULL);

     std::map<SgNode*,PreviousAndNextNodeData*>* result = Rose::previousAndNextNodeMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }

















// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
void
SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(std::multimap<int,SgStatement*> & X)
   {
  // Rose::redundantlyMappedTokensToStatementMultimap = X;

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::frontierNodes = tokenStreamSequenceMap;

     std::multimap<int,SgStatement*> & frontierMap = this->get_redundantlyMappedTokensToStatementMultimap();

#if 0
     mprintf ("In SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::multimap<int,SgStatement*>::iterator i = X.begin();
     while (i != X.end())
        {
       // ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               ROSE_ASSERT(i->second != NULL);
#if 0
               mprintf ("SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): This is a redundant entry in the Map: i->first = %d i->second = %p = %s \n",i->first,i->second,i->second->class_name().c_str());
#endif
            // DQ (11/1/2018): Since this is a multimap, this might be OK (debugging move tool tests).
            // ROSE_ASSERT(false);
             }
            else
             {
#if 0
               mprintf ("SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): new entry in the map: i->first = %d i->second = %p = %s \n",i->first,i->second,i->second->class_name().c_str());
#endif
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_redundantlyMappedTokensToStatementMultimap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
std::multimap<int,SgStatement*> &
SgSourceFile::get_redundantlyMappedTokensToStatementMultimap()
   {
  // return Rose::redundantlyMappedTokensToStatementMultimap;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_redundantlyMappedTokensToStatementMultimap(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::redundantlyMappedTokensToStatementMapOfMultimaps.find(index) == Rose::redundantlyMappedTokensToStatementMapOfMultimaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::redundantlyMappedTokensToStatementMapOfMultimaps: (before) size = %zu \n",Rose::redundantlyMappedTokensToStatementMapOfMultimaps.size());
#endif
          std::multimap<int,SgStatement*>* frontierNodesMap = new std::multimap<int,SgStatement*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::redundantlyMappedTokensToStatementMapOfMultimaps.insert(std::pair<int,std::multimap<int,SgStatement*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,FrontierNode*> object to the Rose::redundantlyMappedTokensToStatementMapOfMultimaps: (after) size = %zu \n",Rose::redundantlyMappedTokensToStatementMapOfMultimaps.size());
#endif
        }

     ROSE_ASSERT(Rose::redundantlyMappedTokensToStatementMapOfMultimaps.find(index) != Rose::redundantlyMappedTokensToStatementMapOfMultimaps.end());
     ROSE_ASSERT(Rose::redundantlyMappedTokensToStatementMapOfMultimaps[index] != NULL);

     std::multimap<int,SgStatement*>* result = Rose::redundantlyMappedTokensToStatementMapOfMultimaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }
















// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
void
SgSourceFile::set_redundantTokenEndingsSet(std::set<int> & X)
   {
  // Rose::redundantTokenEndingsSet = X;

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::frontierNodes = tokenStreamSequenceMap;

     std::set<int> & frontierMap = this->get_redundantTokenEndingsSet();

#if 0
     mprintf ("In SgSourceFile::set_redundantTokenEndingsSet(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::set<int>::iterator i = X.begin();
     while (i != X.end())
        {
       // ROSE_ASSERT(i->first  != NULL);
       // ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
       // if (frontierMap.find(i->first) != frontierMap.end())
          if (frontierMap.find(*i) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_redundantTokenEndingsSet(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_redundantTokenEndingsSet(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

// DQ (11/29/2013): Added to support access to multi-map of redundant mapping of frontier IR nodes to token subsequences.
std::set<int> &
SgSourceFile::get_redundantTokenEndingsSet()
   {
  // return Rose::redundantTokenEndingsSet;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_token_unparse_frontier(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::redundantTokenEndingsMapOfSets.find(index) == Rose::redundantTokenEndingsMapOfSets.end())
        {
#if 0
          mprintf ("Adding a new std::set<int> object to the Rose::redundantTokenEndingsMapOfSets: (before) size = %zu \n",Rose::redundantTokenEndingsMapOfSets.size());
#endif
          std::set<int>* frontierNodesMap = new std::set<int>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::redundantTokenEndingsMapOfSets.insert(std::pair<int,std::set<int>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::set<int> object to the Rose::redundantTokenEndingsMapOfSets: (after) size = %zu \n",Rose::redundantTokenEndingsMapOfSets.size());
#endif
        }

     ROSE_ASSERT(Rose::redundantTokenEndingsMapOfSets.find(index) != Rose::redundantTokenEndingsMapOfSets.end());
     ROSE_ASSERT(Rose::redundantTokenEndingsMapOfSets[index] != NULL);

     std::set<int>* result = Rose::redundantTokenEndingsMapOfSets[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }














void 
SgSourceFile::set_representativeWhitespaceStatementMap(std::map<SgScopeStatement*,SgStatement*> & representativeWhitespaceStatementMap)
   {
  // DQ (11/20/2015): Provide a statement to use as a key in the token sequence map to get representative whitespace.
  // Rose::representativeWhitespaceStatementMap = representativeWhitespaceStatementMap;

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::frontierNodes = tokenStreamSequenceMap;

     std::map<SgScopeStatement*,SgStatement*> & frontierMap = this->get_representativeWhitespaceStatementMap();

#if 0
     mprintf ("In SgSourceFile::set_representativeWhitespaceStatementMap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgScopeStatement*,SgStatement*>::iterator i = representativeWhitespaceStatementMap.begin();
     while (i != representativeWhitespaceStatementMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

#if 1
       // DQ (6/3/2019): Testing (unparse heaaders active, but token-based unparsing inactive) with an alternative implementation.

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_representativeWhitespaceStatementMap(): This is a redundant entry in the Map \n");
               mprintf ("   --- filename = %s \n",getFileName().c_str());
               mprintf ("   --- i->first  = %p = %s \n",i->first,i->first->class_name().c_str());
               mprintf ("   --- i->second = %p = %s \n",i->second,i->second->class_name().c_str());
            // ROSE_ASSERT(false);
             }
            else
             {
               frontierMap.insert(*i);
             }
#else
       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_representativeWhitespaceStatementMap(): This is a redundant entry in the Map \n");
               mprintf ("   --- filename = %s \n",getFileName().c_str());
               mprintf ("   --- i->first  = %p = %s \n",i->first,i->first->class_name().c_str());
               mprintf ("   --- i->second = %p = %s \n",i->second,i->second->class_name().c_str());
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);
#endif
          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_representativeWhitespaceStatementMap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

std::map<SgScopeStatement*,SgStatement*> &
SgSourceFile::get_representativeWhitespaceStatementMap()
   {
  // DQ (11/20/2015): Provide a statement to use as a key in the token sequence map to get representative whitespace.
  // DQ (11/20/2015): Not sure I want this to be copy by value, but OK for now.
  // return Rose::representativeWhitespaceStatementMap;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_representativeWhitespaceStatementMap(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::representativeWhitespaceStatementMapOfMaps.find(index) == Rose::representativeWhitespaceStatementMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgScopeStatement*,SgStatement*> object to the Rose::representativeWhitespaceStatementMapOfMaps: (before) size = %zu \n",Rose::representativeWhitespaceStatementMapOfMaps.size());
#endif
          std::map<SgScopeStatement*,SgStatement*>* frontierNodesMap = new std::map<SgScopeStatement*,SgStatement*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::representativeWhitespaceStatementMapOfMaps.insert(std::pair<int,std::map<SgScopeStatement*,SgStatement*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgScopeStatement*,SgStatement*> object to the Rose::representativeWhitespaceStatementMapOfMaps: (after) size = %zu \n",Rose::representativeWhitespaceStatementMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::representativeWhitespaceStatementMapOfMaps.find(index) != Rose::representativeWhitespaceStatementMapOfMaps.end());
     ROSE_ASSERT(Rose::representativeWhitespaceStatementMapOfMaps[index] != NULL);

     std::map<SgScopeStatement*,SgStatement*>* result = Rose::representativeWhitespaceStatementMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }
















void 
SgSourceFile::set_macroExpansionMap(std::map<SgStatement*,MacroExpansion*> & macroExpansionMap)
   {
  // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.
  // Rose::macroExpansionMap = macroExpansionMap;

  // DQ (9/26/2018): We need to merge these results not overright the initial results.  This is essential when we are supporting
  // multiple files (or header files in addition to the source file).
  // Rose::frontierNodes = tokenStreamSequenceMap;

     std::map<SgStatement*,MacroExpansion*> & frontierMap = this->get_macroExpansionMap();

#if 0
     mprintf ("In SgSourceFile::set_macroExpansionMap(): (before): frontierMap.size() = %zu \n",frontierMap.size());
#endif

     std::map<SgStatement*,MacroExpansion*>::iterator i = macroExpansionMap.begin();
     while (i != macroExpansionMap.end())
        {
          ROSE_ASSERT(i->first  != NULL);
          ROSE_ASSERT(i->second != NULL);

       // DQ (9/26/2018): Make sure this is not an entry that already exists in the map.
          if (frontierMap.find(i->first) != frontierMap.end())
             {
               mprintf ("SgSourceFile::set_macroExpansionMap(): This is a redundant entry in the Map \n");
               ROSE_ASSERT(false);
             }

          frontierMap.insert(*i);

          i++;
        }

#if 0
     mprintf ("In SgSourceFile::set_macroExpansionMap(): (after): frontierMap.size() = %zu \n",frontierMap.size());
#endif
   }

std::map<SgStatement*,MacroExpansion*> &
SgSourceFile::get_macroExpansionMap()
   {
  // DQ (11/30/2015): Provide a statement to use as a key in the macro expansion map to get info about macro expansions.
  // DQ (11/30/2015): Not sure I want this to be copy by value, but OK for now.
  // return Rose::macroExpansionMap;

     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(this->get_startOfConstruct() != NULL);

     int index = this->get_startOfConstruct()->get_file_id();

#if 0
     mprintf ("In SgSourceFile::get_macroExpansionMapOfMaps(): index = %d filename = %s \n",index,this->getFileName().c_str());
#endif

     if (index < 0)
        {
          mprintf ("ERROR: we only have token stream subsequences for valid files: fileid < 0: index = %d \n",index);
          ROSE_ASSERT(false);
        }

     if (Rose::macroExpansionMapOfMaps.find(index) == Rose::macroExpansionMapOfMaps.end())
        {
#if 0
          mprintf ("Adding a new std::map<SgStatement*,MacroExpansion*> object to the Rose::macroExpansionMapOfMaps: (before) size = %zu \n",Rose::macroExpansionMapOfMaps.size());
#endif
          std::map<SgStatement*,MacroExpansion*>* frontierNodesMap = new std::map<SgStatement*,MacroExpansion*>();
          ROSE_ASSERT(frontierNodesMap != NULL);

          Rose::macroExpansionMapOfMaps.insert(std::pair<int,std::map<SgStatement*,MacroExpansion*>* >(index,frontierNodesMap));
#if 0
          mprintf ("Adding a new std::map<SgStatement*,MacroExpansion*> object to the Rose::macroExpansionMapOfMaps: (after) size = %zu \n",Rose::macroExpansionMapOfMaps.size());
#endif
        }

     ROSE_ASSERT(Rose::macroExpansionMapOfMaps.find(index) != Rose::macroExpansionMapOfMaps.end());
     ROSE_ASSERT(Rose::macroExpansionMapOfMaps[index] != NULL);

     std::map<SgStatement*,MacroExpansion*>* result = Rose::macroExpansionMapOfMaps[index];
     ROSE_ASSERT(result != NULL);

     return *result;
   }

























SOURCE_APPLICATION_SOURCE_FILE_END


SOURCE_INCLUDE_FILE_START
SOURCE_INCLUDE_FILE_END


SOURCE_HEADER_FILE_REPORT_START

#if 0
SgHeaderFileReport::SgHeaderFileReport( SgSourceFile* sourceFile )
   {
  // Nothing to do here (so far).
   }
#endif


// DQ (9/26/2018): Added so that we can call the display function for TokenStreamSequenceToNodeMapping (for debugging).
#include "tokenStreamMapping.h"

void
SgHeaderFileReport::display( const string & label) const
   {
     mprintf ("\nIn HeaderFileReport::display(): label = %s \n",label.c_str());

     ROSE_ASSERT(this != NULL);

#if 1
     mprintf ("In HeaderFileReport::display(): p_source_file = %p \n",p_source_file);
     ROSE_ASSERT(p_source_file != NULL);
     mprintf ("   --- source filename = %s \n",p_source_file->getFileName().c_str());
     mprintf ("   --- isHeaderFile = %s \n",p_source_file->get_isHeaderFile() ? "true" : "false");
     mprintf ("   --- isHeaderFileIncludedMoreThanOnce = %s \n",p_source_file->get_isHeaderFileIncludedMoreThanOnce() ? "true" : "false");

  // DQ (11/15/2018): removed the include list from SgSourceFile so that we could support traversals on the inlcude tree.
  // mprintf ("   --- include_file_list size = %zu \n",p_source_file->get_include_file_list().size());
     mprintf ("   --- associated_include_file = %p \n",p_source_file->get_associated_include_file());
     ROSE_ASSERT(p_source_file->get_associated_include_file() != NULL);
     mprintf ("   --- associated_include_file include_file_list size = %zu \n",p_source_file->get_associated_include_file()->get_include_file_list().size());

#if 0
     mprintf ("   --- source_file_of_translation_unit = %p = %s \n",
          p_source_file->get_source_file_of_translation_unit(),p_source_file->get_source_file_of_translation_unit()->getFileName().c_str());
     mprintf ("   --- including_source_file = %p = %s \n",
          p_source_file->get_including_source_file(),p_source_file->get_including_source_file()->getFileName().c_str());
#endif

     mprintf ("In HeaderFileReport::display(): p_include_file_list.size() = %zu \n",p_include_file_list.size());

     Rose_STL_Container<SgSourceFile*>::const_iterator i = p_include_file_list.begin();
     while (i != p_include_file_list.end())
        {
       // const SgSourceFile* includedFile = *i;
          SgSourceFile* includedFile = *i;
          ROSE_ASSERT(includedFile != NULL);

          mprintf ("   --- includedFile: name = %s \n",includedFile->getFileName().c_str());
          mprintf ("   --- --- # of statements in global scope = %zu \n",includedFile->get_globalScope()->get_declarations().size());
          mprintf ("   --- --- isHeaderFile = %s \n",includedFile->get_isHeaderFile() ? "true" : "false");
          mprintf ("   --- --- isHeaderFileIncludedMoreThanOnce = %s \n",includedFile->get_isHeaderFileIncludedMoreThanOnce() ? "true" : "false");

       // DQ (11/15/2018): removed the include list from SgSourceFile so that we could support traversals on the inlcude tree.
       // mprintf ("   --- --- include_file_list size = %zu \n",includedFile->get_include_file_list().size());
          mprintf ("   --- --- associated_include_file = %p \n",includedFile->get_associated_include_file());
          ROSE_ASSERT(includedFile->get_associated_include_file() != NULL);
          mprintf ("   --- --- associated_include_file include_file_list size = %zu \n",includedFile->get_associated_include_file()->get_include_file_list().size());

#if 0
          mprintf ("   --- --- source_file_of_translation_unit = %p = %s \n",
               includedFile->get_source_file_of_translation_unit(),includedFile->get_source_file_of_translation_unit()->getFileName().c_str());
          mprintf ("   --- --- including_source_file = %p = %s \n",
               includedFile->get_including_source_file(),includedFile->get_including_source_file()->getFileName().c_str());
#endif
#if 0
          mprintf ("In SgHeaderFileReport::display(): includedFile         = %p file name = %s \n",includedFile,includedFile->getFileName().c_str());
          mprintf ("   --- includedFile->get_globalScope()                 = %p \n",includedFile->get_globalScope());
          mprintf ("   --- includedFile->get_tokenSubsequenceMap().size()  = %zu \n",includedFile->get_tokenSubsequenceMap().size());
#endif
#if 0
          ROSE_ASSERT(includedFile->get_tokenSubsequenceMap().find(includedFile->get_globalScope()) != includedFile->get_tokenSubsequenceMap().end());

          mprintf ("In SgHeaderFileReport::display(): Calling display on token sequence for global scope \n");
          ROSE_ASSERT(includedFile->get_tokenSubsequenceMap()[includedFile->get_globalScope()] != NULL);
          TokenStreamSequenceToNodeMapping* tokenSequence = includedFile->get_tokenSubsequenceMap()[includedFile->get_globalScope()];
          ROSE_ASSERT(tokenSequence != NULL);
          tokenSequence->display("token sequence for global scope");
#endif

          i++;
        }
#endif



   }

SOURCE_HEADER_FILE_REPORT_END


SOURCE_APPLICATION_BINARY_FILE_START

const SgAsmGenericFile* 
SgBinaryComposite::get_binaryFile() const
   {
     assert(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

SgAsmGenericFile*
SgBinaryComposite::get_binaryFile()
   {
     assert(p_genericFileList->get_files().size() == 1);
     return p_genericFileList->get_files()[0];
   }

void
SgBinaryComposite::set_binaryFile( SgAsmGenericFile* file )
   {
     assert(p_genericFileList->get_files().empty() == true);
     p_genericFileList->get_files().push_back(file);
   }

SOURCE_APPLICATION_BINARY_FILE_END

SOURCE_APPLICATION_UNKNOWN_FILE_START
SgUnknownFile::SgUnknownFile ( vector<string> & argv ,  SgProject* project )
   : SgFile(argv, project)
   {
  // set_parent(project);
   }

SOURCE_APPLICATION_UNKNOWN_FILE_END


SOURCE_APPLICATION_FILE_LIST_START
SOURCE_APPLICATION_FILE_LIST_END

SOURCE_APPLICATION_DIRECTORY_START
int
SgDirectory::numberOfFiles() const
   {
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     return -1;
#else
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles().size();
#endif
   }

SgFile*
SgDirectory::get_file(int i) const
   {
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     return NULL;
#else
     assert(p_fileList != NULL);
     return p_fileList->get_listOfFiles()[i];
#endif
   }

int
SgDirectory::numberOfDirectories() const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories().size();
   }

SgDirectory*
SgDirectory::get_directory(int i) const
   {
     assert(p_directoryList != NULL);
     return p_directoryList->get_listOfDirectories()[i];
   }

void 
SgDirectory::post_construction_initialization()
   {
  // Make sure these data members start out as NULL.
     assert(p_fileList == NULL);
     assert(p_directoryList == NULL);

  // Initialize pointers to valid opjects with empty lists.
     p_fileList      = new SgFileList();
     p_directoryList = new SgDirectoryList();

     assert(p_fileList != NULL);
     assert(p_directoryList != NULL);

     p_fileList->set_parent(this);
     p_directoryList->set_parent(this);
   }

SOURCE_APPLICATION_DIRECTORY_END

SOURCE_APPLICATION_DIRECTORY_LIST_START
SOURCE_APPLICATION_DIRECTORY_LIST_END


SOURCE_JAVA_IMPORT_STATEMENT_LIST_START
SOURCE_JAVA_IMPORT_STATEMENT_LIST_END


SOURCE_JAVA_CLASS_DECLARATION_LIST_START
SOURCE_JAVA_CLASS_DECLARATION_LIST_END



SOURCE_APPLICATION_PROJECT_START

//! Declaration of space for static variables
//static int SgProject::p_defaultNumberOfCommandLineArguments = 0;
//static char** SgProject::p_defaultCommandLineArgumentList   = NULL;


//! (static data) global concept of verbose level which controls useful output from the compiler
int SgProject::p_verbose = 0;

//! this can constructor can be used but parse(int argc, char** argv) needs to be called
SgProject::SgProject()
   {
     initialization();
   }

SgProject::SgProject( const SgProject & project )
   {
  // This copy constructor is not supported, it is implemented with to return an error message!

     initialization();

  // What is the point of this code!
  // p_numberOfCommandLineArguments(project.p_numberOfCommandLineArguments),
  // p_commandLineArgumentList(project.p_commandLineArgumentList),
  // p_defaultNumberOfCommandLineArguments(project.p_defaultNumberOfCommandLineArguments),
  // p_defaultCommandLineArgumentList(project.p_defaultCommandLineArgumentList),

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
  // DQ (1/20/2010): This is no longer a list and is now a pointer to a SgFileList IR node.

  // Build the empty STL lists
     p_fileList.clear();
#endif

  // print error message and quit
     mprintf ("ERROR: this SgProject copy constructor is not supposed to be used \n");
     mprintf ("    use SgProject ( int & argc, char** & argv , int & errorCode ) OR copy member function instead \n");
     ROSE_ABORT();
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( int argc, char** argv, bool frontendConstantFolding)
   {
  // DQ (11/4/2015): Added assertion.
     ROSE_ASSERT(this != NULL);

     initialization();

  // DQ (9/18/2011): Added support to use frontend specific constnat folding (applies to C/C++ using EDG).
  // All other languges have no specific constant folding options in there frontends.  We use to support
  // the original expression tree in the AST, and this provided both the constant folded value and
  // the original expression tree, but this was a problem for analysis (which tened to mix them together).
  // mprintf ("In SgProject(int argc,char** argv): frontendConstantFolding = %s \n",frontendConstantFolding == true ? "true" : "false");
     p_frontendConstantFolding = frontendConstantFolding;

     std::vector<std::string> argvList(argv, argv + argc);
     int errorCode = parse(argvList);
     set_frontendErrorCode(errorCode);
   }

//! constructor invokes EDG front end and creates AST. Use frontend() instead.
SgProject::SgProject ( const std::vector<std::string>& argv, bool frontendConstantFolding )
   {
  // DQ (11/4/2015): Added assertion.
     ROSE_ASSERT(this != NULL);

     initialization();

  // DQ (9/18/2011): Added support to use frontend specific constnat folding (applies to C/C++ using EDG).
  // All other languges have no specific constant folding options in there frontends.  We use to support
  // the original expression tree in the AST, and this provided both the constant folded value and
  // the original expression tree, but this was a problem for analysis (which tened to mix them together).
  // mprintf ("In SgProject(const std::vector<std::string>& argv): frontendConstantFolding = %s \n",frontendConstantFolding == true ? "true" : "false");
     p_frontendConstantFolding = frontendConstantFolding;

     int errorCode = parse(argv);
     set_frontendErrorCode(errorCode);
   }

void
SgProject::initialization()
   {
  // DQ (4/11/2017): Some implementations of ROSE tools are just calling the SgProject constructor directly, these 
  // need to call ROSE_INITIALIZE.  Here is a reasonable point to make that call.
     ROSE_INITIALIZE;

  // DQ (10/16/2005): This function initializes default values (until we use an automatically generated version)

  // Matzke (12/06/2016): Added missing initializations identified by valgrind and code inspection
     p_javacErrorCode = 0;
     p_ecjErrorCode = 0;
     p_midendErrorCode = 0;
     p_openmp_linking = false;

  // DQ (11/10/2016): Added initialization for keep_going data member and otehr data members that appear to be missing.
     p_keep_going                   = false;
     p_unparser__clobber_input_file = false;

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     p_fileList.clear();
#else
  // Initialize to IR node
     p_fileList_ptr = new SgFileList();
     assert(p_fileList_ptr != NULL);

     p_fileList_ptr->set_parent(this);
#endif

  // p_numberOfCommandLineArguments        = 0;
  // p_commandLineArgumentList             = NULL;
  // p_defaultNumberOfCommandLineArguments = 0;
  // p_defaultCommandLineArgumentList      = NULL;
     p_frontendErrorCode                   = 0;
     p_backendErrorCode                    = 0;
     p_outputFileName                      = "";
     p_compileOnly                         = false;

  // DQ (11/10/2016): Added initialization for data member that appeared to be missing.
     p_wave                         = false;

     p_prelink                             = false;
     p_template_instantiation_mode         = e_unknown;
     p_astMerge                            = false;
     p_astMergeCommandFile                 = "";
     p_projectSpecificDatabaseFile         = "";
     p_compilationPerformanceFile          = "";
     p_C_PreprocessorOnly                  = false;

  // DQ (5/2/2006): Added initialization to prevent valgrind warning.
     p_attributeMechanism                  = NULL;

  // DQ (1/23/2010): Added support for the project to have directory structure
     p_directoryList                       = NULL;

  // DQ (3/9/2009): Allow the verbose level to be set before we even call the SgProject constructor (helps debug Intel Pin usage).
     if (p_verbose > 0)
        {
          mprintf ("Note: Verbose was already set to non-zero value = %d (valid range is 0...10) \n",p_verbose);
          assert(p_verbose <= 10);
        }
       else
        {
          p_verbose                        = 0;
        }

  // DQ (2/4/2009): This was moved to the SgProject from the SgFile
     p_binary_only                         = false;

  // DQ (1/16/2008): This is part of a ROSE supported mechanism for the 
  // specification of exclude/include paths/files for interpretation by 
  // the ROSE translator.
  // p_lookForIncludePaths                 = false;
  // p_lookForExcludePaths                 = false;

  // DQ (1/20/2010): Added support for the project to have directory structure
  // (usefult for large scale code generation).
     assert(p_directoryList == NULL);

  // Initialize pointers to valid opjects with empty lists.
     p_directoryList = new SgDirectoryList();
     assert(p_directoryList != NULL);
     p_directoryList->set_parent(this);

  // DQ (10/3/2010): Added entries that had not be properly set previously.
     p_C_only                = false;
     p_Cxx_only              = false;

  // DQ (11/10/2016): Added initialization for data member that appeared to be missing.
     p_C11_only              = false;
     p_Cxx0x_only            = false;
     p_Cxx11_only            = false;
     p_C14_only              = false;
     p_Cxx14_only            = false;

     p_Fortran_only          = false;
     p_addCppDirectivesToAST = false;
     p_Java_only             = false;

  // DQ (11/10/2016): Added initialization for data member that appeared to be missing.
     p_X10_only              = false;
     p_Java_batch_mode       = false;
     p_Java_nowarn             = false;
     p_Java_verbose            = false;
     p_Java_deprecation        = false;
     p_addCppDirectivesToAST   = false;

  // DQ (9/18/2011): Added support for using more constant AST to select to use or not use frontend specific constant folding.
     p_frontendConstantFolding = false;

  // TV (07/18/2013): Initialise the global GlobalScope for multiple flie handeling
     Sg_File_Info * fi_gsaf = Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode();
     p_globalScopeAcrossFiles = new SgGlobal(fi_gsaf);
     fi_gsaf->set_parent(p_globalScopeAcrossFiles);
     p_globalScopeAcrossFiles->set_parent(this);

  // DQ (9/15/2013): Adding support to handle output of files into the same directory as the source file.
  // This avoids some subtle issues in how header files are resolved by the backend compiler.
  // See documentation in src/ROSETTA/src/support.C.
     p_unparse_in_same_directory_as_input_file = false;

  // DQ (1/19/2014): This option "-S" is required for some build systems (e.g. valgrind).
     p_stop_after_compilation_do_not_assemble_file = false;

  // DQ (1/20/2014): This option "-m32" over-rides the 64-bit mode on 64-bit environments and is required for some build systems (e.g. valgrind).
     p_mode_32_bit = false;

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error.
     p_noclobber_output_file              = false;

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error if it results in a different file.
     p_noclobber_if_different_output_file = false;

  // DQ (1/31/2014): Option to skip AST post-processing constant folding support. Currently required for OpenMP and C++, but not for C.
  // This option only makes a perfromance difference on a handful of files in the (large) wireshark application (2.5 million line application).
     p_suppressConstantFoldingPostProcessing = false;

  // Pei-Hung (8/6/2014): This option appends PID into the output name to avoid file collision in parallel compilation. 
     p_appendPID = false;

  // DQ (9/15/2018): Added support for a report on the internal use of header file unparsing.
  // This is to support the header file unparsing when used with and without the token based unparsing.
     p_reportOnHeaderFileUnparsing = false;

  // DQ (11/16/2019): this was not added previously.
     p_usingApplicationRootDirectory = false;

  // DQ (11/16/2019): this is a new data member just added.
     p_usingDeferredTransformations = false;
   }


// DQ (2/1/2007): Added new operator so that w could depricate the inconsistant usage of 
// SgFile& in get_file() member function.  The get_file() member function is now depricated.
SgFile*
SgProject::operator[]( unsigned int i )
   {

  // Since we use an STL vector internally we can use the vector::operator[] directly.
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     assert(i < get_fileList().size());
     return p_fileList[i];
#else
     assert(p_fileList_ptr != NULL);
     assert(i < (unsigned)numberOfFiles());
     return p_fileList_ptr->get_listOfFiles()[i];
#endif
   }

// DQ (6/13/2013): Access function for retriving a SgFile object from the list stored internally, 
// but using the filename with full path.  This is part of the new Java performance support and
// a design change that first builds all of the SgFile IR nodes and then calls the frontend for
// each of them.  This permits a more sophisticated level of command line multiple file support.
SgFile* SgProject::operator[]( std::string filename )
   {
  // Since we use an STL vector internally we can use the vector::operator[] directly.
#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
#error "ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT should be FALSE"
#else
     ROSE_ASSERT(p_fileList_ptr != NULL);
     ROSE_ASSERT(numberOfFiles() > 0);

#if 0
     mprintf ("In SgProject::operator[]( std::string filename ): Searching for the SgFile matching filename: filename = %s \n",filename.c_str());
#endif

     SgFilePtrList::iterator i = p_fileList_ptr->get_listOfFiles().begin();
     while (i != p_fileList_ptr->get_listOfFiles().end())
        {
          ROSE_ASSERT(*i != NULL);
#if 0
          mprintf ("Searching for the matching filename: filename = %s *i = %p  \n",filename.c_str(),*i);
#endif
       // Find the matching SgFile object using the get_sourceFileNameWithPath()
          if (filename == (*i)->get_sourceFileNameWithPath())
             {
#if 0
               mprintf ("Found the matching filename: filename = %s *i = %p  \n",filename.c_str(),*i);
#endif
               return *i;
             }

          i++;
        }

     return NULL;
#endif
   }


// Moved to sage_support.cpp: int SgProject::parse(const vector<string>& argv)
// Moved to sage_support.cpp: void SgProject::processCommandLine(const vector<string>& input_argv)

std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<string> & l )
   {
  // mprintf ("Output Rose_STL_Container<string> in operator<< (std::ostream,Rose_STL_Container<string>) \n");
     return os;
   }

// DQ (5/22/2007): Moved to astPostProcessing
// DQ (5/8/2007): Function prototype declared in HiddenList.h
// void buildHiddenTypeAndDeclarationLists( SgProject* project );

#if 0
// Moved the sage_support.cpp
int 
SgProject::parse()
   {
     int errorCode = 0;

#error "DEAD CODE!"

     return errorCode;
   }
#endif


#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
#else
// DQ (1/21/2010): In this case we want to support the previous interface so that we can transition easily.

SgFilePtrList &
SgProject::get_fileList() const
   {
     assert (this != NULL);
     return p_fileList_ptr->get_listOfFiles();
   }

void
SgProject::set_fileList( SgFilePtrList & fileList )
   {
     assert (this != NULL);
     set_isModified(true);

     p_fileList_ptr->get_listOfFiles() = fileList;
   }

#endif

int
SgProject::numberOfFiles() const
   {
  // This function does not return a meaningful result until all the files have been processed
  // assert (p_fileList != NULL);

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     int returnValue = p_fileList.size();
#else
     assert (p_fileList_ptr != NULL);
     int returnValue = p_fileList_ptr->get_listOfFiles().size();
#endif
  // assert ( returnValue > 0 );

  // Seems like a good upper bound for now!
  // assert ( returnValue < 100 );

     return returnValue;
   }

int
SgProject::numberOfDirectories() const
   {
     assert (p_directoryList != NULL);
     int returnValue = p_directoryList->get_listOfDirectories().size();

     return returnValue;
   }

SgFile &
SgProject::get_file ( int i ) const
   {
  // error checking
     assert (i >= 0);
     assert (i < numberOfFiles());

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     SgFile* targetFile = p_fileList[i];
#else
     assert (p_fileList_ptr != NULL);
     SgFile* targetFile = p_fileList_ptr->get_listOfFiles()[i];
  // SgFile* targetFile = NULL;

  // mprintf ("Exiting since this is not finished. \n");
  // assert(false);
#endif
     assert (targetFile != NULL);

     return *targetFile;
   }

void
SgProject::set_file ( SgFile & file )
   {
  // assert (p_fileList != NULL);

#if ROSE_USING_OLD_PROJECT_FILE_LIST_SUPPORT
     p_fileList.push_back(&file);
#else
     assert (p_fileList_ptr != NULL);
     p_fileList_ptr->get_listOfFiles().push_back(&file);

  // DQ (1/25/2010): Set the parent of the file to point to the list (this is a change and may break some code).
  // But it is consistant within ROSE for how we handle list objects in the IR.
     file.set_parent(p_fileList_ptr);

  // mprintf ("Exiting since this is not finished. \n");
  // assert(false);
#endif

     assert (numberOfFiles() > 0);
   }

SgFilePtrList
SgProject::get_files() const
{
  return p_fileList_ptr->get_listOfFiles();
}

SgFilePtrList
SgProject::get_files_with_errors() const
{
  SgFilePtrList files_with_errors;

  SgFilePtrList files = p_fileList_ptr->get_listOfFiles();
  SgFilePtrList::iterator it;
  for (it = files.begin(); it != files.end(); ++it)
  {
      SgFile* file = *it;
      bool has_errors =
          file->get_javacErrorCode()            != 0 ||
          file->get_frontendErrorCode()         != 0 ||
          file->get_midendErrorCode()           != 0 ||
          file->get_unparserErrorCode()         != 0 ||
          file->get_backendCompilerErrorCode()  != 0;
      if (has_errors)
      {
          files_with_errors.push_back(file);
      }
  }

  return files_with_errors;
}

SgFilePtrList
SgProject::get_files_without_errors() const
{
  SgFilePtrList files_without_errors;

  SgFilePtrList files = p_fileList_ptr->get_listOfFiles();
  SgFilePtrList::iterator it;
  for (it = files.begin(); it != files.end(); ++it)
  {
      SgFile* file = *it;
      bool has_no_errors =
          file->get_javacErrorCode()            == 0 &&
          file->get_frontendErrorCode()         == 0 &&
          file->get_midendErrorCode()         == 0 &&
          file->get_unparserErrorCode()         == 0 &&
          file->get_backendCompilerErrorCode()  == 0;
      if (has_no_errors)
      {
          files_without_errors.push_back(file);
      }
  }

  return files_without_errors;
}

void
SgProject::unparse ( UnparseFormatHelp *unparseFormatHelp, UnparseDelegate* unparseDelegate )
   {
#if 0
     for (int i = 0; i < numberOfFiles(); i++)
        {
       // mprintf ("In SgProject::unparse(): Unparsing file #%d \n",i);
          SgFile & file = get_file(i);

       // DQ (3/18/2006): Added support for user defined control of code generation
          file.unparse(unparseFormatHelp,unparseDelegate);
        }
#else
  // DQ (1/24/2010): refactored code to call existing function.
     extern void unparseProject( SgProject* project, UnparseFormatHelp *unparseFormatHelp /* = NULL */, UnparseDelegate* unparseDelegate/* = NULL */);
     unparseProject( this, unparseFormatHelp, unparseDelegate);
#endif
   }

// Moved to sage_support.cpp: int SgProject::compileOutput( const std::string& compilerName )

void
SgProject::resetSourcePositionToGeneratedCode ( UnparseFormatHelp *unparseFormatHelp )
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.resetSourcePositionToGeneratedCode( unparseFormatHelp );
        }
   }


#if 0
// DQ (9/2/2008): Removed this redundant function
// DQ (10/16/2005): I would like to get rid of this function since it is redundant with other 
// automatically generated functions containing list of source files (with and without paths).
Rose_STL_Container<string>
SgProject::getFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }
#endif

#if 1
// DQ (9/2/2008): Readded this function with a clearer name, since it is different from the
// list of filenames that appear on the command line; these are resolved to be absolute paths.
Rose_STL_Container<string>
SgProject::getAbsolutePathFileNames() const
   {
     Rose_STL_Container<string> nameList;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          nameList.push_back(std::string(file.getFileName()));
        }

     return nameList;
   }
#endif

// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
int
SgProject::get_verbose (void)
   {
     return p_verbose;
   }

// DQ (1/5/2008): I think this could be an automatically generated function!
// Unless the point is that it should not trigger a transformation to be recorded on the AST.
void
SgProject::set_verbose ( int x )
   {
     p_verbose = x;
   }

bool
SgProject::get_skip_translation_from_edg_ast_to_rose_ast (void) const
   {
  // look at how the files are set
     bool returnSkipTranslation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTranslation = returnSkipTranslation && (bool) file.get_skip_translation_from_edg_ast_to_rose_ast();
        }
     return returnSkipTranslation;
   }

bool
SgProject::get_skip_transformation (void) const
   {
  // look at how the files are set
     bool returnSkipTransformation = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipTransformation = returnSkipTransformation && (bool) file.get_skip_transformation();
        }
     return returnSkipTransformation;
   }

bool
SgProject::get_skip_unparse (void) const
   {
  // look at how the files are set
     bool returnSkipUnparse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipUnparse = returnSkipUnparse && (bool) file.get_skip_unparse();
        }
     return returnSkipUnparse;
   }

bool
SgProject::get_useBackendOnly (void) const
   {
  // look at how the files are set
     bool returnUseBackendOnly = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnUseBackendOnly = returnUseBackendOnly && (bool) file.get_useBackendOnly();
        }
     return returnUseBackendOnly;
   }

// DQ (4/6/2010): Added to support parsing only option.
bool
SgProject::get_exit_after_parser(void) const
   {
  // look at how the files are set
     bool returnExitAfterParse = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnExitAfterParse = returnExitAfterParse && (bool) file.get_exit_after_parser();
        }
     return returnExitAfterParse;
   }

bool
SgProject::get_skipfinalCompileStep (void) const
   {
  // look at how the files are set
     bool returnSkipFinalCompileStep = (numberOfFiles() > 0) ? true : false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          returnSkipFinalCompileStep = returnSkipFinalCompileStep && (bool) file.get_skipfinalCompileStep();
        }
     return returnSkipFinalCompileStep;
   }

void 
SgProject::set_C_only       (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_C_only = value;
   }

void
SgProject::set_Cxx_only     (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_Cxx_only = value;
   }

void
SgProject::set_Fortran_only (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_Fortran_only = value;
   }

bool
SgProject::get_C_only (void) const
   {
     bool result = p_C_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C_only();
        }
     return result;
   }

bool
SgProject::get_C89_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C89_only();
        }
     return result;
   }

bool
SgProject::get_C89_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C89_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C90_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C90_only();
        }
     return result;
   }

bool
SgProject::get_C90_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C90_gnu_only();
        }
     return result;
   }


bool
SgProject::get_C99_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_only();
        }
     return result;
   }

bool
SgProject::get_C99_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C99_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C11_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C11_only();
        }
     return result;
   }

bool
SgProject::get_C11_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C11_gnu_only();
        }
     return result;
   }

bool
SgProject::get_C14_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C14_only();
        }
     return result;
   }

bool
SgProject::get_C14_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_C14_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx_only (void) const
   {
     bool result = p_Cxx_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx_only();
        }
     return result;
   }

bool
SgProject::get_Cxx98_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx98_only();
        }
     return result;
   }

bool
SgProject::get_Cxx98_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx98_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx03_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx03_only();
        }
     return result;
   }

bool
SgProject::get_Cxx03_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx03_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx11_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx11_only();
        }
     return result;
   }

bool
SgProject::get_Cxx11_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx11_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx14_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx14_only();
        }
     return result;
   }

bool
SgProject::get_Cxx14_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx14_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Cxx17_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx17_only();
        }
     return result;
   }

bool
SgProject::get_Cxx17_gnu_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cxx17_gnu_only();
        }
     return result;
   }

bool
SgProject::get_Fortran_only (void) const
   {
     bool result = p_Fortran_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Fortran_only();
        }
     return result;
   }

bool
SgProject::get_F77_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F77_only();
        }
     return result;
   }

bool
SgProject::get_F90_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F90_only();
        }
     return result;
   }

bool
SgProject::get_F95_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F95_only();
        }
     return result;
   }

bool
SgProject::get_F2003_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2003_only();
        }
     return result;
   }

bool
SgProject::get_F2008_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2008_only();
        }
     return result;
   }

bool
SgProject::get_F2018_only (void) const
   {
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_F2018_only();
        }
     return result;
   }

bool
SgProject::get_CoArrayFortran_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_CoArrayFortran_only();
        }
     return result;
   }

bool
SgProject::get_PHP_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_PHP_only();
        }
     return result;
   }

bool
SgProject::get_Python_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Python_only();
        }
     return result;
   }

void
SgProject::set_Java_only (bool value)
   {
     ROSE_ASSERT(this != NULL);
     p_Java_only = value;
   }

bool
SgProject::get_Java_only (void) const
   {
  // look at how the files are set.
     bool result = p_Java_only;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Java_only();
        }
     return result;
   }

void
SgProject::set_Java_classpath (std::list<std::string> param)
   {
     p_Java_classpath = param;
   }

std::list<std::string>
SgProject::get_Java_classpath (void) const
   {
     return p_Java_classpath;
   }
   
void
SgProject::set_Java_sourcepath (std::list<std::string> param)
   {
     p_Java_sourcepath = param;
   }

std::list<std::string>
SgProject::get_Java_sourcepath (void) const
   {
     return p_Java_sourcepath;
   }
   
void
SgProject::set_Java_destdir (std::string param)
   {
     p_Java_destdir = param;
   }

std::string
SgProject::get_Java_destdir (void) const
   {
    if (p_Java_destdir == "") {
      return Rose::getWorkingDirectory();
    }
    return p_Java_destdir;
   }

void
SgProject::set_X10_only (bool value)
{
  ROSE_ASSERT(this != NULL);
  p_X10_only = value;
}

bool
SgProject::get_X10_only (void) const
{
  // look at how the files are set.
  bool result = p_X10_only;
  for (int i = 0; i < numberOfFiles(); i++)
  {
      SgFile & file = get_file(i);
      result = result || (bool) file.get_X10_only();
  }
  return result;
}

void
SgProject::set_Java_source_destdir (std::string param)
   {
     p_Java_source_destdir = param;
   }

std::string
SgProject::get_Java_source_destdir (void) const
   {
    if (p_Java_source_destdir == "") {
      return Rose::getWorkingDirectory();
    }
    return p_Java_source_destdir;
  }

bool
SgProject::get_Csharp_only (void) const
   {
  // DQ (8/25/2017): Added more language support.

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Csharp_only();
        }
     return result;
   }

bool
SgProject::get_Ada_only (void) const
   {
  // DQ (8/25/2017): Added more language support.

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Ada_only();
        }
     return result;
   }

bool
SgProject::get_Jovial_only (void) const
   {
  // DQ (8/25/2017): Added more language support.

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Jovial_only();
        }
     return result;
   }

bool
SgProject::get_Cobol_only (void) const
   {
  // DQ (8/25/2017): Added more language support.

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_Cobol_only();
        }
     return result;
   }

#if 0
// DQ (2/4/2009): This is now a data member at the SgProject and so is automatically generated asa member function.
bool
SgProject::get_binary_only (void) const
   {
  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_binary_only();
        }
     return result;
   }
#endif

void
SgProject::skipfinalCompileStep(bool value)
   {
     for (int i = 0; i < numberOfFiles(); i++)
        {
          get_file(i).set_skipfinalCompileStep(value);
        }
   }


int
SgProject::get_detect_dangling_pointers(void) const
   {
  // look at how the files are set
     int result = 0;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result | file.get_detect_dangling_pointers();
        }

     return result;
   }


void
SgProject::display ( const std::string & label ) const
   {
     mprintf ("In SgProject::display(%s) \n",label.c_str());

     mprintf ("   p_verbose                                 = %d \n",p_verbose);

     mprintf ("   p_outputFileName                          = %s \n",p_outputFileName.c_str());

     mprintf ("   p_sourceFileNameList.size()               = %" PRIuPTR " \n", p_sourceFileNameList.size());
     mprintf ("   p_sourceFileNameList                      = \n      %s \n",Rose::StringUtility::listToString(p_sourceFileNameList).c_str());

     mprintf ("   p_objectFileNameList.size()               = %" PRIuPTR " \n", p_objectFileNameList.size());
     mprintf ("   p_objectFileNameList                      = \n      %s \n",Rose::StringUtility::listToString(p_objectFileNameList).c_str());

     mprintf ("   p_libraryFileList.size()                  = %" PRIuPTR " \n", p_libraryFileList.size());
     mprintf ("   p_libraryFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_libraryFileList).c_str());

     mprintf ("   p_librarySpecifierList.size()             = %" PRIuPTR " \n", p_librarySpecifierList.size());
     mprintf ("   p_librarySpecifierList                    = \n      %s \n",Rose::StringUtility::listToString(p_librarySpecifierList).c_str());

     mprintf ("   p_libraryDirectorySpecifierList.size()    = %" PRIuPTR " \n", p_libraryDirectorySpecifierList.size());
     mprintf ("   p_libraryDirectorySpecifierList           = \n      %s \n",Rose::StringUtility::listToString(p_libraryDirectorySpecifierList).c_str());

     mprintf ("   p_includeDirectorySpecifierList.size()    = %" PRIuPTR " \n", p_includeDirectorySpecifierList.size());
     mprintf ("   p_includeDirectorySpecifierList           = \n      %s \n",Rose::StringUtility::listToString(p_includeDirectorySpecifierList).c_str());

     mprintf ("   p_compileOnly                             = %s \n",(p_compileOnly == true) ? "true" : "false");
     mprintf ("   p_prelink                                 = %s \n",(p_prelink     == true) ? "true" : "false");

     mprintf ("   p_template_instantiation_mode             = %d \n",p_template_instantiation_mode);

     mprintf ("   p_astMerge                                = %s \n",(p_astMerge == true) ? "true" : "false");
     mprintf ("   p_astMergeCommandFile                     = %s \n",p_astMergeCommandFile.c_str());
     mprintf ("   p_projectSpecificDatabaseFile             = %s \n",p_projectSpecificDatabaseFile.c_str());
     mprintf ("   p_compilationPerformanceFile              = %s \n",p_compilationPerformanceFile.c_str());

  // DQ (1/16/2008): This is part of a ROSE supported mechanism for the 
  // specification of exclude/include paths/files for interpretation by 
  // the ROSE translator.
  // mprintf ("   p_lookForIncludePaths                     = %s \n",(p_lookForIncludePaths == true) ? "true" : "false");
  // mprintf ("   p_lookForExcludePaths                     = %s \n",(p_lookForExcludePaths == true) ? "true" : "false");

     mprintf ("   p_includePathList.size()                  = %" PRIuPTR " \n", p_includePathList.size());
     mprintf ("   p_includePathList                         = \n      %s \n",Rose::StringUtility::listToString(p_includePathList).c_str());

     mprintf ("   p_excludePathList.size()                  = %" PRIuPTR " \n", p_excludePathList.size());
     mprintf ("   p_excludePathList                         = \n      %s \n",Rose::StringUtility::listToString(p_excludePathList).c_str());

     mprintf ("   p_includeFileList.size()                  = %" PRIuPTR " \n", p_includeFileList.size());
     mprintf ("   p_includeFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_includeFileList).c_str());

     mprintf ("   p_excludeFileList.size()                  = %" PRIuPTR " \n", p_excludeFileList.size());
     mprintf ("   p_excludeFileList                         = \n      %s \n",Rose::StringUtility::listToString(p_excludeFileList).c_str());

     mprintf ("   p_preincludeFileList.size()               = %" PRIuPTR " \n", p_preincludeFileList.size());
     mprintf ("   p_preincludeFileList                      = \n      %s \n",Rose::StringUtility::listToString(p_preincludeFileList).c_str());

     mprintf ("   p_preincludeDirectoryList.size()          = %" PRIuPTR " \n", p_preincludeDirectoryList.size());
     mprintf ("   p_preincludeDirectoryList                 = \n      %s \n",Rose::StringUtility::listToString(p_preincludeDirectoryList).c_str());

  // DQ (2/4/2009): Moved from SgFile to SgProject.
     mprintf ("   p_binary_only()                           = %s \n",(p_binary_only == true) ? "true" : "false");

  // DQ (9/15/2013): Added debugging support for a previously missed data member.
     mprintf ("   p_frontendConstantFolding                 = %s \n",(p_frontendConstantFolding == true) ? "true" : "false");

  // DQ (9/15/2013): Added debugging support for a new data member.
     mprintf ("   p_unparse_in_same_directory_as_input_file = %s \n",(p_unparse_in_same_directory_as_input_file == true) ? "true" : "false");

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error.
     mprintf ("   p_noclobber_output_file              = %s \n",(p_noclobber_output_file == true) ? "true" : "false");

  // DQ (3/19/2014): This option causes the output of source code to an existing file to be an error if it results in a different file.
     mprintf ("   p_noclobber_if_different_output_file = %s \n",(p_noclobber_if_different_output_file == true) ? "true" : "false");

  // Pei-Hung (8/6/2014): This option appends PID into the output name to avoid file collision in parallel compilation. 
     mprintf ("   p_appendPID = %s \n",(p_appendPID == true) ? "true" : "false");

     mprintf ("In this project: numberOfFiles() = %d \n",numberOfFiles());
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          file.display("called from SgProject::display()");
        }
   }

// Moved to sage_support.cpp: int SgProject::link ( std::string linkerName )
// Moved to sage_support.cpp: int SgProject::link ( const std::vector<std::string>& argv, std::string linkerName )

const SgStringList &
SgProject::get_includePathList () const
   {
     assert (this != NULL);
     return p_includePathList;
   }

SgStringList &
SgProject::get_includePathList ()
   {
     assert (this != NULL);
     return p_includePathList;
   }

void
SgProject::set_includePathList ( const SgStringList & includePathList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_includePathList = includePathList;
   }


const SgStringList &
SgProject::get_excludePathList () const
   {
     assert (this != NULL);
     return p_excludePathList;
   }

SgStringList &
SgProject::get_excludePathList ()
   {
     assert (this != NULL);
     return p_excludePathList;
   }

void
SgProject::set_excludePathList ( const SgStringList & excludePathList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_excludePathList = excludePathList;
   }

const SgStringList &
SgProject::get_includeFileList () const
   {
     assert (this != NULL);
     return p_includeFileList;
   }

SgStringList &
SgProject::get_includeFileList ()
   {
     assert (this != NULL);
     return p_includeFileList;
   }

void
SgProject::set_includeFileList ( const SgStringList & includeFileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_includeFileList = includeFileList;
   }


const SgStringList &
SgProject::get_excludeFileList () const
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

SgStringList &
SgProject::get_excludeFileList ()
   {
     assert (this != NULL);
     return p_excludeFileList;
   }

void
SgProject::set_excludeFileList ( const SgStringList & excludeFileList )
   {
     assert (this != NULL);
     set_isModified(true);
     
     p_excludeFileList = excludeFileList;
   }



bool
SgProject::get_unparse_tokens (void) const
   {
  // DQ (8/3/2018): Added support for evaluation of options at the project level (which are normally associated with files).

  // look at how the files are set
     bool result = false;
     for (int i = 0; i < numberOfFiles(); i++)
        {
          SgFile & file = get_file(i);
          result = result || (bool) file.get_unparse_tokens();
        }

     return result;
   }


SOURCE_APPLICATION_PROJECT_END


SOURCE_OPTIONS_START
SOURCE_OPTIONS_END


SOURCE_UNPARSE_INFO_START

// SgUnparse_Info SgNO_UNPARSE_INFO;
extern void printSgVariant(std::ostream&,int);

// DQ (1/11/2004): Remove this static member and make it a member pointer
// Declaration of static member to support unparsing complex structures
SgTypePtrList SgUnparse_Info::p_structureTagProcessingList;

/*! \brief Debugging support 

     Debugging support to test correctness of the implementation the SgUnparse_Info 
     object as an inherited attribute in the unparser.
 */
bool SgUnparse_Info::p_forceDefaultConstructorToTriggerError = false;

bool
SgUnparse_Info::get_forceDefaultConstructorToTriggerError()
   {
     return p_forceDefaultConstructorToTriggerError;
   }
 
void
SgUnparse_Info::set_forceDefaultConstructorToTriggerError( bool forceDefaultConstructorToTriggerError)
   {
     p_forceDefaultConstructorToTriggerError = forceDefaultConstructorToTriggerError;
   }
 


// Default constructor defined here because the automatically generated constructor
// would not be generated with the error checking that I require to debug the use of
// the SgUnparse_Info object as an inherited attribute in the unparser.
SgUnparse_Info::SgUnparse_Info ()
   : SgSupport()
   {
     static int counter = 0;
     counter++;

#ifdef DEBUG
     mprintf ("In SgUnparse_Info::SgUnparse_Info () sage_class_name() = %s counter = %d \n",sage_class_name(),counter);
#endif

  // Supporting error checking for test of SgUnparse_Info as an inherited attribute in the unparser
     if (p_forceDefaultConstructorToTriggerError == true)
        {
          mprintf ("SgUnparse_Info constructor called in inappropriate location (part of debugging code) counter = %d \n",counter);
#if 1
       // DQ (11/9/2009): This can be allowed to be uncommented!
          ROSE_ABORT();
#else
       // DQ (11/9/2009): Allow this to support debugging of the unparser (posabily recursive behavior) \n");
          mprintf ("Warning: Allow this to support debugging of the unparser (posabily recursive behavior) \n");
#endif
        }

  // Test the variant virtual function
     assert(Unparse_InfoTag == variant());
     post_construction_initialization();

  // mprintf ("p_unparse_attribute.size() = %" PRIuPTR " \n",p_unparse_attribute.size());
  // mprintf ("SgNO_UNPARSE_INFO.p_unparse_attribute.size() = %" PRIuPTR " \n",SgNO_UNPARSE_INFO.p_unparse_attribute.size());
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Test the isSgUnparse_Info() function since it has been problematic
     assert(isSgUnparse_Info(this) != NULL);

  // Initialize the nesting level to 0 (for python).
     p_nestingLevel = 0;
   }

// DQ (1/5/2008): I think this is a redundant function with the one in sageInterface.C
std::string
getSgVariant ( int variant )
   {
  // Return a string associated with the input variant!
  // check to make sure we have the correct variant and a valid string
     assert(variant == $GRAMMAR_NAMETerminalNames[variant].variant);

     return $GRAMMAR_NAMETerminalNames[variant].name;
   }

SgUnparse_Info::SgUnparse_Info ( const SgUnparse_Info & X )
   : SgSupport()
   {
     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     *this = X;

     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // Copy nesting level (for python).
     p_nestingLevel = X.p_nestingLevel;

  // DQ (1/10/2014): Added to support token based unparsing.
     ROSE_ASSERT(p_current_source_file == X.p_current_source_file);
  // p_current_source_file = X.p_current_source_file;
   }

SgUnparse_Info & SgUnparse_Info::operator= ( const SgUnparse_Info & X )
   {
     p_unparse_attribute = X.p_unparse_attribute;
     p_access_attribute  = X.p_access_attribute;
     p_nested_expression = X.p_nested_expression;
     p_operator_name     = X.p_operator_name;
     p_var_name          = X.p_var_name;
     p_declstatement_ptr = X.p_declstatement_ptr;
     p_current_context   = X.p_current_context;
     p_array_index_list  = X.p_array_index_list;

  // DQ (11/6/2004): aded initialization of namespace context
     p_current_namespace = X.p_current_namespace;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = X.p_outputCodeGenerationFormatDelimiters;

     assert (X.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size()   == UNPARSE_TYPE_LAST);
  // assert (SgNO_UNPARSE_INFO.p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList = X.p_qualifiedNameList;

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = X.p_current_function_call;

  // DQ (5/22/2007): Added to support name qualification and access to the new hidden 
  // type, declaration and class elaboration lists stored in the scopes.
     p_current_scope = X.p_current_scope;

  // DQ (5/11/2011): New support for name qualification.
     p_name_qualification_length     = X.p_name_qualification_length;
     p_type_elaboration_required     = X.p_type_elaboration_required;
     p_global_qualification_required = X.p_global_qualification_required;

  // DQ (5/21/2011): New support for name qualification.
     p_reference_node_for_qualification = X.p_reference_node_for_qualification;

  // DQ (9/15/2012): Added mechanism to specify the language more directly.
  // Required to know when to unparse boolean values as integer for C and C99/C++
     p_language = X.p_language;

  // DQ (1/10/2014): Added to support token based unparsing.
     p_current_source_file = X.p_current_source_file;

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template 
  // arguments as used in symbol table lookup.
     p_use_generated_name_for_template_arguments = X.p_use_generated_name_for_template_arguments;

  // DQ (12/26/2019): When supporting multiple files, the defining declaration in a named type must refer to the 
  // defining declaration associated with the appropriate file (to be unparsed correctly).
     p_declstatement_associated_with_type = X.p_declstatement_associated_with_type;

     return *this;
   }

bool
SgUnparse_Info::checkBit(unparse_type_num bit) const
   {
  // if(p_unparse_attribute & bit) return 1; else return 0;
  // bool returnValue = false;
  // if (p_unparse_attribute[bit]) 
  //      returnValue = true;
  // return returnValue;

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     return p_unparse_attribute[bit];
   }

void
SgUnparse_Info::setBit(unparse_type_num bit)
   { 
  // p_unparse_attribute |= bit; 

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = true;
   }

void
SgUnparse_Info::unsetBit(unparse_type_num bit)
   { 
  // p_unparse_attribute &= ~bit;

     assert (this != NULL);
     assert (bit > 0);
     assert (bit < UNPARSE_TYPE_LAST);
     assert (p_unparse_attribute.size() == UNPARSE_TYPE_LAST);

     p_unparse_attribute[bit] = false;
   }

void
SgUnparse_Info::post_construction_initialization()
   {
  // DQ (11/4/2003): Modified initialization from "0" to "NULL"
  // and "" for non-integer values

     assert (this != NULL);

  // Clear all bit flags
  // p_unparse_attribute = b_enum_defaultValue;
     for (int i = 0; i < UNPARSE_TYPE_LAST; i++)
        {
          p_unparse_attribute.push_back(false);
        }
     assert (p_unparse_attribute.size() > 0);

     p_access_attribute  = a_unset_access;
     p_nested_expression = false;
     p_operator_name     = "";
     p_var_name          = "";
     p_declstatement_ptr = NULL;
     p_current_context   = NULL;
     p_array_index_list  = "";

  // DQ (1/12/2003): If calling constructor then empty the list
  // constructors (except copy constructor) are only call in the 
  // initiation of a unparser traversal (precisely where there 
  // is no context yet build up).
  
  // mprintf ("p_structureTagProcessingList.size() = %" PRIuPTR " \n",p_structureTagProcessingList.size());
     if (p_structureTagProcessingList.empty() != true)
        {
       // empty the list (using STL list's assignment operator)
          SgTypePtrList emptyList;
          p_structureTagProcessingList = emptyList;
        }

  // DQ (11/6/2004): Added initialization of namespace context (error reported valgrind)
     p_current_namespace = NULL;

  // DQ (3/18/2006): Support for specification of output useful in debugging formatting
  // of generated code (unparsing).
     p_outputCodeGenerationFormatDelimiters = false;

  // DQ (10/10/2006): Added support for qualified name lists.
     p_qualifiedNameList.clear();

  // DQ (10/20/2006): Added support for function call context information.
     p_current_function_call = NULL;

  // DQ (6/2/2007): Added initialization of new data member.
     p_current_scope = NULL;

  // DQ (5/21/2011): New support for name qualification.
     p_reference_node_for_qualification = NULL;

  // DQ (5/11/2011): New support for name qualification.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;

  // DQ (12/26/2019): Added initialization.
     p_nestingLevel = 0;

  // DQ (12/26/2019): Added initialization.
     p_language = SgFile::e_default_language;

  // DQ (1/10/2014): Added to support token based unparsing.
     p_current_source_file = NULL;

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template 
  // arguments as used in symbol table lookup.
     p_use_generated_name_for_template_arguments = false;

  // DQ (12/26/2019): Added initialization.
     p_user_defined_literal = false;

  // DQ (12/26/2019): When supporting multiple files, the defining declaration in a named type must refer to the 
  // defining declaration associated with the appropriate file (to be unparsed correctly).
     p_declstatement_associated_with_type = NULL;
   }

bool
SgUnparse_Info::isUnsetAccess() const
   { return p_access_attribute == a_unset_access; }

void
SgUnparse_Info::set_isUnsetAccess()
   { p_access_attribute = a_unset_access; }

bool
SgUnparse_Info::isPrivateAccess() const
   { return p_access_attribute == a_private_access; }

void
SgUnparse_Info::set_isPrivateAccess()
   { p_access_attribute = a_private_access; }

bool
SgUnparse_Info::isProtectedAccess() const
   { return p_access_attribute == a_protected_access; }

void
SgUnparse_Info::set_isProtectedAccess()
   { p_access_attribute = a_protected_access; } 

bool
SgUnparse_Info::isPublicAccess() const
   { return p_access_attribute == a_public_access; }

void
SgUnparse_Info::set_isPublicAccess()
   { p_access_attribute = a_public_access; }  

bool
SgUnparse_Info::isPointerToSomething() const
   { return checkBit(b_isPointerToSomething); }

void
SgUnparse_Info::set_isPointerToSomething()
   { setBit(b_isPointerToSomething); }

void
SgUnparse_Info::unset_isPointerToSomething()
   { unsetBit(b_isPointerToSomething); }

bool
SgUnparse_Info::isReferenceToSomething() const
   { return checkBit(b_isReferenceToSomething); }

void
SgUnparse_Info::set_isReferenceToSomething()
   { setBit(b_isReferenceToSomething); }

void
SgUnparse_Info::unset_isReferenceToSomething()
   { unsetBit(b_isReferenceToSomething); }

bool
SgUnparse_Info::inVarDecl() const
   { return checkBit(b_inVarDecl); }

void
SgUnparse_Info::set_inVarDecl()
   { setBit(b_inVarDecl); }

void
SgUnparse_Info::unset_inVarDecl()
   { unsetBit(b_inVarDecl); }

bool
SgUnparse_Info::inArgList() const
   { return checkBit(b_inArgList); }

void
SgUnparse_Info::set_inArgList()
   { setBit(b_inArgList); }

void
SgUnparse_Info::unset_inArgList()
   { unsetBit(b_inArgList); }

bool
SgUnparse_Info::SkipSemiColon() const
   { return checkBit(b_SkipSemiColon); }

void
SgUnparse_Info::set_SkipSemiColon()
   { setBit(b_SkipSemiColon); }

void
SgUnparse_Info::unset_SkipSemiColon()
   { unsetBit(b_SkipSemiColon); }

bool
SgUnparse_Info::inEnumDecl() const
   { return checkBit(b_inEnumDecl); }

void
SgUnparse_Info::set_inEnumDecl()
   { setBit(b_inEnumDecl); }

void
SgUnparse_Info::unset_inEnumDecl()
   { unsetBit(b_inEnumDecl); }

bool
SgUnparse_Info::inTemplateList() const
   { return checkBit(b_inTemplateList); }

void
SgUnparse_Info::set_inTemplateList()
   { setBit(b_inTemplateList); }

void
SgUnparse_Info::unset_inTemplateList()
   { unsetBit(b_inTemplateList); }

bool
SgUnparse_Info::SkipBaseType() const
   { return checkBit(b_SkipBaseType); }

void
SgUnparse_Info::set_SkipBaseType()
   { setBit(b_SkipBaseType); }

void
SgUnparse_Info::unset_SkipBaseType()
   { unsetBit(b_SkipBaseType); }

bool
SgUnparse_Info::inAggregateInitializer() const
   { return checkBit(b_inAggregateInitializer); }

void
SgUnparse_Info::set_inAggregateInitializer()
   { setBit(b_inAggregateInitializer); }

void
SgUnparse_Info::unset_inAggregateInitializer()
   { unsetBit(b_inAggregateInitializer); }

bool
SgUnparse_Info::isWithType() const
   { return checkBit(b_isWithType); }

void
SgUnparse_Info::set_isWithType()
   { setBit(b_isWithType); }

void
SgUnparse_Info::unset_isWithType()
   { unsetBit(b_isWithType); }

bool
SgUnparse_Info::inConditional() const
   { return checkBit(b_inConditional); }

void
SgUnparse_Info::set_inConditional()
   { setBit(b_inConditional); }

void
SgUnparse_Info::unset_inConditional()
   { unsetBit(b_inConditional); }

// DQ (1/23/03) Modified use of SkipDefinition to separate the functionality across
// different types of definitions (Enum, Function, and Class definitions).
bool
SgUnparse_Info::SkipDefinition() const
   { // return checkBit(b_SkipDefinition);
     return checkBit(b_SkipEnumDefinition) && 
            checkBit(b_SkipFunctionDefinition) && 
            checkBit(b_SkipClassDefinition);
   }

void
SgUnparse_Info::set_SkipDefinition()
   { 
  // setBit(b_SkipDefinition); 
     setBit(b_SkipEnumDefinition); 
     setBit(b_SkipFunctionDefinition); 
     setBit(b_SkipClassDefinition); 
   }

void
SgUnparse_Info::unset_SkipDefinition()
   {
  // unsetBit(b_SkipDefinition);
     unsetBit(b_SkipEnumDefinition);
     unsetBit(b_SkipFunctionDefinition);
     unsetBit(b_SkipClassDefinition);
   }

bool
SgUnparse_Info::SkipClassSpecifier() const
   { return checkBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::set_SkipClassSpecifier()
   { setBit(b_SkipClassSpecifier); }

void
SgUnparse_Info::unset_SkipClassSpecifier()
   { unsetBit(b_SkipClassSpecifier); }

bool
SgUnparse_Info::inEmbeddedDecl() const
   { return checkBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::set_inEmbeddedDecl()
   { setBit(b_inEmbeddedDecl); }

void
SgUnparse_Info::unset_inEmbeddedDecl()
   { unsetBit(b_inEmbeddedDecl); }

bool
SgUnparse_Info::SkipGlobal() const
   { return checkBit(b_SkipGlobal); }

void
SgUnparse_Info::set_SkipGlobal()
   { setBit(b_SkipGlobal); }

void
SgUnparse_Info::unset_SkipGlobal()
   { unsetBit(b_SkipGlobal); }

bool
SgUnparse_Info::SkipAtomic() const
   { return checkBit(b_SkipAtomic); }

void
SgUnparse_Info::set_SkipAtomic()
   { setBit(b_SkipAtomic); }

void
SgUnparse_Info::unset_SkipAtomic()
   { unsetBit(b_SkipAtomic); }

bool
SgUnparse_Info::PrintName() const
   { return checkBit(b_PrintName); }

void
SgUnparse_Info::set_PrintName()
   {
#if 0
     mprintf ("p_var_name.is_null() = %s p_var_name = %s \n",p_var_name.is_null() ? "true" : "false",p_var_name.str());

  // This is the older version of the code (dependent on an internal variable that was easy to forget to set).
     if(!p_var_name.is_null())
        {
          setBit(b_PrintName); 
        }
       else
        {
          mprintf ("PrintName is not set! \n");
        }
#else
  // DQ (7/30/2012): I like this simpler semantics better.
     setBit(b_PrintName);
#endif
#if 0
     mprintf ("Leaving set_PrintName(): PrintName() = %s \n",PrintName() ? "true" : "false");
#endif
   }

void
SgUnparse_Info::unset_PrintName()
   { unsetBit(b_PrintName); }

bool
SgUnparse_Info::CheckAccess() const
   { return checkBit(b_CheckAccess); }

void
SgUnparse_Info::set_CheckAccess()
   { setBit(b_CheckAccess); }

void
SgUnparse_Info::unset_CheckAccess()
   { unsetBit(b_CheckAccess); }

bool
SgUnparse_Info::SkipFunctionQualifier() const
   { return checkBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::set_SkipFunctionQualifier()
   { setBit(b_SkipFunctionQualifier); }

void
SgUnparse_Info::unset_SkipFunctionQualifier()
   { unsetBit(b_SkipFunctionQualifier); }

bool
SgUnparse_Info::isArrayType() const
   { return checkBit(b_isArrayType); }

void
SgUnparse_Info::set_isArrayType()
   { setBit(b_isArrayType); }

void
SgUnparse_Info::unset_isArrayType()
   { unsetBit(b_isArrayType); }

bool
SgUnparse_Info::inRhsExpr() const
   { return checkBit(b_inRhsExpr); }

void
SgUnparse_Info::set_inRhsExpr()
   { setBit(b_inRhsExpr); }

void
SgUnparse_Info::unset_inRhsExpr()
   { unsetBit(b_inRhsExpr); }

bool
SgUnparse_Info::SkipParen() const
   { return checkBit(b_SkipParen); }

void
SgUnparse_Info::set_SkipParen()
   { setBit(b_SkipParen); }

void
SgUnparse_Info::unset_SkipParen()
   { unsetBit(b_SkipParen); }

bool
SgUnparse_Info::isTypeSecondPart() const
   { return checkBit(b_isTypeSecondPart); }

void
SgUnparse_Info::set_isTypeSecondPart()  
   { setBit(b_isTypeSecondPart); unsetBit(b_isTypeFirstPart); }

void
SgUnparse_Info::unset_isTypeSecondPart()
   { unsetBit(b_isTypeSecondPart); }

bool
SgUnparse_Info::isTypeFirstPart() const
   { return checkBit(b_isTypeFirstPart); }

void
SgUnparse_Info::set_isTypeFirstPart()  
   { setBit(b_isTypeFirstPart); unsetBit(b_isTypeSecondPart); }

void
SgUnparse_Info::unset_isTypeFirstPart()
   { unsetBit( b_isTypeFirstPart); }

std::string
SgUnparse_Info::get_operator_name()
   { return p_operator_name; }

void
SgUnparse_Info::set_operator_name(const std::string& on)
   {
     p_operator_name = on;
   }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipInitializer() const
   { return checkBit(b_SkipInitializer); }

void
SgUnparse_Info::set_SkipInitializer()
   { setBit(b_SkipInitializer); }

void
SgUnparse_Info::unset_SkipInitializer()
   { unsetBit(b_SkipInitializer); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipComments() const
   { return checkBit(b_SkipComments); }

void
SgUnparse_Info::set_SkipComments()
   { setBit(b_SkipComments); }

void
SgUnparse_Info::unset_SkipComments()
   { unsetBit(b_SkipComments); }

//! (09/03/03) MS: Added to make whitespace optional
bool
SgUnparse_Info::SkipWhitespaces() const
   { return checkBit(b_SkipWhitespaces); }

void
SgUnparse_Info::set_SkipWhitespaces()
   { setBit(b_SkipWhitespaces); }

void
SgUnparse_Info::unset_SkipWhitespaces()
   { unsetBit(b_SkipWhitespaces); }

//! (1/15/03) DQ: Added to support use of unparser in rewrite mechanism
bool
SgUnparse_Info::SkipCPPDirectives() const
   { return checkBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::set_SkipCPPDirectives()
   { setBit(b_SkipCPPDirectives); }

void
SgUnparse_Info::unset_SkipCPPDirectives()
   { unsetBit(b_SkipCPPDirectives); }

bool
SgUnparse_Info::SkipEnumDefinition() const
   { return checkBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::set_SkipEnumDefinition()
   { setBit(b_SkipEnumDefinition); }

void
SgUnparse_Info::unset_SkipEnumDefinition()
   { unsetBit(b_SkipEnumDefinition); }

bool
SgUnparse_Info::SkipFunctionDefinition() const
   { return checkBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::set_SkipFunctionDefinition()
   { setBit(b_SkipFunctionDefinition); }

void
SgUnparse_Info::unset_SkipFunctionDefinition()
   { unsetBit(b_SkipFunctionDefinition); }

bool
SgUnparse_Info::SkipClassDefinition() const
   { return checkBit(b_SkipClassDefinition); }

void
SgUnparse_Info::set_SkipClassDefinition()
   { setBit(b_SkipClassDefinition); }

void
SgUnparse_Info::unset_SkipClassDefinition()
   { unsetBit(b_SkipClassDefinition); }

bool
SgUnparse_Info::AddSemiColonAfterDeclaration() const
   { return checkBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::set_AddSemiColonAfterDeclaration()
   { setBit(b_AddSemiColonAfterDeclaration); }

void
SgUnparse_Info::unset_AddSemiColonAfterDeclaration()
   { unsetBit(b_AddSemiColonAfterDeclaration); }

bool
SgUnparse_Info::SkipBasicBlock() const
   { return checkBit(b_SkipBasicBlock); }

void
SgUnparse_Info::set_SkipBasicBlock()
   { setBit(b_SkipBasicBlock); }

void
SgUnparse_Info::unset_SkipBasicBlock()
   { unsetBit(b_SkipBasicBlock); }

// DQ (3/18/2004): Added to support unparsing of class templates in variables but 
// not in in instatiated template declarations (unless the template is transformed 
// in which case another test is used).
bool
SgUnparse_Info::outputClassTemplateName() const
   { return checkBit(b_outputClassTemplateName); }

void
SgUnparse_Info::set_outputClassTemplateName()
   { setBit(b_outputClassTemplateName); }

void
SgUnparse_Info::unset_outputClassTemplateName()
   { unsetBit(b_outputClassTemplateName); }

// DQ (5/27/2005): support (see documentation above, in header file enum value)
bool
SgUnparse_Info::outputCompilerGeneratedStatements() const
   { return checkBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::set_outputCompilerGeneratedStatements()
   { setBit(b_outputCompilerGeneratedStatements); }

void
SgUnparse_Info::unset_outputCompilerGeneratedStatements()
   { unsetBit(b_outputCompilerGeneratedStatements); }


// DQ (4/5/2006): Added support for constant folded values to be optionally output
bool
SgUnparse_Info::SkipConstantFoldedExpressions() const
   { return checkBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::set_SkipConstantFoldedExpressions()
   { setBit(b_SkipConstantFoldedExpressions); }

void
SgUnparse_Info::unset_SkipConstantFoldedExpressions()
   { unsetBit(b_SkipConstantFoldedExpressions); }


// DQ and PC (6/1/2006): Added Peter's suggested fixes to support unparsing fully qualified names.
bool
SgUnparse_Info::forceQualifiedNames() const
   { return checkBit(b_forceQualifiedNames); }

void
SgUnparse_Info::set_forceQualifiedNames()
   { setBit(b_forceQualifiedNames); }

void
SgUnparse_Info::unset_forceQualifiedNames()
   { unsetBit(b_forceQualifiedNames); }

bool
SgUnparse_Info::skipCheckAccess() const
   { return checkBit(b_skipCheckAccess); }

void
SgUnparse_Info::set_skipCheckAccess()
   { setBit(b_skipCheckAccess); }

void
SgUnparse_Info::unset_skipCheckAccess()
   { unsetBit(b_skipCheckAccess); }

// DQ (10/11/2006): Added to support new implementation of name qualification
bool
SgUnparse_Info::SkipQualifiedNames() const
   { return checkBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::set_SkipQualifiedNames()
   { setBit(b_SkipQualifiedNames); }

void
SgUnparse_Info::unset_SkipQualifiedNames()
   { unsetBit(b_SkipQualifiedNames); }

bool
SgUnparse_Info::requiresGlobalNameQualification() const
   { return checkBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::set_requiresGlobalNameQualification()
   { setBit(b_requiresGlobalNameQualification); }

void
SgUnparse_Info::unset_requiresGlobalNameQualification()
   { unsetBit(b_requiresGlobalNameQualification); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
bool
SgUnparse_Info::useTypeAttributes() const
   { return checkBit(b_useTypeAttributes); }

void
SgUnparse_Info::set_useTypeAttributes()
   { setBit(b_useTypeAttributes); }

void
SgUnparse_Info::unset_useTypeAttributes()
   { unsetBit(b_useTypeAttributes); }

// DQ (12/26/2007): Added support to restrict formatting of Fortran code.
// This allows us to put statements on the same line as if-stmt, where-stmt, etc.
// Plus it allows us to skip the insertion of leading 6 spaces in fixed format output.
bool
SgUnparse_Info::SkipFormatting() const
   { return checkBit(b_SkipFormatting); }

void
SgUnparse_Info::set_SkipFormatting()
   { setBit(b_SkipFormatting); }

void
SgUnparse_Info::unset_SkipFormatting()
   { unsetBit(b_SkipFormatting); }

// DQ (9/22/2007): Added optional handling of Fortran type attributes, these may have to be setup for each different kind of type attribute.
bool
SgUnparse_Info::supressStrippedTypeName() const
   { return checkBit(b_supressStrippedTypeName); }

void
SgUnparse_Info::set_supressStrippedTypeName()
   { setBit(b_supressStrippedTypeName); }

void
SgUnparse_Info::unset_supressStrippedTypeName()
   { unsetBit(b_supressStrippedTypeName); }


SgName&
SgUnparse_Info::get_name()
   { return p_var_name; }

void
SgUnparse_Info::set_name(const SgName& name)
   { p_var_name = name; set_PrintName(); }

void
SgUnparse_Info::unset_name()
   {
     unset_PrintName(); 
     p_var_name=0;
   }

SgDeclarationStatement*
SgUnparse_Info::get_decl_stmt()
   { return p_declstatement_ptr; }

void
SgUnparse_Info::set_decl_stmt(SgDeclarationStatement* stmt )
   { p_declstatement_ptr = stmt; }

void
SgUnparse_Info::unset_decl_stmt()
   { p_declstatement_ptr=0; }

int
SgUnparse_Info::get_nested_expression()
   { return p_nested_expression; }

void
SgUnparse_Info::set_nested_expression()
   { p_nested_expression++; }

void
SgUnparse_Info::unset_nested_expression()
   { p_nested_expression--; }

void
SgUnparse_Info::unset_current_context()
   { p_current_context = NULL; }

SgName
SgUnparse_Info::get_array_index_list()
{ return p_array_index_list; }

void
SgUnparse_Info::set_array_index_list(SgExpression *e, SgUnparse_Info finfo )
   {
#if 1
     mprintf ("ERROR: not implemented in SAGE3! \n");
     ROSE_ABORT();
#else
     p_array_index_list << "[";
     ostringstream buffer;
     if(e) e->unparse(finfo,buffer);
     p_array_index_list << buffer.str() << "]";
#endif
   }

void
SgUnparse_Info::unset_array_index_list()
   { p_array_index_list=0; }

// FMZ : Added to support to generated XX.rose_mod file for a module
//       (based on fortran unparser).
bool
SgUnparse_Info::outputFortranModFile() const
   { return checkBit(b_outputFortranModFile); }

void
SgUnparse_Info::set_outputFortranModFile()
   { setBit(b_outputFortranModFile); }

void
SgUnparse_Info::unset_outputFortranModFile()
   { unsetBit(b_outputFortranModFile); }


// DQ (4/13/2013): Added support to mark overloaded operators as prefix operators so they can be unparsed before the lhs.
bool
SgUnparse_Info::isPrefixOperator() const
   { return checkBit(b_prefixOperator); }

void
SgUnparse_Info::set_prefixOperator()
   { setBit(b_prefixOperator); }

void
SgUnparse_Info::unset_prefixOperator()
   { unsetBit(b_prefixOperator); }

// DQ (2/2/2014): Supress output of array bound in array type.  Used to support array declearations with empty bracket syntax (e.g. int array[];).
bool SgUnparse_Info::supressArrayBound() const
   { return checkBit(b_supressArrayBound); }

void SgUnparse_Info::set_supressArrayBound()
   { setBit(b_supressArrayBound); }

void SgUnparse_Info::unset_supressArrayBound()
   { unsetBit(b_supressArrayBound); }


// DQ (9/3/2014): Supress output of this operator where compiler generated (required to support lambda function code generation).
bool SgUnparse_Info::supressImplicitThisOperator() const
   { return checkBit(b_supressImplicitThisOperator); }

void SgUnparse_Info::set_supressImplicitThisOperator()
   { setBit(b_supressImplicitThisOperator); }

void SgUnparse_Info::unset_supressImplicitThisOperator()
   { unsetBit(b_supressImplicitThisOperator); }

// DQ (12/5/2014): Record that the statement was partially unparsed using the token stream.
bool SgUnparse_Info::unparsedPartiallyUsingTokenStream() const
   { return checkBit(b_unparsedPartiallyUsingTokenStream); }

void SgUnparse_Info::set_unparsedPartiallyUsingTokenStream()
   { setBit(b_unparsedPartiallyUsingTokenStream); }

void SgUnparse_Info::unset_unparsedPartiallyUsingTokenStream()
   { unsetBit(b_unparsedPartiallyUsingTokenStream); }

// DQ (3/25/2015): This is the support required for the offsetof() function family (__offsetof(), __builtin_offsetof(), etc.).
bool SgUnparse_Info::skipCompilerGeneratedSubExpressions() const
   { return checkBit(b_skipCompilerGeneratedSubExpressions); }

void SgUnparse_Info::set_skipCompilerGeneratedSubExpressions()
   { setBit(b_skipCompilerGeneratedSubExpressions); }

void SgUnparse_Info::unset_skipCompilerGeneratedSubExpressions()
   { unsetBit(b_skipCompilerGeneratedSubExpressions); }

// DQ (11/15/2015): Token-based unparsing support for partial token sequence unparsing of lists of statements (controls fromatting).
bool SgUnparse_Info::parentStatementListBeingUnparsedUsingPartialTokenSequence() const
   { return checkBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

void SgUnparse_Info::set_parentStatementListBeingUnparsedUsingPartialTokenSequence()
   { setBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

void SgUnparse_Info::unset_parentStatementListBeingUnparsedUsingPartialTokenSequence()
   { unsetBit(b_parentStatementListBeingUnparsedUsingPartialTokenSequence); }

// DQ (2/8/2016): Adding support for C++11 specific initialization lists.
bool
SgUnparse_Info::get_cxx11_initialization_list() const
   { return checkBit(b_cxx11_initialization_list); }

void
SgUnparse_Info::set_cxx11_initialization_list()
   { setBit(b_cxx11_initialization_list); }

void
SgUnparse_Info::unset_cxx11_initialization_list()
   { unsetBit(b_cxx11_initialization_list); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
bool
SgUnparse_Info::inTypedefDecl() const
   { return checkBit(b_inTypedefDecl); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
void
SgUnparse_Info::set_inTypedefDecl()
   { setBit(b_inTypedefDecl); }

// DQ (2/3/2019): We need to record when we are in a typedef declaration so that when a member pointer base type is used, extra parenthesis can be unparsed).
void
SgUnparse_Info::unset_inTypedefDecl()
   { unsetBit(b_inTypedefDecl); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
bool
SgUnparse_Info::SkipNameQualification() const
   { return checkBit(b_SkipNameQualification); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
void
SgUnparse_Info::set_SkipNameQualification()
   { setBit(b_SkipNameQualification); }

// DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
void
SgUnparse_Info::unset_SkipNameQualification()
   { unsetBit(b_SkipNameQualification); }

// DQ (12/26/2019): unparsing for defining declarations in named types defined in multiple translation units (multi-file support).
bool
SgUnparse_Info::useAlternativeDefiningDeclaration() const
   { return checkBit(b_useAlternativeDefiningDeclaration); }

void
SgUnparse_Info::set_useAlternativeDefiningDeclaration()
   { setBit(b_useAlternativeDefiningDeclaration); }

void
SgUnparse_Info::unset_useAlternativeDefiningDeclaration()
   { unsetBit(b_useAlternativeDefiningDeclaration); }


void
SgUnparse_Info::display ( const std::string & label ) const
   {
     mprintf ("\nInside of SgUnparse_Info::display(%s) \n",label.c_str());

#if 0
#define PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) mprintf (#XX" = %s \n",(XX() == true) ? "true" : "false");

     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     PRINT_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)
#else
  // DQ: Note that this provides better formatting of the output!
     mprintf ("isPointerToSomething                   = %s \n",( isPointerToSomething() == true ) ? "true" : "false");
     mprintf ("isReferenceToSomething                 = %s \n",( isReferenceToSomething() == true ) ? "true" : "false");
     mprintf ("inVarDecl                              = %s \n",( inVarDecl() == true ) ? "true" : "false");
     mprintf ("inArgList                              = %s \n",( inArgList() == true ) ? "true" : "false");
     mprintf ("SkipSemiColon                          = %s \n",( SkipSemiColon() == true ) ? "true" : "false");
     mprintf ("inEnumDecl                             = %s \n",( inEnumDecl() == true ) ? "true" : "false");
     mprintf ("inTemplateList                         = %s \n",( inTemplateList() == true ) ? "true" : "false");
     mprintf ("SkipBaseType                           = %s \n",( SkipBaseType() == true ) ? "true" : "false");
     mprintf ("inAggregateInitializer                 = %s \n",( inAggregateInitializer() == true ) ? "true" : "false");
     mprintf ("isWithType                             = %s \n",( isWithType() == true ) ? "true" : "false");
     mprintf ("inConditional                          = %s \n",( inConditional() == true ) ? "true" : "false");
     mprintf ("SkipDefinition                         = %s \n",( SkipDefinition() == true ) ? "true" : "false");
     mprintf ("SkipClassSpecifier                     = %s \n",( SkipClassSpecifier() == true ) ? "true" : "false");
     mprintf ("inEmbeddedDecl                         = %s \n",( inEmbeddedDecl() == true ) ? "true" : "false");
     mprintf ("SkipGlobal                             = %s \n",( SkipGlobal() == true ) ? "true" : "false");
     mprintf ("SkipAtomic                             = %s \n",( SkipAtomic() == true ) ? "true" : "false");
     mprintf ("PrintName                              = %s \n",( PrintName() == true ) ? "true" : "false");
     mprintf ("CheckAccess                            = %s \n",( CheckAccess() == true ) ? "true" : "false");
     mprintf ("SkipFunctionQualifier                  = %s \n",( SkipFunctionQualifier() == true ) ? "true" : "false");
     mprintf ("isArrayType                            = %s \n",( isArrayType() == true ) ? "true" : "false");
     mprintf ("inRhsExpr                              = %s \n",( inRhsExpr() == true ) ? "true" : "false");
     mprintf ("SkipParen                              = %s \n",( SkipParen() == true ) ? "true" : "false");
     mprintf ("isTypeSecondPart                       = %s \n",( isTypeSecondPart() == true ) ? "true" : "false");
     mprintf ("isTypeFirstPart                        = %s \n",( isTypeFirstPart() == true ) ? "true" : "false");
     mprintf ("SkipInitializer                        = %s \n",( SkipInitializer() == true ) ? "true" : "false");
     mprintf ("SkipComments                           = %s \n",( SkipComments() == true ) ? "true" : "false");
     mprintf ("SkipCPPDirectives                      = %s \n",( SkipCPPDirectives() == true ) ? "true" : "false");
     mprintf ("SkipEnumDefinition                     = %s \n",( SkipEnumDefinition() == true ) ? "true" : "false");
     mprintf ("SkipFunctionDefinition                 = %s \n",( SkipFunctionDefinition() == true ) ? "true" : "false");
     mprintf ("SkipClassDefinition                    = %s \n",( SkipClassDefinition() == true ) ? "true" : "false");
     mprintf ("AddSemiColonAfterDeclaration           = %s \n",( AddSemiColonAfterDeclaration() == true ) ? "true" : "false");
     mprintf ("SkipWhitespaces                        = %s \n",( SkipWhitespaces() == true ) ? "true" : "false");
     mprintf ("SkipBasicBlock                         = %s \n",( SkipBasicBlock() == true ) ? "true" : "false");
     mprintf ("outputClassTemplateName                = %s \n",( outputClassTemplateName() == true ) ? "true" : "false");
     mprintf ("outputCompilerGeneratedStatements      = %s \n",( outputCompilerGeneratedStatements() == true ) ? "true" : "false");
     mprintf ("SkipConstantFoldedExpressions          = %s \n",( SkipConstantFoldedExpressions() == true ) ? "true" : "false");
     mprintf ("forceQualifiedNames                    = %s \n",( forceQualifiedNames() == true ) ? "true" : "false");
     mprintf ("SkipQualifiedNames                     = %s \n",( SkipQualifiedNames() == true ) ? "true" : "false");
     mprintf ("skipCheckAccess                        = %s \n",( skipCheckAccess() == true ) ? "true" : "false");
     mprintf ("requiresGlobalNameQualification        = %s \n",( requiresGlobalNameQualification() == true ) ? "true" : "false");
     mprintf ("supressArrayBound                      = %s \n",( supressArrayBound() == true ) ? "true" : "false");
     mprintf ("supressImplicitThisOperator            = %s \n",( supressImplicitThisOperator() == true ) ? "true" : "false");
     mprintf ("unparsedPartiallyUsingTokenStream      = %s \n",( unparsedPartiallyUsingTokenStream() == true ) ? "true" : "false");
     mprintf ("skipCompilerGeneratedSubExpressions    = %s \n",( skipCompilerGeneratedSubExpressions() == true ) ? "true" : "false");

     mprintf ("parentStatementListBeingUnparsedUsingPartialTokenSequence = %s \n",( parentStatementListBeingUnparsedUsingPartialTokenSequence() == true ) ? "true" : "false");

  // DQ (2/3/2019): Ading support to know when we are in a typedef.
     mprintf ("inTypedefDecl                          = %s \n",( inTypedefDecl() == true ) ? "true" : "false");

  // DQ (4/13/2019): unparsing for generated template instantiations need to sometime skip the initial name qualification.
     mprintf ("SkipNameQualification                  = %s \n",( SkipNameQualification() == true ) ? "true" : "false");
#endif

     switch (p_access_attribute)
        {
          case a_unset_access:
               mprintf ("p_access                               = unset access \n");
               break;
          case a_private_access:
               mprintf ("p_access                               = private access \n");
               break;
          case a_protected_access:
               mprintf ("p_access                               = protected access \n");
               break;
          case a_public_access:
               mprintf ("p_access                               = public access \n");
               break;
          default:
               mprintf ("Error: default reached in switch \n");
               assert(false);
        }

  // DQ (1/26/2006): Modified to handle 64 bit machines
     mprintf ("p_structureTagProcessingList.size()    = %" PRIuPTR " \n", p_structureTagProcessingList.size());
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          mprintf ("--- structure tag pointer = %p class name = %s \n",*i,(*i)->sage_class_name());

          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               mprintf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     mprintf ("p_nested_expression                    = %d \n",p_nested_expression);
     mprintf ("p_operator_name                        = %s \n", p_operator_name.c_str());
     mprintf ("p_var_name                             = %s \n",(p_var_name.is_null() == false) ? p_var_name.str() : "EmPtY sTrInG");

  // mprintf ("p_declstatement_ptr                    = %p \n",p_declstatement_ptr);
     mprintf ("p_declstatement_ptr                    = %p = %s \n",p_declstatement_ptr,p_declstatement_ptr != NULL ? p_declstatement_ptr->class_name().c_str() : "null");
     if (p_declstatement_ptr != NULL)
        {
          mprintf ("   --- firstNondefiningDeclaration = %p \n",p_declstatement_ptr->get_firstNondefiningDeclaration());
          mprintf ("   --- definingDeclaration         = %p \n",p_declstatement_ptr->get_definingDeclaration());
        }

     mprintf ("p_current_context                      = %p \n",p_current_context);
     mprintf ("p_array_index_list                     = %s \n",(p_array_index_list.is_null() == false) ? p_array_index_list.str() : "EmPtY sTrInG");
     mprintf ("p_current_namespace                    = %p \n",p_current_namespace);
     mprintf ("p_outputCodeGenerationFormatDelimiters = %s \n",p_outputCodeGenerationFormatDelimiters ? "true" : "false");

     mprintf ("p_current_function_call                = %p \n",p_current_function_call);
     mprintf ("p_current_scope                        = %p = %s \n",p_current_scope,p_current_scope != NULL ? p_current_scope->class_name().c_str() : "EmPtY sTrInG");

  // DQ (5/21/2011): Added support for name qualification...
     mprintf ("p_reference_node_for_qualification     = %p = %s \n",p_reference_node_for_qualification,p_reference_node_for_qualification != NULL ? p_reference_node_for_qualification->class_name().c_str() : "EmPtY sTrInG");

     mprintf ("p_language (value)                     = %d \n",p_language);

  // DQ (9/24/2013): Added function to output the name of the language for the generated code.
     mprintf ("p_language (name)                      = %s \n",SgFile::get_outputLanguageOptionName(p_language).c_str());

  // DQ (1/10/2015): Added support for debugging the SgUnparse_Info object.
     mprintf ("p_current_source_file                  = %p = %s \n",p_current_source_file,p_current_source_file != NULL ? p_current_source_file->class_name().c_str() : "EmPtY sTrInG");

  // DQ (10/23/2018): Output the name of the file to support debugging of the token based unparsing.
     if (p_current_source_file != NULL)
        {
          mprintf ("   --- p_current_source_file = %s \n",p_current_source_file->getFileName().c_str());
        }

  // DQ (4/28/2017): Added information required for use of generated names in the output of types for template 
  // arguments as used in symbol table lookup.
     mprintf ("p_use_generated_name_for_template_arguments = %s \n",p_use_generated_name_for_template_arguments ? "true" : "false");
   }

string
SgUnparse_Info::displayString ( const std::string & label ) const
   {
  // using namespace std;
     std::string returnString = std::string("Inside of SgUnparse_Info::display( ") + label + std::string(" )\n");

#define STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(XX) \
     returnString += std::string("     ") + std::string(#XX) + std::string(" = ") + std::string((XX() == true) ? "true" : "false") + std::string(" \n");

     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isPointerToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isReferenceToSomething)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inVarDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inArgList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipSemiColon)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEnumDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTemplateList)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipBaseType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inAggregateInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isWithType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inConditional)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassSpecifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inEmbeddedDecl)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipGlobal)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipAtomic)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(PrintName)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(CheckAccess)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionQualifier)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isArrayType)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inRhsExpr)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipParen)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeSecondPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(isTypeFirstPart)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipInitializer)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipComments)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipCPPDirectives)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipEnumDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipFunctionDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(SkipClassDefinition)
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(AddSemiColonAfterDeclaration)

  // DQ (2/3/2019): Adding support to know when we are in a typedef.
     STRINGIFY_INFO_MEMBER_DATA_OUTPUT_MACRO(inTypedefDecl)

     switch (p_access_attribute)
        {
          case a_unset_access:
               returnString += std::string("p_access = unset access \n");
               break;
          case a_private_access:
               returnString += std::string("p_access = private access \n");
               break;
          case a_protected_access:
               returnString += std::string("p_access = protected access \n");
               break;
          case a_public_access:
               returnString += std::string("p_access = public access \n");
               break;
          default:
               printf("Error: default reached in switch \n");
               assert(false);
        }

     returnString += std::string("p_structureTagProcessingList.size() = ") + 
                     Rose::StringUtility::numberToString(p_structureTagProcessingList.size()) + std::string("\n");
     SgTypePtrList::iterator i;
     for (i = p_structureTagProcessingList.begin(); i != p_structureTagProcessingList.end(); i++)
        {
       // print out the pointer values
          returnString += std::string("--- structure tag pointer = ") + 
                          Rose::StringUtility::numberToString((void*)(*i)) + 
                          std::string("= class name = ") + std::string((*i)->sage_class_name()) + std::string("\n");
          SgClassType* classType = isSgClassType(*i);
          if (classType != NULL)
             {
               returnString += std::string("     Class name = ") + std::string(classType->get_name().str()) + std::string("\n");
            // mprintf ("     Class name = %s \n",classType->get_name().str());
            // ROSE_ABORT();
             }
        }

     return returnString;
   }

void
SgUnparse_Info::addStructureTag ( SgNamedType* structureTag )
   {
  // push the pointer to the back of the list
     p_structureTagProcessingList.push_back(structureTag);
   }

SgTypePtrList &
SgUnparse_Info::getStructureTagList ()
   {
  // Access function for internal STL list
     return p_structureTagProcessingList;
   }

void
SgUnparse_Info::inc_nestingLevel() {
    p_nestingLevel += 1;
}

void
SgUnparse_Info::dec_nestingLevel() {
    p_nestingLevel -= 1;
    if (p_nestingLevel < 0) {
        cerr << "warning: SgUnparse_Info.p_nestingLevel decremented below zero." << endl;
    }
}

SOURCE_UNPARSE_INFO_END

HEADER_TYPEDEF_SEQ_START         
      // Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
      //! This is the const STL container access function for the STL list of typedef types using the type pointing to this SgTypedefSeq.
          const SgTypePtrList & get_typedefs() const;

      // Get the list of input types (types of the parameters list) to this function type
      //! This is the non-const STL container access function for the STL list of typedef types using the type pointing to this SgTypedefSeq.
          SgTypePtrList & get_typedefs();

      //! Append new typedef to typedef type list
          void append_typedef( SgType* what);

      //! Insert new typedef to typedef type list
          void insert_typedef(const SgTypePtrList::iterator& where, SgType* what);

HEADER_TYPEDEF_SEQ_END

SOURCE_TYPEDEF_SEQ_START
const SgTypePtrList & 
$CLASSNAME::get_typedefs() const 
   { return p_typedefs; }

SgTypePtrList & 
$CLASSNAME::get_typedefs() 
   { return p_typedefs; }

void
$CLASSNAME::append_typedef( SgType* what) 
   {
     insert_typedef(p_typedefs.end(),what);
   }

void
$CLASSNAME::insert_typedef(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_typedefs.insert(where,what);
   }
SOURCE_TYPEDEF_SEQ_END


HEADER_FUNCTION_PARAMETER_TYPE_LIST_START
      //! Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
          const SgTypePtrList & get_arguments() const;

      //! Get the list of input types (types of the parameters list) to this function type
          SgTypePtrList & get_arguments();

       // WAS: void append_argument(const SgTypePtr& what);
       // WAS: void insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)

      //! Append new argument to argument type list
          void append_argument( SgType* what);

      //! Insert new argument to argument type list
          void insert_argument(const SgTypePtrList::iterator& where, SgType* what);

       // DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
          SgFunctionParameterTypeList();

HEADER_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_FUNCTION_PARAMETER_TYPE_LIST_START
const SgTypePtrList & 
$CLASSNAME::get_arguments() const 
   { return p_arguments; }

SgTypePtrList & 
$CLASSNAME::get_arguments() 
   { return p_arguments; }

void
$CLASSNAME::append_argument( SgType* what) 
   {
     insert_argument(p_arguments.end(),what);
   }

void
$CLASSNAME::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
  // WAS: void SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)
  // mprintf ("ERROR (in modified SAGE3 function): not implemented in SAGE3! \n");
  // abort();
     p_arguments.insert(where,what);
   }

// DQ (1/18/2006): Added default constructor explicitly to avoid having it be generated by the compiler
SgFunctionParameterTypeList::SgFunctionParameterTypeList()
   {
  // Build the default constructor (nothing to build here since the only data member is an STL list)
   }
 
SOURCE_FUNCTION_PARAMETER_TYPE_LIST_END


SOURCE_TEMPLATE_PARAMETER_START

void SgTemplateParameter::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

#if 0
  // DQ (11/28/2011): Commented out since this code prevents the ROSETTA generated constructor from working correctly.
  // Values initialized in the constructor are reset by this code.

     p_parameterType                       = parameter_undefined;
     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;
#endif
   }

// Different constructors for use in building the different types of parameters possible
SgTemplateParameter::SgTemplateParameter ( SgType* parameter, SgType* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType        = type_parameter;
     p_type                 = parameter;
     p_defaultTypeParameter = defaultParameter;

     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;

     p_initializedName                     = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgExpression* parameter, SgExpression* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType              = nontype_parameter;

  // DQ (11/28/2011): These were not initialized properly.
  // p_expression                 = NULL;
  // p_defaultExpressionParameter = NULL;
     p_expression                 = parameter;
     p_defaultExpressionParameter = defaultParameter;

     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_templateDeclaration                 = NULL;
     p_defaultTemplateDeclarationParameter = NULL;

     p_initializedName                     = NULL;
   }

SgTemplateParameter::SgTemplateParameter ( SgTemplateDeclaration* parameter, SgTemplateDeclaration* defaultParameter )
   {
  // This is normally called last (but because it is called first we had to comment out the
  // initialization in the SgTemplateParameter::post_construction_initialization() function.
     post_construction_initialization();

     p_parameterType                       = template_parameter;
     p_templateDeclaration                 = parameter;
     p_defaultTemplateDeclarationParameter = defaultParameter;

     p_type                                = NULL;
     p_defaultTypeParameter                = NULL;
     p_expression                          = NULL;
     p_defaultExpressionParameter          = NULL;

     p_initializedName                     = NULL;
   }

// DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
bool
SgTemplateParameter::is_matching_type    (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::type_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

bool
SgTemplateParameter::is_matching_nontype (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::nontype_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

bool
SgTemplateParameter::is_matching_template(const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == SgTemplateParameter::template_parameter) && (X.get_parameterType() == Y.get_parameterType());
   }

// DQ (5/19/2014): This is added to symetry in the functions that are template on either SgTemplateArgument or SgTemplateParameter.
bool
SgTemplateParameter::is_matching_template_pack_expansion (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
  // There is not associated value for the SgTemplateParameter enums, so this function should always return SgTemplateParameter::is_matching_kind().
  // return true;
  // return (X.get_parameterType() == Y.get_parameterType());
     return is_matching_kind(X,Y);
   }

bool
SgTemplateParameter::is_matching_kind (const SgTemplateParameter & X, const SgTemplateParameter & Y)
   {
     return (X.get_parameterType() == Y.get_parameterType());
   }


SgName
SgTemplateParameter::get_mangled_name (void) const
   {
     ROSE_ASSERT(this != NULL);

#if 0
  // mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p get_argumentType() = %d unparseToString() = %s \n",this,get_argumentType(),unparseToString().c_str());
     mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p get_argumentType() = %d \n",this,get_argumentType());
     mprintf ("In SgTemplateParameter::get_mangled_name(): unparseToString() = %s \n",unparseToString().c_str());
#endif

     ostringstream mangled_name;
     switch (get_parameterType())
        {
          case SgTemplateParameter::type_parameter:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               mangled_name << type->get_mangled().str();
               break;
             }

          case SgTemplateParameter::nontype_parameter:
             {
               const SgExpression* expr = get_expression();
               if (expr != NULL)
                  {
                    mangled_name << mangleExpression(expr);
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);
                    mangled_name << get_initializedName()->get_name().str();
                  }
               break;
             }

          case SgTemplateParameter::template_parameter:
             {
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
               mangled_name << templateDeclaration->get_mangled_name().str();
               break;
             }

          default:
             {
            // mangled_name << "UNKNOWN";
               mprintf ("ERROR: In SgTemplateParameter::get_mangled_name(): default reached in switch: get_parameterType() = %d \n",get_parameterType());
               ROSE_ASSERT(false);
               break;
             }
        }

#if 0
     mprintf ("In SgTemplateParameter::get_mangled_name(): mangled_name = %s \n",mangled_name.str());
#endif

     string str_mangled_name (mangled_name.str());

#if 1
  // DQ (9/24/2012): Added test for template syntax in the generated mangled name (convert to std::string so we can simplify the test).
     if ( str_mangled_name.find('<') != string::npos )
        {
          mprintf ("In SgTemplateParameter::get_mangled_name(): this = %p = %s mangled template argument name = %s \n",this,this->class_name().c_str(),str_mangled_name.c_str());
        }
     ROSE_ASSERT(str_mangled_name.find('<') == string::npos);
#endif

  // return SgName(str_mangled_name.c_str());
     return str_mangled_name;
   }


SOURCE_TEMPLATE_PARAMETER_END


SOURCE_TEMPLATE_ARGUMENT_START

void SgTemplateArgument::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

#if 0
  // DQ (11/22/2011): These are set in the constrcutors and should not be reset.
     p_argumentType          = argument_undefined;
     p_type                  = NULL;
     p_expression            = NULL;

  // p_templateInstantiation = NULL;
     p_templateDeclaration   = NULL;
#endif

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;
   }

// Different constructors for use in building the different types of arguments possible
SgTemplateArgument::SgTemplateArgument ( SgType* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = type_argument;
     p_type                = argument;
     p_explicitlySpecified = explicitlySpecified;

     p_expression          = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;

  // Don't set the parent of a type!
  // argument->set_parent(this);
   }

SgTemplateArgument::SgTemplateArgument ( SgExpression* argument, bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = nontype_argument;
     p_expression          = argument;
     p_explicitlySpecified = explicitlySpecified;

     p_type                = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;

  // DQ (8/24/2006): Set the parent
     argument->set_parent(this);
   }

#if 0
// DQ (8/24/2006): This is the incorrect constructor to have, it should have been a SgTemplateDeclaration (see new version below)
SgTemplateArgument::SgTemplateArgument ( SgTemplateInstantiationDecl* parameter, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType          = template_argument;
     p_templateInstantiation = parameter;
     p_explicitlySpecified   = explicitlySpecified;
   }
#endif

// DQ (8/24/2006): This is the more correct version to have.
SgTemplateArgument::SgTemplateArgument ( SgTemplateDeclaration* argument, bool explicitlySpecified )
   {
  // Should this be a SgTemplateInstantiationDecl instead of a SgTemplateDeclaration?
     post_construction_initialization();

     p_argumentType        = template_template_argument;
     p_templateDeclaration = argument;
     p_explicitlySpecified = explicitlySpecified;

  // DQ (11/22/2011): These are no longer set in the post_construction_initialization() function.
     p_expression          = NULL;
     p_type                = NULL;

  // DQ (8/24/2006): Set the parent ???  (make sure it is not already set!)
  // This is likely a shared IR node, so we don't want to set the parent here!
  // assert(argument->get_parent() == NULL);
  // argument->set_parent(this);
#if PRINT_DEVELOPER_WARNINGS
     mprintf ("Skipping setting of parent on SgTemplateDeclaration in SgTemplateArgument \n");
#endif
   }

// DQ (7/3/2013): Added new type of template argument type to support varadic template arguments.
SgTemplateArgument::SgTemplateArgument ( bool explicitlySpecified )
   {
     post_construction_initialization();

     p_argumentType        = start_of_pack_expansion_argument;
     p_expression          = NULL;
     p_explicitlySpecified = explicitlySpecified;

     p_type                = NULL;

  // DQ (11/22/2011): This is no longer set in the post_construction_initialization() function.
     p_templateDeclaration = NULL;

  // DQ (8/24/2006): Set the parent
  // argument->set_parent(this);
   }

#define DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME 0

// RV (2/2/2006): Added mangling of template arguments.
SgName
SgTemplateArgument::get_mangled_name (void) const
   {
     ROSE_ASSERT(this != NULL);

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
  // mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p get_argumentType() = %d unparseToString() = %s \n",this,get_argumentType(),unparseToString().c_str());
     mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p get_argumentType() = %d \n",this,get_argumentType());
  // mprintf ("In SgTemplateArgument::get_mangled_name(): unparseToString() = %s \n",unparseToString().c_str());
#endif

     ostringstream mangled_name;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): type = %p = %s = %s \n",type,type->class_name().c_str(),type->unparseToString().c_str());
#endif
               SgName mangled_type = type->get_mangled();

               SgNode* parent = this->get_parent();
               ROSE_ASSERT(parent != NULL);

            // DQ (9/21/2012): We need to support defining a mangled name that uses the name of the declaration where the template 
            // argument is used.  E.g. In "template <class T> X<T> foo();", the return type "X<T>" shuld have a uniquely mangled 
            // name from that of a similar return type in any other function.  The template declaration support will define an
            // instantiation of "X<T>" which must be seperate from all other tempalte functions having a similar return type.
            // This is the say that te restrict sharing of "X<T>" by supporting a mangled name that forces each functions reference
            // to such a type to be different.
               ROSE_ASSERT(this->get_parent() != NULL);

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               ROSE_ASSERT(parent != NULL);
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: this->get_parent() = %p = %s \n",this->get_parent(),this->get_parent()->class_name().c_str());
#endif
               SgTemplateInstantiationDecl* templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(parent);
               if (templateClassInstantiationDeclaration != NULL)
                  {
                 // DQ (12/26/2012): I think that to generate a unique mangled name we need to alwasy reference the same declaration, so set this and enforce that it is a valid pointer.
                    templateClassInstantiationDeclaration = isSgTemplateInstantiationDecl(templateClassInstantiationDeclaration->get_firstNondefiningDeclaration());
                    ROSE_ASSERT(templateClassInstantiationDeclaration != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: templateClassInstantiationDeclaration = %p name = %s \n",templateClassInstantiationDeclaration,templateClassInstantiationDeclaration->get_name().str());
#endif
                    mangled_type += Rose::StringUtility::numberToString(templateClassInstantiationDeclaration);

                 // DQ (12/26/2012): This assert fails for copyAST_tests/copytest2007_40.C, but I think it is unreasonable 
                 // to expect it to always be true.  So I have made it a warning for now.
                    if (templateClassInstantiationDeclaration != templateClassInstantiationDeclaration->get_firstNondefiningDeclaration())
                       {
                         mprintf ("Warning: In SgTemplateArgument::get_mangled_name(): templateClassInstantiationDeclaration used for mangled name was not the firstNondefiningDeclaration \n");
                       }
                    ROSE_ASSERT(templateClassInstantiationDeclaration == templateClassInstantiationDeclaration->get_firstNondefiningDeclaration());
                  }
                 else
                  {
                 // DQ (8/19/2014): I am not clear how important it is to warn about this issue.
// #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("WARNING: In SgTemplateArgument::get_mangled_name(): parent declaration is not handled: this->get_parent() = %p = %s \n",parent,parent->class_name().c_str());
#endif
                  }

               mangled_name << mangled_type.str();
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::type_argument: mangled_type = %s \n",mangled_type.str());
#endif
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();

            // assert(expr != NULL);
            // mangled_name << mangleExpression(expr);
               if (expr != NULL)
                  {
                    mangled_name << mangleExpression(expr);
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);
                 // mangled_name << mangleExpression(expr);
                 // mangled_name << get_initializedName()->get_mangled_name();
                    mangled_name << get_initializedName()->get_name().str();
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
                    mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::nontype_argument: get_initializedName()->get_name() = %s \n",get_initializedName()->get_name().str());
#endif
#if 0
                    mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::nontype_argument: Need to support name mangling for SgInitializedName \n");
                    ROSE_ASSERT(false);
#endif
                  }
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
            // DQ (12/22/2011): The new design has a SgTemplateClassDeclaration derived from a SgClassDeclaration (and
            // the same for SgTemplateFunctionDeclaration, etc.) So we have to change this to support the new design.
            // Now we have to use a common base class which would be the SgDeclarationStatement.
            // const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("In SgTemplateArgument::get_mangled_name(): case SgTemplateArgument::template_template_argument: = %p = %s \n",templateDeclaration,templateDeclaration->class_name().c_str());
#endif

               SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
               mprintf ("Mangling of template template argument to template type not well tested yet mangled name = %s \n",mangled_templateDeclaration.str());
#endif
               mangled_name << mangled_templateDeclaration.str();
               break;
             }

       // DQ (5/19/2014): Added support for varadic template argument.
          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
               mangled_name << "start_of_pack_expansion_argument";
               break;
             }

          default:
             {
            // mangled_name << "UNKNOWN";
               mprintf ("ERROR: In SgTemplateArgument::get_mangled_name(): default reached in switch: get_argumentType() = %d \n",get_argumentType());
               ROSE_ASSERT(false);
               break;
             }
        }

#if DEBUG_TEMPLATE_ARGUMENT_GET_MANGLED_NAME
     mprintf ("In SgTemplateArgument::get_mangled_name(): mangled_name = %s \n",mangled_name.str().c_str());
#endif

     string str_mangled_name (mangled_name.str());

#if 1
  // DQ (9/24/2012): Added test for template syntax in the generated mangled name (convert to std::string so we can simplify the test).
     if ( str_mangled_name.find('<') != string::npos )
        {
          mprintf ("In SgTemplateArgument::get_mangled_name(): this = %p = %s mangled template argument name = %s \n",this,this->class_name().c_str(),str_mangled_name.c_str());
        }
     ROSE_ASSERT(str_mangled_name.find('<') == string::npos);
#endif

  // return SgName(str_mangled_name.c_str());
     return str_mangled_name;
   }


// DQ (6/9/2007): Some template arguments have a concept of scope, this is required to get the name qualification correct.
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
  // DQ (6/9/2007): This function traverses through the parents to the first scope (used for name qualification support of template arguments)

     const SgNode* parentNode = this;
     ROSE_ASSERT(parentNode != NULL);

     while ( (isSgScopeStatement(parentNode) == NULL) && (parentNode->get_parent() != NULL) )
        {
          ROSE_ASSERT(parentNode != NULL);
          parentNode = parentNode->get_parent();
          ROSE_ASSERT(parentNode != NULL);
        }

     ROSE_ASSERT(parentNode != NULL);

  // Check to see if we made it back to the root (current root is SgProject).
  // It is also OK to stop at a node for which get_parent() returns NULL (SgType and SgSymbol nodes).
     if ( isSgScopeStatement(parentNode) == NULL &&
          dynamic_cast<const SgType*>(parentNode) == NULL &&
          dynamic_cast<const SgSymbol*>(parentNode) == NULL )
        {
          mprintf ("Error in SgTemplateArgument::get_scope(): could not trace back to SgScopeStatement node this = %p = %s parentNode = %p = %s \n",this,this->class_name().c_str(),parentNode,parentNode->class_name().c_str());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(parentNode);
          if (templateInstantiation != NULL)
             {
               mprintf ("templateInstantiation->get_name() = %s \n",templateInstantiation->get_name().str());

            // DQ (8/23/2012): This is not defined for a SgTemplateInstantiationDecl (which is not a template).
            // mprintf ("templateInstantiation->get_template_name() = %s \n",templateInstantiation->get_template_name().str());
               templateInstantiation->get_startOfConstruct()->display("Error in SgTemplateArgument::get_scope()");
             }

          if (parentNode->get_parent() == NULL)
             {
               mprintf ("Error: parent not set for parentNode = %p = %s \n",parentNode,parentNode->class_name().c_str());
             }

          ROSE_ASSERT(parentNode->get_parent() != NULL);

          return NULL;
        }
       else
        {
          if ( dynamic_cast<const SgType*>(parentNode) != NULL || dynamic_cast<const SgSymbol*>(parentNode) != NULL )
             {
               mprintf ("Error: can't locate an associated SgStatement from SgTemplateArgument = %p \n",this);
               return NULL;
             }
        }

  // Make sure we have a SgStatement node
     const SgScopeStatement* scopeStatement = isSgScopeStatement(parentNode);
     assert (scopeStatement != NULL);

  // return statement;
     return const_cast<SgScopeStatement*>(scopeStatement);
   }

#if 0
// Not the correct idea!
SgScopeStatement*
SgTemplateArgument::get_scope () const
   {
     SgScopeStatement* scope = NULL;
     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               const SgNamedType* namedType = isSgNamedType(type);
               if (namedType != NULL)
                  {
                    assert(namedType->get_declaration() != NULL);
                    scope = namedType->get_declaration()->get_scope();
                  }
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
            // Not clear if the scope should be defined here!
            // const SgExpression* expr = get_expression();
               assert(get_expression() != NULL);
               scope = NULL;
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
               assert (templateDeclaration != NULL);

               scope = templateDeclaration->get_scope();
               break;
             }

          default:
             {
               mprintf ("Error in SgTemplateArgument::get_scope(): default reached! \n");
               assert (false);
               break;
             }
        }

     return scope;
   } 
#endif

#if 1
// DQ (2/10/2019): Debugging information
std::string
SgTemplateArgument::template_argument_kind () const
   {
     std::string kindOfTemplateArgument;

     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
               const SgNamedType* namedType = isSgNamedType(type);
               if (namedType != NULL)
                  {
                    assert(namedType->get_declaration() != NULL);
                  }
               kindOfTemplateArgument = "type_argument";
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
            // Not clear if the scope should be defined here!
            // const SgExpression* expr = get_expression();
            // assert(get_expression() != NULL);
               if (get_expression() == NULL)
                  {
                    mprintf ("NOTE: In SgTemplateArgument::template_argument_kind(): case SgTemplateArgument::nontype_argument: get_expression() == NULL: what is this? \n");
                    mprintf (" --- get_type()                = %p \n",get_type());
                    mprintf (" --- get_initializedName()     = %p \n",get_initializedName());
                    mprintf (" --- get_templateDeclaration() = %p \n",get_templateDeclaration());
                  }

               kindOfTemplateArgument = "nontype_argument";
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
            // const SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
            // assert (templateDeclaration != NULL);

               kindOfTemplateArgument = "template_template_argument";
               break;
             }

          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
               kindOfTemplateArgument = "start_of_pack_expansion_argument";
               break;
             }

          default:
             {
               mprintf ("Error in SgTemplateArgument::template_kind(): default reached! \n");
               assert (false);
               break;
             }
        }

     return kindOfTemplateArgument;
   } 
#endif


bool
SgTemplateArgument::isTemplateArgumentFromAnonymousClass() const
   {
     bool isAnonymous = false;

#define DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS 0

     bool hasLambdaFollowed = false;

     if (SgClassType * ctype = isSgClassType (this->get_type()))
        {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
          mprintf ("ctype != NULL \n");
#endif
          if (SgNode* pnode = ctype->get_declaration()->get_parent())
             {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
               mprintf ("pnode != NULL \n");
#endif
               if (isSgLambdaExp(pnode))
                  {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
                    mprintf ("Found a SgLambdaExp parent for the class: set hasLambdaFollowed = true  \n");
#endif
                    hasLambdaFollowed = true; 
                  }
             }

       // DQ (1/21/2018): Check if this is an unnamed class (used as a template argument, which is not alloweded, so we should not unparse it).
       // bool isAnonymous = isAnonymousClass(ctype);

       // SgClassType* classType = isSgClassType(templateArgumentType);
          SgClassType* classType = ctype;
          if (classType != NULL)
             {
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classType->get_declaration());
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
               mprintf ("In isAnonymousClass(): case SgTemplateArgument::type_argument: classDeclaration = %p = %s classDeclaration->get_name() = %s \n",
                    classDeclaration,classDeclaration->class_name().c_str(),classDeclaration->get_name().str());
#endif
               bool isUnnamed = (string(classDeclaration->get_name()).substr(0,14) == "__anonymous_0x");
#if 0
               if (isUnnamed == true)
                  {
                    mprintf ("In isAnonymousClass(): case SgTemplateArgument::type_argument: isUnnamed = %s \n",isUnnamed ? "true" : "false");
                  }
#endif
               isAnonymous = isUnnamed;
             }

          if (isAnonymous == true)
             {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS || 0
               mprintf ("isAnonymous == true: set hasLambdaFollowed = true \n");
#endif
            // DQ (1/21/2018): This is mixing logic for explicitlySpecified with something Liao introduced 
            // which checks for a trailing lambda function.  So we should fix this up later.
               hasLambdaFollowed = true; 
             }
#if 0
            else
             {
#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
               mprintf ("isAnonymous == false \n");
#endif
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(ctype->get_declaration());
               if (classDeclaration != NULL)
                  {
                    mprintf ("In unparseTemplateArgumentList(): last template argument: classDeclaration->get_name() = %s \n",classDeclaration->get_name().str());
                  }
             }
#endif
        }

#if DEBUG_IS_TEMPLATE_ARGUMENT_FROM_ANONYOUS_CLASS
     mprintf ("Leaving SgTemplateArgument::isTemplateArgumentFromAnonymousClass(): isAnonymous = %s hasLambdaFollowed = %s \n",isAnonymous ? "true" : "false",hasLambdaFollowed ? "true" : "false");
#endif

  // return (isAnonymous == true);
     return (isAnonymous == true) || (hasLambdaFollowed == true);
   }



SgName
SgTemplateArgument::get_qualified_name_prefix() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgBaseClass
  //    SgTemplateArgument

// #ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
#if 0
  // DQ (9/27/2012): This does appear to be called in processing test2004_127.C.
     mprintf ("This is not called see the function: SgTemplateArgument::get_qualified_name_prefix_for_type() \n");
#endif

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTemplateArgument*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
       // mprintf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
        }

  // mprintf ("nameQualifier for SgBaseClass = %s = %s \n",class_name().c_str(),nameQualifier.str());

     return nameQualifier;
   }

SgName
SgTemplateArgument::get_qualified_name_prefix_for_type() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTemplateArgument*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
          mprintf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }

#if 0
     mprintf ("nameQualifier for SgTemplateArgument = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }

// DQ (8/10/2013): commonly names functions for SgTemplateParameter and SgTemplateArgument.
bool
SgTemplateArgument::is_matching_type    (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::type_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_nontype (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::nontype_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_template(const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::template_template_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

// DQ (5/19/2014): Added support for matching on this kind of template argument (only applies to SgTemplateArgument and not SgTemplateParemeter).
bool
SgTemplateArgument::is_matching_template_pack_expansion (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == SgTemplateArgument::start_of_pack_expansion_argument) && (X.get_argumentType() == Y.get_argumentType());
   }

bool
SgTemplateArgument::is_matching_kind (const SgTemplateArgument & X, const SgTemplateArgument & Y)
   {
     return (X.get_argumentType() == Y.get_argumentType());
   }


// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA 
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int 
SgTemplateArgument::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTemplateArgument::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool 
SgTemplateArgument::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTemplateArgument::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool 
SgTemplateArgument::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTemplateArgument::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

bool 
SgTemplateArgument::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgTemplateArgument::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);
     
     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

int 
SgTemplateArgument::get_name_qualification_length_for_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_type;
   }

void
SgTemplateArgument::set_name_qualification_length_for_type ( int name_qualification_length_for_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);
     
     p_name_qualification_length_for_type = name_qualification_length_for_type;
   }

// DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTemplateArgument::get_type_elaboration_required_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_type;
   }

void
SgTemplateArgument::set_type_elaboration_required_for_type(bool type_elaboration_required_for_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);
     
     p_type_elaboration_required_for_type = type_elaboration_required_for_type;
   }

// DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTemplateArgument::get_global_qualification_required_for_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_type;
   }

void
SgTemplateArgument::set_global_qualification_required_for_type(bool global_qualification_required_for_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);
     
     p_global_qualification_required_for_type = global_qualification_required_for_type;
   }

void
SgTemplateArgument::display( const std::string & label) const
   {
  // DQ (5/22/2016): Adding display function for debugging.

     ROSE_ASSERT(this != NULL);

     switch (get_argumentType())
        {
          case SgTemplateArgument::type_argument:
             {
               const SgType* type = get_type();
               assert (type != NULL);
#if 1
               mprintf ("In SgTemplateArgument::display(): type = %p = %s = %s \n",type,type->class_name().c_str(),type->unparseToString().c_str());
#endif
               Rose_STL_Container<SgType*> typeChain = type->getInternalTypes();

            // Debugging output.
               mprintf (" --- Output of type chain for template argument \n");
               for (size_t i = 0; i < typeChain.size(); i++)
                  {
                    SgType* element_type = typeChain[i];
                    mprintf ("   --- element_type = %p = %s \n",element_type,element_type->class_name().c_str());
                    SgModifierType* modifierType = isSgModifierType(element_type);
                    if (modifierType != NULL)
                       {
                      // modifierType->get_typeModifier().display("X type chain");
                         string s = modifierType->get_typeModifier().displayString();
                         mprintf ("   ------ type chain modifier: %s \n",s.c_str());
                       }
                  }
               break;
             }

          case SgTemplateArgument::nontype_argument:
             {
               const SgExpression* expr = get_expression();

            // DQ (12/28/2018): Added assertion.
            // ROSE_ASSERT(expr != NULL);
#if 0
            // DQ (12/28/2018): original version of code.
               mprintf ("SgTemplateArgument::nontype_argument: expr = %s \n",expr->unparseToString().c_str());
#else
            // DQ (12/28/2018): This is a better implementation (it was here, but commented out).
               if (expr != NULL)
                  {
                    mprintf ("SgTemplateArgument::nontype_argument: expr = %s \n",expr->unparseToString().c_str());
                  }
                 else
                  {
                    ROSE_ASSERT(get_initializedName() != NULL);
                    ROSE_ASSERT(get_initializedName()->get_scope() != NULL);

                 // DQ (12/28/2018): original version of code, fixed to output the name.
                 // mprintf ("SgTemplateArgument::nontype_argument: expr = %s \n",expr->unparseToString().c_str());
                    mprintf ("SgTemplateArgument::nontype_argument: initializedName = %s \n",get_initializedName()->get_name().str());
                  }
#endif
               break;
             }

          case SgTemplateArgument::template_template_argument:
             {
               const SgDeclarationStatement* templateDeclaration = get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);
#if 1
               mprintf ("In SgTemplateArgument::display(): case SgTemplateArgument::template_template_argument: = %p = %s \n",templateDeclaration,templateDeclaration->class_name().c_str());
#endif
               SgName mangled_templateDeclaration = templateDeclaration->get_mangled_name();
               mprintf ("case SgTemplateArgument::template_template_argument: mangled_templateDeclaration = %s \n",mangled_templateDeclaration.str());
               break;
             }

          case SgTemplateArgument::start_of_pack_expansion_argument:
             {
            // const SgExpression* expr = get_expression();
               assert(get_expression() != NULL);
#if 1
               mprintf ("WARNING: In SgTemplateArgument::display(): handling of display for varadic template argument is incomplete! \n");
#endif
               mprintf ("In SgTemplateArgument::display(): case SgTemplateArgument::start_of_pack_expansion_argument: varadic_template_argument \n");

            // DQ (12/28/2018): Add support to handle this case.
               const SgExpression* expr = get_expression();
               mprintf ("SgTemplateArgument::start_of_pack_expansion_argument: expr = %s \n",expr->unparseToString().c_str());

               break;
             }

          default:
             {
               mprintf ("ERROR: In SgTemplateArgument::display(): default reached in switch: get_argumentType() = %d \n",get_argumentType());
               ROSE_ASSERT(false);
               break;
             }
        }
   }

std::string
SgTemplateArgument::unparseToStringSupport()
   {
  // DQ (3/10/2018): This is a function mostly used for debugging.
     ROSE_ASSERT(this != NULL);

     SgUnparse_Info *info = new SgUnparse_Info();
     ROSE_ASSERT(info != NULL);

     info->set_language(SgFile::e_Cxx_language);

  // DQ (4/28/2017): For template arguments we never want to output the definitions of classes, and enums.
     info->set_SkipClassDefinition();
     info->set_SkipEnumDefinition();
     info->set_use_generated_name_for_template_arguments(true);

     std::string returnName = this->unparseToString(info);

     delete info;
     info = NULL;

     return returnName;
   }

SOURCE_TEMPLATE_ARGUMENT_END


SOURCE_TEMPLATE_PARAMETER_LIST_START
SOURCE_TEMPLATE_PARAMETER_LIST_END


SOURCE_TEMPLATE_ARGUMENT_LIST_START
SOURCE_TEMPLATE_ARGUMENT_LIST_END


SOURCE_GRAPHNODE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphNode::p_index_counter = 0;


// tps : todo : remove this soon
void
SgGraphNode::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }


void
SgGraphNode::post_construction_initialization()
   {

  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;

  // mprintf ("In SgGraphNode::post_construction_initialization(): p_index = %u p_index_counter = %u \n",p_index,p_index_counter);

   }

SOURCE_GRAPHNODE_END


SOURCE_GRAPHEDGE_START


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraphEdge::p_index_counter = 0;


// tps : todo : remove me
void
SgGraphEdge::append_properties( int addr, const std::string & prop )
   {
  // DQ (4/29/2009): Unclear what this comment (below) means...
  // implemented directly until we can fix how the statementList is built
     p_properties[addr] = prop;
   }


void
SgGraphEdge::post_construction_initialization()
   {

  // DQ (4/29/2009): This function could be inlined for better performance.
     p_index = p_index_counter++;

  // mprintf ("In SgGraphEdge::post_construction_initialization(): p_index = %u p_index_counter = %u \n",p_index,p_index_counter);

   }

SOURCE_GRAPHEDGE_END


SOURCE_GRAPH_START

//#if defined(ROSE_USE_NEW_GRAPH_NODES) && !defined(ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY)
//#warning "ROSE_USING_GRAPH_IR_NODES_FOR_BACKWARD_COMPATABILITY not set"
//#endif


// DQ (4/29/2009): Declaration of space for static data member.
int SgGraph::p_index_counter = 0;



// tps : todo : remove me -----------------------------------------
void
SgGraph::append_properties( int addr, const std::string & prop )
   {
     assert(this != NULL);
  /* implemented directly until we can fix how the statementList is built */
     p_properties[addr] = prop;
   }

int 
SgGraph::hashCode( const char* p, int len) const // hash a character array
   {
     assert(this != NULL);
     unsigned int h = 0;
     for (int i=0; i < len; i++)
        {
          h = (h<<5) | (h>>27);    // 5-bit cyclic shift
          h += (unsigned int)p[i]; // add in next character
        }
     return (int)h; 
   }
// -----------------------------------------------------



// DQ (4/28/2009): Added support to have internal list nodes built automatically in the SgGraph constructor.
void
SgGraph::post_construction_initialization()
   {
     assert(this != NULL);


  // Setup an internal graph_id
     p_index = p_index_counter++;

   }



std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphNode* node) {
  string value="";
  map < int , string> node_p = node->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}

std::string
SgGraph::getProperty(SgGraph::GraphProperties property, SgGraphEdge* edge) {
  string value="";
  map < int , string> node_p = edge->get_properties();
  map < int , string>::iterator prop = node_p.find(property);
  if (prop!=node_p.end()) {
    value = prop->second;
  }
  return value;
}


void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphNode* node,
			   std::string value) {
  node->append_properties(property, value);
}

void
SgGraph::setProperty(SgGraph::GraphProperties property, SgGraphEdge* edge,
			   std::string value) {
  edge->append_properties(property, value);
}




void
SgGraph::checkIfGraphNodeExists(const string& trg_mnemonic, std::vector<SgGraphNode*>& nodes) {
  rose_graph_string_integer_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_string_integer_hash_multimap::const_iterator, rose_graph_string_integer_hash_multimap::const_iterator> 
    iter = p_string_to_node_index_multimap.equal_range(trg_mnemonic);
  it1 = iter.first;
  it2 = iter.second;
  SgGraphNode* node = NULL;
  for (;it1!=it2; ++it1) {
    //
    //rose_graph_string_integer_hash_multimap::iterator it = p_string_to_node_index_multimap.find(trg_mnemonic);
    //if (it!=p_string_to_node_index_multimap.end()) {
    int index =  it1->second;
    node = p_node_index_to_node_map.find(index)->second;
    nodes.push_back(node);
  }
  //  return nodes;

  //  return NULL;
}

#if 0
// old interface
SgGraphNode*
SgGraph::checkIfGraphNodeExists(string& trg_mnemonic) {
#if 1
  SgGraphNode* node = NULL;
  SgGraphNodeList* gnodes = get_nodes();
  rose_graph_hash_multimap nodes = gnodes->get_nodes();
  rose_graph_hash_multimap::iterator it = nodes.find(trg_mnemonic);
  if (it!=nodes.end()) {
    node =  it->second;
    return node;
  }
#endif

  return NULL;
}

  // Increase the size of the hash_map
     resize_hash_maps( 1000 );
#endif


SOURCE_GRAPH_END


SOURCE_DIRECTED_GRAPH_EDGE_START


SgDirectedGraphEdge::SgDirectedGraphEdge(std::string label, std::string type, int n, SgGraphNode* from, SgGraphNode* to)

   {
   	p_name = label;
//   	p_type=t;
   	p_node_A = from;
   	p_node_B=to;
   }

SOURCE_DIRECTED_GRAPH_EDGE_END

#if 0
SOURCE_DIRECTED_GRAPH_NODE_START
// DQ (4/23/2009): Removed to debug use of new Graph node interfaces.

SgDirectedGraphNode::SgDirectedGraphNode(std::string name , std::string t , int n)
   {
   	p_name = name;
//   	p_type=t;
   //	p_node_A = n1;
   }

SOURCE_DIRECTED_GRAPH_NODE_END


SOURCE_DIRECTED_GRAPH_START
SgDirectedGraph::SgDirectedGraph(std::string name, std::string t)
   {
   p_name=name;
   }
SOURCE_DIRECTED_GRAPH_END
#endif

SOURCE_INCIDENCE_UNDIRECTED_GRAPH_START
SOURCE_INCIDENCE_UNDIRECTED_GRAPH_END


SOURCE_INCIDENCE_DIRECTED_GRAPH_START


void
SgIncidenceDirectedGraph::post_construction_initialization()
   {
     assert(this != NULL);

   }


bool
SgIncidenceDirectedGraph::checkIfGraphEdgeExists(SgGraphNode* src) {
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  rose_graph_integer_edge_hash_multimap::const_iterator it = edges.find(src->get_index());
  
  return (it != edges.end());
}

std::set <SgGraphEdge*>
SgIncidenceDirectedGraph::getEdge(SgGraphNode* src) {
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    //    SgGraphNode* source = it1->first;
    SgGraphEdge* edge = isSgGraphEdge(it1->second);
    medges.insert(edge);
  }
  return medges;
}






void
SgIncidenceDirectedGraph::getSuccessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const
{
  //SgGraphEdgeList* gedges = get_edgesOut();
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  //  cerr << " >>>>>>>>>>>>>>> Outedges for node " << node->get_index() << endl;
  assert(node);
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
 // cerr << "            are : " << edge->get_index() << endl;
    assert(edge);
    if (edge) {
      SgGraphNode* target = isSgGraphNode(edge->get_to());
      assert(target);
      if (target) {
	       vec.push_back(target);
      }
    } else {
      printf("This is not a DirectedGraphEdge.\n");
      assert(edge);
    }
  }
}

void
SgIncidenceDirectedGraph::getPredecessors(const SgGraphNode* node, std::vector <SgGraphNode*>& vec ) const
{
  //SgGraphEdgeList* gredges = get_edgesIn();
  rose_graph_integer_edge_hash_multimap edges = get_node_index_to_edge_multimap_edgesIn();
  rose_graph_integer_edge_hash_multimap::iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::iterator, rose_graph_integer_edge_hash_multimap::iterator> iter =
    //fails
    //	  get_edgesIn()->get_edges().equal_range(node);
    edges.equal_range(node->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);
    if (edge) {
      SgGraphNode* source = isSgGraphNode(edge->get_from());
      if (source) {
	//string type_n = getProperty(SgGraph::type, edge);
	  vec.push_back(source);
      }
    }
  }
}



set<SgDirectedGraphEdge*>
SgIncidenceDirectedGraph::getDirectedEdge(SgGraphNode* src, SgGraphNode* trg) {
  //SgGraphEdgeList* gedges = get_edgesOut();
  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();
  set<SgDirectedGraphEdge*> medges;
  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter =
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    //    SgGraphNode* source = it1->first;
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);

 // DQ (3/19/2016): Klocworks reports this as an issue, since "edge" could be NULL.  Fix by adding an addertion.
    ROSE_ASSERT(edge != NULL);

    SgGraphNode* target = isSgGraphNode(edge->get_to());
    if (target==trg)
      medges.insert(edge);
  }
  return medges;
}


bool
SgIncidenceDirectedGraph::checkIfDirectedGraphEdgeExists(SgGraphNode* src, SgGraphNode* trg) {
  if (src==NULL)
    return false;
  if (trg==NULL)
    return false;

  const rose_graph_integer_edge_hash_multimap& edges = get_node_index_to_edge_multimap_edgesOut();

  rose_graph_integer_edge_hash_multimap::const_iterator it1, it2;
  pair <rose_graph_integer_edge_hash_multimap::const_iterator, rose_graph_integer_edge_hash_multimap::const_iterator> iter = 
    edges.equal_range(src->get_index());
  it1 = iter.first;
  it2 = iter.second;
  for (;it1!=it2; ++it1) {
    SgDirectedGraphEdge* edge = isSgDirectedGraphEdge(it1->second);

 // DQ (3/19/2016): Klocworks reports this as an issue, since "edge" could be NULL.  Fix by adding an addertion.
    ROSE_ASSERT(edge != NULL);

    SgGraphNode* target = edge->get_to();
    if (target==trg)
      return true;
  }
  return false;
}



SOURCE_INCIDENCE_DIRECTED_GRAPH_END




SOURCE_NAME_GROUP_START
const SgStringList &
SgNameGroup::get_name_list() const
   {
     return p_name_list;
   }

SgStringList &
SgNameGroup::get_name_list()
   {
     return p_name_list;
   }
SOURCE_NAME_GROUP_END


SOURCE_COMMON_BLOCK_OBJECT_START
SOURCE_COMMON_BLOCK_OBJECT_END


SOURCE_DIMENSION_OBJECT_START
SOURCE_DIMENSION_OBJECT_END


SOURCE_DATA_STATEMENT_GROUP_START

const SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list() const
   {
     return p_object_list;
   }

SgDataStatementObjectPtrList &
SgDataStatementGroup::get_object_list()
   {
     return p_object_list;
   }

const SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list() const
   {
     return p_value_list;
   }

SgDataStatementValuePtrList &
SgDataStatementGroup::get_value_list()
   {
     return p_value_list;
   }

SOURCE_DATA_STATEMENT_GROUP_END

SOURCE_DATA_STATEMENT_OBJECT_START
SOURCE_DATA_STATEMENT_OBJECT_END

SOURCE_DATA_STATEMENT_VALUE_START

void
SgDataStatementValue::post_construction_initialization()
   {
#if 0
     mprintf ("Inside of SgDataStatementValue::post_construction_initialization() initializer_list = %p \n",p_initializer_list);
     if (p_initializer_list == NULL)
        {
          p_initializer_list = new SgExprListExp();
          p_initializer_list->set_parent(this);
        }
#endif
   }
 
SOURCE_DATA_STATEMENT_VALUE_END


SOURCE_FORMAT_ITEM_START
SOURCE_FORMAT_ITEM_END


SOURCE_FORMAT_ITEM_LIST_START

const SgFormatItemPtrList &
SgFormatItemList::get_format_item_list() const
   {
     return p_format_item_list;
   }
 
SgFormatItemPtrList &
SgFormatItemList::get_format_item_list()
   {
     return p_format_item_list;
   }

void
SgFormatItemList::set_format_item_list ( const SgFormatItemPtrList & formatItemList )
   {
     p_format_item_list = formatItemList;
   }
 

SOURCE_FORMAT_ITEM_LIST_END

SOURCE_OPENCL_ACCESS_MODE_MODIFIER_START

// Copy constructor
$CLASSNAME::$CLASSNAME ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
   }

$CLASSNAME &
$CLASSNAME::operator= ( const $CLASSNAME & X )
   {
     p_modifier = X.p_modifier;
     return *this;
   }

void
$CLASSNAME::post_construction_initialization()
   {
     p_modifier = e_default;
   }

bool $CLASSNAME::isUnknown() const { return p_modifier == e_unknown; }
void $CLASSNAME::setUnknown()      { p_modifier = e_unknown; }

bool $CLASSNAME::isDefault() const { return p_modifier == e_default; }
void $CLASSNAME::setDefault()      { p_modifier = e_default; }

bool $CLASSNAME::isReadOnly() const { return p_modifier == e_read_only; }
void $CLASSNAME::setReadOnly()      { p_modifier = e_read_only; }

bool $CLASSNAME::isWriteOnly() const { return p_modifier == e_write_only; }
void $CLASSNAME::setWriteOnly()      { p_modifier = e_write_only; }

bool $CLASSNAME::isReadWrite() const { return p_modifier == e_read_write; }
void $CLASSNAME::setReadWrite()      { p_modifier = e_read_write; }

std::ostream & operator<< ( std::ostream & os, const $CLASSNAME & m) 
   {
      os << m.get_modifier(); 
     return os;
   }

string
$CLASSNAME::displayString() const
   {
     std::string s = "$CLASSNAME(";
     s += std::string("isUnknown() = ")   + std::string(isUnknown()   ? "true " : "false ");
     s += std::string("isDefault() = ")   + std::string(isDefault()   ? "true " : "false ");
     s += std::string("isReadOnly() = ")  + std::string(isReadOnly()  ? "true " : "false ");
     s += std::string("isWriteOnly() = ") + std::string(isWriteOnly() ? "true " : "false ");
     s += std::string("isReadWrite() = ") + std::string(isReadWrite() ? "true " : "false ");
     s += ")";
     return s;
   }

void
$CLASSNAME::display ( std::string label ) const
   {
     mprintf ("In $CLASSNAME::display(%s) \n",label.c_str());
     mprintf ("%s \n",displayString().c_str());
   }


SOURCE_OPENCL_ACCESS_MODE_MODIFIER_END


SOURCE_TYPE_TABLE_START

/* \brief Hash table of types (table is stored on global scope).

   Hash table of types (table is stored on global scope and includes types
   from all scopes). Types are placed into and retrieved from this data 
   base (simple hash table) of SgTypes.
 */
SgTypeTable::SgTypeTable ()
   {
  // DQ (2/19/2007): Use a much larger size symbol table for the function types (the input value is the hash table size, which should be a prime number)!
  // p_function_type_table = new SgSymbolTable();
     p_type_table = new SgSymbolTable(1001);
     ROSE_ASSERT(p_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_type_table->set_parent(this);
   }

#if 0
// DQ (2/19/2007): This appears to not be called but is here because 
// the ROSETTA code requires it (I think).
void
SgTypeTable::post_construction_initialization()
   {
   }
#endif

void
SgTypeTable::print_typetable(std::ostream& os)
   {
  // mprintf ("ERROR: Sage $CLASSNAME::print_functypetable function called! \n");
  // abort();

     os << endl << "...TypeTbl..." << endl;
  // p_type_table.print(os);

     ROSE_ASSERT(p_type_table != NULL);
  // p_type_table->print(os);
     p_type_table->print("Called from $CLASSNAME::print_typetable");
   }

void
SgTypeTable::insert_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_type_table != NULL);
     ROSE_ASSERT (t != NULL);

  // DQ (7/22/2010): We might want to reuse the SgFunctionTypeSymbol or change the name of it to SgTypeSymbol
     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);
#if 0
  // DQ (7/29/2010): This can sometimes fail in unparsing types.  This is important becasse we now support type tables in ROSE.
     mprintf ("Inside of SgTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s = %s newSymbol = %p \n",
             n.str(),t->sage_class_name(),t->unparseToString().c_str(),newSymbol);
#endif
#if 0
  // DQ (7/29/2010): This is more robust for the new type table support.
     mprintf ("Inside of SgTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s newSymbol = %p \n",
             n.str(),t->sage_class_name(),newSymbol);
#endif
  // mprintf ("Is the qualified name being used! \n");
  // ROSE_ASSERT(false);

  // DQ (7/26/2010): Set the parent of the type to it symbol.
  // This is a new idea and will allow the parent pointer to be valid for all types and also 
  // point to something meaningful.  This is another benefit of using the type table idea.
     t->set_parent(newSymbol);

     p_type_table->insert(n, newSymbol);
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgTypeTable::remove_type(const SgName& n)
   {
     ROSE_ASSERT (p_type_table != NULL);
     p_type_table->remove_function_type(n);
   }

#if 0
// see if this is ever used!
void
SgTypeTable::insert_type(const SgFunctionDeclaration *fdecl)
   {
     assert(fdecl != NULL);
     mprintf ("Inside of SgTypeTable::insert_function_type(SgFunctionDeclaration = %s) \n",fdecl->get_name().str());
     SgFunctionType* type = isSgFunctionType(fdecl->get_type());
     ROSE_ASSERT(type != NULL);

     SgName n = type->get_mangled_type();
  // mprintf ("Using function name = %s  should be using qualified function type name \n",n.str());

     mprintf ("Looking up %s in function table \n",n.str());
     if (lookup_function_type(n) != NULL)
        {
          mprintf ("Found function %s (skip reinsertion) \n",n.str());
       // return; // DQ: no need for multiple return!
        }
       else
        {
       // mprintf ("Function NOT Found: so insert in table %s \n",n.str());
          insert_function_type(n,type);
        }
   }
#endif

SgType*
SgTypeTable::lookup_type(const SgName& n)
   {
#if 0
     mprintf ("In SgTypeTable::lookup_type: Looking for %s \n",n.str());
#endif

     ROSE_ASSERT (p_type_table != NULL);

  // SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(p_function_type_table->findfunctype(n));

#if 0
     mprintf ("Is this an error: shouldn't this be looking for any type, and not just a function Type? \n");
#endif

     SgSymbol *symbol = p_type_table->find_function_type(n);

#if 0
     mprintf ("In SgTypeTable::lookup_type: symbol = %p \n",symbol);
#endif

     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);

     SgType* returnType = NULL;

     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
#if 0
          mprintf ("In SgTypeTable::lookup_type(): found function type %s \n",returnType->class_name().c_str());
#endif
        }

#if 0
     mprintf ("In SgTypeTable::lookup_type: returnType = %p \n",returnType);
#endif

     return returnType;
   }

SOURCE_TYPE_TABLE_END


