HEADER_START
     public:

#if 0
      //! This enum type is used to hold values controling if new comments/directives are added
      //! to the front of back of the AttachedPreprocessingInfoType (typedef to a list of
      //! PreprocessorInfo objects).
          enum PositionOfPreprocessingInfoInListType
             {
               defaultValue                   = 0, // let the zero value be an error value
               prependPreprocessingInfoToList = 1, // Prepend the new PreprocessingInfo object to the list
               appendPreprocessingInfoToList  = 2  // Append the new PreprocessingInfo object to the list
             };
#endif

       // ~SgLocatedNode();

       // void setlineNumber(unsigned long new_line);

       // virtual bool _print(int depth) const; /* prints file info */

       // DQ (8/20/2004): Make this depricated since we should remove this (or should we?)
       // If we want to preserve it we should make it a member function of SgNode?
       // Function added by DQ (7/22/2001)
       // const char* getFileName() ROSE_DEPRECATED_FUNCTION;
          const std::string & getFilenameString() const;

     protected:
     // void delete_file_info();
     // void directives(ostream& os);
        void post_construction_initialization() $ROSE_OVERRIDE;

     private:
          $CLASSNAME( const $CLASSNAME & X ); /* until we know what to do with it */

     public:
       // [MK] Member function to 
       // ! attach PreprocessingInfo object to the node. It can only prepend or append the info. to the existing list of preprocessing info.
       // void addToAttachedPreprocessingInfo(PreprocessingInfo *prepInfoPtr);
          void addToAttachedPreprocessingInfo( PreprocessingInfo *prepInfoPtr, PreprocessingInfo::RelativePositionType locationInList = PreprocessingInfo::after );

        // Liao 1/27/2015
        //! Insert prepInfo After (or before if last parameter is false) an anchor info ptr  in the list of preprocessing info attached to the current node. This is useful to insert things in the middle.   
          void insertToAttachedPreprocessingInfo( PreprocessingInfo *prepInfoPtr, PreprocessingInfo* anchorInfoPtr, bool insertAfter = true);

       // DQ (2/6/2003):
       /*! \brief Interface function to implement original SAGE interface to
                  SgFile_Info objects.

          This function is added explicitly to provide the older interface to the file_info
          pointer which has been removed and replaced with two Sg_File_Info pointers to mark the
          start and end of the located node object (previously we only stored the starting location).
          This function still returns the starting location of the construct.
        */
          virtual Sg_File_Info* get_file_info() const $ROSE_OVERRIDE;

      //! Access function calls set_startingConstruct(Sg_File_Info*) member function
          virtual void set_file_info(Sg_File_Info* X);

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as compiler generated.

          Since the flag for isCompilerGenerated is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setCompilerGenerated ();
          void unsetCompilerGenerated ();

       // DQ (7/5/2014): Added interface function to simplify code.
      /*! \brief Simple test for if this is a compiler generated node.

          This is a simpler interface to check the settings of this associated flag in the multiple Sg_File_Info objects.

          \internal This function also checks the consistancy of the setting in the different Sg_File_Info objects.
       */
          bool isCompilerGenerated () const;

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as a transformation.

          Since the flag for isTransformation is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setTransformation ();
          void unsetTransformation ();

       // DQ (12/4/2014): Added interface function to simplify code.
      /*! \brief Simple test for if this is a part of a transformation.

          This is a simpler interface to check the settings of this associated flag in the multiple Sg_File_Info objects.

          \internal This function also checks the consistancy of the setting in the different Sg_File_Info objects.
       */
          bool isTransformation () const;

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as front-end specific (generated by the front-end to support a specific backend compiler; e.g. GNU gcc and g++).

          Since the flag for isFrontendSpecific is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setFrontendSpecific ();
          void unsetFrontendSpecific ();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as to when the information was unavilable in the front-end (even if it typically is there are special cases).

          Since the flag for isSourcePositionUnavailableInFrontend is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setSourcePositionUnavailableInFrontend();
          void unsetSourcePositionUnavailableInFrontend();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be marked as to when the information was unavilable in the front-end (even if it typically is there are special cases).

          Since the flag for isOutputInCodeGeneration is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be set uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          void setOutputInCodeGeneration();
          void unsetOutputInCodeGeneration();

      /*! \brief Allow IR nodes (mostly SgLocatedNode) to be queried for there physical file ID.

          Since the value for the physical_file_id is stored in the Sg_File_Info, and because there
          are up to three of these for the source position information to be comprehensive, this 
          function permits a mechanism to have them be queried uniformally.  Warnings are issued if
          they are not set uniformally.

          \internal This function marks the Sg_File_Info objects that must already be present.
       */
          int get_physical_file_id();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const $ROSE_OVERRIDE;
#else
       // DQ (11/1/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      /*! \brief Computes the number of nodes in the defined subtree of the AST.

          This function is used as a basis for steps in AST isomophism tests.
       */
       // PC (7/9/2009): This function is not defined.
       // size_t numberOfNodesInSubtree();

     public:

// #ifndef ROSE_USE_SWIG_SUPPORT
#ifndef SWIG
       // [MK] Member function to access attached preprocessing info 
          AttachedPreprocessingInfoType*& getAttachedPreprocessingInfo(void);
#endif

       // DQ (4/10/2006): This is replaced by a better interface for attributes.
       // DQ (1/2/2006): Added attribute mechanism to SgLocatedNode
       // AstAttributeMechanism & attribute();

       // DQ (12/30/2009): This is moved to be a member function instead of a local inlined 
       // function in global scope.  This implementation better supports the optional use 
       // of smaller separate files generated by ROSETTA. The name is changed to both be
       // more clear and match the naming convention in ROSE.
       // inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
       // Sg_File_Info* New_File_Info( SgLocatedNode *p);
          Sg_File_Info* generateMatchingFileInfo();

HEADER_END

HEADER_TOKEN_START
// DQ (3/24/2007): These are added from Rama's
// work on the lexical analysis of Fortran.  There will
// be similar values for C and C++ (and Python at some point).

// DQ (3/24/2007): We should put this in a namespace or rename it.
struct token_element
   {
     std::string token_lexeme;
     int token_id;
   };

// DQ (4/14/2007): New enum values are language specific to clarity.
// The "index + language_specific_offset" permits IR node enum values
// that will be grouped appropriately.
// DQ (3/24/2007): first versions of tokens using "ROSE_" prefix was judged overdone.
// Language specific enum values for Fortran 2003 tokens
// enum ROSE_Fortran_Identifiers
enum ROSE_Fortran_Keywords
   {
      FORTRAN_ABSTRACT = 0 + 0,
      FORTRAN_ACCESS = 1 + 0,
      FORTRAN_ACTION = 2 + 0,
      FORTRAN_ALLOCATE = 3 + 0,
      FORTRAN_ALLOCATABLE = 4 + 0,
      FORTRAN_ASSIGN = 5 + 0,
      FORTRAN_ASSOCIATE = 6 + 0,
      FORTRAN_ASYNCHRONOUS = 7 + 0,
      FORTRAN_BACKSPACE = 8 + 0,
      FORTRAN_BIND = 9 + 0,
      FORTRAN_BLANK = 10 + 0,
      FORTRAN_BLOCK_DATA = 11 + 0,
      FORTRAN_CALL = 12 + 0,
      FORTRAN_CHARACTER = 13 + 0,
      FORTRAN_CLASS = 14 + 0,
      FORTRAN_CLOSE = 15 + 0,
      FORTRAN_CONTINUE = 16 + 0,
      FORTRAN_CYCLE = 17 + 0,
      FORTRAN_CASE = 18 + 0,
      FORTRAN_COMMON = 19 + 0,
      FORTRAN_COMPLEX = 20 + 0,
      FORTRAN_CONTAINS = 21 + 0,
      FORTRAN_DEALLOCATE = 22 + 0,
      FORTRAN_DATA = 23 + 0,
      FORTRAN_DEFERRED = 24 + 0,
      FORTRAN_DELIM = 25 + 0,
      FORTRAN_DIMENSION = 26 + 0,
      FORTRAN_DO = 27 + 0,
      FORTRAN_DT = 28 + 0,
      FORTRAN_DOUBLEPRECISION = 29 + 0,
      FORTRAN_ENCODING = 30 + 0,
      FORTRAN_END_CASE = 31 + 0,
      FORTRAN_ENDDO = 32 + 0,
      FORTRAN_END_FILE = 33 + 0,
      FORTRAN_END_ENUM = 34 + 0,
      FORTRAN_END_INTERFACE = 35 + 0,
      FORTRAN_END_TYPE = 36 + 0,
      FORTRAN_ERR = 37 + 0,
      FORTRAN_ERRMSG = 38 + 0,
      FORTRAN_EXIT = 39 + 0,
      FORTRAN_ELSE = 40 + 0,
      FORTRAN_ELSEWHERE = 41 + 0,
      FORTRAN_ELSEIF = 42 + 0,
      FORTRAN_ENDIF = 43 + 0,
      FORTRAN_ENTRY = 44 + 0,
      FORTRAN_END = 45 + 0,
      FORTRAN_ENUM = 46 + 0,
      FORTRAN_ENUMERATOR = 47 + 0,
      FORTRAN_EQUIVALENCE = 48 + 0,
      FORTRAN_EXTERNAL = 49 + 0,
      FORTRAN_EXTENDS = 50 + 0,
      FORTRAN_FILE = 51 + 0,
      FORTRAN_FINAL = 52 + 0,
      FORTRAN_FMT = 53 + 0,
      FORTRAN_FORALL = 54 + 0,
      FORTRAN_FORM = 55 + 0,
      FORTRAN_FORMATTED = 56 + 0,
      FORTRAN_FORMAT = 57 + 0,
      FORTRAN_FLUSH = 58 + 0,
      FORTRAN_FUNCTION = 59 + 0,
      FORTRAN_GENERIC = 60 + 0,
      FORTRAN_GOTO = 61 + 0,
      FORTRAN_ID = 62 + 0,
      FORTRAN_IF = 63 + 0,
      FORTRAN_INQUIRE = 64 + 0,
      FORTRAN_INTEGER = 65 + 0,
      FORTRAN_IOMSG = 66 + 0,
      FORTRAN_IOSTAT = 67 + 0,
      FORTRAN_IMPLICIT = 68 + 0,
      FORTRAN_IMPLICIT_NONE = 69 + 0,
      FORTRAN_IMPORT = 70 + 0,
      FORTRAN_INTERFACE = 71 + 0,
      FORTRAN_INTENT = 72 + 0,
      FORTRAN_INTRINSIC = 73 + 0,
      FORTRAN_LEN = 74 + 0,
      FORTRAN_LOGICAL = 75 + 0,
      FORTRAN_KIND = 76 + 0,
      FORTRAN_MODULE_PROC = 77 + 0,
      FORTRAN_MODULE = 78 + 0,
      FORTRAN_NON_INTRINSIC = 79 + 0,
      FORTRAN_NON_OVERRIDABLE = 80 + 0,
      FORTRAN_NULL = 81 + 0,
      FORTRAN_NULLIFY = 82 + 0,
      FORTRAN_NAMELIST = 83 + 0,
      FORTRAN_NML = 84 + 0,
      FORTRAN_NONE = 85 + 0,
      FORTRAN_NOPASS = 86 + 0,
      FORTRAN_ONLY = 87 + 0,
      FORTRAN_OPEN = 88 + 0,
      FORTRAN_OPTIONAL = 89 + 0,
      FORTRAN_PARAMETER = 90 + 0,
      FORTRAN_PASS = 91 + 0,
      FORTRAN_PAUSE = 92 + 0,
      FORTRAN_POINTER = 93 + 0,
      FORTRAN_PRINT = 94 + 0,
      FORTRAN_PRIVATE = 95 + 0,
      FORTRAN_PROCEDURE = 96 + 0,
      FORTRAN_PROGRAM = 97 + 0,
      FORTRAN_PROTECTED = 98 + 0,
      FORTRAN_READ = 99 + 0,
      FORTRAN_REAL = 100 + 0,
      FORTRAN_RETURN = 101 + 0,
      FORTRAN_REWIND = 102 + 0,
      FORTRAN_ROUND = 103 + 0,
      FORTRAN_SELECTCASE = 104 + 0,
      FORTRAN_SELECTTYPE = 105 + 0,
      FORTRAN_SEQUENCE = 106 + 0,
      FORTRAN_SAVE = 107 + 0,
      FORTRAN_SIGN = 108 + 0,
      FORTRAN_SIZE = 109 + 0,
      FORTRAN_SOURCE = 110 + 0,
      FORTRAN_STAT = 111 + 0,
      FORTRAN_STOP = 112 + 0,
      FORTRAN_SUBROUTINE = 113 + 0,
      FORTRAN_TARGET = 114 + 0,
      FORTRAN_THEN = 115 + 0,
      FORTRAN_DERIVED_DECL = 116 + 0,
      FORTRAN_TYPEIS = 117 + 0,
      FORTRAN_UNFORMATTED = 118 + 0,
      FORTRAN_UNIT = 119 + 0,
      FORTRAN_USE = 120 + 0,
      FORTRAN_VALUE = 121 + 0,
      FORTRAN_VOLATILE = 122 + 0,
      FORTRAN_WAIT = 123 + 0,
      FORTRAN_WHERE = 124 + 0,
      FORTRAN_WRITE = 125 + 0,

   // DQ (11/27/2013): Added missing entries.
      FORTRAN_END_PROGRAM = 126 + 0,
      FORTRAN_END_FUNCTION = 127 + 0,
      FORTRAN_END_SUBROUTINE = 128 + 0,
      FORTRAN_END_MODULE = 129 + 0,
      FORTRAN_END_BLOCK_DATA = 130 + 0,
      FORTRAN_SUBMODULE = 131 + 0,
      FORTRAN_END_SUBMODULE = 132 + 0,
      FORTRAN_DOUBLE_COMPLEX = 133 + 0,
      FORTRAN_TYPE = 134 + 0,
      FORTRAN_ABSTRACT_INTERFACE = 135 + 0,
      FORTRAN_ERROR_STOP = 136 + 0,
      FORTRAN_CONTIGUOUS = 137 + 0,
      FORTRAN_PUBLIC = 138 + 0,

   // Function prefix keywords (Module keyword created above)
      FORTRAN_ELEMENTAL = 139 + 0,
      FORTRAN_IMPURE = 140 + 0,
      FORTRAN_PURE = 141 + 0,
      FORTRAN_RECURSIVE = 142 + 0,

   // IntentSpec keywords (these are combined keywords, perhaps should be done differently)
      FORTRAN_INTENT_IN = 143 + 0,
      FORTRAN_INTENT_OUT = 144 + 0,
      FORTRAN_INTENT_INOUT = 145 + 0,

      FORTRAN_ASSIGNMENT = 146 + 0,
      FORTRAN_OPERATOR = 147 + 0,

      FORTRAN_READ_FORMATTED = 148 + 0,
      FORTRAN_READ_UNFORMATTED = 149 + 0,
      FORTRAN_WRITE_FORMATTED = 150 + 0,
      FORTRAN_WRITE_UNFORMATTED = 151 + 0,

      FORTRAN_UNKNOWN = 152 + 0
   };

// Language specific enum values for C and C++ tokens
enum ROSE_C_CXX_keywords
   {
      C_CXX_ASM = 0 + 500,
      C_CXX_AUTO = 1 + 500,
      C_CXX_BOOL = 2 + 500,
      C_CXX_BREAK = 3 + 500,
      C_CXX_CASE = 4 + 500,
      C_CXX_CATCH = 5 + 500,
      C_CXX_CHAR = 6 + 500,
      C_CXX_CLASS = 7 + 500,
      C_CXX_CONST = 8 + 500,
      C_CXX_CONSTCAST = 9 + 500,
      C_CXX_CONTINUE = 10 + 500,
      C_CXX_DEFAULT = 11 + 500,
      C_CXX_DEFINED = 12 + 500,
      C_CXX_DELETE = 13 + 500,
      C_CXX_DO = 14 + 500,
      C_CXX_DOUBLE = 15 + 500,
      C_CXX_DYNAMICCAST = 16 + 500,
      C_CXX_ELSE = 17 + 500,
      C_CXX_ENUM = 18 + 500,
      C_CXX_EXPLICIT = 19 + 500,
      C_CXX_EXPORT = 20 + 500,
      C_CXX_EXTERN = 21 + 500,
      C_CXX_FALSE = 22 + 500,
      C_CXX_FLOAT = 23 + 500,
      C_CXX_FOR = 24 + 500,
      C_CXX_FRIEND = 25 + 500,
      C_CXX_GOTO = 26 + 500,
      C_CXX_IF = 27 + 500,
      C_CXX_INLINE = 28 + 500,
      C_CXX_INT = 29 + 500,
      C_CXX_LONG = 30 + 500,
      C_CXX_MUTABLE = 31 + 500,
      C_CXX_NAMESPACE = 32 + 500,
      C_CXX_NEW = 33 + 500,
      C_CXX_OPERATOR = 34 + 500,
      C_CXX_PRIVATE = 35 + 500,
      C_CXX_PROTECTED = 36 + 500,
      C_CXX_PUBLIC = 37 + 500,
      C_CXX_REGISTER = 38 + 500,
      C_CXX_REINTERPRETCAST = 39 + 500,
      C_CXX_RETURN = 40 + 500,
      C_CXX_SHORT = 41 + 500,
      C_CXX_SIGNED = 42 + 500,
      C_CXX_SIZEOF = 43 + 500,
      C_CXX_STATIC = 44 + 500,
      C_CXX_STATICCAST = 45 + 500,
      C_CXX_STRUCT = 46 + 500,
      C_CXX_SWITCH = 47 + 500,
      C_CXX_TEMPLATE = 48 + 500,
      C_CXX_THIS = 49 + 500,
      C_CXX_THROW = 50 + 500,
      C_CXX_TRY = 51 + 500,
      C_CXX_TRUE = 52 + 500,
      C_CXX_TYPEDEF = 53 + 500,
      C_CXX_TYPEID = 54 + 500,
      C_CXX_TYPENAME = 55 + 500,
      C_CXX_UNION = 56 + 500,
      C_CXX_UNSIGNED = 57 + 500,
      C_CXX_USING = 58 + 500,
      C_CXX_VIRTUAL = 59 + 500,
      C_CXX_VOID = 60 + 500,
      C_CXX_VOLATILE = 61 + 500,
      C_CXX_WCHART = 62 + 500,
      C_CXX_WHILE = 63 + 500
   };

// Language specific token enums for Fortran intrinsic operators
enum ROSE_Fortran_Operators
   {
      FORTRAN_INTRINSIC_PLUS = 0 + 10000,
      FORTRAN_INTRINSIC_MINUS = 1 + 10000,
      FORTRAN_INTRINSIC_POWER = 2 + 10000,
      FORTRAN_INTRINSIC_CONCAT = 3 + 10000,
      FORTRAN_INTRINSIC_TIMES = 4 + 10000,
      FORTRAN_INTRINSIC_DIVIDE = 5 + 10000,
      FORTRAN_INTRINSIC_AND = 6 + 10000,
      FORTRAN_INTRINSIC_OR = 7 + 10000,
      FORTRAN_INTRINSIC_EQV = 8 + 10000,
      FORTRAN_INTRINSIC_NEQV = 9 + 10000,
      FORTRAN_INTRINSIC_EQ = 10 + 10000,
      FORTRAN_INTRINSIC_NE = 11 + 10000,
      FORTRAN_INTRINSIC_GE = 12 + 10000,
      FORTRAN_INTRINSIC_LE = 13 + 10000,
      FORTRAN_INTRINSIC_LT = 14 + 10000,
      FORTRAN_INTRINSIC_GT = 15 + 10000,
      FORTRAN_INTRINSIC_NOT = 16 + 10000,
      FORTRAN_INTRINSIC_OLDEQ = 17 + 10000,
      FORTRAN_INTRINSIC_OLDNE = 18 + 10000,
      FORTRAN_INTRINSIC_OLDGE = 19 + 10000,
      FORTRAN_INTRINSIC_OLDLE = 20 + 10000,
      FORTRAN_INTRINSIC_OLDLT = 21 + 10000,
      FORTRAN_INTRINSIC_OLDGT = 22 + 10000
   };

enum ROSE_C_CXX_Operators
   {
      C_CXX_AND = 0 + 50000,
      C_CXX_ANDAND = 1 + 50000,
      C_CXX_ASSIGN = 2 + 50000,
      C_CXX_ANDASSIGN = 3 + 50000,
      C_CXX_OR = 4 + 50000,
      C_CXX_ORASSIGN = 5 + 50000,
      C_CXX_XOR = 6 + 50000,
      C_CXX_XORASSIGN = 7 + 50000,
      C_CXX_COMMA = 8 + 50000,
      C_CXX_COLON = 9 + 50000,
      C_CXX_DIVIDE = 10 + 50000,
      C_CXX_DIVIDEASSIGN = 11 + 50000,
      C_CXX_DOT = 12 + 50000,
      C_CXX_DOTSTAR = 13 + 50000,
      C_CXX_ELLIPSIS = 14 + 50000,
      C_CXX_EQUAL = 15 + 50000,
      C_CXX_GREATER = 16 + 50000,
      C_CXX_GREATEREQUAL = 17 + 50000,
      C_CXX_LEFTBRACE = 18 + 50000,
      C_CXX_LESS = 19 + 50000,
      C_CXX_LESSEQUAL = 20 + 50000,
      C_CXX_LEFTPAREN = 21 + 50000,
      C_CXX_LEFTBRACKET = 22 + 50000,
      C_CXX_MINUS = 23 + 50000,
      C_CXX_MINUSASSIGN = 24 + 50000,
      C_CXX_MINUSMINUS = 25 + 50000,
      C_CXX_PERCENT = 26 + 50000,
      C_CXX_PERCENTASSIGN = 27 + 50000,
      C_CXX_NOT = 28 + 50000,
      C_CXX_NOTEQUAL = 29 + 50000,
      C_CXX_OROR = 30 + 50000,
      C_CXX_PLUS = 31 + 50000,
      C_CXX_PLUSASSIGN = 32 + 50000,
      C_CXX_PLUSPLUS = 33 + 50000,
      C_CXX_ARROW = 34 + 50000,
      C_CXX_ARROWSTAR = 35 + 50000,
      C_CXX_QUESTION_MARK = 36 + 50000,
      C_CXX_RIGHTBRACE = 37 + 50000,
      C_CXX_RIGHTPAREN = 38 + 50000,
      C_CXX_RIGHTBRACKET = 39 + 50000,
      C_CXX_COLON_COLON = 40 + 50000,
      C_CXX_SEMICOLON = 41 + 50000,
      C_CXX_SHIFTLEFT = 42 + 50000,
      C_CXX_SHIFTLEFTASSIGN = 43 + 50000,
      C_CXX_SHIFTRIGHT = 44 + 50000,
      C_CXX_SHIFTRIGHTASSIGN = 45 + 50000,
      C_CXX_STAR = 46 + 50000,
      C_CXX_COMPL = 47 + 50000,
      C_CXX_STARASSIGN = 48 + 50000,
      C_CXX_POUND_POUND = 49 + 50000,
      C_CXX_POUND = 50 + 50000,
      C_CXX_AND_ALT = 51 + 50000,
      C_CXX_ANDASSIGN_ALT = 52 + 50000,
      C_CXX_OR_ALT = 53 + 50000,
      C_CXX_ORASSIGN_ALT = 54 + 50000,
      C_CXX_XOR_ALT = 55 + 50000,
      C_CXX_XORASSIGN_ALT = 56 + 50000,
      C_CXX_LEFTBRACE_ALT = 57 + 50000,
      C_CXX_LEFTBRACKET_ALT = 58 + 50000,
      C_CXX_NOT_ALT = 59 + 50000,
      C_CXX_NOTEQUAL_ALT = 60 + 50000,
      C_CXX_RIGHTBRACE_ALT = 61 + 50000,
      C_CXX_RIGHTBRACKET_ALT = 62 + 50000,
      C_CXX_COMPL_ALT = 63 + 50000,
      C_CXX_POUND_POUND_ALT = 64 + 50000,
      C_CXX_POUND_ALT = 65 + 50000,
      C_CXX_OR_TRIGRAPH = 66 + 50000,
      C_CXX_XOR_TRIGRAPH = 67 + 50000,
      C_CXX_LEFTBRACE_TRIGRAPH = 68 + 50000,
      C_CXX_LEFTBRACKET_TRIGRAPH = 69 + 50000,
      C_CXX_RIGHTBRACE_TRIGRAPH = 70 + 50000,
      C_CXX_RIGHTBRACKET_TRIGRAPH = 71 + 50000,
      C_CXX_COMPL_TRIGRAPH = 72 + 50000,
      C_CXX_POUND_POUND_TRIGRAPH = 73 + 50000,
      C_CXX_POUND_TRIGRAPH = 74 + 50000
   };

// Fortran specific additional token classifications
enum ROSE_Fortran_Additional_Info
   {
      FORTRAN_COMMENTS = 0 + 100000,
      FORTRAN_STRING_LITERALS = 1 + 100000,
      FORTRAN_IDENTIFIER = 2 + 100000,
      FORTRAN_UNIDENTIFIED_TOKEN = 3 + 100000,
      FORTRAN_ERROR = 4 + 100000
   };

     public:
       // DQ (4/14/2007): Modified to make this a const array
          static const token_element ROSE_Fortran_keyword_map[127];

       // DQ (11/20/2015): Added function to detect CR to support unparsing of whitespace defined up to an including only the first CR.
          bool isCarriageReturn() const;

HEADER_TOKEN_END


HEADER_LOCATED_NODE_SUPPORT_START
HEADER_LOCATED_NODE_SUPPORT_END

HEADER_RENAME_PAIR_START

          bool isRename() const;

HEADER_RENAME_PAIR_END

HEADER_INTERFACE_BODY_START

HEADER_INTERFACE_BODY_END

HEADER_HEADER_FILE_BODY_START

HEADER_HEADER_FILE_BODY_END


HEADER_UNTYPED_NODE_START
     public:
       // DQ (9/14/2014): Added to support more general unparsing for untyped ASTs.
          virtual void unparse(SgUnparse_Info& info);

HEADER_UNTYPED_NODE_END

HEADER_UNTYPED_EXPRESSION_START
HEADER_UNTYPED_EXPRESSION_END

HEADER_UNTYPED_UNARY_OPERATOR_START
HEADER_UNTYPED_UNARY_OPERATOR_END

HEADER_UNTYPED_BINARY_OPERATOR_START
HEADER_UNTYPED_BINARY_OPERATOR_END

HEADER_UNTYPED_EXPR_LIST_EXPRESSION_START
HEADER_UNTYPED_EXPR_LIST_EXPRESSION_END

HEADER_UNTYPED_VALUE_EXPRESSION_START
HEADER_UNTYPED_VALUE_EXPRESSION_END

HEADER_UNTYPED_ARRAY_REFERENCE_EXPRESSION_START
HEADER_UNTYPED_ARRAY_REFERENCE_EXPRESSION_END

HEADER_UNTYPED_SUBSCRIPT_EXPRESSION_START
HEADER_UNTYPED_SUBSCRIPT_EXPRESSION_END

HEADER_UNTYPED_OTHER_EXPRESSION_START
HEADER_UNTYPED_OTHER_EXPRESSION_END

HEADER_UNTYPED_NAMED_EXPRESSION_START
HEADER_UNTYPED_NAMED_EXPRESSION_END

HEADER_UNTYPED_NULL_EXPRESSION_START
HEADER_UNTYPED_NULL_EXPRESSION_END

HEADER_UNTYPED_FUNCTION_CALL_OR_ARRAY_REFERENCE_EXPRESSION_START
HEADER_UNTYPED_FUNCTION_CALL_OR_ARRAY_REFERENCE_EXPRESSION_END

HEADER_UNTYPED_STATEMENT_START
HEADER_UNTYPED_STATEMENT_END

HEADER_UNTYPED_ASSIGNMENT_STATEMENT_START
HEADER_UNTYPED_ASSIGNMENT_STATEMENT_END

HEADER_UNTYPED_BLOCK_STATEMENT_START
HEADER_UNTYPED_BLOCK_STATEMENT_END

HEADER_UNTYPED_EXPRESSION_STATEMENT_START
HEADER_UNTYPED_EXPRESSION_STATEMENT_END

HEADER_UNTYPED_FUNCTION_CALL_STATEMENT_START
HEADER_UNTYPED_FUNCTION_CALL_STATEMENT_END

HEADER_UNTYPED_IMAGE_CONTROL_STATEMENT_START
HEADER_UNTYPED_IMAGE_CONTROL_STATEMENT_END

HEADER_UNTYPED_OTHER_STATEMENT_START
HEADER_UNTYPED_OTHER_STATEMENT_END

HEADER_UNTYPED_USE_STATEMENT_START
HEADER_UNTYPED_USE_STATEMENT_END

HEADER_UNTYPED_NULL_STATEMENT_START
HEADER_UNTYPED_NULL_STATEMENT_END

HEADER_UNTYPED_NULL_DECLARATION_START
HEADER_UNTYPED_NULL_DECLARATION_END

HEADER_UNTYPED_IF_STATEMENT_START
HEADER_UNTYPED_IF_STATEMENT_END

HEADER_UNTYPED_CASE_STATEMENT_START
HEADER_UNTYPED_CASE_STATEMENT_END

HEADER_UNTYPED_LOOP_STATEMENT_START
HEADER_UNTYPED_LOOP_STATEMENT_END

HEADER_UNTYPED_WHILE_STATEMENT_START
HEADER_UNTYPED_WHILE_STATEMENT_END

HEADER_UNTYPED_FOR_STATEMENT_START
HEADER_UNTYPED_FOR_STATEMENT_END

HEADER_UNTYPED_FORALL_STATEMENT_START
HEADER_UNTYPED_FORALL_STATEMENT_END

HEADER_UNTYPED_EXIT_STATEMENT_START
HEADER_UNTYPED_EXIT_STATEMENT_END

HEADER_UNTYPED_GOTO_STATEMENT_START
HEADER_UNTYPED_GOTO_STATEMENT_END

HEADER_UNTYPED_PROCEDURE_CALL_STATEMENT_START
HEADER_UNTYPED_PROCEDURE_CALL_STATEMENT_END

HEADER_UNTYPED_RETURN_STATEMENT_START
HEADER_UNTYPED_RETURN_STATEMENT_END

HEADER_UNTYPED_EXTENDED_RETURN_STATEMENT_START
HEADER_UNTYPED_EXTENDED_RETURN_STATEMENT_END

HEADER_UNTYPED_STOP_STATEMENT_START
HEADER_UNTYPED_STOP_STATEMENT_END

HEADER_UNTYPED_ACCEPT_STATEMENT_START
HEADER_UNTYPED_ACCEPT_STATEMENT_END

HEADER_UNTYPED_ENTRY_CALL_STATEMENT_START
HEADER_UNTYPED_ENTRY_CALL_STATEMENT_END

HEADER_UNTYPED_REQUEUE_STATEMENT_START
HEADER_UNTYPED_REQUEUE_STATEMENT_END

HEADER_UNTYPED_DELAY_UNTIL_STATEMENT_START
HEADER_UNTYPED_DELAY_UNTIL_STATEMENT_END

HEADER_UNTYPED_DELAY_RELATIVE_STATEMENT_START
HEADER_UNTYPED_DELAY_RELATIVE_STATEMENT_END

HEADER_UNTYPED_TERMINATE_ALTERNATIVE_STATEMENT_START
HEADER_UNTYPED_TERMINATE_ALTERNATIVE_STATEMENT_END

HEADER_UNTYPED_SELECTIVE_ACCEPT_STATEMENT_START
HEADER_UNTYPED_SELECTIVE_ACCEPT_STATEMENT_END

HEADER_UNTYPED_TIMED_ENTRY_CALL_STATEMENT_START
HEADER_UNTYPED_TIMED_ENTRY_CALL_STATEMENT_END

HEADER_UNTYPED_CONDITIONAL_ENTRY_CALL_STATEMENT_START
HEADER_UNTYPED_CONDITIONAL_ENTRY_CALL_STATEMENT_END

HEADER_UNTYPED_ASYNCHRONOUS_SELECT_STATEMENT_START
HEADER_UNTYPED_ASYNCHRONOUS_SELECT_STATEMENT_END

HEADER_UNTYPED_ABORT_STATEMENT_START
HEADER_UNTYPED_ABORT_STATEMENT_END

HEADER_UNTYPED_RAISE_STATEMENT_START
HEADER_UNTYPED_RAISE_STATEMENT_END

HEADER_UNTYPED_CODE_STATEMENT_START
HEADER_UNTYPED_CODE_STATEMENT_END

HEADER_UNTYPED_DECLARATION_STATEMENT_START
HEADER_UNTYPED_DECLARATION_STATEMENT_END

HEADER_UNTYPED_DIRECTIVE_DECLARATION_START
HEADER_UNTYPED_DIRECTIVE_DECLARATION_END

HEADER_UNTYPED_ENUM_DECLARATION_START
HEADER_UNTYPED_ENUM_DECLARATION_END

HEADER_UNTYPED_LABEL_STATEMENT_START
HEADER_UNTYPED_LABEL_STATEMENT_END

HEADER_UNTYPED_NAMELIST_DECLARATION_START
HEADER_UNTYPED_NAMELIST_DECLARATION_END

HEADER_UNTYPED_INITIALIZED_NAMELIST_DECLARATION_START
HEADER_UNTYPED_INITIALIZED_NAMELIST_DECLARATION_END

HEADER_UNTYPED_IMPLICIT_DECLARATION_START
HEADER_UNTYPED_IMPLICIT_DECLARATION_END

HEADER_UNTYPED_VARIABLE_DECLARATION_START
HEADER_UNTYPED_VARIABLE_DECLARATION_END

HEADER_UNTYPED_TYPEDEF_DECLARATION_START
HEADER_UNTYPED_TYPEDEF_DECLARATION_END

HEADER_UNTYPED_PROGRAM_HEADER_DECLARATION_START
HEADER_UNTYPED_PROGRAM_HEADER_DECLARATION_END

HEADER_UNTYPED_FUNCTION_DECLARATION_START
HEADER_UNTYPED_FUNCTION_DECLARATION_END

HEADER_UNTYPED_MODULE_DECLARATION_START
HEADER_UNTYPED_MODULE_DECLARATION_END

HEADER_UNTYPED_SUBMODULE_DECLARATION_START
HEADER_UNTYPED_SUBMODULE_DECLARATION_END

HEADER_UNTYPED_BLOCK_DATA_DECLARATION_START
HEADER_UNTYPED_BLOCK_DATA_DECLARATION_END

HEADER_UNTYPED_SUBROUTINE_DECLARATION_START
HEADER_UNTYPED_SUBROUTINE_DECLARATION_END

HEADER_UNTYPED_PACKAGE_DECLARATION_START
HEADER_UNTYPED_PACKAGE_DECLARATION_END

HEADER_UNTYPED_STRUCTURE_DECLARATION_START
HEADER_UNTYPED_STRUCTURE_DECLARATION_END

HEADER_UNTYPED_STRUCTURE_DEFINITION_START
HEADER_UNTYPED_STRUCTURE_DEFINITION_END

HEADER_UNTYPED_EXCEPTION_DECLARATION_START
HEADER_UNTYPED_EXCEPTION_DECLARATION_END

HEADER_UNTYPED_EXCEPTION_HANDLER_DECLARATION_START
HEADER_UNTYPED_EXCEPTION_HANDLER_DECLARATION_END

HEADER_UNTYPED_TASK_DECLARATION_START
HEADER_UNTYPED_TASK_DECLARATION_END

HEADER_UNTYPED_UNIT_DECLARATION_START
HEADER_UNTYPED_UNIT_DECLARATION_END

HEADER_UNTYPED_INTERFACE_DECLARATION_START
HEADER_UNTYPED_INTERFACE_DECLARATION_END

HEADER_UNTYPED_SCOPE_START
HEADER_UNTYPED_SCOPE_END

HEADER_UNTYPED_FUNCTION_SCOPE_START
HEADER_UNTYPED_FUNCTION_SCOPE_END

HEADER_UNTYPED_MODULE_SCOPE_START
HEADER_UNTYPED_MODULE_SCOPE_END

HEADER_UNTYPED_GLOBAL_SCOPE_START
HEADER_UNTYPED_GLOBAL_SCOPE_END

HEADER_UNTYPED_INITIALIZED_NAME_START
HEADER_UNTYPED_INITIALIZED_NAME_END

HEADER_UNTYPED_REFERENCE_EXPRESSION_START
HEADER_UNTYPED_REFERENCE_EXPRESSION_END

HEADER_UNTYPED_TYPE_START
     public:
          enum type_enum
             {
               e_unknown,        //! default unspecified type as identified by parser.
               e_implicit,       //! implicit unspecified type for Fortran as identified by parser.
               e_void,           //! void type as identified by parser.
               e_int,            //! int type as identified by parser.
            // Rasmussen (10/17/2017): Added e_uint for Jovial
               e_uint,           //! unsigned int type as identified by parser.
               e_float,          //! float type as identified by parser.
               e_double,         //! double type as identified by parser.
               e_complex,        //! complex type as identified by parser.
               e_double_complex, //! double complex type as identified by parser.
               e_bool,           //! boolean type as identified by parser.
               e_char,           //! character type as identified by parser.
            // Rasmussen (03/29/2018): Added e_string for Fortran and Jovial
               e_string,         //! character string type as identified by parser.
            // Rasmussen (01/02/2018): Added e_bit, e_fixed, e_ptr, e_status for Jovial
               e_bit,            //! bit type as identified by parser.
               e_fixed,          //! fixed type as identified by parser.
               e_ptr,            //! ptr type as identified by parser.
               e_status,         //! status type as identified by parser.
            // Rasmussen (05/07/2019): Added e_user_defined for Fortran and e_table for Jovial
               e_table,          //! table type as identified by parser.
               e_user_defined,   //! type defined by the programmer as identified by the parser.
               e_last,           //! last type
             };

HEADER_UNTYPED_TYPE_END

HEADER_UNTYPED_ARRAY_TYPE_START
HEADER_UNTYPED_ARRAY_TYPE_END

HEADER_UNTYPED_TABLE_TYPE_START
HEADER_UNTYPED_TABLE_TYPE_END

HEADER_UNTYPED_ATTRIBUTE_START
HEADER_UNTYPED_ATTRIBUTE_END

HEADER_UNTYPED_NAME_START
HEADER_UNTYPED_NAME_END

HEADER_UNTYPED_TOKEN_START
HEADER_UNTYPED_TOKEN_END

HEADER_UNTYPED_TOKEN_PAIR_START
HEADER_UNTYPED_TOKEN_PAIR_END

HEADER_UNTYPED_NAMED_STATEMENT_START
HEADER_UNTYPED_NAMED_STATEMENT_END

HEADER_UNTYPED_FILE_START
HEADER_UNTYPED_FILE_END

HEADER_UNTYPED_STATEMENT_LIST_START
HEADER_UNTYPED_STATEMENT_LIST_END

HEADER_UNTYPED_DECLARATION_STATEMENT_LIST_START
HEADER_UNTYPED_DECLARATION_STATEMENT_LIST_END

HEADER_UNTYPED_FUNCTION_DECLARATION_LIST_START
HEADER_UNTYPED_FUNCTION_DECLARATION_LIST_END

HEADER_UNTYPED_INITIALIZED_NAME_LIST_START
HEADER_UNTYPED_INITIALIZED_NAME_LIST_END

HEADER_UNTYPED_NAME_LIST_START
HEADER_UNTYPED_NAME_LIST_END

HEADER_UNTYPED_TOKEN_LIST_START
HEADER_UNTYPED_TOKEN_LIST_END

HEADER_UNTYPED_TOKEN_PAIR_LIST_START
HEADER_UNTYPED_TOKEN_PAIR_LIST_END


HEADER_JAVA_MEMBER_VALUE_PAIR_START
HEADER_JAVA_MEMBER_VALUE_PAIR_END

HEADER_LAMBDA_CAPTURE_START
// DQ (9/3/2014): Adding support for C++11 lambda expresions.
HEADER_LAMBDA_CAPTURE_END


HEADER_LAMBDA_CAPTURE_LIST_START
// DQ (9/3/2014): Adding support for C++11 lambda expresions.
HEADER_LAMBDA_CAPTURE_LIST_END



// *************************************************
// *************************************************
//                  Source Code
// *************************************************
// *************************************************

SOURCE_START

#if 0
// DQ (4/10/2006): This is replaced by a better interface for attributes.
AstAttributeMechanism & 
SgLocatedNode::attribute()
   {
  // DQ (1/2/2006): This function preserves as much of
  // the syntax of attribute being a public data member.
     if (p_attribute == NULL)
        {
          printf ("Error: p_attribute == NULL  (node = %s) \n",class_name().c_str());
          ROSE_ASSERT(false);
        }

     return *p_attribute;
   }
#endif

#if 0
const char*
SgLocatedNode::getFileName ()
   {
  // Function added by DQ (7/22/2001)

     const char* fileName = "NO NAME FILE";
  // Sometimes the locatedNode doesn't have a SgFile object 
  // (likely because it is part of a parent statement object)
     if (get_file_info() != NULL)
        {
          Sg_File_Info* fileInfo = get_file_info();
          ROSE_ASSERT (fileInfo != NULL);
          fileName = fileInfo->get_filename();
          ROSE_ASSERT (fileName != NULL);
        }

     return fileName;
   }
#endif

const std::string &
SgLocatedNode::getFilenameString() const
   {
  // Function added by DQ (2/2/2007) to replace depricated function const char* SgLocatedNode::getFileName()
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     return get_startOfConstruct()->get_filenameString();
   }

Sg_File_Info*
SgLocatedNode::get_file_info() const
   {
  // DQ (11/8/2006):
  // At this level in the hierarchy of AST IR nodes we want the get_file_info() 
  // member function to be mapped to the get_startOfConstruct() member function.
  // For SgExpression IR nodes we will map it to the get_operatorPosition() 
  // member function.
     return get_startOfConstruct();
   }

void
SgLocatedNode::set_file_info( Sg_File_Info* fileInfo )
   {
  // DQ (5.14.2006): Allow input to be NULL so that we can safely reset the Sg_File_Info pointer.
  // ROSE_ASSERT (fileInfo != NULL);
     set_startOfConstruct(fileInfo);
#ifndef REMOVE_SET_PARENT_FUNCTION
     fileInfo->set_parent(this);
#endif
   }

void
SgLocatedNode::post_construction_initialization()
   {
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

  // Make sure that the pointer to the data structure storing the
  // attached PreprocessingInfo objects is NULL
     p_attachedPreprocessingInfoPtr = NULL;

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_startOfConstruct != NULL)
        {
          p_startOfConstruct->set_parent(this);
        }

  // DQ (12/17/2006): Added semantics to set the parent of any avaliable Sg_File_Info objects.
     if (p_endOfConstruct != NULL)
        {
          p_endOfConstruct->set_parent(this);
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setCompilerGenerated ()
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setCompilerGenerated();
     get_endOfConstruct()->setCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setCompilerGenerated();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetCompilerGenerated()
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetCompilerGenerated();
     get_endOfConstruct()->unsetCompilerGenerated();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetCompilerGenerated();
        }
   }

bool
SgLocatedNode::isCompilerGenerated () const
   {
  // DQ (7/5/2014): Added function to define a simple API.

  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);

     bool result = get_startOfConstruct()->isCompilerGenerated();
     // ROSE_ASSERT(result == get_endOfConstruct()->isCompilerGenerated()); // FIXME fails on SgInitializedName = ::std::_Vector_base < Real_t , allocator< Real_t > >::_M_impl

     const SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(result == expression->get_operatorPosition()->isCompilerGenerated());
        }

     return result;
   }


// DQ (4/14/2015): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setTransformation ()
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setTransformation();
     get_endOfConstruct()->setTransformation();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setTransformation();
        }
   }

// DQ (4/14/2015): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetTransformation()
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetTransformation();
     get_endOfConstruct()->unsetTransformation();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetTransformation();
        }
   }

bool
SgLocatedNode::isTransformation () const
   {
  // DQ (12/4/2014): Added function to define a simple API.

  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_startOfConstruct() != NULL);

     bool result = get_startOfConstruct()->isTransformation();

  // DQ (4/6/2015): Allow this to work even when the endOfConstruct is not yet set (required for inlining).
  // ROSE_ASSERT(get_endOfConstruct() != NULL);
     if (get_endOfConstruct() != NULL)
        {
          ROSE_ASSERT(result == get_endOfConstruct()->isTransformation());
        }
       else
        {
          printf ("WARNING: In SgLocatedNode::isTransformation(): this = %p = %s testing: get_endOfConstruct() != NULL (failed) \n",this,this->class_name().c_str());
        }

     const SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
#if 0
          printf ("NOTE: this = %p = %s testing: result != expression->get_operatorPosition()->isTransformation() \n",this,this->class_name().c_str());
#endif
          if (result != expression->get_operatorPosition()->isTransformation())
             {
               printf ("Warning: this = %p = %s result != expression->get_operatorPosition()->isTransformation() \n",this,this->class_name().c_str());
               printf ("   --- Suggest calling the set transformation on the SgLocated node directly, instead of on the SgFileInfo objects seperately. \n");
             }
       // DQ (12/13/2018): This is difficult to enforce and causes an error in the outlining tests for Fortran in roseTests/astOutliningTests.
       // When we eliminate the alternative interface to set this in each Sg_FileInfo object then it will be easier to enforce. So for now
       // just issue the warning.
       // ROSE_ASSERT(result == expression->get_operatorPosition()->isTransformation());
        }

     return result;
   }


// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setFrontendSpecific ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setFrontendSpecific();
     get_endOfConstruct()->setFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetFrontendSpecific()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetFrontendSpecific();
     get_endOfConstruct()->unsetFrontendSpecific();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetFrontendSpecific();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setSourcePositionUnavailableInFrontend ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->setSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetSourcePositionUnavailableInFrontend()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetSourcePositionUnavailableInFrontend();
     get_endOfConstruct()->unsetSourcePositionUnavailableInFrontend();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetSourcePositionUnavailableInFrontend();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::setOutputInCodeGeneration ()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->setOutputInCodeGeneration();
     get_endOfConstruct()->setOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setOutputInCodeGeneration();
        }
   }

// DQ (12/22/2006): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
void
SgLocatedNode::unsetOutputInCodeGeneration()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     get_startOfConstruct()->unsetOutputInCodeGeneration();
     get_endOfConstruct()->unsetOutputInCodeGeneration();

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          ROSE_ASSERT(expression->get_operatorPosition() != NULL);
          expression->get_operatorPosition()->unsetOutputInCodeGeneration();
        }
   }

// DQ (10/25/20018): These function are part of a move to lift the interface for
// IR node classification from the Sg_File_Info object to the SgLocatedNode (at least).
int
SgLocatedNode::get_physical_file_id()
   {
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     ROSE_ASSERT(get_endOfConstruct() != NULL);
     ROSE_ASSERT(get_startOfConstruct()->get_physical_file_id() == get_endOfConstruct()->get_physical_file_id());

     SgExpression* expression = isSgExpression(this);
     if (expression != NULL && expression->get_operatorPosition() != NULL)
        {
          expression->get_operatorPosition()->setOutputInCodeGeneration();
          ROSE_ASSERT(expression->get_operatorPosition()->get_physical_file_id() == get_endOfConstruct()->get_physical_file_id());
        }

  // Return any one of these since they are all checked to be equal.
     return get_startOfConstruct()->get_physical_file_id();
   }


#if 0
SgLocatedNode::~SgLocatedNode()
   {
  // Some expressions are initialized with NULL_FILE (which is a null Sg_File_Info pointer)
  // so we can't assert that p_file_info != NULL.
  // ROSE_ASSERT(p_file_info != NULL);

#if 0
  // At the moment uncommenting this will cause SAGE 3 to crash 
  // (SAGE 2 never tried to cleanup memory leaks and is it not 
  // done well in SAGE 3 yet either, though it is started).
     ROSE_ASSERT(get_file_info()->getReferenceCount() > 0);
     get_file_info()->decrementReferenceCount();
     if (get_file_info()->getReferenceCount() == 0)
        {
       // We need to add reference counting to Sg_File_Info objects 
       // before we can properly cleanup the meory that they allocate
          delete p _ file _ info;
        }
#endif

  // p_file_info = NULL;
     set_startOfConstruct(NULL);
     set_endOfConstruct(NULL);
   } 
#endif

#if 0
void SgLocatedNode::directives(ostream& os)
   {
#if 0
     if (p_file_info) 
        {
          p_file_info->output(os);
        }
     output_pragma(os);

#if MEIDEBUG 
     SgExpression *e=isSgExpression(this);
     if(e && e->get_is_lvalue())
        {
          os << "<a_LVAL>";
        }
#endif
#else
     printf ("ERROR: not yet implemented within SAGE3! \n");
     abort();
#endif
   }
#endif

#if 0
void 
SgLocatedNode::setlineNumber(unsigned long new_line)
   {
     if (p_file_info == 0) 
        {
          p_file_info = new Sg_File_Info(0, new_line, 0);
        }
       else 
        {
          p_file_info->set_line(new_line);
        }
   }
#endif

#if 0
void 
SgLocatedNode::delete_file_info() 
   {
     if (p_file_info != 0)
        {
          p_file_info->deregister_node(this);
          p_file_info = 0;
        }
   }
#endif

#if 0
bool
SgLocatedNode::_print(int depth) const
   {
     if (SgNode::_print(depth))
        {
          Sg_print_info().output_field(get_file_info(),depth+1);
          return true;
        }

     return false;
   }
#endif

// [MK] Member function to attach PreprocessingInfo object to the node
void
SgLocatedNode::addToAttachedPreprocessingInfo(
     PreprocessingInfo *prepInfoPtr,
  // PositionOfPreprocessingInfoInListType locationInList )
     PreprocessingInfo::RelativePositionType locationInList )
   {
  // DQ (11/23/2008): Is this comment still true?  Is there something to fix here?
  // There are places in ROSE where the comments is added before the statement
  // though most commonly the comment is added after the statement.  So I think that
  // this interface is required adn that it need not be fixed.

  // DQ (9/19/2003)
  // This function takes a PreprocessingInfo::RelativePositionType type parameter which
  // makes no since because it is used only to determine if the new comment/directive is
  // added to the front or back of the current list of comments/directives.  It does not 
  // change the value of the PreprocessingInfo::RelativePositionType field in the
  // PreprocessingInfo object that it takes for the other parameter (nor should it).
  // This function was poorly desinged in the first place and needs to be fixed!!!
  // printf ("In LocatedNode::addToAttachedPreprocessingInfo(PreprocessingInfo,PreprocessingInfo::RelativePositionType): FIX INTERFACE!!!! \n");

     ROSE_ASSERT(prepInfoPtr != NULL);

#if 0
     printf ("In SgLocatedNode::addToAttachedPreprocessingInfo(): Current node is a %s: prepInfoPtr->getString() = %s \n",class_name().c_str(),prepInfoPtr->getString().c_str());
#endif

  // Nodes that should not have comments attached (since they are not unparsed)

  // DQ (1/28/2013): Now that we correctly handle the source position for SgForInitStatement,
  // I think we can allow CPP directives and comments to be attached to this IR node (failed
  // for Zsh: params.c).  Now tested using test2013_48.C, though comments not output precisely.
  // ROSE_ASSERT (dynamic_cast<SgForInitStatement*>(this) == NULL);

     ROSE_ASSERT (dynamic_cast<SgTypedefSeq*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCatchStatementSeq*>(this) == NULL);

  // These should not be used but are are least handled in the unparser (if not debugged)
  // ROSE_ASSERT (dynamic_cast<SgFunctionParameterList*>(this) == NULL);
     ROSE_ASSERT (dynamic_cast<SgCtorInitializerList*>(this) == NULL);

     SgFunctionParameterList* functionParameterList = isSgFunctionParameterList(this);
     if (functionParameterList != NULL)
        {
#if 0
       // DQ (10/8/2012): Commented out to provide less output spew.
          printf ("SgFunctionParameterList are not typically associated with comments or CPP directives \n");
#endif
          ROSE_ASSERT(get_startOfConstruct() != NULL);
          ROSE_ASSERT(get_endOfConstruct() != NULL);
        }

  // Create data structure for storing the attached PreprocessingInfo objects, if necessary
     if (p_attachedPreprocessingInfoPtr == NULL)
        {
          p_attachedPreprocessingInfoPtr = new AttachedPreprocessingInfoType;
          ROSE_ASSERT(p_attachedPreprocessingInfoPtr != NULL);
        }

#if 0
     printf ("In SgLocatedNode::addToAttachedPreprocessingInfo(): locationInList = %s \n",PreprocessingInfo::relativePositionName(locationInList).c_str());
#endif

  // Add the current PreprocessingInfo object
     switch (locationInList)
        {
          case PreprocessingInfo::defaultValue:
          case PreprocessingInfo::undef:
               printf ("Error: defaultValue or undef value found in switch statement \n");
               ROSE_ASSERT(false);
               break;

          case PreprocessingInfo::before:
               p_attachedPreprocessingInfoPtr->insert(p_attachedPreprocessingInfoPtr->begin(),prepInfoPtr);
               break;

          case PreprocessingInfo::after:
            // (9/10/2003) DQ: Force new comments to be attached closest to the target statement
               p_attachedPreprocessingInfoPtr->push_back(prepInfoPtr);
               break;

          default:
               printf ("Error: default found in switch statement \n");
               ROSE_ASSERT(false);
        }
   }
// Liao 1/27/2015   
// Insert prepInfo right after (or before) an existing anchor info in the preprocessing info list
void
SgLocatedNode::insertToAttachedPreprocessingInfo(
     PreprocessingInfo *prepInfoPtr,
     PreprocessingInfo *anchorInfoPtr,
     bool insertAfter /*= true*/
     )
   {
     ROSE_ASSERT(prepInfoPtr != NULL);
     ROSE_ASSERT(anchorInfoPtr != NULL);
    // This function assumes the list already exists 
     ROSE_ASSERT (p_attachedPreprocessingInfoPtr != NULL);
  
    AttachedPreprocessingInfoType::iterator anchor_iter = find(
                  p_attachedPreprocessingInfoPtr->begin(), p_attachedPreprocessingInfoPtr->end(), anchorInfoPtr);

     if (insertAfter )
             p_attachedPreprocessingInfoPtr->insert(anchor_iter+1,prepInfoPtr);
      else      
             p_attachedPreprocessingInfoPtr->insert(anchor_iter, prepInfoPtr);
  }


// [MK] Member function to return attached PreprocessingInfo objects
AttachedPreprocessingInfoType*&
SgLocatedNode::getAttachedPreprocessingInfo(void)
   {
     return p_attachedPreprocessingInfoPtr;
   }

Sg_File_Info*
SgLocatedNode::generateMatchingFileInfo()
   {
  // DQ (12/30/2009): Added this function to remove previous global function in large 
  // ROSETTA generated file so that we could support smaller ROSETTA generated files.

  // DQ (11/20/2004): Modified to provide more accurate information, use the 
  // copy constructor instead of the constructor that takes a file name.
  // return new Sg_File_Info( p->get_file_info()->get_filename());

#if 0
  // DQ (1/27/2019): Skipping the generation of a proper symbol when get_startOfConstruct() == NULL 
  // so that we can debug the dot graph for a symbol withouth proper basis.

  // DQ (11/6/2006): startOfConstruct is the one Sg_File_Info that will always exist and must exist.
  // ROSE_ASSERT(get_startOfConstruct() != NULL);
     Sg_File_Info* returnFileInfo = NULL;
     if (get_startOfConstruct() != NULL)
        {
          returnFileInfo = new Sg_File_Info(*(get_startOfConstruct()));
        }
       else
        {
          printf ("In SgLocatedNode::generateMatchingFileInfo(): Skipping the generation of a proper symbol when get_startOfConstruct() == NULL \n");
       // returnFileInfo = new Sg_File_Info();
          returnFileInfo = Sg_File_Info::generateDefaultFileInfoForTransformationNode();
        }
     ROSE_ASSERT(returnFileInfo != NULL);
#else
     ROSE_ASSERT(get_startOfConstruct() != NULL);
     Sg_File_Info* returnFileInfo = new Sg_File_Info(*(get_startOfConstruct()));
     ROSE_ASSERT(returnFileInfo != NULL);
#endif

  // printf ("In New_File_Info: returnFileInfo = %p \n",returnFileInfo);

     return returnFileInfo;
   }

SOURCE_END



SOURCE_TOKEN_START
/*
Some assumptions:
We know that keywords in FORTRAN can be separated by whitespace
Our lexer handles end if as two identifiers with lexemes "end", "if"
A later pass can coalese these two identifers into one token 
   of type ROSE_IDENTIFIER
   of lexeme "end if"
Look at the the coalese tokens phase
*/

// DQ (4/14/2007): Modified to use new enum values
// DQ (3/24/2007): I would like to make this a const array (double check with Rama).
const SgToken::token_element SgToken::ROSE_Fortran_keyword_map[127] = 
   {
      {"abstract",             SgToken::FORTRAN_ABSTRACT}, 
      {"access",               SgToken::FORTRAN_ACCESS}, 
      {"action",               SgToken::FORTRAN_ACTION}, 
      {"abstractinterface",    SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"allocate",             SgToken::FORTRAN_ALLOCATE},            /*   GFORTRAN/G95 equivalent is ST_ALLOCATE        */
      {"allocatable",          SgToken::FORTRAN_ALLOCATABLE},         /*   GFORTRAN/G95 equivalent is ST_ALLOCATABLE     */
      {"assign",               SgToken::FORTRAN_ASSIGN},              /*   GFORTRAN/G95 equivalent is ST_ASSIGN          */
      {"associate",            SgToken::FORTRAN_ASSOCIATE}, 
      {"asynchronous",         SgToken::FORTRAN_ASYNCHRONOUS},        /*   GFORTRAN/G95 equivalent is ST_ASYNCHRONOUS    */
      {"backspace",            SgToken::FORTRAN_BACKSPACE},           /*   GFORTRAN/G95 equivalent is ST_BACKSPACE       */
      {"bind",                 SgToken::FORTRAN_BIND},                /*   GFORTRAN/G95 equivalent is ST_BIND            */
      {"blank",                SgToken::FORTRAN_BLANK},         
      {"blockdata",            SgToken::FORTRAN_BLOCK_DATA},          /*   GFORTRAN/G95 equivalent is ST_BLOCK_DATA      */
      {"call",                 SgToken::FORTRAN_CALL},                /*   GFORTRAN/G95 equivalent is ST_CALL            */
      {"character",            SgToken::FORTRAN_CHARACTER}, 
      {"class",                SgToken::FORTRAN_CLASS},
      {"close",                SgToken::FORTRAN_CLOSE},               /*   GFORTRAN/G95 equivalent is ST_CLOSE           */
      {"continue",             SgToken::FORTRAN_CONTINUE},            /*   GFORTRAN/G95 equivalent is ST_CONTINUE        */
      {"cycle",                SgToken::FORTRAN_CYCLE},               /*   GFORTRAN/G95 equivalent is ST_CYCLE           */
      {"case",                 SgToken::FORTRAN_CASE},                /*   GFORTRAN/G95 equivalent is ST_CASE            */
      {"common",               SgToken::FORTRAN_COMMON},              /*   GFORTRAN/G95 equivalent is ST_COMMON          */
      {"complex",              SgToken::FORTRAN_COMPLEX},
      {"contains",             SgToken::FORTRAN_CONTAINS},            /*   GFORTRAN/G95 equivalent is ST_CONTAINS        */
      {"deallocate",           SgToken::FORTRAN_DEALLOCATE},          /*   GFORTRAN/G95 equivalent is ST_DEALLOCATE      */
      {"data",                 SgToken::FORTRAN_DATA},                /*   GFORTRAN/G95 equivalent is ST_DATA            */
      {"deferred",             SgToken::FORTRAN_DEFERRED},  
      {"delim",                SgToken::FORTRAN_DELIM},  
      {"dimension",            SgToken::FORTRAN_DIMENSION},           /*   GFORTRAN/G95 equivalent is ST_DIMENSION       */
      {"do",                   SgToken::FORTRAN_DO},
      {"dt",                   SgToken::FORTRAN_DT},
      {"doubleprecision",      SgToken::FORTRAN_DOUBLEPRECISION},
      {"encoding",             SgToken::FORTRAN_ENCODING},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endcase",              SgToken::FORTRAN_END_CASE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"enddo",                SgToken::FORTRAN_ENDDO},               /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endfile",              SgToken::FORTRAN_END_FILE},            /*   GFORTRAN/G95 equivalent is ST_END_FILE        */
      {"endenum",              SgToken::FORTRAN_END_ENUM}, 
      {"endinterface",         SgToken::FORTRAN_END_INTERFACE}, 
      {"endtype",              SgToken::FORTRAN_END_TYPE}, 
      {"err",                  SgToken::FORTRAN_ERR}, 
      {"errmsg",               SgToken::FORTRAN_ERRMSG}, 
      {"exit",                 SgToken::FORTRAN_EXIT},                /*   GFORTRAN/G95 equivalent is ST_EXIT            */
      {"else",                 SgToken::FORTRAN_ELSE},                /*   GFORTRAN/G95 equivalent is ST_ELSE            */
      {"elsewhere",            SgToken::FORTRAN_ELSEWHERE},           /*   GFORTRAN/G95 equivalent is ST_ELSEWHERE       */
      {"elseif",               SgToken::FORTRAN_ELSEIF},              /*   GFORTRAN/G95 equivalent is ST_ELSEIF          */
      {"endif",                SgToken::FORTRAN_ENDIF},
      {"entry% ",              SgToken::FORTRAN_ENTRY},               /*   GFORTRAN/G95 equivalent is ST_ENTRY           */
      {"end",                  SgToken::FORTRAN_END},             
      {"enum",                 SgToken::FORTRAN_ENUM},                /*   GFORTRAN/G95 equivalent is ST_ENUM            */
      {"enumerator",           SgToken::FORTRAN_ENUMERATOR},          /*   GFORTRAN/G95 equivalent is ST_ENUMERATOR      */
      {"equivalence",          SgToken::FORTRAN_EQUIVALENCE},         /*   GFORTRAN/G95 equivalent is ST_EQUIVALENCE     */
      {"external",             SgToken::FORTRAN_EXTERNAL},            /*   GFORTRAN/G95 equivalent is ST_EXTERNAL        */
      {"extends",              SgToken::FORTRAN_EXTENDS}, 
      {"file",                 SgToken::FORTRAN_FILE}, 
      {"final",                SgToken::FORTRAN_FINAL},               /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"fmt",                  SgToken::FORTRAN_FMT},                 /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"forall",               SgToken::FORTRAN_FORALL},              /*   GFORTRAN/G95 equivalent is ST_FORALL          */
      {"form",                 SgToken::FORTRAN_FORM},  
      {"formatted",            SgToken::FORTRAN_FORMATTED},  
      {"format",               SgToken::FORTRAN_FORMAT},              /*   GFORTRAN/G95 equivalent is ST_FORMAT          */
      {"flush",                SgToken::FORTRAN_FLUSH},               /*   GFORTRAN/G95 equivalent is ST_FLUSH           */
      {"function",             SgToken::FORTRAN_FUNCTION},         
      {"generic",              SgToken::FORTRAN_GENERIC},             /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"goto",                 SgToken::FORTRAN_GOTO},                /*   GFORTRAN/G95 equivalent is ST_GOTO            */
      {"id",                   SgToken::FORTRAN_ID},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"if",                   SgToken::FORTRAN_IF},                  /*   GFORTRAN/G95 equivalent is ST_IF,             */
      {"inquire",              SgToken::FORTRAN_INQUIRE},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"integer",              SgToken::FORTRAN_INTEGER},             /*   GFORTRAN/G95 equivalent is ST_INQUIRE         */
      {"iomsg",                SgToken::FORTRAN_IOMSG}, 
      {"iostat",               SgToken::FORTRAN_IOSTAT}, 
      {"implicit",             SgToken::FORTRAN_IMPLICIT},            /*   GFORTRAN/G95 equivalent is ST_IMPLICIT        */
      {"implicitnone",         SgToken::FORTRAN_IMPLICIT_NONE},       /*   GFORTRAN/G95 equivalent is ST_IMPLICIT_NONE   */
      {"import",               SgToken::FORTRAN_IMPORT},              /*   GFORTRAN/G95 equivalent is ST_IMPORT          */
      {"interface",            SgToken::FORTRAN_INTERFACE},           /*   GFORTRAN/G95 equivalent is ST_INTERFACE       */
      {"intent",               SgToken::FORTRAN_INTENT},              /*   GFORTRAN/G95 equivalent is ST_INTENT          */
      {"intrinsic",            SgToken::FORTRAN_INTRINSIC},           /*   GFORTRAN/G95 equivalent is ST_INTRINSIC       */
      {"len",                  SgToken::FORTRAN_LEN},         
      {"logical",              SgToken::FORTRAN_LOGICAL},          
      {"kind",                 SgToken::FORTRAN_KIND}, 
      {"moduleprocedure",      SgToken::FORTRAN_MODULE_PROC},         /*   GFORTRAN/G95 equivalent is ST_E_MODULE_PROC   */
      {"module",               SgToken::FORTRAN_MODULE},              /*   GFORTRAN/G95 equivalent is ST_MODULE          */
      {"non_intrinsic",        SgToken::FORTRAN_NON_INTRINSIC},       /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"non_overridable",      SgToken::FORTRAN_NON_OVERRIDABLE},     /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"null",                 SgToken::FORTRAN_NULL},
      {"nullify",              SgToken::FORTRAN_NULLIFY},             /*   GFORTRAN/G95 equivalent is ST_NULLIFY         */
      {"namelist",             SgToken::FORTRAN_NAMELIST},            /*   GFORTRAN/G95 equivalent is ST_NAMELIST        */
      {"nml",                  SgToken::FORTRAN_NML},
      {"none",                 SgToken::FORTRAN_NONE},                /*   GFORTRAN/G95 equivalent is ST_NONE            */
      {"nopass",               SgToken::FORTRAN_NOPASS},  
      {"only",                 SgToken::FORTRAN_ONLY},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"open",                 SgToken::FORTRAN_OPEN},                /*   GFORTRAN/G95 equivalent is ST_OPEN            */
      {"optional",             SgToken::FORTRAN_OPTIONAL},            /*   GFORTRAN/G95 equivalent is ST_OPTIONAL        */
      {"parameter",            SgToken::FORTRAN_PARAMETER},           /*   GFORTRAN/G95 equivalent is ST_PARAMETER       */
      {"pass",                 SgToken::FORTRAN_PASS}, 
      {"pause",                SgToken::FORTRAN_PAUSE},               /*   GFORTRAN/G95 equivalent is ST_PAUSE           */
      {"pointer",              SgToken::FORTRAN_POINTER},             /*   GFORTRAN/G95 equivalent is ST_POINTER         */
      {"print",                SgToken::FORTRAN_PRINT},               /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"private",              SgToken::FORTRAN_PRIVATE},             /*   GFORTRAN/G95 equivalent is ST_PRINT           */
      {"procedure",            SgToken::FORTRAN_PROCEDURE},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"program",              SgToken::FORTRAN_PROGRAM},             /*   GFORTRAN/G95 equivalent is ST_PROGRAM         */
      {"protected",            SgToken::FORTRAN_PROTECTED},           /*   GFORTRAN/G95 equivalent is ST_DATA_DECL       */
      {"read",                 SgToken::FORTRAN_READ},                /*   GFORTRAN/G95 equivalent is ST_READ            */
      {"real",                 SgToken::FORTRAN_REAL}, 
      {"return",               SgToken::FORTRAN_RETURN},              /*   GFORTRAN/G95 equivalent is ST_RETURN          */
      {"rewind",               SgToken::FORTRAN_REWIND},              /*   GFORTRAN/G95 equivalent is ST_REWIND          */
      {"round",                SgToken::FORTRAN_ROUND},  
      {"selectcase",           SgToken::FORTRAN_SELECTCASE}, 
      {"selecttype",           SgToken::FORTRAN_SELECTTYPE}, 
      {"sequence",             SgToken::FORTRAN_SEQUENCE},            /*   GFORTRAN/G95 equivalent is ST_SEQUENCE        */
      {"save",                 SgToken::FORTRAN_SAVE},                /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"sign",                 SgToken::FORTRAN_SIGN}, 
      {"size",                 SgToken::FORTRAN_SIZE}, 
      {"source",               SgToken::FORTRAN_SOURCE},              /*   GFORTRAN/G95 equivalent is ST_SAVE            */
      {"stat",                 SgToken::FORTRAN_STAT}, 
      {"stop",                 SgToken::FORTRAN_STOP},                /*   GFORTRAN/G95 equivalent is ST_STOP            */
      {"subroutine",           SgToken::FORTRAN_SUBROUTINE},
      {"target",               SgToken::FORTRAN_TARGET},              /*   GFORTRAN/G95 equivalent is ST_TARGET          */
      {"then",                 SgToken::FORTRAN_THEN}, 
      {"type",                 SgToken::FORTRAN_DERIVED_DECL},        /*   GFORTRAN/G95 equivalent is ST_DERIVED_DECL    */
      {"typeis",               SgToken::FORTRAN_TYPEIS}, 
      {"unformatted",          SgToken::FORTRAN_UNFORMATTED}, 
      {"unit",                 SgToken::FORTRAN_UNIT}, 
      {"use",                  SgToken::FORTRAN_USE},                 /*   GFORTRAN/G95 equivalent is ST_USE             */
      {"value",                SgToken::FORTRAN_VALUE},               /*   GFORTRAN/G95 equivalent is ST_VALUE           */
      {"volatile",             SgToken::FORTRAN_VOLATILE},            /*   GFORTRAN/G95 equivalent is ST_VOLATILE        */
      {"wait",                 SgToken::FORTRAN_WAIT},                /*   GFORTRAN/G95 equivalent is ST_WAIT            */
      {"where",                SgToken::FORTRAN_WHERE},               /*   GFORTRAN/G95 equivalent is ST_WHERE,          */
      {"write",                SgToken::FORTRAN_WRITE}                /*   GFORTRAN/G95 equivalent is ST_WRITE           */
   };


bool
SgToken::isCarriageReturn() const
   {
  // DQ (11/20/2015): Added function to detect CR to support unparsing of whitespace defined up to an including only the first CR.
     return (get_lexeme_string() == "\n");
   }

SOURCE_TOKEN_END

SOURCE_LOCATED_NODE_SUPPORT_START
SOURCE_LOCATED_NODE_SUPPORT_END

SOURCE_RENAME_PAIR_START

bool
SgRenamePair::isRename() const
   {
  // This a treated as a valid renaming if the names are different.
     return (p_local_name != p_use_name);
   }

SOURCE_RENAME_PAIR_END

SOURCE_INTERFACE_BODY_START

SOURCE_INTERFACE_BODY_END

SOURCE_HEADER_FILE_BODY_START

SOURCE_HEADER_FILE_BODY_END



SOURCE_UNTYPED_NODE_START
// DQ (9/14/2014): Added to support more general unparsing for untyped ASTs.
void SgUntypedNode::unparse(SgUnparse_Info& info)
   {
  // DQ (9/14/2014): Until we decide what the best implementation is this is enough.
     printf ("SgUntypedNode::unparse() function not implemented! (should maybe be a pure virtual member function) \n");
   }

SOURCE_UNTYPED_NODE_END

SOURCE_UNTYPED_EXPRESSION_START
SOURCE_UNTYPED_EXPRESSION_END

SOURCE_UNTYPED_UNARY_OPERATOR_START
SOURCE_UNTYPED_UNARY_OPERATOR_END

SOURCE_UNTYPED_BINARY_OPERATOR_START
SOURCE_UNTYPED_BINARY_OPERATOR_END

SOURCE_UNTYPED_EXPR_LIST_EXPRESSION_START
SOURCE_UNTYPED_EXPR_LIST_EXPRESSION_END

SOURCE_UNTYPED_VALUE_EXPRESSION_START
SOURCE_UNTYPED_VALUE_EXPRESSION_END

SOURCE_UNTYPED_ARRAY_REFERENCE_EXPRESSION_START
SOURCE_UNTYPED_ARRAY_REFERENCE_EXPRESSION_END

SOURCE_UNTYPED_SUBSCRIPT_EXPRESSION_START
SOURCE_UNTYPED_SUBSCRIPT_EXPRESSION_END

SOURCE_UNTYPED_OTHER_EXPRESSION_START
SOURCE_UNTYPED_OTHER_EXPRESSION_END

SOURCE_UNTYPED_NAMED_EXPRESSION_START
SOURCE_UNTYPED_NAMED_EXPRESSION_END

SOURCE_UNTYPED_NULL_EXPRESSION_START
SOURCE_UNTYPED_NULL_EXPRESSION_END

SOURCE_UNTYPED_FUNCTION_CALL_OR_ARRAY_REFERENCE_EXPRESSION_START
SOURCE_UNTYPED_FUNCTION_CALL_OR_ARRAY_REFERENCE_EXPRESSION_END

SOURCE_UNTYPED_STATEMENT_START
SOURCE_UNTYPED_STATEMENT_END

SOURCE_UNTYPED_ASSIGNMENT_STATEMENT_START
SOURCE_UNTYPED_ASSIGNMENT_STATEMENT_END

SOURCE_UNTYPED_BLOCK_STATEMENT_START
SOURCE_UNTYPED_BLOCK_STATEMENT_END

SOURCE_UNTYPED_EXPRESSION_STATEMENT_START
SOURCE_UNTYPED_EXPRESSION_STATEMENT_END

SOURCE_UNTYPED_FUNCTION_CALL_STATEMENT_START
SOURCE_UNTYPED_FUNCTION_CALL_STATEMENT_END

SOURCE_UNTYPED_IMAGE_CONTROL_STATEMENT_START
SOURCE_UNTYPED_IMAGE_CONTROL_STATEMENT_END

SOURCE_UNTYPED_OTHER_STATEMENT_START
SOURCE_UNTYPED_OTHER_STATEMENT_END

SOURCE_UNTYPED_USE_STATEMENT_START
SOURCE_UNTYPED_USE_STATEMENT_END

SOURCE_UNTYPED_NULL_STATEMENT_START
SOURCE_UNTYPED_NULL_STATEMENT_END

SOURCE_UNTYPED_NULL_DECLARATION_START
SOURCE_UNTYPED_NULL_DECLARATION_END

SOURCE_UNTYPED_IF_STATEMENT_START
SOURCE_UNTYPED_IF_STATEMENT_END

SOURCE_UNTYPED_CASE_STATEMENT_START
SOURCE_UNTYPED_CASE_STATEMENT_END

SOURCE_UNTYPED_LOOP_STATEMENT_START
SOURCE_UNTYPED_LOOP_STATEMENT_END

SOURCE_UNTYPED_WHILE_STATEMENT_START
SOURCE_UNTYPED_WHILE_STATEMENT_END

SOURCE_UNTYPED_FOR_STATEMENT_START
SOURCE_UNTYPED_FOR_STATEMENT_END

SOURCE_UNTYPED_FORALL_STATEMENT_START
SOURCE_UNTYPED_FORALL_STATEMENT_END

SOURCE_UNTYPED_EXIT_STATEMENT_START
SOURCE_UNTYPED_EXIT_STATEMENT_END

SOURCE_UNTYPED_GOTO_STATEMENT_START
SOURCE_UNTYPED_GOTO_STATEMENT_END

SOURCE_UNTYPED_PROCEDURE_CALL_STATEMENT_START
SOURCE_UNTYPED_PROCEDURE_CALL_STATEMENT_END

SOURCE_UNTYPED_RETURN_STATEMENT_START
SOURCE_UNTYPED_RETURN_STATEMENT_END

SOURCE_UNTYPED_EXTENDED_RETURN_STATEMENT_START
SOURCE_UNTYPED_EXTENDED_RETURN_STATEMENT_END

SOURCE_UNTYPED_STOP_STATEMENT_START
SOURCE_UNTYPED_STOP_STATEMENT_END

SOURCE_UNTYPED_ACCEPT_STATEMENT_START
SOURCE_UNTYPED_ACCEPT_STATEMENT_END

SOURCE_UNTYPED_ENTRY_CALL_STATEMENT_START
SOURCE_UNTYPED_ENTRY_CALL_STATEMENT_END

SOURCE_UNTYPED_REQUEUE_STATEMENT_START
SOURCE_UNTYPED_REQUEUE_STATEMENT_END

SOURCE_UNTYPED_DELAY_UNTIL_STATEMENT_START
SOURCE_UNTYPED_DELAY_UNTIL_STATEMENT_END

SOURCE_UNTYPED_DELAY_RELATIVE_STATEMENT_START
SOURCE_UNTYPED_DELAY_RELATIVE_STATEMENT_END

SOURCE_UNTYPED_TERMINATE_ALTERNATIVE_STATEMENT_START
SOURCE_UNTYPED_TERMINATE_ALTERNATIVE_STATEMENT_END

SOURCE_UNTYPED_SELECTIVE_ACCEPT_STATEMENT_START
SOURCE_UNTYPED_SELECTIVE_ACCEPT_STATEMENT_END

SOURCE_UNTYPED_TIMED_ENTRY_CALL_STATEMENT_START
SOURCE_UNTYPED_TIMED_ENTRY_CALL_STATEMENT_END

SOURCE_UNTYPED_CONDITIONAL_ENTRY_CALL_STATEMENT_START
SOURCE_UNTYPED_CONDITIONAL_ENTRY_CALL_STATEMENT_END

SOURCE_UNTYPED_ASYNCHRONOUS_SELECT_STATEMENT_START
SOURCE_UNTYPED_ASYNCHRONOUS_SELECT_STATEMENT_END

SOURCE_UNTYPED_ABORT_STATEMENT_START
SOURCE_UNTYPED_ABORT_STATEMENT_END

SOURCE_UNTYPED_RAISE_STATEMENT_START
SOURCE_UNTYPED_RAISE_STATEMENT_END

SOURCE_UNTYPED_CODE_STATEMENT_START
SOURCE_UNTYPED_CODE_STATEMENT_END

SOURCE_UNTYPED_DECLARATION_STATEMENT_START
SOURCE_UNTYPED_DECLARATION_STATEMENT_END

SOURCE_UNTYPED_DIRECTIVE_DECLARATION_START
SOURCE_UNTYPED_DIRECTIVE_DECLARATION_END

SOURCE_UNTYPED_ENUM_DECLARATION_START
SOURCE_UNTYPED_ENUM_DECLARATION_END

SOURCE_UNTYPED_LABEL_STATEMENT_START
SOURCE_UNTYPED_LABEL_STATEMENT_END

SOURCE_UNTYPED_NAMELIST_DECLARATION_START
SOURCE_UNTYPED_NAMELIST_DECLARATION_END

SOURCE_UNTYPED_INITIALIZED_NAMELIST_DECLARATION_START
SOURCE_UNTYPED_INITIALIZED_NAMELIST_DECLARATION_END

SOURCE_UNTYPED_IMPLICIT_DECLARATION_START
SOURCE_UNTYPED_IMPLICIT_DECLARATION_END

SOURCE_UNTYPED_VARIABLE_DECLARATION_START
SOURCE_UNTYPED_VARIABLE_DECLARATION_END

SOURCE_UNTYPED_TYPEDEF_DECLARATION_START
SOURCE_UNTYPED_TYPEDEF_DECLARATION_END

SOURCE_UNTYPED_PROGRAM_HEADER_DECLARATION_START
SOURCE_UNTYPED_PROGRAM_HEADER_DECLARATION_END

SOURCE_UNTYPED_FUNCTION_DECLARATION_START
SOURCE_UNTYPED_FUNCTION_DECLARATION_END

SOURCE_UNTYPED_MODULE_DECLARATION_START
SOURCE_UNTYPED_MODULE_DECLARATION_END

SOURCE_UNTYPED_SUBMODULE_DECLARATION_START
SOURCE_UNTYPED_SUBMODULE_DECLARATION_END

SOURCE_UNTYPED_BLOCK_DATA_DECLARATION_START
SOURCE_UNTYPED_BLOCK_DATA_DECLARATION_END

SOURCE_UNTYPED_PACKAGE_DECLARATION_START
SOURCE_UNTYPED_PACKAGE_DECLARATION_END

SOURCE_UNTYPED_STRUCTURE_DECLARATION_START
SOURCE_UNTYPED_STRUCTURE_DECLARATION_END

SOURCE_UNTYPED_STRUCTURE_DEFINITION_START
SOURCE_UNTYPED_STRUCTURE_DEFINITION_END

SOURCE_UNTYPED_EXCEPTION_DECLARATION_START
SOURCE_UNTYPED_EXCEPTION_DECLARATION_END

SOURCE_UNTYPED_EXCEPTION_HANDLER_DECLARATION_START
SOURCE_UNTYPED_EXCEPTION_HANDLER_DECLARATION_END

SOURCE_UNTYPED_TASK_DECLARATION_START
SOURCE_UNTYPED_TASK_DECLARATION_END

SOURCE_UNTYPED_UNIT_DECLARATION_START
SOURCE_UNTYPED_UNIT_DECLARATION_END

SOURCE_UNTYPED_SUBROUTINE_DECLARATION_START
SOURCE_UNTYPED_SUBROUTINE_DECLARATION_END

SOURCE_UNTYPED_INTERFACE_DECLARATION_START
SOURCE_UNTYPED_INTERFACE_DECLARATION_END

SOURCE_UNTYPED_SCOPE_START
SOURCE_UNTYPED_SCOPE_END

SOURCE_UNTYPED_FUNCTION_SCOPE_START
SOURCE_UNTYPED_FUNCTION_SCOPE_END

SOURCE_UNTYPED_MODULE_SCOPE_START
SOURCE_UNTYPED_MODULE_SCOPE_END

SOURCE_UNTYPED_GLOBAL_SCOPE_START
SOURCE_UNTYPED_GLOBAL_SCOPE_END

SOURCE_UNTYPED_INITIALIZED_NAME_START
SOURCE_UNTYPED_INITIALIZED_NAME_END

SOURCE_UNTYPED_REFERENCE_EXPRESSION_START
SOURCE_UNTYPED_REFERENCE_EXPRESSION_END

SOURCE_UNTYPED_TYPE_START
SOURCE_UNTYPED_TYPE_END

SOURCE_UNTYPED_ARRAY_TYPE_START
SOURCE_UNTYPED_ARRAY_TYPE_END

SOURCE_UNTYPED_TABLE_TYPE_START
SOURCE_UNTYPED_TABLE_TYPE_END

SOURCE_UNTYPED_ATTRIBUTE_START
SOURCE_UNTYPED_ATTRIBUTE_END

SOURCE_UNTYPED_NAME_START
SOURCE_UNTYPED_NAME_END

SOURCE_UNTYPED_TOKEN_START
SOURCE_UNTYPED_TOKEN_END

SOURCE_UNTYPED_TOKEN_PAIR_START
SOURCE_UNTYPED_TOKEN_PAIR_END

SOURCE_UNTYPED_NAMED_STATEMENT_START
SOURCE_UNTYPED_NAMED_STATEMENT_END

SOURCE_UNTYPED_FILE_START
SOURCE_UNTYPED_FILE_END

SOURCE_UNTYPED_STATEMENT_LIST_START
SOURCE_UNTYPED_STATEMENT_LIST_END

SOURCE_UNTYPED_DECLARATION_STATEMENT_LIST_START
SOURCE_UNTYPED_DECLARATION_STATEMENT_LIST_END

SOURCE_UNTYPED_FUNCTION_DECLARATION_LIST_START
SOURCE_UNTYPED_FUNCTION_DECLARATION_LIST_END

SOURCE_UNTYPED_INITIALIZED_NAME_LIST_START
SOURCE_UNTYPED_INITIALIZED_NAME_LIST_END

SOURCE_UNTYPED_NAME_LIST_START
SOURCE_UNTYPED_NAME_LIST_END

SOURCE_UNTYPED_TOKEN_LIST_START
SOURCE_UNTYPED_TOKEN_LIST_END

SOURCE_UNTYPED_TOKEN_PAIR_LIST_START
SOURCE_UNTYPED_TOKEN_PAIR_LIST_END


SOURCE_JAVA_MEMBER_VALUE_PAIR_START
SOURCE_JAVA_MEMBER_VALUE_PAIR_END


SOURCE_LAMBDA_CAPTURE_START
// DQ (9/3/2014): Adding support for C++11 lambda expresions.
SOURCE_LAMBDA_CAPTURE_END


SOURCE_LAMBDA_CAPTURE_LIST_START
// DQ (9/3/2014): Adding support for C++11 lambda expresions.
SOURCE_LAMBDA_CAPTURE_LIST_END

