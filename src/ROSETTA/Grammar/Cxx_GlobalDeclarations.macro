// Preprocessor definitions                                     -*- C++ -*-

// DQ (3/8/2006): I wonder if someone is uncommenting this!
// DQ (8/1/2005): Commented out to depricate the use of this within ROSE
// This will be a problem once we declare more than one grammar
// define SgNULL_FILE ((Sg_File_Info*) 0)
// define SgNULL_FILE ( new Sg_File_Info("NULL_FILE",0,0) )

#include <string.h>
#if 0
// JJW 10-25-2007 nobody should be using these anymore
#define SgSHALLOW_COPY SgShallowCopy::static_instance()
#define SgTREE_COPY SgTreeCopy::static_instance()
#endif

#ifndef ROSE_PREVENT_CONSTRUCTION_ON_STACK
#define ROSE_PREVENT_CONSTRUCTION_ON_STACK
inline void preventConstructionOnStack(SgNode* n)
   {
#ifndef NDEBUG
#ifdef _MSC_VER
  // DQ (11/28/2009): This was a fix suggested by Robb.
  // void* frameaddr = 0;
  // Build an "auto" variable (should be located near the stack frame, I think).
// tps (12/4/2009)
#if _MSC_VER >= 1600  // 1600 == VC++ 10.0
//../Grammar/Cxx_GlobalDeclarations.macro(32): error C3530: 'auto' cannot be combined with any other type-specifier
     unsigned int nonStackFrameReferenceVariable;
  #pragma message ( " Cxx_GlobalDeclarations.macro: __builtin_frame_address not known in Windows. Workaround in VS 10.0")
#else
     auto unsigned int nonStackFrameReferenceVariable;
#endif
     void* frameaddr = &nonStackFrameReferenceVariable;

  // DQ (11/28/2009): I think we can comment out the pragma message now.
  // #pragma message ( " Cxx_GlobalDeclarations.macro: __builtin_frame_address not known in Windows.This will not work. Need to fix this")
#else
  // GNU compiler specific code
     void* frameaddr = __builtin_frame_address(0);
#endif // _MSC_VER
     signed long dist = (char*)n - (char*)frameaddr;

  // DQ (12/6/2009): This fails for the 4.0.4 compiler, but only in 64-bit when run with Hudson.
  // I can't reporduce the problem using the 4.0.4 compiler, but it is uniformally a problem
  // since it fails on all tests (via hudson) which are using Boost 1.40 and either minimal or
  // full configurations (and also for the tests of the EDG binary).
  // assert (dist < -10000 || dist > 10000);

#ifdef __GNUC__
  // Note that this is a test of the backend compiler, it seems that we don't track
  // the compiler used to compile ROSE, but this is what we would want.

   #if (BACKEND_CXX_COMPILER_MAJOR_VERSION_NUMBER == 4) && (BACKEND_CXX_COMPILER_MINOR_VERSION_NUMBER == 0)
  // For the GNU 4.0.x make this a warning, since it appears to fail due to a 
  // poor implementaiton for just this compiler and no other version of GNU.
  // Just that we are pringing this warning is a problem for many tests (maybe this should be enable within verbose mode).
     if (dist < -10000 || dist > 10000)
        {
#if 0
          printf ("Warning: preventConstructionOnStack() reporting object on stack, not allowed. dist = %ld \n",dist);
#endif
        }
   #else
  // For all other versions of the GNU compiler make this an error.
     assert (dist < -10000 || dist > 10000);
   #endif
#else
  // For all other compilers make this an error (e.g. on Windows MSVC, Intel icc, etc.).
     assert (dist < -10000 || dist > 10000);
#endif // __GNUC__

#endif // NDEBUG
   }
#endif // ROSE_PREVENT_CONSTRUCTION_ON_STACK

// Global Declarations

// extern SgUnparse_Info SgNO_UNPARSE_INFO;

// These must be declared AFTER the gramar's header file is declared because
// some of them must have already seen the full class declarations!
// Some of the function names require a prefix to make them unique since
// C++ does not allow overloaded functions to differ in return type!

//SgAttribute* get_system_bitflag    ( const SgAttributePtrList& );
//void         set_system_bitflag    ( SgAttributePtrList&       , unsigned long int );
//void         unset_system_bitflag  ( SgAttributePtrList&       , unsigned long int );
//int          is_system_bitflag     ( const SgAttributePtrList& , unsigned long int );
//SgAttribute* Sgadd_user_attribute    ( SgAttributePtrList&       , char *, SgAttribute* );
//SgAttribute* Sgget_user_attribute    ( const SgAttributePtrList& , char* );
//int          remove_user_attribute ( SgAttributePtrList&       , char* );
//SgPragma*    Sgadd_pragma            ( SgAttributePtrList&       , char* );
//SgPragma*    Sgadd_pragma            ( SgAttributePtrList&       , SgPragma* );
//SgPragma*    Sgget_pragma            ( const SgAttributePtrList& , char* );
// tps : old mechanism - removed this line
//void         print_pragma          ( SgAttributePtrList&       , std::ostream& );
//int          remove_pragma         ( SgAttributePtrList&       , char* );

//extern SgPragma *Sgfound_pragma_list[];
//extern int       found_pragma_cnt;
//extern int       pure_cc_depth;

// Custom function declarations for debugging!
//extern void showSgType( std::ostream& os, SgType* type, const char* label, int depth );

// JH (11/28/2005): This turns on/off many asserts concerimng the manipulation and remanipulation of the
// data inside the memory pools.
#define FILE_IO_EXTRA_CHECK 1

/* JH (01/18/2006): To improve the memory check (traversing the memory pools, and checking the data member
   pointers to other IR nodes) we have this macro, that manages if a deleted IR node can be returned by the
   new operator again.
   ATTENTION: For huge applications, this might be set to 0, otherwise, we can run out of space easily ....
*/
#define DISABLE_REALLOCATION_OF_DELETED_POINTERS 1
