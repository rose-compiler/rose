// Preprocessor definitions                                     -*- C++ -*-

// DQ (3/8/2006): I wonder if someone is uncommenting this!
// DQ (8/1/2005): Commented out to depricate the use of this within ROSE
// This will be a problem once we declare more than one grammar
// define SgNULL_FILE ((Sg_File_Info*) 0)
// define SgNULL_FILE ( new Sg_File_Info("NULL_FILE",0,0) )

#include <string.h>

#if 0
// JJW 10-25-2007 nobody should be using these anymore
#define SgSHALLOW_COPY SgShallowCopy::static_instance()
#define SgTREE_COPY SgTreeCopy::static_instance()
#endif

#ifndef ROSE_PREVENT_CONSTRUCTION_ON_STACK
#define ROSE_PREVENT_CONSTRUCTION_ON_STACK
inline void preventConstructionOnStack(SgNode* n) {
#ifndef NDEBUG
  void* frameaddr = __builtin_frame_address(0);
  signed long dist = (char*)n - (char*)frameaddr;
  assert (dist < -10000 || dist > 10000);
#endif
}
#endif // ROSE_PREVENT_CONSTRUCTION_ON_STACK

// Global Declarations

// extern SgUnparse_Info SgNO_UNPARSE_INFO;

// These must be declared AFTER the gramar's header file is declared because
// some of them must have already seen the full class declarations!
// Some of the function names require a prefix to make them unique since
// C++ does not allow overloaded functions to differ in return type!

//SgAttribute* get_system_bitflag    ( const SgAttributePtrList& );
//void         set_system_bitflag    ( SgAttributePtrList&       , unsigned long int );
//void         unset_system_bitflag  ( SgAttributePtrList&       , unsigned long int );
//int          is_system_bitflag     ( const SgAttributePtrList& , unsigned long int );
//SgAttribute* Sgadd_user_attribute    ( SgAttributePtrList&       , char *, SgAttribute* );
//SgAttribute* Sgget_user_attribute    ( const SgAttributePtrList& , char* );
//int          remove_user_attribute ( SgAttributePtrList&       , char* );
//SgPragma*    Sgadd_pragma            ( SgAttributePtrList&       , char* );
//SgPragma*    Sgadd_pragma            ( SgAttributePtrList&       , SgPragma* );
//SgPragma*    Sgget_pragma            ( const SgAttributePtrList& , char* );
void         print_pragma          ( SgAttributePtrList&       , std::ostream& );
//int          remove_pragma         ( SgAttributePtrList&       , char* );

//extern SgPragma *Sgfound_pragma_list[];
//extern int       found_pragma_cnt;
//extern int       pure_cc_depth;

// Custom function declarations for debugging!
//extern void showSgType( std::ostream& os, SgType* type, const char* label, int depth );

// JH (11/28/2005): This turns on/off many asserts concerimng the manipulation and remanipulation of the
// data inside the memory pools.
#define FILE_IO_EXTRA_CHECK 1
                                                                                                                                                                                                                          

/* JH (01/18/2006): To improve the memory check (traversing the memory pools, and checking the data member
   pointers to other IR nodes) we have this macro, that manages if a deleted IR node can be returned by the
   new operator again.
   ATTENTION: For huge applications, this might be set to 0, otherwise, we can run out of space easily ....
*/
#define DISABLE_REALLOCATION_OF_DELETED_POINTERS 1

#ifndef REFERENCETOPOINTERHANDLER_DEFINED
#define REFERENCETOPOINTERHANDLER_DEFINED

// JJW (11/1/2008): This is the base class for handler objects given to
// processReferenceToDataMembers(); just override operator()() to do your
// replacement; apply() calls it and appropriately checks and writes back the
// result.

struct ReferenceToPointerHandler
   {
     template <typename NodeSubclass>
     void apply(NodeSubclass*& r, const SgName& n)
        {
          SgNode* sgn = r;
          (*this)(sgn, n);
          ROSE_ASSERT (sgn == NULL || dynamic_cast<NodeSubclass*>(sgn));
          r = dynamic_cast<NodeSubclass*>(sgn);
        }

     virtual void operator()(SgNode*&, const SgName&) = 0;
     virtual ~ReferenceToPointerHandler() {}
   };

#endif // REFERENCETOPOINTERHANDLER_DEFINED
