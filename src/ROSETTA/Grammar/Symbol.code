// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START
          virtual SgName  get_name() const = 0;
          virtual SgType* get_type() const = 0;
          virtual SgNode* get_symbol_basis() const; // from HEADER

       // DQ (6/10/007): supports test of symbol declaration scope against symbol table's associated scope
          virtual SgScopeStatement* get_scope() const;

       // DQ (12/3/2011): refactoring support for symbol tables and symbols.
          SgName get_mangled_name() const;

#if 0
       // PP (4/29/22): removed to eliminate confusion
       // DQ (8/21/2013): Added function so that templated lower-level symbol table support will compile.
       // Note that this function can not be called and returns an appropriate error message.
       // Note also that we have to return a declaration for which get_type exists as well
       // (selected SgFunctionDeclaration).  The return value of this function is always NULL
       // plus it is a runtime error to call this function.
       // SgFunctionDeclaration* get_declaration() const;
          SgDeclarationStatement* get_declaration() const;
#endif /* 0 */

HEADER_END

HEADER_X_SYMBOL_START
          virtual SgName  get_name() const = 0;
          virtual SgType* get_type() const = 0;
          virtual SgNode* get_symbol_basis() const; // from X_SYMBOL
HEADER_X_SYMBOL_END

HEADER_NON_X_SYMBOL_START
HEADER_NON_X_SYMBOL_END


HEADER_GET_TYPE_START
       // DQ (3/23/2017): ROSETTA macro expansion
          SgType* get_type() const override;
       // SgNode* get_symbol_basis() const; // from GET_TYPE
HEADER_GET_TYPE_END

HEADER_GET_NAME_START
          SgName get_name() const override;
          SgNode* get_symbol_basis() const override; // from GET_NAME
HEADER_GET_NAME_END


HEADER_DECLARATION_START
          SgMemberFunctionDeclaration* get_declaration() const;

       // DQ (6/10/2007): This is now deprecated in favor of a more uniform implementation for all symbols.
          SgClassDefinition *get_scope() const override ROSE_DEPRECATED_FUNCTION;

       // SgNode* get_symbol_basis() const; // from DECLARATION
HEADER_DECLARATION_END

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_START
          ** This code is not used by ROSETTA! **
          SgTemplateInstantiationDecl *get_declaration() const;
HEADER_TEMPLATE_INSTANTIATION_DECLARATION_END


HEADER_LABEL_SYMBOL_START

      //! Type of label used (fortran only)
          enum label_type_enum
             {
               e_unknown_label_type      = 0,
               e_non_numeric_label_type  = 1,
               e_start_label_type        = 2,
               e_else_label_type         = 3,
               e_end_label_type          = 4,
            // DQ (2/1/2011): Added support for Fortran specific alternative return labels.
               e_alternative_return_type = 5,
               e_last_label_type         = 6
             };

          SgLabelSymbol ( SgInitializedName* initializedName );

HEADER_LABEL_SYMBOL_END

HEADER_ADA_INHERITED_FUNCTION_SYMBOL_START
  //! returns the scope where the inherited function is implicitly defined.
  SgScopeStatement* get_scope() const override;
HEADER_ADA_INHERITED_FUNCTION_SYMBOL_END


HEADER_JAVA_LABEL_SYMBOL_START
// DQ (9/9/2011): Not clear yet what member functions we might require.
HEADER_JAVA_LABEL_SYMBOL_END


HEADER_ALIAS_SYMBOL_START
       // SgName  get_name() const;
       // SgType* get_type() const;
       // SgNode* get_symbol_basis() const;

       // DQ (2/28/2015): Added copy constructor to make sure that the causal_nodes is preserved across copies.
          SgAliasSymbol( const SgAliasSymbol & X );

       // DQ (2/28/2015): Add this function so that we can check and for alias of SgAliasSymbol.
          void post_construction_initialization() override;

      //! For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
          SgSymbol* get_base() const;

      //! Where possible extract the declaration from the aliased symbol
          SgDeclarationStatement* get_declaration() const;
HEADER_ALIAS_SYMBOL_END

HEADER_RENAME_SYMBOL_START

      //! For a chain of aliased symbols the last link may be a SgRenameSymbol, this
      //! function returns the declaration in the last (non-aliased and not renamed) symbol.
      //  SgSymbol* get_base() const;

HEADER_RENAME_SYMBOL_END

HEADER_NAMESPACE_SYMBOL_START
          void post_construction_initialization() override;
HEADER_NAMESPACE_SYMBOL_END


HEADER_ASM_BINARY_ADDRESS_SYMBOL_START
HEADER_ASM_BINARY_ADDRESS_SYMBOL_END

HEADER_ASM_BINARY_DATA_SYMBOL_START
HEADER_ASM_BINARY_DATA_SYMBOL_END

// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

SOURCE_START
#if 1
// DQ (2/6/2007): This returns the basis for SgSymbol
SgNode*
SgSymbol::get_symbol_basis() const
   {
     return NULL;
   }
#endif

#if PHASED_OUT

SgDeclarationStatement*
SgSymbol::get_declaration() const
   {
  // DQ (8/21/2013): Added function so that templated lower-level symbol table support will compile.
  // Note that this function can not be called and returns an appropriate error message.

     printf ("ERROR: SgSymbol::get_declaration(): this function exists so that templated lower-level symbol table support will compile (please call this on an appropriate derived class of SgSymbol) \n");
     ROSE_ASSERT(false);

     return NULL;
   }
#endif /* PHASED_OUT */

// This function has been implement to support testing of the scope of
// the declartion with the scope of where the symbols are placed
// (within the inserion and checking og symbol tables).
SgScopeStatement*
SgSymbol::get_scope() const
   {
     SgScopeStatement* scope = NULL;
     const SgNode* basis = get_symbol_basis();

     ROSE_ASSERT(basis != NULL);
  // printf ("In SgSymbol::get_scope(): basis = %p = %s \n",basis,basis->class_name().c_str());

     const SgInitializedName* initializedName = isSgInitializedName(basis);
     if (initializedName != NULL)
        {
          scope = initializedName->get_scope();
        }

     const SgStatement* statement = isSgStatement(basis);
     if (statement != NULL)
        {
          scope = statement->get_scope();
        }

     ROSE_ASSERT(scope != NULL);
     return scope;
   }


SgName
SgSymbol::get_mangled_name() const
   {
  // DQ (12/3/2011): refactoring of support for symbol tables and symbols.

     SgName mangledName;
     const SgSymbol* symbolFromTable = this;
     ROSE_ASSERT(symbolFromTable != NULL);

     switch(symbolFromTable->variantT())
        {
          case V_SgFunctionSymbol:
             {
               const SgFunctionSymbol* symbol = isSgFunctionSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(functionDeclaration != NULL);

               mangledName = functionDeclaration->get_mangled_name();

               break;
             }

          case V_SgMemberFunctionSymbol:
             {
               const SgMemberFunctionSymbol* symbol = isSgMemberFunctionSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgFunctionDeclaration* functionDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(functionDeclaration != NULL);

               mangledName = functionDeclaration->get_mangled_name();
               break;
             }

          case V_SgClassSymbol:
             {
               const SgClassSymbol* symbol = isSgClassSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgClassDeclaration* classDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(classDeclaration != NULL);

               mangledName = classDeclaration->get_mangled_name();
               break;
             }

          case V_SgAdaPackageSymbol:
             {
               const SgAdaPackageSymbol* symbol = isSgAdaPackageSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgDeclarationStatement* decl = symbol->get_declaration();
               ROSE_ASSERT(decl != NULL);

               mangledName = decl->get_mangled_name();
               break;
             }

          case V_SgAdaTaskSymbol:
             {
               const SgAdaTaskSymbol* symbol = isSgAdaTaskSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgDeclarationStatement* decl = symbol->get_declaration();
               ROSE_ASSERT(decl != NULL);

               mangledName = decl->get_mangled_name();
               break;
             }

          case V_SgAdaProtectedSymbol:
             {
               const SgAdaProtectedSymbol* symbol = isSgAdaProtectedSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgDeclarationStatement* decl = symbol->get_declaration();
               ROSE_ASSERT(decl != NULL);

               mangledName = decl->get_mangled_name();
               break;
             }

          case V_SgAdaGenericSymbol:
             {
               const SgAdaGenericSymbol* symbol = isSgAdaGenericSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgDeclarationStatement* decl = symbol->get_declaration();
               ROSE_ASSERT(decl != NULL);
               mangledName = decl->get_mangled_name();
               break;
             }

          case V_SgAdaGenericInstanceSymbol:
             {
               const SgAdaGenericInstanceSymbol* symbol = isSgAdaGenericInstanceSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgAdaGenericInstanceDecl* decl = symbol->get_declaration();
               ROSE_ASSERT(decl != NULL);
               mangledName = decl->get_mangled_name();
               break;
             }

          case V_SgEnumFieldSymbol:
             {
               const SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgInitializedName* enumFieldName = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(enumFieldName != NULL);

               mangledName = enumFieldName->get_mangled_name();
               break;
             }

          case V_SgEnumSymbol:
             {
               const SgEnumSymbol* symbol = isSgEnumSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgEnumDeclaration* enumDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(enumDeclaration != NULL);

               mangledName = enumDeclaration->get_mangled_name();
               break;
             }

          case V_SgFunctionTypeSymbol:
             {
               const SgFunctionTypeSymbol* symbol = isSgFunctionTypeSymbol(symbolFromTable);
               assert(symbol != NULL);
               mangledName = symbol->get_name();

            // DQ (4/12/2019): I think this should be commented out since it generates output spew.
            // printf ("A SgFunctionTypeSymbol also has a pointer to a SgType = %p \n",symbol->get_type());

               break;
             }

          case V_SgLabelSymbol:
             {
               const SgLabelSymbol* symbol = isSgLabelSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgLabelStatement* labelStatement = symbol->get_declaration();

            // DQ (12/24/2007): Modified to reflect new implementation for Fortran numeric labels.
            // mangledName = labelStatement->get_label();
               if (labelStatement == NULL)
                  {
                    assert(symbol->get_numeric_label_value() >= 0);
                    mangledName = Rose::StringUtility::numberToString(symbol->get_numeric_label_value());
                  }
                 else
                  {
                    mangledName = labelStatement->get_label();
                  }
               break;
             }

          case V_SgNamespaceSymbol:
             {
               const SgNamespaceSymbol* symbol = isSgNamespaceSymbol(symbolFromTable);
               assert(symbol != NULL);
#if 0
               SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();
               mangledName = namespaceDeclaration->get_mangled_name();
               printf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
#else
               if (symbol->get_isAlias() == true)
                  {
                    SgNamespaceAliasDeclarationStatement* namespaceAliasDeclarationStatement = symbol->get_aliasDeclaration();

                 // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
                    ROSE_ASSERT(namespaceAliasDeclarationStatement != NULL);

                    mangledName = namespaceAliasDeclarationStatement->get_mangled_name();

                    printf ("A SgNamespaceSymbol has an ALIAS with name = %s \n",symbol->get_name().str());
                  }
                 else
                  {
                    SgNamespaceDeclarationStatement* namespaceDeclaration = symbol->get_declaration();

                 // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
                    ROSE_ASSERT(namespaceDeclaration != NULL);

                    mangledName = namespaceDeclaration->get_mangled_name();
                    printf ("A SgNamespaceSymbol also has a name = %s \n",symbol->get_name().str());
                  }
#endif
               break;
             }

          case V_SgTemplateSymbol:
             {
               const SgTemplateSymbol* symbol = isSgTemplateSymbol(symbolFromTable);
               assert(symbol != NULL);
               SgTemplateDeclaration* templateDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(templateDeclaration != NULL);

               mangledName = templateDeclaration->get_mangled_name();
               break;
             }

          case V_SgTypedefSymbol:
             {
               const SgTypedefSymbol* symbol = isSgTypedefSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgTypedefDeclaration* typedefDeclaration = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(typedefDeclaration != NULL);

               mangledName = typedefDeclaration->get_mangled_name();
               break;
             }

          case V_SgVariableSymbol:
             {
               const SgVariableSymbol* symbol = isSgVariableSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               SgInitializedName* initializedName = symbol->get_declaration();

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(initializedName != NULL);

               mangledName = initializedName->get_mangled_name();
               break;
             }

          case V_SgAliasSymbol:
             {
               const SgAliasSymbol* symbol = isSgAliasSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               mangledName = symbol->get_name();
               break;
             }

       // DQ (3/7/2012): Added support for new kind of symbol (required for test2004_77.C).
          case V_SgTemplateFunctionSymbol:
             {
               const SgTemplateFunctionSymbol* symbol = isSgTemplateFunctionSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               mangledName = symbol->get_name();
               break;
             }

          case V_SgTemplateClassSymbol:
             {
               const SgTemplateClassSymbol* symbol = isSgTemplateClassSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               mangledName = symbol->get_name();
               break;
             }

       // DQ (3/8/2012): Added support for new kind of symbol (required for test2004_77.C).
          case V_SgTemplateMemberFunctionSymbol:
             {
               const SgTemplateMemberFunctionSymbol* symbol = isSgTemplateMemberFunctionSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               mangledName = symbol->get_name();
               break;
             }

          case V_SgNonrealSymbol:
             {
               const SgNonrealSymbol* symbol = isSgNonrealSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               mangledName = symbol->get_name();
               break;
             }

#if 1
       // DQ (2/28/2018): Added support for C++11 specific symbol.
          case V_SgTemplateTypedefSymbol:
             {
               const SgTemplateTypedefSymbol* symbol = isSgTemplateTypedefSymbol(symbolFromTable);
               ROSE_ASSERT(symbol != NULL);
               ROSE_ASSERT(symbol->get_declaration() != NULL);

#if 0
            // DQ (3/19/2016): Klocworks reports this as an issue (fix by adding assertion).
               ROSE_ASSERT(typedefDeclaration != NULL);

               mangledName = typedefDeclaration->get_mangled_name();
#else
            // DQ (2/28/2018): We need to handle the association of the symbol with either a
            // SgTemplateTypedefDeclaration or a SgTemplateInstantiationTypedefDeclaration IR node.

               SgTemplateTypedefDeclaration* typedefDeclaration = isSgTemplateTypedefDeclaration(symbol->get_declaration());
               if (typedefDeclaration != NULL)
                  {
                    mangledName = typedefDeclaration->get_mangled_name();
                  }
                 else
                  {
                    printf ("In SgSymbol::get_mangled_name(): symbol->get_declaration() = %p = %s \n",symbol->get_declaration(),symbol->get_declaration()->class_name().c_str());

                    SgTemplateInstantiationTypedefDeclaration* typedefInstantiationDeclaration = isSgTemplateInstantiationTypedefDeclaration(symbol->get_declaration());
                    if (typedefInstantiationDeclaration != NULL)
                       {
                         mangledName = typedefInstantiationDeclaration->get_mangled_name();
                       }
                      else
                       {
                         printf ("ERROR: In SgSymbol::get_mangled_name(): symbol->get_declaration() = %p = %s \n",symbol->get_declaration(),symbol->get_declaration()->class_name().c_str());
                       }
                  }
#endif
               break;
             }
#endif
          default:
             {
               mangledName = "unknown mangled name";
               printf ("Error: SgSymbol not handled (%s) \n",symbolFromTable->class_name().c_str());

            // DQ (6/8/2007): Make this case fail so we can detect this error.
               assert(false);
             }
        }

     return mangledName;
   }

SOURCE_END

SOURCE_X_SYMBOL_START
SOURCE_X_SYMBOL_END


SOURCE_NON_X_SYMBOL_START

SgType*
$CLASSNAME::get_type() const
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_non_X_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
SOURCE_NON_X_SYMBOL_END


SOURCE_LONG_GET_NAME_START
SgName
$CLASSNAME::get_name() const
   {
#if 0
   // DQ (2/7/2020): Use this code since we are debugging a case when get_declaration() == NULL.

      printf ("Debugging long form of get_name(): this = %p = %s \n",this,this->class_name().c_str());
      printf ("Debugging long form of get_name(): get_declaration() = %p \n",this->get_declaration());

      SgName theName;

      if (get_declaration() != NULL)
         {
           printf ("Debugging long form of get_name(): get_declaration() != NULL: get_declaration() = %p = %s \n",this->get_declaration(),this->get_declaration()->class_name().c_str());
           theName = get_declaration()->get_name();
         }
        else
         {
           printf ("Debugging long form of get_name(): get_declaration() == NULL \n");
           theName = SgName("undefined");
         }

      printf ("Debugging long form of get_name(): theName = %s \n",theName.str());

      return theName;
#else
      return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
#endif
   }

#if 1
// DQ (2/6/2007): This returns the basis for the SgVariableSymbol (an SgInitializedName object)
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif

SOURCE_LONG_GET_NAME_END


SOURCE_GET_TYPE_START
SgType*
$CLASSNAME::get_type() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_type() : NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the type based symbol (get_type for the SgFunctionTypeSymbol)
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return get_type();
   }
#endif
SOURCE_GET_TYPE_END


SOURCE_EMPTY_GET_TYPE_START
SgType*
$CLASSNAME::get_type() const
   {
     return NULL;
   }

#if 0
// DQ (2/6/2007): This returns the basis for the EMPTY_GET_TYPE
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
#endif
SOURCE_EMPTY_GET_TYPE_END


SOURCE_SHORT_GET_NAME_START
SgName
$CLASSNAME::get_name() const
   {
     return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return get_declaration();
   }
SOURCE_SHORT_GET_NAME_END


SOURCE_SHORT_EMPTY_GET_NAME_START
SgName
$CLASSNAME::get_name() const
   {
     return NULL;
   }

#if 1
// DQ (2/6/2007): This returns the basis for the SHORT_EMPTY_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
#endif
SOURCE_SHORT_EMPTY_GET_NAME_END

SOURCE_SHORT_DEFAULT_GET_NAME_START
SgName
$CLASSNAME::get_name() const
   {
     return "Default_Symbol_Name";
   }

// DQ (2/6/2007): This returns the basis for the SHORT_DEFAULT_GET_NAME
SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }
SOURCE_SHORT_DEFAULT_GET_NAME_END


SOURCE_LABEL_SYMBOL_START
SgName
SgLabelSymbol::get_name() const
   {
  // DQ (12/9/2007): This IR node has been modified to hold a SgStatement in addition
  // to a SgLabelStatement. by leaving the pointer to a SgLabelStatement I don't change
  // anything about how the C/C++ case works, but I have added a pointer to a SgStatement
  // so that the Fortran support can reference any statement (to support numeric labels
  // and non-numeric labels as well, though this is not yet implemented).  I plan to
  // merge the support for C/C++ and fortran a bit later after I am sure that this
  // approach will work.

  // This handles the general case where for C/C++ the declaration statement is not set,
  // but I think this should be an error.  Except that we have to handle the case of a
  // label with unassociated statement in C.  So maybe we need to handle this case!

  // Previous implementation.
  // return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");

     SgName name;
     if (get_declaration() != NULL)
        {
          name = get_declaration()->get_name();
        }
       else
        {
          SgStatement* fortranStatement = get_fortran_statement();
#if 0
          ROSE_ASSERT(fortranStatement != NULL);

       // int numericLabel = fortranStatement->get_numeric_label();
          int numericLabel = get_numeric_label_value();
       // printf ("SgLabelSymbol::get_name(): numericLabel = %d \n",numericLabel);

          name = Rose::StringUtility::numberToString(numericLabel);
#else
          if (fortranStatement != NULL)
             {
               int numericLabel = get_numeric_label_value();
               name = Rose::StringUtility::numberToString(numericLabel);
             }
            else
             {
            // DQ (2/2/2011): Fortran specific code.
               SgInitializedName* alternativeReturnDeclaration = get_fortran_alternate_return_parameter();
               if (alternativeReturnDeclaration != NULL)
                  {
                    name = alternativeReturnDeclaration->get_name();
                  }
             }
#endif
        }

     return name;
   }

// DQ (2/1/2011): This function has the wrong semantics for the case of labels.
// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgLabelSymbol::get_symbol_basis() const
   {
  // DQ (12/9/2007): Modified (see comment above).
  // return get_declaration();

#if 0
  // DQ (2/2/2011): This is OK since this is the C/C++ semantics.
  // DQ (2/1/2011): This function has the wrong semantics for the case of labels.
  // I am not clear how to handle this function, but I think it is required to support
  // internal testing of the symbol tables.  If we supported a pointer to the
  // SgInitializedName object used in the function declaration's parameter list,
  // then we could use that as a concept of declaration (similar to the semantics of
  // a SgVariableSymbol).

     printf ("Error: This function has the wrong semantics for the case of labels. \n");
     ROSE_ASSERT(false);
#endif

  // SgStatement* returnStatement = get_declaration();
     SgLocatedNode* returnStatement = get_declaration();
     if (returnStatement == NULL)
        {
          SgStatement* fortranStatement = get_fortran_statement();
#if 0
          ROSE_ASSERT(fortranStatement != NULL);
          returnStatement = fortranStatement;
#else
          if (fortranStatement != NULL)
             {
               returnStatement = fortranStatement;
             }
            else
             {
               SgInitializedName* alternativeReturnDeclaration = get_fortran_alternate_return_parameter();
               if (alternativeReturnDeclaration != NULL)
                  {
                    returnStatement = alternativeReturnDeclaration;
                  }
             }
#endif
        }

     return returnStatement;
   }

SgType*
SgLabelSymbol::get_type() const
   {
  // DQ (2/1/2011): Label symbols can only have a label type.
     return SgTypeLabel::createType();
   }

// DQ (2/1/2011): Added support for named lable to handle arternative return parameters in Fortran.
SgLabelSymbol::SgLabelSymbol ( SgInitializedName* initializedName )
   : SgSymbol()
   {
  // This constructor is used to support Fortran alternative return parameters in the function declaration.
  // Note that we don't really use the name but I didn't want to make this a default constructor.

  // We could support a pointer to the SgInitializedName object used in the function declaration's parameter list.
     ROSE_ASSERT(initializedName != NULL);

  // Verify that this is used correctly.
     ROSE_ASSERT(initializedName->get_name() == "*");

  // Set the internal mode to support analysis...
     p_label_type = e_alternative_return_type;

     set_fortran_alternate_return_parameter(initializedName);
   }

SOURCE_LABEL_SYMBOL_END


SOURCE_JAVA_LABEL_SYMBOL_START

// DQ (9/9/2011): Not clear yet what member functions we might require.

SgName
SgJavaLabelSymbol::get_name() const
   {
     ROSE_ASSERT(get_declaration() != NULL);

  // Calling get_label() is the perfered API.
  // SgName name = get_declaration()->get_name();
     SgName name = get_declaration()->get_label();

     return name;
   }

SgNode*
SgJavaLabelSymbol::get_symbol_basis() const
   {
     SgLocatedNode* returnStatement = get_declaration();
     ROSE_ASSERT(returnStatement != NULL);
     return returnStatement;
   }

SgType*
SgJavaLabelSymbol::get_type() const
   {
  // DQ (9/9/2011): Use the common SgLabelType for both SgLableStatment and SgJavaLabelStatment.
  // At least until we can reason about why this is a bad idea.
     return SgTypeLabel::createType();
   }

SOURCE_JAVA_LABEL_SYMBOL_END


SOURCE_DECLARATION_START

SgMemberFunctionDeclaration*
SgMemberFunctionSymbol::get_declaration() const
   {
     SgFunctionDeclaration* funcionDeclaration = SgFunctionSymbol::get_declaration();
     if (funcionDeclaration == NULL)
          return NULL;
     SgMemberFunctionDeclaration* memberFuncionDeclaration = isSgMemberFunctionDeclaration(funcionDeclaration);
     ROSE_ASSERT(memberFuncionDeclaration != NULL);
     return memberFuncionDeclaration;
   }

#if 1
// DQ (6/10/2007): This is now deprecated in favor of a more uniform implementation for all symbols.
// This is used in the hidden list intersection code:
//      astHiddenTypeAndDeclarationLists/HiddenList_Intersection.C
// and maybe else where as well.
SgClassDefinition*
SgMemberFunctionSymbol::get_scope() const
   {
  // DQ (7/28/2007): Call the base class instead
  // ROSE_ASSERT(get_declaration() != NULL);
  // return get_declaration()->get_class_scope();
     SgScopeStatement* scope = SgSymbol::get_scope();
     ROSE_ASSERT(scope != NULL);
     SgClassDefinition* classDefinition = isSgClassDefinition(scope);

     if (classDefinition == NULL)
        {
#if PRINT_DEVELOPER_WARNINGS
          printf ("In SgMemberFunctionSymbol::get_scope() (scope is not a SgClassDefinition, likely a pointer to member function): scope = %p = %s \n",scope,scope->class_name().c_str());
#endif
        }
  // ROSE_ASSERT(classDefinition != NULL);

     return classDefinition;
   }
#endif
#if 0
// DQ (2/6/2007): This returns the basis for the DECLARATION
SgNode*
SgMemberFunctionSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }
#endif
SOURCE_DECLARATION_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_START

 *** This case of ROSETTA test is not used! ***

SgTemplateInstantiationDecl*
#if 0
// DQ (12/23/2005): Not sure why this was eliminated a lot time ago.
$CLASSNAME::get_declaration() const
   {
     SgFunctionDeclaration* r = SgFunctionSymbol::get_declaration();
     if (r == 0)
          return 0;
     SgTemplateInstantiationDecl* r1 = isSgTemplateInstantiationDecl(r);
     ROSE_ASSERT(r1 != 0);
     return r1;
   }
#endif

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_END

SOURCE_MODULE_GET_NAME_START
SgName
SgModuleSymbol::get_name() const
   {
#if 1
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration())
         {
           theName = get_declaration()->get_name();
         }
        else
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

// DQ (2/6/2007): This returns the basis for the SgModuleSymbol
SgNode*
SgModuleSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_MODULE_GET_NAME_END

SOURCE_COMMON_GET_NAME_START
SgName
SgCommonSymbol::get_name() const
   {
#if 1
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration())
         {
           theName = get_declaration()->get_name();
         }
        else
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgCommonSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_COMMON_GET_NAME_END

SOURCE_INTRIN_GET_NAME_START
SgName
SgIntrinsicSymbol::get_name() const
   {
#if 1
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration())
         {
           theName = get_declaration()->get_name();
         }
        else
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgIntrinsicSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_INTRIN_GET_NAME_END

SOURCE_INTERFACE_GET_NAME_START
SgName
SgInterfaceSymbol::get_name() const
   {
#if 1
   // (original note from Sage II) this is less efficient but it does avoid a bug in Sun C++
      $GRAMMAR_PREFIX_Name theName;

      if (get_declaration())
         {
           theName = get_declaration()->get_name();
         }
        else
         {
           theName = $GRAMMAR_PREFIX_Name("undefined");
         }

      return theName;
#else
      return (get_declaration) ? get_declaration()->get_name() : $GRAMMAR_PREFIX_Name("undefined");
#endif
   }

SgNode*
SgInterfaceSymbol::get_symbol_basis() const
   {
     return get_declaration();
   }

SOURCE_INTERFACE_GET_NAME_END



SOURCE_ALIAS_SYMBOL_START
SgName
SgAliasSymbol::get_name() const
   {
     ROSE_ASSERT(p_alias != NULL);

     SgName name;
     if (get_isRenamed() == true)
        {
          name = get_new_name();
        }
       else
        {
          name = get_alias()->get_name();
        }

#if 0
  // DQ (1/21/2019): Adding debugging information.
     printf ("In SgAliasSymbol::get_name(): name = %s \n",name.str());
#endif

     return name;
   }

SgNode*
SgAliasSymbol::get_symbol_basis() const
   {
     ROSE_ASSERT(p_alias != NULL);
     return get_alias()->get_symbol_basis();
   }

SgType*
SgAliasSymbol::get_type() const
   {
     ROSE_ASSERT(p_alias != NULL);
     return get_alias()->get_type();
   }

SgSymbol*
SgAliasSymbol::get_base() const
   {
  // DQ (10/9/2008): For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
     SgSymbol* nonAliasedSymbol = get_alias();
     ROSE_ASSERT(nonAliasedSymbol != NULL);

     SgAliasSymbol* aliasSymbol = isSgAliasSymbol(get_alias());
     while (aliasSymbol != NULL)
        {
#if 0
       // DQ (1/21/2019): Adding debugging information.
          printf ("SgAliasSymbol::get_base(): We want to avoid chains of SgAliasSymbol symbols \n");
#endif
       // This may be any symbol (even a SgAliasSymbol)
          nonAliasedSymbol = aliasSymbol->get_alias();

       // Advance in the chain to the next SgAliasSymbol symbol
          aliasSymbol = isSgAliasSymbol(aliasSymbol->get_alias());
        }

  // Every chain of aliased symbols should have a non-aliased symbol at the end!
     ROSE_ASSERT(nonAliasedSymbol != NULL);
     return nonAliasedSymbol;
   }


SgDeclarationStatement*
SgAliasSymbol::get_declaration() const
   {
  // DQ (4/14/2010): Added support for getting declarations from the alias symbols.

     ROSE_ASSERT(get_alias() != NULL);

     SgDeclarationStatement* returnValue = NULL;
     switch (get_alias()->variantT())
        {
          case V_SgNamespaceSymbol:
             {
               SgNamespaceSymbol* symbol = isSgNamespaceSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          case V_SgVariableSymbol:
             {
            // This case is a bit special since the SgInitializedName is not a declaration
            // and thus the get_declaration() function does not return a SgDeclarationStatement.
               SgVariableSymbol* symbol = isSgVariableSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               SgInitializedName* initializedName = isSgInitializedName(symbol->get_declaration());
               ROSE_ASSERT(initializedName != NULL);
               SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName->get_parent());
               ROSE_ASSERT(variableDeclaration != NULL);
               returnValue = variableDeclaration;
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          case V_SgFunctionSymbol:
          case V_SgMemberFunctionSymbol:
             {
               SgFunctionSymbol* symbol = isSgFunctionSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgTemplateClassSymbol:
           case V_SgClassSymbol:
             {
               SgClassSymbol* symbol = isSgClassSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAdaPackageSymbol:
             {
               SgAdaPackageSymbol* symbol = isSgAdaPackageSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAdaTaskSymbol:
             {
               SgAdaTaskSymbol* symbol = isSgAdaTaskSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAdaProtectedSymbol:
             {
               SgAdaProtectedSymbol* symbol = isSgAdaProtectedSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAdaGenericSymbol:
             {
               SgAdaGenericSymbol* symbol = isSgAdaGenericSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAdaGenericInstanceSymbol:
             {
               SgAdaGenericInstanceSymbol* symbol = isSgAdaGenericInstanceSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgEnumSymbol:
             {
               SgEnumSymbol* symbol = isSgEnumSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgEnumFieldSymbol:
             {
               SgEnumFieldSymbol* symbol = isSgEnumFieldSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               SgInitializedName* initializedName = isSgInitializedName(symbol->get_declaration());
               ROSE_ASSERT(initializedName != NULL);

            // DQ (5/20/2010): Call the SgInitializedName::get_declaration() function directly instead.
            // SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(initializedName->get_parent());
            // ROSE_ASSERT(variableDeclaration != NULL);
            // returnValue = variableDeclaration;
               returnValue = initializedName->get_declaration();

               ROSE_ASSERT(returnValue != NULL);
               break;
             }
#if 0
        // I don't think we want to handle this case (at least not as part of alias support)!
           case V_SgLabelSymbol:
             {
               SgLabelSymbol* symbol = isSgLabelSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }
#endif
           case V_SgTemplateSymbol:
             {
               SgTemplateSymbol* symbol = isSgTemplateSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgTypedefSymbol:
             {
               SgTypedefSymbol* symbol = isSgTypedefSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

           case V_SgAliasSymbol:
             {
               SgAliasSymbol* symbol = isSgAliasSymbol(get_alias());
               ROSE_ASSERT(symbol != NULL);
               returnValue = symbol->get_declaration();
               ROSE_ASSERT(returnValue != NULL);
               break;
             }

          default:
             {
               printf ("Error: default reached in switch inside of SgAliasSymbol::get_declaration() get_alias() = %p = %s \n",get_alias(),get_alias()->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

#if 0
  // DQ (1/21/2019): Adding debugging information.
     printf ("In SgAliasSymbol::get_declaration(): returnValue = %p = %s \n",returnValue,(returnValue != NULL) ? returnValue->class_name().c_str() : "null");
#endif

     return returnValue;
   }

SgAliasSymbol::SgAliasSymbol( const SgAliasSymbol & X )
   {
  // DQ (2/28/2015): Added copy constructor to make sure that the causal_nodes is preserved across copies (used in SgScopeStatement::insert_symbol() function).
  // This is a fix for Tristan's use of the copy constructor in the SgScopeStatement::insert_symbol() function).

     p_alias        = X.p_alias;
     p_isRenamed    = X.p_isRenamed;
     p_new_name     = X.p_new_name;
     p_causal_nodes = X.p_causal_nodes;

#if 0
  // DQ (1/21/2019): Adding debugging information.
     printf ("In SgAliasSymbol copy constructor: p_causal_nodes.size() = %zu X.p_causal_nodes = %zu \n",p_causal_nodes.size(),X.p_causal_nodes.size());
#endif
   }

       // DQ (2/28/2015): Add this function so that we can check and for alias of SgAliasSymbol.
void
SgAliasSymbol::post_construction_initialization()
   {
     ROSE_ASSERT(p_alias != NULL);
     SgAliasSymbol* aliasSymbol = isSgAliasSymbol(p_alias);
     if (aliasSymbol != NULL)
        {
#if 0
       // DQ (1/21/2019): Adding debugging information.
          printf ("WARNING: SgAliasSymbol build from another SgAliasSymbol is not allowed! (automating fix) \n");
#endif
          p_alias = aliasSymbol->get_alias();

          SgAliasSymbol* aliasSymbol_nextLevel = isSgAliasSymbol(p_alias);
          if (aliasSymbol_nextLevel != NULL)
             {
               printf ("ERROR: SgAliasSymbol build from another SgAliasSymbol is not allowed! \n");
               ROSE_ASSERT(false);
             }
        }
   }

SOURCE_ALIAS_SYMBOL_END


SOURCE_RENAME_SYMBOL_START
SgName
SgRenameSymbol::get_name() const
   {
     ROSE_ASSERT(p_original_symbol != NULL);

#if 0
     ROSE_ASSERT(get_isRenamed() == true);

     SgName name;
     if (get_isRenamed() == true)
        {
          name = get_new_name();
        }
       else
        {
          name = get_original_symbol()->get_name();
        }
#else
  // This is a difference between SgAliasSymbol and SgRenameSymbol
     SgName name = get_new_name();
#endif

     return name;
   }

SgNode*
SgRenameSymbol::get_symbol_basis() const
   {
     ROSE_ASSERT(p_original_symbol != NULL);
     return get_original_symbol()->get_symbol_basis();
   }

SgType*
SgRenameSymbol::get_type() const
   {
     ROSE_ASSERT(p_original_symbol != NULL);
     return get_original_symbol()->get_type();
   }

#if 0
// DQ (10/11/2008): This is derived from SgFunctionSymbol and so we don't require this member function?

SgSymbol*
SgRenameSymbol::get_base() const
   {
  // DQ (10/9/2008): For a chain of aliased symbols, this function returns the last (non-aliased) symbol.
     SgSymbol* nonAliasedSymbol = get_alias();
     ROSE_ASSERT(nonAliasedSymbol != NULL);

XXXXX

This is not FINISHED!!!

XXXXX

     SgAliasSymbol*  aliasSymbol  = isSgAliasSymbol (get_alias());
     SgRenameSymbol* renameSymbol = isSgRenameSymbol(get_alias());
     while (aliasSymbol != NULL || renameSymbol != NULL)
        {
       // This may be any symbol (even a SgAliasSymbol)
          if (aliasSymbol != NULL)
             {
               nonAliasedSymbol = aliasSymbol->get_alias();
             }
            else
             {
               if (renameSymbol != NULL)
                  {
                    nonAliasedSymbol = renameSymbol->get_alias();
                  }
                 else
                  {
                    printf ("Error: aliasSymbol == NULL and renameSymbol == NULL \n");
                    ROSE_ASSERT(false);
                  }
             }

       // Advance in the chain to the next SgAliasSymbol symbol
          aliasSymbol = isSgAliasSymbol(aliasSymbol->get_alias());
        }

  // Every chain of aliased symbols should have a non-aliased symbol at the end!
     ROSE_ASSERT(nonAliasedSymbol != NULL);
     return nonAliasedSymbol;
   }
#endif

SOURCE_RENAME_SYMBOL_END


SOURCE_NAMESPACE_SYMBOL_START

SgName
SgNamespaceSymbol::get_name() const
   {
  // DQ (8/30/2009): Added support for SgNamespaceAliasDeclarationStatement
     SgName n;
     if (p_isAlias == true)
        {
          n = (get_aliasDeclaration() != NULL) ? get_aliasDeclaration()->get_name() : SgName("undefined");
        }
       else
        {
          n = (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
        }

  // return (get_declaration() != NULL) ? get_declaration()->get_name() : SgName("undefined");
     return n;
   }

// DQ (2/6/2007): This returns the basis for the SHORT_GET_NAME
SgNode*
SgNamespaceSymbol::get_symbol_basis() const
   {
  // DQ (8/30/2009): Added support for SgNamespaceAliasDeclarationStatement
     SgNode* declaration = NULL;
     if (p_isAlias == true)
        {
          declaration = get_aliasDeclaration();
        }
       else
        {
          declaration = get_declaration();
        }

  // return get_declaration();
     return declaration;
   }

void
SgNamespaceSymbol::post_construction_initialization()
   {
  // DQ (8/30/2009): Added support for namespace alias in the SgNamespaceSymbol

     ROSE_ASSERT(p_declaration != NULL || p_aliasDeclaration != NULL);
     ROSE_ASSERT(p_declaration == NULL || p_aliasDeclaration == NULL);

  // Mark this symbol as representing a namespace alias
     if (p_aliasDeclaration != NULL)
          set_isAlias(true);
   }

SOURCE_NAMESPACE_SYMBOL_END

SOURCE_ADA_PACKAGE_SYMBOL_START
SgName
SgAdaPackageSymbol::get_name() const
{
  if (SgAdaPackageSpecDecl* dcl = isSgAdaPackageSpecDecl(get_declaration()))
    return dcl->get_name();

  if (SgAdaPackageBodyDecl* dcl = isSgAdaPackageBodyDecl(get_declaration()))
    return dcl->get_name();

  return SgName("undefined");
}

SgNode*
SgAdaPackageSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_PACKAGE_SYMBOL_END

SOURCE_ADA_GENERIC_SYMBOL_START
SgName
SgAdaGenericSymbol::get_name() const
{
  SgDeclarationStatement* dcl = get_declaration();

  if (SgAdaFormalTypeDecl* frmdcl = isSgAdaFormalTypeDecl(dcl))
    return frmdcl->get_name();

  SgAdaGenericDecl* gendcl = isSgAdaGenericDecl(dcl);
  ASSERT_not_null(gendcl);

  SgDeclarationStatement* dclstm = gendcl->get_declaration();

  if (SgFunctionDeclaration* fundcl = isSgFunctionDeclaration(dclstm))
    return fundcl->get_name();

  if (SgAdaPackageSpecDecl* pkgdcl = isSgAdaPackageSpecDecl(dclstm))
    return pkgdcl->get_name();

  return SgName("undefined");
}

SgNode*
SgAdaGenericSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_GENERIC_SYMBOL_END

SOURCE_ADA_GENERIC_INSTANCE_SYMBOL_START
SgName
SgAdaGenericInstanceSymbol::get_name() const
{
  SgAdaGenericInstanceDecl* dcl = get_declaration();
  ROSE_ASSERT(dcl);

  return dcl->get_name();
}

SgNode*
SgAdaGenericInstanceSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_GENERIC_INSTANCE_SYMBOL_END

SOURCE_ADA_FORMAL_PACKAGE_SYMBOL_START
SgName
SgAdaFormalPackageSymbol::get_name() const
{
  SgAdaFormalPackageDecl* dcl = get_declaration();
  ROSE_ASSERT(dcl);

  return dcl->get_name();
}

SgNode*
SgAdaFormalPackageSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_FORMAL_PACKAGE_SYMBOL_END


SOURCE_ADA_TASK_SYMBOL_START
SgName
SgAdaTaskSymbol::get_name() const
{
  if (SgAdaTaskSpecDecl* dcl = isSgAdaTaskSpecDecl(get_declaration()))
    return dcl->get_name();

  if (SgAdaTaskTypeDecl* dcl = isSgAdaTaskTypeDecl(get_declaration()))
    return dcl->get_name();

  if (SgAdaTaskBodyDecl* dcl = isSgAdaTaskBodyDecl(get_declaration()))
    return dcl->get_name();

  return SgName("undefined");
}

SgNode*
SgAdaTaskSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_TASK_SYMBOL_END

SOURCE_ADA_PROTECTED_SYMBOL_START
SgName
SgAdaProtectedSymbol::get_name() const
{
  if (SgAdaProtectedSpecDecl* dcl = isSgAdaProtectedSpecDecl(get_declaration()))
    return dcl->get_name();

  if (SgAdaProtectedTypeDecl* dcl = isSgAdaProtectedTypeDecl(get_declaration()))
    return dcl->get_name();

  if (SgAdaProtectedBodyDecl* dcl = isSgAdaProtectedBodyDecl(get_declaration()))
    return dcl->get_name();

  return SgName("undefined");
}

SgNode*
SgAdaProtectedSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_PROTECTED_SYMBOL_END

SOURCE_ADA_RENAMING_SYMBOL_START
SgName
SgAdaRenamingSymbol::get_name() const
{
  SgAdaRenamingDecl* dcl = get_declaration();
  ROSE_ASSERT(dcl);

  return dcl->get_name();
}

SgNode*
SgAdaRenamingSymbol::get_symbol_basis() const
{
  return get_declaration();
}
SOURCE_ADA_RENAMING_SYMBOL_END


SOURCE_ADA_INHERITED_FUNCTION_SYMBOL_START
SgName
SgAdaInheritedFunctionSymbol::get_name() const
{
  SgFunctionDeclaration* dcl = get_declaration();
  ASSERT_not_null(dcl);

  return dcl->get_name();
}

SgNode*
SgAdaInheritedFunctionSymbol::get_symbol_basis() const
{
  return get_declaration();
}

SgType*
SgAdaInheritedFunctionSymbol::get_type() const
{
  return get_derivedFunctionType();
}

SgScopeStatement*
SgAdaInheritedFunctionSymbol::get_scope() const
{
  SgScopeStatement* res = isSgScopeStatement(get_parent());

  ASSERT_not_null(res);
  return res;
}

SOURCE_ADA_INHERITED_FUNCTION_SYMBOL_END



SOURCE_ASM_BINARY_ADDRESS_SYMBOL_START

SgType*
$CLASSNAME::get_type() const
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_binary_address_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }

SOURCE_ASM_BINARY_ADDRESS_SYMBOL_END

SOURCE_ASM_BINARY_DATA_SYMBOL_START

SgType*
$CLASSNAME::get_type() const
   {
     return NULL;
   }

SgName
$CLASSNAME::get_name() const
   {
     return SgName("undefined_binary_data_variable_symbol");
   }

SgNode*
$CLASSNAME::get_symbol_basis() const
   {
     return NULL;
   }

SOURCE_ASM_BINARY_DATA_SYMBOL_END

SOURCE_ADA_CONCURRENT_GET_TYPE_START
SgType*
$CLASSNAME::get_type() const
   {
     TYPE_TYPE*              res = nullptr;
     SgDeclarationStatement* dcl = get_declaration();

     if (const SPECDECL_TYPE* spdcl = isSPECDECL_TYPE(dcl))
       res = spdcl->get_type();
     else if (const TYPEDECL_TYPE* tydcl = isTYPEDECL_TYPE(dcl))
       res = tydcl->get_type();

     ASSERT_not_null(res);
     return res;
   }
SOURCE_ADA_CONCURRENT_GET_TYPE_END

SOURCE_TYPE_SYMBOL_START
SgName SgTypeSymbol::get_name() const {
  ROSE_ABORT();
  return SgName("");
}

SgNode * SgTypeSymbol::get_symbol_basis() const {
  ROSE_ABORT();
  return nullptr;
}

SgType * SgTypeSymbol::get_type() const {
  ROSE_ABORT();
  return nullptr;
}
SOURCE_TYPE_SYMBOL_END

