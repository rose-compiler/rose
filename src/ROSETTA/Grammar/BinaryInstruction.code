// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################



HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_START
#include "x86InstructionEnum.h"
HEADER_BINARY_X86_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_START
#include "armInstructionEnum.h"
HEADER_BINARY_ARM_INSTRUCTION_PREDECLARATION_END

HEADER_BINARY_POWERPC_INSTRUCTION_PREDECLARATION_START
#include "powerpcInstructionEnum.h"
HEADER_BINARY_POWERPC_INSTRUCTION_PREDECLARATION_END

HEADER_GENERIC_SECTION_PREDECLARATION_START
#include "MemoryMap.h"
HEADER_GENERIC_SECTION_PREDECLARATION_END

HEADER_GENERIC_FILE_PREDECLARATION_START
#include "MemoryMap.h"
#include "DataConversion.h"
HEADER_GENERIC_FILE_PREDECLARATION_END

HEADER_INTERPRETATION_PREDECLARATION_START
#include "MemoryMap.h"
HEADER_INTERPRETATION_PREDECLARATION_END

HEADER_BINARY_START

 /*  This class forms a base class for all of the types represented in the Asm Instruction grammar.
     All Asm Instructions are derived from this class and thus contain the following functionality.
  */

  public:

HEADER_BINARY_END



HEADER_INTERPRETATION_START
     public:
          SgAsmInterpretation()
             : p_map(NULL), coverageComputed(false), percentageCoverage(0.0), p_dwarf_info(NULL), p_headers(NULL), p_global_block(NULL) 
             {
               ctor();
             }
          SgAsmGenericFilePtrList get_files() const; /*files referenced by interpretation*/
          MemoryMap *get_map() const {return p_map;}
          void set_map(MemoryMap* m) {p_map=m;}

      //! Compute the percentage of coverage based on the length of disassembled functions (in bytes) compared 
      //! to the size of the section which are disassembled (in bytes) (uses coverageComputed and percentageCoverage data members).
          // PC (05/16/2010): Commented out as no definition exists
          // int get_disassembledInstructionCoverageMetricForDisassembledSections() const;

      //! Compute the percentage of coverage based on the length of disassembled functions (in bytes) compared 
      //! to the size of the address range of the top of the first block in memory to the end of the last block in memory.
          // PC (05/16/2010): Commented out as no definition exists
          // double get_disassembledInstructionCoverageMetricForAddressRangeOfFunctionBlocks() const;

          void set_coverageComputed( bool x )
             {
               coverageComputed = x;
             }

          void set_percentageCoverage( double x )
             {
               percentageCoverage = x;
             }

     private:
          void ctor();
          MemoryMap *p_map;

       // DQ (4/29/2010): Added support for computing the percentage of coverage of the disassembled functions relative to the section size.
      //! Save as state if the coverage was computed (so that we can know when the value in percentageCoverage makes sense).
          bool coverageComputed;

      //! The percentage of an interpretation where each section is marked as executable and identified for disassembly into instructions.
          double percentageCoverage;

HEADER_INTERPRETATION_END



HEADER_BINARY_INSTRUCTION_START
	public:
		SgAsmInstruction* cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info);
		std::vector<VirtualBinCFG::CFGEdge> cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info);
		std::vector<VirtualBinCFG::CFGEdge> cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info);
		void append_sources( SgAsmInstruction* instruction );
		virtual bool terminatesBasicBlock(); /*subclasses must redefine*/
		virtual bool is_function_call(const std::vector<SgAsmInstruction*>&, rose_addr_t *target) {return false;}
		virtual bool is_function_return(const std::vector<SgAsmInstruction*>&) { return false; }
		virtual bool has_effect();
		virtual bool has_effect(const std::vector<SgAsmInstruction*>&, bool allow_branch=false,
					bool relax_stack_semantics=false);
		virtual std::vector<std::pair<size_t,size_t> >
		    find_noop_subsequences(const std::vector<SgAsmInstruction*>& insns, bool allow_branch=false,
					   bool relax_stack_semantics=false);
		virtual std::set<rose_addr_t> get_successors(bool* complete); /*subclasses must redefine*/
		virtual std::set<rose_addr_t> get_successors(const std::vector<SgAsmInstruction*>&, bool *complete);
HEADER_BINARY_INSTRUCTION_END



HEADER_BINARY_FILE_START

#if 0
       // enums for ELF header information

#error "DEAD CODE!"

       // unsigned char	e_ident[EI_NIDENT]
       // typedef unsigned char magic_number_vector_type[EI_NIDENT];

       // Executable and Linking Format class kind
          enum elf_class_kind_enum
             {
               e_class_error   = 0,
               e_class_unknown = 1,
               e_class_none    = 2, // value maps to ELFCLASSNONE
               e_class_32      = 3, // value maps to ELFCLASS32
               e_class_64      = 4, // value maps to ELFCLASS64
               e_class_last
             };

#error "DEAD CODE!"

          enum elf_data_encoding_enum
             {
               e_data_encoding_error                  = 0,
               e_data_encoding_unknown                = 1,
               e_data_encoding_none                   = 2, // value maps to ELFDATANONE
               e_data_encoding_least_significant_byte = 3, // value maps to ELFDATA2LSB
               e_data_encoding_most_significant_byte  = 4, // value maps to ELFDATA2MSB
               e_data_encoding_last
             };

          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };


#error "DEAD CODE!"

          enum elf_OS_ABI_identification_enum
             {
               e_OS_ABI_error      = 0,
               e_OS_ABI_unknown    = 1,
               e_OS_ABI_none       = 2,
               e_OS_ABI_SYSV       = 3, // Note that ELFOSABI_SYSV == ELFOSABI_NONE (the two are alised)
               e_OS_ABI_HPUX       = 4,
               e_OS_ABI_NETBSD     = 5,
               e_OS_ABI_LINUX      = 6,
               e_OS_ABI_SOLARIS    = 7,
               e_OS_ABI_AIX        = 8,
               e_OS_ABI_IRIX       = 9,
               e_OS_ABI_FREEBSD    = 10,
               e_OS_ABI_TRU64      = 11,
               e_OS_ABI_MODESTO    = 12,
               e_OS_ABI_OPENBSD    = 13,
               e_OS_ABI_ARM        = 14,
               e_OS_ABI_STANDALONE = 15,
               e_OS_ABI_last
             };

#error "DEAD CODE!"

          enum elf_object_file_type_enum
             {
               e_file_type_error       = 0,
               e_file_type_unknown     = 1,
               e_file_type_none        = 2,
               e_file_type_relocatable = 3,
               e_file_type_executable  = 4,
               e_file_type_shared      = 5,
               e_file_type_core        = 6,
               e_file_type_last
             };


#error "DEAD CODE!"

       // DQ (1/8/2008): For a collection of interesting binaries go to: http://www.distributed.net/source/
          enum elf_machine_architecture_enum
             {
               e_machine_architecture_error                    = 0,
               e_machine_architecture_unknown                  = 1,
               e_machine_architecture_none                     = 2, // Maps to EM_NONE
               e_machine_architecture_ATT_WE_32100             = 3,
               e_machine_architecture_Sun_Sparc                = 4,
               e_machine_architecture_Intel_80386              = 5,
               e_machine_architecture_Motorola_m68k_family     = 6,
               e_machine_architecture_Motorola_m88k_family     = 7,
               e_machine_architecture_Intel_80860              = 8,
               e_machine_architecture_MIPS_R3000_big_endian    = 9,
               e_machine_architecture_IBM_System_370           = 10,
               e_machine_architecture_MIPS_R3000_little_endian = 11,
               e_machine_architecture_HPPA                     = 12,
               e_machine_architecture_Fujitsu_VPP500           = 13,
               e_machine_architecture_Sun_v8plus               = 14,
               e_machine_architecture_Intel_80960              = 15,
               e_machine_architecture_PowerPC                  = 16,
               e_machine_architecture_PowerPC_64bit            = 17,
               e_machine_architecture_IBM_S390                 = 18,
               e_machine_architecture_NEC_V800_series          = 19,
               e_machine_architecture_Fujitsu_FR20             = 20,
               e_machine_architecture_TRW_RH_32                = 21,
               e_machine_architecture_Motorola_RCE             = 22,
               e_machine_architecture_ARM                      = 23,
               e_machine_architecture_Digital_Alpha_fake       = 24,
               e_machine_architecture_Hitachi_SH               = 25,
               e_machine_architecture_SPARC_v9_64bit           = 26,
               e_machine_architecture_Siemens_Tricore          = 27,
               e_machine_architecture_Argonaut_RISC_Core       = 28,
               e_machine_architecture_Hitachi_H8_300           = 29,
               e_machine_architecture_Hitachi_H8_300H          = 30,
               e_machine_architecture_Hitachi_H8S              = 31,
               e_machine_architecture_Hitachi_H8_500           = 32,
               e_machine_architecture_Intel_Merced             = 33,
               e_machine_architecture_Stanford_MIPS_X          = 34,
               e_machine_architecture_Motorola_Coldfire        = 35,
               e_machine_architecture_Motorola_M68HC12         = 36,
               e_machine_architecture_Fujitsu_MMA_Multimedia_Accelerator                  = 37,
               e_machine_architecture_Siemens_PCP                                         = 38,
               e_machine_architecture_Sony_nCPU_embeeded_RISC                             = 39,
               e_machine_architecture_Denso_NDR1_microprocessor                           = 40,
               e_machine_architecture_Motorola_Start_Core_processor                       = 41,
               e_machine_architecture_Toyota_ME16_processor                               = 42,
               e_machine_architecture_STMicroelectronic_ST100_processor                   = 43,
               e_machine_architecture_Advanced_Logic_Corp_Tinyj_emb_family                = 44,
               e_machine_architecture_AMD_x86_64_architecture                             = 45,
               e_machine_architecture_Sony_DSP_Processor                                  = 46,
               e_machine_architecture_Siemens_FX66_microcontroller                        = 47,
               e_machine_architecture_STMicroelectronics_ST9_plus_8_16_microcontroller    = 48,
               e_machine_architecture_STMicroelectronics_ST7_8bit_microcontroller         = 49,
               e_machine_architecture_Motorola_MC68HC16_microcontroller                   = 50,
               e_machine_architecture_Motorola_MC68HC11_microcontroller                   = 51,
               e_machine_architecture_Motorola_MC68HC08_microcontroller                   = 52,
               e_machine_architecture_Motorola_MC68HC05_microcontroller                   = 53,
               e_machine_architecture_Silicon_Graphics_SVx                                = 54,
               e_machine_architecture_STMicroelectronics_ST19_8bit_microcontroller        = 55,
               e_machine_architecture_Digital_VAX                                         = 56,
               e_machine_architecture_Axis_Communications_32bit_embedded_processor        = 57,
               e_machine_architecture_Infineon_Technologies_32bit_embedded_processor      = 58,
               e_machine_architecture_Element_14_64bit_DSP_Processor                      = 59,
               e_machine_architecture_LSI_Logic_16bit_DSP_Processor                       = 60,
               e_machine_architecture_Donald_Knuths_educational_64bit_processor           = 61,
               e_machine_architecture_Harvard_University_machine_independent_object_files = 62,
               e_machine_architecture_SiTera_Prism                                        = 63,
               e_machine_architecture_Atmel_AVR_8bit_microcontroller                      = 64,
               e_machine_architecture_Fujitsu_FR30                                        = 65,
               e_machine_architecture_Mitsubishi_D10V                                     = 66,
               e_machine_architecture_Mitsubishi_D30V                                     = 67,
               e_machine_architecture_NEC_v850                                            = 68,
               e_machine_architecture_Mitsubishi_M32R                                     = 69,
               e_machine_architecture_Matsushita_MN10300                                  = 70,
               e_machine_architecture_Matsushita_MN10200                                  = 71,
               e_machine_architecture_picoJava                                            = 72,
               e_machine_architecture_OpenRISC_32bit_embedded_processor                   = 73,
               e_machine_architecture_ARC_Cores_Tangent_A5                                = 74,
               e_machine_architecture_Tensilica_Xtensa_Architecture                       = 75,
               e_machine_architecture_Digital_Alpha                                       = 76,
               e_machine_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_architecture_enum
             {
               e_processor_architecture_error   = 0,
               e_processor_architecture_unknown = 1,
               e_processor_architecture_none    = 2,
               e_processor_architecture_INTEL   = 3,
               e_processor_architecture_MIPS    = 4,
               e_processor_architecture_ALPHA   = 5,
               e_processor_architecture_PPC     = 6,
               e_processor_architecture_SHX     = 7,
               e_processor_architecture_ARM     = 8,
               e_processor_architecture_IA64    = 9,
               e_processor_architecture_ALPHA64 = 10,
               e_processor_architecture_MSIL    = 11,
               e_processor_architecture_AMD64   = 12,
               e_processor_architecture_UNKNOWN = 13,
               e_processor_architecture_last
             };

#error "DEAD CODE!"

       // DQ (2/11/2008): Added support for Windows binaries
          enum pe_processor_type_enum
             {
               e_processor_type_error         = 0,
               e_processor_type_unknown       = 1,
               e_processor_type_none          = 2,
               e_processor_type_INTEL_386     = 3,
               e_processor_type_INTEL_486     = 4,
               e_processor_type_INTEL_PENTIUM = 5,
               e_processor_type_INTEL_860     = 6,
               e_processor_type_INTEL_IA64    = 7,
               e_processor_type_AMD_X8664     = 8,
               e_processor_type_MIPS_R2000    = 9,
               e_processor_type_MIPS_R3000    = 10,
               e_processor_type_MIPS_R4000    = 11,
               e_processor_type_ALPHA_21064   = 12,
               e_processor_type_PPC_601       = 13,
               e_processor_type_PPC_603       = 14,
               e_processor_type_PPC_604       = 15,
               e_processor_type_PPC_620       = 16,
               e_processor_type_HITACHI_SH3   = 17,
               e_processor_type_HITACHI_SH3E  = 18,
               e_processor_type_HITACHI_SH4   = 19,
               e_processor_type_MOTOROLA_821  = 20,
               e_processor_type_SHx_SH3       = 21,
               e_processor_type_SHx_SH4       = 22,
               e_processor_type_STRONGARM     = 23,
               e_processor_type_ARM720        = 24,
               e_processor_type_ARM820        = 25,
               e_processor_type_ARM920        = 26,
               e_processor_type_ARM_7TDMI     = 27,
               e_processor_type_last
             };

       // DQ (6/15/2008): Adding interface to simplify migration to newer executable formate IR nodes.
       // JJW (6/18/2008): Commenting out because this function doesn't have a definition
       // SgAsmGenericSectionPtrList & get_sectionList();
#endif

          void post_construction_initialization();

HEADER_BINARY_FILE_END


HEADER_BINARY_FILE_SECTION_HEADER_START

#if 0
          enum elf_version_enum
             {
               e_version_error   = 0,
               e_version_unknown = 1,
               e_version_none    = 2, // value maps to EV_NONE
               e_version_current = 3, // value maps to EV_CURRENT
               e_version_last
             };
#endif

HEADER_BINARY_FILE_SECTION_HEADER_END


HEADER_BINARY_FILE_PROGRAM_HEADER_START

#if 0
          enum elf_type_enum
             {
               e_type_error                = 0,
               e_type_unknown              = 1,
               e_type_null                 = 2,
               e_type_loadable_segment     = 3,
               e_type_dynamic_linking_info = 4,
               e_type_interpreter          = 5,
               e_type_note                 = 6,
               e_type_shlib_reserved       = 7,
               e_type_program_header_table = 8,
               e_type_processor_specific   = 9,
               e_type_last
             };
#endif

HEADER_BINARY_FILE_PROGRAM_HEADER_END


HEADER_BINARY_FILE_SECTION_HEADER_LIST_START
       // const SgAsmSectionHeaderPtrList & get_section_headers() const;
       // SgAsmSectionHeaderPtrList & get_section_headers();

HEADER_BINARY_FILE_SECTION_HEADER_LIST_END


HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_START
       // const SgAsmProgramHeaderPtrList & get_program_headers() const;
       // SgAsmProgramHeaderPtrList & get_program_headers();

HEADER_BINARY_FILE_PROGRAM_HEADER_LIST_END

HEADER_BINARY_BYTE_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_BYTE_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_VECTOR_VALUE_EXPRESSION_END

HEADER_BINARY_WORD_VALUE_EXPRESSION_START

          virtual SgAsmType* get_type();

HEADER_BINARY_WORD_VALUE_EXPRESSION_END



// ************************************
// NEW IR NODES FOR BINARY FILE FORMATS
// ************************************

HEADER_EXECUTABLE_FILE_FORMAT_START

     public:
       // DQ (8/21/2008): We need something to be in global scope (or not nested here) so that a few references in Node.code can be made.
          typedef rose_addr_t addr_t; // address and size (file and memory)
	  typedef rose_rva_t rva_t;   // relative virtual address

       // DQ (8/21/2008): Moved this from Node.code to make it local since we can't reference the nested addr_t directly from glogal scope.
       // typedef Rose_STL_Container<addr_t> SgAddressList;
       // typedef SgAddressList*             SgAddressListPtr;

       /* Thrown when an attempt is made to read past the end of a file, section, header, segment, etc. */
          class ShortRead {
               public:
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    const SgAsmGenericSection *section;   /* Section from which read occurred; null implies file-level write */
                    addr_t         offset;    /* Byte offset into section (or file) */
                    addr_t         size;      /* Number of bytes of attempted read */
                    std::string          mesg;      /* Optional message */
             };

       /* Thrown when an attempt is made to write past the end of a file, section, header, segment, etc. */
          class ShortWrite {
               public:
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size)
                       : section(section), offset(offset), size(size) {}
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
                       : section(section), offset(offset), size(size), mesg(mesg) {}
                    const SgAsmGenericSection *section;  /* Section to which write occurred; null implies file-level write */
                    addr_t         offset;   /* Byte offset into section (or file) */
                    addr_t         size;     /* Number of bytes of attempted write */
                    std::string          mesg;     /* Optional message */
             };

       /* Thrown when the file contains an error that prevents us from parsing it. */
          class FormatError {
               public:
                    FormatError(const std::string &mesg) {this->mesg=mesg;}
                    FormatError(const char *mesg) {this->mesg=mesg;}
                    std::string mesg;
             };


          typedef struct stat fileDetails;

          enum ByteOrder {
              ORDER_UNSPECIFIED,
              ORDER_LSB,                                          /* little-endian; least significant byte first */
              ORDER_MSB,                                          /* big-endian; most significant byte first */
             };
    
          enum ExecFamily {
              FAMILY_UNSPECIFIED,
              FAMILY_DOS,                                         /* Microsoft DOS format */
              FAMILY_ELF,                                         /* Unix Executable and Linking Format */
              FAMILY_LE,                                          /* Microsft Linear Executable format */
              FAMILY_LX,                                          /* OS/2 LX (Windows 9x VxD device drivers, extension of LE) */
              FAMILY_NE,                                          /* Microsoft New Executable Format */
              FAMILY_PE                                           /* Microsoft Portable Executable Format */
             };

          enum ExecABI {
              ABI_UNSPECIFIED,                                    /* Not specified in file and could not be inferred */
              ABI_OTHER,                                          /* Anything other than values below */
              ABI_86OPEN,                                         /* 86Open Common IA32 */
              ABI_AIX,                                            /* AIX */
              ABI_ARM,                                            /* ARM architecture */
              ABI_FREEBSD,                                        /* FreeBSD */
              ABI_HPUX,                                           /* HP/UX */
              ABI_IRIX,                                           /* IRIX */
              ABI_HURD,                                           /* GNU/Hurd */
              ABI_LINUX,                                          /* GNU/Linux */
              ABI_MODESTO,                                        /* Novell Modesto */
              ABI_MONTEREY,                                       /* Monterey project */
              ABI_MSDOS,                                          /* Microsoft DOS */
              ABI_NT,                                             /* Windows NT */
              ABI_NETBSD,                                         /* NetBSD */
              ABI_OS2,                                            /* OS/2 */
              ABI_SOLARIS,                                        /* Sun Solaris */
              ABI_SYSV,                                           /* SysV R4 */
              ABI_TRU64,                                          /* Compaq TRU64 UNIX */
              ABI_WIN386                                          /* Microsoft Windows */
             };

          /* Instruction sets organized by families */
          enum InsSetArchitecture {
              ISA_UNSPECIFIED             = 0x0000,               /* File does not specify an architecture */
              ISA_OTHER                   = 0xffff,               /* Architecture is something other than below */
              ISA_FAMILY_MASK             = 0xff00,               /* Mask to get family part of ISA */

              ISA_IA32_Family             = 0x0100,               /* x86 IA-32 family of architectures; Intel, AMD, VIA, ... */
              ISA_IA32_286                = 0x0101,               /* 80286 */
              ISA_IA32_386                = 0x0102,               /* MMU with paging */
              ISA_IA32_486                = 0x0103,               /* risc-like pipelining, integrated FPU, on-chip cache */
              ISA_IA32_Pentium            = 0x0104,               /* superscalar, 64-bit databus, MMX */
              ISA_IA32_Cyrix6x86          = 0x0105,               /* register renaming, speculative execution */
              ISA_IA32_AMDK5              = 0x0106,               /* micro-op translation */
              ISA_IA32_PentiumPro         = 0x0107,               /* PAE, integrated L2 cache */
              ISA_IA32_PentiumII          = 0x0108,               /* L3-cache, 3D Now, SSE */
              ISA_IA32_Athlon             = 0x0109,               /* superscalar FPU, wide design */
              ISA_IA32_Pentium4           = 0x010a,               /* deeply pipelined, high frequency, SSE2, hyper-threading */
              ISA_IA32_PentiumM           = 0x010b,               /* low power */

              ISA_X8664_Family            = 0x0200,               /* x86-64 family of architectures: Intel, AMD, VIA, ... */
              ISA_X8664_Athlon64          = 0x0201,               /* on-die memory controller, 40-bit phys address space */
              ISA_X8664_Prescott          = 0x0202,               /* deeply pipelined, high frequency, SSE3 */
              ISA_X8664_IntelCore         = 0x0203,               /* low power, multi-core, lower clock frequency */
              ISA_X8664_AMDPhenom         = 0x0204,               /* quad core, 128-bit FPUs, SSE4a, native mem ctrl, on-die L3 cache */

              ISA_SPARC_Family            = 0x0300,               /* SPARC family of architectures; Sun Microsystems */
              ISA_SPARC_V7                = 0x0301,
              ISA_SPARC_V8                = 0x0302,
              ISA_SPARC_V8E               = 0x0303,
              ISA_SPARC_V9                = 0x0304,
              ISA_SPARC_V9JPS1            = 0x0305,
              ISA_SPARC_V9UA              = 0x0306,
              ISA_SPARC_V9JPS2            = 0x0307,

              ISA_M68K_Family             = 0x0400,               /* Motorala m68k family */
              ISA_M68K_68000              = 0x0401,               /* generation one: 16/32 internal; 8-, 16-, 32-bit interface */
              ISA_M68K_68EC000            = 0x0402,
              ISA_M68K_68HC000            = 0x0403,
              ISA_M68K_68008              = 0x0404,
              ISA_M68K_68010              = 0x0405,
              ISA_M68K_68012              = 0x0406,
              ISA_M68K_68020              = 0x0407,               /* generation two: fully 32-bit */
              ISA_M68K_68EC020            = 0x0408,
              ISA_M68K_68030              = 0x0409,
              ISA_M68K_68EC030            = 0x040a,
              ISA_M68K_68040              = 0x040b,               /* generation three: pipelined */
              ISA_M68K_68EC040            = 0x040c,
              ISA_M68K_68LC040            = 0x040d,
              ISA_M68K_68060              = 0x040e,               /* generation four: superscalar */
              ISA_M68K_ColdFire           = 0x040f,               /* other */
              ISA_M68K_DragonBall         = 0x0410,               /* other */

              ISA_M88K_Family             = 0x0500,               /* Motorola m88k family (not very popular) */
              ISA_M88K_88100              = 0x0501,               /* 32-bit, integrated FPU mated with 88200 MMU and cache controller */
              ISA_M88K_88110              = 0x0502,               /* single package of 88100+88200 */
              ISA_M88K_88110MP            = 0x0503,               /* on-chip comm for use in multi-processor systems */
              ISA_M88K_88120              = 0x0504,               /* superscalar (never actually released) */

              ISA_MIPS_Family             = 0x0600,               /* 32/64-bit RISC; MIPS Technologies, Inc. */
              ISA_MIPS_MarkI              = 0x0601,               /* R2000, R3000 */
              ISA_MIPS_MarkII             = 0x0602,               /* R6000 */
              ISA_MIPS_MarkIII            = 0x0603,               /* R4000 */
              ISA_MIPS_R2000              = 0x0604,               /* 32-bit, Big or little endian */
              ISA_MIPS_R3000              = 0x0605,               /* virtual identical: Pacempi's R3400, IDT's R3500, Toshiba R3900 */
              ISA_MIPS_R4000              = 0x0606,               /* 64-bit; others in the series had larger caches and bug fixes */
              ISA_MIPS_R4200              = 0x0607,               /* low-cost version of R4000 */
              ISA_MIPS_R4300              = 0x0608,               /* low-cost version of R4000 with 32-bit external bus */
              ISA_MIPS_R4600              = 0x0609,               /* "Orion" by Qauntum Effect Devices (QED); larger caches */
              ISA_MIPS_R4650              = 0x060a,               /* by QED */
              ISA_MIPS_R4700              = 0x060b,               /* "Orion" by QED */
              ISA_MIPS_R5000              = 0x060c,               /* by QED */
              ISA_MIPS_RM7000             = 0x060d,               /* by PMC-Sierra; 256kB L2 and optional L3 */
              ISA_MIPS_R8000              = 0x060e,               /* superscalar, fairly rare */
              ISA_MIPS_R10000             = 0x060f,               /* R8000 on a single chip; 32kB caches; out-of-order */
              ISA_MIPS_R12000             = 0x0610,               /* R10000 + higher clock rates */
              ISA_MIPS_R14000             = 0x0611,               /* R12000 + support for DDR SRAM; 200MHz front side bus */
              ISA_MIPS_R16000             = 0x0612,               /* R14000 + increased freq, more L1, smaller die */
              ISA_MIPS_R16000A            = 0x0613,
              ISA_MIPS_16                 = 0x0614,               /* Unknown. Windows PE architecture 0x266 "MIPS16" */
              ISA_MIPS_FPU                = 0x0615,               /* Unknown. Windows PE architecture 0x366 "MIPS with FPU" */
              ISA_MIPS_16FPU              = 0x0616,               /* Unknown. Windows PE architecture 0x466 "MIPS16 with FPU" */

              ISA_I860_Family             = 0x0700,               /* Intel i860 family; 1989-mid 90's; RISC VLIW */
              ISA_I860_860XR              = 0x0701,               /* (code named N10) 25-40MHz */
              ISA_I860_860XP              = 0x0702,               /* (code named N11) larger caches; 40-50MHz; same IS as XR */

              ISA_IA64_Family             = 0x0800,               /* Intel 64-bit architecture */
              ISA_IA64_Itanium            = 0x0801,               /* First generation */
              ISA_IA64_Itanium2           = 0x0802,               /* Second generation starting Nov 2007 */

              /* See http://en.wikipedia.org/wiki/ARM_architecture */
              ISA_ARM_Family              = 0x0900,               /* Acorn RISC Machine, Advanced RISC Machines, ARM Limited */
              ISA_ARM_ARM1                = 0x0901,               /* ARM evaluation system */
              ISA_ARM_ARM2                = 0x0902,               /* ARM2, ARM250 cores */
              ISA_ARM_ARM3                = 0x0903,               /* ARM2a core */
              ISA_ARM_ARM6                = 0x0904,               /* ARM60, ARM600, ARM610 cores */
              ISA_ARM_ARM7                = 0x0905,               /* ARM{700,710,710a,7100,7500,7500FE} cores */
              ISA_ARM_ARM7TDMI            = 0x0906,               /* ARM{7TDMI,7TDMI-S,710T,720T,740T,7EJ-S} cores */
              ISA_ARM_StrongARM           = 0x0907,               /* SA-110, SA-1110 cores */
              ISA_ARM_ARM8                = 0x0908,               /* ARM810 core */
              ISA_ARM_ARM9TDMI            = 0x0909,               /* ARM{9TDMI,920T,922T,940T} cores */
              ISA_ARM_ARM9E               = 0x090a,               /* ARM{946E-S,966E-S,968E-S,926EJ-S,966HS} cores */
              ISA_ARM_ARM10E              = 0x090b,               /* ARM{1020E,1022E,1026EJ-S} cores */
              ISA_ARM_XScale              = 0x090c,               /* 80200, IOP310, IOP315, 80219, IOP321, IOP33x, IOP34x, PXA210,
                                                         * PXA250, PXA255, PXA26x, PXA27x, PXA800(E)F, Monahans, PXA900,
                                                         * IXC1100, IXP2400, IXP2800, IXP2850, IXP2325, IXP2350, IXP42x,
                                                         * IXP460, IXP465 cores */
              ISA_ARM_ARM11               = 0x090d,               /* ARMv{6,6T2,6KZ,6K} cores */
              ISA_ARM_Cortex              = 0x090e,               /* Cortex-{A8,A9,A9 MPCore,R4(F),M3,M1} cores */
          
              /* Others, not yet incorporated into this enum */
              ISA_OTHER_Family            = 0xf000,

              ISA_ATT_WE_32100            = 0xf001,               /* sometimes simply "M32" */
              ISA_IBM_System_370          = 0xf002,
              ISA_HPPA                    = 0xf003,
              ISA_Fujitsu_VPP500          = 0xf004,
              ISA_Sun_v8plus              = 0xf005,
              ISA_PowerPC                 = 0xf006,
              ISA_PowerPC_64bit           = 0xf007,
              ISA_IBM_S390                = 0xf008,
              ISA_NEC_V800_series         = 0xf009,
              ISA_Fujitsu_FR20            = 0xf00a,
              ISA_TRW_RH_32               = 0xf00b,
              ISA_Motorola_RCE            = 0xf00c,
              ISA_Digital_Alpha_fake      = 0xf00e,
              ISA_Hitachi_SH              = 0xf00f,
              ISA_Siemens_Tricore         = 0xf010,
              ISA_Argonaut_RISC_Core      = 0xf011,
              ISA_Hitachi_H8_300          = 0xf012,
              ISA_Hitachi_H8_300H         = 0xf013,
              ISA_Hitachi_H8S             = 0xf014,
              ISA_Hitachi_H8_500          = 0xf015,
              ISA_Stanford_MIPS_X         = 0xf016,
              ISA_Motorola_M68HC12        = 0xf017,
              ISA_Fujitsu_MMA_Multimedia_Accelerator=0xf018,
              ISA_Siemens_PCP             = 0xf019,
              ISA_Sony_nCPU_embeeded_RISC = 0xf01a,
              ISA_Denso_NDR1_microprocessor=0xf01b,
              ISA_Motorola_Start_Core_processor=0xf01c,
              ISA_Toyota_ME16_processor   = 0xf01d,
              ISA_STMicroelectronic_ST100_processor=0xf01e,
              ISA_Advanced_Logic_Corp_Tinyj_emb_family=0xf01f,
              ISA_AMD_x86_64_architecture = 0xf020,
              ISA_Sony_DSP_Processor      = 0xf021,
              ISA_Siemens_FX66_microcontroller=0xf022,
              ISA_STMicroelectronics_ST9_plus_8_16_microcontroller=0xf023,
              ISA_STMicroelectronics_ST7_8bit_microcontroller=0xf024,
              ISA_Motorola_MC68HC16_microcontroller=0xf025,
              ISA_Motorola_MC68HC11_microcontroller=0xf026,
              ISA_Motorola_MC68HC08_microcontroller=0xf027,
              ISA_Motorola_MC68HC05_microcontroller=0xf028,
              ISA_Silicon_Graphics_SVx    = 0xf029,
              ISA_STMicroelectronics_ST19_8bit_microcontroller=0xf02a,
              ISA_Digital_VAX             = 0xf02b,
              ISA_Axis_Communications_32bit_embedded_processor=0xf02c,
              ISA_Infineon_Technologies_32bit_embedded_processor=0xf02d,
              ISA_Element_14_64bit_DSP_Processor=0xf02e,
              ISA_LSI_Logic_16bit_DSP_Processor=0xf02f,
              ISA_Donald_Knuths_educational_64bit_processor=0xf030,
              ISA_Harvard_University_machine_independent_object_files=0xf031,
              ISA_SiTera_Prism            = 0xf032,
              ISA_Atmel_AVR_8bit_microcontroller=0xf033,
              ISA_Fujitsu_FR30            = 0xf034,
              ISA_Mitsubishi_D10V         = 0xf035,
              ISA_Mitsubishi_D30V         = 0xf036,
              ISA_NEC_v850                = 0xf037,
              ISA_Mitsubishi_M32R         = 0xf038,
              ISA_Matsushita_MN10300      = 0xf039,
              ISA_Matsushita_MN10200      = 0xf03a,
              ISA_picoJava                = 0xf03b,
              ISA_OpenRISC_32bit_embedded_processor=0xf03c,
              ISA_ARC_Cores_Tangent_A5    = 0xf03d,
              ISA_Tensilica_Xtensa_Architecture=0xf03e,
              ISA_Digital_Alpha		= 0xf03f,
              ISA_Matsushita_AM33         = 0xf040,
              ISA_EFI_ByteCode            = 0xf041
             };

       /* General purpose of a binary executable file */
          enum ExecPurpose {
              PURPOSE_UNSPECIFIED,                                /* Purpose is not specified and could not be inferred */
              PURPOSE_OTHER,                                      /* A purpose other than any defined below */
              PURPOSE_EXECUTABLE,                                 /* Executable program */
              PURPOSE_LIBRARY,                                    /* Library (shared or relocatable) */
              PURPOSE_CORE_DUMP,                                  /* Post mortem image */
              PURPOSE_OS_SPECIFIC,                                /* Some operating system specific purpose */
              PURPOSE_PROC_SPECIFIC                               /* Some processor specific purpose */
          };


       // DQ (12/8/2008): Hook into the construction of the binary file format support.
          static SgAsmGenericFile *parseBinaryFormat(const char *name);
          static void unparseBinaryFormat(const std::string &name, SgAsmGenericFile*);
	  static void unparseBinaryFormat(std::ostream&, SgAsmGenericFile*);

        /** Displays binary data in a fashion similar to the "hexdump -C" command in Unix: an address, numeric byte values,
         *  character byte values.  The format of the output is configurable through the HexdumpFormat argument. There are
	 *  other versions that output containers of data.  The hexdump comes in three flavors: output to a C++ stream,
	 *  output to a C FILE, and output to an std::string.  The FILE and string versions are implemented in terms of the
	 *  stream version. */
	static void hexdump(std::ostream&, rose_addr_t base_addr, const unsigned char *data, size_t data_sz, const HexdumpFormat&);
	static void hexdump(std::ostream&, rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
			    bool multiline=true);
	static void hexdump(std::ostream&, rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
			    bool multiline=true);

	/* Same, but returning a string instead. */
	static std::string hexdump(rose_addr_t base_addr, const unsigned char *data, size_t data_sz, const HexdumpFormat&);
	static std::string hexdump(rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
			           bool multiline=true);
	static std::string hexdump(rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
			           bool multiline=true);

	/* Same, but output to a FILE* instead. */
	static void hexdump(FILE*, rose_addr_t base_addr, const unsigned char *data, size_t data_sz, const HexdumpFormat&);
	static void hexdump(FILE*, rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
			    bool multiline=true);
	static void hexdump(FILE*, rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
			    bool multiline=true);

       /* Return byte order of caller */
          static SgAsmExecutableFileFormat::ByteOrder host_order();

       /* Swap (reverse) bytes taking care of sign extension */
          static uint8_t swap_bytes(uint8_t n);
          static uint16_t swap_bytes(uint16_t n);
          static uint32_t swap_bytes(uint32_t n);
          static uint64_t swap_bytes(uint64_t n);

          static int8_t swap_bytes(int8_t n);
          static int16_t swap_bytes(int16_t n);
          static int32_t swap_bytes(int32_t n);
          static int64_t swap_bytes(int64_t n);

       /* Little-endian byte order conversions */
          static uint8_t le_to_host(uint8_t n);
          static uint16_t le_to_host(uint16_t n);
          static uint32_t le_to_host(uint32_t n);
          static uint64_t le_to_host(uint64_t n);

          static int8_t le_to_host(int8_t n);
          static int16_t le_to_host(int16_t n);
          static int32_t le_to_host(int32_t n);
          static int64_t le_to_host(int64_t n);

          static void host_to_le(unsigned h, uint8_t *n);
          static void host_to_le(unsigned h, uint16_t *n);
          static void host_to_le(unsigned h, uint32_t *n);
          static void host_to_le(addr_t h, uint64_t *n);
          static void host_to_le(rva_t h, uint32_t *n);
          static void host_to_le(rva_t h, uint64_t *n);
          static void host_to_le(int h, int8_t *n);
          static void host_to_le(int h, int16_t *n);
          static void host_to_le(int h, int32_t *n);
          static void host_to_le(int64_t h, int64_t *n);

       /* Big-endian byte order conversions */
          static uint8_t be_to_host(uint8_t n);
          static uint16_t be_to_host(uint16_t n);
          static uint32_t be_to_host(uint32_t n);
          static uint64_t be_to_host(uint64_t n);
          static int8_t be_to_host(int8_t n);
          static int16_t be_to_host(int16_t n);
          static int32_t be_to_host(int32_t n);
          static int64_t be_to_host(int64_t n);

          static void host_to_be(unsigned h, uint8_t *n);
          static void host_to_be(unsigned h, uint16_t *n);
          static void host_to_be(unsigned h, uint32_t *n);
          static void host_to_be(addr_t h, uint64_t *n);
          static void host_to_be(rva_t h, uint32_t *n);
          static void host_to_be(rva_t h, uint64_t *n);
          static void host_to_be(int h, int8_t *n);
          static void host_to_be(int h, int16_t *n);
          static void host_to_be(int h, int32_t *n);
          static void host_to_be(int64_t h, int64_t *n);

       /* Caller-specified byte order conversions */
          static uint8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint8_t n);
          static uint16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint16_t n);
          static uint32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint32_t n);
          static uint64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, uint64_t n);
          static int8_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int8_t n);
          static int16_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int16_t n);
          static int32_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int32_t n);
          static int64_t disk_to_host(SgAsmExecutableFileFormat::ByteOrder sex, int64_t n);

       // static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder, unsigned char h, unsigned char *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, unsigned h, uint32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, addr_t h, uint64_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, rva_t h, uint64_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int8_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int16_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int h, int32_t *np);
          static void host_to_disk(SgAsmExecutableFileFormat::ByteOrder sex, int64_t h, int64_t *np);

	  static std::string isa_family_to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
	  static std::string isa_to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
       /**alias for isa_to_string(InsSetArchitecture) */
	  static std::string to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
	  static std::string to_string(SgAsmExecutableFileFormat::ByteOrder);
	  static std::string to_string(SgAsmExecutableFileFormat::ExecFamily);
	  static std::string to_string(SgAsmExecutableFileFormat::ExecABI);
	  static std::string to_string(SgAsmExecutableFileFormat::ExecPurpose);
HEADER_EXECUTABLE_FILE_FORMAT_END



HEADER_GENERIC_SECTION_START
	public:
		// RPM (8/27/2008): Is this right? get_offset() returns file offset; get_mapped_rva() returns memory addr*/
		// This can be mapped to the offset data member
		unsigned long get_starting_memory_address() { return get_offset(); }

		// DQ (8/7/2008): These are a few data member access functions that were required 
		// to compile when first adding the new IR nodes (these should be removed).
		unsigned long get_starting_file_offset() { return 0; }
		unsigned long get_flags() { return 0; }
		unsigned long get_type() { return 0; }


		/* Reason for section's existence. This is a union of all the section purposes from the various supported file
		 * formats.  However, at this time we're only interested in a few kinds of sections and therefore most will fall
		 * into the SP_OTHER category. */
		enum SectionPurpose {
			SP_UNSPECIFIED,			/* File format did not specify a reason and none could be determined */
			SP_PROGRAM,             	/* Program-supplied data, code, etc. */
			SP_HEADER,              	/* Section contains a header for the executable file format */
			SP_SYMTAB,              	/* Symbol table */
			SP_OTHER                	/* File-specified purpose other than any given in this enum */
		};

		SgAsmGenericSection(SgAsmGenericFile *f, SgAsmGenericHeader *fhdr)
			: local_data_pool(0), p_file(f), p_header(NULL), p_size(1), p_offset(f->get_current_size()),
			p_file_alignment(0), p_purpose(SP_UNSPECIFIED), p_synthesized(false), p_id(-1), p_name(0),
			p_mapped_preferred_rva(0), p_mapped_size(0), p_mapped_alignment(0), p_mapped_rperm(false),
			p_mapped_wperm(false), p_mapped_xperm(false), p_contains_code(false), p_mapped_actual_va(0)
			{ctor(f, fhdr);}

		// This destructor modifies the SgAsmGenericFile data to remove its section from the section list!
		virtual ~SgAsmGenericSection();

		static void dump_containing_sections(FILE *f, const std::string &prefix, rose_rva_t rva,
			const SgAsmGenericSectionPtrList&);
		void grab_content();
		virtual SgAsmGenericSection* parse() {grab_content(); return this;}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual bool reallocate() {return false;}
		virtual void unparse(std::ostream&) const;
		void unparse(std::ostream&, const ExtentMap&) const;
		void unparse_holes(std::ostream&) const;
		SgAsmGenericHeader *is_file_header();	/** true if section represents a top level file header */

		/* Functions for section extent within the file */
		addr_t        get_size() const;
		virtual void  set_size(addr_t);		/* Resize a section w/o regard to other sections or mapping */
		addr_t        get_offset() const;
		virtual void  set_offset(addr_t);		/** Move a section w/o regard to other sections or mapping */
		addr_t        get_end_offset() const;		/** file offset for end of section */
		void          extend(addr_t nbytes);         	/** make section larger by extending the end */
		addr_t        write(std::ostream&, addr_t offset, size_t bufsize, const void *buf) const;
		addr_t        write(std::ostream&, addr_t offset, const std::string &str) const;
		addr_t        write(std::ostream&, addr_t offset, char c) const;
		addr_t        write(std::ostream&, addr_t offset, const SgFileContentList &buf) const;
		addr_t	      write(std::ostream&, addr_t offset, const SgUnsignedCharList &buf) const;
		addr_t        write_uleb128(unsigned char*, addr_t offset, uint64_t) const;
		addr_t        write_sleb128(unsigned char*, addr_t offset, int64_t) const;

		/* Functions for accessing content */
		size_t read_content(addr_t abs_offset, void *dst_buf, addr_t size, bool strict=true);
		size_t read_content(const MemoryMap*, addr_t rva, void *dst_buf, addr_t size, bool strict=true);
		size_t read_content(const MemoryMap *map, rva_t rva, void *dst_buf, addr_t size, bool strict=true) {
			return read_content(map, rva.get_rva(), dst_buf, size, strict);
		}
		size_t read_content_local(addr_t rel_offset, void *dst_buf, addr_t size, bool strict=true);
		std::string read_content_str(const MemoryMap*, addr_t rva, bool strict=true);
		std::string read_content_str(const MemoryMap *map, rva_t rva, bool strict=true) {
			return read_content_str(map, rva.get_rva(), strict);
		}
		std::string read_content_str(addr_t abs_offset, bool strict=true);
		std::string read_content_local_str(addr_t rel_offset, bool strict=true);
		SgUnsignedCharList read_content_local_ucl(addr_t rel_offset, addr_t size); //always non-strict
		int64_t read_content_local_sleb128(rose_addr_t *rel_offset, bool strict=true);
		uint64_t read_content_local_uleb128(rose_addr_t *rel_offset, bool strict=true);
		unsigned char *writable_content(size_t nbytes); /* obtain a local, writable pool to hold content */

		/* Functions for tracking referenced/unreferenced content. The tracking actually happens at the entire file level
		 * (see functions with the same name in SgAsmGenericFile) and these functions return that same information but
		 * limit the results to this section and return section rather than file offsets. */
		ExtentMap get_referenced_extents() const;	/* Returns parts of the file that have been referenced */
		ExtentMap get_unreferenced_extents() const;	/* Returns parts of file that have not been referenced */

		/* Functions related to mapping of sections into executable memory */
		bool   	      is_mapped() const;                /** True iff non-zero mapped address and size */
		void   	      clear_mapped();                 	/** Set mapped address and size to zero (unmapped)*/
		addr_t        get_mapped_size() const;
		virtual void  set_mapped_size(addr_t);	      	/* Set mapped size w/o regard to other section mappings */
		addr_t	      get_mapped_preferred_rva() const;	/* The virtual address indicated in the binary file */
		virtual void  set_mapped_preferred_rva(addr_t); /* Move a section w/o regard to other section mappings */
		addr_t 	      get_base_va() const;            	/* Convenience to get header's base VA */
		addr_t 	      get_mapped_preferred_va() const;	/* Like get_mapped_preferred_rva() except returns absolute VA */
		addr_t        get_va_offset(addr_t va) const;  	/* Return file offset for specified virtual address */
		addr_t	      get_rva_offset(addr_t rva) const;	/* Return file offset for specified relative virtual address */

		/* Accessors for private members */
		SgAsmGenericString *get_name() const;		/** Same as standard ROSETTA accessor */
		void set_name(SgAsmGenericString *s);		/** Like std accessor but sets parent of 's' */

		/* Convenience functions */
		ExtentPair get_file_extent() const;		/* Returns get_offset() and get_size() */
		ExtentPair get_mapped_preferred_extent() const; /* Returns get_mapped_preferred_rva() and get_mapped_size() */

		// PC (05/16/2010): Commented out as no definition exists
		// bool is_content_writable() const;               /** Returns true if a contents are writable. i.e. local_data_pool!=NULL */
		static std::string to_string(SgAsmGenericSection::SectionPurpose);
	protected:
		void ctor(SgAsmGenericFile*, SgAsmGenericHeader*);

	private:
		/** This is an optional local, writable pool for the p_data member. Normally a section will point into the pool
		 * for its SgAsmGenericFile which is memory-mapped (read-only) from the actual file being parsed. The default
		 * unparsing action is to write the original data back to the file. By allowing a section to allocate its own
		 * pool for p_data we create a very easy way to get data into the unparsed file (the alternative is to derive
		 * a new class and override the unparse() method). */
		unsigned char *local_data_pool;
HEADER_GENERIC_SECTION_END



HEADER_GENERIC_HEADER_START
	public:
          	explicit SgAsmGenericHeader(SgAsmGenericFile *ef)
			: SgAsmGenericSection(ef, NULL),
			p_exec_format(NULL), p_isa(ISA_OTHER), p_base_va(0), p_dlls(NULL), p_sections(NULL)
			{ctor();}

		virtual ~SgAsmGenericHeader();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

		// DQ (8/8/2008): We can't make this pure virtual since then we can't allocate this class.
		// virtual const char *format_name() = 0;
		virtual const char *format_name() const;

		/* Functions for dynamically linked libraries (DLLs) */
		void add_dll(SgAsmGenericDLL *dll);                     /* Add new DLL to list of DLLs for this file */
		std::vector<SgAsmGenericDLL*>& get_dlls() {		/* all necessary dynamically loaded libraries */
		        ROSE_ASSERT(p_dlls != NULL);
			return p_dlls->get_dlls();
		}

		/* Accessors for protected/private members */
		std::vector<unsigned char>& get_magic() {return p_magic;}
		addr_t get_entry_rva() const;
		void add_entry_rva(const rose_rva_t &rva) { p_entry_rvas.push_back(rva);}

		/* Convenience functions */
		SgAsmExecutableFileFormat::ByteOrder get_sex() const;
		size_t get_word_size() const;

		/* Functions for sections */
		void add_section(SgAsmGenericSection*); /* Add new section to the file; called implicitly by section ctor */
		void remove_section(SgAsmGenericSection*); 	      /* Remove section from the file */

		/* Section lookup functions (plural) */
		SgAsmGenericSectionPtrList get_mapped_sections() const;
		SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
		SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep=0) const;
		SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size) const;
		SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva) const;
		SgAsmGenericSectionPtrList get_sections_by_va(addr_t va, bool use_preferred) const;

		/* Section lookup functions (singular) */
		SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_va(addr_t va, bool use_preferred, size_t *nfound=0) const;
		SgAsmGenericSection *get_best_section_by_va(addr_t va, bool use_preferred, size_t *nfound=0) const;

	private:
		void ctor();
HEADER_GENERIC_HEADER_END



HEADER_GENERIC_FILE_START
	public:
		SgAsmGenericFile()
			: p_unreferenced_cache(NULL), p_data_converter(NULL),p_fd(-1), p_headers(NULL), p_holes(NULL),
			  p_truncate_zeros(false), p_tracking_references(true)
			{ctor();}
		virtual ~SgAsmGenericFile();				/* Destructor deletes children and unmaps/closes file */
		SgAsmGenericFile* parse(std::string file_name);		/* Attach an existing file for parsing */
		void reallocate();					/* Make consistent before calling unparse */
		void unparse(std::ostream&) const;			/* Unparse the file -- mirror image of parsing */
		void extend_to_eof(std::ostream&) const;		/* Write zeros to logical EOF */
		void dump(FILE*) const;                                 /* Print some top-level debugging info */
		void dump_all(bool in_cwd=true, const char *ext=NULL);	/* Recursively print all known info about the file */
		void dump_all(const std::string& dumpname);		/* Recursively print all known info about the file */

		/* Tracking references */
		const ExtentMap& get_unreferenced_extents() const;	/* Returns parts of file that have not been referenced */
		void mark_referenced_extent(addr_t start_rva, addr_t size);

		/* Converting encoding/decoding data is it's transferred from/to disk. */
		void set_data_converter(DataConverter* dc) {p_data_converter=dc;}
		DataConverter* get_data_converter() const {return p_data_converter;}

		/* File contents */
		rose_addr_t get_current_size() const;			/* Current size based on defined sections */
		rose_addr_t get_orig_size() const;              	/* Original size based on actual file size */
		size_t read_content(addr_t offset, void *dst_buf, addr_t size, bool strict=true);
		size_t read_content(const MemoryMap *map, addr_t va, void *dst_buf, addr_t size, bool strict=true);
		std::string read_content_str(const MemoryMap *map, addr_t va, bool strict=true);
		std::string read_content_str(addr_t abs_offset, bool strict=true);

		const SgFileContentList& content() {			/* Entire file contents */
			return p_data;
		}
		SgFileContentList content(addr_t offset, addr_t size);	/* Partial file contents; no reference tracking */

		/* Section lookup functions (plural) */
		SgAsmGenericSectionPtrList get_mapped_sections() const;
		SgAsmGenericSectionPtrList get_sections(bool include_holes=true) const;
		SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
		SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep='\0') const;
		SgAsmGenericSectionPtrList get_sections_by_offset(addr_t offset, addr_t size) const;
		SgAsmGenericSectionPtrList get_sections_by_rva(addr_t rva) const;
		SgAsmGenericSectionPtrList get_sections_by_va(addr_t va) const;

		/* Section lookup functions (singular) */
		SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_offset(addr_t offset, addr_t size, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_rva(addr_t rva, size_t *nfound=0) const;
		SgAsmGenericSection *get_section_by_va(addr_t va, size_t *nfound=0) const;
		SgAsmGenericSection *get_best_section_by_va(addr_t va, size_t *nfound=0) const;
		static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList &sections, addr_t va);

		/* Section modification functions */
		enum AddressSpace {					/* Bit flags for address spaces for shift_extend() */
			ADDRSP_MEMORY = 0x0001,
			ADDRSP_FILE   = 0x0002,
			ADDRSP_ALL    = 0x0003,
		};
		enum Elasticity {					/* Elasticity argument for shift_extend() */
			ELASTIC_NONE  = 0,				/* Nothing is elastic; other parts of space are shifted */
			ELASTIC_UNREF = 1,				/* Unreferenced address space is elastic */
			ELASTIC_HOLE  = 2,				/* Unreferenced and "hole" sections are elastic */
		};
		void shift_extend(SgAsmGenericSection *s, addr_t sa, addr_t sn)
			{shift_extend(s, sa, sn, ADDRSP_ALL, ELASTIC_UNREF);}
		void shift_extend(SgAsmGenericSection*, addr_t sa, addr_t sn, AddressSpace, Elasticity);

		/* Holes (unreferenced regions in the file) */	
		addr_t get_next_section_offset(addr_t offset);      	/* Find file offset for next section */
		void add_hole(SgAsmGenericSection*);		      	/* Add section to list of holes */
		void remove_hole(SgAsmGenericSection*);             	/* Remove section from list of holes */
		void fill_holes();                                  	/* Find holes in file and create sections to fill them */
		void unfill_holes();                                	/* Undoes what fill_holes() did */

		/* Functions for file headers (a kind of section) */
		void add_header(SgAsmGenericHeader*);               	/* Add a new file header to the list of headers */
		void remove_header(SgAsmGenericHeader*);            	/* Remove file header from the file */
		SgAsmGenericHeader *get_header(SgAsmGenericFormat::ExecFamily);/* Returns the specified header or exception */
		const char *format_name() const;                        /* Return a string describing the file format */

		const SgAsmGenericFormat::fileDetails &get_sb() {
			return p_sb;
		}
		void set_sb(const SgAsmGenericFormat::fileDetails &sb) {
			printf("set_sb() not implemented!\n");
			ROSE_ASSERT(false);
		}

		// DQ (8/26/2008): Added support for alternative section selection for use in disassembler.
		SgAsmGenericSection* get_best_possible_section_by_va(addr_t va);

	private:
		void ctor();
		mutable ExtentMap *p_unreferenced_cache;
		DataConverter *p_data_converter;
HEADER_GENERIC_FILE_END



HEADER_GENERIC_FORMAT_START
	public:
		void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_GENERIC_FORMAT_END



HEADER_GENERIC_DLL_START
	public:
		explicit SgAsmGenericDLL(SgAsmGenericString *s);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_symbol(const std::string &s) 			/* Add a needed symbol to the import list for this DLL */
			{p_symbols.push_back(s);}

		/* Override ROSETTA accessors */
		SgAsmGenericString *get_name() const;
		void set_name(SgAsmGenericString *s);
HEADER_GENERIC_DLL_END



HEADER_GENERIC_DLL_LIST_START
HEADER_GENERIC_DLL_LIST_END



HEADER_GENERIC_SYMBOL_START
	public:
		enum SymbolDefState {
			SYM_UNDEFINED,		/* Symbol has not been defined yet */
			SYM_TENTATIVE,          /* Does not have size/value yet (uninitialized C or Fortran common blks) */
			SYM_DEFINED             /* Created and assigned storage */
		};

		enum SymbolType {
			SYM_NO_TYPE,            /* No type or type is unknown */
			SYM_DATA,               /* Normal variable definitions */
			SYM_FUNC,               /* Function or other code */
			SYM_SECTION,            /* Section of a file */
			SYM_FILE,               /* Name of a file */
			SYM_ARRAY,              /* Array of some other type */
			SYM_TLS,                /* Thread-local storage */
			SYM_REGISTER,           /* CPU register value (see Sparc) */
			SYM_COMMON		/* Common block */
		};

		enum SymbolBinding {
			SYM_NO_BINDING,         /* Unknown binding */
			SYM_LOCAL,
			SYM_GLOBAL,
			SYM_WEAK
		};


		SgAsmGenericSymbol()
			: p_def_state(SYM_UNDEFINED), p_binding(SYM_NO_BINDING), p_type(SYM_NO_TYPE), p_value(0), p_size(0),
			p_bound(NULL), p_name(NULL)
			{ctor();}

		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string stringifyDefState() const;
		std::string stringifyType() const;
		std::string stringifyBinding() const;

		// Accessors
		SgAsmGenericString *get_name() const; // same as ROSETTA-generated version
		void set_name(SgAsmGenericString *s); // also sets s.parent
	private:
		void ctor();
HEADER_GENERIC_SYMBOL_END



HEADER_GENERIC_SYMBOL_LIST_START
HEADER_GENERIC_SYMBOL_LIST_END



HEADER_BASIC_STRING_START
	public:
		//SgAsmBasicString() {ctor();}
		explicit SgAsmBasicString(const std::string &s)
			: p_string(s) {ctor();}
		explicit SgAsmBasicString(const char *s)
			: p_string(s) {ctor();}
		// virtual ~SgAsmBasicString() {}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual std::string get_string() const;
		virtual void set_string(const std::string&);
		virtual void set_string(addr_t);
	private:
		void ctor();
HEADER_BASIC_STRING_END



HEADER_GENERIC_STRING_START
	public:
		//virtual ~SgAsmGenericString() {};
		static const rose_addr_t unallocated = ~(rose_addr_t)0;

		// These aren't the ROSETTA-generated versions because they hook into string table allocation functions
		virtual std::string get_string() const;
		virtual void set_string(const std::string &s);
		virtual void set_string(addr_t);
		virtual rose_addr_t get_offset() const {return unallocated;}
		const char *c_str() const;

		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_GENERIC_STRING_END



HEADER_STRING_STORAGE_START
     public:
          SgAsmStringStorage(SgAsmGenericStrtab *strtab, const std::string &string, rose_addr_t offset)
             : p_strtab(strtab), p_string(string), p_offset(offset) {}
          void dump(FILE *s, const char *prefix, ssize_t idx) const;

       /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are used
        * to control string allocation in ELF string tables and must only be modified by allocators in closely related classes.
        * For instance, to change the value of the string one should call SgAsmGenericString::set_string() instead. */

#if 0
       // Let the access function generated by ROSETTA be used.
	  SgAsmElfStrtab* get_strtab() const {
	       return p_strtab;
	     }
	  const std::string& get_string() const {             /*read-only; set string with SgAsmGenericString::set_string()*/
	       return p_string;
	     }
	  const rose_addr_t get_offset() const {              /*read-only; set only by the string table allocator*/
	       return p_offset;                               /*does not trigger reallocation; cf. SgAsmStoredString::get_offset()*/
	     }
#endif

     private:
          friend class SgAsmStoredString;                     /*allowed to set private data members*/
          friend class SgAsmStoredStrtab;                     /*allowed to set private data members*/
#if 0
       // Let the access function generated by ROSETTA be used.
          void set_string(const std::string &s) {
               p_string = s;
             }
          void set_strtab(SgAsmElfStrtab *strtab) {
               p_strtab = strtab;
             }
          void set_offset(rose_addr_t offset) {
               p_offset = offset;
             }
          SgAsmStringStorage() {abort();}                    /*no default constructor; cf. SgAsmStoredString::create_storage()*/
#endif

HEADER_STRING_STORAGE_END

HEADER_GENERIC_STRTAB_START
	public:
		explicit SgAsmGenericStrtab(SgAsmGenericSection *container)
			: p_container(container), p_dont_free(0), p_num_freed(0) {}
		virtual ~SgAsmGenericStrtab() {}
		virtual SgAsmGenericStrtab* parse() {return this;}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmStoredString *create_string(addr_t offset, bool shared);
		void free(SgAsmStringStorage*);
		void free(addr_t offset, addr_t size); /*mark part of table as free*/
		void free_all_strings(bool blow_away_holes=false);
		virtual void allocate_overlap(SgAsmStringStorage*) {};
		bool reallocate(bool shrink); /*allocate storage for all unallocated strings*/

		/* Free list accessors. Overriding ROSETTA because get_freelist() must return a modifiable free list. */
		const ExtentMap& get_freelist() const;
		ExtentMap& get_freelist();

		//These should be pure virtual but ROSETTA apparently doesn't support that (RPM 2008-10-03)
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared) {abort(); return NULL;}
		virtual addr_t get_storage_size(const SgAsmStringStorage*) {abort(); return 0;}
		virtual void rebind(SgAsmStringStorage*, addr_t) {abort();}
		typedef std::vector<class SgAsmStringStorage*> referenced_t;
	private:
		void ctor();
HEADER_GENERIC_STRTAB_END

// ***********************************************
//          ELF Binary File Format Support
// ***********************************************

HEADER_ELF_HEADER_START
	public:
		/** enum used for e_type */ 
		enum ObjectType { 
			 ET_NONE         = 0 		/** No file type */
			,ET_REL          = 1 		/** Relocatable file */
			,ET_EXEC         = 2 		/** Executable file */
			,ET_DYN          = 3 		/** Shared object file */
			,ET_CORE         = 4 		/** Core file */

			,ET_LOOS         = 0xfe00	/** OS-specific range start */
			,ET_HIOS         = 0xfeff	/** OS-specific range end */
			,ET_LOPROC       = 0xff00	/** Processor-specific range start */
			,ET_HIPROC       = 0xff00	/** Processor-specific range end */
		};


		/* File format of an ELF header. Byte order of members depends on e_ident value. This code comes directly from
		 * "System V Application Binary Interface, Edition 4.1" and the FreeBSD elf(5) man page, and the "Executable and
		 * Linkable Format (ELF) Portable Formats Specifications, Version 1.2" and not from any header file. */

/* Some structures are used to represent certain things whose layout is very precise in binary files, thus we need to make
 * sure the compiler doesn't insert alignment padding between the struct members.  ROSE can be compiled on an architecture
 * that has different alignment constraints than the architecture that these structs describe. GNU compilers have long used
 * the attribute mechanism. Microsoft compilers on the other hand use pragmas. GCC versions 4.0 and earlier do not recognize
 * the Microsoft pragmas and issue compiler errors when one is encountered. */
#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct Elf32FileHeader_disk {
			unsigned char       e_ident_magic[4];       /* 0x7f, 'E', 'L', 'F' */
			unsigned char       e_ident_file_class;     /* 1=>32-bit; 2=>64-bit; other is error */
			unsigned char       e_ident_data_encoding;  /* 1=>LSB; 2=>MSB; other is error */
			unsigned char       e_ident_file_version;   /* Format version number (same as e_version); must be 1 */
			unsigned char       e_ident_padding[9];     /* padding to byte 16; must be zero */
			uint16_t            e_type;                 /* object file type: relocatable, executable, lib, core */
			uint16_t            e_machine;              /* required architecture for an individual file */
			uint32_t            e_version;              /* object file version, currently zero or one */
			uint32_t            e_entry;                /* entry virtual address or zero if none */
			uint32_t            e_phoff;                /* file offset of program header table or zero if none */
			uint32_t            e_shoff;                /* file offset of section header table or zero if none */
			uint32_t            e_flags;                /* processor-specific flags (EF_* constants in docs) */
			uint16_t            e_ehsize;               /* size of ELF header in bytes */
			uint16_t            e_phentsize;            /* size of each entry in the program header table */
			uint16_t            e_phnum;                /* number of program headers, or PN_XNUM, or zero */
			uint16_t            e_shentsize;            /* size of each entry in the section header table */
			uint16_t            e_shnum;                /* number of section headers, or zero for extended entries */
			uint16_t            e_shstrndx;             /* index of name section, or SHN_UNDEF, or SHN_XINDEX */
		}
#ifndef _MSC_VER
		 __attribute__((packed))
#endif
		;

		struct Elf64FileHeader_disk {
			unsigned char       e_ident_magic[4];
			unsigned char       e_ident_file_class;
			unsigned char       e_ident_data_encoding;
			unsigned char       e_ident_file_version;
			unsigned char       e_ident_padding[9];
			uint16_t            e_type;
			uint16_t            e_machine;
			uint32_t            e_version;
			uint64_t            e_entry;
			uint64_t            e_phoff;
			uint64_t            e_shoff;
			uint32_t            e_flags;
			uint16_t            e_ehsize;
			uint16_t            e_phentsize;
			uint16_t            e_phnum;
			uint16_t            e_shentsize;
			uint16_t            e_shnum;
			uint16_t            e_shstrndx;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
	        ;
#ifdef _MSC_VER
# pragma pack ()
#endif

		/* Non-parsing constructor */
		explicit SgAsmElfFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f) , p_e_ident_file_class(0), p_e_ident_file_version(1), p_e_type(0),
			p_e_machine(0), p_e_flags(0), p_e_ehsize(0), p_phextrasz(0), p_e_phnum(0), p_shextrasz(0),
			p_e_shnum(0), p_e_shstrndx(0), p_section_table(NULL), p_segment_table(NULL)
			{ctor();}

		uint64_t max_page_size();
		SgAsmExecutableFileFormat::InsSetArchitecture machine_to_isa(unsigned machine) const;
		unsigned isa_to_machine(SgAsmExecutableFileFormat::InsSetArchitecture isa) const;

		virtual SgAsmElfFileHeader *parse();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

		virtual const char *format_name() const;
		static bool is_ELF(SgAsmGenericFile*);
		SgAsmGenericSectionPtrList get_sectab_sections();
		SgAsmGenericSectionPtrList get_segtab_sections();

	private:
		void ctor();
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf32FileHeader_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfFileHeader::Elf64FileHeader_disk*) const;
HEADER_ELF_HEADER_END



HEADER_ELF_SECTION_TABLE_START
	public:
		explicit SgAsmElfSectionTable(SgAsmElfFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
		virtual SgAsmElfSectionTable *parse();
		SgAsmElfSectionTableEntry *add_section(SgAsmElfSection*);
		rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();    
HEADER_ELF_SECTION_TABLE_END



HEADER_ELF_SECTION_TABLE_ENTRY_START
	public:
		/** Section types (host order). All other values are reserved. */
		enum SectionType {
			SHT_NULL        = 0,            /**< Section header is inactive */
			SHT_PROGBITS	= 1,            /**< Info defined by the program; format and meaning determined by prog */
			SHT_SYMTAB      = 2,            /**< Complete symbol table */
			SHT_STRTAB      = 3,            /**< String table */
			SHT_RELA        = 4,            /**< Relocation entries with explicit addends (e.g., Elf32_Rela types) */
			SHT_HASH        = 5,            /**< Symbol hash table (used by dynamic linking) */
			SHT_DYNAMIC     = 6,            /**< Information for dynamic linking */
			SHT_NOTE        = 7,            /**< Information that marks the file in some way */
			SHT_NOBITS      = 8,            /**< Like SHT_PROGBITS but occupies no file space */
			SHT_REL         = 9,            /**< Relocation entries without explicit addends (e.g., Elf32_Rel types) */
			SHT_SHLIB       = 10,           /**< Reserved, unspecified semantics; Present only in non-conforming files */
			SHT_DYNSYM      = 11,           /**< Minimal set of dynamic linking symbols */

			SHT_LOOS        = 0x60000000,   /**< OS specific semantics */
			SHT_GNU_verdef  = 0x6ffffffd,   /**< Symbol Version Definitions [gnu extension] .gnu.version_d */
			SHT_GNU_verneed = 0x6ffffffe,   /**< Symbol Version Requirements [gnu extension] .gnu.version_r */
			SHT_GNU_versym  = 0x6fffffff,   /**< Symbol Version Table [gnu extension] .gnu.version */
			SHT_HIOS        = 0x6fffffff,   /**< End OS specific semantics */

			SHT_LOPROC      = 0x70000000,	/* Processor specific semantics */
			SHT_HIPROC      = 0x7fffffff,
			SHT_LOUSER      = 0x80000000,   /* Application specific semantics */
			SHT_HIUSER      = 0xffffffff
		};

		/** Section Flags (host order).  All other values are reserved. */
		enum SectionFlags {
			SHF_NULL=		   0,	/** Invalid section flag (added for rose) */
			SHF_WRITE=	     (1 << 0),	/** Writable */
			SHF_ALLOC=	     (1 << 1),	/** Occupies memory during execution */
			SHF_EXECINSTR=	     (1 << 2),	/** Executable */
			SHF_MERGE=	     (1 << 4),	/** Might be merged */
			SHF_STRINGS=	     (1 << 5),	/** Contains nul-terminated strings */
			SHF_INFO_LINK=	     (1 << 6),	/** `sh_info' contains SHT index */
			SHF_LINK_ORDER=	     (1 << 7),	/** Preserve order after combining */
			SHF_OS_NONCONFORMING=(1 << 8),	/** Non-standard OS specific handling required */
			SHF_GROUP=	     (1 << 9),	/** Section is member of a group.  */
			SHF_TLS=	     (1 << 10),	/** Section hold thread-local data.  */
			SHF_MASKOS=	     0x0ff00000,/** OS-specific.  */
			SHF_MASKPROC=	     0xf0000000	/** Processor-specific */
		};

		/** File format of an ELF Section header. Byte order of members depends on e_ident value in file header. This code
		 * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
                 * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux
                 * elf(5) man page. */
#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct Elf32SectionTableEntry_disk {
			uint32_t	sh_name;	/* 0x00 Section name; index into section header string table */
			uint32_t        sh_type;        /* 0x04 Section contents and semantics (see SectionType enum) */
			uint32_t        sh_flags;       /* 0x08 Bit flags */
			uint32_t        sh_addr;        /* 0x0c Desired mapped address */
			uint32_t        sh_offset;      /* 0x10 Section location in file unless sh_type==SHT_NOBITS */
			uint32_t        sh_size;        /* 0x14 Section size in bytes */
			uint32_t        sh_link;        /* 0x18 Section ID of another section; meaning depends on section type */
			uint32_t        sh_info;        /* 0x1c Extra info depending on section type */
			uint32_t        sh_addralign;   /* 0x20 Mapped alignment (0 and 1=>byte aligned); sh_addr must be aligned*/
			uint32_t        sh_entsize;     /* 0x24 If non-zero, size in bytes of each array member in the section */
		}              				/* 0x28 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf64SectionTableEntry_disk {
			uint32_t	sh_name;	/* 0x00 see Elf32SectionTableEntry_disk */
			uint32_t        sh_type;	/* 0x04 */
			uint64_t        sh_flags;	/* 0x08 */
			uint64_t        sh_addr;	/* 0x10 */
			uint64_t        sh_offset;	/* 0x18 */
			uint64_t        sh_size;	/* 0x20 */
			uint32_t        sh_link;	/* 0x28 */
			uint32_t        sh_info;	/* 0x2c */
			uint64_t        sh_addralign;	/* 0x30 */
			uint64_t        sh_entsize;	/* 0x38 */
		}					/* 0x40 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);
		SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);
		void *encode(SgAsmExecutableFileFormat::ByteOrder sex,
			SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder sex,
			SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk) const;
		void update_from_section(SgAsmElfSection*);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		static std::string to_string(SgAsmElfSectionTableEntry::SectionType);
		static std::string to_string(SgAsmElfSectionTableEntry::SectionFlags);
	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk*);
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk*);
HEADER_ELF_SECTION_TABLE_ENTRY_END



HEADER_ELF_SECTION_START
	public:
		explicit SgAsmElfSection(SgAsmGenericHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr),
			p_linked_section(NULL), p_section_entry(NULL), p_segment_entry(NULL)
			{ctor();}

		SgAsmElfSection *init_from_section_table(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int id);
		SgAsmElfSection *init_from_segment_table(SgAsmElfSegmentTableEntry*, bool mmap_only=false);
		rose_addr_t calculate_sizes(size_t r32size, size_t r64size, const std::vector<size_t> &optsizes,
					    size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual void finish_parsing() {}
		virtual rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void allocate_name_to_storage(SgAsmElfStringSection*);

		/* Convenience functions */
		SgAsmElfFileHeader *get_elf_header() const;

		// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
		SgAsmElfSection* get_linked_section () const;
		virtual void set_linked_section(SgAsmElfSection*);
	private:
		void ctor();
HEADER_ELF_SECTION_END



HEADER_STORED_STRING_START
	public:
		SgAsmStoredString(SgAsmGenericStrtab *strtab, rose_addr_t offset)	/*string in string table*/
			{ctor(strtab, offset, false);}
		SgAsmStoredString(SgAsmGenericStrtab *strtab, const std::string &s)	/*new string in string table*/
			{ctor(strtab, s);}
		explicit SgAsmStoredString(class SgAsmStringStorage *storage)		/*string shares other storage*/
			{ctor(storage);}
		// virtual ~SgAsmStoredString();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmGenericStrtab *get_strtab();					/*table holding the string*/

		// These are not access functions -- they do more than just getting or setting the value!
		virtual std::string get_string() const;
		virtual void set_string(const std::string&);				/*also deallocates previous value*/
		virtual void set_string(addr_t);					/*rebinds to a new value*/
		virtual rose_addr_t get_offset() const;					/*also triggers realloc*/
	private:
		// Maybe we need to supressed ROSETTA generated constructor!
		// SgAsmStoredString() {abort();}
		void ctor(class SgAsmGenericStrtab*, rose_addr_t offset, bool shared);
		void ctor(class SgAsmGenericStrtab*, const std::string&);
		void ctor(class SgAsmStringStorage*);
		void ctor(const std::string &s);

HEADER_STORED_STRING_END



HEADER_ELF_STRING_TABLE_START
	public:
		explicit SgAsmElfStrtab(class SgAsmElfSection *containing_section)
			: SgAsmGenericStrtab(containing_section)
			{ctor();}
		virtual ~SgAsmElfStrtab();
		virtual SgAsmElfStrtab *parse();
		virtual void unparse(std::ostream&) const;
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared);
		virtual addr_t get_storage_size(const SgAsmStringStorage*);
		virtual void allocate_overlap(SgAsmStringStorage*);
		virtual void rebind(SgAsmStringStorage*, addr_t);
	private:
		void ctor();
HEADER_ELF_STRING_TABLE_END



HEADER_ELF_STRING_SECTION_START
	public:
		explicit SgAsmElfStringSection(SgAsmElfFileHeader *fhdr);
		virtual SgAsmElfStringSection *parse();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual void set_size(addr_t newsize);
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
	private:
		void ctor();
		void ctor(SgAsmElfSectionTable*);
HEADER_ELF_STRING_SECTION_END



HEADER_ELF_RELOC_SECTION_START
	public:
		SgAsmElfRelocSection(SgAsmElfFileHeader *fhdr, SgAsmElfSymbolSection *symsec,SgAsmElfSection* targetsec)
			: SgAsmElfSection(fhdr)
			{ctor(symsec,targetsec);}
		using SgAsmElfSection::calculate_sizes;
		virtual SgAsmElfRelocSection *parse();
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

	private:
		void ctor(SgAsmElfSymbolSection*,SgAsmElfSection*);
HEADER_ELF_RELOC_SECTION_END



HEADER_ELF_RELOC_ENTRY_START
	public:
		/** Relocation Type (host order).  All other values are reserved. */
		enum RelocType{
			/** Intel 80386 specific definitions.  */
			R_386_NONE	   =0,		/**< No reloc */
			R_386_32	   =1,		/**< Direct 32 bit  */
			R_386_PC32	   =2,		/**< PC relative 32 bit */
			R_386_GOT32	   =3,		/**< 32 bit GOT entry */
			R_386_PLT32	   =4,		/**< 32 bit PLT address */
			R_386_COPY	   =5,		/**< Copy symbol at runtime */
			R_386_GLOB_DAT	   =6,		/**< Create GOT entry */
			R_386_JMP_SLOT	   =7,		/**< Create PLT entry */
			R_386_RELATIVE	   =8,		/**< Adjust by program base */
			R_386_GOTOFF	   =9,		/**< 32 bit offset to GOT */
			R_386_GOTPC	   =10,		/**< 32 bit PC relative offset to GOT */
			R_386_32PLT	   =11,
			R_386_TLS_TPOFF    =14,		/**< Offset in static TLS block */
			R_386_TLS_IE       =15,		/**< Address of GOT entry for static TLS block offset */
			R_386_TLS_GOTIE    =16,		/**< GOT entry for static TLS block offset */
			R_386_TLS_LE	   =17,		/**< Offset relative to static TLS block */
			R_386_TLS_GD	   =18,		/**< Direct 32 bit for GNU version of general dynamic thread local data */
			R_386_TLS_LDM	   =19,		/**< Direct 32 bit for GNU version of local dynamic thread local data in LE code */
			R_386_16	   =20,
			R_386_PC16	   =21,
			R_386_8	           =22,
			R_386_PC8	   =23,
			R_386_TLS_GD_32    =24,		/**< Direct 32 bit for general dynamic thread local data */
			R_386_TLS_GD_PUSH  =25,		/**< Tag for pushl in GD TLS code */
			R_386_TLS_GD_CALL  =26,		/**< Relocation for call to __tls_get_addr() */
			R_386_TLS_GD_POP   =27,		/**< Tag for popl in GD TLS code */
			R_386_TLS_LDM_32   =28,		/**< Direct 32 bit for local dynamic thread local data in LE code */
			R_386_TLS_LDM_PUSH =29,		/**< Tag for pushl in LDM TLS code */
			R_386_TLS_LDM_CALL =30,		/**< Relocation for call to __tls_get_addr() in LDM code */
			R_386_TLS_LDM_POP  =31,		/**< Tag for popl in LDM TLS code */
			R_386_TLS_LDO_32   =32,		/**< Offset relative to TLS block */
			R_386_TLS_IE_32    =33,		/**< GOT entry for negated static TLS block offset */
			R_386_TLS_LE_32    =34,		/**< Negated offset relative to static TLS block */
			R_386_TLS_DTPMOD32 =35,		/**< ID of module containing symbol */
			R_386_TLS_DTPOFF32 =36,		/**< Offset in TLS block */
			R_386_TLS_TPOFF32  =37,		/**< Negated offset in static TLS block */
			/* This the last entry for x86  */
			R_386_NUM	   =38,

	                /** First Entry for X86-64 */
			R_X86_64_NONE     =0,		/**<  No reloc */
			R_X86_64_64       =1,		/**<  Direct 64 bit  */
			R_X86_64_PC32     =2,		/**<  PC relative 32 bit signed */
			R_X86_64_GOT32    =3,		/**<  32 bit GOT entry */
			R_X86_64_PLT32    =4,		/**<  32 bit PLT address */
			R_X86_64_COPY     =5,		/**<  Copy symbol at runtime */
			R_X86_64_GLOB_DAT =6,		/**<  Create GOT entry */
			R_X86_64_JUMP_SLOT=7,		/**<  Create PLT entry */
			R_X86_64_RELATIVE =8,		/**<  Adjust by program base */
			R_X86_64_GOTPCREL =9,		/**<  32 bit signed PC relative offset to GOT */
			R_X86_64_32       =10,		/**<  Direct 32 bit zero extended */
			R_X86_64_32S      =11,		/**<  Direct 32 bit sign extended */
			R_X86_64_16       =12,		/**<  Direct 16 bit zero extended */
			R_X86_64_PC16     =13,		/**<  16 bit sign extended pc relative */
			R_X86_64_8        =14,		/**<  Direct 8 bit sign extended  */
			R_X86_64_PC8      =15,		/**<  8 bit sign extended pc relative */
			R_X86_64_DTPMOD64 =16,		/**<  ID of module containing symbol */
			R_X86_64_DTPOFF64 =17,		/**<  Offset in module's TLS block */
			R_X86_64_TPOFF64  =18,		/**<  Offset in initial TLS block */
			R_X86_64_TLSGD    =19,		/**<  32 bit signed PC relative offset to two GOT entries for GD symbol */
			R_X86_64_TLSLD    =20,		/**<  32 bit signed PC relative offset to two GOT entries for LD symbol */
			R_X86_64_DTPOFF32 =21,		/**<  Offset in TLS block */
			R_X86_64_GOTTPOFF =22,		/**<  32 bit signed PC relative offset to GOT entry for IE symbol */
			R_X86_64_TPOFF32  =23,		/**<  Offset in initial TLS block */

			R_X86_64_NUM      =24
		};

#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct Elf32RelaEntry_disk {
			uint32_t	r_offset;
			uint32_t	r_info;
			uint32_t	r_addend;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
		struct Elf64RelaEntry_disk {
			uint64_t	r_offset;
			uint64_t	r_info;
			uint64_t	r_addend;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf32RelEntry_disk {
			uint32_t	r_offset;
			uint32_t	r_info;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf64RelEntry_disk {
			uint64_t	r_offset;
			uint64_t	r_info;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		SgAsmElfRelocEntry(SgAsmElfRelocSection *section)
			: p_r_offset(0), p_r_addend(0), p_sym(0), p_type(R_386_NONE)
			{ctor(section);}

		void parse(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelocEntry::Elf32RelaEntry_disk *disk);
		void parse(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelocEntry::Elf64RelaEntry_disk *disk);
		void parse(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelocEntry::Elf32RelEntry_disk *disk);
		void parse(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfRelocEntry::Elf64RelEntry_disk *disk);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelocEntry::Elf32RelaEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelocEntry::Elf64RelaEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelocEntry::Elf32RelEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfRelocEntry::Elf64RelEntry_disk*) const;

		void dump(FILE *f, const char *prefix, ssize_t idx, SgAsmElfSymbolSection *symtab) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const
			{dump(f, prefix, idx, NULL);}
		std::string reloc_name() const;
	private:
		void ctor(SgAsmElfRelocSection*);

HEADER_ELF_RELOC_ENTRY_END



HEADER_ELF_DYNAMIC_SECTION_START
	public:
		SgAsmElfDynamicSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec)
			: SgAsmElfSection(fhdr)
			{ctor(strsec);}
		virtual SgAsmElfDynamicSection* parse();
		virtual void finish_parsing();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfStringSection*);
HEADER_ELF_DYNAMIC_SECTION_END



HEADER_ELF_DYNAMIC_ENTRY_START
	public:
		enum EntryType {                /* Type    Executable SharedObj Purpose */
			DT_NULL     = 0,        /* ignored mandatory  mandatory Marks end of dynamic array */
			DT_NEEDED   = 1,      	/* value   optional   optional  Name of needed library */
			DT_PLTRELSZ = 2,    	/* value   optional   optional  Size of reloc entries associated with PLT */
			DT_PLTGOT   = 3,    	/* pointer optional   optional  PLT and/or GOT */
			DT_HASH     = 4,    	/* pointer mandatory  mandatory Symbol hash table */
			DT_STRTAB   = 5,    	/* pointer mandatory  mandatory String table for symbols, lib names, etc. */
			DT_SYMTAB   = 6,    	/* pointer mandatory  mandatory Symbol table */
			DT_RELA     = 7,    	/* pointer mandatory  optional  Relocation table */
			DT_RELASZ   = 8,    	/* value   mandatory  optional  Size of RELA relocation table */
			DT_RELAENT  = 9,    	/* value   mandatory  optional  Size of each RELA table entry */
			DT_STRSZ    = 10,   	/* value   mandatory  mandatory Size of string table */
			DT_SYMENT   = 11,   	/* value   mandatory  mandatory Size of symbol table entry */
			DT_INIT     = 12,   	/* pointer optional   optional  Initialization function */
			DT_FINI     = 13,   	/* pointer optional   optional  Termination function */
			DT_SONAME   = 14,   	/* value   ignored    optional  Name of shared object */
			DT_RPATH    = 15,   	/* value   optional   ignored   NUL-term library search path */
			DT_SYMBOLIC = 16,   	/* ignored ignored    optional  Bool determines dynamic linker symbol resolution */
			DT_REL      = 17,   	/* pointer mandatory  optional  Relocation table */
			DT_RELSZ    = 18,   	/* value   mandatory  optional  Size of REL relocation table */
			DT_RELENT   = 19,   	/* value   mandatory  optional  Size of each REL table entry */
			DT_PLTREL   = 20,   	/* value   optional   optional  Reloc type for PLT; value is DT_RELA or DT_REL */
			DT_DEBUG    = 21,   	/* pointer optional   ignored   Contents are not specified at ABI level */
			DT_TEXTREL  = 22,   	/* ignored optional   optional  presence => relocs to nonwritable segments OK */
			DT_JMPREL   = 23,   	/* pointer optional   optional  Addr of relocation entries for PLT */
			DT_BIND_NOW = 24,   	/* ignored optional   optional  Shall dynlinker do relocs before xfering control?*/
			DT_INIT_ARRAY = 25,     /* pointer optional   ?         Array with addresses of init fct */
			DT_FINI_ARRAY = 26,     /* pointer optional   ?         Array with address of fini fct */
			DT_INIT_ARRAYSZ = 27,   /* value   optional   ?         Size in bytes of DT_INIT_ARRAY */
			DT_FINI_ARRAYSZ = 28,   /* value   optional   ?         Size in bytes of DT_FINI_ARRAY */
			DT_RUNPATH  = 29,       /* ?       optional   ?         Library search path (how diff from DT_RPATH?) */
			DT_FLAGS    = 30,       /* value   optional   ?         Bit flags */
			DT_PREINIT_ARRAY = 32,  /* pointer optional   ?         Array with addrs of preinit fct (aka DT_ENCODING)*/
			DT_PREINIT_ARRAYSZ = 33,/* value   optional   ?         size in bytes of DT_PREINIT_ARRAY */
			DT_NUM      = 34,       /* ?       ?          ?         "number used"? */

			DT_GNU_PRELINKED =0x6ffffdf5,/*value ?          ?         Prelinking time stamp */
			DT_GNU_CONFLICTSZ=0x6ffffdf6,/*value ?          ?         Size of conflict section */
			DT_GNU_LIBLISTSZ=0x6ffffdf7,/*value  ?          ?         Size of library list */
			DT_CHECKSUM = 0x6ffffdf8, /* value   ?          ?         ? */
			DT_PLTPADSZ = 0x6ffffdf9, /* value   ?          ?         ? */
			DT_MOVEENT  = 0x6ffffdfa, /* value   ?          ?         ? */
			DT_MOVESZ   = 0x6ffffdfb, /* value   ?          ?         ? */
			DT_FEATURE_1= 0x6ffffdfc, /* value   ?          ?         Feature selection (DTF_*) */
			DT_POSFLAG_1= 0x6ffffdfd, /* value   ?          ?         Flag for DT_* entries affecting next entry */
			DT_SYMINSZ  = 0x6ffffdfe, /* value   ?          ?         Size of syminfo table in bytes */
			DT_SYMINENT = 0x6ffffdff, /* value   ?          ?         Size of each syminfo table entry */

			DT_GNU_HASH = 0x6ffffef5, /* pointer ?          ?         GNU-style hash table */
			DT_TLSDESC_PLT=0x6ffffef6,/* pointer ?          ?         ? */
			DT_TLSDESC_GOT=0x6ffffef7,/* pointer ?          ?         ? */
			DT_GNU_CONFLICT=0x6ffffef8,/*pointer ?          ?         Start of conflict section */
			DT_GNU_LIBLIST=0x6ffffef9,/* pointer ?          ?         Library list */
			DT_CONFIG   = 0x6ffffefa, /* pointer ?          ?         Configuration information */
			DT_DEPAUDIT = 0x6ffffefb, /* pointer ?          ?         Dependency auditing */
			DT_AUDIT    = 0x6ffffefc, /* pointer ?          ?         Object auditing */
			DT_PLTPAD   = 0x6ffffefd, /* pointer ?          ?         PLT padding */
			DT_MOVETAB  = 0x6ffffefe, /* pointer ?          ?         Move table */
			DT_SYMINFO  = 0x6ffffeff, /* pointer ?          ?         Syminfo table */

			DT_VERSYM   = 0x6ffffff0, /* pointer ?          ?         ? */
			DT_RELACOUNT= 0x6ffffff9, /* value   ?          ?         ? */
			DT_RELCOUNT = 0x6ffffffa, /* value   ?          ?         ? */
			DT_FLAGS_1  = 0x6ffffffb, /* value   ?          ?         Sun state flags */
			DT_VERDEF   = 0x6ffffffc, /* pointer ?          ?         Sun version definition table */
			DT_VERDEFNUM= 0x6ffffffd, /* value   ?          ?         Sun number of version definitions */
			DT_VERNEED  = 0x6ffffffe, /* pointer ?          ?         Sun needed versions table */
			DT_VERNEEDNUM=0x6fffffff, /* value   ?          ?         Sun number of needed versions */

			DT_AUXILIARY= 0x7ffffffd, /* pointer ?          ?         Sun shared obj to load before self */
			DT_FILTER   = 0x7fffffff, /* pointer ?          ?         Shared object ot get values from */
		};

#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct Elf32DynamicEntry_disk {
			uint32_t            d_tag;  /* Entry type, one of the DT_* constants */
			uint32_t            d_val;  /* Tag's value */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf64DynamicEntry_disk {
			uint64_t            d_tag;  /* Entry type, one of the DT_* constants */
			uint64_t            d_val;  /* Tag's value */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif
		explicit SgAsmElfDynamicEntry(SgAsmElfDynamicSection *dynsec)
			: p_d_tag(DT_NULL), p_name(NULL)
			{ctor(dynsec);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*);
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

	        static std::string to_string(SgAsmElfDynamicEntry::EntryType);
		/*Override ROSETTA because set_name() needs to adjust parent pointer*/
		SgAsmGenericString *get_name() const {return p_name;}
		void set_name(SgAsmGenericString *name);
	private:
		void ctor(SgAsmElfDynamicSection*);
HEADER_ELF_DYNAMIC_ENTRY_END



HEADER_ELF_NOTE_SECTION_START
	public:
		explicit SgAsmElfNoteSection(SgAsmElfFileHeader *fhdr)
			: SgAsmElfSection(fhdr)
			{ctor();}
		virtual SgAsmElfNoteSection *parse();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_NOTE_SECTION_END



HEADER_ELF_NOTE_ENTRY_START
	public:
		SgAsmElfNoteEntry(SgAsmElfNoteSection *section)
			: p_type(0), p_name(NULL)
			{ctor(section);}
		rose_addr_t parse(rose_addr_t starting_offset);
		rose_addr_t unparse(std::ostream &f, rose_addr_t starting_offset);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmGenericString *get_name() const;
		void set_name(SgAsmGenericString *name);
		void set_payload(const void*, size_t nbytes);
		rose_addr_t calculate_size() const;
	private:
		void ctor(SgAsmElfNoteSection *section);
HEADER_ELF_NOTE_ENTRY_END



HEADER_ELF_EH_FRAME_SECTION_START
	public:
		explicit SgAsmElfEHFrameSection(SgAsmElfFileHeader *fhdr)
			: SgAsmElfSection(fhdr), p_ci_entries(NULL)
			{ctor();}
		virtual SgAsmElfEHFrameSection *parse();
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const;
		virtual void unparse(std::ostream&) const;
		addr_t unparse(std::ostream*) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_EH_FRAME_SECTION_END



HEADER_ELF_EH_FRAME_ENTRY_CI_START
	public:
		explicit SgAsmElfEHFrameEntryCI(SgAsmElfEHFrameSection *ehframe)
			: p_version(0), p_code_alignment_factor(0), p_data_alignment_factor(0), p_augmentation_data_length(0),
			p_lsda_encoding(-1), p_prh_encoding(-1), p_prh_arg(0), p_prh_addr(0), p_addr_encoding(-1),
			p_fd_entries(NULL)
			{ctor(ehframe);}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string unparse(const SgAsmElfEHFrameSection*) const;
	private:
		void ctor(SgAsmElfEHFrameSection*);
HEADER_ELF_EH_FRAME_ENTRY_CI_END



HEADER_ELF_EH_FRAME_ENTRY_FD_START
	public:
		explicit SgAsmElfEHFrameEntryFD(SgAsmElfEHFrameEntryCI *cie)
			: p_size(0)
			{ctor(cie);}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string unparse(const SgAsmElfEHFrameSection*, SgAsmElfEHFrameEntryCI*) const;
	private:
		void ctor(SgAsmElfEHFrameEntryCI*);
HEADER_ELF_EH_FRAME_ENTRY_FD_END



HEADER_ELF_SYMVER_SECTION_START
	public:
		explicit SgAsmElfSymverSection(SgAsmElfFileHeader *fhdr)
		        : SgAsmElfSection(fhdr)
			{ctor();}
		virtual SgAsmElfSymverSection* parse();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_SYMVER_SECTION_END


HEADER_ELF_SYMVER_ENTRY_START
	public:
		explicit SgAsmElfSymverEntry(SgAsmElfSymverSection *symver)
		        : p_value(0)
			{ctor(symver);}
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfSymverSection*);
HEADER_ELF_SYMVER_ENTRY_END


HEADER_ELF_SYMVER_DEFINED_SECTION_START
	public:
		SgAsmElfSymverDefinedSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec)
			: SgAsmElfSection(fhdr)
			{ctor(strsec);}
		virtual SgAsmElfSymverDefinedSection* parse();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfStringSection*);
HEADER_ELF_SYMVER_DEFINED_SECTION_END


HEADER_ELF_SYMVER_DEFINED_ENTRY_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/** Elfxx_Verdef, Note, same for 32bit and 64bit */
		struct ElfSymverDefinedEntry_disk { 
			uint16_t      vd_version;   /**< version of this struct: This field shall be set to 1 */
			uint16_t      vd_flags;     /**< Version information flag bitmask */
			uint16_t      vd_ndx;       /**< Version index of this entry */
			uint16_t      vd_cnt;       /**< Number of verdaux entries @see SgAsmElfSymverDefinedAux */
			uint32_t      vd_hash;      /**< Hash of version name */
			uint32_t      vd_aux;       /**< Offset (in bytes) to start of array of verdaux entries */
			uint32_t      vd_next;      /**< Offset (in bytes) to next verdef entry */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		explicit SgAsmElfSymverDefinedEntry(SgAsmElfSymverDefinedSection *symver_defined)
		  	{ctor(symver_defined);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfSymverDefinedSection*);
HEADER_ELF_SYMVER_DEFINED_ENTRY_END


HEADER_ELF_SYMVER_DEFINED_AUX_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/** Elfxx_Verdaux, Note: same for 32bit and 64bit */
		struct ElfSymverDefinedAux_disk { 
			uint32_t      vda_name;   /**< Offset (in bytes) to strings table to name string */
		        uint32_t      vda_next;   /**< Offset (in bytes) to next verdaux entry */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif


                explicit SgAsmElfSymverDefinedAux(SgAsmElfSymverDefinedEntry *symver_def_entry,
						  SgAsmElfSymverDefinedSection *symver_def_sec)
		        : p_name(NULL)
                        {ctor(symver_def_entry,symver_def_sec);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

	private:
	        void ctor(SgAsmElfSymverDefinedEntry*,SgAsmElfSymverDefinedSection *symver_def_sec);
HEADER_ELF_SYMVER_DEFINED_AUX_END


HEADER_ELF_SYMVER_NEEDED_SECTION_START
	public:
		 SgAsmElfSymverNeededSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec)
			: SgAsmElfSection(fhdr)
			{ctor(strsec);}
		virtual SgAsmElfSymverNeededSection* parse();
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfStringSection*);
HEADER_ELF_SYMVER_NEEDED_SECTION_END


HEADER_ELF_SYMVER_NEEDED_ENTRY_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/** Elfxx_Verneed, Note, same for 32bit and 64bit */
		struct ElfSymverNeededEntry_disk { 
			uint16_t      vn_version;  /**< version of this struct: This field shall be set to 1 */
			uint16_t      vn_cnt;      /**< Number of vernaux entries @see SgAsmElfSymverNeededAux */
			uint32_t      vn_file;     /**< Offset (in bytes) to strings table to file string */
			uint32_t      vn_aux;      /**< Offset (in bytes) to start of array of vernaux entries */
			uint32_t      vn_next;     /**< Offset (in bytes) to next verneed entry */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif


		explicit SgAsmElfSymverNeededEntry(SgAsmElfSymverNeededSection *symver_needed)
		        : p_file_name(NULL)
			{ctor(symver_needed);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

	private:
		void ctor(SgAsmElfSymverNeededSection*);
HEADER_ELF_SYMVER_NEEDED_ENTRY_END


HEADER_ELF_SYMVER_NEEDED_AUX_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/** Elfxx_Verdaux, Note: same for 32bit and 64bit */
		struct ElfSymverNeededAux_disk { 
			uint32_t      vna_hash;  /**< Hash of version name */
			uint16_t      vna_flags; /**< Version information flag bitmask */
			uint16_t      vna_other; /**< Version index of this entry (bit 15 is special) */
			uint32_t      vna_name;  /**< Offset (in bytes) to strings table to name string */
		        uint32_t      vna_next;  /**< Offset (in bytes) to next vernaux entry */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif


                SgAsmElfSymverNeededAux(SgAsmElfSymverNeededEntry *symver_needed_entry,
					SgAsmElfSymverNeededSection *symver_needed_sec)
		        : p_name(NULL)
                        {ctor(symver_needed_entry,symver_needed_sec);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

	private:
	        void ctor(SgAsmElfSymverNeededEntry*,SgAsmElfSymverNeededSection*);
HEADER_ELF_SYMVER_NEEDED_AUX_END


HEADER_ELF_SEGMENT_TABLE_START
	public:
		explicit SgAsmElfSegmentTable(SgAsmElfFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
		virtual SgAsmElfSegmentTable *parse();
		SgAsmElfSegmentTableEntry *add_section(SgAsmElfSection*);
		rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_ELF_SEGMENT_TABLE_END



HEADER_ELF_SEGMENT_TABLE_ENTRY_START
	public:

		/* Segment types (host order). All other values are reserved. */
		enum SegmentType {
			PT_NULL         = 0,            /* entry is ignored; other values of entry are undefined */
			PT_LOAD         = 1,            /* loadable by mapping file contents into memory */
			PT_DYNAMIC      = 2,            /* dynamic linking information */
			PT_INTERP       = 3,            /* segment contains NUL-terminated path name of interpreter */
			PT_NOTE         = 4,            /* auxiliary information */
			PT_SHLIB        = 5,            /* Reserved w/unspecified semantics; such a file is nonconforming */
			PT_PHDR         = 6,            /* Segment contains the segment table itself (program header array) */
			PT_TLS		= 7,		/* Thread local storage */

			/* OS- and Processor-specific ranges */
			PT_LOOS         = 0x60000000,   /* Values reserved for OS-specific semantics */
			PT_HIOS         = 0x6fffffff,
			PT_LOPROC       = 0x70000000,   /* Values reserved for processor-specific semantics */
			PT_HIPROC       = 0x7fffffff,

			/* OS-specific values for GNU/Linux */
			PT_GNU_EH_FRAME	= 0x6474e550,	/* GCC .eh_frame_hdr segment */
			PT_GNU_STACK    = 0x6474e551,   /* Indicates stack executability */
			PT_GNU_RELRO    = 0x6474e552,   /* Read-only after relocation */
			PT_PAX_FLAGS    = 0x65041580,   /* Indicates PaX flag markings */

			/* OS-specific values for Sun */
			PT_SUNWBSS      = 0x6ffffffa,   /* Sun Specific segment */
			PT_SUNWSTACK    = 0x6ffffffb    /* Stack segment */
		};

		/* Segment bit flags */
		enum SegmentFlags {
			PF_NONE		= 0,		/* Initial value in c'tor */
			PF_RESERVED     = 0x000ffff8,   /* Reserved bits */
			PF_XPERM        = 0x00000001,   /* Execute permission */
			PF_WPERM        = 0x00000002,   /* Write permission */
			PF_RPERM        = 0x00000004,   /* Read permission */
	                PF_OS_MASK      = 0x0ff00000,   /* os-specific bits */
			PF_PROC_MASK    = 0xf0000000    /* Processor-specific bits */
		};

#ifdef _MSC_VER
# pragma pack (1)
#endif
		/* File format of an ELF Segment header. Byte order of members depends on e_ident value in file header. This code
		 * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
		 * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5)
		 * man page. Segment table entries (a.k.a., ELF program headers) either describe process segments or give
		 * supplementary info which does not contribute to the process image. */
		struct Elf32SegmentTableEntry_disk {
			uint32_t	p_type;		/* 0x00 kind of segment */
			uint32_t        p_offset;       /* 0x04 file offset */
			uint32_t        p_vaddr;        /* 0x08 desired mapped address of segment */
			uint32_t        p_paddr;        /* 0x0c physical address where supported (unused by System V) */
			uint32_t        p_filesz;       /* 0x20 bytes in file (may be zero or other value smaller than p_memsz) */
			uint32_t        p_memsz;        /* 0x24 number of bytes when mapped (may be zero) */
			uint32_t        p_flags;	/* 0x28 */
			uint32_t        p_align;        /* 0x2c alignment for file and memory (0,1=>none); power of two */
		}              				/* 0x30 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf64SegmentTableEntry_disk {
			uint32_t        p_type;		/* 0x00 */
			uint32_t        p_flags;	/* 0x04 */
			uint64_t        p_offset;	/* 0x08 */
			uint64_t        p_vaddr;	/* 0x10 */
			uint64_t        p_paddr;	/* 0x18 */
			uint64_t        p_filesz;	/* 0x20 */
			uint64_t        p_memsz;	/* 0x28 */
			uint64_t        p_align;	/* 0x30 */
		}					/* 0x38 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif


		SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);
		SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex,
			const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);

		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*) const;
		void update_from_section(SgAsmElfSection*);
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		static std::string to_string(SgAsmElfSegmentTableEntry::SegmentType);
		static std::string to_string(SgAsmElfSegmentTableEntry::SegmentFlags);


	private:
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*);
		void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*);
HEADER_ELF_SEGMENT_TABLE_ENTRY_END



HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_START
HEADER_ELF_SEGMENT_TABLE_ENTRY_LIST_END



HEADER_ELF_SYMBOL_SECTION_START
	public:
		 SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec)
			: SgAsmElfSection(fhdr), p_is_dynamic(false)
			{ctor(strsec);}
		virtual SgAsmElfSymbolSection* parse();
		virtual void finish_parsing();
		size_t index_of(SgAsmElfSymbol*);
		using SgAsmElfSection::calculate_sizes;
		virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const;
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmElfStringSection*);
HEADER_ELF_SYMBOL_SECTION_END



HEADER_ELF_SYMBOL_LIST_START
HEADER_ELF_SYMBOL_LIST_END

HEADER_ELF_SYMBOL_START
	public:
		enum ElfSymBinding {
			STB_LOCAL=0,
			STB_GLOBAL=1,
			STB_WEAK=2
		};

		enum ElfSymType {
			STT_NOTYPE  	= 0,	/* unspecified type */
			STT_OBJECT  	= 1,	/* data object */
			STT_FUNC    	= 2,	/* code object */
			STT_SECTION 	= 3,	/* associated with a section */
			STT_FILE    	= 4,	/* name of a file */
			STT_COMMON  	= 5,	/* common data object */
			STT_TLS		= 6	/* thread-local data object */
		};

#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct Elf32SymbolEntry_disk {
			uint32_t      st_name;  /* Name offset into string table */
			uint32_t      st_value; /* Value: absolute value, address, etc. depending on sym type */
			uint32_t      st_size;  /* Symbol size in bytes */
			unsigned char st_info;  /* Type and binding attributes */
			unsigned char st_res1;  /* Reserved; always zero */
			uint16_t      st_shndx; /* Section index or special meaning */
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct Elf64SymbolEntry_disk {
			uint32_t      st_name;
			unsigned char st_info;
			unsigned char st_res1;
			uint16_t      st_shndx;
			uint64_t      st_value;
			uint64_t      st_size;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		explicit SgAsmElfSymbol(SgAsmElfSymbolSection *symtab)
			{ctor(symtab);}
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf32SymbolEntry_disk*);
		void parse(SgAsmExecutableFileFormat::ByteOrder, const SgAsmElfSymbol::Elf64SymbolEntry_disk*);
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf32SymbolEntry_disk*) const;
		void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmElfSymbol::Elf64SymbolEntry_disk*) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
		void dump(FILE*, const char *prefix, ssize_t idx, SgAsmGenericSection*) const;
		SgAsmElfSymbol::ElfSymBinding get_elf_binding() const;
		SgAsmElfSymbol::ElfSymType get_elf_type() const;

		static std::string to_string(SgAsmElfSymbol::ElfSymBinding);
		static std::string to_string(SgAsmElfSymbol::ElfSymType);

	private:
		void ctor(SgAsmElfSymbolSection*);
		void parse_common(); /* Initialization common to all parse() methods */
HEADER_ELF_SYMBOL_END





// ***********************************************
//          PE Binary File Format Support
// ***********************************************

HEADER_PE_RVA_SIZE_PAIR_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/* File format for an RVA/Size pair. Such pairs are considered to be part of the PE file header.  All fields are
		 * little endian. */
		struct RVASizePair_disk {
			uint32_t    e_rva;
			uint32_t    e_size;
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		explicit SgAsmPERVASizePair(const SgAsmPERVASizePair::RVASizePair_disk *disk)
			: p_e_rva(0), p_e_size(0), p_section(NULL) {
			ctor(disk);
		}
		void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const;
	private:
		void ctor(const SgAsmPERVASizePair::RVASizePair_disk*);
HEADER_PE_RVA_SIZE_PAIR_END



HEADER_PE_RVA_SIZE_PAIR_LIST_START
HEADER_PE_RVA_SIZE_PAIR_LIST_END



HEADER_PE_FILE_HEADER_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/* File format of a PE File Header. All fields are little endian. */
		struct PEFileHeader_disk {
			unsigned char e_magic[4];	/* 0x00 magic number "PE\0\0" */
			uint16_t    e_cpu_type;         /* 0x04 e.g., 0x014c = Intel 386 */
			uint16_t    e_nsections;        /* 0x06 number of sections defined in the Section Table */
			uint32_t    e_time;             /* 0x08 time and date file was created or modified by the linker */
			uint32_t    e_coff_symtab;      /* 0x0c offset to COFF symbol table */
			uint32_t    e_coff_nsyms;       /* 0x10 number of symbols in COFF symbol table */
			uint16_t    e_nt_hdr_size;      /* 0x14 num remaining bytes in the header following the 'flags' field */
			uint16_t    e_flags;            /* 0x16 Bit flags: exe file, program/library image, fixed address, etc. */
		}              				/* 0x18 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct PE32OptHeader_disk {
			uint16_t    e_opt_magic;        /* 0x18 magic number */
			uint16_t    e_lmajor;           /* 0x1a linker version */
			uint16_t    e_lminor;           /* 0x1c */
			uint16_t    e_code_size;        /* 0x1e Size of .text or sum of all code sections */
			uint32_t    e_data_size;        /* 0x20 Sum size of initialized data */
			uint32_t    e_bss_size;         /* 0x24 Sum size of uninitialized data */
			uint32_t    e_entrypoint_rva;   /* 0x28 RVA="relative virtual address"; relative to 'image_base', below */
			uint32_t    e_code_rva;         /* 0x2c Addr relative to image base for code section when memory mapped */
			uint32_t    e_data_rva;         /* 0x30 Address relative to image base for data section */
			uint32_t    e_image_base;       /* 0x34 Virt base of image (first byte of file, DOS header). 64k aligned */
			uint32_t    e_section_align;    /* 0x38 Alignment of sections in memory. Power of two 512<=x<=256M */
			uint32_t    e_file_align;       /* 0x3c Alignment factor (in bytes) for image pages */
			uint16_t    e_os_major;         /* 0x40 OS version number required to run this image */
			uint16_t    e_os_minor;		/* 0x42 */
			uint16_t    e_user_major;       /* 0x44 User-specified for differentiating between image revs */
			uint16_t    e_user_minor;	/* 0x46 */
			uint16_t    e_subsys_major;     /* 0x48 Subsystem version number */
			uint16_t    e_subsys_minor;     /* 0x4a */
			uint32_t    e_reserved9;	/* 0x4c */
			uint32_t    e_image_size;       /* 0x50 Virtual size of the image inc. all headers; section_align */
			uint32_t    e_header_size;      /* 0x54 Total header size (DOS Header + PE Header + Section table */
			uint32_t    e_file_checksum;    /* 0x58 Checksum for entire file; Set to zero by the linker */
			uint16_t    e_subsystem;        /* 0x5c Native, WindowsGUI, WindowsCharacter, OS/2 Character, etc. */
			uint16_t    e_dll_flags;        /* 0x5e Bit flags for library init/terminate per process or thread */
			uint32_t    e_stack_reserve_size;/*0x60 Virtual mem reserved for stack; non-committed pages are guards */
			uint32_t    e_stack_commit_size;/* 0x64 Size of valid stack; other pages are guards; <=stack_reserve_size*/
			uint32_t    e_heap_reserve_size;/* 0x68 Size (bytes) of local heap to reserve */
			uint32_t    e_heap_commit_size; /* 0x6c Size (bytes) of valid local heap */
			uint32_t    e_loader_flags;     /* 0x70 Reserved, must be zero */
			uint32_t    e_num_rvasize_pairs;/* 0x74 Num RVASizePair entries that follow this member; part of header */
		}					/* 0x78 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct PE64OptHeader_disk {
			uint16_t    e_opt_magic;	/* 0x18 */
			uint16_t    e_lmajor;		/* 0x1a */
			uint16_t    e_lminor;		/* 0x1c */
			uint16_t    e_code_size;	/* 0x1e */
			uint32_t    e_data_size;	/* 0x20 */
			uint32_t    e_bss_size;		/* 0x24 */
			uint32_t    e_entrypoint_rva;	/* 0x28 */
			uint32_t    e_code_rva;		/* 0x2c */
			// uint32_t  e_data_rva;             /* Not present in PE32+ */
			uint64_t    e_image_base;	/* 0x30 */
			uint32_t    e_section_align;	/* 0x38 */
			uint32_t    e_file_align;	/* 0x3c */
			uint16_t    e_os_major;		/* 0x40 */
			uint16_t    e_os_minor;		/* 0x42 */
			uint16_t    e_user_major;	/* 0x44 */
			uint16_t    e_user_minor;	/* 0x46 */
			uint16_t    e_subsys_major;	/* 0x48 */
			uint16_t    e_subsys_minor;	/* 0x4a */
			uint32_t    e_reserved9;	/* 0x4c */
			uint32_t    e_image_size;	/* 0x50 */
			uint32_t    e_header_size;	/* 0x54 */
			uint32_t    e_file_checksum;	/* 0x58 */
			uint16_t    e_subsystem;	/* 0x5c */
			uint16_t    e_dll_flags;	/* 0x5e */
			uint64_t    e_stack_reserve_size;/*0x60 */
			uint64_t    e_stack_commit_size;/* 0x68 */
			uint64_t    e_heap_reserve_size;/* 0x70 */
			uint64_t    e_heap_commit_size;	/* 0x78 */
			uint32_t    e_loader_flags;	/* 0x80 */
			uint32_t    e_num_rvasize_pairs;/* 0x84 */
		}					/* 0x88 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		/* Bit flags for the PE header 'flags' member */
		enum HeaderFlags {
			HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
			HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: link errors or incrementally linked */
			HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
			HF_LIBRARY          = 0x2000,       /* Library image */
			HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
		};

		/* Values for the PE header 'subsystem' member */
		enum Subsystem {
			HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
			HF_NATIVE           = 0x0001,       /* Native */
			HF_WINGUI           = 0x0002,       /* Windows GUI */
			HF_WINCHAR          = 0x0003,       /* Windows character */
			HF_OS2CHAR          = 0x0005,       /* OS/2 character */
			HF_POSIX            = 0x0007        /* POSIX character */
		};

		/* Bit flags for the PE header 'dll_flags' member */
		enum DLLFlags {
			DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
			DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
			DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
			DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
			DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
		};

	public:
		explicit SgAsmPEFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f), p_loader_map(NULL), p_section_table(NULL), p_coff_symtab(NULL)
			{ctor();}
		virtual ~SgAsmPEFileHeader();

		virtual const char *format_name() const {return "PE";}
		static bool is_PE (SgAsmGenericFile*);
		void add_rvasize_pairs();

		virtual SgAsmPEFileHeader *parse();
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void create_table_sections();

		/* Loader memory maps */
		MemoryMap *get_loader_map() const {return p_loader_map;}
		void set_loader_map(MemoryMap *map) {p_loader_map=map;}

	private:
		void ctor();
		void *encode(SgAsmPEFileHeader::PEFileHeader_disk*) const;
		void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*) const;
		void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*) const;
		MemoryMap *p_loader_map;
HEADER_PE_FILE_HEADER_END



HEADER_PE_SECTION_START
	public:
		explicit SgAsmPESection(SgAsmPEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr), p_section_entry(NULL)
			{}
		SgAsmPESection *init_from_section_table(SgAsmPESectionTableEntry *entry, int id);
		virtual bool reallocate();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_PE_SECTION_END



HEADER_PE_IMPORT_DIRECTORY_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct PEImportDirectory_disk {
			uint32_t ilt_rva;		/* 0x00 Import Lookup Table RVA */
			uint32_t time;			/* 0x04 Zero until the image is bound, then time stamp of the DLL */
			uint32_t forwarder_chain;	/* 0x08 Index of the first forwarder chain */
			uint32_t dll_name_rva;    	/* 0x0c address of NUL-terminated DLL name */
			uint32_t iat_rva;		/* 0x10 Import Address Table (Thunk Table) RVA */
		}					/* 0x14 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		SgAsmPEImportDirectory(SgAsmPEImportSection *isec, size_t idx, rose_addr_t *rva_p)
			{ctor(isec,idx,rva_p);}
		void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*) const;
		virtual void unparse(std::ostream&, const SgAsmPEImportSection*) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, size_t idx, rose_addr_t *rva_p);
HEADER_PE_IMPORT_DIRECTORY_END



HEADER_PE_IMPORT_ILT_ENTRY_START
	// PE -> Import Table -> Import Lookup Table -> Entry
	public:
		enum ILTEntryType {
			ILT_ORDINAL,			/* Entry is an ordinal */
			ILT_HNT_ENTRY_RVA,		/* Entry is the RVA of a Hint/Name Pair in the Hint/Name Table */
			ILT_BOUND_RVA,			/* Entry is the actual memory address of the symbol */
		};

		SgAsmPEImportILTEntry(SgAsmPEImportSection *isec, uint64_t entry_word)
			{ctor(isec,entry_word);}
		uint64_t encode(const SgAsmPEFileHeader*) const;
		void unparse(std::ostream&, const SgAsmPEFileHeader *fhdr, rva_t rva, size_t idx) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, uint64_t);
HEADER_PE_IMPORT_ILT_ENTRY_END



HEADER_PE_IMPORT_LOOKUP_TABLE_START
	// PE -> Import Table -> Import Lookup Table   or
	// PE -> Import Table -> Import Address Table
	public:
		SgAsmPEImportLookupTable(SgAsmPEImportSection *isec, rose_rva_t table_rva, size_t idir_idx, bool is_iat=false)
			: p_entries(NULL)
			{ctor(isec, table_rva, idir_idx, is_iat);}
		void add_ilt_entry(SgAsmPEImportILTEntry*);
		virtual void unparse(std::ostream&, const SgAsmPEFileHeader*, rose_rva_t) const;
		virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, rose_rva_t table_rva, size_t idir_idx, bool is_iat);
HEADER_PE_IMPORT_LOOKUP_TABLE_END



HEADER_PE_IMPORT_HNT_ENTRY_START
	// PE -> Import Table -> Hint/Name Table -> Entry
	public:
		explicit SgAsmPEImportHNTEntry(SgAsmPEImportSection *isec, rose_rva_t offset)
			{ctor(isec, offset);}
		void unparse(std::ostream&, rva_t rva) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEImportSection*, rose_rva_t offset);
HEADER_PE_IMPORT_HNT_ENTRY_END



HEADER_PE_IMPORT_SECTION_START
	public:
		explicit SgAsmPEImportSection(SgAsmPEFileHeader *fhdr)
			: SgAsmPESection(fhdr)
			{ctor();}
		virtual SgAsmPEImportSection *parse();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_import_directory(SgAsmPEImportDirectory*);
	private:
		void ctor();
HEADER_PE_IMPORT_SECTION_END



HEADER_PE_EXPORT_DIRECTORY_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/* An Export Section begins with the Export Directory */
		struct PEExportDirectory_disk {
			uint32_t res1;         /* 0x00 Reserved, must be zero */
			uint32_t timestamp;    /* 0x04 Time that export data was created */
			uint16_t vmajor;       /* 0x08 Major version number (user defined) */
			uint16_t vminor;       /* 0x0a Minor version number (user defined) */
			uint32_t name_rva;     /* 0x0c Location of name of DLL */
			uint32_t ord_base;     /* 0x10 Starting ordinal for exports in this image (usually 1) */
			uint32_t expaddr_n;    /* 0x14 Number of entries in the export address table */
			uint32_t nameptr_n;    /* 0x18 Number of entries in the name pointer table and ordinal table */
			uint32_t expaddr_rva;  /* 0x1c Location of Export Address Table */
			uint32_t nameptr_rva;  /* 0x20 Location of Export Name Pointer Table */
			uint32_t ordinals_rva; /* 0x24 Location of Ordinal Table */
		}     				/* 0x28 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		explicit SgAsmPEExportDirectory(SgAsmPEExportSection *s)
			{ctor(s);}
		void dump(FILE *f, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmPEExportSection*);
HEADER_PE_EXPORT_DIRECTORY_END



HEADER_PE_EXPORT_ENTRY_START
	public:
		SgAsmPEExportEntry(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva,
				   SgAsmGenericString *forwarder)
			{ctor(name, ordinal, export_rva, forwarder);}

		void dump(FILE *f,const char *prefix,ssize_t idx) const;

		/* Accessors. Override ROSETTA because we adjust parents. */
		SgAsmGenericString *get_name() const {return p_name;}
		void set_name(SgAsmGenericString*);
		SgAsmGenericString *get_forwarder() const {return p_forwarder;}
		void set_forwarder(SgAsmGenericString*);
	private:
		void ctor(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva, SgAsmGenericString *forwarder);
HEADER_PE_EXPORT_ENTRY_END




HEADER_PE_EXPORT_SECTION_START
	public:
		/* The PE Export Address Table is an array of expaddr_n 4-byte RVAs. If the address is not in the export section
		 * (as defined by the address and length that are indicated in the NT Optional Header) then the RVA is an actual
		 * address in code or data. Otherwise its a Forwarder RVA that names a symbol in another DLL. */
		typedef uint32_t ExportAddress_disk;

		/* The PE Export Name Pointer Table is an array of nameptr_n 4-byte RVAs pointing into the Export Name Table. The
		 * pointers are ordered lexically to allow binary searches.  An export name is defined only if the export name
		 * pointer table contains a pointer to it. */
		typedef uint32_t ExportNamePtr_disk;

		/* The PE Export Ordinal Table is an array of nameptr_n (yes) 2-byte indices into the Export Address Table biased
		 * by ord_base. In other words, the ord_base must be subtracted from the ordinals to obtain true indices into the
		 * Export Address Table. */
		typedef uint16_t ExportOrdinal_disk;

		SgAsmPEExportSection(SgAsmPEFileHeader *fhdr)
			: SgAsmPESection(fhdr)
			{ctor();}
		virtual SgAsmPEExportSection *parse();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		void add_entry(SgAsmPEExportEntry*);
	private:
		void ctor();
HEADER_PE_EXPORT_SECTION_END



HEADER_PE_SECTION_TABLE_START
	public:
		explicit SgAsmPESectionTable(SgAsmPEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
		virtual SgAsmPESectionTable* parse();
		void add_section(SgAsmPESection *section);
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_PE_SECTION_TABLE_END



HEADER_PE_COFF_SYMBOL_TABLE_START
	public:
		explicit SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
		size_t get_nslots() const;
		virtual SgAsmCoffSymbolTable *parse();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_PE_COFF_SYMBOL_TABLE_END



HEADER_PE_SECTION_TABLE_ENTRY_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		/* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
		struct PESectionTableEntry_disk {
			char     name[8];          /* NUL-padded */
			uint32_t virtual_size;     /* virtual memory size, >= physical_size and difference is zero filled */
			uint32_t rva;              /* relative virt addr wrt Image Base; multiple of section_align; dense space */
			uint32_t physical_size;    /* bytes of initialized data on disk; multiple of file_align & <= virtual_size*/
			uint32_t physical_offset;  /* location of initialized data on disk; multiple of file_align */
			uint32_t coff_line_nums;   /* file offset of COFF line number info or zero */
			uint32_t n_relocs;         /* number of relocation entries; should be zero for executables */
			uint32_t n_coff_line_nums; /* number of COFF line number entries */
			uint32_t flags;            /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc.*/
		}
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		/* These come from the windows PE documentation and
		 * http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
		enum PESectionFlags {
			OF_CODE             = 0x00000020,   /* section contains code */
			OF_IDATA            = 0x00000040,   /* initialized data */
			OF_UDATA            = 0x00000080,   /* uninitialized data */
			OF_INFO             = 0x00000200,   /* comments or some other type of info */
			OF_REMOVE           = 0x00000800,   /* section will not become part of image */
			OF_COMDAT           = 0x00001000,   /* section contains comdat */
			OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for
							     * this section */
			OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
			OF_ALIGN_1          = 0x00100000,   /* no alignment */
			OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
			OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
			OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
			OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
			OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
			OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
			OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
			OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
			OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
			OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
			OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
			OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
			OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
			OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
			OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
			OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
			OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
			OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
			OF_SHARED           = 0x10000000,   /* section is shared */
			OF_EXECUTABLE       = 0x20000000,   /* execute permission */
			OF_READABLE         = 0x40000000,   /* read permission */
			OF_WRITABLE         = 0x80000000,   /* write permission */
		};

		explicit SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);
		void update_from_section(SgAsmPESection *section);
		void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(const SgAsmPESectionTableEntry::PESectionTableEntry_disk*);
HEADER_PE_SECTION_TABLE_ENTRY_END



HEADER_PE_COFF_SYMBOL_LIST_START
HEADER_PE_COFF_SYMBOL_LIST_END

HEADER_PE_COFF_SYMBOL_START
     public:

       // This was previously a #define macro in ExecPE.h (so we have to avoid the macro defining it as "static const unsigned int 18 = 18"
          static const unsigned int COFFSymbol_disk_size = 18;

#ifdef _MSC_VER
# pragma pack (1)
#endif
          struct COFFSymbol_disk {
               union {
                   char            st_name[8];
                   struct {
                       uint32_t    st_zero;
                       uint32_t    st_offset;
                   };
               };
               uint32_t            st_value;
               int16_t             st_section_num;
               uint16_t            st_type;
               unsigned char       st_storage_class;
               unsigned char       st_num_aux_entries;
             }
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // virtual ~COFFSymbol() {}
          void *encode(SgAsmCoffSymbol::COFFSymbol_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

       /* Auxilliary data for the symbol */
       // const unsigned char *get_aux_data() {return aux_data;}
       // size_t get_aux_size() {return aux_size;}

       /* Native versions of the COFFSymbol_disk members */
       // std::string         st_name;        /* The original name; super.name might be modified */
       // addr_t              st_name_offset;
       // int                 st_section_num;
       // unsigned            st_type, st_storage_class, st_num_aux_entries;
    
     private:
          void ctor(SgAsmPEFileHeader*, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // const unsigned char *aux_data;      /* Auxilliary data from table entries that follow */
       // size_t              aux_size;       /* Size (bytes) of auxilliary data */

HEADER_PE_COFF_SYMBOL_END

HEADER_COFF_STRING_TABLE_START
	public:
		explicit SgAsmCoffStrtab(class SgAsmPESection *containing_section)
			: SgAsmGenericStrtab(containing_section)
			{}
		virtual ~SgAsmCoffStrtab();
		virtual void unparse(std::ostream&) const;
		virtual SgAsmStringStorage *create_storage(addr_t offset, bool shared);
		virtual addr_t get_storage_size(const SgAsmStringStorage*);
HEADER_COFF_STRING_TABLE_END



HEADER_PE_STRING_SECTION_START
	public:
		SgAsmPEStringSection(SgAsmPEFileHeader *fhdr)
			: SgAsmPESection(fhdr), p_strtab(NULL)
			{ctor();}
		virtual ~SgAsmPEStringSection() {}
		virtual SgAsmPEStringSection* parse();
		virtual bool reallocate();
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual void set_size(addr_t newsize);
	        virtual void unparse(std::ostream&) const;
	private:
		void ctor();
HEADER_PE_STRING_SECTION_END



// ***********************************************
//          NE Binary File Format Support
// ***********************************************

HEADER_NE_FILE_HEADER_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
          /* File format of an NE File Header. All fields are little endian.
           *
           * NOTES
           * 
           * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
           *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
           *         of the stack. */
          struct NEFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 magic number "NE" */
               unsigned char e_linker_major;       /* 0x02 linker major version number */
               unsigned char e_linker_minor;       /* 0x03 linker minor version number */
               uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
               uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
               uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
               uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
               uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
               uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
               uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
               uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
               uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
               uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
               uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
               uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
               uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
               uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
               uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
               uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
               uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
               uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
               uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
               uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
               uint16_t    e_nresources;           /* 0x34 number of resource entries */
               unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
               unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
               uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
               uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
               uint16_t    e_res1;                 /* 0x3c reserved */
               uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
             }              			   /* 0x40 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

          /* Bit flags for the NE header 'e_flags' member.
           *
           * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
           * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
           * value in AX is a status indicator (non-zero for success, zero for failure). */
          enum HeaderFlags1 {
               HF1_RESERVED         = 0x57f4,      /* Reserved bits */
               HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
               HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
               HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
               HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
               HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
               HF1_LIBRARY          = 0x8000,      /* Module is a library */
             };

          /* Bit flags for the NE header 'e_flags2' member. */
          enum HeaderFlags2 {
               HF2_RESERVED         = 0xf1,        /* Reserved bits */
               HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
               HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
               HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
             };

          SgAsmNEFileHeader(SgAsmGenericFile *f, addr_t offset)
		: SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_resname_table(NULL),
		p_nonresname_table(NULL), p_module_table(NULL), p_entry_table(NULL)
		{ctor(f, offset);}

       // virtual ~NEFileHeader() {}
          static bool is_NE (SgAsmGenericFile*);
          static SgAsmNEFileHeader *parse(SgAsmDOSFileHeader*);
          virtual void unparse(std::ostream&) const;
          virtual const char *format_name() const {return "NE";}
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;
HEADER_NE_FILE_HEADER_END

HEADER_NE_SECTION_START
     public:
          explicit SgAsmNESection(SgAsmNEFileHeader *fhdr)
		: SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL), p_reloc_table(NULL)
		{}

       // virtual ~NESection() {}

          virtual void unparse(std::ostream&) const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

       /* Accessors for protected/private data */
       // NESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(NESectionTableEntry *e) {st_entry=e;}
       // NERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(NERelocTable *t) {reloc_table=t;}
  // private:
       // NESectionTableEntry *st_entry;
       // NERelocTable *reloc_table;

HEADER_NE_SECTION_END



HEADER_NE_SECTION_TABLE_START
	public:
		explicit SgAsmNESectionTable(SgAsmNEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
        	virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_NE_SECTION_TABLE_END



HEADER_NE_NAME_TABLE_START
	public:
		SgAsmNENameTable(SgAsmNEFileHeader *fhdr, addr_t offset)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::vector<std::string> get_names_by_ordinal(unsigned ordinal);
	private:
		void ctor(addr_t offset);
HEADER_NE_NAME_TABLE_END



HEADER_NE_MODULE_TABLE_START
	public:
		SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, SgAsmNEStringTable *strtab, addr_t offset, addr_t size)
			: SgAsmGenericSection(fhdr->get_file(), fhdr), p_strtab(strtab)
			{ctor(offset, size);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset, addr_t size);
HEADER_NE_MODULE_TABLE_END



HEADER_NE_STRING_TABLE_START
	public:
		SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset, size);}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		std::string get_string(addr_t offset);
	private:
		void ctor(addr_t offset, addr_t size);
HEADER_NE_STRING_TABLE_END



HEADER_NE_ENTRY_TABLE_START
	public:
		SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, addr_t offset, addr_t size)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset, size);}
		void populate_entries();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset, addr_t size);
HEADER_NE_ENTRY_TABLE_END



HEADER_NE_RELOC_TABLE_START
	public:
		explicit SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, SgAsmNESection *section)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(section);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(SgAsmNESection*);
HEADER_NE_RELOC_TABLE_END



HEADER_NE_ENTRY_POINT_START
          enum NEEntryFlags {
	       EF_ZERO		   = 0x00, /* No flags set */
               EF_RESERVED         = 0xfc, /* Reserved bits */
               EF_EXPORTED         = 0x01, /* Exported */
               EF_GLOBAL           = 0x02  /* Uses a global (shared) data section */
             };

       // SgAsmNEEntryPoint();
          SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);

          void dump(FILE*, const char *prefix, ssize_t idx) const;

       // NEEntryFlags flags;         /* bit flags */
       // unsigned int3f;             /* always 0x3fxx */
       // unsigned section_idx;       /* zero indicates unused entry */
       // unsigned section_offset;    /* byte offset into section */

HEADER_NE_ENTRY_POINT_END

HEADER_NE_RELOC_ENTRY_START

     public:

       /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
        * than defining it here as a struct. */

          enum NERelocSrcType {
               RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
               RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
               RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
               RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
               RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
               RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
               RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
               RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
               RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
             };

          enum NERelocTgtType {
               RF_TGTTYPE_IREF     = 0,            /* Internal reference */
               RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
               RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
               RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */ 
             };

          enum NERelocModifiers {
               RF_MODIFIER_SINGLE  = 1,
               RF_MODIFIER_MULTI   = 3
             };

          enum NERelocFlags {
               RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
               RF_RESERVED         = 0x02,         /* reserved bits */
               RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
               RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
               RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
               RF_8ORDINAL         = 0x20,         /* Ordinal is 8-bits rather than 16 */
             };

       // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support 
       // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, addr_t; and then use member 
       // functions to access the data in the base class.
          struct iref_type
             { /*tgt_type==0x00: internal reference*/
               unsigned    sect_idx;       /* section index (1-origin) */
               unsigned    res1;           /* reserved */
               addr_t      tgt_offset;
     
            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

               iref_type();
             };

          struct iord_type { /*tgt_type==0x01: imported ordinal*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    ordinal;
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

               iord_type();
             };

          struct iname_type { /*tgt_type==0x02: imported name*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    nm_off;         /* offset into import procedure names */
               addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

               iname_type();
             };

          struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
               unsigned    type;
               unsigned    res3;

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

               osfixup_type();
             };

          SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size);

          void ctor(SgAsmGenericSection*, addr_t at, addr_t *rec_size);
          addr_t unparse(std::ostream&, const SgAsmGenericSection*, addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;

       // NERelocSrcType      src_type;       /* low nibble of first byte of relocation record */
       // NERelocModifiers    modifier;       /* high nibble of first byte */
       // NERelocTgtType      tgt_type;       /* low two bits of second byte */
       // NERelocFlags        flags;          /* high six bits of second byte */
       // addr_t              src_offset;

       // iref_type iref;
       // iord_type iord;
       // iname_type iname;
       // osfixup_type osfixup;

HEADER_NE_RELOC_ENTRY_END

HEADER_NE_SECTION_TABLE_ENTRY_START
     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. All fields are little endian. */
          struct NESectionTableEntry_disk {
               uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
               uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
               uint16_t    flags;                  /* 0x04 Segment bit flags */
               uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
             }              			   /* 0x08 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum NESectionFlags {
               SF_RESERVED         = 0x0e08,       /* these bits are reserved */

               SF_TYPE_MASK        = 0x0007,       /* segment-type field */
               SF_CODE             = 0x0000,       /* code-segment type */
               SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
               SF_ALLOC            = 0x0002,       /* loader allocates memory */
               SF_LOAD             = 0x0004,       /* load the segment */

               SF_MOVABLE          = 0x0010,       /* segment is not fixed */
               SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
               SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
               SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
               SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
               SF_DISCARDABLE      = 0x1000,       /* discardable */
               SF_DISCARD          = 0xf000        /* discard priority */
             };

          explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
       // virtual ~NESectionTableEntry() {};

          void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;

       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, sector;
       // addr_t      physical_size, virtual_size;

     private:
          void ctor(const SgAsmNESectionTableEntry::NESectionTableEntry_disk*);

HEADER_NE_SECTION_TABLE_ENTRY_END



// ***********************************************
//          LE Binary File Format Support
// ***********************************************

HEADER_LE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name() const;

          static bool is_LE (SgAsmGenericFile*);
          static SgAsmLEFileHeader *parse(SgAsmDOSFileHeader*);

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
          struct LEFileHeader_disk {
              unsigned char e_magic[2];           /* 0x00 magic number "LX" */
              unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
              unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
              uint32_t    e_format_level;         /* 0x04 LX file format version number */
              uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
              uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
              uint32_t    e_module_version;       /* 0x0c user-specified module version number */
              uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
              uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
              uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
              uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
              uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
              uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
              uint32_t    e_page_size;            /* 0x28 page size in bytes */
              uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
              uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
              uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
              uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
              uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
              uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
              uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
              uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
              uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
              uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
              uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
              uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
              uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
              uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
              uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
              uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
              uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
              uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
              uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
              uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
              uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
              uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
              uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
              uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
              uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
              uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
              uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
              uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
              uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
              uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
              uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
              uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
          }              			  /* 0xac */
#ifndef _MSC_VER
	  __attribute__((packed))
#endif
	  ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum LEFileHeaderFlags {
              HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
              HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
              HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
              HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
              HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
              HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
              HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
              HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
              HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */
    
              HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
              HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
              HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
              HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
              HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
              HF_MODTYPE_VDEV     = 0x00028000,   /* Virtual device driver module */
          };

          SgAsmLEFileHeader(SgAsmGenericFile *f, addr_t offset)
		: SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_page_table(NULL),
		p_resname_table(NULL), p_nonresname_table(NULL), p_entry_table(NULL), p_reloc_table(NULL)
		{ctor(f, offset);}

       // virtual ~LEFileHeader() {}

          virtual void unparse(std::ostream&) const;
       // virtual const char *format_name() const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
     private:
          void ctor(SgAsmGenericFile *f, addr_t offset);
          void *encode(SgAsmExecutableFileFormat::ByteOrder sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;
HEADER_LE_FILE_HEADER_END



HEADER_LE_SECTION_START
	public:
		explicit SgAsmLESection(SgAsmLEFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL)
			{}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_LE_SECTION_END



HEADER_LE_SECTION_TABLE_START
	public:
		SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset, size);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset, addr_t size);
HEADER_LE_SECTION_TABLE_END



HEADER_LE_NAME_TABLE_START
	public:
		/* This table contains a module name followed by the list of exported function names. Each name is associated with
		 * an "ordinal" which serves as an index into the Entry Table. The ordinal for the first string (module name) is
		 * meaningless and should be zero. In the non-resident name table the first entry is a module description and the
		 * functions are not always resident in system memory (they are discardable). */
		SgAsmLENameTable(SgAsmLEFileHeader *fhdr, addr_t offset)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset);
HEADER_LE_NAME_TABLE_END



HEADER_LE_PAGE_TABLE_START
	public:
		SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, addr_t offset, addr_t size)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset, size);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		SgAsmLEPageTableEntry *get_page(size_t idx);
	private:
		void ctor(addr_t offset, addr_t size);
HEADER_LE_PAGE_TABLE_END



HEADER_LE_ENTRY_TABLE_START
	public:
		SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, addr_t offset)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset);}
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset);
HEADER_LE_ENTRY_TABLE_END



HEADER_LE_RELOC_TABLE_START
	public:
		SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, addr_t offset)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor(offset);}
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor(addr_t offset);
HEADER_LE_RELOC_TABLE_END



HEADER_LE_PAGE_TABLE_ENTRY_START
     public:
       /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
        * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while
        * still allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
        * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they
        * are both indexed by the logical page number). */

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format for a page table entry */
          struct LEPageTableEntry_disk {
               uint16_t            pageno_hi;
               unsigned char       pageno_lo;
               unsigned char       flags;
             }
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;

       // unsigned get_pageno() {return pageno;}

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned    pageno;
       // unsigned    flags;

HEADER_LE_PAGE_TABLE_ENTRY_END

HEADER_LE_ENTRY_POINT_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
        * next entry point description follows immediately after the flag. */
          struct LEEntryPoint_disk {
              uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
              uint16_t    objnum;         /* 0x01 Object number */
              uint8_t     entry_type;     /* 0x03 Flags for entry type */
              uint32_t    entry_offset;   /* 0x04 Offset of entry point */
              uint16_t    res1;           /* 0x08 Reserved */
          }      			  /* 0x0a */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
          SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags);

          addr_t unparse(std::ostream&, SgAsmExecutableFileFormat::ByteOrder, const SgAsmGenericSection*, addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLEEntryPoint::LEEntryPoint_disk*);

       // std::vector<LEEntryPoint> entries;
       // unsigned flags, objnum, entry_type, res1;
       // addr_t entry_offset;

HEADER_LE_ENTRY_POINT_END

HEADER_LE_SECTION_TABLE_ENTRY_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
          struct LESectionTableEntry_disk {
               uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
               uint32_t    base_addr;              /* 0x04 relocation base address */
               uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
               uint32_t    pagemap_index;          /* 0x0c */
               uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
               uint32_t    res1;                   /* 0x14 reserved */
             }                                     /* 0x18 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

       /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
        *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
        *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
        *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
        *             stream.) */
          enum LESectionFlags {
               SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */
    
               SF_READABLE         = 0x00000001,   /* Read permission granted when mapped */
               SF_WRITABLE         = 0x00000002,   /* Write permission granted when mapped */
               SF_EXECUTABLE       = 0x00000004,   /* Execute permission granted when mapped */
    
               SF_RESOURCE         = 0x00000008,   /* Section contains resource objects */
               SF_DISCARDABLE      = 0x00000010,   /* Discardable section */
               SF_SHARED           = 0x00000020,   /* Section is shared */
               SF_PRELOAD_PAGES    = 0x00000040,   /* Section has preload pages */
               SF_INVALID_PAGES    = 0x00000080,   /* Section has invalid pages */

               SF_TYPE_MASK        = 0x00000300,
               SF_TYPE_NORMAL      = 0x00000000,
               SF_TYPE_ZERO        = 0x00000100,   /* Section has zero-filled pages */
               SF_TYPE_RESIDENT    = 0x00000200,   /* Section is resident (valid for VDDs and PDDs only) */
               SF_TYPE_RESCONT     = 0x00000300,   /* Section is resident and contiguous */
    
               SF_RES_LONG_LOCK    = 0x00000400,   /* Section is resident and "long-lockable" (VDDs and PDDs only) */
               SF_1616_ALIAS       = 0x00001000,   /* 16:16 alias required (80x86 specific) */
               SF_BIG_BIT          = 0x00002000,   /* Big/default bit setting (80x86 specific); see note above */
               SF_CODE_CONFORM     = 0x00004000,   /* Section is conforming for code (80x86 specific) */
               SF_IO_PRIV          = 0x00008000,   /* Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
             };

          SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
       // virtual ~LESectionTableEntry() {};

          void *encode(SgAsmExecutableFileFormat::ByteOrder, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
    
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, pagemap_index, pagemap_nentries, res1;
       // addr_t      mapped_size, base_addr;

     private:
          void ctor(SgAsmExecutableFileFormat::ByteOrder, const SgAsmLESectionTableEntry::LESectionTableEntry_disk*);

HEADER_LE_SECTION_TABLE_ENTRY_END




// ***********************************************
//          DOS Binary File Format Support
// ***********************************************

HEADER_DOS_HEADER_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct DOSFileHeader_disk {
			unsigned char e_magic[2];          /* 0x00 "MZ" */
			uint16_t      e_last_page_size;    /* 0x02 bytes used on last page of file (1 page == 512 bytes);
							    *      zero implies if last page is full */
			uint16_t      e_total_pages;       /* 0x04 number of pages (inc. last possibly partial page) in file */
			uint16_t      e_nrelocs;           /* 0x06 number of relocation entries stored after this header */
			uint16_t      e_header_paragraphs; /* 0x08 header size in paragraphs (16-byte blocks) inc. relocations */
			uint16_t      e_minalloc;          /* 0x0a number of extra paragraphs needed, similar to BSS in Unix */
			uint16_t      e_maxalloc;          /* 0x0c max paragraphs to allocate for BSS */
			uint16_t      e_ss;                /* 0x0e initial value of SS register relative to program load segment */
			uint16_t      e_sp;                /* 0x10 initial value for SP register */
			uint16_t      e_cksum;             /* 0x12 checksum; 16-bit sum of all words in file should be zero
							    *      (usually not filled in) */
			uint16_t      e_ip;                /* 0x14 initial value for IP register */
			uint16_t      e_cs;                /* 0x16 initial value for CS register relative to program load segment*/
			uint16_t      e_relocs_offset;     /* 0x18 file address of relocation table */
			uint16_t      e_overlay;           /* 0x1a overlay number (zero indicates main program) */
			uint32_t      e_res1;              /* 0x1c unknown purpose */
		}                 			   /* 0x20 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;

		struct DOSRelocEntry_disk {
			uint16_t      offset;		   /* 0x00 */
			uint16_t      segment;		   /* 0x02 */
		}		   			   /* 0x04 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif

		explicit SgAsmDOSFileHeader(SgAsmGenericFile *f)
			: SgAsmGenericHeader(f), p_relocs(NULL), p_rm_section(NULL)
			{ctor();}
		virtual SgAsmDOSFileHeader *parse() {return parse(true);}
		SgAsmDOSFileHeader *parse(bool define_rm_section);
		virtual bool reallocate();
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
		virtual const char *format_name() const {return "DOS";}
		SgAsmGenericSection *add_rm_section(addr_t max_offset=0);
		static bool is_DOS(SgAsmGenericFile*);
	private:
		void ctor();
		void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*) const;
HEADER_DOS_HEADER_END



HEADER_DOS_EXTENDED_HEADER_START
	public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
		struct DOSExtendedHeader_disk {
			uint32_t      e_res1;     /* 0x00 reserved */
			uint16_t      e_oemid;    /* 0x04 OEM Identifier */
			uint16_t      e_oeminfo;  /* 0x06 other OEM information; oemid specific */
			uint32_t      e_res2;     /* 0x08 reserved */
			uint32_t      e_res3;     /* 0x0c reserved */
			uint32_t      e_res4;	  /* 0x10 reserved */
			uint32_t      e_res5;	  /* 0x14 reserved */
			uint32_t      e_res6;	  /* 0x18 reserved */
			uint32_t      e_lfanew;   /* 0x1c file offset of new exe (PE) header */
		}        			  /* 0x20 */
#ifndef _MSC_VER
		__attribute__((packed))
#endif
		;
#ifdef _MSC_VER
# pragma pack ()
#endif
		explicit SgAsmDOSExtendedHeader(SgAsmDOSFileHeader *fhdr)
			: SgAsmGenericSection(fhdr->get_file(), fhdr)
			{ctor();}
		virtual SgAsmDOSExtendedHeader *parse();
		void *encode(SgAsmDOSExtendedHeader::DOSExtendedHeader_disk*) const;
		virtual void unparse(std::ostream&) const;
		virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
	private:
		void ctor();
HEADER_DOS_EXTENDED_HEADER_END





SOURCE_BINARY_FILE_SECTION_HEADER_LIST_START

#if 0
const SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers() const
   {
     return p_section_headers;
   }

SgAsmSectionHeaderPtrList &
SgAsmSectionHeaderList::get_section_headers()
   {
     return p_section_headers;
   }
#endif

SOURCE_BINARY_FILE_SECTION_HEADER_LIST_END

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_START

#if 0
const SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers() const
   {
     return p_program_headers;
   }

SgAsmProgramHeaderPtrList &
SgAsmProgramHeaderList::get_program_headers()
   {
     return p_program_headers;
   }
#endif

SOURCE_BINARY_FILE_PROGRAM_HEADER_LIST_END



HEADER_BINARY_X86_INSTRUCTION_START
	public:
		/* These virtual functions are implemented in DisassemblerX86.C */
		virtual bool terminatesBasicBlock();
		virtual bool is_function_call(const std::vector<SgAsmInstruction*>&, rose_addr_t *target);
		virtual bool is_function_return(const std::vector<SgAsmInstruction*>&);
		virtual bool has_effect();
		virtual bool has_effect(const std::vector<SgAsmInstruction*>&, bool allow_branch=false,
				        bool relax_stack_semantics=false);
		virtual std::vector<std::pair<size_t,size_t> >
		    find_noop_subsequences(const std::vector<SgAsmInstruction*>& insns, bool allow_branch=false,
					   bool relax_stack_semantics=false);
		virtual std::set<rose_addr_t> get_successors(bool* complete);
		virtual std::set<rose_addr_t> get_successors(const std::vector<SgAsmInstruction*>&, bool* complete);
HEADER_BINARY_X86_INSTRUCTION_END



HEADER_BINARY_POWERPC_INSTRUCTION_START
	public:
		/* These virtual functions are implemented in DisassemblerPowerpc.C */
		virtual bool terminatesBasicBlock();
		virtual std::set<rose_addr_t> get_successors(bool* complete);
HEADER_BINARY_POWERPC_INSTRUCTION_END



HEADER_BINARY_ARM_INSTRUCTION_START
	public:
		/* These virtual functions are implemented in DisassemblerArm.C */
		virtual bool terminatesBasicBlock();
		virtual std::set<rose_addr_t> get_successors(bool* complete);
HEADER_BINARY_ARM_INSTRUCTION_END



HEADER_BINARY_DECLARATION_START
HEADER_BINARY_DECLARATION_END


HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );	
HEADER_BINARY_RET_END


HEADER_BINARY_FUNCTION_CALL_START
HEADER_BINARY_FUNCTION_CALL_END

HEADER_BINARY_BLOCK_START
        void append_statement( SgAsmStatement* statement );
        void remove_statement( SgAsmStatement* statement );
        void remove_children (  );
        rose_addr_t get_fallthrough_va(); /*implemented in Disassembler.C*/
HEADER_BINARY_BLOCK_END



HEADER_BINARY_OPERAND_LIST_START
          void append_operand( SgAsmExpression* operand );
HEADER_BINARY_OPERAND_LIST_END



HEADER_BINARY_FUNCTION_DECLARATION_START
	int nrOfValidInstructions(std::vector<SgNode*>& succs);
	//void append_block(SgAsmBlock* operand);
	void append_statement(SgAsmStatement* statement);
	void remove_statement(SgAsmStatement* statement);
	void append_dest(SgAsmStatement* instruction);
	void remove_children();

   std::string get_functionReasonString();

	/** Reasons why an instruction might be considered the beginning of a function. These bit flags are also used by
	 *  the instruction partitioner (Partitioner class) to determine what heuristics are used when partitioning
	 *  instructions into functions. */
        enum FunctionReason {
                FUNC_NONE        = 0x000,               /**< Used for initialization; not a bit flag */
                FUNC_ENTRY_POINT = 0x001,               /**< An entry point specified in the file header */
                FUNC_CALL_TARGET = 0x002,               /**< Target of a CALL-like instruction */
                FUNC_EH_FRAME    = 0x004,               /**< Address mentioned in the ELF .eh_frame section */
                FUNC_SYMBOL      = 0x008,               /**< Address of a function symbol in a symbol table */
                FUNC_PATTERN     = 0x010,               /**< Appears to be a function based on pattern of instructions */
                FUNC_GRAPH       = 0x020,               /**< Implied by inter-basicblock branching */
                FUNC_USERDEF     = 0x040,               /**< User-defined algorithm. See Partitioner::addFunctionDetector(). */
		FUNC_INTERPAD    = 0x080,		/**< Created to represent NOP padding between other functions. */
		FUNC_DISCONT     = 0x100,		/**< Blocks of function are not contiguous in memory. */
		FUNC_INSNHEAD    = 0x200,		/**< For initial instructions not in any other function (is always run) */
		FUNC_IMPORT      = 0x400,		/**< Functions dynamically linked */
		FUNC_LEFTOVERS   = 0x800,		/**< Generated function to hold blocks that are otherwise not part of
							 *   any function.  If this bit is turned off then the instruction
							 *   Partitioner will delete instructions that it couldn't assign to
							 *   a function. */
                FUNC_DEFAULT     = 0xfff                /**< Default value for Partitioner class */
        };

      /** Returns a very short string describing the reason mask. */
          std::string reason_str(bool pad) const;
          static std::string reason_str(bool pad, unsigned reason);

      //! enum declaration as specified in proposed Sabre database schema
          enum function_kind_enum {
               e_unknown  = 0,
               e_standard = 1,
               e_library  = 2,
               e_imported = 3,
               e_thunk	   = 4,
               e_last
             };

      //! enum declaration to specify type of calling convention used.
          enum function_calling_convention_enum {
       // Note that there are additional modes: syscall, optlink, pascal, register, 
       // Microsoft fastcall, Borland fastcall, Watcom register based calling convention, 
       // Topspeed/Clarion/JPI, safecall, etc.  More info is available at:
       //    http://en.wikipedia.org/wiki/X86_calling_conventions
               e_unknown_call  = 0,
               e_std_call      = 1,
               e_fast_call     = 2,
               e_cdecl_call    = 3,
               e_this_call	    = 4,
               e_last_call
             };

      //! Computes the calling convention used in this function (used to score properly formed functions).
          function_calling_convention_enum get_functionCallingConvention() const;

      //! Computes the offset of the stack at the end of the call relative the the start of the call (in a perfect function this would be zero, this is used to score properly formed functions).
          int get_stackNutralityMetric() const;

      //! Computes the number of paths determined to no return (all paths returning metric)
          int get_numberOfPathsNotReturningMetric() const;

      //! Compute the percentage of coverage based on the length of blocks in this disassembled function (in bytes) compared 
      //! to the size of the address range of the top of the first block in memory to the end of the last block in memory.
          // PC (05/16/2010): Commented out as no definition exists
          // double get_disassembledInstructionCoverageMetricForAddressRangeOfBlocks() const;

HEADER_BINARY_FUNCTION_DECLARATION_END



HEADER_BINARY_DATA_STRUCTURE_START
          void append_declaration( SgAsmDeclaration* declaration );

       // SgAsmDeclarationPtrList & get_declarationList();

     protected:

          SgAsmDeclarationPtrList p_declarationList;

     public:
HEADER_BINARY_DATA_STRUCTURE_END



HEADER_BINARY_EXPRESSION_START
	/* NOTE: This is for SgAsmExpression, not SgAsmBinaryExpression */

	//! Generate the type for the expression
	virtual SgAsmType* get_type();

	//! Return the precedence of the operator (see C and C++ examples for details)
	//  virtual int get_precedence();
HEADER_BINARY_EXPRESSION_END



HEADER_BINARY_TYPE_START

       // static SgAsmType* createType();

HEADER_BINARY_TYPE_END

HEADER_BINARY_TYPE_BYTE_START
          static SgAsmTypeByte* createType();
HEADER_BINARY_TYPE_BYTE_END

HEADER_BINARY_TYPE_WORD_START
          static SgAsmTypeWord* createType();
HEADER_BINARY_TYPE_WORD_END

HEADER_BINARY_TYPE_DOUBLE_WORD_START
          static SgAsmTypeDoubleWord* createType();
HEADER_BINARY_TYPE_DOUBLE_WORD_END

HEADER_BINARY_TYPE_QUAD_WORD_START
          static SgAsmTypeQuadWord* createType();
HEADER_BINARY_TYPE_QUAD_WORD_END

HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_START
          static SgAsmTypeDoubleQuadWord* createType();
HEADER_BINARY_TYPE_DOUBLE_QUAD_WORD_END

HEADER_BINARY_TYPE_SINGLE_FLOAT_START
          static SgAsmTypeSingleFloat* createType();
HEADER_BINARY_TYPE_SINGLE_FLOAT_END

HEADER_BINARY_TYPE_DOUBLE_FLOAT_START
          static SgAsmTypeDoubleFloat* createType();
HEADER_BINARY_TYPE_DOUBLE_FLOAT_END

HEADER_BINARY_TYPE_VECTOR_START
          static SgAsmTypeVector* createType(int elementCount, SgAsmType* elementType);
HEADER_BINARY_TYPE_VECTOR_END

HEADER_BINARY_TYPE_80bit_FLOAT_START
          static SgAsmType80bitFloat* createType();
HEADER_BINARY_TYPE_80bit_FLOAT_END

HEADER_BINARY_TYPE_128bit_FLOAT_START
          static SgAsmType128bitFloat* createType();
HEADER_BINARY_TYPE_128bit_FLOAT_END



HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_START
	// Note that the auto-generated version of this is const
        virtual SgAsmType* get_type();
HEADER_BINARY_REGISTER_REFERENCE_EXPRESSION_END



HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

       // DQ (10/28/2009): Added enum values to replace magin number vlues where will confusing in the source code.
      /*! \brief Register names for lower byte registers. 
       */
          enum regnames8l_enum
             {
            // e_regname8l_error      =  0 /*! Register name: error */,
               e_al                   =  0 /*! Register name: al    */,
               e_cl                   =  1 /*! Register name: cl    */,
               e_dl                   =  2 /*! Register name: dl    */,
               e_bl                   =  3 /*! Register name: bl    */,
               e_spl                  =  4 /*! Register name: spl   */,
               e_bpl                  =  5 /*! Register name: bpl   */,
               e_sil                  =  6 /*! Register name: sil   */,
               e_dil                  =  7 /*! Register name: dil   */,
               e_r8b                  =  8 /*! Register name: r8b   */,
               e_r9b                  =  9 /*! Register name: r9b   */,
               e_r10b                 = 10 /*! Register name: r10b  */,
               e_r11b                 = 11 /*! Register name: r11b  */,
               e_r12b                 = 12 /*! Register name: r12b  */,
               e_r13b                 = 13 /*! Register name: r13b  */,
               e_r14b                 = 14 /*! Register name: r14b  */,
               e_r15b                 = 15 /*! Register name: r15b  */,
               e_regname8l_last_value      /*! last value           */
             };

      /*! \brief Register names for high byte registers. 
       */
          enum regnames8h_enum
             {
            // e_regname8h_error      = 0 /*! Register name: error */,
               e_ah                   = 0 /*! Register name: ah    */,
               e_ch                   = 1 /*! Register name: ch    */,
               e_dh                   = 2 /*! Register name: dh    */,
               e_bh                   = 3 /*! Register name: bh    */,
               e_regname8h_last_value     /*! last value           */
             };

      /*! \brief Register names for 16 bit width registers. 
       */
          enum regnames16_enum
             {
            // e_regname16_error      =  0 /*! Register name: error */,
               e_ax                   =  0 /*! Register name: ax    */,
               e_cx                   =  1 /*! Register name: cx    */,
               e_dx                   =  2 /*! Register name: dx    */,
               e_bx                   =  3 /*! Register name: bx    */,
               e_sp                   =  4 /*! Register name: sp    */,
               e_bp                   =  5 /*! Register name: bp    */,
               e_si                   =  6 /*! Register name: si    */,
               e_di                   =  7 /*! Register name: di    */,
               e_r8w                  =  8 /*! Register name: r8w   */,
               e_r9w                  =  9 /*! Register name: r9w   */,
               e_r10w                 = 10 /*! Register name: r10w  */,
               e_r11w                 = 11 /*! Register name: r11w  */,
               e_r12w                 = 12 /*! Register name: r12w  */,
               e_r13w                 = 13 /*! Register name: r13w  */,
               e_r14w                 = 14 /*! Register name: r14w  */,
               e_r15w                 = 15 /*! Register name: r15w  */,
               e_regname16_last_value      /*! last value           */
             };

      /*! \brief Register names for 32 bit width registers. 
       */
          enum regnames32_enum
             {
            // e_regname32_error      =  0 /*! Register name: error */,
               e_eax                  =  0 /*! Register name: eax   */,
               e_ecx                  =  1 /*! Register name: ecx   */,
               e_edx                  =  2 /*! Register name: edx   */,
               e_ebx                  =  3 /*! Register name: ebx   */,
               e_esp                  =  4 /*! Register name: esp   */,
               e_ebp                  =  5 /*! Register name: ebp   */,
               e_esi                  =  6 /*! Register name: esi   */,
               e_edi                  =  7 /*! Register name: edi   */,
               e_r8d                  =  8 /*! Register name: r8d   */,
               e_r9d                  =  9 /*! Register name: r9d   */,
               e_r10d                 = 10 /*! Register name: r10d  */,
               e_r11d                 = 11 /*! Register name: r11d  */,
               e_r12d                 = 12 /*! Register name: r12d  */,
               e_r13d                 = 13 /*! Register name: r13d  */,
               e_r14d                 = 14 /*! Register name: r14d  */,
               e_r15d                 = 15 /*! Register name: r15d  */,
               e_regname32_last_value      /*! last value           */
             };

      /*! \brief Register names for 64 bit width registers. 
       */
          enum regnames64_enum
             {
            // e_regname64_error      =  0 /*! Register name: error */,
               e_rax                  =  0 /*! Register name: rax   */,
               e_rcx                  =  1 /*! Register name: rcx   */,
               e_rdx                  =  2 /*! Register name: rdx   */,
               e_rbx                  =  3 /*! Register name: rbx   */,
               e_rsp                  =  4 /*! Register name: rsp   */,
               e_rbp                  =  5 /*! Register name: rbp   */,
               e_rsi                  =  6 /*! Register name: rsi   */,
               e_rdi                  =  7 /*! Register name: rdi   */,
               e_r8                   =  8 /*! Register name: r8    */,
               e_r9                   =  9 /*! Register name: r9    */,
               e_r10                  = 10 /*! Register name: r10   */,
               e_r11                  = 11 /*! Register name: r11   */,
               e_r12                  = 12 /*! Register name: r12   */,
               e_r13                  = 13 /*! Register name: r13   */,
               e_r14                  = 14 /*! Register name: r14   */,
               e_r15                  = 15 /*! Register name: r15   */,
               e_regname64_last_value      /*! last value           */
             };

      /*! \brief Segment register names.
       */
          enum segregnames_enum
             {
            // e_segregnames_error    = 0 /*! Segment register name: error */,
               e_es                   = 0 /*! Segment register name: es    */,
               e_cs                   = 1 /*! Segment register name: cs    */,
               e_ss                   = 2 /*! Segment register name: ss    */,
               e_ds                   = 3 /*! Segment register name: ds    */,
               e_fs                   = 4 /*! Segment register name: fs    */,
               e_gs                   = 5 /*! Segment register name: gs    */,
               e_segregnames_last_value     /*! last value           */
             };

      /*! Function to generate register string names for low byte registers.
       */
          std::string get_regnames8l(regnames8l_enum n);

      /*! Function to generate register string names for high byte registers.
       */
          std::string get_regnames8h(regnames8h_enum n);

      /*! Function to generate register string names for 16 bit width registers.
       */
          std::string get_regnames16(regnames16_enum n);

      /*! Function to generate register string names for 32 bit width registers.
       */
          std::string get_regnames32(regnames32_enum n);

      /*! Function to generate register string names for 64 bit width registers.
       */
          std::string get_regnames64(regnames64_enum n);

      /*! Function to generate segment register string names registers.
       */
          std::string get_segregnames(segregnames_enum n);

       // Note that the auto-generated version of this is const
          virtual SgAsmType* get_type();

	SgAsmx86RegisterReferenceExpression(X86RegisterClass regcls, int regnum, X86PositionInRegister pos_size);
	SgAsmx86RegisterReferenceExpression(const RegisterDescriptor&);

HEADER_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END



HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START
	enum arm_suffix_field_enum {
		undefined_position_in_suffix = 0, /*!< unknown (error or unitialized value) */
		c = 1, // control field mask bit
		x = 2, // extension field mask bit
		s = 4, // status field mask bit
		f = 8, // flags field mask bit
		last_position_in_suffix
	};

	SgAsmArmRegisterReferenceExpression(const RegisterDescriptor &rdesc) {
		p_descriptor = rdesc;
	}

	// Note that the auto-generated version of this is const
	virtual SgAsmType* get_type();
HEADER_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END



HEADER_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_START
	SgAsmPowerpcRegisterReferenceExpression(const RegisterDescriptor &rdesc) {
		p_descriptor = rdesc;
	}

	// Note that the auto-generated version of this is const
	virtual SgAsmType* get_type();
HEADER_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_END



HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_START

             // Note that the auto-generated version of this is const
             virtual SgAsmType* get_type();

HEADER_BINARY_MEMORY_REFERENCE_EXPRESSION_END



// ************************************
//           DWARF SUPPORT
// ************************************

HEADER_DWARF_INFORMATION_START
HEADER_DWARF_INFORMATION_END

HEADER_DWARF_COMPILATION_UNIT_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_COMPILATION_UNIT_END

HEADER_DWARF_COMPILATION_UNIT_LIST_START
HEADER_DWARF_COMPILATION_UNIT_LIST_END

HEADER_DWARF_MACRO_START
HEADER_DWARF_MACRO_END

HEADER_DWARF_LINE_START
HEADER_DWARF_LINE_END

HEADER_DWARF_MACRO_LIST_START
HEADER_DWARF_MACRO_LIST_END

HEADER_DWARF_LINE_LIST_START

       // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
      //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
          static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

      //! Output information about instruction address <--> source position
          void display( const std::string & label );

          static std::pair<uint64_t,uint64_t> instructionRange();
          static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

          static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
          static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );

HEADER_DWARF_LINE_LIST_END

HEADER_DWARF_CONSTRUCT_START

     public:
      //! Factory pattern to build IR nodes based on the tag
          static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

          virtual SgAsmDwarfConstructList* get_children();

HEADER_DWARF_CONSTRUCT_END

HEADER_DWARF_CONSTRUCT_LIST_START
HEADER_DWARF_CONSTRUCT_LIST_END

HEADER_DWARF_SUBPROGRAM_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_SUBPROGRAM_END

HEADER_DWARF_STRUCTURE_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_STRUCTURE_TYPE_END

HEADER_DWARF_ARRAY_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_ARRAY_TYPE_END

HEADER_DWARF_LEXICAL_BLOCK_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_LEXICAL_BLOCK_END


HEADER_DWARF_INLINED_SUBROUTINE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_INLINED_SUBROUTINE_END

HEADER_DWARF_ENUMERATION_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_ENUMERATION_TYPE_END

HEADER_DWARF_SUBROUTINE_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_SUBROUTINE_TYPE_END

HEADER_DWARF_UNION_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_UNION_TYPE_END

HEADER_DWARF_NAMESPACE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_NAMESPACE_END

HEADER_DWARF_CLASS_TYPE_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_CLASS_TYPE_END

HEADER_DWARF_COMMON_BLOCK_START

     public:
          SgAsmDwarfConstructList* get_children();

HEADER_DWARF_COMMON_BLOCK_END


/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */


SOURCE_BINARY_FILE_START
SOURCE_BINARY_FILE_END

SOURCE_BINARY_BLOCK_START
void
SgAsmBlock::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmBlock::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmBlock::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }

SOURCE_BINARY_BLOCK_END



SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END


SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmDataStructureDeclaration::append_declaration( SgAsmDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END


SOURCE_BINARY_FUNCTION_DECLARATION_START
int 
SgAsmFunctionDeclaration::nrOfValidInstructions( std::vector<SgNode*>& succs  ) {
//  std::vector<SgNode*> succs = this->get_traversalSuccessorContainer();
  std::vector<SgNode*>::reverse_iterator j = succs.rbegin();
  int instructions = succs.size();
  bool foundRet=false;
  bool nodeOtherThanNopAfterRetExists=false;	
/*
  if (j!=succs.begin())
    j--;
  else
    return 0;
*/
  for (;j!=succs.rend(); j++) {
     SgAsmx86Instruction* n = isSgAsmx86Instruction(*j);
     if (n && (n->get_kind() == x86_ret || n->get_kind() == x86_hlt)) {
          foundRet=true;
          break;
    } else {
       if (n && n->get_kind() != x86_nop) {
          nodeOtherThanNopAfterRetExists= true;
       }
       instructions--;
    }
  }
  if (!foundRet)
     instructions = succs.size();
  // if we find a return and there are NOPs following it somewhere,
  // we cut off the CFG at the NOP but we keep valid instructions
  // after the RET
  if (foundRet)
    if (nodeOtherThanNopAfterRetExists)
      return succs.size();
   
  return instructions;
}

void
SgAsmFunctionDeclaration::remove_children(  )
   {
     p_statementList.clear();
   }

void
SgAsmFunctionDeclaration::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

void
SgAsmFunctionDeclaration::append_statement( SgAsmStatement* statement )
   {
     p_statementList.push_back(statement);
   }

void
SgAsmFunctionDeclaration::remove_statement( SgAsmStatement* statement )
   {
     SgAsmStatementPtrList::iterator l = p_statementList.begin();
     for (;l!=p_statementList.end();l++) {
	SgAsmStatement* st = *l;
	if (st==statement) {
             break;
        }
     }	
	if (l!=p_statementList.end())
            p_statementList.erase(l);
   }


/*
void
SgAsmFunctionDeclaration::append_block( SgAsmBlock* operand )
   {
     p_body.push_back(operand);
   }
*/

// DQ (4/29/2010): Added function to return string for function reason field (for debugging).
string
SgAsmFunctionDeclaration::get_functionReasonString ()
   {
#if 0
     enum FunctionReason {
          FUNC_NONE        = 0x000,  /**< Used for initialization; not a bit flag */
          FUNC_ENTRY_POINT = 0x001,  /**< An entry point specified in the file header */
          FUNC_CALL_TARGET = 0x002,  /**< Target of a CALL-like instruction */
          FUNC_EH_FRAME    = 0x004,  /**< Address mentioned in the ELF .eh_frame section */
          FUNC_SYMBOL      = 0x008,  /**< Address of a function symbol in a symbol table */
          FUNC_PATTERN     = 0x010,  /**< Appears to be a function based on pattern of instructions */
          FUNC_GRAPH       = 0x020,  /**< Implied by inter-basicblock branching */
          FUNC_USERDEF     = 0x040,  /**< User-defined algorithm. See Partitioner::addFunctionDetector(). */
          FUNC_INTERPAD    = 0x080,  /**< Created to represent NOP padding between other functions. */
          FUNC_DISCONT     = 0x100,  /**< Blocks of function are not contiguous in memory. */
          FUNC_INSNHEAD    = 0x200,  /**< For initial instructions not in any other function (is always run) */
          FUNC_DEFAULT     = 0x3ff   /**< Default value for Partitioner class */
#endif

     string s;

     unsigned int reason = this->get_reason();
  // printf ("reason = %u \n",reason);
     for (unsigned i = 0; i < sizeof(FunctionReason) * 8; i++)
        {
          unsigned x = (1 << i) & reason;
          switch (x)
             {
            // case FUNC_NONE:        s += "FUNC_NONE ";        break;
               case FUNC_ENTRY_POINT: s += "FUNC_ENTRY_POINT "; break;
               case FUNC_CALL_TARGET: s += "FUNC_CALL_TARGET "; break;
               case FUNC_EH_FRAME:    s += "FUNC_EH_FRAME ";    break;
               case FUNC_SYMBOL:      s += "FUNC_SYMBOL ";      break;
               case FUNC_PATTERN:     s += "FUNC_PATTERN ";     break;
               case FUNC_GRAPH:       s += "FUNC_GRAPH ";       break;
               case FUNC_USERDEF:     s += "FUNC_USERDEF ";     break;
               case FUNC_INTERPAD:    s += "FUNC_INTERPAD ";    break;
               case FUNC_DISCONT:     s += "FUNC_DISCONT ";     break;
               case FUNC_INSNHEAD:    s += "FUNC_INSNHEAD ";    break;
               case FUNC_LEFTOVERS:   s += "FUNC_LEFTOVERS ";   break;
            // case FUNC_DEFAULT:     s += "FUNC_DEFAULT ";     break;

               default:
                  {
                 // Nothing to do here!
                  }
             }
        }

  // Output NONE if nothing was set
     if (s.empty() == true)
        {
       // s = "FUNC_NONE";
          s = "no bit flags set";
        }

     return s;
   }


// DQ (4/29/2010): Added function to support scoring functions as likely valid functions (work with CERT).
SgAsmFunctionDeclaration::function_calling_convention_enum
SgAsmFunctionDeclaration::get_functionCallingConvention() const
   {
  // This function classifies the calling convention used and contributes to a scoring of functions as valid functions.

     printf ("Error: This SgAsmFunctionDeclaration::get_functionCallingConvention() function is not yet implemented. \n");
     ROSE_ASSERT(false);

     return e_unknown_call;
   }

// DQ (4/29/2010): Added function to support scoring functions as likely valid functions (work with CERT).
int
SgAsmFunctionDeclaration::get_stackNutralityMetric() const
   {
  // This function computes the positon of the stack at the end of the function relative to the 
  // start of the function and contributes to a scoring of functions as valid functions.

     printf ("Error: This SgAsmFunctionDeclaration::get_stackNutralityMetric() function is not yet implemented. \n");
     ROSE_ASSERT(false);

     return 0;
   }

// DQ (4/29/2010): Added function to support scoring functions as likely valid functions (work with CERT).
int
SgAsmFunctionDeclaration::get_numberOfPathsNotReturningMetric() const
   {
  // This function computes the number of paths determined to no return (all paths returning metric)

     printf ("Error: This SgAsmFunctionDeclaration::get_numberOfPathsNotReturningMetric() function is not yet implemented. \n");
     ROSE_ASSERT(false);

     return 0;
   }

SOURCE_BINARY_FUNCTION_DECLARATION_END


SOURCE_BINARY_INSTRUCTION_START

void
SgAsmInstruction::append_sources( SgAsmInstruction* inst )
   {
     p_sources.push_back(inst);
   }

SgAsmInstruction*
SgAsmInstruction::cfgBinFlowOutEdge(const VirtualBinCFG::AuxiliaryInformation* info) {
  if (!isAsmUnconditionalBranch(this)) {
    SgAsmInstruction* next = info->getInstructionAtAddress(this->get_address() + this->get_raw_bytes().size());
    return next;
  }
  return NULL;
}

std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinOutEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  //cerr << "cfgBinOutEdges: " << std::hex << this->get_address() << " " << (isSgAsmx86Instruction(this) ? "x86" : "unknown") << " " << (isSgAsmx86Instruction(this) ? toString(isSgAsmx86Instruction(this)->get_kind()) : "") << endl;
  std::vector<VirtualBinCFG::CFGEdge> result;
  uint64_t nextAddr = this->get_address() + this->get_raw_bytes().size();

  if (isAsmBranch(this)) {
    //cout << "Found branch" << endl;
    uint64_t addr = 0;
    bool knownTarget = getAsmKnownBranchTarget(this, addr);
    if (knownTarget) {
      //cout << "Has known target " << std::hex << addr << endl;
      SgAsmInstruction* tgt = info->getInstructionAtAddress(addr);
      if (tgt) {
        makeEdge(this, tgt, info, result);
      }
    } else { // Unknown target
      //cout << "Unknown target" << endl;
      const std::set<uint64_t> successorAddrs = info->getPossibleSuccessors(this);
      for (std::set<uint64_t>::const_iterator i = successorAddrs.begin(); i != successorAddrs.end(); ++i) {
        //cout << "Found succ address " << std::hex << *i << endl;
        SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
        if (tgt) {
          makeEdge(this, tgt, info, result);
        }
      }
#if 0
      if (successorAddrs.empty()) {
	// FIXME: For bug-compatibility with old version
	SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
	if (next) makeEdge(this, next, info, result);
      }
#endif
    } // else
  } // if

  if ((!isSgAsmx86Instruction(this) || (isSgAsmx86Instruction(this)->get_kind() != x86_ret && isSgAsmx86Instruction(this)->get_kind() != x86_hlt)) /* || !isAsmUnconditionalBranch(this) || (isSgAsmx86Instruction(this) && isSgAsmx86Instruction(this)->get_kind() == x86_call) */ ) {
    //cout << "Next insn is at " << std::hex << nextAddr << endl;
    SgAsmInstruction* next = info->getInstructionAtAddress(nextAddr);
    //ROSE_ASSERT (next);
    if (next) makeEdge(this, next, info, result);
  }

  return result;
}


std::vector<VirtualBinCFG::CFGEdge>
SgAsmInstruction::cfgBinInEdges(const VirtualBinCFG::AuxiliaryInformation* info) {
  std::vector<VirtualBinCFG::CFGEdge> result;
  const std::set<uint64_t>& preds = info->getPossiblePredecessors(this);
  for (std::set<uint64_t>::const_iterator i = preds.begin(); i != preds.end(); ++i) {
    SgAsmInstruction* tgt = info->getInstructionAtAddress(*i);
    if (tgt) {
      makeEdge(this, tgt, info, result);
    }
  }
  return result;
}

SOURCE_BINARY_INSTRUCTION_END

SOURCE_BINARY_X86_INSTRUCTION_START

SOURCE_BINARY_X86_INSTRUCTION_END


SOURCE_BINARY_EXPRESSION_START

SgAsmType* SgAsmExpression::get_type() {
  ROSE_ASSERT (!"Cannot get the type of this SgAsmExpression");
	// tps (12/9/2009) : MSC requires a return value
     return NULL;
}

SOURCE_BINARY_EXPRESSION_END

SOURCE_BINARY_TYPE_START
SOURCE_BINARY_TYPE_END

SOURCE_BINARY_TYPE_BYTE_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_BYTE_END

SOURCE_BINARY_TYPE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_WORD_END

SOURCE_BINARY_TYPE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_QUAD_WORD_END

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_QUAD_WORD_END

SOURCE_BINARY_TYPE_SINGLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_SINGLE_FLOAT_END

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_START

$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}

SOURCE_BINARY_TYPE_DOUBLE_FLOAT_END


SOURCE_BINARY_TYPE_80bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_80bit_FLOAT_END


SOURCE_BINARY_TYPE_128bit_FLOAT_START
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// This is from the version for non-asm types
$CLASSNAME* $CLASSNAME::createType() {
  if (p_builtin_type == NULL) {
    p_builtin_type = new $CLASSNAME();
    ROSE_ASSERT(p_builtin_type != NULL);
  }
  return p_builtin_type;
}
       
SOURCE_BINARY_TYPE_128bit_FLOAT_END


SOURCE_BINARY_TYPE_VECTOR_START

$CLASSNAME* $CLASSNAME::createType(int elementCount, SgAsmType* elementType) {
  // This does not need to be saved during file I/O, so it doesn't need to be a
  // class member
  static std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*> cache;
  std::pair<int, SgAsmType*> vectorInfo(elementCount, elementType);
  std::map<std::pair<int, SgAsmType*>, SgAsmTypeVector*>::const_iterator i = cache.find(vectorInfo);
  if (i != cache.end()) {
    return i->second;
  } else {
    SgAsmTypeVector* tv = new SgAsmTypeVector(elementCount, elementType);
    cache.insert(std::make_pair(vectorInfo, tv));
    return tv;
  }
}

SOURCE_BINARY_TYPE_VECTOR_END


SOURCE_BINARY_NODE_START

SOURCE_BINARY_NODE_END

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeByte::createType();
}

SOURCE_BINARY_BYTE_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleFloat::createType();
}

SOURCE_BINARY_DOUBLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeDoubleWord::createType();
}

SOURCE_BINARY_DOUBLE_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeQuadWord::createType();
}

SOURCE_BINARY_QUAD_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeSingleFloat::createType();
}

SOURCE_BINARY_SINGLE_FLOAT_VALUE_EXPRESSION_END

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmVectorValueExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_VECTOR_VALUE_EXPRESSION_END

SOURCE_BINARY_WORD_VALUE_EXPRESSION_START

SgAsmType* $CLASSNAME::get_type() {
  return SgAsmTypeWord::createType();
}

SOURCE_BINARY_WORD_VALUE_EXPRESSION_END

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmRegisterReferenceExpression::get_type() {
  ROSE_ASSERT (false);
	// tps (12/9/2009) : MSC requires a return value
     return NULL;
  
}

SOURCE_BINARY_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_START

SgAsmx86RegisterReferenceExpression::SgAsmx86RegisterReferenceExpression(const RegisterDescriptor &rdesc) {
	p_descriptor = rdesc;
}

SgAsmx86RegisterReferenceExpression::SgAsmx86RegisterReferenceExpression(X86RegisterClass regcls, int regnum,
	X86PositionInRegister pos_size)
	: SgAsmRegisterReferenceExpression() {
	RegisterDescriptor rdesc;
	rdesc.set_major(regcls);
	rdesc.set_minor(regnum);
	switch (pos_size) {
		case x86_regpos_unknown:
			rdesc.set_offset(0);
			rdesc.set_nbits(0);
			break;
		case x86_regpos_low_byte:
			rdesc.set_offset(0);
			rdesc.set_nbits(8);
			break;
		case x86_regpos_high_byte:
			rdesc.set_offset(8);
			rdesc.set_nbits(8);
			break;
		case x86_regpos_word:
			rdesc.set_offset(0);
			rdesc.set_nbits(16);
			break;
		case x86_regpos_dword:
			rdesc.set_offset(0);
			rdesc.set_nbits(32);
			break;
		case x86_regpos_qword:
			rdesc.set_offset(0);
			rdesc.set_nbits(64);
			break;
		case x86_regpos_all:
			ROSE_ASSERT(!"we need to know an actual size");
	}
	p_descriptor = rdesc;
}

std::string
SgAsmx86RegisterReferenceExpression::get_regnames8l(regnames8l_enum n)
   {
     const char* regnames8l[16] = {"al", "cl", "dl", "bl", "spl", "bpl", "sil", "dil", "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b", "r15b"};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_regname8l_last_value);
     return regnames8l[n]; // offset to account for error value in enum
   }

std::string
SgAsmx86RegisterReferenceExpression::get_regnames8h(regnames8h_enum n)
   {
     const char* regnames8h[16] = {"ah", "ch", "dh", "bh", "", "", "", "", "", "", "", "", "", "", "", ""};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_regname8h_last_value);
     return regnames8h[n]; // offset to account for error value in enum
   }

std::string
SgAsmx86RegisterReferenceExpression::get_regnames16(regnames16_enum n)
   {
     const char* regnames16[16] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di", "r8w", "r9w", "r10w", "r11w", "r12w", "r13w", "r14w", "r15w"};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_regname16_last_value);
     return regnames16[n]; // offset to account for error value in enum
   }

std::string
SgAsmx86RegisterReferenceExpression::get_regnames32(regnames32_enum n)
   {
     const char* regnames32[16] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi", "r8d", "r9d", "r10d", "r11d", "r12d", "r13d", "r14d", "r15d"};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_regname32_last_value);
     return regnames32[n]; // offset to account for error value in enum
   }

std::string
SgAsmx86RegisterReferenceExpression::get_regnames64(regnames64_enum n)
   {
     const char* regnames64[16] = {"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_regname64_last_value);
     return regnames64[n]; // offset to account for error value in enum
   }

std::string
SgAsmx86RegisterReferenceExpression::get_segregnames(segregnames_enum n)
   {
     const char* segregnames[6] = {"es", "cs", "ss", "ds", "fs", "gs"};
     ROSE_ASSERT(n >= 0);
     ROSE_ASSERT(n < e_segregnames_last_value);
     return segregnames[n]; // offset to account for error value in enum
   }

// Note that the auto-generated version of this is const
SgAsmType* SgAsmx86RegisterReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_X86_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmArmRegisterReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_ARM_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType*
SgAsmPowerpcRegisterReferenceExpression::get_type()
   {
     return p_type;
   }

SOURCE_BINARY_POWERPC_REGISTER_REFERENCE_EXPRESSION_END

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_START

// Note that the auto-generated version of this is const
SgAsmType* SgAsmMemoryReferenceExpression::get_type() {
  return p_type;
}

SOURCE_BINARY_MEMORY_REFERENCE_EXPRESSION_END










// *************************************
//      Binary File Format Support
// *************************************

SOURCE_EXECUTABLE_FILE_FORMAT_START
SOURCE_EXECUTABLE_FILE_FORMAT_END



SOURCE_GENERIC_SECTION_START
SOURCE_GENERIC_SECTION_END



SOURCE_GENERIC_HEADER_START
const char *
SgAsmGenericHeader::format_name() const
   {
     return "ASM_GENERIC_HEADER";
   }

SgAsmGenericFormat::ByteOrder
SgAsmGenericHeader::get_sex() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_sex();
   }

size_t
SgAsmGenericHeader::get_word_size() const
   {
     ROSE_ASSERT(p_exec_format != NULL);
     return p_exec_format->get_word_size();
   }

SOURCE_GENERIC_HEADER_END

SOURCE_GENERIC_FORMAT_START
SOURCE_GENERIC_FORMAT_END

SOURCE_GENERIC_ARCHITECTURE_START
SOURCE_GENERIC_ARCHITECTURE_END

SOURCE_GENERIC_SYMBOL_START
SOURCE_GENERIC_SYMBOL_END

SOURCE_GENERIC_SYMBOL_LIST_START
SOURCE_GENERIC_SYMBOL_LIST_END

SOURCE_GENERIC_DLL_START

SgAsmGenericDLL::SgAsmGenericDLL(SgAsmGenericString *s)
    : p_name(s)
    {
	s->set_parent(this);
    }

SOURCE_GENERIC_DLL_END

SOURCE_GENERIC_DLL_LIST_START
SOURCE_GENERIC_DLL_LIST_END

SOURCE_BASIC_STRING_START
SOURCE_BASIC_STRING_END

SOURCE_GENERIC_STRING_START
SOURCE_GENERIC_STRING_END

SOURCE_STRING_STORAGE_START
SOURCE_STRING_STORAGE_END

SOURCE_STORED_STRING_START
SOURCE_STORED_STRING_END

SOURCE_ELF_HEADER_START

const char *
SgAsmElfFileHeader::format_name() const
   {
     return "ELF";
   }


SOURCE_ELF_HEADER_END

SOURCE_ELF_SECTION_TABLE_START
SOURCE_ELF_SECTION_TABLE_END



SOURCE_ELF_STRING_SECTION_START
	SgAsmElfStringSection::SgAsmElfStringSection(SgAsmElfFileHeader *fhdr)
		: SgAsmElfSection(fhdr), p_strtab(NULL)
		{ctor();}
SOURCE_ELF_STRING_SECTION_END



SOURCE_ELF_SECTION_TABLE_ENTRY_START
SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSectionTableEntry::SgAsmElfSectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SECTION_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_TABLE_ENTRY_LIST_END

SOURCE_ELF_SECTION_START
// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
SgAsmElfSection* 
SgAsmElfSection::get_linked_section () const
   {
     ROSE_ASSERT (this != NULL);
     return p_linked_section;
   }

// DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
void
SgAsmElfSection::set_linked_section ( SgAsmElfSection* linked_section )
   {
     ROSE_ASSERT (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section)
        {
          printf ("Warning: linked_section = %p overwriting valid pointer p_linked_section = %p \n",linked_section,p_linked_section);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_linked_section != NULL && linked_section != NULL && p_linked_section != linked_section) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_linked_section = linked_section;
   }

SOURCE_ELF_SECTION_END

SOURCE_ELF_STRING_TABLE_START
SOURCE_ELF_STRING_TABLE_END

SOURCE_ELF_DYNAMIC_SECTION_START
SOURCE_ELF_DYNAMIC_SECTION_END

SOURCE_ELF_DYNAMIC_ENTRY_START
SOURCE_ELF_DYNAMIC_ENTRY_END

SOURCE_ELF_SEGMENT_TABLE_START
SOURCE_ELF_SEGMENT_TABLE_END

SOURCE_ELF_SEGMENT_TABLE_ENTRY_START
SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SgAsmElfSegmentTableEntry::SgAsmElfSegmentTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_ELF_SEGMENT_TABLE_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_START
SOURCE_ELF_SEGMENT_ENTRY_END

SOURCE_ELF_SEGMENT_ENTRY_LIST_START
SOURCE_ELF_SEGMENT_ENTRY_LIST_END

SOURCE_ELF_SYMBOL_SECTION_START
SOURCE_ELF_SYMBOL_SECTION_END

SOURCE_ELF_SYMBOL_LIST_START
SOURCE_ELF_SYMBOL_LIST_END

SOURCE_ELF_SYMBOL_START
SOURCE_ELF_SYMBOL_END


SOURCE_PE_RVA_SIZE_PAIR_START
SOURCE_PE_RVA_SIZE_PAIR_END


SOURCE_PE_RVA_SIZE_PAIR_LIST_START
SOURCE_PE_RVA_SIZE_PAIR_LIST_END


SOURCE_PE_FILE_HEADER_START
SOURCE_PE_FILE_HEADER_END

SOURCE_PE_SECTION_START
SOURCE_PE_SECTION_END

SOURCE_PE_SECTION_TABLE_START
SOURCE_PE_SECTION_TABLE_END

SOURCE_PE_COFF_SYMBOL_TABLE_START
SOURCE_PE_COFF_SYMBOL_TABLE_END

SOURCE_PE_IMPORT_HINT_NAME_START
SOURCE_PE_IMPORT_HINT_NAME_END

SOURCE_PE_IMPORT_DIRECTORY_START
SOURCE_PE_IMPORT_DIRECTORY_END

SOURCE_PE_SECTION_TABLE_ENTRY_START
SgAsmPESectionTableEntry::SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_PE_SECTION_TABLE_ENTRY_END

SOURCE_PE_COFF_SYMBOL_START
SgAsmCoffSymbol::SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx)
   : p_st_name_offset(0), p_st_section_num(0), p_st_type(0), p_st_storage_class(0), p_st_num_aux_entries(0)
   {
     ctor(fhdr, symtab, strtab, idx);
   }

SOURCE_PE_COFF_SYMBOL_END

SOURCE_COFF_STRING_TABLE_START
SOURCE_COFF_STRING_TABLE_END

SOURCE_NE_FILE_HEADER_START
SOURCE_NE_FILE_HEADER_END

SOURCE_NE_SECTION_START
SOURCE_NE_SECTION_END

SOURCE_NE_SECTION_TABLE_START
SOURCE_NE_SECTION_TABLE_END

SOURCE_NE_NAME_TABLE_START
SOURCE_NE_NAME_TABLE_END

SOURCE_NE_MODULE_TABLE_START
SOURCE_NE_MODULE_TABLE_END

SOURCE_NE_STRING_TABLE_START
SOURCE_NE_STRING_TABLE_END

SOURCE_NE_ENTRY_TABLE_START
SOURCE_NE_ENTRY_TABLE_END

SOURCE_NE_RELOC_TABLE_START
SOURCE_NE_RELOC_TABLE_END



SOURCE_NE_ENTRY_POINT_START

//SgAsmNEEntryPoint::SgAsmNEEntryPoint()
//   : p_flags((SgAsmNEEntryPoint::EF_ZERO), p_int3f(0), p_section_idx(0), p_section_offset(0)
//   {}

SgAsmNEEntryPoint::SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off)
   : p_flags(flags), p_int3f(int3f), p_section_idx(s_idx), p_section_offset(s_off)
   {
   }

SOURCE_NE_ENTRY_POINT_END

SOURCE_NE_RELOC_ENTRY_START
SgAsmNERelocEntry::SgAsmNERelocEntry(SgAsmGenericSection *relocs, addr_t at, addr_t *rec_size)
   {
     ctor(relocs, at, rec_size);
   }

SOURCE_NE_RELOC_ENTRY_END

SOURCE_NE_SECTION_TABLE_ENTRY_START
SgAsmNESectionTableEntry::SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk)
   {
     ctor(disk);
   }

SOURCE_NE_SECTION_TABLE_ENTRY_END



SOURCE_LE_FILE_HEADER_START
SOURCE_LE_FILE_HEADER_END

SOURCE_LE_SECTION_START
SOURCE_LE_SECTION_END

SOURCE_LE_SECTION_TABLE_START
SOURCE_LE_SECTION_TABLE_END

SOURCE_LE_NAME_TABLE_START
SOURCE_LE_NAME_TABLE_END

SOURCE_LE_PAGE_TABLE_START
SOURCE_LE_PAGE_TABLE_END

SOURCE_LE_ENTRY_TABLE_START
SOURCE_LE_ENTRY_TABLE_END

SOURCE_LE_RELOC_TABLE_START
SOURCE_LE_RELOC_TABLE_END

SOURCE_LE_PAGE_TABLE_ENTRY_START
SgAsmLEPageTableEntry::SgAsmLEPageTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk)
   : p_pageno(0), p_flags(0)
   {
     ctor(sex, disk);
   }

SOURCE_LE_PAGE_TABLE_ENTRY_END

SOURCE_LE_ENTRY_POINT_START
SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk)
   : p_flags(0), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
     ctor(sex, disk);
   }

SgAsmLEEntryPoint::SgAsmLEEntryPoint(SgAsmExecutableFileFormat::ByteOrder sex, unsigned flags)
   : p_flags(flags), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
   }

SOURCE_LE_ENTRY_POINT_END

SOURCE_LE_SECTION_TABLE_ENTRY_START
SgAsmLESectionTableEntry::SgAsmLESectionTableEntry(SgAsmExecutableFileFormat::ByteOrder sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk)
   {
     ctor(sex, disk);
   }

SOURCE_LE_SECTION_TABLE_ENTRY_END



SOURCE_DOS_HEADER_START
SOURCE_DOS_HEADER_END



SOURCE_DWARF_INFORMATION_START
SOURCE_DWARF_INFORMATION_END

SOURCE_DWARF_COMPILATION_UNIT_START

SgAsmDwarfConstructList*
SgAsmDwarfCompilationUnit::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_language_constructs == NULL)
          p_language_constructs = new SgAsmDwarfConstructList();

     return p_language_constructs;
   }

SOURCE_DWARF_COMPILATION_UNIT_END

SOURCE_DWARF_COMPILATION_UNIT_LIST_START
SOURCE_DWARF_COMPILATION_UNIT_LIST_END

SOURCE_DWARF_MACRO_START
SOURCE_DWARF_MACRO_END

SOURCE_DWARF_LINE_START
SOURCE_DWARF_LINE_END

SOURCE_DWARF_MACRO_LIST_START
SOURCE_DWARF_MACRO_LIST_END

SOURCE_DWARF_LINE_LIST_START

DwarfInstructionSourceMapReturnType
SgAsmDwarfLineList::buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu )
   {
  // SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
  // SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;

  // Build this as static local data
     static SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = NULL;

     bool recomputeMap = false;
     if (instruction_source_code_map == NULL)
        {
          recomputeMap = true;
          instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
        }

     ROSE_ASSERT(instruction_source_code_map != NULL);

     static SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = NULL;
     if (source_code_instruction_map == NULL)
          source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;
     ROSE_ASSERT(source_code_instruction_map != NULL);

     if (recomputeMap == true)
        {
          ROSE_ASSERT(dwarf_cu != NULL);
          ROSE_ASSERT(dwarf_cu->get_line_info() != NULL);

          SgAsmDwarfLinePtrList & line_list = dwarf_cu->get_line_info()->get_line_list();

          int listSize = (int) line_list.size();
          for (int i = 0; i < listSize; i++)
             {
            // Loop over each of the entries in the Dwarf line section.
               uint64_t address = line_list[i]->get_address();

            // Note that file_id values are already in terms of the Sg_File_Info maps 
            // between file name integers and file name strings.
               int file_id      = line_list[i]->get_file_id();

               int line         = line_list[i]->get_line();
               int column       = line_list[i]->get_column();

            // printf ("address = 0x%lx file_id = %d line = %d  column = %d \n",address,file_id,line,column);

               FileIdLineColumnFilePosition file_info(file_id,std::pair<int,int>(line,column));

            // This works for stp::map, but for std::multimap
            // instruction_source_code_map->operator[](address)   = file_info;
            // source_code_instruction_map->operator[](file_info) = address;

            // This is the std::multiset version ...
               instruction_source_code_map->insert(AddressFileIdLineColumnFilePositionPair(address,file_info));
               source_code_instruction_map->insert(FileIdLineColumnFilePositionAddressPair(file_info,address));
             }
        }
       else
        {
       // printf ("Maps were computed previously \n");
        }

     DwarfInstructionSourceMapReturnType returnValue(instruction_source_code_map,source_code_instruction_map);

     return returnValue;
   }

SOURCE_DWARF_LINE_LIST_END

SOURCE_DWARF_CONSTRUCT_START

SgAsmDwarfConstructList*
SgAsmDwarfConstruct::get_children()
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("Error: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
     ROSE_ASSERT(false);
#else
     printf ("Warning: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
#endif
     return NULL;
   }

SOURCE_DWARF_CONSTRUCT_END

SOURCE_DWARF_CONSTRUCT_LIST_START
SOURCE_DWARF_CONSTRUCT_LIST_END

SOURCE_DWARF_SUBPROGRAM_START

SgAsmDwarfConstructList*
SgAsmDwarfSubprogram::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBPROGRAM_END

SOURCE_DWARF_STRUCTURE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfStructureType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_STRUCTURE_TYPE_END

SOURCE_DWARF_ARRAY_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfArrayType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ARRAY_TYPE_END


SOURCE_DWARF_LEXICAL_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfLexicalBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_LEXICAL_BLOCK_END


SOURCE_DWARF_INLINED_SUBROUTINE_START

SgAsmDwarfConstructList*
SgAsmDwarfInlinedSubroutine::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_INLINED_SUBROUTINE_END


SOURCE_DWARF_ENUMERATION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfEnumerationType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ENUMERATION_TYPE_END


SOURCE_DWARF_SUBROUTINE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfSubroutineType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBROUTINE_TYPE_END


SOURCE_DWARF_UNION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfUnionType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_UNION_TYPE_END


SOURCE_DWARF_NAMESPACE_START

SgAsmDwarfConstructList*
SgAsmDwarfNamespace::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_NAMESPACE_END


SOURCE_DWARF_CLASS_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfClassType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_CLASS_TYPE_END


SOURCE_DWARF_COMMON_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfCommonBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_COMMON_BLOCK_END


