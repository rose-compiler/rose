// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_BINARY_FILE_START
          void post_construction_initialization();
HEADER_BINARY_FILE_END






// ************************************
// NEW IR NODES FOR BINARY FILE FORMATS
// ************************************




HEADER_GENERIC_SECTION_START
        public:
                // RPM (8/27/2008): Is this right? get_offset() returns file offset; get_mapped_rva() returns memory addr*/
                // This can be mapped to the offset data member
                unsigned long get_starting_memory_address() { return get_offset(); }

                // DQ (8/7/2008): These are a few data member access functions that were required 
                // to compile when first adding the new IR nodes (these should be removed).
                unsigned long get_starting_file_offset() { return 0; }
                unsigned long get_flags() { return 0; }
                unsigned long get_type() { return 0; }


                /* Reason for section's existence. This is a union of all the section purposes from the various supported file
                 * formats.  However, at this time we're only interested in a few kinds of sections and therefore most will fall
                 * into the SP_OTHER category. */
                enum SectionPurpose {
                        SP_UNSPECIFIED,                 /* File format did not specify a reason and none could be determined */
                        SP_PROGRAM,                     /* Program-supplied data, code, etc. */
                        SP_HEADER,                      /* Section contains a header for the executable file format */
                        SP_SYMTAB,                      /* Symbol table */
                        SP_OTHER                        /* File-specified purpose other than any given in this enum */
                };

                // DQ (10/20/2010): Moved this function's definition to the source file.
                SgAsmGenericSection(SgAsmGenericFile *f, SgAsmGenericHeader *fhdr);

                // This destructor modifies the SgAsmGenericFile data to remove its section from the section list!
                virtual ~SgAsmGenericSection();

                static void dump_containing_sections(FILE *f, const std::string &prefix, rose_rva_t rva,
                        const SgAsmGenericSectionPtrList&);
                void grab_content();

                // DQ (10/20/2010): Moved this function's definition to the source file.
                virtual SgAsmGenericSection* parse();

                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                virtual bool reallocate() {return false;}
                virtual void unparse(std::ostream&) const;
                void unparse(std::ostream&, const ExtentMap&) const;
                void unparse_holes(std::ostream&) const;
                SgAsmGenericHeader *is_file_header();   /**< true if section represents a top level file header */

                /* Functions for section extent within the file */
                rose_addr_t   get_size() const;
                virtual void  set_size(rose_addr_t);            /* Resize a section w/o regard to other sections or mapping */
                rose_addr_t   get_offset() const;
                virtual void  set_offset(rose_addr_t);          /**< Move a section w/o regard to other sections or mapping */
                rose_addr_t   get_end_offset() const;           /**< file offset for end of section */
                void          extend(rose_addr_t nbytes);       /**< make section larger by extending the end */
                rose_addr_t   write(std::ostream&, rose_addr_t offset, size_t bufsize, const void *buf) const;
                rose_addr_t   write(std::ostream&, rose_addr_t offset, const std::string &str) const;
                rose_addr_t   write(std::ostream&, rose_addr_t offset, char c) const;
                rose_addr_t   write(std::ostream&, rose_addr_t offset, const SgFileContentList &buf) const;
                rose_addr_t   write(std::ostream&, rose_addr_t offset, const SgUnsignedCharList &buf) const;
                rose_addr_t   write_uleb128(unsigned char*, rose_addr_t offset, uint64_t) const;
                rose_addr_t   write_sleb128(unsigned char*, rose_addr_t offset, int64_t) const;

                /* Functions for accessing content */
                size_t read_content(rose_addr_t abs_offset, void *dst_buf, rose_addr_t size, bool strict=true);
                size_t read_content(const MemoryMap*, rose_addr_t va, void *dst_buf, rose_addr_t size, bool strict=true);
                size_t read_content(const MemoryMap *map, const rose_rva_t &rva, void *dst_buf, rose_addr_t size,
                                    bool strict=true) {
                        return read_content(map, rva.get_va(), dst_buf, size, strict);
                }
                size_t read_content_local(rose_addr_t rel_offset, void *dst_buf, rose_addr_t size, bool strict=true);
                std::string read_content_str(const MemoryMap*, rose_addr_t va, bool strict=true);
                std::string read_content_str(const MemoryMap *map, rose_rva_t rva, bool strict=true) {
                        return read_content_str(map, rva.get_va(), strict);
                }
                std::string read_content_str(rose_addr_t abs_offset, bool strict=true);
                std::string read_content_local_str(rose_addr_t rel_offset, bool strict=true);
                SgUnsignedCharList read_content_local_ucl(rose_addr_t rel_offset, rose_addr_t size); //always non-strict
                int64_t read_content_local_sleb128(rose_addr_t *rel_offset, bool strict=true);
                uint64_t read_content_local_uleb128(rose_addr_t *rel_offset, bool strict=true);
                unsigned char *writable_content(size_t nbytes); /* obtain a local, writable pool to hold content */

                /* Functions for tracking referenced/unreferenced content. The tracking actually happens at the entire file level
                 * (see functions with the same name in SgAsmGenericFile) and these functions return that same information but
                 * limit the results to this section and return section rather than file offsets. */
                AddressIntervalSet get_referenced_extents() const; /* Returns parts of the file that have been referenced */
                AddressIntervalSet get_unreferenced_extents() const; /* Returns parts of file that have not been referenced */

                /* Functions related to mapping of sections into executable memory */
                bool          is_mapped() const;                /**< True iff non-zero mapped address and size */
                void          clear_mapped();                   /**< Set mapped address and size to zero (unmapped)*/
                rose_addr_t   get_mapped_size() const;
                virtual void  set_mapped_size(rose_addr_t);     /* Set mapped size w/o regard to other section mappings */
                rose_addr_t   get_mapped_preferred_rva() const; /* The virtual address indicated in the binary file */
                virtual void  set_mapped_preferred_rva(rose_addr_t); /* Move a section w/o regard to other section mappings */
                rose_addr_t   get_base_va() const;              /* Convenience to get header's base VA */
                rose_addr_t   get_mapped_preferred_va() const;  /* Like get_mapped_preferred_rva() except returns absolute VA */
                rose_addr_t   get_va_offset(rose_addr_t va) const;/* Return file offset for specified virtual address */
                rose_addr_t   get_rva_offset(rose_addr_t rva) const;/* Return file offset for specified relative virtual address */

                /* Accessors for private members */
                SgAsmGenericString *get_name() const;           /* Same as standard ROSETTA accessor */
                void set_name(SgAsmGenericString *s);           /* Like std accessor but sets parent of 's' */
                std::string get_short_name() const;             /* Get the abbreviated name, or the real name */
                void set_short_name(const std::string&);        /* Set the abbreviated name. */

                /* Convenience functions */
                Extent get_file_extent() const;                 /* Returns get_offset() and get_size() */
                Extent get_mapped_preferred_extent() const;     /* Returns get_mapped_preferred_rva() and get_mapped_size() */
                bool align();                                   /* Increase file offset and mapping rva to satisfy constraints */

        protected:
                void ctor(SgAsmGenericFile*, SgAsmGenericHeader*);

        private:
                /** This is an optional local, writable pool for the p_data member. Normally a section will point into the pool
                 * for its SgAsmGenericFile which is memory-mapped (read-only) from the actual file being parsed. The default
                 * unparsing action is to write the original data back to the file. By allowing a section to allocate its own
                 * pool for p_data we create a very easy way to get data into the unparsed file (the alternative is to derive
                 * a new class and override the unparse() method). */
                unsigned char *local_data_pool;
HEADER_GENERIC_SECTION_END



HEADER_GENERIC_HEADER_START
        public:
                explicit SgAsmGenericHeader(SgAsmGenericFile *ef)
                        : SgAsmGenericSection(ef, NULL),
                        p_exec_format(NULL), p_isa(ISA_OTHER), p_base_va(0), p_dlls(NULL), p_sections(NULL)
                        {ctor();}

                virtual ~SgAsmGenericHeader();
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                // DQ (8/8/2008): We can't make this pure virtual since then we can't allocate this class.
                // virtual const char *format_name() = 0;
                virtual const char *format_name() const;

                /* Functions for dynamically linked libraries (DLLs) */
                void add_dll(SgAsmGenericDLL *dll);                     /* Add new DLL to list of DLLs for this file */
                std::vector<SgAsmGenericDLL*>& get_dlls() {             /* all necessary dynamically loaded libraries */
                        ROSE_ASSERT(p_dlls != NULL);
                        return p_dlls->get_dlls();
                }

                /* Accessors for protected/private members */
                std::vector<unsigned char>& get_magic() {return p_magic;}
                rose_addr_t get_entry_rva() const;
                void add_entry_rva(const rose_rva_t &rva) { p_entry_rvas.push_back(rva);}

                /* Convenience functions */
                ByteOrder::Endianness get_sex() const;
                size_t get_word_size() const;

                /* Functions for sections */
                void add_section(SgAsmGenericSection*); /* Add new section to the file; called implicitly by section ctor */
                void remove_section(SgAsmGenericSection*);            /* Remove section from the file */

                /* Section lookup functions (plural) */
                SgAsmGenericSectionPtrList get_mapped_sections() const;
                SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
                SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep=0) const;
                SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t offset, rose_addr_t size) const;
                SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t rva) const;
                SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t va, bool use_preferred) const;

                /* Section lookup functions (singular) */
                SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_offset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_rva(rose_addr_t rva, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_va(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;
                SgAsmGenericSection *get_best_section_by_va(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;

        private:
                void ctor();
HEADER_GENERIC_HEADER_END



HEADER_GENERIC_FILE_START
        public:
   // DQ (10/20/2010): This section does not have a source code block for ROSETTA to put the function definition.
                SgAsmGenericFile()
                        : p_unreferenced_cache(NULL), p_data_converter(NULL), p_dwarf_info(NULL), p_fd(-1), p_headers(NULL),
                          p_holes(NULL), p_truncate_zeros(false), p_tracking_references(true), p_neuter(false)
                        {ctor();}

                virtual ~SgAsmGenericFile();                            /* Destructor deletes children and unmaps/closes file */
                SgAsmGenericFile* parse(std::string file_name);         /* Attach an existing file for parsing */
                void reallocate();                                      /* Make consistent before calling unparse */
                void unparse(std::ostream&) const;                      /* Unparse the file -- mirror image of parsing */
                void extend_to_eof(std::ostream&) const;                /* Write zeros to logical EOF */
                void dump(FILE*) const;                                 /* Print some top-level debugging info */
                void dump_all(bool in_cwd=true, const char *ext=NULL);  /* Recursively print all known info about the file */
                void dump_all(const std::string& dumpname);             /* Recursively print all known info about the file */

                /* Tracking references */
                const AddressIntervalSet& get_unreferenced_extents() const; /* Returns parts of file that have not been referenced */
                void mark_referenced_extent(rose_addr_t start_rva, rose_addr_t size);

                /* Converting encoding/decoding data is it's transferred from/to disk. */
                void set_data_converter(DataConverter* dc) {p_data_converter=dc;}
                DataConverter* get_data_converter() const {return p_data_converter;}

                /* File contents */
                rose_addr_t get_current_size() const;                   /* Current size based on defined sections */
                rose_addr_t get_orig_size() const;                      /* Original size based on actual file size */
                size_t read_content(rose_addr_t offset, void *dst_buf, rose_addr_t size, bool strict=true);
                size_t read_content(const MemoryMap *map, rose_addr_t va, void *dst_buf, rose_addr_t size, bool strict=true);
                std::string read_content_str(const MemoryMap *map, rose_addr_t va, bool strict=true);
                std::string read_content_str(rose_addr_t abs_offset, bool strict=true);

                const SgFileContentList& content() {                    /* Entire file contents */
                        return p_data;
                }
                SgFileContentList content(rose_addr_t offset, rose_addr_t size);        /* Partial file contents; no reference tracking */

                /* Section lookup functions (plural) */
                SgAsmGenericSectionPtrList get_mapped_sections() const;
                SgAsmGenericSectionPtrList get_sections(bool include_holes=true) const;
                SgAsmGenericSectionPtrList get_sections_by_id(int id) const;
                SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep='\0') const;
                SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t offset, rose_addr_t size) const;
                SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t rva) const;
                SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t va) const;

                /* Section lookup functions (singular) */
                SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_offset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_rva(rose_addr_t rva, size_t *nfound=0) const;
                SgAsmGenericSection *get_section_by_va(rose_addr_t va, size_t *nfound=0) const;
                SgAsmGenericSection *get_best_section_by_va(rose_addr_t va, size_t *nfound=0) const;
                static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList &sections, rose_addr_t va);

                /* Section modification functions */
                enum AddressSpace {                                     /* Bit flags for address spaces for shift_extend() */
                        ADDRSP_MEMORY = 0x0001,
                        ADDRSP_FILE   = 0x0002,
                        ADDRSP_ALL    = 0x0003
                };
                enum Elasticity {                                       /* Elasticity argument for shift_extend() */
                        ELASTIC_NONE  = 0,                              /* Nothing is elastic; other parts of space are shifted */
                        ELASTIC_UNREF = 1,                              /* Unreferenced address space is elastic */
                        ELASTIC_HOLE  = 2                               /* Unreferenced and "hole" sections are elastic */
                };
                void shift_extend(SgAsmGenericSection *s, rose_addr_t sa, rose_addr_t sn)
                        {shift_extend(s, sa, sn, ADDRSP_ALL, ELASTIC_UNREF);}
                void shift_extend(SgAsmGenericSection*, rose_addr_t sa, rose_addr_t sn, AddressSpace, Elasticity);

                /* Holes (unreferenced regions in the file) */  
                rose_addr_t get_next_section_offset(rose_addr_t offset);        /* Find file offset for next section */
                void add_hole(SgAsmGenericSection*);                    /* Add section to list of holes */
                void remove_hole(SgAsmGenericSection*);                 /* Remove section from list of holes */
                void fill_holes();                                      /* Find holes in file and create sections to fill them */
                void unfill_holes();                                    /* Undoes what fill_holes() did */

                /* Functions for file headers (a kind of section) */
                void add_header(SgAsmGenericHeader*);                   /* Add a new file header to the list of headers */
                void remove_header(SgAsmGenericHeader*);                /* Remove file header from the file */
                SgAsmGenericHeader *get_header(SgAsmGenericFormat::ExecFamily);/* Returns the specified header or exception */
                const char *format_name() const;                        /* Return a string describing the file format */

                const SgAsmGenericFormat::fileDetails &get_sb() {
                        return p_sb;
                }
                void set_sb(const SgAsmGenericFormat::fileDetails &sb) {
                        printf("set_sb() not implemented!\n");
                        ROSE_ASSERT(false);
                }

                // DQ (8/26/2008): Added support for alternative section selection for use in disassembler.
                SgAsmGenericSection* get_best_possible_section_by_va(rose_addr_t va);

        private:
                void ctor();
                mutable AddressIntervalSet *p_unreferenced_cache;
                DataConverter *p_data_converter;
HEADER_GENERIC_FILE_END



HEADER_GENERIC_FORMAT_START
        public:
                void dump(FILE*, const char *prefix, ssize_t idx) const;
HEADER_GENERIC_FORMAT_END



HEADER_GENERIC_DLL_START
        public:
                explicit SgAsmGenericDLL(SgAsmGenericString *s);
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                void add_symbol(const std::string &s)                   /* Add a needed symbol to the import list for this DLL */
                        {p_symbols.push_back(s);}

                /* Override ROSETTA accessors */
                SgAsmGenericString *get_name() const;
                void set_name(SgAsmGenericString *s);
HEADER_GENERIC_DLL_END





HEADER_GENERIC_SYMBOL_START
        public:
                enum SymbolDefState {
                        SYM_UNDEFINED,          /* Symbol has not been defined yet */
                        SYM_TENTATIVE,          /* Does not have size/value yet (uninitialized C or Fortran common blks) */
                        SYM_DEFINED             /* Created and assigned storage */
                };

                enum SymbolType {
                        SYM_NO_TYPE,            /* No type or type is unknown */
                        SYM_DATA,               /* Normal variable definitions */
                        SYM_FUNC,               /* Function or other code */
                        SYM_SECTION,            /* Section of a file */
                        SYM_FILE,               /* Name of a file */
                        SYM_ARRAY,              /* Array of some other type */
                        SYM_TLS,                /* Thread-local storage */
                        SYM_REGISTER,           /* CPU register value (see Sparc) */
                        SYM_COMMON,             /* Common block */
                        SYM_IFUNC               /* Indirection function */
                };

                enum SymbolBinding {
                        SYM_NO_BINDING,         /* Unknown binding */
                        SYM_LOCAL,
                        SYM_GLOBAL,
                        SYM_WEAK
                };


             // DQ (10/20/2010): Moved this function's definition to the source file.
                SgAsmGenericSymbol();

                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                std::string stringifyDefState() const;
                std::string stringifyType() const;
                std::string stringifyBinding() const;

                // Accessors
                SgAsmGenericString *get_name() const; // same as ROSETTA-generated version
                void set_name(SgAsmGenericString *s); // also sets s.parent
        private:
                void ctor();
HEADER_GENERIC_SYMBOL_END











HEADER_STRING_STORAGE_START
     public:
          SgAsmStringStorage(SgAsmGenericStrtab *strtab, const std::string &string, rose_addr_t offset)
             : p_strtab(strtab), p_string(string), p_offset(offset) {}

          void dump(FILE *s, const char *prefix, ssize_t idx) const;
       /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are used
        * to control string allocation in ELF string tables and must only be modified by allocators in closely related classes.
        * For instance, to change the value of the string one should call SgAsmGenericString::set_string() instead. */

#if 0
       // Let the access function generated by ROSETTA be used.
          SgAsmElfStrtab* get_strtab() const {
               return p_strtab;
             }
          const std::string& get_string() const {             /*read-only; set string with SgAsmGenericString::set_string()*/
               return p_string;
             }
          const rose_addr_t get_offset() const {              /*read-only; set only by the string table allocator*/
               return p_offset;                               /*does not trigger reallocation; cf. SgAsmStoredString::get_offset()*/
             }
#endif

     private:
          friend class SgAsmStoredString;                     /*allowed to set private data members*/
          friend class SgAsmStoredStrtab;                     /*allowed to set private data members*/
#if 0
       // Let the access function generated by ROSETTA be used.
          void set_string(const std::string &s) {
               p_string = s;
             }
          void set_strtab(SgAsmElfStrtab *strtab) {
               p_strtab = strtab;
             }
          void set_offset(rose_addr_t offset) {
               p_offset = offset;
             }
          SgAsmStringStorage() {abort();}                    /*no default constructor; cf. SgAsmStoredString::create_storage()*/
#endif

HEADER_STRING_STORAGE_END

HEADER_GENERIC_STRTAB_START
        public:
                explicit SgAsmGenericStrtab(SgAsmGenericSection *container)
                        : p_container(container), p_dont_free(0), p_num_freed(0) {}
                virtual ~SgAsmGenericStrtab() {}
                virtual SgAsmGenericStrtab* parse() {return this;}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                SgAsmStoredString *create_string(rose_addr_t offset, bool shared);
                void free(SgAsmStringStorage*);
                void free(rose_addr_t offset, rose_addr_t size); /*mark part of table as free*/
                void free_all_strings(bool blow_away_holes=false);
                virtual void allocate_overlap(SgAsmStringStorage*) {};
                bool reallocate(bool shrink); /*allocate storage for all unallocated strings*/

                /* Free list accessors. Overriding ROSETTA because get_freelist() must return a modifiable free list. */
                const AddressIntervalSet& get_freelist() const;
                AddressIntervalSet& get_freelist();

                //These should be pure virtual but ROSETTA apparently doesn't support that (RPM 2008-10-03)
                virtual SgAsmStringStorage *create_storage(rose_addr_t offset, bool shared) {abort(); return NULL;}
                virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) {abort(); return 0;}
                virtual void rebind(SgAsmStringStorage*, rose_addr_t) {abort();}
                typedef std::vector<class SgAsmStringStorage*> referenced_t;
        private:
                void ctor();
HEADER_GENERIC_STRTAB_END

// ***********************************************
//          ELF Binary File Format Support
// ***********************************************










HEADER_ELF_SECTION_START
        public:
   // DQ (10/20/2010): Moved this function's definition to the source file.
      explicit SgAsmElfSection(SgAsmGenericHeader *fhdr);

                SgAsmElfSection *init_from_section_table(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int id);
                SgAsmElfSection *init_from_segment_table(SgAsmElfSegmentTableEntry*, bool mmap_only=false);
                rose_addr_t calculate_sizes(size_t r32size, size_t r64size, const std::vector<size_t> &optsizes,
                                            size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
                virtual void finish_parsing() {}
                virtual rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                void allocate_name_to_storage(SgAsmElfStringSection*);

                /* Convenience functions */
                SgAsmElfFileHeader *get_elf_header() const;

                // DQ (8/22/2008): These are not automatically generated since one of them must be virtual.
                SgAsmElfSection* get_linked_section () const;
                virtual void set_linked_section(SgAsmElfSection*);
        private:
                void ctor();
HEADER_ELF_SECTION_END



HEADER_STORED_STRING_START
        public:
                SgAsmStoredString(SgAsmGenericStrtab *strtab, rose_addr_t offset)       /*string in string table*/
                        {ctor(strtab, offset, false);}
                SgAsmStoredString(SgAsmGenericStrtab *strtab, const std::string &s)     /*new string in string table*/
                        {ctor(strtab, s);}
                explicit SgAsmStoredString(class SgAsmStringStorage *storage)           /*string shares other storage*/
                        {ctor(storage);}
                // virtual ~SgAsmStoredString();
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                SgAsmGenericStrtab *get_strtab();                                       /*table holding the string*/

                // These are not access functions -- they do more than just getting or setting the value!
                virtual std::string get_string(bool escape=false) const $ROSE_OVERRIDE;
                virtual void set_string(const std::string&) $ROSE_OVERRIDE;                            /*also deallocates previous value*/
                virtual void set_string(rose_addr_t) $ROSE_OVERRIDE;                                   /*rebinds to a new value*/
                virtual rose_addr_t get_offset() const $ROSE_OVERRIDE;                                 /*also triggers realloc*/
        private:
                // Maybe we need to supressed ROSETTA generated constructor!
                // SgAsmStoredString() {abort();}
                void ctor(class SgAsmGenericStrtab*, rose_addr_t offset, bool shared);
                void ctor(class SgAsmGenericStrtab*, const std::string&);
                void ctor(class SgAsmStringStorage*);
                void ctor(const std::string &s);

HEADER_STORED_STRING_END



HEADER_ELF_STRING_TABLE_START
        public:
                explicit SgAsmElfStrtab(class SgAsmElfSection *containing_section)
                        : SgAsmGenericStrtab(containing_section)
                        {ctor();}
                virtual ~SgAsmElfStrtab();
                virtual SgAsmElfStrtab *parse() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const;
                virtual SgAsmStringStorage *create_storage(rose_addr_t offset, bool shared) $ROSE_OVERRIDE;
                virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) $ROSE_OVERRIDE;
                virtual void allocate_overlap(SgAsmStringStorage*) $ROSE_OVERRIDE;
                virtual void rebind(SgAsmStringStorage*, rose_addr_t) $ROSE_OVERRIDE;
        private:
                void ctor();
HEADER_ELF_STRING_TABLE_END



HEADER_ELF_STRING_SECTION_START
        public:
                explicit SgAsmElfStringSection(SgAsmElfFileHeader *fhdr);
                virtual SgAsmElfStringSection *parse() $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                virtual void set_size(rose_addr_t newsize) $ROSE_OVERRIDE;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
        private:
                void ctor();
                void ctor(SgAsmElfSectionTable*);
HEADER_ELF_STRING_SECTION_END















HEADER_ELF_NOTE_SECTION_START
        public:
                explicit SgAsmElfNoteSection(SgAsmElfFileHeader *fhdr)
                        : SgAsmElfSection(fhdr)
                        {ctor();}
                virtual SgAsmElfNoteSection *parse() $ROSE_OVERRIDE;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor();
HEADER_ELF_NOTE_SECTION_END



HEADER_ELF_NOTE_ENTRY_START
        public:
                SgAsmElfNoteEntry(SgAsmElfNoteSection *section)
                        : p_type(0), p_name(NULL)
                        {ctor(section);}
                rose_addr_t parse(rose_addr_t starting_offset);
                rose_addr_t unparse(std::ostream &f, rose_addr_t starting_offset);
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                SgAsmGenericString *get_name() const;
                void set_name(SgAsmGenericString *name);
                void set_payload(const void*, size_t nbytes);
                rose_addr_t calculate_size() const;
        private:
                void ctor(SgAsmElfNoteSection *section);
HEADER_ELF_NOTE_ENTRY_END



HEADER_ELF_EH_FRAME_SECTION_START
        public:
                explicit SgAsmElfEHFrameSection(SgAsmElfFileHeader *fhdr)
                        : SgAsmElfSection(fhdr), p_ci_entries(NULL)
                        {ctor();}
                virtual SgAsmElfEHFrameSection *parse() $ROSE_OVERRIDE;
                virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                rose_addr_t unparse(std::ostream*) const;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor();
HEADER_ELF_EH_FRAME_SECTION_END



HEADER_ELF_EH_FRAME_ENTRY_CI_START
        public:
                explicit SgAsmElfEHFrameEntryCI(SgAsmElfEHFrameSection *ehframe)
                        : p_version(0), p_eh_data(0), p_code_alignment_factor(0), p_data_alignment_factor(0),
			p_augmentation_data_length(0), p_lsda_encoding(-1), p_prh_encoding(-1), p_prh_arg(0), p_prh_addr(0),
			p_addr_encoding(-1), p_sig_frame(false), p_fd_entries(NULL)
                        {ctor(ehframe);}

                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

                std::string unparse(const SgAsmElfEHFrameSection*) const;
        private:
                void ctor(SgAsmElfEHFrameSection*);
HEADER_ELF_EH_FRAME_ENTRY_CI_END



HEADER_ELF_EH_FRAME_ENTRY_FD_START
        public:
                explicit SgAsmElfEHFrameEntryFD(SgAsmElfEHFrameEntryCI *cie)
                        : p_size(0)
                        {ctor(cie);}

                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                std::string unparse(const SgAsmElfEHFrameSection*, SgAsmElfEHFrameEntryCI*) const;
        private:
                void ctor(SgAsmElfEHFrameEntryCI*);
HEADER_ELF_EH_FRAME_ENTRY_FD_END































// ***********************************************
//          PE Binary File Format Support
// ***********************************************

HEADER_PE_RVA_SIZE_PAIR_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                /* File format for an RVA/Size pair. Such pairs are considered to be part of the PE file header.  All fields are
                 * little endian. */
                struct RVASizePair_disk {
                        uint32_t    e_rva;
                        uint32_t    e_size;
                }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, const SgAsmPERVASizePair::RVASizePair_disk *disk)
                        : p_e_rva(0), p_e_size(0), p_section(NULL) {
                        ctor(parent, disk);
                }

                SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, rose_addr_t rva, rose_addr_t size)
                        : p_e_rva(0), p_e_size(0), p_section(NULL) {
                        ctor(parent, rva, size);
                }

                void set_section(SgAsmGenericSection *section);
                SgAsmGenericSection *get_section() const;

                void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const;
        private:
                void ctor(SgAsmPERVASizePairList *parent, const SgAsmPERVASizePair::RVASizePair_disk*);
                void ctor(SgAsmPERVASizePairList *parent, rose_addr_t rva, rose_addr_t size);
HEADER_PE_RVA_SIZE_PAIR_END



HEADER_PE_RVA_SIZE_PAIR_LIST_START
        public:
                explicit SgAsmPERVASizePairList(SgAsmPEFileHeader *parent) {
                        set_parent(parent);
                }
HEADER_PE_RVA_SIZE_PAIR_LIST_END



HEADER_PE_FILE_HEADER_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                /* File format of a PE File Header. All fields are little endian. */
                struct PEFileHeader_disk {
                        unsigned char e_magic[4];       /* 0x00 magic number "PE\0\0" */
                        uint16_t    e_cpu_type;         /* 0x04 e.g., 0x014c = Intel 386 */
                        uint16_t    e_nsections;        /* 0x06 number of sections defined in the Section Table */
                        uint32_t    e_time;             /* 0x08 time and date file was created or modified by the linker */
                        uint32_t    e_coff_symtab;      /* 0x0c offset to COFF symbol table */
                        uint32_t    e_coff_nsyms;       /* 0x10 number of symbols in COFF symbol table */
                        uint16_t    e_nt_hdr_size;      /* 0x14 num remaining bytes in the header following the 'flags' field */
                        uint16_t    e_flags;            /* 0x16 Bit flags: exe file, program/library image, fixed address, etc. */
                }                                       /* 0x18 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;

                struct PE32OptHeader_disk {
                        uint16_t    e_opt_magic;        /* 0x18 magic number */
                        uint16_t    e_lmajor;           /* 0x1a linker version */
                        uint16_t    e_lminor;           /* 0x1c */
                        uint16_t    e_code_size;        /* 0x1e Size of .text or sum of all code sections */
                        uint32_t    e_data_size;        /* 0x20 Sum size of initialized data */
                        uint32_t    e_bss_size;         /* 0x24 Sum size of uninitialized data */
                        uint32_t    e_entrypoint_rva;   /* 0x28 RVA="relative virtual address"; relative to 'image_base', below */
                        uint32_t    e_code_rva;         /* 0x2c Addr relative to image base for code section when memory mapped */
                        uint32_t    e_data_rva;         /* 0x30 Address relative to image base for data section */
                        uint32_t    e_image_base;       /* 0x34 Virt base of image (first byte of file, DOS header). 64k aligned */
                        uint32_t    e_section_align;    /* 0x38 Alignment of sections in memory. Power of two 512<=x<=256M */
                        uint32_t    e_file_align;       /* 0x3c Alignment factor (in bytes) for image pages */
                        uint16_t    e_os_major;         /* 0x40 OS version number required to run this image */
                        uint16_t    e_os_minor;         /* 0x42 */
                        uint16_t    e_user_major;       /* 0x44 User-specified for differentiating between image revs */
                        uint16_t    e_user_minor;       /* 0x46 */
                        uint16_t    e_subsys_major;     /* 0x48 Subsystem version number */
                        uint16_t    e_subsys_minor;     /* 0x4a */
                        uint32_t    e_reserved9;        /* 0x4c */
                        uint32_t    e_image_size;       /* 0x50 Virtual size of the image inc. all headers; section_align */
                        uint32_t    e_header_size;      /* 0x54 Total header size (DOS Header + PE Header + Section table */
                        uint32_t    e_file_checksum;    /* 0x58 Checksum for entire file; Set to zero by the linker */
                        uint16_t    e_subsystem;        /* 0x5c Native, WindowsGUI, WindowsCharacter, OS/2 Character, etc. */
                        uint16_t    e_dll_flags;        /* 0x5e Bit flags for library init/terminate per process or thread */
                        uint32_t    e_stack_reserve_size;/*0x60 Virtual mem reserved for stack; non-committed pages are guards */
                        uint32_t    e_stack_commit_size;/* 0x64 Size of valid stack; other pages are guards; <=stack_reserve_size*/
                        uint32_t    e_heap_reserve_size;/* 0x68 Size (bytes) of local heap to reserve */
                        uint32_t    e_heap_commit_size; /* 0x6c Size (bytes) of valid local heap */
                        uint32_t    e_loader_flags;     /* 0x70 Reserved, must be zero */
                        uint32_t    e_num_rvasize_pairs;/* 0x74 Num RVASizePair entries that follow this member; part of header */
                }                                       /* 0x78 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;

                struct PE64OptHeader_disk {
                        uint16_t    e_opt_magic;        /* 0x18 */
                        uint16_t    e_lmajor;           /* 0x1a */
                        uint16_t    e_lminor;           /* 0x1c */
                        uint16_t    e_code_size;        /* 0x1e */
                        uint32_t    e_data_size;        /* 0x20 */
                        uint32_t    e_bss_size;         /* 0x24 */
                        uint32_t    e_entrypoint_rva;   /* 0x28 */
                        uint32_t    e_code_rva;         /* 0x2c */
                        // uint32_t  e_data_rva;             /* Not present in PE32+ */
                        uint64_t    e_image_base;       /* 0x30 */
                        uint32_t    e_section_align;    /* 0x38 */
                        uint32_t    e_file_align;       /* 0x3c */
                        uint16_t    e_os_major;         /* 0x40 */
                        uint16_t    e_os_minor;         /* 0x42 */
                        uint16_t    e_user_major;       /* 0x44 */
                        uint16_t    e_user_minor;       /* 0x46 */
                        uint16_t    e_subsys_major;     /* 0x48 */
                        uint16_t    e_subsys_minor;     /* 0x4a */
                        uint32_t    e_reserved9;        /* 0x4c */
                        uint32_t    e_image_size;       /* 0x50 */
                        uint32_t    e_header_size;      /* 0x54 */
                        uint32_t    e_file_checksum;    /* 0x58 */
                        uint16_t    e_subsystem;        /* 0x5c */
                        uint16_t    e_dll_flags;        /* 0x5e */
                        uint64_t    e_stack_reserve_size;/*0x60 */
                        uint64_t    e_stack_commit_size;/* 0x68 */
                        uint64_t    e_heap_reserve_size;/* 0x70 */
                        uint64_t    e_heap_commit_size; /* 0x78 */
                        uint32_t    e_loader_flags;     /* 0x80 */
                        uint32_t    e_num_rvasize_pairs;/* 0x84 */
                }                                       /* 0x88 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                /* Bit flags for the PE header 'flags' member */
                enum HeaderFlags {
                        HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
                        HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: link errors or incrementally linked */
                        HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
                        HF_LIBRARY          = 0x2000,       /* Library image */
                        HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
                };

                /* Values for the PE header 'subsystem' member */
                enum Subsystem {
                        HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
                        HF_NATIVE           = 0x0001,       /* Native */
                        HF_WINGUI           = 0x0002,       /* Windows GUI */
                        HF_WINCHAR          = 0x0003,       /* Windows character */
                        HF_OS2CHAR          = 0x0005,       /* OS/2 character */
                        HF_POSIX            = 0x0007        /* POSIX character */
                };

                /* Bit flags for the PE header 'dll_flags' member */
                enum DLLFlags {
                        DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
                        DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
                        DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
                        DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
                        DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
                };

                /** Reason for each rva/size pair in the PE header. */
                enum PairPurpose {              // Values are important
                        PAIR_EXPORTS            = 0,
                        PAIR_IMPORTS            = 1,
                        PAIR_RESOURCES          = 2,
                        PAIR_EXCEPTIONS         = 3,
                        PAIR_CERTIFICATES       = 4,
                        PAIR_BASERELOCS         = 5,
                        PAIR_DEBUG              = 6,
                        PAIR_ARCHITECTURE       = 7,
                        PAIR_GLOBALPTR          = 8,
                        PAIR_TLS                = 9,    // Thread local storage
                        PAIR_LOADCONFIG         = 10,
                        PAIR_BOUNDIMPORT        = 11,
                        PAIR_IAT                = 12,   // Import address table
                        PAIR_DELAYIMPORT        = 13,   // Delay import descriptor
                        PAIR_CLRRUNTIME         = 14,   // CLR(?) runtime header
                        PAIR_RESERVED15         = 15    // Reserved (always zero according to specification)
                };
        public:
                explicit SgAsmPEFileHeader(SgAsmGenericFile *f)
                        : SgAsmGenericHeader(f), p_loader_map(NULL), p_section_table(NULL), p_coff_symtab(NULL)
                        {ctor();}

                virtual const char *format_name() const $ROSE_OVERRIDE {return "PE";}
                static bool is_PE (SgAsmGenericFile*);
                std::string rvasize_pair_name(PairPurpose, const char **short_name);
                void set_rvasize_pair(PairPurpose, SgAsmPESection*);
                void update_rvasize_pairs();
                void add_rvasize_pairs();

                virtual SgAsmPEFileHeader *parse() $ROSE_OVERRIDE;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                void create_table_sections();

                /* Loader memory maps */
                MemoryMap *get_loader_map() const {return p_loader_map;}
                void set_loader_map(MemoryMap *map) {p_loader_map=map;}

        private:
                void ctor();
                void *encode(SgAsmPEFileHeader::PEFileHeader_disk*) const;
                void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*) const;
                void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*) const;
                MemoryMap *p_loader_map;
HEADER_PE_FILE_HEADER_END



HEADER_PE_SECTION_START
        public:
                explicit SgAsmPESection(SgAsmPEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr), p_section_entry(NULL)
                        {}
                SgAsmPESection *init_from_section_table(SgAsmPESectionTableEntry *entry, int id);
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
HEADER_PE_SECTION_END



HEADER_PE_IMPORT_ITEM_START
        public:
                explicit SgAsmPEImportItem(SgAsmPEImportItemList *parent) {
                        ctor(parent);
                }
                explicit SgAsmPEImportItem(SgAsmPEImportDirectory *idir) {
                        ctor(idir);
                }
                SgAsmPEImportItem(SgAsmPEImportDirectory *idir, const std::string &name, unsigned hint=0) {
                        ctor(idir, name, hint);
                }
                SgAsmPEImportItem(SgAsmPEImportDirectory *idir, const unsigned ordinal) {
                        ctor(idir, ordinal);
                }
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                size_t hintname_required_size() const;
                rose_addr_t get_iat_entry_va() const;
        private:
                void ctor(SgAsmPEImportItemList *parent);
                void ctor(SgAsmPEImportDirectory*);
                void ctor(SgAsmPEImportDirectory*, const std::string &name, unsigned hint);
                void ctor(SgAsmPEImportDirectory*, unsigned ordinal);
HEADER_PE_IMPORT_ITEM_END






HEADER_PE_IMPORT_DIRECTORY_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                struct PEImportDirectory_disk {
                        uint32_t ilt_rva;               /* 0x00 Import Lookup Table RVA */
                        uint32_t time;                  /* 0x04 Zero until the image is bound, then time stamp of the DLL */
                        uint32_t forwarder_chain;       /* 0x08 Index of the first forwarder chain */
                        uint32_t dll_name_rva;          /* 0x0c address of NUL-terminated DLL name */
                        uint32_t iat_rva;               /* 0x10 Import Address Table (Thunk Table) RVA */
                }                                       /* 0x14 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                explicit SgAsmPEImportDirectory(SgAsmPEImportSection *isec, std::string dll_name="")
                        : p_dll_name(NULL), p_dll_name_rva(0), p_dll_name_nalloc(0), p_time(0), p_forwarder_chain(0),
                          p_ilt_rva(0), p_ilt_nalloc(0), p_iat_rva(0), p_iat_nalloc(0), p_imports(NULL) {
                        ctor(isec, dll_name);
                }
                SgAsmPEImportDirectory *parse(rose_addr_t va);
                size_t reallocate(rose_rva_t starting_rva);
                void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*) const;
                virtual void unparse(std::ostream&, const SgAsmPEImportSection*, size_t idx) const;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
                size_t iat_required_size() const;
                int find_import_item(const SgAsmPEImportItem *item, int hint=0) const;
                size_t hintname_table_extent(AddressIntervalSet &extent/*in,out*/) const;
        private:
                void ctor(SgAsmPEImportSection*, const std::string &dll_name);
                void parse_ilt_iat(const rose_rva_t &table_start, bool assume_bound);
                void unparse_ilt_iat(std::ostream&,const rose_rva_t &table_start, bool assume_bound, size_t nalloc) const;
HEADER_PE_IMPORT_DIRECTORY_END



HEADER_PE_IMPORT_SECTION_START
        public:
                explicit SgAsmPEImportSection(SgAsmPEFileHeader *fhdr)
                        : SgAsmPESection(fhdr)
                        {ctor();}
                virtual SgAsmPEImportSection *parse() $ROSE_OVERRIDE;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                void add_import_directory(SgAsmPEImportDirectory*);
                void remove_import_directory(SgAsmPEImportDirectory*);
                static bool show_import_mesg();
                static void import_mesg_reset() { mesg_nprinted=0; }
                size_t reallocate_iats(rose_rva_t start_at);
        private:
                static size_t mesg_nprinted; //counter for import_mesg()
                void ctor();
HEADER_PE_IMPORT_SECTION_END



HEADER_PE_EXPORT_DIRECTORY_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                /* An Export Section begins with the Export Directory */
                struct PEExportDirectory_disk {
                        uint32_t res1;         /* 0x00 Reserved, must be zero */
                        uint32_t timestamp;    /* 0x04 Time that export data was created */
                        uint16_t vmajor;       /* 0x08 Major version number (user defined) */
                        uint16_t vminor;       /* 0x0a Minor version number (user defined) */
                        uint32_t name_rva;     /* 0x0c Location of name of DLL */
                        uint32_t ord_base;     /* 0x10 Starting ordinal for exports in this image (usually 1) */
                        uint32_t expaddr_n;    /* 0x14 Number of entries in the export address table */
                        uint32_t nameptr_n;    /* 0x18 Number of entries in the name pointer table and ordinal table */
                        uint32_t expaddr_rva;  /* 0x1c Location of Export Address Table */
                        uint32_t nameptr_rva;  /* 0x20 Location of Export Name Pointer Table */
                        uint32_t ordinals_rva; /* 0x24 Location of Ordinal Table */
                }                               /* 0x28 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                explicit SgAsmPEExportDirectory(SgAsmPEExportSection *s)
                        {ctor(s);}

                void dump(FILE *f, const char *prefix, ssize_t idx) const;

        private:
                void ctor(SgAsmPEExportSection*);
HEADER_PE_EXPORT_DIRECTORY_END



HEADER_PE_EXPORT_ENTRY_START
        public:
                SgAsmPEExportEntry(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva,
                                   SgAsmGenericString *forwarder)
                        {ctor(name, ordinal, export_rva, forwarder);}

                void dump(FILE *f,const char *prefix,ssize_t idx) const;
                /* Accessors. Override ROSETTA because we adjust parents. */
                SgAsmGenericString *get_name() const {return p_name;}
                void set_name(SgAsmGenericString*);
                SgAsmGenericString *get_forwarder() const {return p_forwarder;}
                void set_forwarder(SgAsmGenericString*);
        private:
                void ctor(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva, SgAsmGenericString *forwarder);
HEADER_PE_EXPORT_ENTRY_END




HEADER_PE_EXPORT_SECTION_START
        public:
                /* The PE Export Address Table is an array of expaddr_n 4-byte RVAs. If the address is not in the export section
                 * (as defined by the address and length that are indicated in the NT Optional Header) then the RVA is an actual
                 * address in code or data. Otherwise its a Forwarder RVA that names a symbol in another DLL. */
                typedef uint32_t ExportAddress_disk;

                /* The PE Export Name Pointer Table is an array of nameptr_n 4-byte RVAs pointing into the Export Name Table. The
                 * pointers are ordered lexically to allow binary searches.  An export name is defined only if the export name
                 * pointer table contains a pointer to it. */
                typedef uint32_t ExportNamePtr_disk;

                /* The PE Export Ordinal Table is an array of nameptr_n (yes) 2-byte indices into the Export Address Table biased
                 * by ord_base. In other words, the ord_base must be subtracted from the ordinals to obtain true indices into the
                 * Export Address Table. */
                typedef uint16_t ExportOrdinal_disk;

                SgAsmPEExportSection(SgAsmPEFileHeader *fhdr)
                        : SgAsmPESection(fhdr), p_export_dir(NULL), p_exports(NULL)
                        {ctor();}
                virtual SgAsmPEExportSection *parse() $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                void add_entry(SgAsmPEExportEntry*);
        private:
                void ctor();
HEADER_PE_EXPORT_SECTION_END



HEADER_PE_SECTION_TABLE_START
        public:
                explicit SgAsmPESectionTable(SgAsmPEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor();}
                virtual SgAsmPESectionTable* parse() $ROSE_OVERRIDE;
                void add_section(SgAsmPESection *section);
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor();
HEADER_PE_SECTION_TABLE_END



HEADER_PE_COFF_SYMBOL_TABLE_START
        public:
                explicit SgAsmCoffSymbolTable(SgAsmPEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor();}
                size_t get_nslots() const;
                virtual SgAsmCoffSymbolTable *parse() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

        private:
                void ctor();
HEADER_PE_COFF_SYMBOL_TABLE_END



HEADER_PE_SECTION_TABLE_ENTRY_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                /* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
                struct PESectionTableEntry_disk {
                        char     name[8];          /* NUL-padded */
                        uint32_t virtual_size;     /* virtual memory size, >= physical_size and difference is zero filled */
                        uint32_t rva;              /* relative virt addr wrt Image Base; multiple of section_align; dense space */
                        uint32_t physical_size;    /* bytes of initialized data on disk; multiple of file_align & <= virtual_size*/
                        uint32_t physical_offset;  /* location of initialized data on disk; multiple of file_align */
                        uint32_t coff_line_nums;   /* file offset of COFF line number info or zero */
                        uint32_t n_relocs;         /* number of relocation entries; should be zero for executables */
                        uint32_t n_coff_line_nums; /* number of COFF line number entries */
                        uint32_t flags;            /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc.*/
                }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                /* These come from the windows PE documentation and
                 * http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
                enum PESectionFlags {
                        OF_CODE             = 0x00000020,   /* section contains code */
                        OF_IDATA            = 0x00000040,   /* initialized data */
                        OF_UDATA            = 0x00000080,   /* uninitialized data */
                        OF_INFO             = 0x00000200,   /* comments or some other type of info */
                        OF_REMOVE           = 0x00000800,   /* section will not become part of image */
                        OF_COMDAT           = 0x00001000,   /* section contains comdat */
                        OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for
                                                             * this section */
                        OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
                        OF_ALIGN_1          = 0x00100000,   /* no alignment */
                        OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
                        OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
                        OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
                        OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
                        OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
                        OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
                        OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
                        OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
                        OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
                        OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
                        OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
                        OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
                        OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
                        OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
                        OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
                        OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
                        OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
                        OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
                        OF_SHARED           = 0x10000000,   /* section is shared */
                        OF_EXECUTABLE       = 0x20000000,   /* execute permission */
                        OF_READABLE         = 0x40000000,   /* read permission */
                        OF_WRITABLE         = 0x80000000    /* write permission */
                };

                explicit SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);
                void update_from_section(SgAsmPESection *section);
                void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*) const;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
        private:
                void ctor(const SgAsmPESectionTableEntry::PESectionTableEntry_disk*);
HEADER_PE_SECTION_TABLE_ENTRY_END




HEADER_PE_COFF_SYMBOL_START
     public:

       // This was previously a #define macro in ExecPE.h (so we have to avoid the macro defining it as "static const unsigned int 18 = 18"
          static const unsigned int COFFSymbol_disk_size = 18;

#ifdef _MSC_VER
# pragma pack (1)
#endif
          struct COFFSymbol_disk {
               union {
                   char            st_name[8];
                   struct {
                       uint32_t    st_zero;
                       uint32_t    st_offset;
                   };
               };
               uint32_t            st_value;
               int16_t             st_section_num;
               uint16_t            st_type;
               unsigned char       st_storage_class;
               unsigned char       st_num_aux_entries;
             }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // virtual ~COFFSymbol() {}
          void *encode(SgAsmCoffSymbol::COFFSymbol_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
       /* Auxilliary data for the symbol */
       // const unsigned char *get_aux_data() {return aux_data;}
       // size_t get_aux_size() {return aux_size;}

       /* Native versions of the COFFSymbol_disk members */
       // std::string         st_name;        /* The original name; super.name might be modified */
       // rose_addr_t              st_name_offset;
       // int                 st_section_num;
       // unsigned            st_type, st_storage_class, st_num_aux_entries;
    
     private:
          void ctor(SgAsmPEFileHeader*, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
       // const unsigned char *aux_data;      /* Auxilliary data from table entries that follow */
       // size_t              aux_size;       /* Size (bytes) of auxilliary data */

HEADER_PE_COFF_SYMBOL_END

HEADER_COFF_STRING_TABLE_START
        public:
                explicit SgAsmCoffStrtab(class SgAsmPESection *containing_section)
                        : SgAsmGenericStrtab(containing_section)
                        {}
                virtual ~SgAsmCoffStrtab();
                virtual void unparse(std::ostream&) const;
                virtual SgAsmStringStorage *create_storage(rose_addr_t offset, bool shared) $ROSE_OVERRIDE;
                virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) $ROSE_OVERRIDE;
HEADER_COFF_STRING_TABLE_END



HEADER_PE_STRING_SECTION_START
        public:
                SgAsmPEStringSection(SgAsmPEFileHeader *fhdr)
                        : SgAsmPESection(fhdr), p_strtab(NULL)
                        {ctor();}
                virtual ~SgAsmPEStringSection() {}
                virtual SgAsmPEStringSection* parse() $ROSE_OVERRIDE;
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                virtual void set_size(rose_addr_t newsize) $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
        private:
                void ctor();
HEADER_PE_STRING_SECTION_END



// ***********************************************
//          NE Binary File Format Support
// ***********************************************

HEADER_NE_FILE_HEADER_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
          /* File format of an NE File Header. All fields are little endian.
           *
           * NOTES
           * 
           * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
           *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
           *         of the stack. */
          struct NEFileHeader_disk {
               unsigned char e_magic[2];           /* 0x00 magic number "NE" */
               unsigned char e_linker_major;       /* 0x02 linker major version number */
               unsigned char e_linker_minor;       /* 0x03 linker minor version number */
               uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
               uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
               uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
               uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
               uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
               uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
               uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
               uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
               uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
               uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
               uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
               uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
               uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
               uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
               uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
               uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
               uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
               uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
               uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
               uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
               uint16_t    e_nresources;           /* 0x34 number of resource entries */
               unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
               unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
               uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
               uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
               uint16_t    e_res1;                 /* 0x3c reserved */
               uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
             }                                     /* 0x40 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          /* Bit flags for the NE header 'e_flags' member.
           *
           * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
           * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
           * value in AX is a status indicator (non-zero for success, zero for failure). */
          enum HeaderFlags1 {
               HF1_RESERVED         = 0x57f4,      /* Reserved bits */
               HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
               HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
               HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
               HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
               HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
               HF1_LIBRARY          = 0x8000       /* Module is a library */
             };

          /* Bit flags for the NE header 'e_flags2' member. */
          enum HeaderFlags2 {
               HF2_RESERVED         = 0xf1,        /* Reserved bits */
               HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
               HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
               HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
             };

          SgAsmNEFileHeader(SgAsmGenericFile *f, rose_addr_t offset)
                : SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_resname_table(NULL),
                p_nonresname_table(NULL), p_module_table(NULL), p_entry_table(NULL)
                {ctor(f, offset);}

       // virtual ~NEFileHeader() {}
          static bool is_NE (SgAsmGenericFile*);
          static SgAsmNEFileHeader *parse(SgAsmDOSFileHeader*);
          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
          virtual const char *format_name() const $ROSE_OVERRIDE {return "NE";}
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

     private:
          void ctor(SgAsmGenericFile *f, rose_addr_t offset);
          void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;
HEADER_NE_FILE_HEADER_END

HEADER_NE_SECTION_START
     public:
          explicit SgAsmNESection(SgAsmNEFileHeader *fhdr)
                : SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL), p_reloc_table(NULL)
                {}

       // virtual ~NESection() {}

          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
       /* Accessors for protected/private data */
       // NESectionTableEntry *get_st_entry() {return st_entry;}
       // void set_st_entry(NESectionTableEntry *e) {st_entry=e;}
       // NERelocTable *get_reloc_table() {return reloc_table;}
       // void set_reloc_table(NERelocTable *t) {reloc_table=t;}
  // private:
       // NESectionTableEntry *st_entry;
       // NERelocTable *reloc_table;

HEADER_NE_SECTION_END



HEADER_NE_SECTION_TABLE_START
        public:
                explicit SgAsmNESectionTable(SgAsmNEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor();}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

        private:
                void ctor();
HEADER_NE_SECTION_TABLE_END



HEADER_NE_NAME_TABLE_START
        public:
                SgAsmNENameTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                std::vector<std::string> get_names_by_ordinal(unsigned ordinal);
        private:
                void ctor(rose_addr_t offset);
HEADER_NE_NAME_TABLE_END



HEADER_NE_MODULE_TABLE_START
        public:
                SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, SgAsmNEStringTable *strtab, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr), p_strtab(strtab)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_MODULE_TABLE_END



HEADER_NE_STRING_TABLE_START
        public:
                SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                std::string get_string(rose_addr_t offset);
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_STRING_TABLE_END



HEADER_NE_ENTRY_TABLE_START
        public:
                SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                void populate_entries();
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_NE_ENTRY_TABLE_END



HEADER_NE_RELOC_TABLE_START
        public:
                explicit SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, SgAsmNESection *section)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(section);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(SgAsmNESection*);
HEADER_NE_RELOC_TABLE_END



HEADER_NE_ENTRY_POINT_START
          enum NEEntryFlags {
               EF_ZERO             = 0x00, /* No flags set */
               EF_RESERVED         = 0xfc, /* Reserved bits */
               EF_EXPORTED         = 0x01, /* Exported */
               EF_GLOBAL           = 0x02  /* Uses a global (shared) data section */
             };

       // SgAsmNEEntryPoint();
          SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
       // NEEntryFlags flags;         /* bit flags */
       // unsigned int3f;             /* always 0x3fxx */
       // unsigned section_idx;       /* zero indicates unused entry */
       // unsigned section_offset;    /* byte offset into section */

HEADER_NE_ENTRY_POINT_END

HEADER_NE_RELOC_ENTRY_START

     public:

       /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
        * than defining it here as a struct. */

          enum NERelocSrcType {
               RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
               RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
               RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
               RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
               RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
               RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
               RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
               RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
               RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
             };

          enum NERelocTgtType {
               RF_TGTTYPE_IREF     = 0,            /* Internal reference */
               RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
               RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
               RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */ 
             };

          enum NERelocModifiers {
               RF_MODIFIER_SINGLE  = 1,
               RF_MODIFIER_MULTI   = 3
             };

          enum NERelocFlags {
               RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
               RF_RESERVED         = 0x02,         /* reserved bits */
               RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
               RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
               RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
               RF_8ORDINAL         = 0x20          /* Ordinal is 8-bits rather than 16 */
             };

       // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support 
       // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, rose_addr_t; and then use member 
       // functions to access the data in the base class.
          struct iref_type
             { /*tgt_type==0x00: internal reference*/
               unsigned    sect_idx;       /* section index (1-origin) */
               unsigned    res1;           /* reserved */
               rose_addr_t      tgt_offset;
     
            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

               iref_type();
             };

          struct iord_type { /*tgt_type==0x01: imported ordinal*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    ordinal;
               rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

               iord_type();
             };

          struct iname_type { /*tgt_type==0x02: imported name*/
               unsigned    modref;         /* 1-based index into import module table */
               unsigned    nm_off;         /* offset into import procedure names */
               rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

               iname_type();
             };

          struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
               unsigned    type;
               unsigned    res3;

            // Added to support RTI support in ROSE
               friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

               osfixup_type();
             };

          SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size);

          void ctor(SgAsmGenericSection*, rose_addr_t at, rose_addr_t *rec_size);
          rose_addr_t unparse(std::ostream&, const SgAsmGenericSection*, rose_addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;
       // NERelocSrcType      src_type;       /* low nibble of first byte of relocation record */
       // NERelocModifiers    modifier;       /* high nibble of first byte */
       // NERelocTgtType      tgt_type;       /* low two bits of second byte */
       // NERelocFlags        flags;          /* high six bits of second byte */
       // rose_addr_t              src_offset;

       // iref_type iref;
       // iord_type iord;
       // iname_type iname;
       // osfixup_type osfixup;

HEADER_NE_RELOC_ENTRY_END

HEADER_NE_SECTION_TABLE_ENTRY_START
     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. All fields are little endian. */
          struct NESectionTableEntry_disk {
               uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
               uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
               uint16_t    flags;                  /* 0x04 Segment bit flags */
               uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
             }                                     /* 0x08 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum NESectionFlags {
               SF_RESERVED         = 0x0e08,       /* these bits are reserved */

               SF_TYPE_MASK        = 0x0007,       /* segment-type field */
               SF_CODE             = 0x0000,       /* code-segment type */
               SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
               SF_ALLOC            = 0x0002,       /* loader allocates memory */
               SF_LOAD             = 0x0004,       /* load the segment */

               SF_MOVABLE          = 0x0010,       /* segment is not fixed */
               SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
               SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
               SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
               SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
               SF_DISCARDABLE      = 0x1000,       /* discardable */
               SF_DISCARD          = 0xf000        /* discard priority */
             };

          explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
       // virtual ~NESectionTableEntry() {};

          void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
          void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, sector;
       // rose_addr_t      physical_size, virtual_size;

     private:
          void ctor(const SgAsmNESectionTableEntry::NESectionTableEntry_disk*);

HEADER_NE_SECTION_TABLE_ENTRY_END



// ***********************************************
//          LE Binary File Format Support
// ***********************************************

HEADER_LE_FILE_HEADER_START

     public:
       // Overloaded base class virtual function
          const char *format_name() const $ROSE_OVERRIDE;

          static bool is_LE (SgAsmGenericFile*);
          static SgAsmLEFileHeader *parse(SgAsmDOSFileHeader*);

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
          struct LEFileHeader_disk {
              unsigned char e_magic[2];           /* 0x00 magic number "LX" */
              unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
              unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
              uint32_t    e_format_level;         /* 0x04 LX file format version number */
              uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
              uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
              uint32_t    e_module_version;       /* 0x0c user-specified module version number */
              uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
              uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
              uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
              uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
              uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
              uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
              uint32_t    e_page_size;            /* 0x28 page size in bytes */
              uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
              uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
              uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
              uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
              uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
              uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
              uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
              uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
              uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
              uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
              uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
              uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
              uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
              uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
              uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
              uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
              uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
              uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
              uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
              uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
              uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
              uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
              uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
              uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
              uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
              uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
              uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
              uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
              uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
              uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
              uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
              uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
          }                                       /* 0xac */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          enum LEFileHeaderFlags {
              HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
              HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
              HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
              HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
              HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
              HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
              HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
              HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
              HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */
    
              HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
              HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
              HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
              HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
              HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
              HF_MODTYPE_VDEV     = 0x00028000    /* Virtual device driver module */
          };

          SgAsmLEFileHeader(SgAsmGenericFile *f, rose_addr_t offset)
                : SgAsmGenericHeader(f), p_dos2_header(NULL), p_section_table(NULL), p_page_table(NULL),
                p_resname_table(NULL), p_nonresname_table(NULL), p_entry_table(NULL), p_reloc_table(NULL)
                {ctor(f, offset);}

       // virtual ~LEFileHeader() {}

          virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
       // virtual const char *format_name() const;
          virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
     private:
          void ctor(SgAsmGenericFile *f, rose_addr_t offset);
          void *encode(ByteOrder::Endianness sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;
HEADER_LE_FILE_HEADER_END



HEADER_LE_SECTION_START
        public:
                explicit SgAsmLESection(SgAsmLEFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr), p_st_entry(NULL)
                        {}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
HEADER_LE_SECTION_END



HEADER_LE_SECTION_TABLE_START
        public:
                SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_LE_SECTION_TABLE_END



HEADER_LE_NAME_TABLE_START
        public:
                /* This table contains a module name followed by the list of exported function names. Each name is associated with
                 * an "ordinal" which serves as an index into the Entry Table. The ordinal for the first string (module name) is
                 * meaningless and should be zero. In the non-resident name table the first entry is a module description and the
                 * functions are not always resident in system memory (they are discardable). */
                SgAsmLENameTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_NAME_TABLE_END



HEADER_LE_PAGE_TABLE_START
        public:
                SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset, size);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                SgAsmLEPageTableEntry *get_page(size_t idx);
        private:
                void ctor(rose_addr_t offset, rose_addr_t size);
HEADER_LE_PAGE_TABLE_END



HEADER_LE_ENTRY_TABLE_START
        public:
                SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_ENTRY_TABLE_END



HEADER_LE_RELOC_TABLE_START
        public:
                SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor(offset);}
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
        private:
                void ctor(rose_addr_t offset);
HEADER_LE_RELOC_TABLE_END



HEADER_LE_PAGE_TABLE_ENTRY_START
     public:
       /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
        * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while
        * still allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
        * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they
        * are both indexed by the logical page number). */

#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format for a page table entry */
          struct LEPageTableEntry_disk {
               uint16_t            pageno_hi;
               unsigned char       pageno_lo;
               unsigned char       flags;
             }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEPageTableEntry(ByteOrder::Endianness sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);

          void dump(FILE*, const char *prefix, ssize_t idx) const;
          void *encode(ByteOrder::Endianness, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;

       // unsigned get_pageno() {return pageno;}

     private:
          void ctor(ByteOrder::Endianness, const SgAsmLEPageTableEntry::LEPageTableEntry_disk*);

       // unsigned    pageno;
       // unsigned    flags;

HEADER_LE_PAGE_TABLE_ENTRY_END

HEADER_LE_ENTRY_POINT_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
        * next entry point description follows immediately after the flag. */
          struct LEEntryPoint_disk {
              uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
              uint16_t    objnum;         /* 0x01 Object number */
              uint8_t     entry_type;     /* 0x03 Flags for entry type */
              uint32_t    entry_offset;   /* 0x04 Offset of entry point */
              uint16_t    res1;           /* 0x08 Reserved */
          }                               /* 0x0a */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

          SgAsmLEEntryPoint(ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
          SgAsmLEEntryPoint(ByteOrder::Endianness sex, unsigned flags);

          rose_addr_t unparse(std::ostream&, ByteOrder::Endianness, const SgAsmGenericSection*, rose_addr_t spos) const;
          void dump(FILE*, const char *prefix, ssize_t idx) const;
     private:
          void ctor(ByteOrder::Endianness, const SgAsmLEEntryPoint::LEEntryPoint_disk*);

       // std::vector<LEEntryPoint> entries;
       // unsigned flags, objnum, entry_type, res1;
       // rose_addr_t entry_offset;

HEADER_LE_ENTRY_POINT_END

HEADER_LE_SECTION_TABLE_ENTRY_START

     public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
       /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
          struct LESectionTableEntry_disk {
               uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
               uint32_t    base_addr;              /* 0x04 relocation base address */
               uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
               uint32_t    pagemap_index;          /* 0x0c */
               uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
               uint32_t    res1;                   /* 0x14 reserved */
             }                                     /* 0x18 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

       /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
        *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
        *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
        *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
        *             stream.) */
          enum LESectionFlags {
               SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */
    
               SF_READABLE         = 0x00000001,   /**< Read permission granted when mapped */
               SF_WRITABLE         = 0x00000002,   /**< Write permission granted when mapped */
               SF_EXECUTABLE       = 0x00000004,   /**< Execute permission granted when mapped */
    
               SF_RESOURCE         = 0x00000008,   /**< Section contains resource objects */
               SF_DISCARDABLE      = 0x00000010,   /**< Discardable section */
               SF_SHARED           = 0x00000020,   /**< Section is shared */
               SF_PRELOAD_PAGES    = 0x00000040,   /**< Section has preload pages */
               SF_INVALID_PAGES    = 0x00000080,   /**< Section has invalid pages */

               SF_TYPE_MASK        = 0x00000300,        /*NO_STRINGIFY*/
               SF_TYPE_NORMAL      = 0x00000000,
               SF_TYPE_ZERO        = 0x00000100,   /**< Section has zero-filled pages */
               SF_TYPE_RESIDENT    = 0x00000200,   /**< Section is resident (valid for VDDs and PDDs only) */
               SF_TYPE_RESCONT     = 0x00000300,   /**< Section is resident and contiguous */
    
               SF_RES_LONG_LOCK    = 0x00000400,   /**< Section is resident and "long-lockable" (VDDs and PDDs only) */
               SF_1616_ALIAS       = 0x00001000,   /**< 16:16 alias required (80x86 specific) */
               SF_BIG_BIT          = 0x00002000,   /**< Big/default bit setting (80x86 specific); see note above */
               SF_CODE_CONFORM     = 0x00004000,   /**< Section is conforming for code (80x86 specific) */
               SF_IO_PRIV          = 0x00008000    /**< Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
             };

          SgAsmLESectionTableEntry(ByteOrder::Endianness sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
       // virtual ~LESectionTableEntry() {};

          void *encode(ByteOrder::Endianness, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
          virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
       /* These are the native-format versions of the same members described in the NESectionTableEntry_disk struct. */
       // unsigned    flags, pagemap_index, pagemap_nentries, res1;
       // rose_addr_t      mapped_size, base_addr;

     private:
          void ctor(ByteOrder::Endianness, const SgAsmLESectionTableEntry::LESectionTableEntry_disk*);

HEADER_LE_SECTION_TABLE_ENTRY_END




// ***********************************************
//          DOS Binary File Format Support
// ***********************************************

HEADER_DOS_HEADER_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                struct DOSFileHeader_disk {
                        unsigned char e_magic[2];          /* 0x00 "MZ" */
                        uint16_t      e_last_page_size;    /* 0x02 bytes used on last page of file (1 page == 512 bytes);
                                                            *      zero implies if last page is full */
                        uint16_t      e_total_pages;       /* 0x04 number of pages (inc. last possibly partial page) in file */
                        uint16_t      e_nrelocs;           /* 0x06 number of relocation entries stored after this header */
                        uint16_t      e_header_paragraphs; /* 0x08 header size in paragraphs (16-byte blocks) inc. relocations */
                        uint16_t      e_minalloc;          /* 0x0a number of extra paragraphs needed, similar to BSS in Unix */
                        uint16_t      e_maxalloc;          /* 0x0c max paragraphs to allocate for BSS */
                        uint16_t      e_ss;                /* 0x0e initial value of SS register relative to program load segment */
                        uint16_t      e_sp;                /* 0x10 initial value for SP register */
                        uint16_t      e_cksum;             /* 0x12 checksum; 16-bit sum of all words in file should be zero
                                                            *      (usually not filled in) */
                        uint16_t      e_ip;                /* 0x14 initial value for IP register */
                        uint16_t      e_cs;                /* 0x16 initial value for CS register relative to program load segment*/
                        uint16_t      e_relocs_offset;     /* 0x18 file address of relocation table */
                        uint16_t      e_overlay;           /* 0x1a overlay number (zero indicates main program) */
                        uint32_t      e_res1;              /* 0x1c unknown purpose */
                }                                          /* 0x20 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;

                struct DOSRelocEntry_disk {
                        uint16_t      offset;              /* 0x00 */
                        uint16_t      segment;             /* 0x02 */
                }                                          /* 0x04 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

                explicit SgAsmDOSFileHeader(SgAsmGenericFile *f)
                        : SgAsmGenericHeader(f), p_relocs(NULL), p_rm_section(NULL)
                        {ctor();}
                virtual SgAsmDOSFileHeader *parse() $ROSE_OVERRIDE {return parse(true);}
                SgAsmDOSFileHeader *parse(bool define_rm_section);
                virtual bool reallocate() $ROSE_OVERRIDE;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;
                virtual const char *format_name() const $ROSE_OVERRIDE {return "DOS";}
                SgAsmGenericSection *parse_rm_section(rose_addr_t max_offset=0);
                void update_from_rm_section();
                static bool is_DOS(SgAsmGenericFile*);
        private:
                void ctor();
                void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*) const;
HEADER_DOS_HEADER_END



HEADER_DOS_EXTENDED_HEADER_START
        public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
                struct DOSExtendedHeader_disk {
                        uint32_t      e_res1;     /* 0x00 reserved */
                        uint16_t      e_oemid;    /* 0x04 OEM Identifier */
                        uint16_t      e_oeminfo;  /* 0x06 other OEM information; oemid specific */
                        uint32_t      e_res2;     /* 0x08 reserved */
                        uint32_t      e_res3;     /* 0x0c reserved */
                        uint32_t      e_res4;     /* 0x10 reserved */
                        uint32_t      e_res5;     /* 0x14 reserved */
                        uint32_t      e_res6;     /* 0x18 reserved */
                        uint32_t      e_lfanew;   /* 0x1c file offset of new exe (PE) header */
                }                                 /* 0x20 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif
                explicit SgAsmDOSExtendedHeader(SgAsmDOSFileHeader *fhdr)
                        : SgAsmGenericSection(fhdr->get_file(), fhdr)
                        {ctor();}
                virtual SgAsmDOSExtendedHeader *parse() $ROSE_OVERRIDE;
                void *encode(SgAsmDOSExtendedHeader::DOSExtendedHeader_disk*) const;
                virtual void unparse(std::ostream&) const $ROSE_OVERRIDE;
                virtual void dump(FILE*, const char *prefix, ssize_t idx) const $ROSE_OVERRIDE;

        private:
                void ctor();
HEADER_DOS_EXTENDED_HEADER_END

HEADER_BINARY_RET_START
   void append_dest( SgAsmStatement* instruction );     
HEADER_BINARY_RET_END

// ************************************
//           DWARF SUPPORT
// ************************************


HEADER_DWARF_COMPILATION_UNIT_START

     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;

HEADER_DWARF_COMPILATION_UNIT_END



HEADER_DWARF_LINE_LIST_START
       // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
      //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
          static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

      //! Output information about instruction address <--> source position
          void display( const std::string & label );

          static std::pair<uint64_t,uint64_t> instructionRange();
          static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

          static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
          static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );
HEADER_DWARF_LINE_LIST_END

HEADER_DWARF_CONSTRUCT_START
     public:
      //! Factory pattern to build IR nodes based on the tag
          static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

          virtual SgAsmDwarfConstructList* get_children();
HEADER_DWARF_CONSTRUCT_END

HEADER_DWARF_SUBPROGRAM_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_SUBPROGRAM_END

HEADER_DWARF_STRUCTURE_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_STRUCTURE_TYPE_END

HEADER_DWARF_ARRAY_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_ARRAY_TYPE_END

HEADER_DWARF_LEXICAL_BLOCK_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_LEXICAL_BLOCK_END

HEADER_DWARF_INLINED_SUBROUTINE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_INLINED_SUBROUTINE_END

HEADER_DWARF_ENUMERATION_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_ENUMERATION_TYPE_END

HEADER_DWARF_SUBROUTINE_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_SUBROUTINE_TYPE_END

HEADER_DWARF_UNION_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_UNION_TYPE_END

HEADER_DWARF_NAMESPACE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_NAMESPACE_END

HEADER_DWARF_CLASS_TYPE_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_CLASS_TYPE_END

HEADER_DWARF_COMMON_BLOCK_START
     public:
          SgAsmDwarfConstructList* get_children() $ROSE_OVERRIDE;
HEADER_DWARF_COMMON_BLOCK_END


/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */
/* --------------------------------------------------------------------------------- */

SOURCE_BINARY_RET_START
void
SgAsmx86Ret::append_dest( SgAsmStatement* statement )
   {
     p_dest.push_back(statement);
   }

SOURCE_BINARY_RET_END



SOURCE_BINARY_OPERAND_LIST_START
void
SgAsmOperandList::append_operand( SgAsmExpression* operand )
   {
  /* implemented directly until we can fix how the statementList is built */
     p_operands.push_back(operand);
   }

SOURCE_BINARY_OPERAND_LIST_END



SOURCE_BINARY_DATA_STRUCTURE_START
void
SgAsmSynthesizedDataStructureDeclaration::append_declaration( SgAsmSynthesizedDeclaration* declaration )
   {
     p_declarationList.push_back(declaration);
   }

SOURCE_BINARY_DATA_STRUCTURE_END

// *************************************
//      Binary File Format Support
// *************************************

SOURCE_PE_SECTION_TABLE_ENTRY_START
SgAsmPESectionTableEntry::SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_PE_SECTION_TABLE_ENTRY_END

SOURCE_PE_COFF_SYMBOL_START
SgAsmCoffSymbol::SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx)
   : p_st_name_offset(0), p_st_section_num(0), p_st_type(0), p_st_storage_class(0), p_st_num_aux_entries(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(fhdr, symtab, strtab, idx);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_PE_COFF_SYMBOL_END





SOURCE_NE_ENTRY_POINT_START

//SgAsmNEEntryPoint::SgAsmNEEntryPoint()
//   : p_flags((SgAsmNEEntryPoint::EF_ZERO), p_int3f(0), p_section_idx(0), p_section_offset(0)
//   {}

SgAsmNEEntryPoint::SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off)
   : p_flags(flags), p_int3f(int3f), p_section_idx(s_idx), p_section_offset(s_off)
   {
   }

SOURCE_NE_ENTRY_POINT_END

SOURCE_NE_RELOC_ENTRY_START
SgAsmNERelocEntry::SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(relocs, at, rec_size);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_NE_RELOC_ENTRY_END

SOURCE_NE_SECTION_TABLE_ENTRY_START
SgAsmNESectionTableEntry::SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_NE_SECTION_TABLE_ENTRY_END





SOURCE_LE_PAGE_TABLE_ENTRY_START
SgAsmLEPageTableEntry::SgAsmLEPageTableEntry(ByteOrder::Endianness sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk)
   : p_pageno(0), p_flags(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_LE_PAGE_TABLE_ENTRY_END

SOURCE_LE_ENTRY_POINT_START
SgAsmLEEntryPoint::SgAsmLEEntryPoint(ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk)
   : p_flags(0), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SgAsmLEEntryPoint::SgAsmLEEntryPoint(ByteOrder::Endianness sex, unsigned flags)
   : p_flags(flags), p_objnum(0), p_entry_type(0), p_res1(0), p_entry_offset(0)
   {
   }

SOURCE_LE_ENTRY_POINT_END

SOURCE_LE_SECTION_TABLE_ENTRY_START
SgAsmLESectionTableEntry::SgAsmLESectionTableEntry(ByteOrder::Endianness sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk)
   {
#ifdef ROSE_BUILD_BINARY_ANALYSIS_SUPPORT
     ctor(sex, disk);
#else
     printf ("Error: ROSE not configured for binary analysis (this is a language specific build) \n");
     ROSE_ASSERT(false);
#endif
   }

SOURCE_LE_SECTION_TABLE_ENTRY_END




SOURCE_DWARF_COMPILATION_UNIT_START

SgAsmDwarfConstructList*
SgAsmDwarfCompilationUnit::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_language_constructs == NULL)
          p_language_constructs = new SgAsmDwarfConstructList();

     return p_language_constructs;
   }

SOURCE_DWARF_COMPILATION_UNIT_END

SOURCE_DWARF_LINE_LIST_START

DwarfInstructionSourceMapReturnType
SgAsmDwarfLineList::buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu )
   {
  // SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
  // SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;

  // Build this as static local data
     static SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = NULL;

     bool recomputeMap = false;
     if (instruction_source_code_map == NULL)
        {
          recomputeMap = true;
          instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
        }

     ROSE_ASSERT(instruction_source_code_map != NULL);

     static SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = NULL;
     if (source_code_instruction_map == NULL)
          source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;
     ROSE_ASSERT(source_code_instruction_map != NULL);

     if (recomputeMap == true)
        {
          ROSE_ASSERT(dwarf_cu != NULL);
          ROSE_ASSERT(dwarf_cu->get_line_info() != NULL);

          SgAsmDwarfLinePtrList & line_list = dwarf_cu->get_line_info()->get_line_list();

          int listSize = (int) line_list.size();
          for (int i = 0; i < listSize; i++)
             {
            // Loop over each of the entries in the Dwarf line section.
               uint64_t address = line_list[i]->get_address();

            // Note that file_id values are already in terms of the Sg_File_Info maps 
            // between file name integers and file name strings.
               int file_id      = line_list[i]->get_file_id();

               int line         = line_list[i]->get_line();
               int column       = line_list[i]->get_column();

            // printf ("address = 0x%lx file_id = %d line = %d  column = %d \n",address,file_id,line,column);

               FileIdLineColumnFilePosition file_info(file_id,std::pair<int,int>(line,column));

            // This works for stp::map, but for std::multimap
            // instruction_source_code_map->operator[](address)   = file_info;
            // source_code_instruction_map->operator[](file_info) = address;

            // This is the std::multiset version ...
               instruction_source_code_map->insert(AddressFileIdLineColumnFilePositionPair(address,file_info));
               source_code_instruction_map->insert(FileIdLineColumnFilePositionAddressPair(file_info,address));
             }
        }
       else
        {
       // printf ("Maps were computed previously \n");
        }

     DwarfInstructionSourceMapReturnType returnValue(instruction_source_code_map,source_code_instruction_map);

     return returnValue;
   }

SOURCE_DWARF_LINE_LIST_END

SOURCE_DWARF_CONSTRUCT_START

SgAsmDwarfConstructList*
SgAsmDwarfConstruct::get_children()
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("Error: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
     ROSE_ASSERT(false);
#else
     printf ("Warning: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
#endif
     return NULL;
   }

SOURCE_DWARF_CONSTRUCT_END


SOURCE_DWARF_SUBPROGRAM_START

SgAsmDwarfConstructList*
SgAsmDwarfSubprogram::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBPROGRAM_END

SOURCE_DWARF_STRUCTURE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfStructureType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_STRUCTURE_TYPE_END

SOURCE_DWARF_ARRAY_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfArrayType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ARRAY_TYPE_END


SOURCE_DWARF_LEXICAL_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfLexicalBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_LEXICAL_BLOCK_END


SOURCE_DWARF_INLINED_SUBROUTINE_START

SgAsmDwarfConstructList*
SgAsmDwarfInlinedSubroutine::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_INLINED_SUBROUTINE_END


SOURCE_DWARF_ENUMERATION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfEnumerationType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_ENUMERATION_TYPE_END


SOURCE_DWARF_SUBROUTINE_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfSubroutineType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_SUBROUTINE_TYPE_END


SOURCE_DWARF_UNION_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfUnionType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_UNION_TYPE_END


SOURCE_DWARF_NAMESPACE_START

SgAsmDwarfConstructList*
SgAsmDwarfNamespace::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_NAMESPACE_END


SOURCE_DWARF_CLASS_TYPE_START

SgAsmDwarfConstructList*
SgAsmDwarfClassType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_CLASS_TYPE_END


SOURCE_DWARF_COMMON_BLOCK_START

SgAsmDwarfConstructList*
SgAsmDwarfCommonBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SOURCE_DWARF_COMMON_BLOCK_END


