// #########################################################    -*- C++ -*-
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START

 /*  This class forms a base class for all of the types represented in the C++ grammar.
     All types are derived from this class and thus contain the following functionality.
  */

     public:
      /*
          \if documentDevelopmentVersionUsingDoxygen
          name Friend Classes
               \brief Friend classes declarations

          \endif
       */
          friend class SgPointerType;         //!< provide access to private data
          friend class SgReferenceType;       //!< provide access to private data
          friend class SgRvalueReferenceType; //!< provide access to private data
          friend class SgDeclType;            //!< provide access to private data
          friend class SgTypedefType;         //!< provide access to private data
          friend class SgTypeOfType;          //!< provide access to private data
       /*! */

     public:
      /*! \if documentDevelopmentVersionUsingDoxygen
               \brief default constructor

               Default constructor and destructors are not documented in user
               interface \ref defaultConstructorDestructorDocumentationPage.
               \sa \ref defaultConstructorDestructorDocumentationPage
          \endif
       */
          SgType();

      /*! \brief copy constructor

          The Copy constructor is provide to support the AST copy mechanism, where
          types are copied to support copying of named types.
       */
          SgType(const SgType & X);

       // RV (1/30/2006)
      /*! Returns a mangled string representation of this type.
          Equivalent types have the same mangled string.
       */
          virtual SgName get_mangled (void) const;

       // SKW (3/1/2011): Added these explicit declarations since we no longer build them automatically
          virtual SgExpression * get_type_kind () const;
          virtual void set_type_kind ( SgExpression* type_kind );

      /*!
          name Numerical Modifiers
          \brief Compute numerical properties of type.

          These define numeric properties of the type (e.g. int, float, etc.)

          \internal Return type should be changed to "bool."
       */
          bool isUnsignedType() const;  //!< There are many sorts of unsigned types (this queries an arbitrary type).
          bool isIntegerType() const;   //!< There are many sorts of integer types (this queries an arbitrary type).
          bool isFloatType() const;     //!< There are several sorts of float types (this queries an arbitrary type).

       // DQ (4/20/2019): Added support to detect primative types (which don't require name qualification).
          bool isPrimativeType() const;   //!< There are many sorts of primative types (this queries an arbitrary type).
       /*! */

       // DQ (10/11/2007): These sorts of values are usually handled as enum fields in ROSE. They could be redone at some point.
       // PC and AS new variables to support a flexible stripType() which takes an bit array as a paramater
          static const unsigned char STRIP_MODIFIER_TYPE         = ((unsigned char) 1 << 0); // 0x01
          static const unsigned char STRIP_REFERENCE_TYPE        = ((unsigned char) 1 << 1); // 0x02
          static const unsigned char STRIP_RVALUE_REFERENCE_TYPE = ((unsigned char) 1 << 2); // 0x04
          static const unsigned char STRIP_POINTER_TYPE          = ((unsigned char) 1 << 3); // 0x08
          static const unsigned char STRIP_ARRAY_TYPE            = ((unsigned char) 1 << 4); // 0x16
          static const unsigned char STRIP_TYPEDEF_TYPE          = ((unsigned char) 1 << 5); // 0x32

       // DQ (4/15/2019): Adding specific support for pointer to member (SgPointerMemberType) since we don't always
       // want to strip it and we need better control over this.  Since SgPointerMemberType is derived from SgPointerType
       // (which might be a design mistake) it was handled along with SgPointer but for name qualification we need the
       // stripType function to have greater expresiveness.
          static const unsigned char STRIP_POINTER_MEMBER_TYPE   = ((unsigned char) 1 << 6); // 0x64

      /*! \brief Some types store internal SgType pointers explicitly while others compute them from other data.  This function is true if it has a data member that is a type (pointer, array, etc.).

          Result is true if it stores a type explicitly as a data member, else false.

          \internal True only if this is either a SgPointerType, SgReferenceType, PointerMemberType,
                    JavaParameterizedType, JavaWildcardType, ModifierType, QualifiedNameType, FunctionType,
                    MemberFunctionType, SgArrayType, TypeComplex, or TypeImaginary.
       */
          bool hasExplicitType();

      /*! \brief Some types can hide other type IR nodes internally.  This function is true if it can hide another type (pointer, array, etc.).

          Result is true if it can hide a one or more types, else false.

          \internal True only if this is either a SgPointerType, SgArrayType, SgReferenceType, SgTypedefType, SgFunctionType, or SgModifierType.
       */
          bool containsInternalTypes();

      /*! \brief Generate a container of types hidden in the input type.

          Returns a vector of types hidden in the input type (pointer, array, etc.).

          \internal Order of types in vector is not significant (e.g. for SgFunctionType IR nodes).
       */
          Rose_STL_Container<SgType*> getInternalTypes() const;

      /*! \brief Reset the base type.
          This function resets the base type.  It is an error to call it for types where containsInternalTypes() == false.
       */
          void reset_base_type(SgType* baseType);

      /*! \brief Return the base type of the associated type.
          The base type is important when dealing with pointers, arrays, etc.
       */
          SgType* findBaseType() const;

          SgType * dereference();              //!< Returns type hidden behind pointer of reference.
          const SgType * dereference() const ; //!< Returns type hidden behind pointer of reference.

       // DQ (6/21/2005): Added to support getting a deeply nested types quickly and easily.
      //! Returns hidden type beneath layers of typedefs, pointers, references, modifiers, array representation, etc.
      //  SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE ) const;
          SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE |
                                                      STRIP_POINTER_TYPE  | STRIP_ARRAY_TYPE     | STRIP_TYPEDEF_TYPE          | STRIP_POINTER_MEMBER_TYPE ) const;

       // DQ (6/30/2005): Added to support investigation of hidden types
      //! This only strips away typedefs and modifiers (specialized usage).
          SgType* stripTypedefsAndModifiers() const;

       // DQ (9/7/2007): Support for Fortran attribute specifiers
          enum fortran_attribute_specifiers_enum
             {
               e_unknown_attribute_specifier = 0,
               e_public_access,
               e_private_access,
               e_allocatable,
               e_asynchronous,
               e_bind,
               e_data,
               e_dimension,
               e_intent,
               e_optional,
               e_parameter,
               e_pointer,
               e_protected,
               e_save,
               e_target,
               e_value,
               e_volatile,
               e_last_attribute_specifier
             };



      /*
          name Conversion Functions
          \brief Simple conversion functions.
          \internal Not sure these are useful when using the string interface.
       */
      //! performs simple conversions
          static SgType * arithmetic_conversions(SgType *, SgType *);

      //! handles promotion to integer
          static SgType * integer_promotion     (SgType *, SgType *);

      //! handles promotion to float
          static SgType * float_promotion       (SgType *, SgType *);
      /*! */

       // DQ (4/27/2005): Added protected function to support refactored code for name mangling
     protected:
      //! \deprecated by RV (2/2/2006)
          SgName mangledNameSupport(SgName & fname, SgUnparse_Info& info);

     public:

       // DQ (7/24/2010): Added static function to distiquish which types (very few) are
       // required to use the local type table for types built during AST construction.
       // This is required to support that we don't always know the scope of a type while
       // it is being constructed (while it's declarations are being constructed).
          static bool handledUsingLocalTable( SgType* t );

       // DQ (7/30/2010): This function gets the scope from either the C/C++ or Fortran
       // procesing so that the local type table in each scope can be referenced.
          static SgScopeStatement* getCurrentScope();

          SgDeclarationStatement* getAssociatedDeclaration() const;

       // DQ (12/8/2015): Insead of the operator==(), we require a more nuanced approach.
       // There are concepts of type equivalence (where for example a typedef of an int would
       // be the same type as the int) and type intechangablity, where two equivalent types will
       // can be substituted for each other (which might not be possible if one of them has
       // only private access permissions.
      //! Type equivalence is the concept of equality between types independent of access permissions (e.g. private or protected types in a class).
          bool isEquivalentType (const SgType * other_type) const;

HEADER_END


HEADER_X_TYPE_START
HEADER_X_TYPE_END


HEADER_NON_X_TYPE_START
HEADER_NON_X_TYPE_END

HEADER_BUILTIN_TYPE_SUPPORT_START
HEADER_BUILTIN_TYPE_SUPPORT_END


HEADER_COMMON_CREATE_TYPE_START
      //! example of type used where construction is particularly simple

      //! function returns example of type
       // DQ (10/4/2010): Added support for optional Fotran type_kind specification.
          static $CLASSNAME* createType(SgExpression* optional_fortran_type_kind = nullptr);
HEADER_COMMON_CREATE_TYPE_END


HEADER_CREATE_TYPE_WITH_PARAMETER_START
      //! more sophisticated version for more complex types like $CLASSNAME (types whose constructors take parameters)
       // DQ (10/4/2010): Added support for optional Fotran type_kind specification.
       // static $CLASSNAME* createType(CREATE_TYPE_PARAMETER);
          static $CLASSNAME* createType(CREATE_TYPE_PARAMETER, SgExpression* optional_fortran_type_kind = NULL);
HEADER_CREATE_TYPE_WITH_PARAMETER_END


HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_TYPE_ARRAY_START
       // static $CLASSNAME* get_builtin_type();
       // static void set_builtin_type($CLASSNAME* builtin_type);

       //! builtin_type variable specific to the SgArrayType object (for maxBitLength=32 bit integers)
       // Could not use maxBitLength in array size below (so I just used the #define value directly).
HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_TYPE_ARRAY_END


HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_START
       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_END


HEADER_GET_MANGLED_START
       // SgName get_mangled ( SgUnparse_Info & info );

      //! Mangled name support for unparser support
       // SgName get_mangled ( SgUnparse_Info & info );
       // RV (1/31/2006): Removed dependence on SgUnparse_Info.
          virtual SgName get_mangled (void) const override;

HEADER_GET_MANGLED_END

HEADER_TYPEDEF_TYPE_START

       // DQ (10/18/2007): Added copy constructor so that the typedef lists on each type could be updated properly.
      //! Copy constructor to support AST copy mechanism.
          SgTypedefType ( const SgTypedefType & X );

HEADER_TYPEDEF_TYPE_END

HEADER_VIRTUAL_GET_NAME_START
       //! Gets name of the type (useful for debugging, unparsing, etc.)
       /*! Avoid making abstract base classes (if we can) because in the
           automated generation of code we want to avoid placing constraints
           on derived classes.
        */
       // virtual SgName get_name() const = 0;
          virtual SgName get_name() const;

          SgNamedType ( const SgNamedType & X );
HEADER_VIRTUAL_GET_NAME_END


HEADER_GET_NAME_START
      //! Support for some classes which have pure virtual function in base classes.
      /*! For the classes derived from where the pure  virtual "virtual SgName get_name() = 0;"
          This applies to the SgClassType, SgTypedef and the
          SgEnumType (derived from SgNamedType)
       */
          SgName get_name() const override;
HEADER_GET_NAME_END


HEADER_GET_QUALIFIED_NAME_START
      //! Used for the SgNamedType object (base class for the SgClassType, SgTypedefType and the SgEnumType object)
          SgName get_qualified_name() const;
HEADER_GET_QUALIFIED_NAME_END


HEADER_GET_BASE_TYPE_START
      //! This is used in the SgTypedefType object (is not associated with a base_type data field)
          SgType* get_base_type() const;
HEADER_GET_BASE_TYPE_END


HEADER_CLASS_TYPE_START
          SgClassType ( const SgClassType & X );
HEADER_CLASS_TYPE_END

HEADER_NONREAL_TYPE_START
          SgNonrealType ( const SgNonrealType & X );
//        virtual SgName get_mangled(void) const;
//        virtual SgName get_name() const;
HEADER_NONREAL_TYPE_END

HEADER_AUTO_TYPE_START
          SgAutoType ( const SgAutoType & X );
//        virtual SgName get_mangled(void) const;
//        virtual SgName get_name() const;
HEADER_AUTO_TYPE_END


HEADER_JAVA_PARAMETERIZED_TYPE_START
          SgJavaParameterizedType ( const SgJavaParameterizedType & X );
HEADER_JAVA_PARAMETERIZED_TYPE_END


HEADER_JAVA_QUALIFIED_TYPE_START
          SgJavaQualifiedType ( const SgJavaQualifiedType & X );
HEADER_JAVA_QUALIFIED_TYPE_END


HEADER_JAVA_WILDCARD_TYPE_START
          SgJavaWildcardType ( const SgJavaWildcardType & X );
          bool is_unbound();
HEADER_JAVA_WILDCARD_TYPE_END


HEADER_JAVA_UNION_TYPE_START
          SgJavaUnionType ( const SgJavaUnionType & X );

       // DQ (3/22/2017): Added explicitly to avoid using mechansim reserved for virtual functions
       // (part of support for override specification and elimination of those warnings from Clang).
          SgName get_name() const;
HEADER_JAVA_UNION_TYPE_END


HEADER_JAVA_PARAMETER_TYPE_START
          SgJavaParameterType ( const SgJavaParameterType & X );
HEADER_JAVA_PARAMETER_TYPE_END


HEADER_JOVIAL_TABLE_TYPE_START
          SgJovialTableType ( const SgJovialTableType & X );

      //! Enum for Jovial structure specifiers
          enum class StructureSpecifier
             {
               e_default = 0, /*!< jovial table structure is unspecified, indicates serial structure */
               e_parallel,    /*!< jovial table has parallel structure */
               e_tight        /*!< jovial table has serial structure that is tightly packed */
             };
HEADER_JOVIAL_TABLE_TYPE_END


HEADER_ENUM_TYPE_START
          SgEnumType ( const SgEnumType & X );
HEADER_ENUM_TYPE_END


HEADER_TEMPLATE_TYPE_START
HEADER_TEMPLATE_TYPE_END


HEADER_MODIFIER_TYPE_START

       // name TypeModifierGroup3 Type Modifiers
      /*
          name Type Modifiers
          \brief Compute modifier values.

          These return false in the implementation of the virtual functions
          in SgType and are overridden here.

          \internal Return type should be changed to "bool."
          \todo implement type modifier query functions in SgType class.
       */
       /*! */

  // DQ (7/28/2010): Make this private so that we can support API that would force the type table to be used.
  // Users should use the build functions to construct modifier types (SgModifierType IR nodes) with different
  // flags set.
  // private:
      //! Access function for modifier
          SgTypeModifier & get_typeModifier();

       // RV (2/2/2006): Added a 'const' version
          const SgTypeModifier& get_typeModifier (void) const;

  // DQ (7/28/2010): Make this public as the end of the previous private region.
     public:
          static SgModifierType* insertModifierTypeIntoTypeTable( SgModifierType* result );

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() override;

HEADER_MODIFIER_TYPE_END


HEADER_QUALIFIED_NAME_TYPE_START
          SgName get_prefix() const;

       // SgName get_mangled (void) const;

       // DQ (10/10/2006): Handle qualified name list at the declarations directly, instead of at the types.
       // At present these are useful for SgVariableDeclaration and SgTypedefDeclaration, but likely others
       // at some point.
          SgQualifiedNamePtrList & get_qualifiedNameList();
          const SgQualifiedNamePtrList & get_qualifiedNameList() const;
          void set_qualifiedNameList( const SgQualifiedNamePtrList & x );

HEADER_QUALIFIED_NAME_TYPE_END


HEADER_FUNCTION_TYPE_START

      //! Constructor for building a function type
          SgFunctionType(SgPartialFunctionType *);

       // static SgFunctionType* createType(SgPartialFunctionType *);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization () override;

      // Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
      //! This is a const convience access function to the STL container of types in the child IR node (SgFunctionParameterTypeList* p_argument_list).
          const SgTypePtrList & get_arguments() const;

      // Get the list of input types (types of the parameters list) to this function type
      //! This is a non-const convience access function to the STL container of types in the child IR node (SgFunctionParameterTypeList* p_argument_list).
          SgTypePtrList & get_arguments();

       // WAS: void append_argument(const SgTypePtr& what);
       // WAS: void insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)

      //! Append new argument to argument type list
          void append_argument( SgType* what);

      //! Insert new argument to argument type list
          void insert_argument(const SgTypePtrList::iterator& where, SgType* what);

      //! get the mangled name (this version is used in unparsing)
      /*! This version can be tailored using the input SgUnparse_Info parameter.
       */
       // DQ (2/7/2006): Removed as a test
       // virtual SgName get_mangled_name ( SgUnparse_Info & info );

      //! get the mangled name
      //! get the mangled name \deprecated by RV (2/2/2006)
          virtual SgName get_mangled_type ();

      //! I forget why this is here.
      //  SgFunctionType* mkAnotherType(SgType *);

      //! I forget why this is here.
      //  void sym_print(std::ostream& os);

          SgSymbol* get_symbol_from_symbol_table() const;

       // TV (04/18/11): For support of shared function type.
          static SgName get_mangled(SgType* return_type, SgFunctionParameterTypeList * typeList);

HEADER_FUNCTION_TYPE_END

HEADER_MEMBER_FUNCTION_TYPE_START

      //! Constructor
          SgMemberFunctionType(SgPartialFunctionType *);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() override;

      //! Enum for const and volatile function modifiers
          enum mfunc_specifier_enum
             {
               e_const     =     0x00000001,
               e_volatile  =     0x00000002,
               e_restrict  =     0x00000004,

            // DQ (1/9/2020): Added reference qualifiers (C++11 feature).
               e_ref_qualifier_lvalue = 0x00000008,
               e_ref_qualifier_rvalue = 0x00000010
             };

      //! const access/set/unset member functions for member function type
          bool isConstFunc() const; // RV (2/1/2006): Made 'const' member
          void setConstFunc();
          void unsetConstFunc();

      //! volatile access/set/unset member functions for member function type
          bool isVolatileFunc() const; // RV (2/1/2006): Made 'const' member
          void setVolatileFunc();
          void unsetVolatileFunc();

       // DQ (3/8/2012): Enabled the use of rescrict recorded in the function type.
      //! restrict access/set/unset member functions for member function type
          bool isRestrictFunc() const;
          void setRestrictFunc();
          void unsetRestrictFunc();

       // DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
      //! L-value reference access/set/unset member functions and member function type
          bool isLvalueReferenceFunc() const;
          void setLvalueReferenceFunc();
          void unsetLvalueReferenceFunc();

      //! R-value reference access/set/unset member functions and member function type
          bool isRvalueReferenceFunc() const;
          void setRvalueReferenceFunc();
          void unsetRvalueReferenceFunc();

      //! Mangled name support
          virtual SgName get_mangled_name (void) const;

       // DQ (12/6/2012): Adding member function specifier data (since this will be a part of the generated mangled name).
       // DQ (12/3/2011): Added better support for member function name mangling (symetric with SgFunctionType).
          static SgName get_mangled(SgType* ret_type, SgFunctionParameterTypeList* typeList, SgType* classType, unsigned int mfunc_specifier );

          SgMemberFunctionType * mkAnotherType(SgType *);

      //! \deprecated The struct_name property has been replaced by the class_type property, an SgType
          SgClassDefinition* get_struct_name() const;

HEADER_MEMBER_FUNCTION_TYPE_END


HEADER_PARTIAL_FUNCTION_TYPE_START
          void post_construction_initialization () override;
HEADER_PARTIAL_FUNCTION_TYPE_END


HEADER_TYPEDEF_TYPE_START

       // DQ (2/20/2018): Adding support to build typedef type from template instantiation
          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = NULL);

HEADER_TYPEDEF_TYPE_END


HEADER_TYPE_INT_TYPE_START
       // DQ (12/26/2005): C++ allows initialization in-class of static const, but it is not very portable yet.
       // static const int maxBitLength = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;
          static const int maxBitLength; // = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;

       // DQ (12/26/2005): Supporting function for traverseMemoryPool
       // where static IR nodes (only isn soem SgType IR nodes) are
       // present and must be traversed using specially generated code.
       // virtual void executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor);
HEADER_TYPE_INT_TYPE_END

HEADER_TYPE_COMPLEX_TYPE_START
      //! function returns example of type
          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = NULL);
       // SKW (3/1/2011): Added these explicit declarations since we no longer build them automatically
          virtual SgExpression* get_type_kind () const override;
          virtual void set_type_kind ( SgExpression* type_kind ) override;
HEADER_TYPE_COMPLEX_TYPE_END

// SK(08/20/2015): SgTypeTuple implementation
HEADER_TYPE_TUPLE_START
    SgTypePtrList& get_types();
    const SgTypePtrList& get_types() const;

    void prepend_type(SgType *what);
    void append_type(SgType *what);

HEADER_TYPE_TUPLE_END


HEADER_POINTER_MEMBER_TYPE_START
       //! The API to this function has been changed to support returning a SgDeclarationStatement.
       // DQ (4/11/2019): This alllows it to support both the cases where a definition might not
       // exist and the case of a pointer to member of a nonreal type.
       // The old functionality is represented in the get_class_definition_of() function.
          SgDeclarationStatement* get_class_declaration_of() const;

      //! \deprecated The class_of property has been replaced by the class_type property, an SgType
          SgClassDefinition* get_class_definition_of() const;

       // DQ (4/20/2019): Renamed these to make them more clear, since there are two locations for name qualification in a SgPointerMemberType.
       // DQ (4/18/2019): Added support for name qualification of type chains of SgPointerMemberType.
          SgName get_qualified_name_prefix_for_class_of() const;
          SgName get_qualified_name_prefix_for_base_type() const;

HEADER_POINTER_MEMBER_TYPE_END

HEADER_TYPE_STRING_TYPE_START
       // DQ (8/17/2010): Support for Fortran use of SgTypeString.
          static $CLASSNAME* createType(SgExpression*, SgExpression* optional_fortran_type_kind = nullptr);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() override;
HEADER_TYPE_STRING_TYPE_END

HEADER_TYPE_DEFAULT_TYPE_START

       // Generated a mangled name that accounts for the stored name internally.
       // SgName get_mangled (void) const;

      //! Default type creation to support intermediate types built during parsing (required for fortran only).
          static SgTypeDefault* createType ( const SgName & nameOfType );

HEADER_TYPE_DEFAULT_TYPE_END

HEADER_TYPE_LABEL_TYPE_START

       // Generated a mangled name that accounts for the stored name internally.
       // SgName get_mangled (void) const;

      //! Label type creation to support intermediate types built during parsing (required for fortran only).
          static SgTypeLabel* createType ( const SgName & nameOfType );

HEADER_TYPE_LABEL_TYPE_END


HEADER_DECL_TYPE_START

          void set_base_type(SgType* base_type);

HEADER_DECL_TYPE_END


HEADER_TYPEOF_TYPE_START

          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = nullptr);

          void set_base_type(SgType* base_type);

HEADER_TYPEOF_TYPE_END


HEADER_ARRAY_TYPE_START

       // DQ (3/22/2017): I would like to remove this function if possible.
       // DQ (3/22/2017): Added the get_name() function prototype directly so that
       // it could be differentiated from where it is a virtual function.
          SgName get_name() const;

HEADER_ARRAY_TYPE_END

HEADER_ADA_ACCESS_TYPE_START

          SgName get_name() const;

HEADER_ADA_ACCESS_TYPE_END

HEADER_ADA_SUBTYPE_START

          SgName get_name() const;

HEADER_ADA_SUBTYPE_END

HEADER_ADA_DERIVEDTYPE_START

          SgName get_name() const;

HEADER_ADA_DERIVEDTYPE_END

HEADER_ADA_MODULAR_TYPE_START

          SgName get_name() const;

HEADER_ADA_MODULAR_TYPE_END

HEADER_ADA_SUBROUTINE_TYPE_START
          // SgName get_name() const;
HEADER_ADA_SUBROUTINE_TYPE_END

HEADER_RANGE_TYPE_START
          // SgName get_name() const;
HEADER_RANGE_TYPE_END


HEADER_ADA_TASK_TYPE_START
          //~ SgName get_name() const;
HEADER_ADA_TASK_TYPE_END

HEADER_ADA_PROTECTED_TYPE_START
          //~ SgName get_name() const;
HEADER_ADA_PROTECTED_TYPE_END

HEADER_ADA_DISCRIMINATED_TYPE_START
  //~ SgName get_name() const;
HEADER_ADA_DISCRIMINATED_TYPE_END

HEADER_ADA_DISCRETE_TYPE_START
  //~ SgName get_name() const;
HEADER_ADA_DISCRETE_TYPE_END



HEADER_ADA_FORMAL_TYPE_START

          //SgName get_name() const;

HEADER_ADA_FORMAL_TYPE_END

// CR (4/4/2020): Added SgJovialBitType for Jovial. This type participates in logical
//                       operations with literals TRUE and FALSE.
HEADER_JOVIAL_BIT_TYPE_START
          SgName get_name() const;
HEADER_JOVIAL_BIT_TYPE_END

// CR (2/19/2020): Added SgTypedFixed for Jovial. Don't really know what to do here.
HEADER_TYPE_FIXED_TYPE_START
      // SgName get_name() const;
HEADER_TYPE_FIXED_TYPE_END


// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

SOURCE_CONSTRUCTOR_BODY_START
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

 //! now a call to the user defined intialization function
     post_construction_initialization();

SOURCE_CONSTRUCTOR_BODY_END


SOURCE_GET_MANGLED_START

/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (10/4/2010): Modified to provide Fortran support (type_kind is a data member used for Fortran only, it is always NULL for other languages)
  // type_kind is also used for Jovial.
     SgName name = "MANGLED_ID_STRING";
     if (get_type_kind() != NULL)
        {
          SgValueExp* value = isSgValueExp(get_type_kind());
          if (value != NULL)
             {
               name += string("_kind") + value->get_constant_folded_value_as_string();
             }
            else
             {
            // DQ (9/6/2016): This is where the name of the class is used and where it can collide with a
            // complex type (SgTypeComplex) if the class name is "_Complex".  This is why we need something
            // other than the name to be used here.  Unclear if a single prefix is sufficent or if we need
            // a different prefix for each type of named type.  It come down to is there can be multiple
            // types with the same name, and there is only a choice of SgNamedTypes: SgClassType, SgTypedefType,
            // and SgEnumType.  These can't have the same name, so we need not have a unity prefix for each type.
            // I think the issue is that MANGLED_ID_STRING is not defined for any of the SgNameType IR nodes.
               name += SageInterface::generateUniqueName(get_type_kind(),false);
             }
        }

  // Rasmussen (3/6/2020): This is a hack but I can't get SgTypeFixed::get_mangled() to work
  // REMOVE_ME please!
     if (isSgTypeFixed(this))
        {
          const SgTypeFixed* fixed_type = isSgTypeFixed(this);
          if (fixed_type->get_scale() != NULL)
             {
               SgValueExp* value = isSgValueExp(fixed_type->get_scale());
               if (value != NULL)
                  {
                    name += string("_") + value->get_constant_folded_value_as_string();
                  }
             }
          if (fixed_type->get_fraction() != NULL)
             {
               SgValueExp* value = isSgValueExp(fixed_type->get_fraction());
               if (value != NULL)
                  {
                    name += string("_") + value->get_constant_folded_value_as_string();
                  }
             }
        }

     return name;
   }

SOURCE_GET_MANGLED_END

SOURCE_GET_MANGLED_BASE_TYPE_START

/*! Returns a mangled name representation of types with base types
 *  (e.g., pointer, reference).
 */
SgName
$CLASSNAME::get_mangled (void) const
   {
  // DQ (10/23/2015): Note that these functions are called in the AST construction and that might not be
  // required, plus it might be a performance issue as well. I didn't expect to see this while debugging
  // a different subject.  In general, I think we would like to push the generation of mangled names to
  // the end of the AST processing; unless it is required for computing symble table keys (which is the
  // likely usage within the AST construction, if so then I guess we have to allow these functions to be
  // called in the frontend AST construction).

     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);

     SgName base_name = base_type->get_mangled();

     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << base_name.str () // base type
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag

     return mangled_name;
   }

SOURCE_GET_MANGLED_BASE_TYPE_END


SOURCE_POINTER_MEMBER_GET_MANGLED_START
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // Generate a pointer type _without_ the class name in it
     string base_str = SgPointerType::get_mangled ().getString ();

  // Mangle the class name
     const SgType* cls_type = get_class_type ();
     ROSE_ASSERT (cls_type);
     string cls_name = cls_type->get_mangled ().getString ();

  // Now embed the fully qualified class name in it
     string mangled_name (base_str);
     const string ptr_begin_tag ("__Pb__");
     string::size_type pos_begin = mangled_name.find (ptr_begin_tag);
     mangled_name.replace (pos_begin, ptr_begin_tag.size (), "__PMb__" + cls_name);

     return SgName (mangled_name.c_str ());
   }

SOURCE_POINTER_MEMBER_GET_MANGLED_END


SOURCE_GET_MANGLED_STRING_TYPE_START

/*! Returns a mangled name representation of strings types with the size of the string
 *  (e.g., literal, *, or integer expression).
 */
SgName
SgTypeString::get_mangled (void) const
   {
    // DXN (08/01/2011): add type kind to the mangled name
     SgName mangled_name;
     SgValueExp* lenValExp = isSgValueExp(p_lengthExpression);
     SgName mangled_length_name = lenValExp? lenValExp->get_constant_folded_value_as_string():
                                             SageInterface::generateUniqueName(p_lengthExpression,false);
     if (p_type_kind)
        {
          SgValueExp* kindValExp = isSgValueExp(p_type_kind);
          SgName mangled_kind_name = kindValExp? kindValExp->get_constant_folded_value_as_string():
                                            SageInterface::generateUniqueName(p_type_kind,false);
          mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << mangled_length_name.str ()  // length
                  << "__" << mangled_kind_name.str() // kind
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
        }
     else
        {
          mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << mangled_length_name.str ()  // length
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
        }

     return mangled_name;
   }

SOURCE_GET_MANGLED_STRING_TYPE_END

// Rasmussen (3/6/2020): Added get_mangled for SgTypedFixed (primitive type in Jovial)
SOURCE_GET_MANGLED_TYPE_FIXED_START

SgName
SgTypeFixed::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name = "MANGLED_ID_STRING";

  // Note additional name mangling is being done here because I couldn't figure out how to add
  // it to get_mangled directly because the class is a ROSETTA macro and doesn't have access to
  // the scale or fraction information.
     if (get_scale() != NULL)
        {
           SgValueExp* value = isSgValueExp(get_scale());
           if (value != NULL)
              {
                 mangled_name += string("_") + value->get_constant_folded_value_as_string();
                 //~ std::cout << "--> added scale " << mangled_name << std::endl;
              }
        }
     if (get_fraction() != NULL)
        {
           SgValueExp* value = isSgValueExp(get_fraction());
           if (value != NULL)
              {
                 mangled_name += string("_") + value->get_constant_folded_value_as_string();
                 //~ std::cout << "--> added fraction " << mangled_name << std::endl;
              }
        }

     printf ("LEAVING: In SgTypeFixed::get_mangled(): mangled_name = %s \n",mangled_name.str());

     return mangled_name;
   }

SOURCE_GET_MANGLED_TYPE_FIXED_END

SOURCE_CONSTRUCTOR_START
SOURCE_CONSTRUCTOR_END

SOURCE_CONSTRUCTOR_WITH_BASECLASS_TAKING_PARAMETER_START
SOURCE_CONSTRUCTOR_WITH_BASECLASS_TAKING_PARAMETER_END

SOURCE_DATA_ACCESS_FUNCTIONS_START
SOURCE_DATA_ACCESS_FUNCTIONS_END


SOURCE_GET_NAME_START
//! Return the name of the type
SgName
$CLASSNAME::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }
SOURCE_GET_NAME_END


SOURCE_TYPEDEF_GET_BASE_TYPE_START
SgType*
$CLASSNAME::get_base_type() const
   {
     return (get_declaration()) ? isSgTypedefDeclaration(get_declaration())->get_base_type() : (SgType*)0L;
   }
SOURCE_TYPEDEF_GET_BASE_TYPE_END

SOURCE_GET_BASE_TYPE_START
SgType*
$CLASSNAME::get_base_type() const
   {
     return p_base_type;
   }
SOURCE_GET_BASE_TYPE_END


SOURCE_SET_BASE_TYPE_START
void
$CLASSNAME::set_base_type(SgType* new_val)
   {
     p_base_type = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_base_type)
          p_base_type->set_parent(this);
#endif
   }
SOURCE_SET_BASE_TYPE_END


// ########################################################
// ########################################################
//           TYPE SPECIFIC FUNCTION DEFINITIONS
// ########################################################
// ########################################################

SOURCE_MAIN_TYPE_START

//! SgType default constructor (initializes all local variables)
SgType::SgType()
   : p_substitutedForTemplateParam(false),
     p_ref_to(NULL),
     p_ptr_to(NULL),
     p_modifiers(NULL),
     p_typedefs(NULL),
     p_rvalue_ref_to(NULL),
     p_decltype_ref_to(NULL),
     p_typeof_ref_to(NULL),
  // DQ (10/3/2010): Readded to the SgType since it is used uniformally within Fortran types.
  // DQ (12/1/2007): This has been moved to the SgModifierType
     p_type_kind(NULL),
     p_attributeMechanism(NULL)
   {
     ROSE_ASSERT(p_ref_to == NULL);
     ROSE_ASSERT(p_ptr_to == NULL);
     ROSE_ASSERT(p_modifiers == NULL);

     p_typedefs = new SgTypedefSeq();

     ROSE_ASSERT(p_typedefs != NULL);
     ROSE_ASSERT(p_rvalue_ref_to == NULL);
     ROSE_ASSERT(p_decltype_ref_to == NULL);
     ROSE_ASSERT(p_typeof_ref_to == NULL);

  // FMZ (2/6/2009): Added a flag for CoArray
     p_isCoArray = false;

  // DQ (12/1/2007): This has been moved to the SgModifierType
  // ROSE_ASSERT(p_type_kind == NULL);

  // DQ (1/25/2007): Let's try this again!
  // DQ (6/25/2006): Commented out to allow File I/O to work, I don't understand why it is required!
  // DQ (5/11/2006): Added to avoid NULL pointer
     p_typedefs->set_parent(this);
   }


SgType::SgType(const SgType & X)
   : p_substitutedForTemplateParam(X.p_substitutedForTemplateParam),
     p_ref_to(X.p_ref_to),
     p_ptr_to(X.p_ptr_to),
     p_modifiers(X.p_modifiers),
     p_typedefs(X.p_typedefs),
     p_rvalue_ref_to(X.p_rvalue_ref_to),
     p_decltype_ref_to(X.p_decltype_ref_to),
     p_typeof_ref_to(X.p_typeof_ref_to),
  // DQ (10/3/2010): Readded to the SgType since it is used uniformally within Fortran types.
  // DQ (12/1/2007): This has been moved to the SgModifierType
     p_type_kind(X.p_type_kind),
     p_attributeMechanism(X.p_attributeMechanism)
   {
  // DQ (10/17/2007): This copy constructor is built to support the AST copy mechanism where for
  // some declarations that generate named types, the types are copied. and fixed up in a later
  // phase (e.g. SgClassDeclaration::fixupCopy()).

  // I think if we copy X then we want to assume that it has these values, but it might
  // be acceptable if it didn't, but then a more complex copy would be required.

  // FMZ (2/6/2009): Added a flag for CoArray
     p_isCoArray = false;

     p_typedefs = new SgTypedefSeq();
     ROSE_ASSERT(p_typedefs != NULL);
     p_typedefs->set_parent(this);
   }

SgName
SgType::get_mangled(void) const
   {
  // This should be an error, I think!
     printf ("ERROR: base calss get_mangled functions should not be called! \n");
     ROSE_ABORT();

     return "";
   }

bool
SgType::isIntegerType() const
   {
     const $CLASSNAME* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
        {
          t = ((SgTypedefType *) t)->get_base_type();
          ROSE_ASSERT(t != NULL);
        }

     switch (variant())
        {
          case T_CHAR:
          case T_SIGNED_CHAR:
          case T_UNSIGNED_CHAR:
          case T_SHORT:
          case T_SIGNED_SHORT:
          case T_UNSIGNED_SHORT:
          case T_INT:
          case T_SIGNED_INT:
          case T_UNSIGNED_INT:
          case T_LONG:
          case T_SIGNED_LONG:
          case T_UNSIGNED_LONG:
          case T_WCHAR:

       // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
          case T_CHAR16:
          case T_CHAR32:

          case T_LONG_LONG:
          case T_SIGNED_LONG_LONG:
          case T_UNSIGNED_LONG_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_SIGNED_128BIT_INTEGER:
          case T_UNSIGNED_128BIT_INTEGER:
          case T_BOOL:
               return true; // 1
               break;

          default:
               return false; // 0
        }
   }

bool
SgType::isFloatType() const
   {
     const SgType* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     switch (t->variant())
        {
          case T_FLOAT :

       // DQ (4/20/2019): Added additional floating point types to be classified as (isFloatType() == true) by this function.
          case T_FLOAT80 :
          case T_FLOAT128 :

          case T_DOUBLE:
          case T_LONG_DOUBLE:
               return 1;
               break;

          default:
               return 0;
        }
   }

bool
SgType::isUnsignedType() const
   {
     switch (variant())
        {
          case T_UNSIGNED_CHAR:
          case T_UNSIGNED_SHORT:
          case T_UNSIGNED_INT:
          case T_UNSIGNED_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_UNSIGNED_LONG_LONG:
          case T_UNSIGNED_128BIT_INTEGER:
               return 1;
               break;

          default:
               return 0;
        }
   }


bool
SgType::isPrimativeType() const
   {
  // DQ (4/20/2019): Added query for primative types so that they can be easily skipped in name qualification.
  // Note that a typedef type is not a primative type, even if it resolves to such a type (because it can be name qualified).
  // A typedef type may be otherwise type equvalent to a primative type.

     switch (variant())
        {
       // The list of types from isIntegerType() function
          case T_CHAR:
          case T_SIGNED_CHAR:
          case T_UNSIGNED_CHAR:
          case T_SHORT:
          case T_SIGNED_SHORT:
          case T_UNSIGNED_SHORT:
          case T_INT:
          case T_SIGNED_INT:
          case T_UNSIGNED_INT:
          case T_LONG:
          case T_SIGNED_LONG:
          case T_UNSIGNED_LONG:
          case T_WCHAR:

       // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
          case T_CHAR16:
          case T_CHAR32:

          case T_LONG_LONG:
          case T_SIGNED_LONG_LONG:
          case T_UNSIGNED_LONG_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_SIGNED_128BIT_INTEGER:
          case T_UNSIGNED_128BIT_INTEGER:
          case T_BOOL:

       // float types
          case T_FLOAT :
          case T_FLOAT80 :
          case T_FLOAT128 :
          case T_DOUBLE:
          case T_LONG_DOUBLE:

       // Other kinds of float types.
          case T_COMPLEX:
          case T_IMAGINARY:

       // Other types
          case T_VOID:
          case T_LABEL:
          case T_NULLPTR:
          case T_DECLTYPE:
          case T_STRING:

               return true; // 1
               break;

          default:
               return false; // 0
        }
   }



SgType*
SgType::integer_promotion(SgType * t1, SgType * t2)
   {
     if(!t1) return t2;
     if(!t2) return t1;

     if (t1->variant() == T_UNSIGNED_LONG || t2->variant() == T_UNSIGNED_LONG)
          return SgTypeUnsignedLong::createType();

  // This should only be if long can hold unsigned int, not always true!!
     if (t1->variant() == T_UNSIGNED_INT || t2->variant() == T_UNSIGNED_INT)
          return SgTypeLong::createType();

     if (t1->isUnsignedType())
          return t1;
       else
          if (t2->isUnsignedType() )
               return t2;
            else
               return SgTypeInt::createType();
   }

SgType*
SgType::float_promotion( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2;
     if(!t2) return t1;

     if (t1->variant() == T_LONG_DOUBLE)
          return t1;
       else
          if (t2->variant() == T_LONG_DOUBLE)
               return t2;
            else
               if (t1->variant() == T_DOUBLE)
                    return t1;
                 else
                    if (t2->variant() == T_DOUBLE)
                         return t2;
                      else
                         return t1;
   }

SgType*
SgType::arithmetic_conversions ( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2;
     if(!t2) return t1;

     if (t1->isFloatType() && t2->isIntegerType())
          return t1;

     if (t2->isFloatType() && t1->isIntegerType())
          return t2;

     if (t1->isIntegerType())
          return integer_promotion(t1,t2);
       else
          return float_promotion(t1,t2);
   }

SgType*
SgType::dereference()
   {
  // This function does not recursively decend into types, so it should not use the lower
  // level SgType::stripType() member function.

     SgType* t = this;
     ROSE_ASSERT(t != NULL);
     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     if (t->variant() == T_POINTER)
          return ((SgPointerType *) t)->get_base_type();
       else
          if (t->variant() == T_REFERENCE)
               return ((SgReferenceType *) t)->get_base_type();
            else
               if(t->variant() == T_ARRAY)
                    return ((SgArrayType *) t)->get_base_type();
                 else
                    return (SgType*)t;
   }

SgType*
SgType::stripTypedefsAndModifiers() const
   {
  // DQ (6/30/2005): This function answers the question of what type is this? It recursively
  // strips away typedefs until we reach something not typedefeds, thus we stop at any pointer
  // or references (but not modifiers).

  // DQ (10/11/2007): Modified this function to use SgType::stripType().
  // This uses a subset of the possible or'd values available with SgType::stripType()
     return stripType(STRIP_MODIFIER_TYPE | STRIP_TYPEDEF_TYPE);
   }

SgType*
SgType::findBaseType() const
   {
  // This uses the default value for SgType::stripType(), namely
  // (bit_array == STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE)
     return stripType();
   }

#define DEBUG_SGTYPE_STRIPTYPE 0
#define DEBUG_SGTYPE_STRIPTYPE_MORE 0

SgType*
SgType::stripType(unsigned char bit_array) const
   {
  // This function forms the low level support for both SgType::findBaseType()
  // and SgType::stripTypedefsAndModifiers().  It takes a default valued
  // bit_array == (STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE | STRIP_POINTER_MEMBER_TYPE)
  // Alternatively any of these value may be ORed together to for other combinations.

  // Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SageInterface::detectCycleInType(currentType, "SgType::stripType");

#if DEBUG_SGTYPE_STRIPTYPE
     printf ("Inside of SgType::stripType(bit_array = %u): this = %p = %s \n",bit_array,currentType,currentType->class_name().c_str());
#endif

     SgModifierType*        modType     = NULL;
     SgPointerType*         pointType   = NULL;
     SgReferenceType*       refType     = NULL;
     SgRvalueReferenceType* rRefType    = NULL;
     SgArrayType*           arrayType   = NULL;
     SgTypedefType*         typedefType = NULL;

     SgPointerMemberType*   pointerMemberType = NULL;

     size_t counter = 0;
     while (true)
        {
#if DEBUG_SGTYPE_STRIPTYPE
          printf ("In loop of SgType::stripType(bit_array = %u): counter = %" PRIuPTR " this = %p = %s = %s \n",bit_array,counter,currentType,currentType->class_name().c_str(),currentType->unparseToString().c_str());
#endif
          if ( (bit_array & STRIP_MODIFIER_TYPE) && (modType = isSgModifierType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgModifierType \n");
#endif
               currentType = modType->get_base_type();
             }
          else if ( (bit_array & STRIP_REFERENCE_TYPE) &&  (refType = isSgReferenceType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgReferenceType \n");
#endif
               currentType = refType->get_base_type();
             }
          else if ( (bit_array & STRIP_RVALUE_REFERENCE_TYPE) &&  (rRefType = isSgRvalueReferenceType(currentType)) )
             {
               currentType = rRefType->get_base_type();
             }
       // DQ (4/15/2019): I don't think this should apply to SgPointerMemberType (which maybe should not be derived from SgPointerType).
       // Is SgPointerMemberType a kind of type that should be something we should support in this stripType function?
          else if ( (bit_array & STRIP_POINTER_TYPE) && ((pointType = isSgPointerType(currentType)) && (isSgPointerMemberType(currentType) == NULL)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgPointerType (that is not SgPointerMemberType) \n");
#endif
            // DQ (4/15/2019): Added assertion.
               ROSE_ASSERT(pointType != NULL);

               currentType = pointType->get_base_type();
             }
          else if ( (bit_array & STRIP_POINTER_MEMBER_TYPE) && (pointerMemberType = isSgPointerMemberType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgPointerMemberType \n");
#endif
               currentType = pointerMemberType->get_base_type();
             }
          else if ( (bit_array & STRIP_ARRAY_TYPE) && (arrayType = isSgArrayType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgArrayType \n");
#endif
               currentType = arrayType->get_base_type();
             }
          else if ( (bit_array & STRIP_TYPEDEF_TYPE) && (typedefType = isSgTypedefType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgTypedefType: currentType = %p = %s typedefType->get_base_type() = %p = %s \n",
                    currentType,currentType->class_name().c_str(),typedefType->get_base_type(),typedefType->get_base_type()->class_name().c_str());
#endif
            // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
               currentType = typedefType->get_base_type();
             }
            else
             {
            // Exit the while(true){} loop!
               ROSE_ASSERT(currentType != NULL);
#if DEBUG_SGTYPE_STRIPTYPE
               printf ("In loop of SgType::stripType(): exiting loop: currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
               break;
             }

       // DQ (7/4/2013): This should be a reasonable limit.
          if (counter >= 80)
             {
               printf ("In loop of SgType::stripType(bit_array = %u): counter = %" PRIuPTR " currentType = %p = %s = %s\n",bit_array,counter,currentType,currentType->class_name().c_str(),currentType->unparseToString().c_str());
             }

          if (counter >= 100)
             {
            // Exit loop and return the currentType...
               printf ("In loop of SgType::stripType(bit_array = %u): exiting loop using currentType (counter = %" PRIuPTR ") currentType = %p = %s \n",bit_array,counter,currentType,currentType->class_name().c_str());
             }
          ROSE_ASSERT(counter < 100);

          counter++;
        }

     ASSERT_not_null(currentType);
     return currentType;
   }

SgName
SgType::mangledNameSupport(SgName & fname, SgUnparse_Info & /*info*/)
   {
     ROSE_ASSERT(this != NULL);
     SgName rtmp;

  // This only makes sense to call from either the SgFunctionType or the SgMemberFunctionType
     ROSE_ASSERT(isSgFunctionType(this) != NULL || isSgMemberFunctionType(this) != NULL);

     int len = fname.getString().size();
     std::string opstr  = "operator";
     std::string newstr = "new";
     std::string delstr = "delete";
     unsigned int m = opstr.size();

     if (len > 0 && fname.getString().substr(0, m) == opstr)
        {
          if (fname.getString()[m]==' ')
             {
            // DQ (4/27/2005): "m+2" should be "m+1"
               if (fname.getString().substr(m + 1, newstr.size()) == newstr)
                  {
                 // DQ (4/27/2005): Added support for array new
                    int parenStart = m+1+newstr.size();
                    if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                         rtmp << "__na";
                      else
                         rtmp << "__nw";
                  }
                 else
                  {
                 // DQ (4/27/2005): Added support for array delete
                    if (fname.getString().substr(m + 1, delstr.size()) == delstr)
                       {
                         int deleteStringLength = delstr.size();
                         int parenStart = m+1+deleteStringLength;
                         if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                              rtmp << "__da";
                           else
                              rtmp << "__dl";
                       }
                      else
                       {
                      // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                      // This is the only part that is dependent upon either the SgFunctionType or SgMemberFunctionType.
                         SgFunctionType *functionType = isSgFunctionType(this);
                         ROSE_ASSERT(functionType != NULL);
                         ROSE_ASSERT(functionType->get_return_type() != NULL);

                         rtmp << "__op" << functionType->get_return_type()->get_mangled().str();
                       }
                  }
             }
            else
             {
            // real operator (suffix after the substring "operator ")

            // I think that this case could be used to handle "operator new", "operator new[]",
            // "operator delete", and "operator delete[]".

               SgName opname=&(fname.str()[m]);

               if (opname == SgName("->"))     rtmp << "__rf";
               else if (opname==SgName("->*")) rtmp << "__rm";
               else if (opname==SgName("=="))  rtmp << "__eq";
               else if (opname==SgName("<"))   rtmp << "__lt";
               else if (opname==SgName(">"))   rtmp << "__gt";
               else if (opname==SgName("!="))  rtmp << "__ne";
               else if (opname==SgName("<="))  rtmp << "__le";
               else if (opname==SgName(">="))  rtmp << "__ge";
               else if (opname==SgName("+"))   rtmp << "__pl";
               else if (opname==SgName("-"))   rtmp << "__mi";
               else if (opname==SgName("*"))   rtmp << "__ml";
               else if (opname==SgName("/"))   rtmp << "__dv";
               else if (opname==SgName("%"))   rtmp << "__md";
               else if (opname==SgName("&&"))  rtmp << "__aa";
               else if (opname==SgName("!"))   rtmp << "__nt";
               else if (opname==SgName("||"))  rtmp << "__oo";
               else if (opname==SgName("^"))   rtmp << "__er";
               else if (opname==SgName("&"))   rtmp << "__ad";
               else if (opname==SgName("|"))   rtmp << "__or";
               else if (opname==SgName(","))   rtmp << "__cm";
               else if (opname==SgName("<<"))  rtmp << "__ls";
               else if (opname==SgName(">>"))  rtmp << "__rs";
               else if (opname==SgName("--"))  rtmp << "__mm";
               else if (opname==SgName("++"))  rtmp << "__pp";
               else if (opname==SgName("~"))   rtmp << "__co";
               else if (opname==SgName("="))   rtmp << "__as";
               else if (opname==SgName("+="))  rtmp << "__apl";
               else if (opname==SgName("-="))  rtmp << "__ami";
               else if (opname==SgName("&="))  rtmp << "__aad";
               else if (opname==SgName("|="))  rtmp << "__aor";
               else if (opname==SgName("*="))  rtmp << "__amu";
               else if (opname==SgName("/="))  rtmp << "__adv";
               else if (opname==SgName("%="))  rtmp << "__amd";
               else if (opname==SgName("^="))  rtmp << "__aer";
               else if (opname==SgName("<<=")) rtmp << "__als";
               else if (opname==SgName(">>=")) rtmp << "__ars";
               else if (opname==SgName("()"))  rtmp << "__cl";
               else if (opname==SgName("[]"))  rtmp << "__xi";
               else
                  {
                 // DQ (1/8/2006): This is the case of a name that just happends to start with
                 // the work "operator" (e.g. operator_takes_lvalue_operand, in test2005_198.C)
                 // the mangle form is just the unmodified function name.
                    rtmp = fname;
                  }
             }
        }
       else
          rtmp << fname.str();

     return rtmp;
   }

bool
SgType::handledUsingLocalTable(SgType* t)
   {
  // Not all types can use the global type table, since during construction of the AST the
  // scopes may not be fully defined yet.  The local type table can be merged into the
  // global type table as a post-processing step.

     bool returnValue = false;

  // DQ (9/3/2012): I think this should be modified to include SgTemplateType as well.
  // PP (11/22/2021): added ada types.
  //                  Question: should this be named types (isSgNamedType) in general?
     if (  isSgEnumType(t) != NULL
        || isSgClassType(t) != NULL
        || isSgTypedefType(t) != NULL
        || isSgAdaTaskType(t) != NULL
        || isSgAdaProtectedType(t) != NULL
        || isSgAdaDiscriminatedType(t) != NULL
        //~ || isSgAdaFormalType(t) != NULL /* todo: add to local type tables */
        )
        {
          returnValue = true;
        }

  // DQ (9/4/2012): I have made SgTemplateType be stored in the local type table.
  // DQ (9/3/2012): I think this should be modified to include SgTemplateType as well.
     SgTemplateType* templateType = isSgTemplateType(t);
     SgNonrealType* nonrealType = isSgNonrealType(t);
     if (templateType != NULL || nonrealType != NULL)
        {
          returnValue = true;
        }

     return returnValue;
   }

// Kitware 2013/03/25
// This is a workaround for the lack of EDG on Windows.
// Once that problem is resolved, this include file can go away.
#ifdef USE_FAKE_EDG
  #include "fake_EDG.h"
#endif

// Liao 10/29/2010
// My understanding of this code (may not be accurate):
//  This function was designed to work with C/C++ and Fortran frontends to generate AST.
//  So code has to be conditionized with proper #ifdef ..#endf around the use of the variable or stack.
//
//  Now we allow users to build types during AST transformation. This function will be called and scope can be NULL
//  Neither the stack or global variable in frontends are used in this situation either.
//  But this is perfectly legal.
SgScopeStatement*
SgType::getCurrentScope()
   {
  // This function is used to provide the global type table support with a common
  // mechanism to know the scope when generating types.  So types have to know their
  // declaration's scope and it is taken from the current scope that is kept track
  // of using either of a few (two) mechanisms durring the construction of the AST
  // from the frontend.  The mechanism is language dependent, or always returning
  // a NULL pointer (in the case of the AST Builder if the stack is not used, and we
  // are not using the EDG 3.3 connection to ROSE...).

  // Note that this function is an alternative to the specification of the scope directly
  // in the construction of each IR node.  Though I like the direct specification better,
  // such an approach would force us to change the ROSETTA generated API for a moderate
  // number of SgStatement IR nodes and it would likely break some user code.  So we need
  // to schedule this for a later date.  It should not be an issue for anyone using the
  // AST Build Interface.

  // Liao 8/3/2010, pass fortran only test
// #ifdef ROSE_BUILD_CXX_LANGUAGE_SUPPORT

// Liao 8/4/2010, support enable-only-c
#ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT
  // This is what is used in the Open Fortran Parser connection.
     extern SgScopeStatement* getTopOfScopeStack();

  // These functions are used to test if we can use the fortran specific function above.
     extern bool emptyFortranStateStack();
     extern bool emptyFortranScopeStack();
#endif

     SgScopeStatement* currentScope = NULL;
#ifdef ROSE_BUILD_CXX_LANGUAGE_SUPPORT
     if (SageBuilder::emptyScopeStack() == false)
        {
       // C/C++ AST being generated (using new connection to EDG 4.x).
          currentScope = SageBuilder::topScopeStack();
          ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);
        }
       else
#endif
        {
#ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT // Liao 8/4/2010, support enable-only-c
       // DQ (7/31/2010): If Fortran is not enabled then these functions will not be available.

       // Changed check for emptyFortranStateStack to emptyFortranScopeStack. An error can occur
       // when the state stack is not empty but the scope stack is. This error was found when
       // running tests in the experimental_frontend_tests directory. Perhaps junk was left in the
       // Fortran state stack from tests run earlier in the parent Fortran test directory.
       // WARNING, the following relies on short circuiting and emptyFortranStateStack() == false
       // must be checked before emptyFortranScopeStack() == false.
       // Apparently Java is also examining the Fortran stack! [CR 2019-7-18].
          if (SageInterface::is_Fortran_language() && emptyFortranStateStack() == false && emptyFortranScopeStack() == false)
             {
            // Fortran AST being generated
               currentScope = getTopOfScopeStack();
               ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);
             }
            else
#endif
             {
                  {
                 // This is a code generated after the initial C/C++/Fortran AST was built, so we don't know the current scope.
                // Liao 10/29/2010. We allow users to build types during AST transformation, which will trigger this line.
                    if ( SgProject::get_verbose() > 1 )
                      printf ("In SgType::getCurrentScope(): Not in either the generation of C/C++ or Fortran AST construction \n");
                    currentScope = NULL;
                  }
             }
        }

  // DQ (7/23/2010): Add this as another test...
  // ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);

     return currentScope;
   }

SgDeclarationStatement*
SgType::getAssociatedDeclaration() const
   {
     SgDeclarationStatement* declaration = NULL;

  // Resolve to the base type (but not past typedef types).  Note that a subtle point is that
  // we want to avoid expressing typedefs that are private in functions that are public.
     SgType* strippedType = this->stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);
     ROSE_ASSERT(strippedType != NULL);

  // Check if this is a named type (either SgClassType, SgEnumType, or SgTypedefType).
     SgNamedType* namedType = isSgNamedType(strippedType);
     if (namedType != NULL)
        {
       // Look for the declaration and evaluate if it required qualification.
          declaration = namedType->get_declaration();
          ROSE_ASSERT(declaration != NULL);

       // DQ (5/25/2013): Check if the declaration might have been deleted.
          if (declaration->get_freepointer() != AST_FileIO::IS_VALID_POINTER()) {
            printf("Found a pointer to a deleted node:\n");
            printf(" - type = %p (%s)\n", this, this->class_name().c_str());
            printf(" - decl = %p\n", declaration);
            printf(" - name : %s\n", SageInterface::generateUniqueName(this, false).c_str());
          }
          ROSE_ASSERT(declaration->get_freepointer() == AST_FileIO::IS_VALID_POINTER());
        }

  // DQ (4/28/2019): Added support for functions (for which a member function is the base type of SgPointerMemberType
  // when they are pointers to member functions.
     SgFunctionType* functionType = isSgFunctionType(strippedType);
     if (functionType != NULL)
        {
       // DQ (4/28/2019): I think this is the better implementation.
          SgType* returnType = functionType->get_return_type();
          ROSE_ASSERT(returnType != NULL);

          declaration = returnType->getAssociatedDeclaration();
        }

     return declaration;
   }

bool SgType::hasExplicitType()
   {
  // DQ (3/7/2014):  Tis could be implemented as a virtual function but would require 11 functions to be
  // implemented. I have thus instead implemented it as a single function on the SgType instead. We
  // can review this if it is important.

  // This function returns true only if this is either a SgPointerType, SgReferenceType, SgPointerMemberType,
     bool returnValue = false;

     if ( isSgPointerType(this) != NULL        || isSgArrayType(this)    != NULL          || isSgReferenceType(this) != NULL     ||
          isSgPointerMemberType(this) != NULL  || isSgJavaParameterizedType(this) != NULL || isSgJavaWildcardType(this)  != NULL ||
          isSgMemberFunctionType(this) != NULL || isSgTypeComplex(this) != NULL           || isSgTypeImaginary(this)  != NULL    ||
          isSgFunctionType(this) != NULL       || isSgModifierType(this)  != NULL)
        {
          returnValue = true;
        }

     return returnValue;
   }


bool
SgType::containsInternalTypes()
   {
  // DQ (1/14/2011): Added function to support collection of types in AST node query support.
  // Some types can hide internal types and we often want to resolve type based properties
  // that require us to dig into these specific type IR nodes.  For example, when we traverse
  // an AST subtree we might want to build a list of all referenced types (including indirect
  // references through pointers and arrays, etc.).  This function is a simple interface that
  // communicates the type IR nodes that can hide internal types and thus may require a
  // nested traversal or a specialized recursive traversal.

  // PP (2/17/22) added Ada types

     bool returnValue = false;

     if ( isSgPointerType(this) != NULL || isSgArrayType(this)      != NULL || isSgReferenceType(this) != NULL ||
          isSgTypedefType(this) != NULL || isSgFunctionType(this)   != NULL || isSgModifierType(this)  != NULL ||
          isSgAdaSubtype(this)  != NULL || isSgAdaDerivedType(this) != NULL || isSgAdaAccessType(this) != NULL )
        {
          returnValue = true;
        }

     return returnValue;
   }

Rose_STL_Container<SgType*>
SgType::getInternalTypes() const
   {
  // This function builds a collection of internal types (unordered).

     Rose_STL_Container<SgType*> internalTypes;

  // Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

  // DQ (3/16/2014): Of coruse we need this.
  // Initialize with the input type (not clear if this is helpful).
     internalTypes.push_back(currentType);

     while (true)
        {
          if ( (modType = isSgModifierType(currentType)) )
             {
               currentType = modType->get_base_type();
             }
            else
             {
               if ( (refType = isSgReferenceType(currentType)) )
                  {
                    currentType = refType->get_base_type();
                  }
                 else
                  {
                    if ( (pointType = isSgPointerType(currentType)) )
                       {
                         currentType = pointType->get_base_type();
                       }
                      else
                       {
                         if ( (arrayType = isSgArrayType(currentType)) )
                            {
                              currentType = arrayType->get_base_type();
                            }
                           else
                            {
                              if ( (typedefType = isSgTypedefType(currentType)) )
                                 {
                                   currentType = typedefType->get_base_type();
                                 }
                                else
                                 {
                                // If we have a SgFunctionType then we have to use a different approach to collect
                                // the different associated types.  I am not clear if this function should have
                                // such broad semantics.

                                // Exit the while(true){} loop!
                                   break;
                                 }
                            }
                       }
                  }
             }
          internalTypes.push_back(currentType);
        }

     return internalTypes;
   }

void
SgType::reset_base_type(SgType* baseType)
   {
  // DQ (1/15/2011): This function is used to reset types within Fortran handling.
  // Types that have not been see yet and are required to types within construct declarations
  // are assigned a SgTypeDefault which is then replaces after all declarations have been seem.

     SgType* parentType = (SgType*) this;

     ROSE_ASSERT(parentType != NULL);
     ROSE_ASSERT(parentType->containsInternalTypes() == true);

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

     if ( (modType = isSgModifierType(parentType)) )
        {
          modType->set_base_type(baseType);
        }
       else
        {
          if ( (refType = isSgReferenceType(parentType)) )
             {
               refType->set_base_type(baseType);
             }
            else
             {
               if ( (pointType = isSgPointerType(parentType)) )
                  {
                    pointType->set_base_type(baseType);
                  }
                 else
                  {
                    if ( (arrayType = isSgArrayType(parentType)) )
                       {
                         arrayType->set_base_type(baseType);
                       }
                      else
                       {
                         if ( (typedefType = isSgTypedefType(parentType)) )
                            {
                           // DQ (1/15/2011): This does not make sense to approach this way, and I think is not required for Fortran support (at least).
                           // typedefType->set_base_type(baseType);
                              ROSE_ASSERT(typedefType->get_declaration() != NULL);
                              printf ("Error: Typedef can't have there base type reset! \n");
                              ROSE_ASSERT(false);
                            }
                           else
                            {
                              printf ("Unable to reset the base type for parentType = %p = %s \n",parentType,parentType->class_name().c_str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
             }
        }
   }

// SKW (3/1/2011): Added these explicit implementations since we no longer build them automatically
SgExpression *
SgType::get_type_kind () const
   {
     return p_type_kind;
   }

void
SgType::set_type_kind ( SgExpression* type_kind )
   {
     p_type_kind = type_kind;
   }


bool
SgType::isEquivalentType (const SgType* other_type) const
   {
     return SageInterface::isEquivalentType(this,other_type);
   }

SOURCE_MAIN_TYPE_END


SOURCE_BUILTIN_TYPE_SUPPORT_START
SOURCE_BUILTIN_TYPE_SUPPORT_END


SOURCE_TYPE_UNKNOWN_TYPE_START
SOURCE_TYPE_UNKNOWN_TYPE_END


SOURCE_TYPE_CHAR_TYPE_START
SOURCE_TYPE_CHAR_TYPE_END


SOURCE_TYPE_SIGNED_CHAR_TYPE_START
SOURCE_TYPE_SIGNED_CHAR_TYPE_END


SOURCE_TYPE_UNSIGNED_CHAR_TYPE_START
SOURCE_TYPE_UNSIGNED_CHAR_TYPE_END


SOURCE_TYPE_SHORT_TYPE_START
SOURCE_TYPE_SHORT_TYPE_END


SOURCE_TYPE_SIGNED_SHORT_TYPE_START
SOURCE_TYPE_SIGNED_SHORT_TYPE_END


SOURCE_TYPE_UNSIGNED_SHORT_TYPE_START
SOURCE_TYPE_UNSIGNED_SHORT_TYPE_END


SOURCE_TYPE_INT_TYPE_START
SOURCE_TYPE_INT_TYPE_END


SOURCE_TYPE_SIGNED_INT_TYPE_START
SOURCE_TYPE_SIGNED_INT_TYPE_END


SOURCE_TYPE_UNSIGNED_INT_TYPE_START
SOURCE_TYPE_UNSIGNED_INT_TYPE_END


SOURCE_TYPE_LONG_TYPE_START
SOURCE_TYPE_LONG_TYPE_END


SOURCE_TYPE_SIGNED_LONG_TYPE_START
SOURCE_TYPE_SIGNED_LONG_TYPE_END


SOURCE_TYPE_UNSIGNED_LONG_TYPE_START
SOURCE_TYPE_UNSIGNED_LONG_TYPE_END


SOURCE_TYPE_VOID_TYPE_START
SOURCE_TYPE_VOID_TYPE_END


SOURCE_TYPE_GLOBAL_VOID_TYPE_START
SOURCE_TYPE_GLOBAL_VOID_TYPE_END


SOURCE_TYPE_WCHAR_TYPE_START

SOURCE_TYPE_WCHAR_TYPE_END


SOURCE_TYPE_CHAR16_TYPE_START

SOURCE_TYPE_CHAR16_TYPE_END


SOURCE_TYPE_CHAR32_TYPE_START

SOURCE_TYPE_CHAR32_TYPE_END


SOURCE_TYPE_FLOAT_TYPE_START
SOURCE_TYPE_FLOAT_TYPE_END


SOURCE_TYPE_DOUBLE_TYPE_START
SOURCE_TYPE_DOUBLE_TYPE_END


SOURCE_TYPE_LONG_LONG_TYPE_START
SOURCE_TYPE_LONG_LONG_TYPE_END


SOURCE_TYPE_SIGNED_LONG_LONG_TYPE_START
SOURCE_TYPE_SIGNED_LONG_LONG_TYPE_END


SOURCE_TYPE_UNSIGNED_LONG_LONG_TYPE_START
SOURCE_TYPE_UNSIGNED_LONG_LONG_TYPE_END


SOURCE_TYPE_SIGNED_128BIT_TYPE_START
SOURCE_TYPE_SIGNED_128BIT_TYPE_END


SOURCE_TYPE_UNSIGNED_128BIT_TYPE_START
SOURCE_TYPE_UNSIGNED_128BIT_TYPE_END

SOURCE_TYPE_TUPLE_START

SgTypePtrList&
SgTypeTuple::get_types()
   { return p_types; }

const SgTypePtrList&
SgTypeTuple::get_types() const
   { return p_types; }

void
SgTypeTuple::append_type(SgType *what)
   { what->set_parent(this); p_types.push_back(what); }

void
SgTypeTuple::prepend_type(SgType *what)
   { what->set_parent(this); p_types.insert(p_types.begin(), what); }

SOURCE_TYPE_TUPLE_END

SOURCE_TYPE_LONG_DOUBLE_TYPE_START
SOURCE_TYPE_LONG_DOUBLE_TYPE_END


SOURCE_TYPE_STRING_TYPE_START

// DQ (8/17/2010): Added support for SgTypeString.
void
SgTypeString::post_construction_initialization()
   {
   }

SOURCE_TYPE_STRING_TYPE_END


SOURCE_TYPE_BOOL_TYPE_START
SOURCE_TYPE_BOOL_TYPE_END


SOURCE_TYPE_COMPLEX_TYPE_START
SOURCE_TYPE_COMPLEX_TYPE_END


SOURCE_TYPE_DEFAULT_TYPE_START

SgName
SgTypeDefault::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_DEFAULT_TYPE" << "b__" // start tag
                  << p_name.str() // name of default type
                  << "__" << "MANGLED_ID_DEFAULT_TYPE" << "e__"; // end tag

     return mangled_name;
   }

SgTypeDefault*
SgTypeDefault::createType ( const SgName & nameOfType )
   {
     SgTypeDefault* returnType = new SgTypeDefault();
     if (nameOfType.is_null() == false)
        {
          returnType->set_name(nameOfType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgTypeDefault(t);
        }

     return returnType;
   }

SOURCE_TYPE_DEFAULT_TYPE_END


SOURCE_TYPE_LABEL_TYPE_START

SgName
SgTypeLabel::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_LABEL_TYPE" << "b__" // start tag
                  << p_name.str() // name of default type
                  << "__" << "MANGLED_ID_LABEL_TYPE" << "e__"; // end tag

     return mangled_name;
   }

SgTypeLabel*
SgTypeLabel::createType ( const SgName & nameOfType )
   {
     SgTypeLabel* returnType = new SgTypeLabel();
     if (nameOfType.is_null() == false)
        {
          returnType->set_name(nameOfType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = isSgTypeLabel(t);
        }

     return returnType;
   }

SOURCE_TYPE_LABEL_TYPE_END


SOURCE_POINTER_TYPE_START
SOURCE_POINTER_TYPE_END


SOURCE_POINTER_MEMBER_TYPE_START

// DQ (4/11/2019): This function supports returning a SgDeclarationStatement instead of a SgClassDeclaration,
// which will always be well define where returning a SgClassDefinition is not always well defined.  Using
// a SgDeclarationStatement will also allow it to work with the case of pointer to member associated with
// SgNonrealType IR nodes as well.
SgDeclarationStatement*
SgPointerMemberType::get_class_declaration_of() const
   {
     SgDeclarationStatement* result = NULL;

     if (get_class_type() != NULL)
        {
          SgType* type = get_class_type()->stripTypedefsAndModifiers();
          SgClassType *clsType = isSgClassType(type);

          if (clsType != NULL)
             {
            // DQ (4/11/2019): Note that the defining declaration may not exist.
               SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration());
               result = clsDecl;
             }
            else
             {
               SgNonrealType* nonrealType = isSgNonrealType(type);
               ROSE_ASSERT(nonrealType != NULL);
               result = nonrealType->get_declaration();
             }
        }

     ASSERT_not_null(result);
     return result;
   }

// DQ (4/11/2019): This is a deprecated function, because it can not always return a valid SgClassDefinition.
SgClassDefinition*
SgPointerMemberType::get_class_definition_of() const
   {
     SgClassDefinition* result = NULL;

     if (get_class_type() != NULL)
        {
          SgType* type = get_class_type()->stripTypedefsAndModifiers();
          SgClassType *clsType = isSgClassType(type);

          if (clsType != NULL)
             {
               SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration()->get_definingDeclaration());

            // DQ (4/10/2019): This should not be an error when the SgClassDefinition is not available.
            // But we might want to change the API to return the SgClassDeclaration instead.

            // DQ (4/10/2019): This should not be an error when the SgClassDefinition is not available.
               if (clsDecl != NULL)
                  {
                    result = clsDecl->get_definition();
                  }
                 else
                  {
                    printf ("NOTE: SgPointerMemberType::get_class_definition_of() retuning NULL: use SgPointerMemberType::get_class_declaration_of() instead! \n");
                  }
             }
            else
             {
               printf ("WARNING: SgPointerMemberType::get_class_definition_of() retuning NULL type = %p = %s \n",type,type->class_name().c_str());
             }
        }

     return result;
   }


SgName
SgPointerMemberType::get_qualified_name_prefix_for_class_of() const
   {
  // DQ (4/18/2019): Adding support for type chains of types (including SgPointerMemberType).

  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgVarRefExp
  //    SgFunctionRefExp
  //    SgMemberFunctionRefExp

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (4/20/2019): Use the globalQualifiedNameMapForNames for the get_qualified_name_prefix_for_class_of() function.
  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgPointerMemberType*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("nameQualifier for SgType = %p = %p = %s = %s \n",this,const_cast<SgType*>(this),class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }


SgName
SgPointerMemberType::get_qualified_name_prefix_for_base_type() const
   {
  // DQ (4/18/2019): Adding support for type chains of types (including SgPointerMemberType).

  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgVarRefExp
  //    SgFunctionRefExp
  //    SgMemberFunctionRefExp

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("In SgPointerMemberType::get_qualified_name_prefix(): search globalQualifiedNameMapForTypes: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgPointerMemberType*>(this));

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("nameQualifier for SgType = %p = %p = %s = %s \n",this,const_cast<SgType*>(this),class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }

SOURCE_POINTER_MEMBER_TYPE_END


SOURCE_REFERENCE_TYPE_START
SOURCE_REFERENCE_TYPE_END


SOURCE_RVALUE_REFERENCE_TYPE_START
SOURCE_RVALUE_REFERENCE_TYPE_END


SOURCE_DECL_TYPE_START

void
SgDeclType::set_base_type(SgType* base_type)
   {
     ROSE_ASSERT(base_type != NULL);
     if (p_base_expression == NULL || (isSgFunctionParameterRefExp(p_base_expression) != NULL))
        {
          p_base_type = base_type;
        }
       else
        {
       // Prefer the one available in p_base_expression.
          p_base_type = NULL;
          if (base_type != p_base_expression->get_type())
             {
               printf ("Error: base_type in SgDeclType::set_base_type() does not match p_base_expression->get_type() \n");
             }
          ROSE_ASSERT(base_type == p_base_expression->get_type());
        }
   }

SgType*
SgDeclType::get_base_type() const
   {
     SgType* return_type = NULL;
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(p_base_expression != NULL);
     if (p_base_expression == NULL || isSgFunctionParameterRefExp(p_base_expression) != NULL)
        {
          return_type = p_base_type;
        }
       else
        {
          return_type = p_base_expression->get_type();
        }

     ROSE_ASSERT(return_type != NULL);

     return return_type;
  // return p_base_expression->get_type();
   }

SgName
SgDeclType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT (p_base_expression != NULL);

     SgName mangled_name;
     mangled_name << "__bdecltype__"
                  << mangleExpression(p_base_expression)
                  << "__edecltype__";

     return mangled_name;
   }

SOURCE_DECL_TYPE_END


SOURCE_TYPEOF_TYPE_START

void
SgTypeOfType::set_base_type(SgType* base_type)
   {
     ROSE_ASSERT(base_type != NULL);
     if (p_base_expression == NULL || (isSgFunctionParameterRefExp(p_base_expression) != NULL))
        {
          p_base_type = base_type;
        }
       else
        {
       // Prefer the one available in p_base_expression.
          p_base_type = NULL;
          if (base_type != p_base_expression->get_type())
             {
               printf ("Error: base_type in SgTypeOfType::set_base_type() does not match p_base_expression->get_type() \n");
             }
          ROSE_ASSERT(base_type == p_base_expression->get_type());
        }
   }

SgType*
SgTypeOfType::get_base_type() const
   {
     SgType* return_type = NULL;
     ROSE_ASSERT(this != NULL);
  // ROSE_ASSERT(p_base_expression != NULL);
     if (p_base_expression == NULL || isSgFunctionParameterRefExp(p_base_expression) != NULL)
        {
          return_type = p_base_type;
        }
       else
        {
          return_type = p_base_expression->get_type();
        }

     ROSE_ASSERT(return_type != NULL);

     return return_type;
  // return p_base_expression->get_type();
   }

/*! Returns a mangled name representation of types taking expressions and base types (e.g., pointer, reference).
 */
SgName
SgTypeOfType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);

     SgName base_name = base_type->get_mangled();

  // This can be NULL.
     const SgExpression* base_expression = get_base_expression();
     if (base_expression != NULL)
        {
          base_name += string("_base_expr_") + Rose::StringUtility::numberToString(this);
        }

     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << base_name.str () // base expression and type
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
     return mangled_name;
   }

SOURCE_TYPEOF_TYPE_END


SOURCE_NAMED_TYPE_START

SgNamedType::SgNamedType ( const SgNamedType & X )
   {
     p_declaration            = X.p_declaration;
     p_autonomous_declaration = X.p_autonomous_declaration;
     ASSERT_not_null(p_declaration);
   }

SgName
SgNamedType::get_name() const
   {
     printf ("Error: base class $CLASSNAME::get_name() called! \n");
     ROSE_ABORT();

     return SgName();
   }


SgName
SgNamedType::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

     ROSE_ASSERT(get_declaration() != NULL);

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_declaration()->get_scope();
     ROSE_ASSERT(scope != NULL);

     return SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
   }

SOURCE_NAMED_TYPE_END


SOURCE_CLASS_TYPE_START
SgClassType::SgClassType ( const SgClassType & X )
   : SgNamedType(X)
   {
   }


SgName
SgClassType::get_name() const
   {
  // DQ (12/4/2011): Adding support for template declarations in the AST.
     SgDeclarationStatement* declaration = get_declaration();
     if (declaration != NULL)
        {
       // DQ (12/4/2011): Handling support for SgClassDeclaration and SgTemplateClassDeclaration declarations.
          SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
          SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(declaration);
          if (templateClassDeclaration != NULL) {
            return templateClassDeclaration->get_name();
          } else if (classDeclaration != NULL) {
            return classDeclaration->get_name();
          } else {
            ROSE_ASSERT(false);
          }
        }
       else
        {
          return SgName((char *)0L);
        }
   }


// RV (1/31/2006): Changed behavior to return a fully-qualified, mangled name.
/*! Returns a mangled name (with embedded, mangled qualifiers).
 *  \note If the class is anonymous, e.g.,
 *    typedef struct { int a; char b; } tag_t;
 *  then this routine returns an empty name.
 */
#define DEBUG_CLASS_TYPE_GET_MANGLED 0
SgName
SgClassType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

#if DEBUG_CLASS_TYPE_GET_MANGLED
     printf ("In SgClassType::get_mangled(): get_name() = %s \n",get_name().str());
#endif

     SgName mangled_name;
  // if (get_name().get_length() != 0) // not anonymous
     if (get_name().is_null() == false) // not anonymous
        {
          const SgClassDeclaration* class_decl = isSgClassDeclaration(get_declaration());
#if DEBUG_CLASS_TYPE_GET_MANGLED
          printf ("In SgClassType::get_mangled(): class_decl = %p = %s \n",class_decl, ((class_decl == NULL) ? "NULL" : class_decl->class_name().c_str()) );
#endif
          if (class_decl != NULL)
             {
            // DQ (3/14/2012): We need to have a valid scope or else the name qualification will be empty.
               ROSE_ASSERT(class_decl->get_scope() != NULL);

            // DQ (7/29/2010): Template instantiation declarations can differ on template parameters so we have to dig a little farther.
               const SgTemplateInstantiationDecl* template_class_inst = isSgTemplateInstantiationDecl(get_declaration());
               const SgTemplateClassDeclaration* template_class_decl = isSgTemplateClassDeclaration(get_declaration());
               if (template_class_inst != NULL)
                  {
                    mangled_name = template_class_inst->get_mangled_name();
#if DEBUG_CLASS_TYPE_GET_MANGLED
                    printf ("In SgClassType::get_mangled(): SgTemplateInstantiationDecl mangled_name = %s \n",mangled_name.str());
#endif
                  }
                 else if (template_class_decl != NULL)
                  {
                    mangled_name = template_class_decl->get_mangled_name();
                  }
                 else
                  {
                 // DQ (3/14/2012): We need to have a valid scope or else the name qualification will be empty.
                    ROSE_ASSERT(class_decl->get_scope() != NULL);

                 // This is for just a simple SgClassDeclaration.
                    mangled_name = class_decl->get_mangled_name();
#if DEBUG_CLASS_TYPE_GET_MANGLED
                    printf ("In SgClassType::get_mangled(): SgClassDeclaration calling class_decl->get_mangled_name() --- mangled_name = %s \n",mangled_name.str());
#endif
                  }
             }
        }

#if DEBUG_CLASS_TYPE_GET_MANGLED
     printf ("Leaving SgClassType::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

SOURCE_CLASS_TYPE_END

SOURCE_NONREAL_TYPE_START

SgNonrealType::SgNonrealType ( const SgNonrealType & X )
   : SgNamedType(X)
   {
   }

SgName
SgNonrealType::get_mangled(void) const
   {
     SgNonrealDecl * nrdecl = isSgNonrealDecl(get_declaration());
     ROSE_ASSERT(nrdecl != NULL);
     return nrdecl->get_mangled_name();
   }

SgName SgNonrealType::get_name() const {
  SgDeclarationStatement * decl_stmt = get_declaration();
  ROSE_ASSERT(decl_stmt != NULL);
  SgNonrealDecl * nonreal_decl = isSgNonrealDecl(decl_stmt);
  ROSE_ASSERT(nonreal_decl != NULL);
  return nonreal_decl->get_name();
}

SOURCE_NONREAL_TYPE_END

SOURCE_AUTO_TYPE_START

SgAutoType::SgAutoType ( const SgAutoType & X )
   : SgType(X)
   {
   }

SgName
SgAutoType::get_mangled(void) const
   {
     std::ostringstream oss;
     oss << "auto_" << std::hex << this;
     return SgName(oss.str());
   }

/*SgName
SgAutoType::get_name() const {
  return SgName("auto");
}*/

SOURCE_AUTO_TYPE_END

SOURCE_JAVA_PARAMETERIZED_TYPE_START
SgJavaParameterizedType::SgJavaParameterizedType ( const SgJavaParameterizedType & X )
   : SgNamedType(X)
   {
   }

#ifdef ROSE_BUILD_JAVA_LANGUAGE_SUPPORT
SgName
SgJavaParameterizedType::get_name() const {
    if (get_declaration()) {
        string name = get_raw_type() -> get_name().getString();
        if (get_type_list() != NULL) {
            name += "<";
            SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
            for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
                if (i != templateParameters.begin()) {
                    name += ", ";
                }
                SgType *type = (*i) -> get_type();
                SgArrayType *array_type = isSgArrayType(type);

             // DQ (3/19/2016): Klocworks reports the use of isSgNamedType(type) as an issue, since it could be NULL (as it sees it).
             // ROSE_ASSERT(array_type || isSgNamedType(type));
             // name += (array_type ? array_type -> get_name() : isSgNamedType(type) -> get_name()).getString();
                SgNamedType *named_type = isSgNamedType(type);
                ROSE_ASSERT(array_type != NULL || named_type != NULL);
                name += (array_type ? array_type -> get_name() : named_type -> get_name()).getString();
            }
            name += ">";
        }
        return SgName(name);
    }
    else
        return SgName((char *)0L);
}
#else
SgName
SgJavaParameterizedType::get_name() const {
    ROSE_ASSERT(! "[FATAL] ROSE was not configured with Java support");
    return "";
}
#endif

#ifdef ROSE_BUILD_JAVA_LANGUAGE_SUPPORT
SgName
SgJavaParameterizedType::get_qualified_name() const {
    string name = get_raw_type() -> get_qualified_name().getString();
    if (get_type_list() != NULL) {
        name += "<";
        SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
        for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
            if (i != templateParameters.begin()) {
                name += ", ";
            }
            SgType *type = (*i) -> get_type();
            SgArrayType *array_type = isSgArrayType(type);
            ROSE_ASSERT(array_type || isSgNamedType(type));
            name += (array_type ? array_type -> get_qualified_name() : isSgNamedType(type) -> get_qualified_name()).getString();
        }
        name += ">";
    }
    return SgName(name);
}
#else
SgName
SgJavaParameterizedType::get_qualified_name() const {
    ROSE_ASSERT(! "[FATAL] ROSE was not configured with Java support");
    return "";
}
#endif

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     if (get_name().is_null() == false) // not anonymous
        {
             mangled_name = get_raw_type() -> get_mangled();
             if (get_type_list() != NULL) {
                 SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
                 for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
                     mangled_name += "_";
                     mangled_name += (*i) -> get_type() -> get_mangled();
                 }
             }
        }

     return mangled_name;
   }
SOURCE_JAVA_PARAMETERIZED_TYPE_END


SOURCE_JAVA_QUALIFIED_TYPE_START
SgJavaQualifiedType::SgJavaQualifiedType ( const SgJavaQualifiedType & X )
   : SgNamedType(X)
   {
   }

SgName
SgJavaQualifiedType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJavaQualifiedType::get_qualified_name() const
   {
       return p_parent_type -> get_qualified_name().getString() + "." + p_type -> get_name().getString();
   }


// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     if (get_name().is_null() == false) // not anonymous
        {
             mangled_name = get_parent_type() -> get_mangled();
             mangled_name += "_";
             mangled_name += get_type() -> get_mangled();
        }

     return mangled_name;
   }
SOURCE_JAVA_QUALIFIED_TYPE_END


SOURCE_JAVA_WILDCARD_TYPE_START
SgJavaWildcardType::SgJavaWildcardType ( const SgJavaWildcardType & X )
   : SgNamedType(X)
   {
   }

bool
SgJavaWildcardType::is_unbound() {
    return p_bound_type == NULL;
}

SgName
SgJavaWildcardType::get_name() const
   {
     string name = "?";

     if (p_bound_type != NULL)
        {
          if (p_has_extends) {
              name += " extends ";
          }
          else if (p_has_super) {
              name += " super ";
          }

          SgType *type = p_bound_type;
          SgArrayType *array_type = isSgArrayType(type);
    ROSE_ASSERT(array_type || isSgNamedType(type));

       // DQ (3/19/2016): Klocworks reports the use of isSgNamedType(type) as an issue, since it could be NULL (as it sees it).
       // ROSE_ASSERT(array_type || isSgNamedType(type));
       // name += (array_type ? array_type -> get_name() : isSgNamedType(type) -> get_name()).getString();
          SgNamedType *named_type = isSgNamedType(type);
          ROSE_ASSERT(array_type != NULL || named_type != NULL);
          name += (array_type ? array_type -> get_name() : named_type -> get_name()).getString();
        }

     return SgName(name);
   }

SgName
SgJavaWildcardType::get_qualified_name() const {
    string name = "?";

    if (p_bound_type != NULL) {
        if (p_has_extends) {
            name += " extends ";
        }
        else if (p_has_super) {
            name += " super ";
        }

        SgType *type = p_bound_type;
        SgArrayType *array_type = isSgArrayType(type);
  ROSE_ASSERT(array_type || isSgNamedType(type));
        name += (array_type ? array_type -> get_qualified_name() : isSgNamedType(type) -> get_qualified_name()).getString();
    }

    return SgName(name);
}

SgName
SgJavaWildcardType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     string mangled_name = "__MANGLED_ID_WILDCARD_TYPEb__";
     mangled_name += get_name().str(); // name of wildcard type is "?"
     if (p_bound_type != NULL) {
         mangled_name += (p_has_extends ? "_extends_" : "_super_");
         mangled_name += p_bound_type -> get_mangled();
     }
     mangled_name += ("__MANGLED_ID_WILDCARD_TYPEe__"); // end tag

     return SgName(mangled_name);
   }

SOURCE_JAVA_WILDCARD_TYPE_END


SOURCE_JAVA_UNION_TYPE_START
SgJavaUnionType::SgJavaUnionType ( const SgJavaUnionType & X )
   : SgType(X)
   {
   }


SgName
SgJavaUnionType::get_name() const {
    string name = "";
    for (size_t i = 0; i < p_type_list.size(); i++) {
      if (i > 0) {
            name += " | ";
        }
        name += isSgClassDeclaration(isSgNamedType(p_type_list[i]) -> getAssociatedDeclaration()) -> get_name();
    }
    return SgName(name); //. c_str()
}

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);
     SgName mangled_name;

     for (size_t i = 0; i < p_type_list.size(); i++) {
         if (i > 0) {
             mangled_name += "_|_";
         }
         mangled_name += p_type_list[i] -> get_mangled();
     }

     return mangled_name;
   }
SOURCE_JAVA_UNION_TYPE_END


SOURCE_JAVA_PARAMETER_TYPE_START
SgJavaParameterType::SgJavaParameterType ( const SgJavaParameterType & X )
   : SgClassType(X)
   {
   }


SgName
SgJavaParameterType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJavaParameterType::get_qualified_name() const
   {
       return this -> get_name();
   }

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     SgClassDeclaration *class_declaration = isSgClassDeclaration(get_declaration() -> get_definingDeclaration());
     ROSE_ASSERT(class_declaration);
     SgName mangled_name = class_declaration -> get_mangled_name();
     SgBaseClassPtrList &bases = class_declaration -> get_definition() -> get_inheritances();
     for (size_t i = 0; i < bases.size(); i++) {
         mangled_name += "_";
         SgClassDeclaration *super_type = isSgBaseClass(bases[i]) -> get_base_class();
         mangled_name += super_type -> get_mangled_name();
     }

     return mangled_name;
   }
SOURCE_JAVA_PARAMETER_TYPE_END


SOURCE_JOVIAL_TABLE_TYPE_START
SgJovialTableType::SgJovialTableType ( const SgJovialTableType & X )
   : SgClassType(X)
   {
   }

SgName
SgJovialTableType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJovialTableType::get_qualified_name() const
   {
       return this -> get_name();
   }

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (2/10/2014): We want to iterate over the list of types and output a name from the concatination of the type names.
     SgClassDeclaration *class_declaration = isSgClassDeclaration(get_declaration() -> get_definingDeclaration());
     ROSE_ASSERT(class_declaration);
     SgName mangled_name = class_declaration -> get_mangled_name();
     SgBaseClassPtrList &bases = class_declaration -> get_definition() -> get_inheritances();
     for (size_t i = 0; i < bases.size(); i++) {
         mangled_name += "_";
         SgClassDeclaration *super_type = isSgBaseClass(bases[i]) -> get_base_class();
         mangled_name += super_type -> get_mangled_name();
     }

     return mangled_name;
   }
SOURCE_JOVIAL_TABLE_TYPE_END


SOURCE_TEMPLATE_TYPE_START

SgName
SgTemplateType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);
     SgName mangled_name = get_name();

  // DQ (9/21/2012): Add the pointer value for the first undefined declaration as a way to make this a unique mangled value.
  // We need to asspciate template template arguments with their associated declarations and not just there name.
  // See test2012_217.C (return types of functions should be different, have different mangled names, for each function).
     mangled_name += Rose::StringUtility::numberToString(this);

     return mangled_name;
   }

SOURCE_TEMPLATE_TYPE_END


SOURCE_ENUM_TYPE_START

SgEnumType::SgEnumType ( const SgEnumType & X )
   : SgNamedType(X)
   {
   }


SgName
SgEnumType::get_name() const
   {
     if(get_declaration())
          return isSgEnumDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }


// RV (2/1/2006): Updated to use the declaration's mangling routine.
SgName
SgEnumType::get_mangled (void) const
    {
     ROSE_ASSERT(this != NULL);

     const SgEnumDeclaration* decl = isSgEnumDeclaration (get_declaration());
     ROSE_ASSERT (decl != NULL);

     if (decl->get_scope() != NULL)
        {
          ROSE_ASSERT(decl->get_scope()->class_name() != "SgNode");
        }

     return decl->get_mangled_name ();
   }

SOURCE_ENUM_TYPE_END


SOURCE_TYPEDEF_TYPE_START

SgTypedefType::SgTypedefType ( const SgTypedefType & X )
// : SgNamedType(X.get_declaration())
   : SgNamedType(X), p_parent_scope(X.p_parent_scope)
   {
  // DQ (10/18/2007): This copy constructor is to support the AST copy mechansim, specifically
  // to permit the SgTypedefSeq to be updated with new copies of SgTypedefType objects.

  // DQ (10/19/2007): Make sure that this is true (though we could not test it before building the base class.
     ROSE_ASSERT( X.get_declaration() != NULL);

  // Typedefs need to setup the fixup the SgTypedefSeq list.
     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(X.get_declaration());
     ROSE_ASSERT( typedefDeclaration != NULL);
     SgType* baseType = typedefDeclaration->get_base_type();
     ROSE_ASSERT(baseType != NULL);

  // Fixup the SgTypedefSeq object.
     baseType->get_typedefs()->append_typedef(this);
   }

SgName
SgTypedefType::get_name() const
   {
     if (get_declaration() != NULL)
        {
          return isSgTypedefDeclaration(get_declaration())->get_name();
        }
       else
        {
          printf ("Warning: Returning an empty name from $CLASSNAME::get_name() \n");
          return SgName((char *)0L);
        }
   }

SgType*
SgTypedefType::get_base_type() const
   {
     ROSE_ASSERT(isSgTypedefDeclaration(get_declaration()) != NULL);
     return (get_declaration() != NULL) ? isSgTypedefDeclaration(get_declaration())->get_base_type() : NULL;
   }

SgName
SgTypedefType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgTypedefDeclaration* decl = isSgTypedefDeclaration (get_declaration());
     ROSE_ASSERT (decl != NULL);

     return decl->get_mangled_name();
   }

SOURCE_TYPEDEF_TYPE_END


SOURCE_MODIFIER_TYPE_START

SgTypeModifier &
SgModifierType::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

const SgTypeModifier &
SgModifierType::get_typeModifier (void) const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

SgName
SgModifierType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;

     const SgTypeModifier &          type_mod = get_typeModifier();
     const SgConstVolatileModifier & cv_mod   = type_mod.get_constVolatileModifier();
     const SgUPC_AccessModifier &    upc_mod  = type_mod.get_upcModifier();

     // PP (02/17/22) Add aliased information to mangled name
     if (type_mod.isAliased())   mangled_name << "A";
     // PP (02/16/24) Add not null information to mangled name
     if (type_mod.isNotNull())   mangled_name << "N";

     if (cv_mod.isConst())       mangled_name << "C";
     if (cv_mod.isVolatile())    mangled_name << "V";
     if (type_mod.isRestrict())  mangled_name << "RST";

  // PP make mangled name depend on blocksize
     if (upc_mod.get_isShared())
        {
          mangled_name << "SHD";

          std::stringstream sstr;
          long              blocksize = upc_mod.get_layout();
          ROSE_ASSERT(blocksize >= -2);

       // \pp just add the blocksize as string to the mangled name.
       //     The TypeTable implementation needs to differentiate types
       //     with different shared blocksize.
          sstr << blocksize;
          mangled_name << sstr.str();
        }

     if (upc_mod.isUPC_Strict())  mangled_name << "STR";
     if (upc_mod.isUPC_Relaxed()) mangled_name << "RLX";

     mangled_name << get_base_type()->get_mangled().str();

     return mangled_name;
   }

void
SgModifierType::post_construction_initialization()
   {
     ASSERT_not_null(p_base_type);

     if (isSgModifierType(p_base_type) == nullptr)
        {
          ROSE_ASSERT(p_base_type->get_modifiers() == nullptr);
        }
   }

SOURCE_MODIFIER_TYPE_END


SOURCE_QUALIFIED_NAME_TYPE_START

SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgQualifiedNameType::set_qualifiedNameList(const SgQualifiedNamePtrList & x)
   {
     p_qualifiedNameList = x;
   }

SgName
SgQualifiedNameType::get_prefix() const
   {
     SgName tmp;

     SgQualifiedNamePtrList::const_iterator i = p_qualifiedNameList.begin();
     while(i != p_qualifiedNameList.end())
        {
          printf ("Found a qualified name \n");
          if (isSgGlobal((*i)->get_scope()) != NULL)
             {
               printf ("Output the global scope qualifier \n");
               tmp << "::";
             }
            else
             {
            // Use the generated name until we are ready to select between generated or stored qualified names
               printf ("Use the generated name until we are ready to select between generated or stored qualified names \n");
             }
          i++;
        }

     return tmp;
   }

SgName
SgQualifiedNameType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName tmp;
     tmp << "qualified_name_" << get_base_type()->get_mangled().str();

     return tmp;
   }

SOURCE_QUALIFIED_NAME_TYPE_END


SOURCE_FUNCTION_TYPE_START

// Specialized constructor
SgFunctionType::SgFunctionType(SgPartialFunctionType *ft)
   {
     assert(ft != NULL);
     p_return_type      = ft->p_return_type;
     p_has_ellipses     = ft->p_has_ellipses;

  // DQ (12/13/2012): We have to set this to NULL since it is checked in the call to post_construction_initialization().
     p_argument_list = nullptr;
     post_construction_initialization();

     SgTypePtrList::iterator p = ft->get_arguments().begin();
     while(p != ft->get_arguments().end())
        {
          append_argument((*p));
          p++;
        }
   }

void
SgFunctionType::post_construction_initialization ()
   {
     p_orig_return_type = nullptr;
     ROSE_ASSERT(p_argument_list == nullptr);

     p_argument_list = new SgFunctionParameterTypeList();
     ASSERT_not_null(p_argument_list);

     p_argument_list->set_parent(this);

     ASSERT_not_null(p_return_type);
     set_orig_return_type(p_return_type);
     ASSERT_not_null(p_orig_return_type);
   }

const SgTypePtrList &
SgFunctionType::get_arguments() const
   { return p_argument_list->get_arguments(); }

SgTypePtrList &
SgFunctionType::get_arguments()
   { return p_argument_list->get_arguments(); }

void
SgFunctionType::append_argument( SgType* what)
   {
    p_argument_list->append_argument(what);
   }

void
SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_argument_list->insert_argument(where,what);
   }

SgName
SgFunctionType::get_mangled(SgType* ret_type, SgFunctionParameterTypeList* typeList)
   {
  // Note that this is a static member function.

  // process argument type
     SgName arg_names;
     if (typeList != NULL)
        {
          const SgTypePtrList & args = typeList->get_arguments ();
          arg_names = mangleTypes (args.begin (), args.end ());
        }

  // process return type
     ROSE_ASSERT (ret_type != NULL);
     SgName ret_name = ret_type->get_mangled();

  // Build complete mangled name
     SgName mangled_name;
     mangled_name << "_Fb_" // begin function signature
                  << ret_name.str () // return type
                  << "_Gb_" // argument list begin
                  << arg_names.str () // argument types
                  << "_Fe_"; // end function signature

     return mangled_name;
   }

SgName
SgFunctionType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);
     return get_mangled(get_return_type(), get_argument_list());
   }

SgName
SgFunctionType::get_mangled_type()
   {
     ROSE_ASSERT(this != NULL);
     return get_mangled();
   }

SgSymbol*
SgFunctionType::get_symbol_from_symbol_table() const
   {
     return SgNode::get_globalFunctionTypeTable()->get_function_type_table()->find(this);
   }

SOURCE_FUNCTION_TYPE_END


SOURCE_MEMBER_FUNCTION_TYPE_START

SgMemberFunctionType::SgMemberFunctionType ( SgPartialFunctionType* ft )
   : SgFunctionType(ft)
   {
     p_class_type      = ft->p_class_type ;
     p_mfunc_specifier = ft->p_mfunc_specifier;
   }

void
SgMemberFunctionType::post_construction_initialization()
   {
  // PP (10/4/2022): p_ref_qualifier needs to be default initialized
      // p_ref_qualifier   = 0;

  // DQ (3/10/2012): If this is non-zero then the SgPartialFunctionType should have something set internally.
     if (p_mfunc_specifier != 0)
        {
          ROSE_ASSERT( (isConstFunc() == true) || (isVolatileFunc() == true) || (isRestrictFunc() == true) || (isLvalueReferenceFunc() == true) || (isRvalueReferenceFunc() == true));
        }
   }

bool
SgMemberFunctionType::isConstFunc() const
   { return (p_mfunc_specifier & e_const); }

void
SgMemberFunctionType::setConstFunc()
   { p_mfunc_specifier |= e_const; }

void
SgMemberFunctionType::unsetConstFunc()
   { p_mfunc_specifier &= ~e_const; }

bool
SgMemberFunctionType::isVolatileFunc() const
   { return (p_mfunc_specifier & e_volatile); }

void
SgMemberFunctionType::setVolatileFunc()
   { p_mfunc_specifier |= e_volatile; }

void
SgMemberFunctionType::unsetVolatileFunc()
   { p_mfunc_specifier &= ~e_volatile; }

bool
SgMemberFunctionType::isRestrictFunc() const
   { return (p_mfunc_specifier & e_restrict); }

void
SgMemberFunctionType::setRestrictFunc()
   { p_mfunc_specifier |= e_restrict; }

void
SgMemberFunctionType::unsetRestrictFunc()
   { p_mfunc_specifier &= ~e_restrict; }

// DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
// L-value reference access/set/unset member functions and member function type
bool
SgMemberFunctionType::isLvalueReferenceFunc() const
   { return (p_mfunc_specifier & e_ref_qualifier_lvalue); }

void
SgMemberFunctionType::setLvalueReferenceFunc()
   { p_mfunc_specifier |= e_ref_qualifier_lvalue; }

void
SgMemberFunctionType::unsetLvalueReferenceFunc()
   { p_mfunc_specifier &= ~e_ref_qualifier_lvalue; }

// DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
// R-value reference access/set/unset member functions and member function type
bool
SgMemberFunctionType::isRvalueReferenceFunc() const
   { return (p_mfunc_specifier & e_ref_qualifier_rvalue); }

void
SgMemberFunctionType::setRvalueReferenceFunc()
   { p_mfunc_specifier |= e_ref_qualifier_rvalue; }

void
SgMemberFunctionType::unsetRvalueReferenceFunc()
   { p_mfunc_specifier &= ~e_ref_qualifier_rvalue; }

SgName
SgMemberFunctionType::get_mangled_name (void) const
   {
     ROSE_ASSERT(this != NULL);
     return get_mangled ();
   }

// DQ (12/6/2012): Adding member function specifier data (since this will be a part of the generated mangled name).
SgName SgMemberFunctionType::get_mangled(SgType* ret_type, SgFunctionParameterTypeList* typeList, SgType* classType, unsigned int mfunc_specifier)
   {
  // DQ (12/3/2011): Added this static function to simplify (refactor) how mangled names are generated).
  // The advantage of refactoring this code to a static function is that the managle name generated to
  // support the global function type table hash key could be generated more directly that what we do
  // now (which is the generate a SgMemberFunctionType, call the get_mangled() function, and then delete
  // the newly built SgMemberFunctionType if the name is alread in the global function type table.

  // Unfortunaely, this function makes too many calls to non-static member functions, and thus would be
  // harder than expected to turn into a simple static function.

  // Member-function specific information (class name, const/volatile qualifiers).
     SgName mangled_cls_tag;

  // Compute class scope
  //! \todo Figure out why member function types are sometimes used
  //! incorrectly in place of plain function types.
     const SgType* cls_type = classType;
     if (cls_type != NULL)
        {
          SgName class_scope = cls_type->get_mangled();
          mangled_cls_tag += class_scope;
        }

     SgName mangled_name;

  // DQ (12/6/2012): New version of this function using the input parameter (mfunc_specifier) so that we can
  // have this be a static member function.  The goal is to use this function to rewite the SageBuilder::buildMemberFunctionType()
  // to both be more clear and fix the handling of SgFunctionParameterTypeList which appears to be a problem for
  // the AST File I/O and the graphs that we generate of the AST in the new EDG 4.x branch.

     if (mfunc_specifier & SgMemberFunctionType::e_const)
        {
       // Mark as const
          mangled_cls_tag << "_cf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_volatile)
        {
       // Mark as volatile
          mangled_cls_tag << "_vf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_restrict)
        {
       // Mark as restrict
          mangled_cls_tag << "_rf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_ref_qualifier_lvalue)
        {
       // Mark as restrict
          mangled_cls_tag << "_lvf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_ref_qualifier_rvalue)
        {
       // Mark as restrict
          mangled_cls_tag << "_rvf";
        }

  // Mangle the function type without qualifiers
     SgName basic_func_type = SgFunctionType::get_mangled(ret_type,typeList);

  // Compute mangled member function pointer type
     if (mangled_cls_tag.get_length () > 0)
          mangled_name << "__MFb_" << mangled_cls_tag.str (); // really is a member function

     mangled_name << "_" << basic_func_type.str (); // Append standard argument signature.

     return mangled_name;
   }

SgName
SgMemberFunctionType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // Member-function specific information (class name, const/volatile qualifiers)
     SgName mangled_cls_tag;

  // Compute class scope
  //! \todo Figure out why member function types are sometimes used
  //! incorrectly in place of plain function types.
     const SgType* cls_type = get_class_type ();
     if (cls_type)
        {
          SgName class_scope = cls_type->get_mangled ();
          mangled_cls_tag += class_scope;
        }

  // DQ (12/3/2011): Because of these member function calls this can't be refactored to be a static function.
  // Append modifiers
     if (isConstFunc() == true)
          mangled_cls_tag << "_cf";
     if (isVolatileFunc() == true)
          mangled_cls_tag << "_vf";
     if (isRestrictFunc() == true)
          mangled_cls_tag << "_rf";

  // Mangle the function type without qualifiers
     SgName basic_func_type = SgFunctionType::get_mangled();

  // Compute mangled member function pointer type
     SgName mangled_name;
     if (mangled_cls_tag.get_length () > 0)
        {
          mangled_name << "__MFb_" << mangled_cls_tag.str(); // really is a member function
        }

     mangled_name << "_" << basic_func_type.str (); // Append standard argument signature.
     return mangled_name;
   }

SgMemberFunctionType *
SgMemberFunctionType::mkAnotherType(SgType *rtype)
   {
     if (rtype == get_return_type())
          return NULL;

     SgPartialFunctionType *part_type = SgPartialFunctionType::createType(rtype);

  /* process argument type */
     SgTypePtrList::iterator p = this->get_arguments().begin();
     while (p != this->get_arguments().end())
        {
          part_type->append_argument((*p));
          p++;
        }
     part_type->set_class_type(this->get_class_type());
     part_type->set_mfunc_specifier(this->get_mfunc_specifier());

     SgMemberFunctionType *ntype = SgMemberFunctionType::createType(part_type);
     if (ntype == this)
          return NULL;
       else
          return ntype;
   }

SgClassDefinition*
SgMemberFunctionType::get_struct_name() const
   {
     if (get_class_type() == NULL)
          return NULL;
     SgClassType *clsType = isSgClassType(get_class_type()->stripTypedefsAndModifiers());
     ROSE_ASSERT(clsType != NULL);
     SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration()->get_definingDeclaration());
     ROSE_ASSERT(clsDecl != NULL);
     return clsDecl->get_definition();
   }


SOURCE_MEMBER_FUNCTION_TYPE_END


SOURCE_PARTIAL_FUNCTION_TYPE_START
//! This is an empty function (no data to initialize)
void
SgPartialFunctionType::post_construction_initialization ()
   {
   }

SOURCE_PARTIAL_FUNCTION_TYPE_END


SOURCE_ARRAY_TYPE_START

// DQ (3/22/2017): I would like to remove this function if possible (it is not sufficiently general).
// Note that this is used within ROSE (which might be worth checking out in more detail later).
SgName
SgArrayType::get_name(void) const {
    string dimensions = "[]";
    SgType *type = p_base_type;

    for (SgArrayType *array_type = isSgArrayType(type); array_type; array_type = isSgArrayType(type))
    {
        dimensions += "[]";
        type = array_type -> get_base_type();
    }

    string name;
    if (isSgTypeBool(type)) {
        name = "boolean";
    }
    else if (isSgTypeSignedChar(type)) {
        name = "byte";
    }
    else if (isSgTypeWchar(type)) {
        name = "char";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar16(type)) {
        name = "char16";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar32(type)) {
        name = "char32";
    }
    else if (isSgTypeInt(type)) {
        name = "int";
    }
    else if (isSgTypeShort(type)) {
        name = "short";
    }
    else if (isSgTypeFloat(type)) {
        name = "float";
    }
    else if (isSgTypeLong(type)) {
        name = "long";
    }
    else if (isSgTypeDouble(type)) {
        name = "double";
    }
    else if (isSgTypeVoid(type)) {
        name = "void";
    }
    else if (isSgTypeString(type)) {
        name = "String";
    }
    else
    {
      SgNamedType* namedType = isSgNamedType(type);
      if (namedType != NULL)
         {
           name = namedType -> get_name().getString();
         }
    }

    name += dimensions;

    return SgName(name);
}

SgName
SgArrayType::get_qualified_name(void) const {
    string dimensions = "[]";
    SgType *type = p_base_type;

    for (SgArrayType *array_type = isSgArrayType(type); array_type; array_type = isSgArrayType(type))
    {
        dimensions += "[]";
        type = array_type -> get_base_type();
    }

    string name;
    if (isSgTypeBool(type)) {
        name = "boolean";
    }
    else if (isSgTypeSignedChar(type)) {
        name = "byte";
    }
    else if (isSgTypeWchar(type)) {
        name = "char";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar16(type)) {
        name = "char16";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar32(type)) {
        name = "char32";
    }
    else if (isSgTypeInt(type)) {
        name = "int";
    }
    else if (isSgTypeShort(type)) {
        name = "short";
    }
    else if (isSgTypeFloat(type)) {
        name = "float";
    }
    else if (isSgTypeLong(type)) {
        name = "long";
    }
    else if (isSgTypeDouble(type)) {
        name = "double";
    }
    else if (isSgTypeVoid(type)) {
        name = "void";
    }
    else if (isSgTypeString(type)) {
        name = "String";
    }
    else
    {
      SgNamedType* namedType = isSgNamedType(type);
      if (namedType != NULL)
         {
           name = namedType -> get_qualified_name().getString();
         }
    }

    name += dimensions;

    return SgName(name);
}

// DQ (6/13/2015): Added forward declaration of namespace function for constant folding.
namespace ConstantFolding
   {
     ROSE_DLL_API SgValueExp* returnConstantFoldedValueExpression(SgNode* n, bool internalTestingAgainstFrontend = false);
   }

SgName
SgArrayType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);
     SgName base_name = base_type->get_mangled();

#define DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING 0

#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
     printf ("In SgArrayType::get_mangled(): mangled base type name = %s \n",base_name.str());
#endif

  // DQ (2/14/2016): Adding support for variable length arrays.
     const bool is_variable_length_array = this->get_is_variable_length_array();

     const SgExpression* index_exp = get_index();
     SgName index_name;
     if (index_exp != NULL)
        {
       // DQ (9/23/2015): This code is important to the passing of test2015_78.C for both C++98 and C++11 modes.
       //    In C++98 mode a cast is not present and we see a SgIntVal expression, where as for C++11 mode we see a SgUnsignedLongVal expression.
       //    The result was that the variable "value" below was either NULL or non-NULL and the ROSE AST was different for for C++98 as for C++11.
       //    This is important for the Intel C++ compiler (version 14) because it defaults to C++11 instead of C++98.
       //    Forcing the false branch below does at least make the C++98 and C++11 modes uniform, and allows the test code to now pass uniformally
       //    for both C++98 and C++11 modes, but does not really fix the problem well.  We want to where ever possible evaluate the expression to
       //    a constant value literal, but this is part of a seperate issue specific to use of expressions in array bounds (test2015_.C).
          const SgValueExp* value = NULL;

#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
          printf ("In SgArrayType::get_mangled() index_exp = %p = %s value = %p \n",index_exp,index_exp->class_name().c_str(),value);
#endif
          if (value != NULL)
             {
               index_name = value->get_constant_folded_value_as_string().c_str();
               printf ("In SgArrayType::get_mangled() (special case of index as get_constant_folded_value_as_string): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());
             }
            else
             {
               const SgVarRefExp* varRefExp = isSgVarRefExp(index_exp);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
               printf ("In SgArrayType::get_mangled() varRefExp = %p \n",varRefExp);
#endif
               if (varRefExp != NULL)
                  {
                    SgSymbol* index_symbol = varRefExp->get_symbol();
                    ROSE_ASSERT(index_symbol != NULL);

                    SgVariableSymbol* variableSymbol = isSgVariableSymbol(index_symbol);
                    SgInitializedName* index_declaration = variableSymbol->get_declaration();
                    ROSE_ASSERT(index_declaration != NULL);

                 // DQ (2/14/2016): Adding support for VLA types (if we evaluate the mangled name we will cause endless recursion).
                    if (is_variable_length_array == true)
                       {
                         index_name = "vla_dimention";
                       }
                      else
                       {
                         index_name = index_declaration->get_mangled_name();
                       }

                    index_name += "_";
                    index_name += index_exp->unparseToString();
                  }
                 else
                  {
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                    printf ("In SgArrayType::get_mangled() index_exp = %p = %s \n",index_exp,index_exp->class_name().c_str());
#endif

                 // DQ (6/13/2015): bugfix to permit constant valued expressions to be evaluated to constants and the constants used in the mangled names.
                    SgExpression* original_constant_index_exp = get_index();
                    ROSE_ASSERT(original_constant_index_exp != NULL);

                 // To narrow this further we could constrain the lhs and rhs to be SgInitVal nodes.

#define TEST_CONSTANT_FOLDING_IN_NAME_MANGLING_OF_TYPES 0

#if TEST_CONSTANT_FOLDING_IN_NAME_MANGLING_OF_TYPES
                 // DQ (6/14/2015): This is test code to evaluate if we want to use the constant folding in the name mangling.
                 // This appears to cause test2011_117.C to fail (C++ template issue) (also similar test code in test2014_143.C).

                    if (true)
#else
                 // DQ (6/14/2015): This predicate will turn off this support for constant folding in the name mangling.
                    if (isSgAddOp(original_constant_index_exp) != NULL && false)
#endif
                       {
                      // This is a narrow case where this should work, but we need more general support.

                      // Build a shadow copy of the expression so that we can do the constant folding without sideffects on the array index expression.
                         SgExpression* shadow_expr = original_constant_index_exp;
                         ROSE_ASSERT(shadow_expr != NULL);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("   --- BEFORE: shadow_expr = %p = %s \n",shadow_expr,shadow_expr->class_name().c_str());
                         printf ("   --- BEFORE: shadow_expr->get_parent() = %p \n",shadow_expr->get_parent());
#endif
                      // DQ (6/13/2015): Added support to return the SgValueExp holding the constant folded value.
                      // Note that constant folding will have to be extended to support more generality before this will work well.
                         SgExpression* shadow_constant_value_exp = ConstantFolding::returnConstantFoldedValueExpression(shadow_expr,false);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         if (shadow_constant_value_exp != NULL)
                            {
                              printf ("   --- AFTER: shadow_constant_value_exp->get_parent() = %p \n",shadow_constant_value_exp->get_parent());
                            }
#endif
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("   --- AFTER: shadow_expr = %p = %s \n",shadow_expr,shadow_expr->class_name().c_str());
                         printf ("   --- AFTER: shadow_constant_value_exp = %p = %s \n",shadow_constant_value_exp,shadow_constant_value_exp != NULL ? shadow_constant_value_exp->class_name().c_str() : "null");
#endif
                         SgValueExp* shadow_constant_value = isSgValueExp(shadow_constant_value_exp);
                         if (shadow_constant_value != NULL)
                            {
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                              printf ("Generate string from shadow_constant_value->get_constant_folded_value_as_string() \n");
#endif
                              index_name = shadow_constant_value->get_constant_folded_value_as_string().c_str();
                            }
                           else
                            {
                           // This may be the case where ConstantFolding::returnConstantFoldedValueExpression() returned a NULL pointer.
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                              printf ("Using backup plan #1: index_exp->unparseToString() \n");
#endif
                              index_name = index_exp->unparseToString();
                            }

                      // Remove node used to hold the constant value expression.
                         delete shadow_constant_value_exp;
                         shadow_constant_value_exp = NULL;
                         shadow_constant_value = NULL;

#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         SgExpression* constant_value_index_exp = get_index();
                         printf ("constant_value_index_exp = %p = %s \n",constant_value_index_exp,constant_value_index_exp->class_name().c_str());
#endif
                       }
                      else
                       {
                      // DQ (6/13/2015): Original code causing expressions to be mixed into the mangled names.
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("Using backup plan #2: index_exp->unparseToString() \n");
#endif
                         index_name = index_exp->unparseToString();
                       }
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                    printf ("In SgArrayType::get_mangled(): after constant folding: index_name = %s \n",index_name.str());
#endif
                  }
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
               printf ("In SgArrayType::get_mangled(): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());
#endif
             }
        }

     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
          base_name = "unnamed_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     if (index_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
          index_name = "unnamed_index";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "_Ab_"
                  << base_name.str ()
                  << "_index_"
                  << index_name.str ()
                  << "_Ae_";
     return mangled_name;
   }

SOURCE_ARRAY_TYPE_END

SOURCE_ADA_ACCESS_TYPE_START

SgName
SgAdaAccessType::get_mangled(void) const {
    const SgType* under_type = get_base_type();

    std::string name("a$a'");

    name.append(1, get_is_anonymous()      ? 'a':'0');
    name.append(1, get_is_general_access() ? 'g':'0');
    name.append(under_type->get_mangled());

    return SgName(name);
}

SOURCE_ADA_ACCESS_TYPE_END

SOURCE_ADA_TASK_TYPE_START

SgName
SgAdaTaskType::get_name() const {
    return SageInterface::get_name(get_declaration());
}

SOURCE_ADA_TASK_TYPE_END


SOURCE_ADA_PROTECTED_TYPE_START

SgName
SgAdaProtectedType::get_name() const {
    return SageInterface::get_name(get_declaration());
}

SOURCE_ADA_PROTECTED_TYPE_END


SOURCE_ADA_DISCRIMINATED_TYPE_START

SgName
SgAdaDiscriminatedType::get_mangled() const {
    string name("a$d'");
    SgAdaDiscriminatedTypeDecl* dcl = isSgAdaDiscriminatedTypeDecl(get_declaration());
    ASSERT_not_null(dcl);

    name.append(dcl->get_mangled_name());
    return name;
}


SgName
SgAdaDiscriminatedType::get_name() const {
    SgAdaDiscriminatedTypeDecl* dcl = isSgAdaDiscriminatedTypeDecl(get_declaration());
    ASSERT_not_null(dcl);

    return SageInterface::get_name(dcl);
}

SOURCE_ADA_DISCRIMINATED_TYPE_END


SOURCE_ADA_SUBTYPE_START

SgName
SgAdaSubtype::get_mangled(void) const {
    const SgType* under_type = get_base_type();
    ASSERT_not_null(under_type);

    std::string name(under_type->get_mangled());

    name += ":>";
    name += get_constraint()->displayString();
    return SgName(name);
}

SOURCE_ADA_SUBTYPE_END

SOURCE_ADA_DERIVEDTYPE_START

SgName
SgAdaDerivedType::get_mangled(void) const {
    std::stringstream buf;

    const SgType* under_type = get_base_type();
    ASSERT_not_null(under_type);

    // encode the this pointer since every new derived type is
    //   different.
    buf << "a$D'"
        << under_type->get_mangled()
        << "'"
        << std::hex << this
        ;

    return buf.str();
}

SOURCE_ADA_DERIVEDTYPE_END


SOURCE_ADA_MODULAR_TYPE_START

SgName
SgAdaModularType::get_mangled(void) const {
    ASSERT_not_null(get_modexpr());
    std::string name = "a$mod'";

    name += get_modexpr()->unparseToString();
    return SgName(name);
}

SOURCE_ADA_MODULAR_TYPE_END

SOURCE_ADA_SUBROUTINE_TYPE_START

SgName
SgAdaSubroutineType::get_mangled(void) const {
    ROSE_ASSERT(get_return_type() && get_parameterList() );
    std::stringstream buf;

    buf << "a$subrout'";
    buf << get_return_type()->get_mangled();
    buf << get_parameterList()->get_mangled_name();

    return SgName(buf.str());
}

SOURCE_ADA_SUBROUTINE_TYPE_END

SOURCE_RANGE_TYPE_START

SgName
SgRangeType::get_mangled(void) const {
    ASSERT_not_null(get_base_type());
    std::stringstream buf;

    buf << "r'";
    buf << get_base_type()->get_mangled();

    return SgName(buf.str());
}

SOURCE_RANGE_TYPE_END


SOURCE_ADA_FORMAL_TYPE_START

SgName
SgAdaFormalType::get_name() const {
    return SageInterface::get_name(get_declaration());
}

SgName
SgAdaFormalType::get_mangled(void) const {
  SgDeclarationStatement* dcl = get_declaration();
  ASSERT_not_null(dcl);

  string name("a$f'");
  name.append(dcl->get_mangled_name());
  return SgName(name);
}


SOURCE_ADA_FORMAL_TYPE_END

SOURCE_JOVIAL_BIT_TYPE_START
SgName
SgJovialBitType::get_mangled(void) const {
    string name("bt");
    if (get_size())
       {
          name.append("_");
          name.append(get_size()->unparseToString());
       }
    return SgName(name);
}
SOURCE_JOVIAL_BIT_TYPE_END


SOURCE_TYPE_ELLIPSE_TYPE_START
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);
     return SgName ("_E_");
   }
SOURCE_TYPE_ELLIPSE_TYPE_END



// ###################################################################
// ###################################################################
//             CREATE TYPE MEMBER FUNCTION DEFINITIONS
// ###################################################################
// ###################################################################

SOURCE_COMMON_CREATE_TYPE_START

// DQ (1/31/2006): Modified to build all types in the memory pools
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;

// DQ (10/4/2010): Added support for optional Fotran type_kind specification.
$CLASSNAME*
$CLASSNAME::createType(SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): New version of code to support multiple kinds of bool as required for the Fortran type_kind support within ROSE.
  // Note that this implementation does not use p_builtin_type, since with the global type table it is not required.
     $CLASSNAME* temp_type = new $CLASSNAME();
     ASSERT_not_null(temp_type);

     if (optional_fortran_type_kind != nullptr)
        {
          temp_type->set_type_kind(optional_fortran_type_kind);
        }

     SgName name = temp_type->get_mangled();

     ASSERT_not_null(get_globalTypeTable());

     SgType* t = get_globalTypeTable()->lookup_type(name);
     if (t == NULL)
        {
          get_globalTypeTable()->insert_type(name,temp_type);
        }
       else
        {
       // If t is the same as p_builtin_type then we can't delete it...(only comes up in merging AST's read from files).
          if (t != temp_type)
             {
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               temp_type->set_type_kind(nullptr);
               delete temp_type;
#endif
               temp_type = nullptr;
             }

       // Reuse this tempType variable so we can use the same code below.
          temp_type = is$CLASSNAME(t);
        }

     ASSERT_not_null(temp_type);
     return temp_type;
   }

SOURCE_COMMON_CREATE_TYPE_END

SOURCE_CREATE_TYPE_FOR_PARTIAL_FUNCTION_TYPE_START
$CLASSNAME*
$CLASSNAME::createType(SgType* rtype,SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     $CLASSNAME* returnType = new $CLASSNAME(rtype);
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_PARTIAL_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_TYPEDEF_TYPE_START
SgTypedefType*
SgTypedefType::createType(SgTypedefDeclaration *decl, SgExpression* optional_fortran_type_kind)
   {
     ASSERT_not_null(decl);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == nullptr);

     if (decl->get_type() == NULL)
        {
          ASSERT_not_null (decl->get_base_type());
          ASSERT_not_null (decl->get_base_type()->p_typedefs);

          SgTypePtrList::iterator i = ((decl->get_base_type()->p_typedefs)->get_typedefs().begin());
          while (i != ((decl->get_base_type()->p_typedefs)->get_typedefs().end()))
             {
               ROSE_ASSERT( (*i) != NULL);
               SgTypedefType *tptr = isSgTypedefType(*i);
               ROSE_ASSERT(tptr != NULL);

               if ( (decl->get_name() == tptr->get_name()) && (decl->get_parent_scope() == tptr->get_parent_scope()) )
                  {
                    return tptr;
                  }
               i++;
             }

       // We have to build the type before we can generate a mangle name for it.
          SgTypedefType* tempType = new SgTypedefType(decl, decl->get_parent_scope());
          SgName name = tempType->get_mangled();
          ASSERT_require(name.is_null() == false);

          SgScopeStatement* currentScope = getCurrentScope();
          if (currentScope == nullptr)
            currentScope = decl->get_scope();

          ASSERT_not_null(currentScope);

       // ROSE_ASSERT(currentScope != NULL);
          if (currentScope != NULL)
             {
            // DQ (7/30/2010): If valid pointer then we are in the process of building the C/C++/Fortran AST.
               SgType* t = currentScope->get_type_table()->lookup_type(name);

               if (t == NULL)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
                    currentScope->get_type_table()->insert_type(name,tempType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
                    ASSERT_require(t != tempType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                 // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                 // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                 // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                    delete tempType;
#endif
                    tempType = NULL;

                 // Reuse this tempType variable so we can use the same code below.
                    tempType = is$CLASSNAME(t);
                  }
             }

          ASSERT_not_null(tempType);
          decl->set_type(tempType);

          ASSERT_not_null (decl->get_type());
          ASSERT_not_null (decl->get_base_type());
          ASSERT_not_null (decl->get_base_type()->p_typedefs);

          (decl->get_base_type()->p_typedefs)->get_typedefs().push_back(decl->get_type());
        }

     ASSERT_not_null (decl);
     ASSERT_not_null (decl->get_type());  // I think we can assert this!
     ASSERT_require ((decl->get_base_type()->p_typedefs)->get_typedefs().size() > 0);

     return decl->get_type();
   }

SOURCE_CREATE_TYPE_FOR_TYPEDEF_TYPE_END


SOURCE_CREATE_TYPE_FOR_FUNCTION_TYPE_START

SgFunctionType*
SgFunctionType::createType(SgPartialFunctionType* ft, SgExpression* optional_fortran_type_kind)
   {
  // The problem with this function is that I have not added the name mangling into SAGE 3 yet!
     ROSE_ASSERT(ft != NULL);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

  // DQ (3/29/2006):
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is built (and parent pointers
  // are set).  If functions are created then the function type table must also be updated.
     SgFunctionType* theType = new SgFunctionType(ft);

  // DQ (6/21/2006): Since we mangle the return type into the mangled function as part of building
  // the symbol table we don't have to worry about sharing function types that would have different
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());

     ROSE_ASSERT(theType != NULL);
     return theType;
   }

SOURCE_CREATE_TYPE_FOR_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_MEMBER_FUNCTION_TYPE_START
SgMemberFunctionType*
SgMemberFunctionType::createType(SgPartialFunctionType* ft, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(ft != NULL);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

  // DQ (3/29/2006):
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is build (and parent pointers
  // are set).  If functions are created then the function type table must also be updated.
     SgMemberFunctionType* theType = new SgMemberFunctionType(ft);

  // DQ (6/22/2006): Since we mangle the return type into the mangled function as part of building
  // the symbol table we don't have to worry about sharing function types that would have different
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());

     ROSE_ASSERT(theType != NULL);
     return theType;
   }

SOURCE_CREATE_TYPE_FOR_MEMBER_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_POINTER_MEMBER_TYPE_START
$CLASSNAME*
$CLASSNAME::createType ( SgType* base_type, SgType *class_type, SgExpression* optional_fortran_type_kind )
   {
  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     $CLASSNAME* returnType = new $CLASSNAME(base_type,class_type);
     assert(returnType != NULL);
     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_POINTER_MEMBER_TYPE_END

SOURCE_CREATE_TYPE_FOR_TYPE_INT_TYPE_START
#define ROSE_INTEGER_TYPE_MAX_BIT_LENGTH 32
const int SgTypeInt::maxBitLength = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;

// DQ (1/31/2006): Convert to a single builtin pointer rather than an array of them.
// I don't think we really need an array of these internally.
SgTypeInt* SgTypeInt::p_builtin_type = NULL;

// DQ (10/4/2010): Added support for fortran type kind expressions.
SgTypeInt*
  SgTypeInt::createType(int /*bitLength*/, SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/5/2010): New version of code to support multiple kinds of SgTypeInt as required for the Fortran type_kind support within ROSE.
  // Note that this implementation does not use p_builtin_type, since with the global type table it is not required.

     $CLASSNAME* temp_type = new $CLASSNAME();
     if (optional_fortran_type_kind != NULL)
        {
          temp_type->set_type_kind(optional_fortran_type_kind);
        }

     SgName name = temp_type->get_mangled();
     SgType* t = get_globalTypeTable()->lookup_type(name);
     if (t == nullptr)
        {
          get_globalTypeTable()->insert_type(name,temp_type);
        }
       else
        {
       // If t is the same as p_builtin_type then we can't delete it...(only comes up in merging AST's read from files).
          if (t != temp_type)
             {
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               temp_type->set_type_kind(nullptr);
               delete temp_type;
#endif
               temp_type = NULL;
             }

       // Reuse this tempType variable so we can use the same code below.
          temp_type = is$CLASSNAME(t);
          ASSERT_not_null(temp_type);
        }

     return temp_type;
   }

SOURCE_CREATE_TYPE_FOR_TYPE_INT_TYPE_END


SOURCE_CREATE_TYPE_FOR_ENUM_TYPE_START
SgEnumType*
SgEnumType::createType(SgEnumDeclaration* cd, SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgEnumType* returnType = nullptr;
     ASSERT_not_null(cd);

     returnType = cd->get_type();
     if (returnType == NULL)
        {
          returnType = new SgEnumType(cd);
          ROSE_ASSERT(returnType != NULL);

       // We have to build the type before we can generate a mangle name for it.
          SgName name = returnType->get_mangled();
          if (name.is_null() == true)
             {
               name = SageInterface::generateUniqueName(returnType,/*ignoreDifferenceBetweenDefiningAndNondefiningDeclarations=*/ true);
             }
          ROSE_ASSERT(name.is_null() == false);

          SgScopeStatement* currentScope = getCurrentScope();
          if (currentScope != nullptr)
             {
            // DQ (7/30/2010): If valid pointer then we are in the process of building the C/C++/Fortran AST.
               SgType* t = currentScope->get_type_table()->lookup_type(name);
               if (t == nullptr)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
                    currentScope->get_type_table()->insert_type(name,returnType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
                    ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                 // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                 // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                 // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                    delete returnType;
#endif
                    returnType = NULL;

                 // Reuse this returnType variable so we can use the same code below.
                    ROSE_ASSERT(t != NULL);
                    returnType = isSgEnumType(t);

                    if (returnType == NULL)
                       {
                         printf ("ERROR: returnType == NULL --- t = %p = %s \n",t,t->class_name().c_str());
                         cd->get_file_info()->display("ERROR: returnType == NULL");
                       }
                    ROSE_ASSERT(returnType != NULL);
                  }
             }
        }

     ASSERT_not_null(returnType);
     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_ENUM_TYPE_END


SOURCE_CREATE_TYPE_FOR_CLASS_TYPE_START

SgClassType*
SgClassType::createType(SgDeclarationStatement* cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

#define DEBUG_CREATE_TYPE_FOR_CLASS_TYPE 0

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("In SgClassType::createType() \n");
#endif

  // DQ (12/4/2011): Adding template declaration support to AST.  An SgClassType is modified to hold a SgTemplateClassDeclaration or a SgClassDeclaration.
     SgClassDeclaration*         classDeclaration         = isSgClassDeclaration(cd);
     SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(cd);
     ROSE_ASSERT(classDeclaration != NULL || templateClassDeclaration != NULL);
     ROSE_ASSERT(classDeclaration != NULL);

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
  // These debugging statements don't deal with the modifications to handle SgTemplateClassDeclaration.
     printf ("In SgClassType::createType(): cd = %p = %s cd->get_definition() = %p = %s \n",classDeclaration,classDeclaration->class_name().c_str(),
          classDeclaration->get_definition(),(classDeclaration->get_definition() != NULL) ? classDeclaration->get_definition()->class_name().c_str() : "NULL");
     printf ("In SgClassType::createType(): cd->get_type() = %p \n",classDeclaration->get_type());
     printf ("In SgClassType::createType(): cd = %p cd->get_definingDeclaration()         = %p \n",classDeclaration,classDeclaration->get_definingDeclaration());
     printf ("In SgClassType::createType(): cd = %p cd->get_firstNondefiningDeclaration() = %p \n",classDeclaration,classDeclaration->get_firstNondefiningDeclaration());
#endif

     SgType* type_from_declaration = NULL;
     if (templateClassDeclaration == NULL)
        {
          ROSE_ASSERT(classDeclaration != NULL);
          type_from_declaration = classDeclaration->get_type();
        }
       else
        {
          ROSE_ASSERT(templateClassDeclaration != NULL);
          type_from_declaration = templateClassDeclaration->get_type();
        }

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("Inside of SgClassType::createType(): cd = %p = %s type_from_declaration = %p \n",cd,cd->class_name().c_str(),type_from_declaration);
#endif

     if (type_from_declaration == NULL)
        {
       // DQ (7/22/2010): Use the global type table to get the type.
          $CLASSNAME* newType = new $CLASSNAME(cd);
          ROSE_ASSERT(newType != NULL);

       // DQ (3/14/2012): Note that the new template support allows that classDeclaration is non-null (since template classes are derived from non-template classes).
          ROSE_ASSERT(classDeclaration != NULL);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): cd = %p = %s = %s newType = %p = %s \n",cd,cd->class_name().c_str(),classDeclaration->get_name().str(),newType,newType->class_name().c_str());
#endif
          SgScopeStatement* currentScope = getCurrentScope();
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): currentScope = %p = %s \n",currentScope,currentScope->class_name().c_str());
#endif
       // DQ (3/14/2012): Make sure that this is a valid pointer else it might explain why qualification is not being use to generate the mangled names.
          if (cd->get_scope() == NULL && currentScope != NULL)
             {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Inside of SgClassType::createType(): Setting scope for cd = %p = %s to currentScope = %p = %s \n",cd,cd->class_name().c_str(),currentScope,currentScope->class_name().c_str());
#endif
               cd->set_scope(currentScope);
             }
          ROSE_ASSERT(cd->get_scope() != NULL);

       // We have to build the type before we can generate a mangled name for it.
          SgName name = newType->get_mangled();

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): type name (newType->get_mangled()) = %s \n",name.str());
#endif
          if (name.is_null() == true)
             {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Need to handle special case of SgClassDeclaration of un-named class cd = %p = %s \n",cd,cd->class_name().c_str());
#endif
               name = SageInterface::generateUniqueName(newType,/* ignoreDifferenceBetweenDefiningAndNondefiningDeclarations = */ true);
             }
          ROSE_ASSERT(name.is_null() == false);

          if (currentScope != NULL)
             {
               SgType* t = currentScope->get_type_table()->lookup_type(name);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Inside of SgClassType::createType(): after calling lookup_type(): t = %p = %s \n",t,(t != NULL) ? t->class_name().c_str() : "null");
#endif
               if (t == NULL)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("Mangled type name for SgClassType = %s (not available in type table) \n",name.str());
#endif
                    currentScope->get_type_table()->insert_type(name,newType);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("This SgClassType::createType() function also sets the type in the SgClassDeclaration = %p \n",cd);
#endif

                    if (classDeclaration != NULL)
                         classDeclaration->set_type(newType);
                      else
                         templateClassDeclaration->set_type(newType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
                    SgClassType* classType = isSgClassType(t);
                    ROSE_ASSERT(classType != NULL);
                    ROSE_ASSERT(classType->get_declaration() != NULL);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("Mangled type classType = %p (classType->get_declaration() = %p = %s) name for SgClassType name = %s (already exists in type table) \n",t,classType->get_declaration(),classType->get_declaration()->class_name().c_str(),name.str());
#endif
                    if (t != newType)
                       {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                         printf ("Deleting the just built exploritory type = %p (case of t != newType) t = %p = %s \n",newType,t,t->class_name().c_str());
#endif
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                      // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                      // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                      // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                         delete newType;
#endif
                         newType = NULL;
                       }
                      else
                       {
                         printf ("WARNING: In SgClassType::createType(): Found a case of t == newType \n");
                       }
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("This SgClassType::createType() function also sets the type in the SgClassDeclaration = %p \n",cd);
#endif
                    $CLASSNAME* typeFromTypeTable = is$CLASSNAME(t);
                    ASSERT_not_null(typeFromTypeTable);

                    if (classDeclaration != NULL)
                         classDeclaration->set_type(typeFromTypeTable);
                      else
                         templateClassDeclaration->set_type(typeFromTypeTable);
                  }
             }
            else
             {
            // Set the type using the generated type that might be redundant with a previously
            // generated type (something to sort out when we either merge local type tables or
            // when we connect the AST fragment being built (bottom up) into the large AST).
               if (templateClassDeclaration == NULL)
                  {
                    ROSE_ASSERT(classDeclaration != NULL);
                    classDeclaration->set_type(newType);
                  }
                 else
                  {
                    ROSE_ASSERT(templateClassDeclaration != NULL);
                    templateClassDeclaration->set_type(newType);
                  }

             }
        }

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("SgClassType::createType(): classDeclaration         = %p \n",classDeclaration);
     printf ("SgClassType::createType(): templateClassDeclaration = %p \n",templateClassDeclaration);
#endif

     SgClassType* returnType = NULL;
     if (classDeclaration != NULL)
        {
          ROSE_ASSERT(classDeclaration->get_type() != NULL);
          returnType = isSgClassType(classDeclaration->get_type());
          if (returnType == NULL)
             {
               printf ("Error: returnType == NULL: classDeclaration->get_type() = %p = %s \n",classDeclaration->get_type(),classDeclaration->get_type()->class_name().c_str());
             }
          ROSE_ASSERT(returnType != NULL);
        }
       else
        {
          returnType = isSgClassType(templateClassDeclaration->get_type());
          ROSE_ASSERT(returnType != NULL);
        }

     ROSE_ASSERT(returnType != NULL);

     if (returnType->get_declaration() != cd)
        {
          ROSE_ASSERT(returnType->get_declaration()->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT(cd->get_firstNondefiningDeclaration() != NULL);
        }

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("Leaving SgClassType::createType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_CLASS_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETERIZED_TYPE_START

SgJavaParameterizedType*
SgJavaParameterizedType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETERIZED_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_QUALIFIED_TYPE_START

SgJavaQualifiedType*
SgJavaQualifiedType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_QUALIFIED_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_WILDCARD_TYPE_START

SgJavaWildcardType*
SgJavaWildcardType::createType(SgClassDeclaration *cd, SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     return new SgJavaWildcardType(cd);
   }

SOURCE_CREATE_TYPE_FOR_JAVA_WILDCARD_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_UNION_TYPE_START

SgJavaUnionType*
SgJavaUnionType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_UNION_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETER_TYPE_START

SgJavaParameterType*
SgJavaParameterType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     if (! cd -> get_type()) {
         $CLASSNAME *newType = new $CLASSNAME(cd);
         cd -> set_type(newType);
     }
     return ($CLASSNAME *) cd -> get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETER_TYPE_END


SOURCE_CREATE_TYPE_FOR_JOVIAL_TABLE_TYPE_START

// CR - why is optional_fortran_type_kind a parameter?
SgJovialTableType*
SgJovialTableType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     if (! cd -> get_type()) {
         $CLASSNAME *newType = new $CLASSNAME(cd);
         cd -> set_type(newType);
     }
     return ($CLASSNAME *) cd -> get_type();
   }

SOURCE_CREATE_TYPE_FOR_JOVIAL_TABLE_TYPE_END


SOURCE_CREATE_TYPE_FOR_TEMPLATE_TYPE_START

SgTemplateType*
SgTemplateType::createType(SgTemplateDeclaration* cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     printf ("SgTemplateType::createType(SgTemplateDeclaration*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_CREATE_TYPE_FOR_TEMPLATE_TYPE_END

SOURCE_CREATE_TYPE_FOR_NONREAL_TYPE_START

SgNonrealType*
SgNonrealType::createType(SgNonrealDecl* decl, SgExpression* /*optional_fortran_type_kind*/)
   {
     ASSERT_not_null(decl);

     printf ("SgNonrealType::createType(SgTemplateDeclaration*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

     return nullptr;
   }

SOURCE_CREATE_TYPE_FOR_NONREAL_TYPE_END

SOURCE_CREATE_TYPE_FOR_AUTO_TYPE_START

SgAutoType*
SgAutoType::createType(SgNode* /*n*/, SgExpression* /*optional_fortran_type_kind*/)
   {
     printf ("SgAutoType::createType(SgNode*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

     return nullptr;
   }

SOURCE_CREATE_TYPE_FOR_AUTO_TYPE_END

SOURCE_CREATE_TYPE_FOR_POINTER_TYPE_START
SgPointerType*
SgPointerType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ASSERT_not_null(base_type);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == nullptr);

     if (base_type->p_ptr_to != nullptr)
        {
          return base_type->p_ptr_to;
        }
       else
        {
          SgPointerType* newType = new SgPointerType(base_type);
          ASSERT_not_null(newType);

          SgName name = newType->get_mangled();

       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == nullptr)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
                    get_globalTypeTable()->insert_type(name,newType);
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgPointerType(t);
             }

          base_type->p_ptr_to = newType;
          ASSERT_not_null(base_type->p_ptr_to);

          return base_type->p_ptr_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_POINTER_TYPE_END


SOURCE_CREATE_TYPE_FOR_REFERENCE_TYPE_START

SgReferenceType*
SgReferenceType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     if (base_type->p_ref_to)
        {
          return base_type->p_ref_to;
        }
       else
        {
          SgReferenceType* newType = new SgReferenceType(base_type);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
                    get_globalTypeTable()->insert_type(name,newType);
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgReferenceType(t);
             }

          base_type->p_ref_to = newType;
          assert(base_type->p_ref_to != NULL);

          return base_type->p_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_REFERENCE_TYPE_END


SOURCE_CREATE_TYPE_FOR_RVALUE_REFERENCE_TYPE_START
SgRvalueReferenceType*
SgRvalueReferenceType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (7/29/2014): I think that rvalue reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     if (base_type->p_rvalue_ref_to)
        {
          return base_type->p_rvalue_ref_to;
        }
       else
        {
          SgRvalueReferenceType* newType = new SgRvalueReferenceType(base_type);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
                    get_globalTypeTable()->insert_type(name,newType);
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgRvalueReferenceType(t);
             }

          base_type->p_rvalue_ref_to = newType;
          assert(base_type->p_rvalue_ref_to != NULL);

          return base_type->p_rvalue_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_RVALUE_REFERENCE_TYPE_END


SOURCE_CREATE_TYPE_FOR_DECL_TYPE_START

SgDeclType*
SgDeclType::createType(SgExpression* base_expression, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgDeclType* newType = new SgDeclType(base_expression);
/*
     assert(newType != NULL);

     SgName name = newType->get_mangled();
     SgType* t = get_globalTypeTable()->lookup_type(name);
     ROSE_ASSERT(!(t != NULL) || isSgDeclType(t)); // (t != NULL) => isDeclType(t)
     if (t != NULL) {
       delete newType;
       newType = isSgDeclType(t);
     } else {
       get_globalTypeTable()->insert_type(name,newType);
     }
*/
     return newType;
   }

SOURCE_CREATE_TYPE_FOR_DECL_TYPE_END


SOURCE_CREATE_TYPE_FOR_TYPEOF_TYPE_START
SgTypeOfType*
SgTypeOfType::createType(SgExpression* base_expression, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/2/2014): The decltype takes an expression (and stores it) but references the type of that expression.
     SgType* base_type = base_expression->get_type();
     ROSE_ASSERT(base_type != NULL);

  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#define DEBUG_TYPEOF_CREATETYPE_EXP 0

     if (base_type->p_typeof_ref_to != NULL)
        {
#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("In SgTypeOfType::createType(SgExpression*): test 1: base_type->p_typeof_ref_to = %p = %s \n",base_type->p_typeof_ref_to,base_type->p_typeof_ref_to->class_name().c_str());
#endif
          return base_type->p_typeof_ref_to;
        }
       else
        {
          SgTypeOfType* newType = new SgTypeOfType(base_expression,NULL);
          ROSE_ASSERT(newType != NULL);

          SgName name = newType->get_mangled();

#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("Building a typeoftype (expression argument) reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("Building a typeoftype (expression argument): t = get_globalTypeTable()->lookup_type(name): t = %p \n",t);
#endif
          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if DEBUG_TYPEOF_CREATETYPE_EXP
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if DEBUG_TYPEOF_CREATETYPE_EXP
                    printf ("Skip putting the SgTypeOfType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if DEBUG_TYPEOF_CREATETYPE_EXP
               printf ("Mangled type name for SgTypeOfType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgTypeOfType(t);
             }

       // DQ (4/7/2015): We have to allow that all expressions could be different, so we can't reuse the same typeof type (return the neType).
          return newType;
        }
   }

SgTypeOfType*
SgTypeOfType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/2/2014): The decltype takes an expression (and stores it) but references the type of that expression.
     ROSE_ASSERT(base_type != NULL);

  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#define DEBUG_TYPEOF_CREATETYPE_TYPE 0

#if DEBUG_TYPEOF_CREATETYPE_TYPE
     printf ("Building a typeoftype (type argument) base_type->p_typeof_ref_to = %p \n",base_type->p_typeof_ref_to);
#endif

     if (base_type->p_typeof_ref_to)
        {
          return base_type->p_typeof_ref_to;
        }
       else
        {
          SgTypeOfType* newType = new SgTypeOfType(NULL,base_type);
          ROSE_ASSERT(newType != NULL);

          SgName name = newType->get_mangled();

#if DEBUG_TYPEOF_CREATETYPE_TYPE
          printf ("Building a typeoftype (type argument) reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

#if DEBUG_TYPEOF_CREATETYPE_TYPE
          printf ("Building a typeoftype (type argument) get_globalTypeTable()->lookup_type(name = %s) = %p = %s \n",name.str(),t,t != NULL ? t->class_name().c_str() : "null");
#endif
          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if DEBUG_TYPEOF_CREATETYPE_TYPE
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if DEBUG_TYPEOF_CREATETYPE_TYPE
                    printf ("Skip putting the SgTypeOfType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if DEBUG_TYPEOF_CREATETYPE_TYPE
               printf ("Mangled type name for SgTypeOfType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgTypeOfType(t);
             }

          base_type->p_typeof_ref_to = newType;
          assert(base_type->p_typeof_ref_to != NULL);

          return base_type->p_typeof_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_TYPEOF_TYPE_END


SOURCE_CREATE_TYPE_FOR_ARRAY_TYPE_START

SgArrayType*
SgArrayType::createType ( SgType* base_type, SgExpression* idx, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/11/2010): It is OK for idx to be NULL, since it implies a declaration such as: "int array[]" which can be OK.
  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgArrayType* returnType = new SgArrayType(base_type, idx);
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
          SgType* root_type = base_type->stripType();
          ROSE_ASSERT(root_type != NULL);
          if (handledUsingLocalTable(root_type) == false)
             {
               get_globalTypeTable()->insert_type(name,returnType);
             }
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
          ROSE_ASSERT(t != returnType);

       // DQ (9/25/2011): the array index can be an expression tree (not just one node) and it can have valid
       // original expression trees from constant folding.  So we don't want to delete the index unless we are
       // going to do the job completely. so we want to:
       //    1) Avoid having it be deleted by the SgArrayType destructor.
       //    2) Delete it using the SageInterface::deleteAST() function.
          if (idx != NULL)
             {
               ROSE_ASSERT(idx->get_parent() == NULL);

            // Let the parent point to the SgArrayType that we will return.
               idx->set_parent(t);

               returnType->set_index(NULL);
               SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees(idx);
               idx = NULL;
             }
          ROSE_ASSERT(returnType->get_index() == NULL);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgArrayType(t);
        }

  // DQ (2/20/2007): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (idx != NULL)
        {
       // DQ (9/25/2011): If we have deleted the array index then it should be listed as V_SgNode (which would be an error we would want to catch).
          ROSE_ASSERT(idx->variantT() != V_SgNode);

          ROSE_ASSERT(idx->get_parent() == NULL);
          idx->set_parent(returnType);
        }

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_ARRAY_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_ACCESS_TYPE_START

SgAdaAccessType*
SgAdaAccessType::createType (SgType* base_type, bool generalAccess, bool anonymous, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaAccessType  proto(base_type, generalAccess, anonymous);
  SgName           name = proto.get_mangled();
  SgType*          ty = get_globalTypeTable()->lookup_type(name);

  if (SgAdaAccessType* unified = isSgAdaAccessType(ty))
    return unified;

  ROSE_ASSERT(ty == nullptr && "type name mangling issue");
  SgAdaAccessType* res = new SgAdaAccessType(base_type, generalAccess, anonymous);

  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_ACCESS_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_FORMAL_TYPE_START
#if 0
SgAdaFormalType*
SgAdaFormalType::createType(SgType* type, SgExpression* /*optional_fortran_type_kind*/)
{
  ROSE_ASSERT(type != NULL);
  SgAdaFormalType* res  = new SgAdaFormalType(NULL, type);
  SgName           name = res->get_mangled();

  get_globalTypeTable()->insert_type(name, res);
  return res;
}
#endif /* 0 */

SgAdaFormalType*
SgAdaFormalType::createType(SgAdaFormalTypeDecl* decl, SgExpression* /*optional_fortran_type_kind*/)
{
  ASSERT_not_null(decl);

  SgAdaFormalType* res = decl->get_type();

  return res ? res : new SgAdaFormalType(decl);
}
SOURCE_CREATE_TYPE_FOR_ADA_FORMAL_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_TASK_TYPE_START

SgAdaTaskType*
SgAdaTaskType::createType (SgDeclarationStatement* decl, SgExpression* /*optional_fortran_type_kind*/)
{
#if 0
  SgAdaTaskType    proto(decl); // \pp not sure if stack allocation works
  SgName           name = proto.get_mangled();
  SgType*          ty   = get_globalTypeTable()->lookup_type(name);

  if (SgAdaTaskType* unified = isSgAdaTaskType(ty))
    return unified;

  ROSE_ASSERT(ty == NULL);
  SgAdaTaskType* res = new SgAdaTaskType(decl);

  get_globalTypeTable()->insert_type(name, res);
  return res;
#endif

  SgAdaTaskType* res = nullptr;

  if (SgAdaTaskSpecDecl* tskspec = isSgAdaTaskSpecDecl(decl))
    res = tskspec->get_type();
  else if (SgAdaTaskTypeDecl* tsktype = isSgAdaTaskTypeDecl(decl))
    res = tsktype->get_type();
  else
    ROSE_ASSERT(!"Ada task types can be created from SgAdaTaskSpecDecl or SgAdaTaskSpecDecl only!");

  return res ? res : new SgAdaTaskType(decl);
}

SOURCE_CREATE_TYPE_FOR_ADA_TASK_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_PROTECTED_TYPE_START

SgAdaProtectedType*
SgAdaProtectedType::createType (SgDeclarationStatement* decl, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaProtectedType* res = nullptr;

  if (SgAdaProtectedSpecDecl* tskspec = isSgAdaProtectedSpecDecl(decl))
    res = tskspec->get_type();
  else if (SgAdaProtectedTypeDecl* tsktype = isSgAdaProtectedTypeDecl(decl))
    res = tsktype->get_type();
  else
    ROSE_ASSERT(!"Ada task types can be created from SgAdaProtectedSpecDecl or SgAdaProtectedSpecDecl only!");

  return res ? res : new SgAdaProtectedType(decl);
}

SOURCE_CREATE_TYPE_FOR_ADA_PROTECTED_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_DISCRIMINATED_TYPE_START

SgAdaDiscriminatedType*
SgAdaDiscriminatedType::createType (SgAdaDiscriminatedTypeDecl* decl, SgExpression* /*optional_fortran_type_kind*/)
{
#if 0
  SgAdaDiscriminatedType proto(decl); // \pp not sure if stack allocation works
  SgName                 name = proto.get_mangled();
  SgType*                ty   = get_globalTypeTable()->lookup_type(name);

  if (SgAdaDiscriminatedType* unified = isSgAdaDiscriminatedType(ty))
    return unified;

  ROSE_ASSERT(ty == NULL);
  SgAdaDiscriminatedType* res = new SgAdaDiscriminatedType(decl);

  get_globalTypeTable()->insert_type(name, res);
#endif

  ASSERT_not_null(decl);

  SgAdaDiscriminatedType* res = decl->get_type();

  return res ? res : new SgAdaDiscriminatedType(decl);
}

SOURCE_CREATE_TYPE_FOR_ADA_DISCRIMINATED_TYPE_END


SOURCE_CREATE_TYPE_FOR_ADA_SUBTYPE_START

SgAdaSubtype*
SgAdaSubtype::createType (SgType* base_type, SgAdaTypeConstraint* constraint, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaSubtype  proto(base_type, constraint); // \pp not sure if stack allocation works
  SgName        name = proto.get_mangled();
  SgType*       ty = get_globalTypeTable()->lookup_type(name);

  if (SgAdaSubtype* unified = isSgAdaSubtype(ty)) {
    return unified;
  }

  ASSERT_not_null(ty);
  SgAdaSubtype* res = new SgAdaSubtype(base_type, constraint);

  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_SUBTYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_DERIVEDTYPE_START

SgAdaDerivedType*
SgAdaDerivedType::createType (SgType* base_type, SgExpression* /*optional_fortran_type_kind*/)
{
  // an ada derived type is always distinct from its base type,
  // ===> do not unify them.
  ASSERT_not_null(base_type);
  SgAdaDerivedType* res = new SgAdaDerivedType(base_type);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_DERIVEDTYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_MODULAR_TYPE_START

SgAdaModularType*
SgAdaModularType::createType(SgExpression* moduloexpr, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaModularType proto{moduloexpr}; // \pp not sure if stack allocation works
  SgName           name = proto.get_mangled();
  SgType*          ty = get_globalTypeTable()->lookup_type(name);

  if (SgAdaModularType* unified = isSgAdaModularType(ty))
  {
    // \todo \pp moduloexpr can be deleted
    return unified;
  }

  ROSE_ASSERT(ty == NULL);
  SgAdaModularType* res = new SgAdaModularType(moduloexpr);

  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_MODULAR_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_SUBROUTINE_TYPE_START

SgAdaSubroutineType*
SgAdaSubroutineType::createType( SgFunctionParameterList* parmList,
                                 SgFunctionParameterScope* parmScope,
                                 SgType* resultType,
                                 SgExpression* /*optional_fortran_type_kind*/)
{
  ROSE_ASSERT(parmList && parmScope && resultType);

  // \todo PP can we create shared types for subroutines?
  return new SgAdaSubroutineType(parmList, parmScope, resultType);
}

SOURCE_CREATE_TYPE_FOR_ADA_SUBROUTINE_TYPE_END

SOURCE_CREATE_TYPE_FOR_RANGE_TYPE_START

SgRangeType*
SgRangeType::createType( SgType* baseType,
                         SgExpression* /*optional_fortran_type_kind*/)
{
  ASSERT_not_null(baseType);

  SgRangeType proto(baseType);
  SgName      name = proto.get_mangled();
  SgType*     ty   = get_globalTypeTable()->lookup_type(name);

  if (SgRangeType* unified = isSgRangeType(ty)) {
     return unified;
  }

  ROSE_ASSERT(ty == NULL);
  SgRangeType* res = new SgRangeType(baseType);

  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_RANGE_TYPE_END


SOURCE_CREATE_TYPE_FOR_JOVIAL_BIT_TYPE_START
SgJovialBitType*
SgJovialBitType::createType (SgExpression* size, SgExpression* /*optional_fortran_type_kind*/)
{
  SgJovialBitType  proto(size);
  SgName           name = proto.get_mangled();
  SgType*          ty   = get_globalTypeTable()->lookup_type(name);

  if (SgJovialBitType* unified = isSgJovialBitType(ty)) {
     return unified;
  }

  ROSE_ASSERT(ty == NULL);
  SgJovialBitType* res = new SgJovialBitType(size);

  get_globalTypeTable()->insert_type(name, res);
  return res;
}
SOURCE_CREATE_TYPE_FOR_JOVIAL_BIT_TYPE_END

// SgTypedFixed is a primitive type in Jovial
SOURCE_CREATE_TYPE_FOR_TYPE_FIXED_START

SgTypeFixed*
SgTypeFixed::createType(SgExpression* scale, SgExpression* fraction, SgExpression* optional_fortran_type_kind)
   {
  // There is no size (equivalent to Fortran kind) parameter for Jovial fixed type
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgTypeFixed* return_type = new SgTypeFixed(scale, fraction);
     ROSE_ASSERT(return_type != NULL);

     SgName name = return_type->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);
     if (t == NULL)
        {
           get_globalTypeTable()->insert_type(name,return_type);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          ROSE_ASSERT(t != return_type);
          delete return_type;
#endif
          return_type = isSgTypeFixed(t);
        }

     return return_type;
   }

SOURCE_CREATE_TYPE_FOR_TYPE_FIXED_END


SOURCE_CREATE_TYPE_FOR_STRING_TYPE_START

SgTypeString*
SgTypeString::createType ( SgExpression* lengthExpression, SgExpression* optional_fortran_type_kind )
   {
     SgTypeString* returnType = new SgTypeString(lengthExpression);
     if (optional_fortran_type_kind != NULL)
        {
          returnType->set_type_kind(optional_fortran_type_kind);
          optional_fortran_type_kind->set_parent(returnType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;
          // TV (09/29/2021): lengthExpression was owned by returnType so it got deleted. This prevent setting the parent on deleted node below
          lengthExpression = NULL;

          returnType = isSgTypeString(t);
        }

  // DQ (2/20/2007): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (lengthExpression != NULL)
        {
          ROSE_ASSERT(lengthExpression->get_parent() == NULL);
          lengthExpression->set_parent(returnType);
        }

  // DQ (10/9/2010): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (optional_fortran_type_kind != NULL && optional_fortran_type_kind->get_parent() == NULL)
        {
          optional_fortran_type_kind->set_parent(returnType);
        }

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_STRING_TYPE_END


SOURCE_CREATE_TYPE_FOR_MODIFIER_TYPE_START

SgModifierType*
SgModifierType::createType(SgType*, unsigned int, SgExpression*)
   {
     printf ("ERROR: This function should not be called (replaced by different API plus insertModifierTypeIntoTypeTable()) \n");
     ROSE_ABORT();
     return nullptr;
   }

SgModifierType*
SgModifierType::insertModifierTypeIntoTypeTable(SgModifierType* result)
   {
  // DQ (7/28/2010): Insert result type into type table and return it, or
  // replace the result type, if already available in the type table, with
  // the type from type table.

  // An assumption (that I don't know how to check currently) is that this is a newly built
  // type not previously used and not yet returned from any of the following functions
  // calling this function. Thus is has not been added yet to any (global or local) type table.
     ASSERT_not_null(result);

  // This is the type after some specification (setting) via type modifier flags. We could verify
  // this by testing that at least one type modifier flag was set, not done yet.
     SgName name = result->get_mangled();

  // Only look for modifiers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == nullptr)
        {
       // The pointer type was not found in the type table, put it into the global type table.

       // DQ (7/30/2018): This function can't just strip down to the bae type (past typedefs, since we need
       // to resolve different typedefs in different classes to be different, we need to stop at typedefs.
       // This issue is important ot Cxx11_tests/test2018_134.C where a typedef is not to be shared since it
       // exists in two different classes.  Basically typedefs have a declaration which make then have a local
       // scope which is different from other types (such a modifiers, references, pointers, and array types).
          unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE;
          SgType* root_type = result->stripType(bit_array);
          ASSERT_not_null(root_type);
          if (handledUsingLocalTable(root_type) == false)
             {
               get_globalTypeTable()->insert_type(name,result);
             }
        }
       // PP (04/19/24): Ada adds new types that need to be stripped (i.e., AdaAccessType, AdaSubtype)
       //                disable the error checking temporarily..
       else if (!SageInterface::is_Ada_language())
        {
          if (t->stripType() != result->stripType())
             {
               printf ("insertModifierTypeIntoTypeTable(): result is modifier type to base_type = %p = %s name = %s \n",result->get_base_type(),result->get_base_type()->class_name().c_str(),name.str());
               printf ("t      = %p = %s \n",t,t->class_name().c_str());
               printf ("result = %p = %s \n",result,result->class_name().c_str());
               SgType* t_stripped      = t->stripType();
               SgType* result_stripped = result->stripType();
               printf ("t_stripped           = %p = %s \n",t_stripped,t_stripped->class_name().c_str());
               printf ("result_stripped      = %p = %s \n",result_stripped,result_stripped->class_name().c_str());

               SgName t_name      = t->get_mangled();
               SgName result_name = result->get_mangled();

               printf ("t_name      = %s \n",t_name.str());
               printf ("result_name = %s \n",result_name.str());

               bool t_isTypeEquivalent          = t->isEquivalentType(result);
               bool t_stripped_isTypeEquivalent = t_stripped->isEquivalentType(result_stripped);

               printf ("t_isTypeEquivalent          = %s \n",t_isTypeEquivalent ? "true" : "false");
               printf ("t_stripped_isTypeEquivalent = %s \n",t_stripped_isTypeEquivalent ? "true" : "false");

               SgNamedType* t_namedType      = isSgNamedType(t_stripped);
               SgNamedType* result_namedType = isSgNamedType(result_stripped);
               if (t_namedType != nullptr && result_namedType != nullptr)
                  {
                    SgDeclarationStatement* t_declaration = isSgDeclarationStatement(t_namedType->get_declaration());
                    ASSERT_not_null(t_declaration);
                    SgDeclarationStatement* result_declaration = isSgDeclarationStatement(result_namedType->get_declaration());
                    ASSERT_not_null(result_declaration);

                    printf ("t_declaration      = %p = %s \n",t_declaration,t_declaration->class_name().c_str());
                    printf ("result_declaration = %p = %s \n",result_declaration,result_declaration->class_name().c_str());

                    printf ("t_namedType->get_name()      = %s \n",t_namedType->get_name().str());
                    printf ("result_namedType->get_name() = %s \n",result_namedType->get_name().str());

                    SgName t_stripped_name      = t_stripped->get_mangled();
                    SgName result_stripped_name = result_stripped->get_mangled();

                    printf ("t_stripped_name      = %s \n",t_stripped_name.str());
                    printf ("result_stripped_name = %s \n",result_stripped_name.str());

                    SgNonrealDecl* t_nonreal_declaration      = isSgNonrealDecl(t_declaration);
                    SgNonrealDecl* result_nonreal_declaration = isSgNonrealDecl(result_declaration);

                    if (t_nonreal_declaration != nullptr && result_nonreal_declaration != nullptr)
                       {
                         printf ("t_nonreal_declaration->get_name()      = %s \n",t_nonreal_declaration->get_name().str());
                         printf ("result_nonreal_declaration->get_name() = %s \n",result_nonreal_declaration->get_name().str());
                       }
                  }
             }

       // If it is already present in the type table then delete the type (so that it will remain unique).
       // DQ (7/30/2010): Because SageBuilder::buildModifierType(SgType*) can be still
       // called by mistake, we have to handle the case of where the type in the table is
       // not a SgModifierType.
          if (isSgModifierType(t) != nullptr)
             {
               result = isSgModifierType(t);
             }
          ASSERT_not_null(result);
        }

     ASSERT_not_null(result);
     return result;
   }

SOURCE_CREATE_TYPE_FOR_MODIFIER_TYPE_END

SOURCE_CREATE_TYPE_FOR_QUALIFIED_NAME_TYPE_START
$CLASSNAME*
$CLASSNAME::createType(SgType* base_type, unsigned int /*f*/, SgExpression* optional_fortran_type_kind)
   {
     ASSERT_not_null(base_type);

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == nullptr);

     printf ("Error, this function $CLASSNAME should not have been called! \n");
     ROSE_ASSERT (false);

     return nullptr;
   }

SOURCE_CREATE_TYPE_FOR_QUALIFIED_NAME_TYPE_END


SOURCE_CREATE_TYPE_FOR_COMPLEX_TYPE_START

$CLASSNAME*
$CLASSNAME::createType(SgType* t, SgExpression* /*optional_fortran_type_kind*/)
   {
  // Not clear why this is using a map???
     static std::map<SgType*, $CLASSNAME*> cache;

     $CLASSNAME*& returnType = cache[t];

     if (returnType == nullptr)
        {
          returnType = new $CLASSNAME(t);
        }
     ASSERT_not_null(returnType);

     return returnType;
   }

SgExpression*
$CLASSNAME::get_type_kind() const
   {
     return this->get_base_type()->get_type_kind();
   }

void
$CLASSNAME::set_type_kind ( SgExpression* type_kind )
   {
     this->get_base_type()->set_type_kind(type_kind);
   }

SOURCE_CREATE_TYPE_FOR_COMPLEX_TYPE_END
