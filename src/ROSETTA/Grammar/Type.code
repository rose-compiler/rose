// #########################################################    -*- C++ -*-
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START

 /*  This class forms a base class for all of the types represented in the C++ grammar.
     All types are derived from this class and thus contain the following functionality.
  */

     public:
      /*
          \if documentDevelopmentVersionUsingDoxygen
          name Friend Classes
               \brief Friend classes declarations

          \endif
       */
          friend class SgPointerType;         //!< provide access to private data
          friend class SgReferenceType;       //!< provide access to private data
          friend class SgRvalueReferenceType; //!< provide access to private data
          friend class SgDeclType;            //!< provide access to private data
          friend class SgTypedefType;         //!< provide access to private data
          friend class SgTypeOfType;          //!< provide access to private data
       /*! */

     public:
      /*! \if documentDevelopmentVersionUsingDoxygen
               \brief default constructor

               Default constructor and destructors are not documented in user
               interface \ref defaultConstructorDestructorDocumentationPage.
               \sa \ref defaultConstructorDestructorDocumentationPage
          \endif
       */
          SgType();

      /*! \brief copy constructor

          The Copy constructor is provide to support the AST copy mechanism, where
          types are copied to support copying of named types.
       */
          SgType(const SgType & X);

       // RV (1/30/2006)
      /*! Returns a mangled string representation of this type.
          Equivalent types have the same mangled string.
       */
          virtual SgName get_mangled (void) const;

       // SKW (3/1/2011): Added these explicit declarations since we no longer build them automatically
          virtual SgExpression * get_type_kind () const;
          virtual void set_type_kind ( SgExpression* type_kind );

      /*!
          name Numerical Modifiers
          \brief Compute numerical properties of type.

          These define numeric properties of the type (e.g. int, float, etc.)

          \internal Return type should be changed to "bool."
       */
          bool isUnsignedType() const;  //!< There are many sorts of unsigned types (this queries an arbitrary type).
          bool isIntegerType() const;   //!< There are many sorts of integer types (this queries an arbitrary type).
          bool isFloatType() const;     //!< There are several sorts of float types (this queries an arbitrary type).

       // DQ (4/20/2019): Added support to detect primative types (which don't require name qualification).
          bool isPrimativeType() const;   //!< There are many sorts of primative types (this queries an arbitrary type).
       /*! */

       // DQ (10/11/2007): These sorts of values are usually handled as enum fields in ROSE. They could be redone at some point.
       // PC and AS new variables to support a flexible stripType() which takes an bit array as a paramater
          static const unsigned char STRIP_MODIFIER_TYPE         = ((unsigned char) 1 << 0); // 0x01
          static const unsigned char STRIP_REFERENCE_TYPE        = ((unsigned char) 1 << 1); // 0x02
          static const unsigned char STRIP_RVALUE_REFERENCE_TYPE = ((unsigned char) 1 << 2); // 0x04
          static const unsigned char STRIP_POINTER_TYPE          = ((unsigned char) 1 << 3); // 0x08
          static const unsigned char STRIP_ARRAY_TYPE            = ((unsigned char) 1 << 4); // 0x16
          static const unsigned char STRIP_TYPEDEF_TYPE          = ((unsigned char) 1 << 5); // 0x32

       // DQ (4/15/2019): Adding specific support for pointer to member (SgPointerMemberType) since we don't always 
       // want to strip it and we need better control over this.  Since SgPointerMemberType is derived from SgPointerType 
       // (which might be a design mistake) it was handled along with SgPointer but for name qualification we need the 
       // stripType function to have greater expresiveness.
          static const unsigned char STRIP_POINTER_MEMBER_TYPE   = ((unsigned char) 1 << 6); // 0x64

      /*! \brief Some types store internal SgType pointers explicitly while others compute them from other data.  This function is true if it has a data member that is a type (pointer, array, etc.).

          Result is true if it stores a type explicitly as a data member, else false.

          \internal True only if this is either a SgPointerType, SgReferenceType, PointerMemberType, 
                    JavaParameterizedType, JavaWildcardType, ModifierType, QualifiedNameType, FunctionType, 
                    MemberFunctionType, SgArrayType, TypeComplex, or TypeImaginary.
       */
          bool hasExplicitType();

      /*! \brief Some types can hide other type IR nodes internally.  This function is true if it can hide another type (pointer, array, etc.).

          Result is true if it can hide a one or more types, else false.

          \internal True only if this is either a SgPointerType, SgArrayType, SgReferenceType, SgTypedefType, SgFunctionType, or SgModifierType.
       */
          bool containsInternalTypes();

      /*! \brief Generate a container of types hidden in the input type.

          Returns a vector of types hidden in the input type (pointer, array, etc.).

          \internal Order of types in vector is not significant (e.g. for SgFunctionType IR nodes).
       */
          Rose_STL_Container<SgType*> getInternalTypes() const;

      /*! \brief Reset the base type.
          This function resets the base type.  It is an error to call it for types where containsInternalTypes() == false.
       */
          void reset_base_type(SgType* baseType);

      /*! \brief Return the base type of the associated type.
          The base type is important when dealing with pointers, arrays, etc.
       */
          SgType* findBaseType() const;

          SgType * dereference();              //!< Returns type hidden behind pointer of reference.
          const SgType * dereference() const ; //!< Returns type hidden behind pointer of reference.

       // DQ (6/21/2005): Added to support getting a deeply nested types quickly and easily.
      //! Returns hidden type beneath layers of typedefs, pointers, references, modifiers, array representation, etc.
      //  SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE ) const;
          SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | 
                                                      STRIP_POINTER_TYPE  | STRIP_ARRAY_TYPE     | STRIP_TYPEDEF_TYPE          | STRIP_POINTER_MEMBER_TYPE ) const;

       // DQ (6/30/2005): Added to support invistigation of hidden types
      //! This only strips away typedefs and modifiers (specialized usage).
          SgType* stripTypedefsAndModifiers() const;

       // DQ (6/30/2005): Would these functions also be useful?
       // SgType* stripTypedefs() const;
       // SgType* stripModifiers() const;

       // DQ (7/26/2010): Now we finally need this function!
       // Generates a new SgModifierType with modifiers set according to input parameter.
       // SgModifierType* matchModifiers(unsigned int f);

       // void printName(SgUnparse_Info& ui, ostream& os);

#if 0
       // This codes was part of an experiment to distinguish struct tag { int x; } X; from struct tag X;
       // It turns out that the declaration of the tag in this case in placed into the EDG orphan list
       // as a type and that we don't require this mechanism (thought we might in the future so for now
       // it is just commented out.

       // DQ Added to support unparsing of autonomous declarations
       // Support for variable declearations where the type is explicitly defined as a structure
          enum useWithinDeclarationEnum {
           // handle cases of struct B btag { int x; } b_1st; and struct btag b_2nd;
               e_first_declaration          = 0x00000001,
           // distinguish between B { int x; } b; and B btag { int x; } b;
               e_autonomous_tag_declaration = 0x00000002
                                    };
          useWithinDeclarationEnum p_useWithinDeclaration;

       // These are for support of the useWithinDeclaration variable
          bool isFirstDeclaration() const;
          void setFirstDeclaration();
          void unsetFirstDeclaration();
          bool isAutonomousTagDeclaration() const;
          void setAutonomousTagDeclaration();
          void unsetAutonomousTagDeclaration();
#endif

       // DQ (9/7/2007): Support for Fortran attribute specifiers
          enum fortran_attribute_specifiers_enum
             {
               e_unknown_attribute_specifier = 0,
               e_public_access,
               e_private_access,
               e_allocatable,
               e_asynchronous,
               e_bind,
               e_data,
               e_dimension,
               e_intent,
               e_optional,
               e_parameter,
               e_pointer,
               e_protected,
               e_save,
               e_target,
               e_value,
               e_volatile,
               e_last_attribute_specifier
             };



      /*
          name Conversion Functions
          \brief Simple conversion functions.
          \internal Not sure these are useful when using the string interface.
       */
      //! performs simple conversions
          static SgType * arithmetic_conversions(SgType *, SgType *);

      //! handles promotion to integer
          static SgType * integer_promotion     (SgType *, SgType *);

      //! handles promotion to float
          static SgType * float_promotion       (SgType *, SgType *);
      /*! */

       // DQ (4/27/2005): Added protected function to support refactored code for name mangling
     protected:
      //! \deprecated by RV (2/2/2006)
          SgName mangledNameSupport(SgName & fname, SgUnparse_Info& info);

     public:

       // DQ (7/24/2010): Added static function to distiquish which types (very few) are
       // required to use the local type table for types built during AST construction.
       // This is required to support that we don't always know the scope of a type while
       // it is being constructed (while it's declarations are being constructed).
          static bool handledUsingLocalTable( SgType* t );

       // DQ (7/30/2010): This function gets the scope from either the C/C++ or Fortran
       // procesing so that the local type table in each scope can be referenced.
          static SgScopeStatement* getCurrentScope();

          SgDeclarationStatement* getAssociatedDeclaration() const;

#if 0
       // DQ (11/28/2015): This has been moved from the SgModifierType class to the SgType class since it is a general requirement.
       // DQ (11/28/2015): Adding operator==() function to use in symbol table lookup when template 
       // arguments or parameters resolve to SgModifierType and we need to know if it is the same type.
       // One might expect that with type tables they would only be the same if there were the same 
       // pointer, but I think this is not alwasy true for SgModifierType nodes.
       // bool operator== (const SgType & Y) const;
#endif
       // DQ (12/8/2015): Insead of the operator==(), we require a more nuanced approach.
       // There are concepts of type equivalence (where for example a typedef of an int would 
       // be the same type as the int) and type intechangablity, where two equivalent types will
       // can be substituted for each other (which might not be possible if one of them has 
       // only private access permissions.
      //! Type equivalence is the concept of equality between types independent of access permissions (e.g. private or protected types in a class).
          bool isEquivalentType (const SgType * other_type) const;

HEADER_END


HEADER_X_TYPE_START
HEADER_X_TYPE_END


HEADER_NON_X_TYPE_START
HEADER_NON_X_TYPE_END

HEADER_BUILTIN_TYPE_SUPPORT_START
#if 0
       // DQ (12/26/2005): Supporting function for traverseMemoryPool
       // where static IR nodes (only isn soem SgType IR nodes) are
       // present and must be traversed using specially generated code.
          static void executeVisitorMemberFunctionOnBuiltinData(ROSE_VisitorPattern & visitor);
#endif
HEADER_BUILTIN_TYPE_SUPPORT_END


HEADER_COMMON_CREATE_TYPE_START
      //! example of type used where construction is particularly simple
       // DQ (1/31/2006): Modified to build all types in the memory pools
       // static $CLASSNAME builtin_type;
       // static $CLASSNAME* builtin_type;

       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static $CLASSNAME* get_builtin_type();

       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static void set_builtin_type($CLASSNAME* builtin_type);

      //! function returns example of type
       // DQ (10/4/2010): Added support for optional Fotran type_kind specification.
       // static $CLASSNAME* createType(void);
          static $CLASSNAME* createType(SgExpression* optional_fortran_type_kind = NULL);
HEADER_COMMON_CREATE_TYPE_END


HEADER_CREATE_TYPE_WITH_PARAMETER_START
       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static $CLASSNAME* get_builtin_type();

       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static void set_builtin_type($CLASSNAME* builtin_type);

      //! more sophisticated version for more complex types like $CLASSNAME (types whose constructors take parameters)
       // DQ (10/4/2010): Added support for optional Fotran type_kind specification.
       // static $CLASSNAME* createType(CREATE_TYPE_PARAMETER);
          static $CLASSNAME* createType(CREATE_TYPE_PARAMETER, SgExpression* optional_fortran_type_kind = NULL);
HEADER_CREATE_TYPE_WITH_PARAMETER_END


HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_TYPE_ARRAY_START
       // static $CLASSNAME* get_builtin_type();
       // static void set_builtin_type($CLASSNAME* builtin_type);

       //! builtin_type variable specific to the SgArrayType object (for maxBitLength=32 bit integers)
       // Could not use maxBitLength in array size below (so I just used the #define value directly).
       // DQ (1/31/2006): Modified to build all types in the memory pools
       // static $CLASSNAME builtin_type[ROSE_INTEGER_TYPE_MAX_BIT_LENGTH];
       // static $CLASSNAME* builtin_type[ROSE_INTEGER_TYPE_MAX_BIT_LENGTH];
HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_TYPE_ARRAY_END


HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_START
       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static $CLASSNAME* get_builtin_type();

       // DQ (6/18/2007): This does not appear to be used anywhere in ROSE.  It is no longer required
       // since we don't store the type explicitly anymore except in a few IR nodes which have there
       // own data member and associated access function.
       // static set_builtin_type($CLASSNAME* builtin_type);

       //! builtin_type variable specific to the $CLASSNAME object
       // DQ (1/31/2006): Modified to build all types in the memory pools
       // static $CLASSNAME builtin_type;
       // static $CLASSNAME* builtin_type;
HEADER_BUILTIN_FOR_CREATE_TYPE_WITH_PARAMETER_END


HEADER_GET_MANGLED_START
       // SgName get_mangled ( SgUnparse_Info & info );

      //! Mangled name support for unparser support
       // SgName get_mangled ( SgUnparse_Info & info );
       // RV (1/31/2006): Removed dependence on SgUnparse_Info.
          virtual SgName get_mangled (void) const $ROSE_OVERRIDE;

HEADER_GET_MANGLED_END

HEADER_TYPEDEF_TYPE_START

       // DQ (10/18/2007): Added copy constructor so that the typedef lists on each type could be updated properly.
      //! Copy constructor to support AST copy mechanism.
          SgTypedefType ( const SgTypedefType & X );

HEADER_TYPEDEF_TYPE_END

HEADER_VIRTUAL_GET_NAME_START
       //! Gets name of the type (useful for debugging, unparsing, etc.)
       /*! Avoid making abstract base classes (if we can) because in the
           automated generation of code we want to avoid placing constraints
           on derived classes.
        */
       // virtual SgName get_name() const = 0;
          virtual SgName get_name() const;

          SgNamedType ( const SgNamedType & X );
HEADER_VIRTUAL_GET_NAME_END


HEADER_GET_NAME_START
      //! Support for some classes which have pure virtual function in base classes.
      /*! For the classes derived from where the pure  virtual "virtual SgName get_name() = 0;"
          This applies to the SgClassType, SgTypedef and the
          SgEnumType (derived from SgNamedType)
       */
          SgName get_name() const $ROSE_OVERRIDE;
HEADER_GET_NAME_END


HEADER_GET_QUALIFIED_NAME_START
      //! Used for the SgNamedType object (base class for the SgClassType, SgTypedefType and the SgEnumType object)
          SgName get_qualified_name() const;
HEADER_GET_QUALIFIED_NAME_END


HEADER_GET_BASE_TYPE_START
      //! This is used in the SgTypedefType object (is not associated with a base_type data field)
          SgType* get_base_type() const;
HEADER_GET_BASE_TYPE_END


HEADER_CLASS_TYPE_START
          SgClassType ( const SgClassType & X );
HEADER_CLASS_TYPE_END

HEADER_NONREAL_TYPE_START
          SgNonrealType ( const SgNonrealType & X );
//        virtual SgName get_mangled(void) const;
//        virtual SgName get_name() const;
HEADER_NONREAL_TYPE_END

HEADER_AUTO_TYPE_START
          SgAutoType ( const SgAutoType & X );
//        virtual SgName get_mangled(void) const;
//        virtual SgName get_name() const;
HEADER_AUTO_TYPE_END


HEADER_JAVA_PARAMETERIZED_TYPE_START
          SgJavaParameterizedType ( const SgJavaParameterizedType & X );
HEADER_JAVA_PARAMETERIZED_TYPE_END


HEADER_JAVA_QUALIFIED_TYPE_START
          SgJavaQualifiedType ( const SgJavaQualifiedType & X );
HEADER_JAVA_QUALIFIED_TYPE_END


HEADER_JAVA_WILDCARD_TYPE_START
          SgJavaWildcardType ( const SgJavaWildcardType & X );
          bool is_unbound();
HEADER_JAVA_WILDCARD_TYPE_END


HEADER_JAVA_UNION_TYPE_START
          SgJavaUnionType ( const SgJavaUnionType & X );

       // DQ (3/22/2017): Added explicitly to avoid using mechansim reserved for virtual functions 
       // (part of support for override specification and elimination of those warnings from Clang).
          SgName get_name() const;
HEADER_JAVA_UNION_TYPE_END


HEADER_JAVA_PARAMETER_TYPE_START
          SgJavaParameterType ( const SgJavaParameterType & X );
HEADER_JAVA_PARAMETER_TYPE_END


HEADER_JOVIAL_TABLE_TYPE_START
          SgJovialTableType ( const SgJovialTableType & X );
HEADER_JOVIAL_TABLE_TYPE_END


HEADER_ENUM_TYPE_START
          SgEnumType ( const SgEnumType & X );
HEADER_ENUM_TYPE_END


HEADER_TEMPLATE_TYPE_START
HEADER_TEMPLATE_TYPE_END


HEADER_MODIFIER_TYPE_START

       // name TypeModifierGroup3 Type Modifiers
      /*
          name Type Modifiers
          \brief Compute modifier values.

          These return false in the implementation of the virtual functions
          in SgType and are overridden here.

          \internal Return type should be changed to "bool."
          \todo implement type modifier query functions in SgType class.
       */
#if 0
      //! Tests for declaration as const
          bool isConst() const ;
      //! Test for declaration as volatile
          bool isVolatile() const ;
      //! Tests for declaration as restrict
          bool isRestrict() const ;
      //! Tests for declaration as UPC shared
          bool isUPC_Shared() const ;
      //! Tests for declaration as UPC strict
          bool isUPC_Strict() const ;
      //! Tests for declaration as UPC relaxed
          bool isUPC_Relaxed() const ;
#endif
       /*! */

  // DQ (7/28/2010): Make this private so that we can support API that would force the type table to be used.
  // Users should use the build functions to construct modifier types (SgModifierType IR nodes) with different
  // flags set.
  // private:
      //! Access function for modifier
          SgTypeModifier & get_typeModifier();

       // RV (2/2/2006): Added a 'const' version
          const SgTypeModifier& get_typeModifier (void) const;

  // DQ (7/28/2010): Make this public as the end of the previous private region.
     public:
       // friend namespace SageBuilder;
       // friend SgModifierType* SageBuilder::buildConstType(SgType* base_type /*=NULL*/);

          static SgModifierType* insertModifierTypeIntoTypeTable( SgModifierType* result );

#if 0
       // DQ (11/28/2015): This has been move to the SgType class since it is a general requirement.
       // DQ (11/28/2015): Adding operator==() function to use in symbol table lookup when template 
       // arguments or parameters resolve to SgModifierType and we need to know if it is the same type.
       // One might expect that with type tables they would only be the same if there were the same 
       // pointer, but I think this is not alwasy true for SgModifierType nodes.
       // bool operator== (const SgModifierType & X, const SgModifierType & Y);
          bool operator== (const SgModifierType & Y) const;
#endif
#if 0
          void unsetRestrict();
          void setRestrict();
          void unsetConst();
          void setConst();
          void unsetVolatile();
          void setVolatile();
          void unsetUPC_Shared();
          void setUPC_Shared();
          void unsetUPC_Strict();
          void setUPC_Strict();
          void unsetUPC_Relaxed();
          void setUPC_Relaxed();
#endif

#if 0
       // Tests not implemented!

      //! Tests for declaration as extern
          bool isExtern() const ;
      //! Tests for declaration as typedef
          bool isTypedef() const ;
      //! Tests for declaration as virtual
          bool isVirtual() const ;
      //! Test for declaration as protected
          bool isProtected() const ;
      //! Test for declaration as private
          bool isPrivate() const ;
      //! Test for declaration as public
          bool isPublic() const ;
      //! Test for declaration as auto (default)
          bool isAuto() const ;
#endif

#if 0
      //! Enum type containing all modifiers
          enum modifiers
             {
               m_volatile = 0x01, //!< storage modifier
               m_global   = 0x02, //!< not use by ROSE
               m_sync     = 0x04, //!< not use by ROSE
               m_const    = 0x08, //!< const modifier
               m_restrict = 0x10,//!< support for restrict keyword (specifies non-aliased pointers)
               m_shared   = 0x20, //!< UPC shared modifier
               m_strict   = 0x40, //!< UPC strict modifier
               m_relaxed  = 0x80, //!< UPC relaxed modifier
             };

       //! mask bits on
          void set_modifier   (int flag);

       //! mask bits off
          void unset_modifier (int flag);

      //! Access function for modifiers
          bool isConst() const;
          bool isSync() const;
          bool isGlobal() const;
          bool isVolatile() const;
          bool isRestrict() const;

       // UPC specific
          bool isShared() const;
          bool isStrict() const;
          bool isRelaxed() const;

      //! Set/unset functions for specific modifiers
          void unsetSync();
          void setSync();
          void unsetGlobal();
          void setGlobal();
          void unsetConst();
          void setConst();
          void unsetRestrict();
          void setRestrict();

       // UPC specific
          void unsetShared();
          void setShared();
          void unsetStrict();
          void setStrict();
          void unsetRelaxed();
          void setRelaxed();

      //! Get whole bit field fr modifier set
          unsigned int bitfield(void);
#endif

#if 0
       // DQ (4/6/2004): Added to provide uniform support for type modifiers
          enum type_modifier_enum
             {
            // Bit values can support multiple values in a single enum type
               e_unknown     =   0x000,   // Unknown value (default)
               e_const       =   0x001,   // Const qualifier
               e_volatile    =   0x002,   // Volatile qualifier
               e_restrict    =   0x004,   // Restrict qualifier
               e_unaligned   =   0x008,   // Microsoft __unaligned qualifier
               e_near        =   0x010,   // near
               e_far         =   0x020,   // far
               e_upc_shared  =   0x040,   // UPC shared
               e_upc_strict  =   0x080,   // UPC strict
               e_upc_relaxed =   0x100,   // UPC relaxed
               e_last_type_modifier = 0x200
             };

       // DQ (4/6/2004): Added to provide uniform support for storage modifiers
          enum storage_modifier_enum
             {
            // Only one value can be specified (at least in C, what about C++)
               e_unknown_storage,
               e_extern,
               e_static,
               e_auto,
               e_unspecified,
               e_typedef,
               e_register,
               e_asm,
#ifdef FORTRAN_SUPPORTED
               e_local,              // Auto or static at back end's preference
               e_common,             // A COMMON block
               e_associated,         // Variable is part of an association
               e_intrinsic,          // Intrinsic function or subroutine
               e_pointer_based,      // Pointee of a POINTER definition
#endif
               e_last_storage_modifier
             };

       // DQ (4/6/2004): Added to provide uniform support for access modifiers
          enum access_modifier_enum
             {
            // Only one value can be specified (at least in C, what about C++)
               e_unknown_access,
               e_private,
               e_protected,
               e_public,
               e_virtual,  // support for virtual base class (applies only in case of inheritance)
               e_last_access_modifier
             };

          int checkBit(type_modifier_enum bit) const;
          void setBit(type_modifier_enum bit);
          void unsetBit(type_modifier_enum bit);
#endif

#if 0
       // DQ (4/13/2004): This new design organizes the modifiers in SAGE

      //! Modifier Interface (implementation is hidden in specific modifier objects)
      //! Type Modifier Support

       // Interface from cv-specifier in type-specifier
          int isConst() const;
          void setConst();
          void unsetConst();

       // Interface from cv-specifier in type-specifier
          int isVolatile() const;
          void setVolatile();
          void unsetVolatile();

       // Interface from type-specifier
          int isRestrict() const;
          void setRestrict();
          void unsetRestrict();
#if 0
          int isUnaligned() const;
          void setUnaligned();
          void unsetUnaligned();

          int isNear() const;
          void setNear();
          void unsetNear();

          int isFar() const;
          void setFar();
          void unsetFar();
#endif
          int isUPC_Shared() const;
          void setUPC_Shared();
          void unsetUPC_Shared();

          int isUPC_Strict() const;
          void setUPC_Strict();
          void unsetUPC_Strict();

          int isUPC_Relaxed() const;
          void setUPC_Relaxed();
          void unsetUPC_Relaxed();

      //! Storage Modifier Support
          int isUnknownStorage() const;
          void setUnknownStorage();

          int isExtern() const;
          void setExtern();

          int isStatic() const;
          void setStatic();

          int isAuto() const;
          void setAuto();

          int isUnspecified() const;
          void setUnspecified();

       // This is not used (but is present in the EDG AST)
          int isTypedef() const;
          void setTypedef();

          int isRegister() const;
          void setRegister();

          int isAsm() const;
          void setAsm();

#ifdef FORTRAN_SUPPORTED
       // These remaining access functions are specific to FORTRAN
          int isLocal() const;
          void setLocal();

          int isCommon() const;
          void setCommon();

          int isAssociated() const;
          void setAssociated();

          int isIntrinsic() const;
          void setIntrinsic();

          int isPointerBased() const;
          void setPointerBased();
#endif

      //! Access Modifier Support
          int isUnknownAccess() const;
          void setUnknownAccess();

          int isPrivate() const;
          void setPrivate();

          int isProtected() const;
          void setProtected();

          int isPublic() const;
          void setPublic();

          int isVirtual() const;
          void setVirtual();

      //! Get whole bit field fr modifier set
          unsigned int bitfield(void);
#endif

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() $ROSE_OVERRIDE;

HEADER_MODIFIER_TYPE_END


HEADER_QUALIFIED_NAME_TYPE_START
          SgName get_prefix() const;

       // SgName get_mangled (void) const;

       // DQ (10/10/2006): Handle qualified name list at the declarations directly, instead of at the types.
       // At present these are useful for SgVariableDeclaration and SgTypedefDeclaration, but likely others
       // at some point.
          SgQualifiedNamePtrList & get_qualifiedNameList();
          const SgQualifiedNamePtrList & get_qualifiedNameList() const;
          void set_qualifiedNameList( const SgQualifiedNamePtrList & x );

HEADER_QUALIFIED_NAME_TYPE_END


HEADER_FUNCTION_TYPE_START

      //! Constructor for building a function type
          SgFunctionType(SgPartialFunctionType *);

       // static SgFunctionType* createType(SgPartialFunctionType *);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization () $ROSE_OVERRIDE;

      // Get a const list of input types (types of the parameters list) to this function type (from a cost functionType object)
      //! This is a const convience access function to the STL container of types in the child IR node (SgFunctionParameterTypeList* p_argument_list).
          const SgTypePtrList & get_arguments() const;

      // Get the list of input types (types of the parameters list) to this function type
      //! This is a non-const convience access function to the STL container of types in the child IR node (SgFunctionParameterTypeList* p_argument_list).
          SgTypePtrList & get_arguments();

       // WAS: void append_argument(const SgTypePtr& what);
       // WAS: void insert_argument(const SgTypePtrList::iterator& where, const SgTypePtr & what)

      //! Append new argument to argument type list
          void append_argument( SgType* what);

      //! Insert new argument to argument type list
          void insert_argument(const SgTypePtrList::iterator& where, SgType* what);

      //! get the mangled name (this version is used in unparsing)
      /*! This version can be tailored using the input SgUnparse_Info parameter.
       */
       // DQ (2/7/2006): Removed as a test
       // virtual SgName get_mangled_name ( SgUnparse_Info & info );

      //! get the mangled name
      //! get the mangled name \deprecated by RV (2/2/2006)
          virtual SgName get_mangled_type ();

      //! I forget why this is here.
      //  SgFunctionType* mkAnotherType(SgType *);

      //! I forget why this is here.
      //  void sym_print(std::ostream& os);

          SgSymbol* get_symbol_from_symbol_table() const;
          
       // TV (04/18/11): For support of shared function type.
          static SgName get_mangled(SgType* return_type, SgFunctionParameterTypeList * typeList);

HEADER_FUNCTION_TYPE_END

HEADER_MEMBER_FUNCTION_TYPE_START

      //! Constructor
          SgMemberFunctionType(SgPartialFunctionType *);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() $ROSE_OVERRIDE;

#if 1
      //! Enum for const and volatile function modifiers
          enum mfunc_specifier_enum
             {
               e_const     =     0x00000001,
               e_volatile  =     0x00000002,
               e_restrict  =     0x00000004,

            // DQ (1/9/2020): Added reference qualifiers (C++11 feature).
               e_ref_qualifier_lvalue = 0x00000008,
               e_ref_qualifier_rvalue = 0x00000010
             };

       // static SgMemberFunctionType* createType(SgPartialFunctionType *);

#if 0
      //! const access/set/unset member functions for member function type
          int isUnknownFunc();
          void setUnknownFunc();

      //! const access/set/unset member functions for member function type
          int isDefaultFunc();
          void setDefaultFunc();
#endif
      //! const access/set/unset member functions for member function type
          bool isConstFunc() const; // RV (2/1/2006): Made 'const' member
          void setConstFunc();
          void unsetConstFunc();

      //! volatile access/set/unset member functions for member function type
          bool isVolatileFunc() const; // RV (2/1/2006): Made 'const' member
          void setVolatileFunc();
          void unsetVolatileFunc();
#if 1
       // DQ (3/8/2012): Enabled the use of rescrict recorded in the function type.
      //! restrict access/set/unset member functions for member function type
          bool isRestrictFunc() const;
          void setRestrictFunc();
          void unsetRestrictFunc();
#endif

       // DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
      //! L-value reference access/set/unset member functions and member function type
          bool isLvalueReferenceFunc() const;
          void setLvalueReferenceFunc();
          void unsetLvalueReferenceFunc();

      //! R-value reference access/set/unset member functions and member function type
          bool isRvalueReferenceFunc() const;
          void setRvalueReferenceFunc();
          void unsetRvalueReferenceFunc();
#endif

       // void set_mfunc_specifier(unsigned long i);
       // SgName get_mangled(SgUnparse_Info &);

      //! Mangled name support for unparser
      //  SgName get_mangled_name(SgUnparse_Info&);

      //! Mangled name support
       // SgName get_mangled_type();
       // RV (2/1/2006): Changed signature, and removed 'get_mangled_type()'.
          virtual SgName get_mangled_name (void) const;

       // DQ (12/6/2012): Adding member function specifier data (since this will be a part of the generated mangled name).
       // DQ (12/3/2011): Added better support for member function name mangling (symetric with SgFunctionType).
       // static SgName get_mangled(SgType* ret_type, SgFunctionParameterTypeList* typeList, SgClassType* classType );
          static SgName get_mangled(SgType* ret_type, SgFunctionParameterTypeList* typeList, SgType* classType, unsigned int mfunc_specifier );

      //! I forget why this is here.
          SgMemberFunctionType * mkAnotherType(SgType *);

      //! \deprecated The struct_name property has been replaced by the class_type property, an SgType
          SgClassDefinition* get_struct_name() const;

HEADER_MEMBER_FUNCTION_TYPE_END


HEADER_PARTIAL_FUNCTION_TYPE_START
          void post_construction_initialization () $ROSE_OVERRIDE;
HEADER_PARTIAL_FUNCTION_TYPE_END


HEADER_TYPEDEF_TYPE_START

       // DQ (2/20/2018): Adding support to build typedef type from template instantiation
          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = NULL);

HEADER_TYPEDEF_TYPE_END


HEADER_TYPE_INT_TYPE_START
       // DQ (12/26/2005): C++ allows initialization in-class of static const, but it is not very portable yet.
       // static const int maxBitLength = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;
          static const int maxBitLength; // = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;

       // DQ (12/26/2005): Supporting function for traverseMemoryPool
       // where static IR nodes (only isn soem SgType IR nodes) are
       // present and must be traversed using specially generated code.
       // virtual void executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor);
HEADER_TYPE_INT_TYPE_END

HEADER_TYPE_COMPLEX_TYPE_START
      //! function returns example of type
       // static $CLASSNAME* createType(SgType* base_type);
          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = NULL);
       // SKW (3/1/2011): Added these explicit declarations since we no longer build them automatically
          virtual SgExpression* get_type_kind () const $ROSE_OVERRIDE;
          virtual void set_type_kind ( SgExpression* type_kind ) $ROSE_OVERRIDE;
HEADER_TYPE_COMPLEX_TYPE_END

// SK(08/20/2015): SgTypeTuple implementation
HEADER_TYPE_TUPLE_START
    SgTypePtrList& get_types();
    const SgTypePtrList& get_types() const;

    void prepend_type(SgType *what);
    void append_type(SgType *what);

HEADER_TYPE_TUPLE_END


HEADER_POINTER_MEMBER_TYPE_START
       //! The API to this function has been changed to support returning a SgDeclarationStatement.
       // DQ (4/11/2019): This alllows it to support both the cases where a definition might not 
       // exist and the case of a pointer to member of a nonreal type.
       // The old functionality is represented in the get_class_definition_of() function.
          SgDeclarationStatement* get_class_declaration_of() const;

      //! \deprecated The class_of property has been replaced by the class_type property, an SgType
          SgClassDefinition* get_class_definition_of() const;

       // DQ (4/20/2019): Renamed these to make them more clear, since there are two locations for name qualification in a SgPointerMemberType.
       // DQ (4/18/2019): Added support for name qualification of type chains of SgPointerMemberType.
       // SgName get_qualified_name_prefix() const;
          SgName get_qualified_name_prefix_for_class_of() const;
          SgName get_qualified_name_prefix_for_base_type() const;

HEADER_POINTER_MEMBER_TYPE_END

HEADER_TYPE_STRING_TYPE_START
       // DQ (8/17/2010): Support for Fortran use of SgTypeString.
       // static $CLASSNAME* createType(SgExpression*, size_t length, SgExpression* optional_fortran_type_kind = NULL);
          static $CLASSNAME* createType(SgExpression*, SgExpression* optional_fortran_type_kind = NULL);

      //! Performs final initialization of data members (called by constructors)
          void post_construction_initialization() $ROSE_OVERRIDE;
HEADER_TYPE_STRING_TYPE_END

HEADER_TYPE_DEFAULT_TYPE_START

       // Generated a mangled name that accounts for the stored name internally.
       // SgName get_mangled (void) const;

      //! Default type creation to support intermediate types built during parsing (required for fortran only).
          static SgTypeDefault* createType ( const SgName & nameOfType );

HEADER_TYPE_DEFAULT_TYPE_END

HEADER_TYPE_LABEL_TYPE_START

       // Generated a mangled name that accounts for the stored name internally.
       // SgName get_mangled (void) const;

      //! Label type creation to support intermediate types built during parsing (required for fortran only).
          static SgTypeLabel* createType ( const SgName & nameOfType );

HEADER_TYPE_LABEL_TYPE_END


HEADER_DECL_TYPE_START

          void set_base_type(SgType* base_type);

HEADER_DECL_TYPE_END


HEADER_TYPEOF_TYPE_START

          static $CLASSNAME* createType(SgType* base_type, SgExpression* optional_fortran_type_kind = NULL);

          void set_base_type(SgType* base_type);

HEADER_TYPEOF_TYPE_END


HEADER_ARRAY_TYPE_START

       // DQ (3/22/2017): I would like to remove this function if possible.
       // DQ (3/22/2017): Added the get_name() function prototype directly so that 
       // it could be differentiated from where it is a virtual function.
          SgName get_name() const;

HEADER_ARRAY_TYPE_END

HEADER_ADA_ACCESS_TYPE_START

          SgName get_name() const;

HEADER_ADA_ACCESS_TYPE_END

HEADER_ADA_SUBTYPE_START

          SgName get_name() const;

HEADER_ADA_SUBTYPE_END

HEADER_ADA_FLOAT_TYPE_START

          SgName get_name() const;

HEADER_ADA_FLOAT_TYPE_END


// Rasmussen (2/19/2020): Added SgTypedFixed for Jovial. Don't really know what to do here.
HEADER_TYPE_FIXED_TYPE_START
      // SgName get_name() const;
HEADER_TYPE_FIXED_TYPE_END


// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

SOURCE_CONSTRUCTOR_BODY_START
  // JJW 10-26-2007 ensure that this object is not on the stack
     preventConstructionOnStack(this);

 //! now a call to the user defined intialization function
     post_construction_initialization();

SOURCE_CONSTRUCTOR_BODY_END


SOURCE_GET_MANGLED_START
#if 1
/*! Support for mangled names (for unparser)
    There are two different cases of source code for the get_mangled member function
    This one is used in all but the classes containing a base type
 */
// SgName $CLASSNAME::get_mangled ( SgUnparse_Info & info )
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (10/4/2010): Modified to provide Fortran support (type_kind is a data member used for Fortran only, it is always NULL for other languages)
  // Rasmussen (3/6/2020): Now type_kind is also used for Jovial.
     SgName name = "MANGLED_ID_STRING";
     if (get_type_kind() != NULL)
        {
       // name += get_type_kind()->get_mangled();
       // name += SageInterface::generateUniqueName(get_type_kind(),false);
          SgValueExp* value = isSgValueExp(get_type_kind());
          if (value != NULL)
             {
            // name += string("_") + StringUtility::numberToString(value->get_value());
               name += string("_kind") + value->get_constant_folded_value_as_string();
             }
            else
             {
            // DQ (9/6/2016): This is where the name of the class is used and where it can collide with a 
            // complex type (SgTypeComplex) if the class name is "_Complex".  This is why we need something
            // other than the name to be used here.  Unclear if a single prefix is sufficent or if we need 
            // a different prefix for each type of named type.  It come down to is there can be multiple 
            // types with the same name, and there is only a choice of SgNamedTypes: SgClassType, SgTypedefType, 
            // and SgEnumType.  These can't have the same name, so we need not have a unity prefix for each type.
            // I think the issue is that MANGLED_ID_STRING is not defined for any of the SgNameType IR nodes.
#if 0
               printf ("In get_mangled(void): (get_type_kind() != NULL): this = %p = %s MANGLED ID STRING = %s \n",this,this->class_name().c_str(),"MANGLED_ID_STRING");
#endif
               name += SageInterface::generateUniqueName(get_type_kind(),false);
             }
        }

  // Rasmussen (3/6/2020): This is a hack but I can't get SgTypeFixed::get_mangled() to work
  // REMOVE_ME please!
     if (isSgTypeFixed(this))
        {
          const SgTypeFixed* fixed_type = isSgTypeFixed(this);
          if (fixed_type->get_scale() != NULL)
             {
               SgValueExp* value = isSgValueExp(fixed_type->get_scale());
               if (value != NULL)
                  {
                    name += string("_") + value->get_constant_folded_value_as_string();
                  }
             }
          if (fixed_type->get_fraction() != NULL)
             {
               SgValueExp* value = isSgValueExp(fixed_type->get_fraction());
               if (value != NULL)
                  {
                    name += string("_") + value->get_constant_folded_value_as_string();
                  }
             }
        }

#if 0
     printf("Leaving get_mangled(void): this = %p = %s mangled name = %s \n",this,this->class_name().c_str(),name.str());
#endif

     return name;
   }
#endif
SOURCE_GET_MANGLED_END

SOURCE_GET_MANGLED_BASE_TYPE_START

/*! Returns a mangled name representation of types with base types
 *  (e.g., pointer, reference).
 */
SgName
$CLASSNAME::get_mangled (void) const
   {
  // DQ (10/23/2015): Note that these functions are called in the AST construction and that might not be
  // required, plus it might be a performance issue as well. I didn't expect to see this while debugging
  // a different subject.  In general, I think we would like to push the generation of mangled names to 
  // the end of the AST processing; unless it is required for computing symble table keys (which is the 
  // likely usage within the AST construction, if so then I guess we have to allow these functions to be
  // called in the frontend AST construction).

     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_mangled(): base_type = %p = %s \n",base_type,base_type->class_name().c_str());
#endif

     SgName base_name = base_type->get_mangled();

#if 0
     printf ("DONE: In $CLASSNAME::get_mangled(): base_type = %p = %s base_name = %s \n",base_type,base_type->class_name().c_str(),base_name.str());
#endif

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In $CLASSNAME::get_mangled(), empty base type name found \n");
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << base_name.str () // base type
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag

  // printf ("LEAVING: In $CLASSNAME::get_mangled(): base_type = %p = %s mangled_name = %s \n",base_type,base_type->class_name().c_str(),mangled_name.str());

     return mangled_name;
   }

#if 0
// Old version of function
SgName
$CLASSNAME::get_mangled ( SgUnparse_Info & info )
   {
     SgName tmp("MANGLED_ID_STRING");

  // DQ (3/15/2005): Should be be using a qualified name???

     ROSE_ASSERT(get_base_type() != NULL);
     ROSE_ASSERT(get_base_type()->get_mangled(info).get_length() > 0);
     tmp << get_base_type()->get_mangled(info).str();

#if 0
     printf ("###########  In $CLASSNAME::get_mangled(): tmp = %s (get_base_type() = %s is a %s) ########## \n",
          tmp.str(),get_base_type()->get_mangled(info).str(),get_base_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif

SOURCE_GET_MANGLED_BASE_TYPE_END


SOURCE_POINTER_MEMBER_GET_MANGLED_START
// RV (2/3/2006): Updated this routine to use the mangling of the parent type.
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // Generate a pointer type _without_ the class name in it
     string base_str = SgPointerType::get_mangled ().getString ();

  // Mangle the class name
     const SgType* cls_type = get_class_type ();
     ROSE_ASSERT (cls_type);
     string cls_name = cls_type->get_mangled ().getString ();

  // Now embed the fully qualified class name in it
     string mangled_name (base_str);
     const string ptr_begin_tag ("__Pb__");
     string::size_type pos_begin = mangled_name.find (ptr_begin_tag);
     mangled_name.replace (pos_begin, ptr_begin_tag.size (), "__PMb__" + cls_name);

     return SgName (mangled_name.c_str ());
   }

#if 0
// Old code
SgName
$CLASSNAME::get_mangled ( SgUnparse_Info& info )
   {
     SgName tmp("M");
     int cnt = 0;
     ROSE_ASSERT(get_class_of() != NULL);
     tmp << get_class_of()->get_mangled_qualified_name(cnt).str();

#if 0
     printf ("###########  In $CLASSNAME::get_mangled(): tmp = %s (get_base_type() = %s is a %s) ########## \n",
          tmp.str(),get_class_of()->get_mangled_qualified_name(cnt).str(),get_class_of()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif

SOURCE_POINTER_MEMBER_GET_MANGLED_END


SOURCE_GET_MANGLED_STRING_TYPE_START

/*! Returns a mangled name representation of strings types with the size of the string
 *  (e.g., literal, *, or integer expression).
 */
SgName
SgTypeString::get_mangled (void) const
   {
#if 1

    // DXN (08/01/2011): add type kind to the mangled name
     SgName mangled_name;
     SgValueExp* lenValExp = isSgValueExp(p_lengthExpression);
     SgName mangled_length_name = lenValExp? lenValExp->get_constant_folded_value_as_string():
                                             SageInterface::generateUniqueName(p_lengthExpression,false);
     if (p_type_kind)
        {        
          SgValueExp* kindValExp = isSgValueExp(p_type_kind);
          SgName mangled_kind_name = kindValExp? kindValExp->get_constant_folded_value_as_string(): 
                                            SageInterface::generateUniqueName(p_type_kind,false);
          mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << mangled_length_name.str ()  // length
                  << "__" << mangled_kind_name.str() // kind
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
        }
     else
        {
          mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << mangled_length_name.str ()  // length
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
        }

     return mangled_name;

#else
  // DQ (10/5/2010): Note that we do not include the type_kind data member in the mangled name,
  // but for Fortran this value must always be "1" and the data member is only relevant for Fortran.

     ROSE_ASSERT(this != NULL);

  // DQ (10/5/2010): This is now always false (this fails for test2007_15.f90)
  // ROSE_ASSERT(this->p_definedUsingScalarLength == false);

     SgName mangled_length_name;

  // Note that a better implementation would separate out the mangling of scalar valued length expressions.
     SgValueExp* valueExpression = isSgValueExp(p_lengthExpression);
#if 0
     if (valueExpression != NULL)
        {
          printf ("In SgTypeString::get_mangled(): separate out case of where lengthExpression is a SgValueExp. \n");
        }
#endif
#if 0
     if (this->p_definedUsingScalarLength == true)
        {
            mangled_length_name = Rose::StringUtility::numberToString(this->p_lengthScalar);
        }
       else
        {
          ROSE_ASSERT(this->p_lengthExpression != NULL);
       // mangled_length_name = this->p_lengthExpression->get_mangled_name();
          mangled_length_name = SageInterface::generateUniqueName(p_lengthExpression,false);
        }
#else
     ROSE_ASSERT(this->p_lengthExpression != NULL);
  // mangled_length_name = this->p_lengthExpression->get_mangled_name();
     if (valueExpression != NULL)
        {
          mangled_length_name = valueExpression->get_constant_folded_value_as_string();
        }
       else
        {
          mangled_length_name = SageInterface::generateUniqueName(p_lengthExpression,false);
        }
#endif

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << mangled_length_name.str () // length
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag

  // printf ("LEAVING: In SgTypeString::get_mangled(): definedUsingScalarLength = %s lengthScalar = %" PRIuPTR " lengthExpression = %p mangled_name = %s \n",p_definedUsingScalarLength ? "true" : "false",p_lengthScalar,p_lengthExpression,mangled_name.str());

     return mangled_name;
#endif
   }

SOURCE_GET_MANGLED_STRING_TYPE_END

// Rasmussen (3/6/2020): Added get_mangled for SgTypedFixed (primitive type in Jovial)
SOURCE_GET_MANGLED_TYPE_FIXED_START

SgName
SgTypeFixed::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name = "MANGLED_ID_STRING";

  // Note additional name mangling is being done here because I couldn't figure out how to add
  // it to get_mangled directly because the class is a ROSETTA macro and doesn't have access to
  // the scale or fraction information.
     if (get_scale() != NULL)
        {
           SgValueExp* value = isSgValueExp(get_scale());
           if (value != NULL)
              {
                 mangled_name += string("_") + value->get_constant_folded_value_as_string();
                 std::cout << "--> added scale " << mangled_name << std::endl;
              }
        }
     if (get_fraction() != NULL)
        {
           SgValueExp* value = isSgValueExp(get_fraction());
           if (value != NULL)
              {
                 mangled_name += string("_") + value->get_constant_folded_value_as_string();
                 std::cout << "--> added fraction " << mangled_name << std::endl;
              }
        }

#if 1
     printf ("LEAVING: In SgTypeFixed::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

SOURCE_GET_MANGLED_TYPE_FIXED_END

SOURCE_CONSTRUCTOR_START
#if 0
/*! this is the generated constructor */
$CLASSNAME::$CLASSNAME ( INITIALIZER_LIST_SOURCE )
   BASE_CLASS_CONSTRUCTOR_CALL
   {
     p_field_size = field_size;
 //! now a call to the user defined intialization function
     post_construction_initialization();
   }
#endif
SOURCE_CONSTRUCTOR_END

SOURCE_CONSTRUCTOR_WITH_BASECLASS_TAKING_PARAMETER_START
#if 0
/*! this is the generated constructor */
$CLASSNAME::$CLASSNAME ( SgDeclarationStatement* declaration )
   :BASECLASS(declaration)
   {
  //! now a call to the user defined intialization function
     post_construction_initialization();
   }
#endif
SOURCE_CONSTRUCTOR_WITH_BASECLASS_TAKING_PARAMETER_END

SOURCE_DATA_ACCESS_FUNCTIONS_START
#if 0
DATA_TYPE
$CLASSNAME::get_DATA() const
   {
     return p_DATA;
   }

void $CLASSNAME::set_DATA ( DATA_TYPE )
   {
     p_DATA = DATA;
   }
#endif
SOURCE_DATA_ACCESS_FUNCTIONS_END


SOURCE_GET_NAME_START
//! Return the name of the type
SgName
$CLASSNAME::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }
SOURCE_GET_NAME_END


SOURCE_TYPEDEF_GET_BASE_TYPE_START
SgType*
$CLASSNAME::get_base_type() const
   {
     return (get_declaration()) ? isSgTypedefDeclaration(get_declaration())->get_base_type() : (SgType*)0L;
   }
SOURCE_TYPEDEF_GET_BASE_TYPE_END

SOURCE_GET_BASE_TYPE_START
SgType*
$CLASSNAME::get_base_type() const
   {
     return p_base_type;
   }
SOURCE_GET_BASE_TYPE_END


SOURCE_SET_BASE_TYPE_START
void
$CLASSNAME::set_base_type(SgType* new_val)
   {
     p_base_type = new_val;
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(p_base_type)
          p_base_type->set_parent(this);
#endif
   }
SOURCE_SET_BASE_TYPE_END


// ########################################################
// ########################################################
//           TYPE SPECIFIC FUNCTION DEFINITIONS
// ########################################################
// ########################################################

SOURCE_MAIN_TYPE_START

//! SgType default constructor (initializes all local variables)
SgType::SgType()
   : p_substitutedForTemplateParam(false),
     p_ref_to(NULL),
     p_ptr_to(NULL),
     p_modifiers(NULL),
     p_typedefs(NULL),
     p_rvalue_ref_to(NULL),
     p_decltype_ref_to(NULL),
     p_typeof_ref_to(NULL),
  // DQ (10/3/2010): Readded to the SgType since it is used uniformally within Fortran types.
  // DQ (12/1/2007): This has been moved to the SgModifierType
     p_type_kind(NULL),
     p_attributeMechanism(NULL)
   {
     ROSE_ASSERT(p_ref_to == NULL);
     ROSE_ASSERT(p_ptr_to == NULL);
     ROSE_ASSERT(p_modifiers == NULL);

     p_typedefs = new SgTypedefSeq();

     ROSE_ASSERT(p_typedefs != NULL);
     ROSE_ASSERT(p_rvalue_ref_to == NULL);
     ROSE_ASSERT(p_decltype_ref_to == NULL);
     ROSE_ASSERT(p_typeof_ref_to == NULL);

  // FMZ (2/6/2009): Added a flag for CoArray
     p_isCoArray = false;

  // DQ (12/1/2007): This has been moved to the SgModifierType
  // ROSE_ASSERT(p_type_kind == NULL);

  // DQ (1/25/2007): Let's try this again!
  // DQ (6/25/2006): Commented out to allow File I/O to work, I don't understand why it is required!
  // DQ (5/11/2006): Added to avoid NULL pointer
     p_typedefs->set_parent(this);
   }


SgType::SgType(const SgType & X)
   : p_substitutedForTemplateParam(X.p_substitutedForTemplateParam),
     p_ref_to(X.p_ref_to),
     p_ptr_to(X.p_ptr_to),
     p_modifiers(X.p_modifiers),
     p_typedefs(X.p_typedefs),
     p_rvalue_ref_to(X.p_rvalue_ref_to),
     p_decltype_ref_to(X.p_decltype_ref_to),
     p_typeof_ref_to(X.p_typeof_ref_to),
  // DQ (10/3/2010): Readded to the SgType since it is used uniformally within Fortran types.
  // DQ (12/1/2007): This has been moved to the SgModifierType
     p_type_kind(X.p_type_kind),
     p_attributeMechanism(X.p_attributeMechanism)
   {
  // DQ (10/17/2007): This copy constructor is built to support the AST copy mechanism where for
  // some declarations that generate named types, the types are copied. and fixed up in a later
  // phase (e.g. SgClassDeclaration::fixupCopy()).

  // I think if we copy X then we want to assume that it has these values, but it might
  // be acceptable if it didn't, but then a more complex copy would be required.

#if 0
  // DQ (10/17/2007) Commented out (see copytest2007_14.C).
     ROSE_ASSERT(p_ref_to == NULL);
     ROSE_ASSERT(p_ptr_to == NULL);
     ROSE_ASSERT(p_modifiers == NULL);
     ROSE_ASSERT(p_rvalue_ref_to == NULL);
     ROSE_ASSERT(p_decltype_ref_to == NULL);
     ROSE_ASSERT(p_typeof_ref_to == NULL);
  // DQ (12/1/2007): This has been moved to the SgModifierType
  // ROSE_ASSERT(p_type_kind == NULL);
#endif

  // FMZ (2/6/2009): Added a flag for CoArray
     p_isCoArray = false;

     p_typedefs = new SgTypedefSeq();
     ROSE_ASSERT(p_typedefs != NULL);
     p_typedefs->set_parent(this);
   }


#if 0
SgType::~SgType()
   {
     delete p_modifiers;
     delete p_typedefs;
   }
#endif

// SgName $CLASSNAME::get_mangled(SgUnparse_Info& info)
SgName
SgType::get_mangled(void) const
   {
  // This should be an error, I think!
     printf ("ERROR: base calss get_mangled functions should not be called! \n");
     ROSE_ABORT();

     return "";
   }

#if 0
// DQ (3/2/2003): Implement get_parent from SgNode
SgNode*
SgType::get_parent() const
   {
     ROSE_ASSERT(this != NULL);
     return NULL;   // this is the original sage 2 code (but I think it should return p_parent)
  // return (SgType*) p_parent;
   }
#endif

#if 0
//! virtual functions define to return false
//! (will be overwritten on only a few of the derived classes)
bool SgType::isConst() const       { return false; }
bool SgType::isVolatile() const    { return false; }
bool SgType::isRestrict() const    { return false; }
bool SgType::isUPC_Shared() const  { return false; }
bool SgType::isUPC_Strict() const  { return false; }
bool SgType::isUPC_Relaxed() const { return false; }
#endif

#if 0
bool SgType::isExtern() const    { return false; }
bool SgType::isTypedef() const   { return false; }
bool SgType::isVirtual() const   { return false; }
bool SgType::isProtected() const { return false; }
bool SgType::isPrivate() const   { return false; }
bool SgType::isPublic() const    { return false; }
bool SgType::isAuto() const      { return false; }
#endif

// bool SgType::isGlobal() const    { return false; }
// bool SgType::isSync() const      { return false; }

#if 0
// These are unimplemented within SAGE 2
bool
SgType::isLong() const
   { return false; }

bool
SgType::isShort() const
   { return false; }
#endif

#if 0
// This codes was part of an experiment to distinguish struct tag { int x; } X; from struct tag X;
// It turns out that the declaration of the tag in this case in placed into the EDG orphan list
// as a type and that we don't require this mechanism (thought we might in the future so for now
// it is just commented out.
bool
SgType::isFirstDeclaration() const
   { return (p_useWithinDeclaration & e_first_declaration); }

void
SgType::setFirstDeclaration()
   { p_useWithinDeclaration |= e_first_declaration; }

void
SgType::unsetFirstDeclaration()
   { p_useWithinDeclaration &= ~e_first_declaration; }

bool
SgType::isAutonomousTagDeclaration() const
   { return (p_useWithinDeclaration & e_autonomous_tag_declaration); }

void
SgType::setAutonomousTagDeclaration()
   { p_useWithinDeclaration |= e_autonomous_tag_declaration; }

void
SgType::unsetAutonomousTagDeclaration()
   { p_useWithinDeclaration &= ~e_autonomous_tag_declaration; }
#endif

#if 0
// DQ (7/26/2010): Now we finally need this function!
SgModifierType*
SgType::matchModifiers (unsigned int f)
   {
#if 0
  // DQ (7/26/2010): Not clear if we want this function to return a reference to itself.
     ROSE_ASSERT (p_modifiers == NULL);

     if (p_modifiers)
        {
          return p_modifiers->match(this, f);
        }
       else
        {
          return (p_modifiers = new SgModifierNodes())->match(this, f);
        }
#else

#endif
   }
#endif

bool
SgType::isIntegerType() const
   {
     const $CLASSNAME* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
        {
          t = ((SgTypedefType *) t)->get_base_type();
          ROSE_ASSERT(t != NULL);
        }

     switch (variant())
        {
          case T_CHAR:
          case T_SIGNED_CHAR:
          case T_UNSIGNED_CHAR:
          case T_SHORT:
          case T_SIGNED_SHORT:
          case T_UNSIGNED_SHORT:
          case T_INT:
          case T_SIGNED_INT:
          case T_UNSIGNED_INT:
          case T_LONG:
          case T_SIGNED_LONG:
          case T_UNSIGNED_LONG:
          case T_WCHAR:

       // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
          case T_CHAR16:
          case T_CHAR32:

          case T_LONG_LONG:
          case T_SIGNED_LONG_LONG:
          case T_UNSIGNED_LONG_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_SIGNED_128BIT_INTEGER:
          case T_UNSIGNED_128BIT_INTEGER:
          case T_BOOL:
               return true; // 1
               break;

          default:
               return false; // 0
        }
   }

bool
SgType::isFloatType() const
   {
     const SgType* t = this;
     ROSE_ASSERT(t != NULL);

     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     switch (t->variant())
        {
          case T_FLOAT :

       // DQ (4/20/2019): Added additional floating point types to be classified as (isFloatType() == true) by this function.
          case T_FLOAT80 :
          case T_FLOAT128 :

          case T_DOUBLE:
          case T_LONG_DOUBLE:
               return 1;
               break;

          default:
               return 0;
        }
   }

bool
SgType::isUnsignedType() const
   {
     switch (variant())
        {
          case T_UNSIGNED_CHAR:
          case T_UNSIGNED_SHORT:
          case T_UNSIGNED_INT:
          case T_UNSIGNED_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_UNSIGNED_LONG_LONG:
          case T_UNSIGNED_128BIT_INTEGER:
               return 1;
               break;

          default:
               return 0;
        }
   }


bool
SgType::isPrimativeType() const
   {
  // DQ (4/20/2019): Added query for primative types so that they can be easily skipped in name qualification.
  // Note that a typedef type is not a primative type, even if it resolves to such a type (because it can be name qualified).
  // A typedef type may be otherwise type equvalent to a primative type.

     switch (variant())
        {
       // The list of types from isIntegerType() function
          case T_CHAR:
          case T_SIGNED_CHAR:
          case T_UNSIGNED_CHAR:
          case T_SHORT:
          case T_SIGNED_SHORT:
          case T_UNSIGNED_SHORT:
          case T_INT:
          case T_SIGNED_INT:
          case T_UNSIGNED_INT:
          case T_LONG:
          case T_SIGNED_LONG:
          case T_UNSIGNED_LONG:
          case T_WCHAR:

       // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
          case T_CHAR16:
          case T_CHAR32:

          case T_LONG_LONG:
          case T_SIGNED_LONG_LONG:
          case T_UNSIGNED_LONG_LONG:
       // DQ (3/24/2014): Added support for 128 bit integers.
          case T_SIGNED_128BIT_INTEGER:
          case T_UNSIGNED_128BIT_INTEGER:
          case T_BOOL:

       // float types
          case T_FLOAT :
          case T_FLOAT80 :
          case T_FLOAT128 :
          case T_DOUBLE:
          case T_LONG_DOUBLE:

       // Other kinds of float types.
          case T_COMPLEX:
          case T_IMAGINARY:

       // Other types
          case T_VOID:
          case T_LABEL:
          case T_NULLPTR:
          case T_DECLTYPE:
          case T_STRING:

               return true; // 1
               break;

          default:
               return false; // 0
        }
   }



SgType*
SgType::integer_promotion(SgType * t1, SgType * t2)
   {
     if(!t1) return t2;
     if(!t2) return t1;

     if (t1->variant() == T_UNSIGNED_LONG || t2->variant() == T_UNSIGNED_LONG)
          return SgTypeUnsignedLong::createType();

  // This should only be if long can hold unsigned int, not always true!!
     if (t1->variant() == T_UNSIGNED_INT || t2->variant() == T_UNSIGNED_INT)
          return SgTypeLong::createType();

     if (t1->isUnsignedType())
          return t1;
       else
          if (t2->isUnsignedType() )
               return t2;
            else
               return SgTypeInt::createType();
   }

SgType*
SgType::float_promotion( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2;
     if(!t2) return t1;

     if (t1->variant() == T_LONG_DOUBLE)
          return t1;
       else
          if (t2->variant() == T_LONG_DOUBLE)
               return t2;
            else
               if (t1->variant() == T_DOUBLE)
                    return t1;
                 else
                    if (t2->variant() == T_DOUBLE)
                         return t2;
                      else
                         return t1;
   }

#if 0
// DQ (4/5/2004): Removed since it is not used anywhere!
SgType*
SgType::rmModifier ( SgType* t1, int which )
   {
     $CLASSNAME* tmp_type = t1;

     ROSE_ASSERT(t1 != NULL);

     if(t1->variant()==T_MODIFIER)
        {
          SgModifierType *mod = (SgModifierType *) t1;
          ROSE_ASSERT(mod != NULL);

          SgType *btype = mod->get_base_type();

          int modval = mod->get_bitfield();

          if(mod->isSync() && (which & e_sync))
               modval &= ~SgModifierType::m_sync;

          if(mod->isGlobal() && (which & e_global))
               modval &= ~SgModifierType::m_global;

          if(mod->isConst() && (which & e_const))
               modval &= ~SgModifierType::m_const;

          tmp_type = (modval) ? SgModifierType::createType(btype,modval) : btype;
        }

     return tmp_type;
   }
#endif

#if 0
// DQ (4/5/2004): Removed since it is not used anywhere!
SgType*
SgType::addModifier(SgType *t1, int which)
   {
     $CLASSNAME* tmp_type = t1;
     $CLASSNAME* btype;
     int modval;

     ROSE_ASSERT(t1 != NULL);

     if(t1->variant()==T_MODIFIER)
        {
          SgModifierType *mod=(SgModifierType *) t1;
          btype=mod->get_base_type();
          modval=mod->get_bitfield();
        }
       else
        {
          btype=t1;
          modval=0;
        }

     if(which & e_sync)   modval |= SgModifierType::m_sync;
     if(which & e_global) modval |= SgModifierType::m_global;
     if(which & e_const)  modval |= SgModifierType::m_const;

     tmp_type = SgModifierType::createType(btype,modval);

     return tmp_type;
   }
#endif

SgType*
SgType::arithmetic_conversions ( SgType* t1, SgType* t2 )
   {
     if(!t1) return t2;
     if(!t2) return t1;

  // DQ (4/5/2004): Removed since it is the only use of rmModifier and e_sync is not used anywhere!
  // if (isSgModifierType(t1)) t1 = rmModifier(t1,e_sync);
  // if (isSgModifierType(t2)) t2 = rmModifier(t2,e_sync);

     if (t1->isFloatType() && t2->isIntegerType())
          return t1;

     if (t2->isFloatType() && t1->isIntegerType())
          return t2;

     if (t1->isIntegerType())
          return integer_promotion(t1,t2);
       else
          return float_promotion(t1,t2);
   }

SgType*
SgType::dereference()
   {
  // This function does not recursively decend into types, so it should not use the lower
  // level SgType::stripType() member function.

     SgType* t = this;
     ROSE_ASSERT(t != NULL);
     while (t->variant() == T_TYPEDEF)
          t = ((SgTypedefType *) t)->get_base_type();

     if (t->variant() == T_POINTER)
          return ((SgPointerType *) t)->get_base_type();
       else
          if (t->variant() == T_REFERENCE)
               return ((SgReferenceType *) t)->get_base_type();
            else
               if(t->variant() == T_ARRAY)
                    return ((SgArrayType *) t)->get_base_type();
                 else
                    return (SgType*)t;
   }

SgType*
SgType::stripTypedefsAndModifiers() const
   {
  // DQ (6/30/2005): This function answers the question of what type is this? It recursively
  // strips away typedefs until we reach something not typedefeds, thus we stop at any pointer
  // or references (but not modifiers).
#if 0
     SgType *returnType = const_cast<SgType*>(this);
     ROSE_ASSERT(returnType != NULL);

     SgTypedefType* typedefType   = isSgTypedefType(returnType);
     SgModifierType* modifierType = isSgModifierType(returnType);
     while (typedefType != NULL || modifierType != NULL)
  // while (isSgTypedefType(returnType) != NULL || isSgModifierType(returnType) != NULL)
        {
          if (typedefType != NULL)
             {
               returnType = typedefType->get_base_type();
             }
          if (modifierType != NULL)
             {
               returnType = modifierType->get_base_type();
             }

       // reset the typedefType and modifierType variables
          typedefType  = isSgTypedefType(returnType);
          modifierType = isSgModifierType(returnType);
        }

     ROSE_ASSERT (returnType != NULL);

     return returnType;
#else
  // DQ (10/11/2007): Modified this function to use SgType::stripType().
  // This uses a subset of the possible or'd values available with SgType::stripType()
     return stripType(STRIP_MODIFIER_TYPE | STRIP_TYPEDEF_TYPE);
#endif
   }

SgType*
SgType::findBaseType() const
   {
#if 0
// Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;


     while (true)
	{


	  if ( modType = isSgModifierType(currentType) )
	     {
         	 currentType = modType->get_base_type();
	     }
	  else if ( (refType = isSgReferenceType(currentType)) )
	     {
	       currentType = refType->get_base_type();
	     }
	  else if ( (pointType = isSgPointerType(currentType)) )
	     {
	       currentType = pointType->get_base_type();
	     }
	  else if ( (arrayType = isSgArrayType(currentType)) )
	     {
	       currentType = arrayType->get_base_type();
	     }
	  else if ( (typedefType = isSgTypedefType(currentType)) )
	     {
	    // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()

	       currentType = typedefType->get_base_type();
	     }
	  else {
	    // Exit the while(true){} loop!
	       break;
	  }

	}
#else
  // This uses the default value for SgType::stripType(), namely
  // (bit_array == STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE)
     return stripType();
#endif
   }

#define DEBUG_SGTYPE_STRIPTYPE 0
#define DEBUG_SGTYPE_STRIPTYPE_MORE 0

SgType*
SgType::stripType(unsigned char bit_array) const
   {
  // This function forms the low level support for both SgType::findBaseType()
  // and SgType::stripTypedefsAndModifiers().  It takes a default valued
  // bit_array == (STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE | STRIP_POINTER_MEMBER_TYPE)
  // Alternatively any of these value may be ORed together to for other combinations.

  // Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SageInterface::detectCycleInType(currentType, "SgType::stripType");

#if DEBUG_SGTYPE_STRIPTYPE
     printf ("Inside of SgType::stripType(bit_array = %u): this = %p = %s \n",bit_array,currentType,currentType->class_name().c_str());
#endif

     SgModifierType*        modType     = NULL;
     SgPointerType*         pointType   = NULL;
     SgReferenceType*       refType     = NULL;
     SgRvalueReferenceType* rRefType    = NULL;
     SgArrayType*           arrayType   = NULL;
     SgTypedefType*         typedefType = NULL;

     SgPointerMemberType*   pointerMemberType = NULL;

     size_t counter = 0;
     while (true)
        {
#if DEBUG_SGTYPE_STRIPTYPE
          printf ("In loop of SgType::stripType(bit_array = %u): counter = %" PRIuPTR " this = %p = %s = %s \n",bit_array,counter,currentType,currentType->class_name().c_str(),currentType->unparseToString().c_str());
#endif
          if ( (bit_array & STRIP_MODIFIER_TYPE) && (modType = isSgModifierType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgModifierType \n");
#endif
               currentType = modType->get_base_type();
             }
          else if ( (bit_array & STRIP_REFERENCE_TYPE) &&  (refType = isSgReferenceType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgReferenceType \n");
#endif
               currentType = refType->get_base_type();
             }
          else if ( (bit_array & STRIP_RVALUE_REFERENCE_TYPE) &&  (rRefType = isSgRvalueReferenceType(currentType)) )
             {
#if 0
               printf ("In loop of SgType::stripType(): found SgRvalueReferenceType \n");
#endif
               currentType = rRefType->get_base_type();
             }
       // DQ (4/15/2019): I don't think this should apply to SgPointerMemberType (which maybe should not be derived from SgPointerType).
       // Is SgPointerMemberType a kind of type that should be something we should support in this stripType function?
       // else if ( (bit_array & STRIP_POINTER_TYPE) && (pointType = isSgPointerType(currentType)) )
          else if ( (bit_array & STRIP_POINTER_TYPE) && ((pointType = isSgPointerType(currentType)) && (isSgPointerMemberType(currentType) == NULL)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgPointerType (that is not SgPointerMemberType) \n");
#endif
            // DQ (4/15/2019): Added assertion.
               ROSE_ASSERT(pointType != NULL);

               currentType = pointType->get_base_type();
             }
          else if ( (bit_array & STRIP_POINTER_MEMBER_TYPE) && (pointerMemberType = isSgPointerMemberType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgPointerMemberType \n");
#endif
               currentType = pointerMemberType->get_base_type();
             }
          else if ( (bit_array & STRIP_ARRAY_TYPE) && (arrayType = isSgArrayType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgArrayType \n");
#endif
               currentType = arrayType->get_base_type();
             }
          else if ( (bit_array & STRIP_TYPEDEF_TYPE) && (typedefType = isSgTypedefType(currentType)) )
             {
#if DEBUG_SGTYPE_STRIPTYPE_MORE
               printf ("In loop of SgType::stripType(): found SgTypedefType: currentType = %p = %s typedefType->get_base_type() = %p = %s \n",
                    currentType,currentType->class_name().c_str(),typedefType->get_base_type(),typedefType->get_base_type()->class_name().c_str());
#endif
            // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
               currentType = typedefType->get_base_type();
             }
            else
             {
            // Exit the while(true){} loop!
               ROSE_ASSERT(currentType != NULL);
#if DEBUG_SGTYPE_STRIPTYPE
               printf ("In loop of SgType::stripType(): exiting loop: currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
               break;
             }

       // DQ (7/4/2013): This should be a reasonable limit.
          if (counter >= 80)
             {
               printf ("In loop of SgType::stripType(bit_array = %u): counter = %" PRIuPTR " currentType = %p = %s = %s\n",bit_array,counter,currentType,currentType->class_name().c_str(),currentType->unparseToString().c_str());
             }

          if (counter >= 100)
             {
            // Exit loop and return the currentType... 
               printf ("In loop of SgType::stripType(bit_array = %u): exiting loop using currentType (counter = %" PRIuPTR ") currentType = %p = %s \n",bit_array,counter,currentType,currentType->class_name().c_str());
#if 0
               break;
#endif
             }
          ROSE_ASSERT(counter < 100);

          counter++;
        }

     ROSE_ASSERT(currentType != NULL);

#if 0
     printf ("Leaving SgType::stripType(): currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif

     return currentType;
   }

#if 0
SgType*
SgType::stripType() const
   {
  // DQ (6/21/2005): strip type of all typedefs, modifiers, pointers, references, and array typing
     SgType* returnType = ($CLASSNAME*) this;
     while ( (isSgTypedefType(returnType) != NULL) ||
             (isSgPointerType(returnType) != NULL) ||
             (isSgModifierType(returnType) != NULL) ||
             (isSgReferenceType(returnType) != NULL) ||
             (isSgArrayType(returnType) != NULL) )
        {
          returnType = returnType->findBaseType();
          ROSE_ASSERT (returnType != NULL);
       // printf ("In stripType(): returnType = %s hidden behind this = %s \n",returnType->sage_class_name(),sage_class_name());
        }

     return returnType;
   }
#endif


SgName
SgType::mangledNameSupport(SgName & fname, SgUnparse_Info & info)
   {
     ROSE_ASSERT(this != NULL);

  // DQ (4/27/2005): This protected function refactors code located into two places into a single implementation!
     SgName rtmp;

  // This only makes sense to call from either the SgFunctionType or the SgMemberFunctionType
     ROSE_ASSERT(isSgFunctionType(this) != NULL || isSgMemberFunctionType(this) != NULL);

     int len = fname.getString().size();
     std::string opstr  = "operator";
     std::string newstr = "new";
     std::string delstr = "delete";
     unsigned int m = opstr.size();

  // printf ("In SgType::mangledNameSupport(): class_name = %s len = %d m = %d fname = %s \n",sage_class_name(),len,m,fname.str());

     if (len > 0 && fname.getString().substr(0, m) == opstr)
        {
          if (fname.getString()[m]==' ')
             {
            // DQ (4/27/2005): "m+2" should be "m+1"
               if (fname.getString().substr(m + 1, newstr.size()) == newstr)
                  {
                 // DQ (4/27/2005): Added support for array new
                    int parenStart = m+1+newstr.size();
                    if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                         rtmp << "__na";
                      else
                         rtmp << "__nw";
                  }
                 else
                  {
                 // DQ (4/27/2005): Added support for array delete
                    if (fname.getString().substr(m + 1, delstr.size()) == delstr)
                       {
                         int deleteStringLength = delstr.size();
                         int parenStart = m+1+deleteStringLength;
                         if (len > parenStart && fname.getString().substr(parenStart, 2) == "[]")
                              rtmp << "__da";
                           else
                              rtmp << "__dl";
                       }
                      else
                       {
                      // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                      // This is the only part that is dependent upon either the SgFunctionType or SgMemberFunctionType.
                         SgFunctionType *functionType = isSgFunctionType(this);
                         ROSE_ASSERT(functionType != NULL);
                         ROSE_ASSERT(functionType->get_return_type() != NULL);

                         rtmp << "__op" << functionType->get_return_type()->get_mangled().str();
                       }
                  }
             }
            else
             {
            // real operator (suffix after the substring "operator ")

            // I think that this case could be used to handle "operator new", "operator new[]",
            // "operator delete", and "operator delete[]".

               SgName opname=&(fname.str()[m]);

               if (opname == SgName("->"))     rtmp << "__rf";
               else if (opname==SgName("->*")) rtmp << "__rm";
               else if (opname==SgName("=="))  rtmp << "__eq";
               else if (opname==SgName("<"))   rtmp << "__lt";
               else if (opname==SgName(">"))   rtmp << "__gt";
               else if (opname==SgName("!="))  rtmp << "__ne";
               else if (opname==SgName("<="))  rtmp << "__le";
               else if (opname==SgName(">="))  rtmp << "__ge";
               else if (opname==SgName("+"))   rtmp << "__pl";
               else if (opname==SgName("-"))   rtmp << "__mi";
               else if (opname==SgName("*"))   rtmp << "__ml";
               else if (opname==SgName("/"))   rtmp << "__dv";
               else if (opname==SgName("%"))   rtmp << "__md";
               else if (opname==SgName("&&"))  rtmp << "__aa";
               else if (opname==SgName("!"))   rtmp << "__nt";
               else if (opname==SgName("||"))  rtmp << "__oo";
               else if (opname==SgName("^"))   rtmp << "__er";
               else if (opname==SgName("&"))   rtmp << "__ad";
               else if (opname==SgName("|"))   rtmp << "__or";
               else if (opname==SgName(","))   rtmp << "__cm";
               else if (opname==SgName("<<"))  rtmp << "__ls";
               else if (opname==SgName(">>"))  rtmp << "__rs";
               else if (opname==SgName("--"))  rtmp << "__mm";
               else if (opname==SgName("++"))  rtmp << "__pp";
               else if (opname==SgName("~"))   rtmp << "__co";
               else if (opname==SgName("="))   rtmp << "__as";
               else if (opname==SgName("+="))  rtmp << "__apl";
               else if (opname==SgName("-="))  rtmp << "__ami";
               else if (opname==SgName("&="))  rtmp << "__aad";
               else if (opname==SgName("|="))  rtmp << "__aor";
               else if (opname==SgName("*="))  rtmp << "__amu";
               else if (opname==SgName("/="))  rtmp << "__adv";
               else if (opname==SgName("%="))  rtmp << "__amd";
               else if (opname==SgName("^="))  rtmp << "__aer";
               else if (opname==SgName("<<=")) rtmp << "__als";
               else if (opname==SgName(">>=")) rtmp << "__ars";
               else if (opname==SgName("()"))  rtmp << "__cl";
               else if (opname==SgName("[]"))  rtmp << "__xi";
               else
                  {
                 // printf ("In SgType::mangledNameSupport(): This case should never be reached (fname = %s) \n",fname.str());
                 // ROSE_ASSERT(false);

                 // DQ (1/8/2006): This is the case of a name that just happends to start with
                 // the work "operator" (e.g. operator_takes_lvalue_operand, in test2005_198.C)
                 // the mangle form is just the unmodified function name.
                    rtmp = fname;
                  }
             }
        }
       else
          rtmp << fname.str();

     return rtmp;
   }

bool
SgType::handledUsingLocalTable(SgType* t)
   {
  // Not all types can use the global type table, since during construction of the AST the
  // scopes may not be fully defined yet.  The local type table can be merged into the
  // global type table as a post-processing step.

     bool returnValue = false;

  // DQ (9/3/2012): I think this should be modified to include SgTemplateType as well.
     if (isSgEnumType(t) != NULL || isSgClassType(t) != NULL || isSgTypedefType(t) != NULL)
        {
          returnValue = true;
        }

  // DQ (9/4/2012): I have made SgTemplateType be stored in the local type table.
  // DQ (9/3/2012): I think this should be modified to include SgTemplateType as well.
     SgTemplateType* templateType = isSgTemplateType(t);
     SgNonrealType* nonrealType = isSgNonrealType(t);
     if (templateType != NULL || nonrealType != NULL)
        {
       // printf ("WARNING: In SgType::handledUsingLocalTable(): I think that SgTemplateType should be handled out of the local type table! templateType = %p = %s \n",templateType,templateType->get_name().str());
          returnValue = true;
        }

     return returnValue;
   }

// Kitware 2013/03/25
// This is a workaround for the lack of EDG on Windows.
// Once that problem is resolved, this include file can go away.
#ifdef USE_FAKE_EDG
  #include "fake_EDG.h"
#endif

// Liao 10/29/2010
// My understanding of this code (may not be accurate):
//  This function was designed to work with C/C++ and Fortran frontends to generate AST.
//  So code has to be conditionized with proper #ifdef ..#endf around the use of the variable or stack.
//  
//  Now we allow users to build types during AST transformation. This function will be called and scope can be NULL
//  Neither the stack or global variable in frontends are used in this situation either.
//  But this is perfectly legal. 
SgScopeStatement*
SgType::getCurrentScope()
   {
  // This function is used to provide the global type table support with a common
  // mechanism to know the scope when generating types.  So types have to know their
  // declaration's scope and it is taken from the current scope that is kept track
  // of using either of a few (two) mechanisms durring the construction of the AST
  // from the frontend.  The mechanism is language dependent, or always returning 
  // a NULL pointer (in the case of the AST Builder if the stack is not used, and we
  // are not using the EDG 3.3 connection to ROSE...).

  // Note that this function is an alternative to the specification of the scope directly
  // in the construction of each IR node.  Though I like the direct specification better,
  // such an approach would force us to change the ROSETTA generated API for a moderate
  // number of SgStatement IR nodes and it would likely break some user code.  So we need
  // to schedule this for a later date.  It should not be an issue for anyone using the 
  // AST Build Interface.

  // Liao 8/3/2010, pass fortran only test
// #ifdef ROSE_BUILD_CXX_LANGUAGE_SUPPORT

// Liao 8/4/2010, support enable-only-c
#ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT
  // This is what is used in the Open Fortran Parser connection.
     extern SgScopeStatement* getTopOfScopeStack();

  // These functions are used to test if we can use the fortran specific function above.
     extern bool emptyFortranStateStack();
     extern bool emptyFortranScopeStack();
#endif

     SgScopeStatement* currentScope = NULL;
#ifdef ROSE_BUILD_CXX_LANGUAGE_SUPPORT
     if (SageBuilder::emptyScopeStack() == false)
        {
       // C/C++ AST being generated (using new connection to EDG 4.x).
          currentScope = SageBuilder::topScopeStack();
          ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);
        }
       else
#endif
        {
#ifdef ROSE_BUILD_FORTRAN_LANGUAGE_SUPPORT // Liao 8/4/2010, support enable-only-c
       // DQ (7/31/2010): If Fortran is not enabled then these functions will not be available.

       // Changed check for emptyFortranStateStack to emptyFortranScopeStack. An error can occur
       // when the state stack is not empty but the scope stack is. This error was found when
       // running tests in the experimental_frontend_tests directory. Perhaps junk was left in the
       // Fortran state stack from tests run earlier in the parent Fortran test directory.
       // WARNING, the following relies on short circuiting and emptyFortranStateStack() == false
       // must be checked before emptyFortranScopeStack() == false.
       // Apparently Java is also examining the Fortran stack! [Rasmussen 2019-7-18].
          if (SageInterface::is_Fortran_language() && emptyFortranStateStack() == false && emptyFortranScopeStack() == false)
             {
            // Fortran AST being generated
               currentScope = getTopOfScopeStack();
               ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);
             }
            else
#endif
             {
                  {
                 // This is a code generated after the initial C/C++/Fortran AST was built, so we don't know the current scope.
                // Liao 10/29/2010. We allow users to build types during AST transformation, which will trigger this line.
                    if ( SgProject::get_verbose() > 1 ) 
                      printf ("In SgType::getCurrentScope(): Not in either the generation of C/C++ or Fortran AST construction \n");
                    currentScope = NULL;
                  }
             }
        }

  // DQ (7/23/2010): Add this as another test...
  // ROSE_ASSERT(isSgScopeStatement(currentScope) != NULL);

     return currentScope;
   }

SgDeclarationStatement*
SgType::getAssociatedDeclaration() const
   {
     SgDeclarationStatement* declaration = NULL;

  // printf ("In SgType::getAssociatedDeclaration(): type = %s \n",class_name().c_str());

  // DQ (4/15/2019): Adding support for SgType::STRIP_POINTER_MEMBER_TYPE, not clear if we need it here.
  // printf ("NOTE: SgType::getAssociatedDeclaration(): not using SgType::STRIP_POINTER_MEMBER_TYPE in call to stripType() \n");

  // Resolve to the base type (but not past typedef types).  Note that a subtle point is that 
  // we want to avoid expressing typedefs that are private in functions that are public.
  // SgType* strippedType = this->stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);
     SgType* strippedType = this->stripType(SgType::STRIP_MODIFIER_TYPE|SgType::STRIP_REFERENCE_TYPE|SgType::STRIP_RVALUE_REFERENCE_TYPE|SgType::STRIP_POINTER_TYPE|SgType::STRIP_ARRAY_TYPE);
     ROSE_ASSERT(strippedType != NULL);

  // printf ("In getAssociatedDeclaration(): strippedType = %s \n",strippedType->class_name().c_str());

  // Check if this is a named type (either SgClassType, SgEnumType, or SgTypedefType).
     SgNamedType* namedType = isSgNamedType(strippedType);
     if (namedType != NULL)
        {
       // Look for the declaration and evaluate if it required qualification.
          declaration = namedType->get_declaration();
          ROSE_ASSERT(declaration != NULL);

       // printf ("In HiddenListTraversal::getDeclarationAssociatedWithType(): declaration = %p = %s \n",declaration,declaration->class_name().c_str());

       // DQ (5/25/2013): Check if the declaration might have been deleted.
          if (declaration->get_freepointer() != AST_FileIO::IS_VALID_POINTER()) {
            printf("Found a pointer to a deleted node:\n");
            printf(" - type = %p (%s)\n", this, this->class_name().c_str());
            printf(" - decl = %p\n", declaration);
            printf(" - name : %s\n", SageInterface::generateUniqueName(this, false).c_str());
          }
          ROSE_ASSERT(declaration->get_freepointer() == AST_FileIO::IS_VALID_POINTER());
        }

#if 0
  // DQ (4/28/2019): Added support for member functions which are the base type of SgPointerMemberType 
  // when they are pointers to member functions.
     SgMemberFunctionType* memberFunctionType = isSgMemberFunctionType(strippedType);
     if (memberFunctionType != NULL)
        {
#if 0
          SgType* associtedClass = memberFunctionType->get_class_type();
          ROSE_ASSERT(associtedClass != NULL);

          declaration = associtedClass->getAssociatedDeclaration();
          ROSE_ASSERT(declaration != NULL);
#else
       // DQ (4/28/2019): I think this is the better implementation.
          SgType* returnType = memberFunctionType->get_return_type();
          ROSE_ASSERT(returnType != NULL);

          declaration = returnType->getAssociatedDeclaration();
#endif
        }
#endif

#if 1
  // DQ (4/28/2019): Added support for functions (for which a member function is the base type of SgPointerMemberType 
  // when they are pointers to member functions.
     SgFunctionType* functionType = isSgFunctionType(strippedType);
     if (functionType != NULL)
        {
       // DQ (4/28/2019): I think this is the better implementation.
          SgType* returnType = functionType->get_return_type();
          ROSE_ASSERT(returnType != NULL);

          declaration = returnType->getAssociatedDeclaration();
        }
#endif

     return declaration;
   }

bool SgType::hasExplicitType()
   {
  // DQ (3/7/2014):  Tis could be implemented as a virtual function but would require 11 functions to be 
  // implemented. I have thus instead implemented it as a single function on the SgType instead. We
  // can review this if it is important.

  // This function returns true only if this is either a SgPointerType, SgReferenceType, SgPointerMemberType, 
  // SgJavaParameterizedType, SgJavaWildcardType, SgModifierType, SgQualifiedNameType, SgFunctionType, 
  // SgMemberFunctionType, SgArrayType, SgTypeComplex, or SgTypeImaginary.

     bool returnValue = false;

     if ( isSgPointerType(this) != NULL        || isSgArrayType(this)    != NULL          || isSgReferenceType(this) != NULL     || 
          isSgPointerMemberType(this) != NULL  || isSgJavaParameterizedType(this) != NULL || isSgJavaWildcardType(this)  != NULL ||
          isSgMemberFunctionType(this) != NULL || isSgTypeComplex(this) != NULL           || isSgTypeImaginary(this)  != NULL    ||
          isSgFunctionType(this) != NULL       || isSgModifierType(this)  != NULL)
        {
          returnValue = true;
        }

     return returnValue;
   }


bool
SgType::containsInternalTypes()
   {
  // DQ (1/14/2011): Added function to support collection of types in AST node query support.
  // Some types can hide internal types and we often want to resolve type based properties 
  // that require us to dig into these specific type IR nodes.  For example, when we traverse
  // an AST subtree we might want to build a list of all referenced types (including indirect
  // references through pointers and arrays, etc.).  This function is a simple interface that
  // communicates the type IR nodes that can hide internal types and thus may require a 
  // nested traverals or a specialized recursive traveral.

     bool returnValue = false;

     if ( isSgPointerType(this) != NULL || isSgArrayType(this)    != NULL || isSgReferenceType(this) != NULL || 
          isSgTypedefType(this) != NULL || isSgFunctionType(this) != NULL || isSgModifierType(this)  != NULL)
        {
          returnValue = true;
        }

     return returnValue;
   }

Rose_STL_Container<SgType*>
SgType::getInternalTypes() const
   {
  // This function builds a collection of internal types (unordered).

     Rose_STL_Container<SgType*> internalTypes;

  // Cast away const of "this" pointer
     SgType* currentType = (SgType*) this;

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

#if 0
     printf ("In SgType::getInternalTypes(): TOP: currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif

  // DQ (3/16/2014): Of coruse we need this.
  // Initialize with the input type (not clear if this is helpful).
  // internalTypes.push_back(currentType);
     internalTypes.push_back(currentType);

     while (true)
        {
#if 0
           printf ("In SgType::getInternalTypes(): currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
          if ( (modType = isSgModifierType(currentType)) )
             {
               currentType = modType->get_base_type();
             }
            else
             {
               if ( (refType = isSgReferenceType(currentType)) )
                  {
                    currentType = refType->get_base_type();
                  }
                 else
                  {
                    if ( (pointType = isSgPointerType(currentType)) )
                       {
                         currentType = pointType->get_base_type();
                       }
                      else
                       {
                         if ( (arrayType = isSgArrayType(currentType)) )
                            {
                              currentType = arrayType->get_base_type();
                            }
                           else
                            {
                              if ( (typedefType = isSgTypedefType(currentType)) )
                                 {
                                   currentType = typedefType->get_base_type();
                                 }
                                else
                                 {
                                // Exit the while(true){} loop!

                                // If we have a SgFunctionType then we have to use a different approach to collect 
                                // the different associated types.  I am not clear if this function should have
                                // such broad semantics.
                                   SgFunctionType* functionType = isSgFunctionType(currentType);
                                   if (functionType != NULL)
                                      {
#if 0
                                        printf ("Note: Found a SgFunctionType within SgType::getInternalTypes(), not clear how to handle this case... \n");
                                     // ROSE_ASSERT(false);
#endif
                                      }

                                   break;
                                 }
                            }
                       }
                  }
             }

#if 0
           printf ("In SgType::getInternalTypes(): push_back(): currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
          internalTypes.push_back(currentType);
        }

     return internalTypes;
   }

void
SgType::reset_base_type(SgType* baseType)
   {
  // DQ (1/15/2011): This function is used to reset types within Fortran handling.
  // Types that have not been see yet and are required to types within construct declarations
  // are assigned a SgTypeDefault which is then replaces after all declarations have been seem.

     SgType* parentType = (SgType*) this;

     ROSE_ASSERT(parentType != NULL);
     ROSE_ASSERT(parentType->containsInternalTypes() == true);

     SgModifierType*  modType     = NULL;
     SgPointerType*   pointType   = NULL;
     SgReferenceType* refType     = NULL;
     SgArrayType*     arrayType   = NULL;
     SgTypedefType*   typedefType = NULL;

     if ( (modType = isSgModifierType(parentType)) )
        {
          modType->set_base_type(baseType);
        }
       else
        {
          if ( (refType = isSgReferenceType(parentType)) )
             {
               refType->set_base_type(baseType);
             }
            else
             {
               if ( (pointType = isSgPointerType(parentType)) )
                  {
                    pointType->set_base_type(baseType);
                  }
                 else
                  {
                    if ( (arrayType = isSgArrayType(parentType)) )
                       {
                         arrayType->set_base_type(baseType);
                       }
                      else
                       {
                         if ( (typedefType = isSgTypedefType(parentType)) )
                            {
                           // DQ (1/15/2011): This does not make sense to approach this way, and I think is not required for Fortran support (at least).
                           // typedefType->set_base_type(baseType);
                              ROSE_ASSERT(typedefType->get_declaration() != NULL);
                              printf ("Error: Typedef can't have there base type reset! \n");
                              ROSE_ASSERT(false);
                            }
                           else
                            {
                              printf ("Unable to reset the base type for parentType = %p = %s \n",parentType,parentType->class_name().c_str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
             }
        }
   }

// SKW (3/1/2011): Added these explicit implementations since we no longer build them automatically
SgExpression *
SgType::get_type_kind () const
   {
     return p_type_kind;
   }

void
SgType::set_type_kind ( SgExpression* type_kind )
   {
     p_type_kind = type_kind;
   }


bool
SgType::isEquivalentType (const SgType* other_type) const
   {
  // DQ (12/8/2015): This implementation is now refactored into a function implemented in the SageInterface.

     return SageInterface::isEquivalentType(this,other_type);
   }

#if 0
// DQ (11/28/2015): Implementation of type equivalence required to support differentiating template instantiations in the symbol table handling.
// This code needs to be reviewed, since it is critical to the template name lookup (which a lot of general robustness depends upon).
// bool SgType::operator== (const SgType & Y) const
bool
SgType::isEquivalentType (const SgType & Y) const;
   {
  // DQ (11/28/2015): A better goal for this function should be to define it as a recursive function.

     bool isSame = false;

  // While debugging avoid infinte loops (most type chains in STL and boost are only a 3-4 long in test2015_127.C, nesting is how it goes wild).
     static int counter = 0;

     const SgType & X = *this;

#error "DEAD CODE!"

  // DQ (11/28/2015): We don't want to strip off everything.
  // SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE ) const;

  // I think we need to compute the type chain to evaluate equalence.
  // Rose_STL_Container< SgType*> getInternalTypes () const

     Rose_STL_Container<SgType*> X_typeChain = X.getInternalTypes();
     Rose_STL_Container<SgType*> Y_typeChain = Y.getInternalTypes();

#define DEBUG_TYPE_EQUIVALENCE 0

#if DEBUG_TYPE_EQUIVALENCE
     printf ("In SgType::operator==(): evaluation of type equivalence for lhs and rhs: counter = %d \n",counter);
#endif
#if DEBUG_TYPE_EQUIVALENCE
  // Debugging output.
     printf ("Output of type chain for lhs: \n");
     for (size_t i = 0; i < X_typeChain.size(); i++)
        {
          SgType* element_type = X_typeChain[i];
          printf ("X_element_type = %p = %s \n",element_type,element_type->class_name().c_str());
          SgModifierType* modifierType = isSgModifierType(element_type);
          if (modifierType != NULL)
             {
            // modifierType->get_typeModifier().display("X type chain");
               string s = modifierType->get_typeModifier().displayString();
               printf ("   --- type chain modifier: %s \n",s.c_str());
             }
        }

     printf ("Output of type chain for rhs: \n");
     for (size_t i = 0; i < Y_typeChain.size(); i++)
        {
          SgType* element_type = Y_typeChain[i];
          printf ("Y_element_type = %p = %s \n",element_type,element_type->class_name().c_str());
          SgModifierType* modifierType = isSgModifierType(element_type);
          if (modifierType != NULL)
             {
            // modifierType->get_typeModifier().display("Y type chain");
               string s = modifierType->get_typeModifier().displayString();
               printf ("   --- type chain modifier: %s \n",s.c_str());
             }          
        }
#endif

  // Increment the static variable to control the recursive d3epth while we debug this.
     counter++;

  // DQ (11/28/2015): exit in stead of infinte recursion.
     if (counter > 100) 
        {
       // DQ (11/28/2015): I htink this is a reasonable limit.
          printf ("ERROR: In SgType::operator==(): recursive limit exceeded for : counter = %d \n",counter);
          ROSE_ASSERT(false);

          return false;
        }

  // bool exit = false;

  // DQ (11/28/2015): exit in stead of infinte recursion.
     if (counter > 90) 
        {
          printf ("In SgType::operator==(): counter = %d: type chain X_element_type = %s Y_element_type = %s \n",counter,X.class_name().c_str(),Y.class_name().c_str());
        }

  // Strip off ant typedefs since they are equivalent by definition.
     SgType* X_element_type = X.stripType( STRIP_TYPEDEF_TYPE );
     SgType* Y_element_type = Y.stripType( STRIP_TYPEDEF_TYPE );

  // DQ (11/29/2015): We need to handle reference (when they are both references we can support then uniformally).
     SgReferenceType* X_referenceType = isSgReferenceType(X_element_type);
     SgReferenceType* Y_referenceType = isSgReferenceType(Y_element_type);

     if (X_referenceType != NULL && Y_referenceType != NULL)
        {
          X_element_type = X_referenceType->get_base_type();
          Y_element_type = Y_referenceType->get_base_type();

          counter--;

       // Recursive call.
          return (*X_element_type) == (*Y_element_type);
        }
       else
        {
        }

     SgModifierType* X_modifierType = isSgModifierType(X_element_type);
     SgModifierType* Y_modifierType = isSgModifierType(Y_element_type);

#if DEBUG_TYPE_EQUIVALENCE
     printf ("In SgType::operator==(): counter = %d: type chain X_element_type = %p = %s Y_element_type = %p = %s \n",
          counter,X_element_type,X_element_type->class_name().c_str(),Y_element_type,Y_element_type->class_name().c_str());
#endif

     if (X_modifierType != NULL && Y_modifierType != NULL)
        {
       // Handle the case of both modifiers.
#if DEBUG_TYPE_EQUIVALENCE
          printf ("In SgType::operator==(): loop: these are the both SgModifierType nodes: isSame = %s \n",isSame ? "true" : "false");
#endif
          if (X_modifierType == Y_modifierType)
             {
               isSame = true;
#if DEBUG_TYPE_EQUIVALENCE
               printf ("In SgType::operator==(): loop: these are the same modifier type: isSame = %s \n",isSame ? "true" : "false");
#endif
             }
            else
             {
               if (X_modifierType->get_typeModifier() == Y_modifierType->get_typeModifier())
                  {
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: these are equivalent modifiers: check the base type: isSame = %s \n",isSame ? "true" : "false");
#endif
                 // Recursive call.
                    isSame = (*X_modifierType->get_base_type()) == (*Y_modifierType->get_base_type());
                  }
                 else
                  {
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: these are not equivalent modifier types: check for default settings: isSame = %s \n",isSame ? "true" : "false");
#endif
                 // if (X_modifierType->get_typeModifier().isDefault() == true)
                    if (X_modifierType->get_typeModifier().isIdentity() == true)
                       {
#if DEBUG_TYPE_EQUIVALENCE
                         printf ("In SgType::operator==(): loop: found self-similar setting for lhs: isSame = %s \n",isSame ? "true" : "false");
#endif
                         X_element_type = X_modifierType->get_base_type();
                       }

                 // if (Y_modifierType->get_typeModifier().isDefault() == true)
                    if (Y_modifierType->get_typeModifier().isIdentity() == true)
                       {
#if DEBUG_TYPE_EQUIVALENCE
                         printf ("In SgType::operator==(): loop: found self-similar setting for rhs: isSame = %s \n",isSame ? "true" : "false");
#endif
                         Y_element_type = Y_modifierType->get_base_type();
                       }

                 // NOTE: If either of these are a SgTypedefType then the typedefs will be stripped away at the top of the recursive call.
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: recursive call on different adjusted modifier types: before recursive call to compare base types: isSame = %s \n",isSame ? "true" : "false");
#endif
                 // Recursive call on non-default modifier base types.
                    isSame = (*X_element_type) == (*Y_element_type);
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: these are different modifier types: after recursive call to compare base types: isSame = %s \n",isSame ? "true" : "false");
#endif
                  }
             }
        }
       else
        {
       // At least one of these is not a SgModifierType.

          if (X_modifierType != NULL || Y_modifierType != NULL)
             {
               bool isReduceable = false;

            // if (X_modifierType != NULL && X_modifierType->get_typeModifier().isDefault() == true)
               if (X_modifierType != NULL && X_modifierType->get_typeModifier().isIdentity() == true)
                  {
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: found default setting for lhs: isSame = %s \n",isSame ? "true" : "false");
#endif
                    X_element_type = X_modifierType->get_base_type();
                    isReduceable = true;
                  }

            // if (Y_modifierType != NULL && Y_modifierType->get_typeModifier().isDefault() == true)
            // if (Y_modifierType != NULL && Y_modifierType->get_typeModifier().isIdentity() == true)
               if (Y_modifierType != NULL && Y_modifierType->get_typeModifier().isIdentity() == true)
                  {
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): loop: found default setting for rhs: isSame = %s \n",isSame ? "true" : "false");
#endif
                    Y_element_type = Y_modifierType->get_base_type();
                    isReduceable = true;
                  }

            // NOTE: If either of these are a SgTypedefType then the typedefs will be stripped away at the top of the recursive call.
#if DEBUG_TYPE_EQUIVALENCE
               printf ("In SgType::operator==(): loop: these are different modifier types: after recursive call to compare base types: isReduceable = %s \n",isReduceable ? "true" : "false");
#endif
               if (isReduceable == true)
                  {
                 // Recursive call on non-default modifier base types.
                    isSame = (*X_element_type) == (*Y_element_type);
                  }
                 else
                  {
                 // Neither of these types were reducable.
                    isSame = false;
                  }

#if DEBUG_TYPE_EQUIVALENCE
               printf ("In SgType::operator==(): loop: these are different modifier types: after recursive call to compare base types: isReduceable = %s isSame = %s \n",
                    isReduceable ? "true" : "false",isSame ? "true" : "false");
#endif
             }
            else
             {
            // Neither of these are SgModifierType nodes.
            // X_element_type = X_element_type->stripType( STRIP_TYPEDEF_TYPE );
            // Y_element_type = Y_element_type->stripType( STRIP_TYPEDEF_TYPE );

               if (X_element_type == Y_element_type)
                  {
                    isSame = true;
#if DEBUG_TYPE_EQUIVALENCE
                    printf ("In SgType::operator==(): resolved to equal types: isSame = %s \n",isSame ? "true" : "false");
#endif
                  }
                 else
                  {
                    bool isReduceable = false;

                 // DQ (11/29/2015): We need to handle reference (when they are both references we can support then uniformally).
                    SgReferenceType* X_referenceType = isSgReferenceType(X_element_type);
                    SgReferenceType* Y_referenceType = isSgReferenceType(Y_element_type);

                    if (X_referenceType != NULL || Y_referenceType != NULL)
                       {

                         if (X_referenceType != NULL)
                            {
                              X_element_type = X_referenceType->get_base_type();
                              isReduceable = true;
                            }

                         if (Y_referenceType != NULL)
                            {
                              Y_element_type = Y_referenceType->get_base_type();
                              isReduceable = true;
                            }

                         if (isReduceable == true)
                            {
                           // Recursive call on non-default modifier base types.
                              isSame = (*X_element_type) == (*Y_element_type);
                            }
                           else
                            {
                           // Neither of these types were reducable.
                              isSame = false;
                            }
                       }
                      else
                       {
                      // DQ (11/29/2015): I think we need to add support for SgPointerType as well.

                      // Recursive call on non-typedef base types.
                         isSame = (*X_element_type) == (*Y_element_type);
#if DEBUG_TYPE_EQUIVALENCE
                         printf ("In SgType::operator==(): loop: evaluation of inner types: isSame = %s \n",isSame ? "true" : "false");
#endif
                       }
                  }
             }
        }

  // Decrement the static variable to control the recursive depth while we debug this.
     counter--;

#if DEBUG_TYPE_EQUIVALENCE
     printf ("In SgType::operator==(): isSame = %s \n",isSame ? "true" : "false");
#endif

#error "DEAD CODE!"

     return isSame;
   }
#endif





SOURCE_MAIN_TYPE_END


SOURCE_BUILTIN_TYPE_SUPPORT_START

#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
$CLASSNAME::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     $CLASSNAME::builtin_type.executeVisitorMemberFunction(visitor);
   }
#endif

SOURCE_BUILTIN_TYPE_SUPPORT_END


SOURCE_TYPE_UNKNOWN_TYPE_START
SOURCE_TYPE_UNKNOWN_TYPE_END


SOURCE_TYPE_CHAR_TYPE_START
SOURCE_TYPE_CHAR_TYPE_END


SOURCE_TYPE_SIGNED_CHAR_TYPE_START
SOURCE_TYPE_SIGNED_CHAR_TYPE_END


SOURCE_TYPE_UNSIGNED_CHAR_TYPE_START
SOURCE_TYPE_UNSIGNED_CHAR_TYPE_END


SOURCE_TYPE_SHORT_TYPE_START
SOURCE_TYPE_SHORT_TYPE_END


SOURCE_TYPE_SIGNED_SHORT_TYPE_START
SOURCE_TYPE_SIGNED_SHORT_TYPE_END


SOURCE_TYPE_UNSIGNED_SHORT_TYPE_START
SOURCE_TYPE_UNSIGNED_SHORT_TYPE_END


SOURCE_TYPE_INT_TYPE_START
SOURCE_TYPE_INT_TYPE_END


SOURCE_TYPE_SIGNED_INT_TYPE_START
SOURCE_TYPE_SIGNED_INT_TYPE_END


SOURCE_TYPE_UNSIGNED_INT_TYPE_START
SOURCE_TYPE_UNSIGNED_INT_TYPE_END


SOURCE_TYPE_LONG_TYPE_START
SOURCE_TYPE_LONG_TYPE_END


SOURCE_TYPE_SIGNED_LONG_TYPE_START
SOURCE_TYPE_SIGNED_LONG_TYPE_END


SOURCE_TYPE_UNSIGNED_LONG_TYPE_START
SOURCE_TYPE_UNSIGNED_LONG_TYPE_END


SOURCE_TYPE_VOID_TYPE_START
SOURCE_TYPE_VOID_TYPE_END


SOURCE_TYPE_GLOBAL_VOID_TYPE_START
SOURCE_TYPE_GLOBAL_VOID_TYPE_END


SOURCE_TYPE_WCHAR_TYPE_START

SOURCE_TYPE_WCHAR_TYPE_END


SOURCE_TYPE_CHAR16_TYPE_START

SOURCE_TYPE_CHAR16_TYPE_END


SOURCE_TYPE_CHAR32_TYPE_START

SOURCE_TYPE_CHAR32_TYPE_END


SOURCE_TYPE_FLOAT_TYPE_START
SOURCE_TYPE_FLOAT_TYPE_END


SOURCE_TYPE_DOUBLE_TYPE_START
SOURCE_TYPE_DOUBLE_TYPE_END


SOURCE_TYPE_LONG_LONG_TYPE_START
SOURCE_TYPE_LONG_LONG_TYPE_END


SOURCE_TYPE_SIGNED_LONG_LONG_TYPE_START
SOURCE_TYPE_SIGNED_LONG_LONG_TYPE_END


SOURCE_TYPE_UNSIGNED_LONG_LONG_TYPE_START
SOURCE_TYPE_UNSIGNED_LONG_LONG_TYPE_END


SOURCE_TYPE_SIGNED_128BIT_TYPE_START
SOURCE_TYPE_SIGNED_128BIT_TYPE_END


SOURCE_TYPE_UNSIGNED_128BIT_TYPE_START
SOURCE_TYPE_UNSIGNED_128BIT_TYPE_END

SOURCE_TYPE_TUPLE_START

SgTypePtrList&
SgTypeTuple::get_types()
   { return p_types; }

const SgTypePtrList&
SgTypeTuple::get_types() const
   { return p_types; }

void
SgTypeTuple::append_type(SgType *what)
   { what->set_parent(this); p_types.push_back(what); }

void
SgTypeTuple::prepend_type(SgType *what)
   { what->set_parent(this); p_types.insert(p_types.begin(), what); }

SOURCE_TYPE_TUPLE_END

SOURCE_TYPE_LONG_DOUBLE_TYPE_START
SOURCE_TYPE_LONG_DOUBLE_TYPE_END


SOURCE_TYPE_STRING_TYPE_START

// DQ (8/17/2010): Added support for SgTypeString.
void
SgTypeString::post_construction_initialization()
   {
  // printf ("Inside of SgTypeString::post_construction_initialization() \n");

  // DQ (10/5/2010): We no longer use this scalar mechanism (comment out).
#if 0
     p_definedUsingScalarLength = (p_lengthExpression == NULL);

     if (p_definedUsingScalarLength && p_lengthScalar == 0)
        {
       // DQ (8/21/2010): This is not a problem.
       // printf ("Warning: Zero length string specified, might be OK. \n");
        }
#endif
   }

SOURCE_TYPE_STRING_TYPE_END


SOURCE_TYPE_BOOL_TYPE_START
SOURCE_TYPE_BOOL_TYPE_END


SOURCE_TYPE_COMPLEX_TYPE_START
SOURCE_TYPE_COMPLEX_TYPE_END



SOURCE_TYPE_DEFAULT_TYPE_START

SgName
SgTypeDefault::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_DEFAULT_TYPE" << "b__" // start tag
                  << p_name.str() // name of default type
                  << "__" << "MANGLED_ID_DEFAULT_TYPE" << "e__"; // end tag

#if 0
     printf ("LEAVING: In SgTypeDefault::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

SgTypeDefault*
SgTypeDefault::createType ( const SgName & nameOfType )
   {
#if 0
     printf ("In SgTypeDefault::createType(): calling new SgTypeDefault \n");
     printf ("   --- nameOfType = %s \n",nameOfType.str());
#endif

     SgTypeDefault* returnType = new SgTypeDefault();
     if (nameOfType.is_null() == false)
        {
          returnType->set_name(nameOfType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

#if 0
     printf ("In SgTypeDefault::createType(): Building a default type = %p mangled name = %s \n",returnType,name.str());
#endif

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
          printf ("Mangled type name for SgTypeDefault = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
          printf ("Mangled type name for SgTypeDefault = %s (already exists in type table) \n",name.str());
#endif
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgTypeDefault(t);
        }

#if 0
     printf ("Leaving SgTypeDefault::createType(): returnType = %p \n",returnType);
#endif

     return returnType;
   }

SOURCE_TYPE_DEFAULT_TYPE_END


SOURCE_TYPE_LABEL_TYPE_START

SgName
SgTypeLabel::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_LABEL_TYPE" << "b__" // start tag
                  << p_name.str() // name of default type
                  << "__" << "MANGLED_ID_LABEL_TYPE" << "e__"; // end tag

#if 0
     printf ("LEAVING: In SgTypeLabel::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

SgTypeLabel*
SgTypeLabel::createType ( const SgName & nameOfType )
   {
#if 0
     printf ("In SgTypeLabel::createType(): \n");
#endif

     SgTypeLabel* returnType = new SgTypeLabel();
     if (nameOfType.is_null() == false)
        {
          returnType->set_name(nameOfType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

#if 0
     printf ("In SgTypeLabel::createType(): Building a label type = %p mangled name = %s \n",returnType,name.str());
#endif

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
          printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
          printf ("Mangled type name for SgStringType = %s (already exists in type table) \n",name.str());
#endif
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgTypeLabel(t);
        }

     return returnType;
   }

SOURCE_TYPE_LABEL_TYPE_END


SOURCE_POINTER_TYPE_START
SOURCE_POINTER_TYPE_END


SOURCE_POINTER_MEMBER_TYPE_START

// DQ (4/11/2019): This function supports returning a SgDeclarationStatement instead of a SgClassDeclaration, 
// which will always be well define where returning a SgClassDefinition is not always well defined.  Using
// a SgDeclarationStatement will also allow it to work with the case of pointer to member associated with 
// SgNonrealType IR nodes as well.
SgDeclarationStatement*
SgPointerMemberType::get_class_declaration_of() const
   {
     SgDeclarationStatement* result = NULL;

     if (get_class_type() != NULL)
        {
          SgType* type = get_class_type()->stripTypedefsAndModifiers();
       // SgClassType *clsType = isSgClassType(get_class_type()->stripTypedefsAndModifiers());
          SgClassType *clsType = isSgClassType(type);
       // ROSE_ASSERT(clsType != NULL);

          if (clsType != NULL)
             {
            // DQ (4/11/2019): Note that the defining declaration may not exist.
            // SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration()->get_definingDeclaration());
               SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration());
               result = clsDecl;
             }
            else
             {
#if 0
               printf ("WARNING: SgPointerMemberType::get_class_declaration_of() retuning NULL type = %p = %s \n",type,type->class_name().c_str());
#endif
               SgNonrealType* nonrealType = isSgNonrealType(type);
               ROSE_ASSERT(nonrealType != NULL);
               result = nonrealType->get_declaration();
             }

          ROSE_ASSERT(result != NULL);
        }

     ROSE_ASSERT(result != NULL);

     return result;
   }

// DQ (4/11/2019): This is a depricated function, because it can not always return a valid SgClassDefinition.
SgClassDefinition*
SgPointerMemberType::get_class_definition_of() const
   {
     SgClassDefinition* result = NULL;

     if (get_class_type() != NULL)
        {
          SgType* type = get_class_type()->stripTypedefsAndModifiers();
       // SgClassType *clsType = isSgClassType(get_class_type()->stripTypedefsAndModifiers());
          SgClassType *clsType = isSgClassType(type);
       // ROSE_ASSERT(clsType != NULL);
       // SgClassType *clsType = isSgClassType(get_class_type()->stripTypedefsAndModifiers());
       // ROSE_ASSERT(clsType != NULL);

          if (clsType != NULL)
             {
               SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration()->get_definingDeclaration());

            // DQ (4/10/2019): This should not be an error when the SgClassDefinition is not available.  
            // But we might want to change the API to return the SgClassDeclaration instead.
            // ROSE_ASSERT(clsDecl != NULL);
            // return clsDecl->get_definition();

            // DQ (4/10/2019): This should not be an error when the SgClassDefinition is not available.  
               if (clsDecl != NULL)
                  {
                    result = clsDecl->get_definition();
                  }
                 else
                  {
                    printf ("NOTE: SgPointerMemberType::get_class_definition_of() retuning NULL: use SgPointerMemberType::get_class_declaration_of() instead! \n");
                  }
             }
            else
             {
               printf ("WARNING: SgPointerMemberType::get_class_definition_of() retuning NULL type = %p = %s \n",type,type->class_name().c_str());
             }
        }

     return result;
   }


SgName
SgPointerMemberType::get_qualified_name_prefix_for_class_of() const
   {
  // DQ (4/18/2019): Adding support for type chains of types (including SgPointerMemberType).

  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgVarRefExp
  //    SgFunctionRefExp
  //    SgMemberFunctionRefExp

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
  // printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
  // printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): search globalQualifiedNameMapForTypes: this = %p = %s \n",this,this->class_name().c_str());
     printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (4/20/2019): Use the globalQualifiedNameMapForNames for the get_qualified_name_prefix_for_class_of() function.
  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
  // std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgPointerMemberType*>(this));
  // std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgPointerMemberType*>(this));
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgPointerMemberType*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

  // if (i != SgNode::get_globalQualifiedNameMapForNames().end())
  // if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("nameQualifier for SgType = %p = %p = %s = %s \n",this,const_cast<SgType*>(this),class_name().c_str(),nameQualifier.str());
#endif

#if 0
  // DQ (8/19/2013): Error checking on the globalTypeNameMap...check if there is an entry here that we might have wanted to use instead.
     std::map<SgNode*,std::string>::iterator j = SgNode::get_globalTypeNameMap().find(const_cast<SgPointerMemberType*>(this));
     if (j != SgNode::get_globalTypeNameMap().end())
        {
          SgName debug_nameQualifier = j->second;
          printf ("In SgPointerMemberType::get_qualified_name_prefix_for_class_of(): Found a valid name qualification in the globalTypeNameMap: debug_nameQualifier = %s \n",debug_nameQualifier.str());
        }
#endif

     return nameQualifier;
   }
 

SgName
SgPointerMemberType::get_qualified_name_prefix_for_base_type() const
   {
  // DQ (4/18/2019): Adding support for type chains of types (including SgPointerMemberType).

  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific SgSupport IR nodes:
  //    SgVarRefExp
  //    SgFunctionRefExp
  //    SgMemberFunctionRefExp

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
  // printf ("In SgPointerMemberType::get_qualified_name_prefix(): search globalQualifiedNameMapForNames: this = %p = %s \n",this,this->class_name().c_str());
     printf ("In SgPointerMemberType::get_qualified_name_prefix(): search globalQualifiedNameMapForTypes: this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified 
  // different and so it depends upon where the type is referenced.  Thus the qualified name is 
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
  // std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgPointerMemberType*>(this));
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgPointerMemberType*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

  // if (i != SgNode::get_globalQualifiedNameMapForNames().end())
     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix(): Found a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
          printf ("In SgPointerMemberType::get_qualified_name_prefix(): Could NOT find a valid name qualification: nameQualifier = %s \n",nameQualifier.str());
#endif
        }

#if DEBUG_SGTYPE_GET_QUALIFIED_NAME_PREFIX
     printf ("nameQualifier for SgType = %p = %p = %s = %s \n",this,const_cast<SgType*>(this),class_name().c_str(),nameQualifier.str());
#endif

#if 0
  // DQ (8/19/2013): Error checking on the globalTypeNameMap...check if there is an entry here that we might have wanted to use instead.
     std::map<SgNode*,std::string>::iterator j = SgNode::get_globalTypeNameMap().find(const_cast<SgPointerMemberType*>(this));
     if (j != SgNode::get_globalTypeNameMap().end())
        {
          SgName debug_nameQualifier = j->second;
          printf ("In SgPointerMemberType::get_qualified_name_prefix(): Found a valid name qualification in the globalTypeNameMap: debug_nameQualifier = %s \n",debug_nameQualifier.str());
        }
#endif

     return nameQualifier;
   }
 


SOURCE_POINTER_MEMBER_TYPE_END


SOURCE_REFERENCE_TYPE_START
SOURCE_REFERENCE_TYPE_END


SOURCE_RVALUE_REFERENCE_TYPE_START
SOURCE_RVALUE_REFERENCE_TYPE_END


SOURCE_DECL_TYPE_START

void
SgDeclType::set_base_type(SgType* base_type)
   {
     ROSE_ASSERT(base_type != NULL);
     if (p_base_expression == NULL || (isSgFunctionParameterRefExp(p_base_expression) != NULL))
        {
          p_base_type = base_type;
        }
       else
        {
       // Prefer the one available in p_base_expression.
          p_base_type = NULL;
          if (base_type != p_base_expression->get_type())
             {
               printf ("Error: base_type in SgDeclType::set_base_type() does not match p_base_expression->get_type() \n");
             }
          ROSE_ASSERT(base_type == p_base_expression->get_type());
        }
   }

SgType*
SgDeclType::get_base_type() const
   {
     SgType* return_type = NULL;
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(p_base_expression != NULL);
     if (p_base_expression == NULL || isSgFunctionParameterRefExp(p_base_expression) != NULL)
        {
          return_type = p_base_type;
        }
       else
        {
          return_type = p_base_expression->get_type();
        }

     ROSE_ASSERT(return_type != NULL);

     return return_type;
  // return p_base_expression->get_type();
   }

SgName
SgDeclType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT (p_base_expression != NULL);

     SgName mangled_name;
     mangled_name << "__bdecltype__"
                  << mangleExpression(p_base_expression)
                  << "__edecltype__";


     return mangled_name;
   }

SOURCE_DECL_TYPE_END


SOURCE_TYPEOF_TYPE_START

void
SgTypeOfType::set_base_type(SgType* base_type)
   {
     ROSE_ASSERT(base_type != NULL);
     if (p_base_expression == NULL || (isSgFunctionParameterRefExp(p_base_expression) != NULL))
        {
          p_base_type = base_type;
        }
       else
        {
       // Prefer the one available in p_base_expression.
          p_base_type = NULL;
          if (base_type != p_base_expression->get_type())
             {
               printf ("Error: base_type in SgTypeOfType::set_base_type() does not match p_base_expression->get_type() \n");
             }
          ROSE_ASSERT(base_type == p_base_expression->get_type());
        }
   }

SgType*
SgTypeOfType::get_base_type() const
   {
     SgType* return_type = NULL;
     ROSE_ASSERT(this != NULL);
  // ROSE_ASSERT(p_base_expression != NULL);
     if (p_base_expression == NULL || isSgFunctionParameterRefExp(p_base_expression) != NULL)
        {
          return_type = p_base_type;
        }
       else
        {
          return_type = p_base_expression->get_type();
        }

     ROSE_ASSERT(return_type != NULL);

     return return_type;
  // return p_base_expression->get_type();
   }

/*! Returns a mangled name representation of types taking expressions and base types (e.g., pointer, reference).
 */
SgName
SgTypeOfType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_mangled(): base_type = %p = %s \n",base_type,base_type->class_name().c_str());
#endif

     SgName base_name = base_type->get_mangled();

#if 0
     printf ("DONE: In $CLASSNAME::get_mangled(): base_type = %p = %s base_name = %s \n",base_type,base_type->class_name().c_str(),base_name.str());
#endif

  // This can be NULL.
     const SgExpression* base_expression = get_base_expression();
  // ROSE_ASSERT (base_expression != NULL);
     if (base_expression != NULL)
        {
#if 0
          printf ("In $CLASSNAME::get_mangled(): base_expression = %p = %s \n",base_expression,base_expression->class_name().c_str());
#endif

       // base_name += base_expression->get_mangled();
       // base_name += SageInterface::get_name(base_expression);
          base_name += string("_base_expr_") + Rose::StringUtility::numberToString(this);

#if 0
          printf ("DONE: In $CLASSNAME::get_mangled(): base_expression = %p = %s accumulated base_name = %s \n",base_expression,base_expression->class_name().c_str(),base_name.str());
#endif
        }

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
#if 0
          printf ("Warning: In $CLASSNAME::get_mangled(), empty base type name found \n");
#endif
          base_name = "un_named_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "__" << "MANGLED_ID_STRING" << "b__" // start tag
                  << base_name.str () // base expression and type
                  << "__" << "MANGLED_ID_STRING" << "e__"; // end tag
#if 0
     printf ("LEAVING: In $CLASSNAME::get_mangled(): base_expression = %p = %s base_type = %p = %s mangled_name = %s \n",
          base_expression,base_expression != NULL ? base_expression->class_name().c_str() : "null",
          base_type,base_type->class_name().c_str(),mangled_name.str());
#endif

     return mangled_name;
   }

SOURCE_TYPEOF_TYPE_END


SOURCE_NAMED_TYPE_START
// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgNamedType::p_defaultQualifiedNamePtrList;

SgNamedType::SgNamedType ( const SgNamedType & X )
   {
     p_declaration            = X.p_declaration;
 	  p_autonomous_declaration = X.p_autonomous_declaration;

     ROSE_ASSERT(p_declaration != NULL);
   }

SgName
SgNamedType::get_name() const
   {
     printf ("Error: base class $CLASSNAME::get_name() called! \n");
     ROSE_ABORT();

     return SgName();
   }


SgName
SgNamedType::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() for %p = %s name = %s \n",this,sage_class_name(),get_name().str());

     ROSE_ASSERT(get_declaration() != NULL);

  // DQ (6/23/2005): This does not appear to be required any more (I think)
  // ROSE_ASSERT(get_declaration()->get_parent() != NULL);

#if 0
     printf ("In $CLASSNAME::get_qualified_name() get_declaration() = %p = %s at: \n",get_declaration(),get_declaration()->sage_class_name());
     get_declaration()->get_file_info()->display("In $CLASSNAME::get_qualified_name(): location of declaration");
#endif

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_declaration()->get_scope();
     ROSE_ASSERT(scope != NULL);

  // printf ("In $CLASSNAME::get_qualified_name(): scope->sage_class_name() = %s \n",scope->sage_class_name());

     SgName returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

  // printf ("Exiting at end of $CLASSNAME::get_qualified_name() \n");
  // ROSE_ASSERT(false);

     return returnName;
   }

SOURCE_NAMED_TYPE_END


SOURCE_CLASS_TYPE_START
SgClassType::SgClassType ( const SgClassType & X )
   : SgNamedType(X)
   {
   }


SgName
SgClassType::get_name() const
   {
  // DQ (12/4/2011): Adding support for template declarations in the AST.
  // if (get_declaration() != NULL)
     SgDeclarationStatement* declaration = get_declaration();
     if (declaration != NULL)
        {
       // DQ (12/4/2011): Handling support for SgClassDeclaration and SgTemplateClassDeclaration declarations.
       // return isSgClassDeclaration(get_declaration())->get_name();
          SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
          SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(declaration);
          if (templateClassDeclaration != NULL) {
            return templateClassDeclaration->get_name();
          } else if (classDeclaration != NULL) {
            return classDeclaration->get_name();
          } else {
            ROSE_ASSERT(false);
          }
        }
       else
        {
          return SgName((char *)0L);
        }
   }


// RV (1/31/2006): Changed behavior to return a fully-qualified, mangled name.
/*! Returns a mangled name (with embedded, mangled qualifiers).
 *  \note If the class is anonymous, e.g.,
 *    typedef struct { int a; char b; } tag_t;
 *  then this routine returns an empty name.
 */
#define DEBUG_CLASS_TYPE_GET_MANGLED 0
SgName
SgClassType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

#if DEBUG_CLASS_TYPE_GET_MANGLED
     printf ("In SgClassType::get_mangled(): get_name() = %s \n",get_name().str());
#endif

     SgName mangled_name;
  // if (get_name().get_length() != 0) // not anonymous
     if (get_name().is_null() == false) // not anonymous
        {
          const SgClassDeclaration* class_decl = isSgClassDeclaration(get_declaration());
#if DEBUG_CLASS_TYPE_GET_MANGLED
          printf ("In SgClassType::get_mangled(): class_decl = %p = %s \n",class_decl, ((class_decl == NULL) ? "NULL" : class_decl->class_name().c_str()) );
#endif
          if (class_decl != NULL)
             {
            // DQ (3/14/2012): We need to have a valid scope or else the name qualification will be empty.
               ROSE_ASSERT(class_decl->get_scope() != NULL);

            // DQ (7/29/2010): Template instantiation declarations can differ on template parameters so we have to dig a little farther.
               const SgTemplateInstantiationDecl* template_class_inst = isSgTemplateInstantiationDecl(get_declaration());
               const SgTemplateClassDeclaration* template_class_decl = isSgTemplateClassDeclaration(get_declaration());
               if (template_class_inst != NULL)
                  {
                    mangled_name = template_class_inst->get_mangled_name();
#if DEBUG_CLASS_TYPE_GET_MANGLED
                    printf ("In SgClassType::get_mangled(): SgTemplateInstantiationDecl mangled_name = %s \n",mangled_name.str());
#endif
                  }
                 else if (template_class_decl != NULL)
                  {
                    mangled_name = template_class_decl->get_mangled_name();
#if 0
                    printf ("In SgClassType::get_mangled(): SgTemplateClassDeclaration mangled_name = %s \n",mangled_name.str());
#endif
                  }
                 else
                  {
                 // DQ (3/14/2012): We need to have a valid scope or else the name qualification will be empty.
                    ROSE_ASSERT(class_decl->get_scope() != NULL);

                 // This is for just a simple SgClassDeclaration.
                    mangled_name = class_decl->get_mangled_name();
#if DEBUG_CLASS_TYPE_GET_MANGLED
                    printf ("In SgClassType::get_mangled(): SgClassDeclaration calling class_decl->get_mangled_name() --- mangled_name = %s \n",mangled_name.str());
#endif
                  }
             }
        }

#if DEBUG_CLASS_TYPE_GET_MANGLED
     printf ("Leaving SgClassType::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

#if 0
// Older code
SgName
$CLASSNAME::get_mangled(SgUnparse_Info&)
   {
     SgName tmp;
  // todo: what should be done when the class name is nil (anonymous class?)

#if 0
     SgName name = get_name();
     if (!name.is_null())
        {
          tmp << strlen(name.str()) << name.str();
        }
#else
     SgName name = get_qualified_name();
  // printf ("Using get_qualified_name() instead of get_name() in get_mangled() name = %s \n",name.str());
     if (!name.is_null())
        {
       // DQ (6/23/2005): type names put into the symbol table (function symbol table) should be name qualified (maybe)
       // tmp << strlen(get_name().str()) << get_name().str();
       // tmp << strlen(get_mangled_name().str()) << get_mangled_name().str();
          tmp << strlen(name.str()) << name.str();
        }
#endif

     return tmp;
   }
#endif

SOURCE_CLASS_TYPE_END

SOURCE_NONREAL_TYPE_START

SgNonrealType::SgNonrealType ( const SgNonrealType & X )
   : SgNamedType(X)
   {
   }

SgName
SgNonrealType::get_mangled(void) const
   {
     SgNonrealDecl * nrdecl = isSgNonrealDecl(get_declaration());
     ROSE_ASSERT(nrdecl != NULL);
     return nrdecl->get_mangled_name();
   }

SgName SgNonrealType::get_name() const {
  SgDeclarationStatement * decl_stmt = get_declaration();
  ROSE_ASSERT(decl_stmt != NULL);
  SgNonrealDecl * nonreal_decl = isSgNonrealDecl(decl_stmt);
  ROSE_ASSERT(nonreal_decl != NULL);
  return nonreal_decl->get_name();
}

SOURCE_NONREAL_TYPE_END

SOURCE_AUTO_TYPE_START

SgAutoType::SgAutoType ( const SgAutoType & X )
   : SgType(X)
   {
   }

SgName
SgAutoType::get_mangled(void) const
   {
     std::ostringstream oss;
     oss << "auto_" << std::hex << this;
     return SgName(oss.str());
   }

/*SgName
SgAutoType::get_name() const {
  return SgName("auto");
}*/

SOURCE_AUTO_TYPE_END

SOURCE_JAVA_PARAMETERIZED_TYPE_START
SgJavaParameterizedType::SgJavaParameterizedType ( const SgJavaParameterizedType & X )
   : SgNamedType(X)
   {
   }

#ifdef ROSE_BUILD_JAVA_LANGUAGE_SUPPORT
SgName
SgJavaParameterizedType::get_name() const {
    if (get_declaration()) {
        string name = get_raw_type() -> get_name().getString();
        if (get_type_list() != NULL) {
            name += "<";
            SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
            for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
                if (i != templateParameters.begin()) {
                    name += ", ";
                }
                SgType *type = (*i) -> get_type();
                SgArrayType *array_type = isSgArrayType(type);

             // DQ (3/19/2016): Klocworks reports the use of isSgNamedType(type) as an issue, since it could be NULL (as it sees it).
             // ROSE_ASSERT(array_type || isSgNamedType(type));
             // name += (array_type ? array_type -> get_name() : isSgNamedType(type) -> get_name()).getString();
                SgNamedType *named_type = isSgNamedType(type);
                ROSE_ASSERT(array_type != NULL || named_type != NULL);
                name += (array_type ? array_type -> get_name() : named_type -> get_name()).getString();
            }
            name += ">";
        }
        return SgName(name);
    }
    else
        return SgName((char *)0L);
}
#else
SgName
SgJavaParameterizedType::get_name() const {
    ROSE_ASSERT(! "[FATAL] ROSE was not configured with Java support");
    return "";
}
#endif

#ifdef ROSE_BUILD_JAVA_LANGUAGE_SUPPORT
SgName
SgJavaParameterizedType::get_qualified_name() const {
    string name = get_raw_type() -> get_qualified_name().getString();
    if (get_type_list() != NULL) {
        name += "<";
        SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
        for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
            if (i != templateParameters.begin()) {
                name += ", ";
            }
            SgType *type = (*i) -> get_type();
            SgArrayType *array_type = isSgArrayType(type);
            ROSE_ASSERT(array_type || isSgNamedType(type));
            name += (array_type ? array_type -> get_qualified_name() : isSgNamedType(type) -> get_qualified_name()).getString();
        }
        name += ">";
    }
    return SgName(name);
}
#else
SgName
SgJavaParameterizedType::get_qualified_name() const {
    ROSE_ASSERT(! "[FATAL] ROSE was not configured with Java support");
    return "";
}
#endif

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // printf ("In $CLASSNAME::get_mangled(): get_name() = %s \n",get_name().str());

     SgName mangled_name;
  // if (get_name().get_length() != 0) // not anonymous
     if (get_name().is_null() == false) // not anonymous
        {
             mangled_name = get_raw_type() -> get_mangled();
             if (get_type_list() != NULL) {
                 SgTemplateParameterPtrList templateParameters = get_type_list() -> get_args();
                 for (SgTemplateParameterPtrList::iterator i = templateParameters.begin(); i != templateParameters.end(); i++) {
                     mangled_name += "_";
                     mangled_name += (*i) -> get_type() -> get_mangled();
                 }
             }
        }

     return mangled_name;
   }
SOURCE_JAVA_PARAMETERIZED_TYPE_END


SOURCE_JAVA_QUALIFIED_TYPE_START
SgJavaQualifiedType::SgJavaQualifiedType ( const SgJavaQualifiedType & X )
   : SgNamedType(X)
   {
   }

SgName
SgJavaQualifiedType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJavaQualifiedType::get_qualified_name() const
   {
       return p_parent_type -> get_qualified_name().getString() + "." + p_type -> get_name().getString();
   }


// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // printf ("In $CLASSNAME::get_mangled(): get_name() = %s \n",get_name().str());

     SgName mangled_name;
  // if (get_name().get_length() != 0) // not anonymous
     if (get_name().is_null() == false) // not anonymous
        {
             mangled_name = get_parent_type() -> get_mangled();
             mangled_name += "_";
             mangled_name += get_type() -> get_mangled();
        }

     return mangled_name;
   }
SOURCE_JAVA_QUALIFIED_TYPE_END


SOURCE_JAVA_WILDCARD_TYPE_START
SgJavaWildcardType::SgJavaWildcardType ( const SgJavaWildcardType & X )
   : SgNamedType(X)
   {
   }

bool
SgJavaWildcardType::is_unbound() {
    return p_bound_type == NULL;
}

SgName
SgJavaWildcardType::get_name() const 
   {
     string name = "?";

     if (p_bound_type != NULL) 
        {
          if (p_has_extends) {
              name += " extends ";
          }
          else if (p_has_super) {
              name += " super ";
          }

          SgType *type = p_bound_type;
          SgArrayType *array_type = isSgArrayType(type);
	  ROSE_ASSERT(array_type || isSgNamedType(type));

       // DQ (3/19/2016): Klocworks reports the use of isSgNamedType(type) as an issue, since it could be NULL (as it sees it).
       // ROSE_ASSERT(array_type || isSgNamedType(type));
       // name += (array_type ? array_type -> get_name() : isSgNamedType(type) -> get_name()).getString();
          SgNamedType *named_type = isSgNamedType(type);
          ROSE_ASSERT(array_type != NULL || named_type != NULL);
          name += (array_type ? array_type -> get_name() : named_type -> get_name()).getString();
        }

     return SgName(name);
   }

SgName
SgJavaWildcardType::get_qualified_name() const {
    string name = "?";

    if (p_bound_type != NULL) {
        if (p_has_extends) {
            name += " extends ";
        }
        else if (p_has_super) {
            name += " super ";
        }

        SgType *type = p_bound_type;
        SgArrayType *array_type = isSgArrayType(type);
	ROSE_ASSERT(array_type || isSgNamedType(type));
        name += (array_type ? array_type -> get_qualified_name() : isSgNamedType(type) -> get_qualified_name()).getString();
    }

    return SgName(name);
}

SgName
SgJavaWildcardType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     string mangled_name = "__MANGLED_ID_WILDCARD_TYPEb__";
     mangled_name += get_name().str(); // name of wildcard type is "?"
     if (p_bound_type != NULL) {
         mangled_name += (p_has_extends ? "_extends_" : "_super_");
         mangled_name += p_bound_type -> get_mangled();
     }
     mangled_name += ("__MANGLED_ID_WILDCARD_TYPEe__"); // end tag

#if 0
     printf ("LEAVING: In SgJavaWildcardType::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return SgName(mangled_name);
   }

SOURCE_JAVA_WILDCARD_TYPE_END


SOURCE_JAVA_UNION_TYPE_START
SgJavaUnionType::SgJavaUnionType ( const SgJavaUnionType & X )
   : SgType(X)
   {
   }


SgName
SgJavaUnionType::get_name() const {
    string name = "";
    for (size_t i = 0; i < p_type_list.size(); i++) {
      if (i > 0) {
            name += " | ";
        }
        name += isSgClassDeclaration(isSgNamedType(p_type_list[i]) -> getAssociatedDeclaration()) -> get_name();
    }
    return SgName(name); //. c_str()
}

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // printf ("In $CLASSNAME::get_mangled(): get_name() = %s \n",get_name().str());

     SgName mangled_name;

     for (size_t i = 0; i < p_type_list.size(); i++) {
         if (i > 0) {
             mangled_name += "_|_";
         }
         mangled_name += p_type_list[i] -> get_mangled();
     }

     return mangled_name;
   }
SOURCE_JAVA_UNION_TYPE_END


SOURCE_JAVA_PARAMETER_TYPE_START
SgJavaParameterType::SgJavaParameterType ( const SgJavaParameterType & X )
   : SgClassType(X)
   {
   }


SgName
SgJavaParameterType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJavaParameterType::get_qualified_name() const
   {
       return this -> get_name();
   }

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // printf ("In $CLASSNAME::get_mangled(): get_name() = %s \n",get_name().str());

  // DQ (2/10/2014): We want to iterate over the list of types and output a name from the concatination of the type names.
  //   printf ("Implementation of SgJavaParameterType::get_mangled(void) not complete! \n");

     SgClassDeclaration *class_declaration = isSgClassDeclaration(get_declaration() -> get_definingDeclaration());
     ROSE_ASSERT(class_declaration);
     SgName mangled_name = class_declaration -> get_mangled_name();
     SgBaseClassPtrList &bases = class_declaration -> get_definition() -> get_inheritances();
     for (size_t i = 0; i < bases.size(); i++) {
         mangled_name += "_";
         SgClassDeclaration *super_type = isSgBaseClass(bases[i]) -> get_base_class();
         mangled_name += super_type -> get_mangled_name();
     }

     return mangled_name;
   }
SOURCE_JAVA_PARAMETER_TYPE_END


SOURCE_JOVIAL_TABLE_TYPE_START
SgJovialTableType::SgJovialTableType ( const SgJovialTableType & X )
   : SgClassType(X)
   {
   }

SgName
SgJovialTableType::get_name() const
   {
     if(get_declaration())
          return isSgClassDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }

SgName
SgJovialTableType::get_qualified_name() const
   {
       return this -> get_name();
   }

// DQ (8/18/2011): This function is copied from the version from SgClassType.
SgName
$CLASSNAME::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

  // DQ (2/10/2014): We want to iterate over the list of types and output a name from the concatination of the type names.
     SgClassDeclaration *class_declaration = isSgClassDeclaration(get_declaration() -> get_definingDeclaration());
     ROSE_ASSERT(class_declaration);
     SgName mangled_name = class_declaration -> get_mangled_name();
     SgBaseClassPtrList &bases = class_declaration -> get_definition() -> get_inheritances();
     for (size_t i = 0; i < bases.size(); i++) {
         mangled_name += "_";
         SgClassDeclaration *super_type = isSgBaseClass(bases[i]) -> get_base_class();
         mangled_name += super_type -> get_mangled_name();
     }

     return mangled_name;
   }
SOURCE_JOVIAL_TABLE_TYPE_END


SOURCE_TEMPLATE_TYPE_START

SgName
SgTemplateType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In SgTemplateType::get_mangled(): this = %p get_name() = %s \n",this,get_name().str());
#endif

     SgName mangled_name = get_name();

  // DQ (9/21/2012): Add the pointer value for the first undefined declaration as a way to make this a unique mangled value.
  // We need to asspciate template template arguments with their associated declarations and not just there name.
  // See test2012_217.C (return types of functions should be different, have different mangled names, for each function).
  // mangled_name += StringUtility::numberToString(this->get_declaration());
     mangled_name += Rose::StringUtility::numberToString(this);

#if 0
    printf ("In SgTemplateType::get_mangled(): this = %p mangled_name = %s \n",this,mangled_name.str());
#endif

     return mangled_name;
   }

SOURCE_TEMPLATE_TYPE_END


SOURCE_ENUM_TYPE_START

SgEnumType::SgEnumType ( const SgEnumType & X )
   : SgNamedType(X)
   {
   }


SgName
SgEnumType::get_name() const
   {
     if(get_declaration())
          return isSgEnumDeclaration(get_declaration())->get_name();
       else
          return SgName((char *)0L);
   }


// RV (2/1/2006): Updated to use the declaration's mangling routine.
SgName
SgEnumType::get_mangled (void) const
    {
     ROSE_ASSERT(this != NULL);

     const SgEnumDeclaration* decl = isSgEnumDeclaration (get_declaration());
     ROSE_ASSERT (decl != NULL);

  // DQ (1/12/13): Assert that this is not a previously deleted IR node (which will have the name = "SgNode").
  // ROSE_ASSERT(decl->get_scope() != NULL);

#if 0
     printf ("SgEnumType::get_mangled(): decl->get_scope() = %p \n",decl->get_scope());
#endif

     if (decl->get_scope() != NULL)
        {
#if 0
          printf ("SgEnumType::get_mangled(): decl->get_scope() = %p = %s name = %s \n",decl->get_scope(),decl->get_scope()->class_name().c_str(),SageInterface::get_name(decl->get_scope()).c_str());
#endif

          ROSE_ASSERT(decl->get_scope()->class_name() != "SgNode");
        }

  // DQ (1/12/13): Added assertion (only makes sense for non SgGlobal scopes).
     if (isSgGlobal(decl->get_scope()) == NULL)
        {
       // ROSE_ASSERT(decl->get_scope()->get_scope() != NULL);
        }

     return decl->get_mangled_name ();
   }


#if 0
// Older code
SgName
SgEnumType::get_mangled(SgUnparse_Info&)
   {
  // DQ (6/23/2005): Use the qualified name here
  // return get_name();
     return get_qualified_name();
   }
#endif

SOURCE_ENUM_TYPE_END


SOURCE_TYPEDEF_TYPE_START

SgTypedefType::SgTypedefType ( const SgTypedefType & X )
// : SgNamedType(X.get_declaration())
   : SgNamedType(X), p_parent_scope(X.p_parent_scope)
   {
  // DQ (10/18/2007): This copy constructor is to support the AST copy mechansim, specifically
  // to permit the SgTypedefSeq to be updated with new copies of SgTypedefType objects.

  // DQ (10/19/2007): Make sure that this is true (though we could not test it before building the base class.
     ROSE_ASSERT( X.get_declaration() != NULL);

  // Typedefs need to setup the fixup the SgTypedefSeq list.
     SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(X.get_declaration());
     ROSE_ASSERT( typedefDeclaration != NULL);
     SgType* baseType = typedefDeclaration->get_base_type();
     ROSE_ASSERT(baseType != NULL);

  // Fixup the SgTypedefSeq object.
     baseType->get_typedefs()->append_typedef(this);
   }

SgName
SgTypedefType::get_name() const
   {
     if (get_declaration() != NULL)
        {
          return isSgTypedefDeclaration(get_declaration())->get_name();
        }
       else
        {
          printf ("Warning: Returning an empty name from $CLASSNAME::get_name() \n");
          return SgName((char *)0L);
        }
   }

SgType*
SgTypedefType::get_base_type() const
   {
  // DQ (6/30/2005): Added assertion (I think this makes sense!)
     ROSE_ASSERT(isSgTypedefDeclaration(get_declaration()) != NULL);
     return (get_declaration() != NULL) ? isSgTypedefDeclaration(get_declaration())->get_base_type() : NULL;
   }

// RV (2/1/2006): Updated to use the declaration's mangling routine.
SgName
SgTypedefType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgTypedefDeclaration* decl = isSgTypedefDeclaration (get_declaration());
     ROSE_ASSERT (decl != NULL);

#if 0
  // DQ (5/23/2018): Added debugging support for infinite loop bug.
     printf ("In SgTypedefType::get_mangled(): decl = %p = %s = %s \n",decl,decl->class_name().c_str(),decl->get_name().str());
#endif
#if 0
     if (decl->get_file_info() != NULL)
        {
          printf ("   --- typedef source position: decl = %p line = %d \n",decl,decl->get_file_info()->get_line());
        }
       else
        {
          printf ("   --- typedef source position: line = (unknown) \n");
        }
#endif

     return decl->get_mangled_name();
   }

SOURCE_TYPEDEF_TYPE_END


SOURCE_MODIFIER_TYPE_START

// mask some bit on or off
// void set_modifier   (int flag);
// void unset_modifier (int flag);

SgTypeModifier &
SgModifierType::get_typeModifier ()
   {
     assert (this != NULL);
     return p_typeModifier;
   }

// RV (2/2/2006): Created this 'const' version.
const SgTypeModifier &
SgModifierType::get_typeModifier (void) const
   {
     assert (this != NULL);
     return p_typeModifier;
   }

#if 0
// DQ (11/28/2015): I think that I might not require this (not that I have reviewed the new implementation).
// It appears that it is already implemented as a friend function (acording to doxygen documentation).
// Actually it shows up in Doxygen, but it does not appear to be implemented.
// That was a mistake, it appears that the SgTypeModifier has an operator==(), but not the SgModifierType.
// These names make it easy to get confused!
bool
// SgModifierType::operator== (const SgModifierType & X, const SgModifierType & Y)
SgModifierType::operator== (const SgModifierType & Y) const
   {
  // return ( (X.get_base_type() == Y.get_base_type()) &&  (X.get_typeModifier() == Y.get_typeModifier()) );
     bool isSame = false;

#error "DEAD CODE!"

     const SgModifierType & X = *this;

  // DQ (11/28/2015): We don't want to strip off everything.
  // SgType* stripType(unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE ) const;

  // I think we need to compute the type chain to evaluate equalence.
  // Rose_STL_Container< SgType*> getInternalTypes () const

  // Rose_STL_Container<SgType*> X_typeChain = X.get_base_type()->getInternalTypes();
  // Rose_STL_Container<SgType*> Y_typeChain = Y.get_base_type()->getInternalTypes();
     Rose_STL_Container<SgType*> X_typeChain = X.getInternalTypes();
     Rose_STL_Container<SgType*> Y_typeChain = Y.getInternalTypes();

#if 1
     for (size_t i = 0; i < X_typeChain.size(); i++)
        {
          SgType* element_type = X_typeChain[i];
          printf ("X_element_type = %p = %s \n",element_type,element_type->class_name().c_str());
          SgModifierType* modifierType = isSgModifierType(element_type);
          if (modifierType != NULL)
             {
               modifierType->get_typeModifier().display("X type chain");
             }
        }
     for (size_t i = 0; i < Y_typeChain.size(); i++)
        {
          SgType* element_type = Y_typeChain[i];
          printf ("Y_element_type = %p = %s \n",element_type,element_type->class_name().c_str());
          SgModifierType* modifierType = isSgModifierType(element_type);
          if (modifierType != NULL)
             {
               modifierType->get_typeModifier().display("Y type chain");
             }          
        }

     int counter = 0;
     bool exit = false;

     Rose_STL_Container<SgType*>::iterator i = X_typeChain.begin();
     Rose_STL_Container<SgType*>::iterator j = Y_typeChain.begin();
     while ( counter < 10 && exit == false && (i != X_typeChain.end() && j != Y_typeChain.end()))
        {
#if 1
          printf ("In SgModifierType::operator==(): counter = %d: type chain *i = %p = %s *j = %p = %s \n",counter,*i,(*i)->class_name().c_str(),*j,(*j)->class_name().c_str());
#endif
          SgType* X_element_type = *i;
          SgType* Y_element_type = *j;

          if (X_element_type == Y_element_type)
             {
               isSame = true;
               exit = true;
#if 1
               printf ("In SgModifierType::operator==(): loop: X_element_type == Y_element_type: isSame = %s \n",isSame ? "true" : "false");
#endif
             }
            else
             {
            // SgType* X_type = X.get_base_type()->stripType( STRIP_TYPEDEF_TYPE );
            // SgType* Y_type = Y.get_base_type()->stripType( STRIP_TYPEDEF_TYPE );

               X_element_type = X_element_type->stripType( STRIP_TYPEDEF_TYPE );
               Y_element_type = Y_element_type->stripType( STRIP_TYPEDEF_TYPE );
#if 0
               SgTypedefType* X_typedefType = isSgTypedefType(X_element_type);
               SgTypedefType* Y_typedefType = isSgTypedefType(Y_element_type);
               if (X_typedefType != NULL && X_typedefType == Y_typedefType)
                  {
                    isSame = true;
                    exit = true;
#if 1
                    printf ("In SgModifierType::operator==(): loop: these are the same typedef type: isSame = %s \n",isSame ? "true" : "false");
#endif
                  }
                 else
                  {
                    if (X_typedefType != NULL || Y_typedefType != NULL)
                       {
                         if (X_typedefType != NULL)
                            {
                              i++;
                            }
                         if (Y_typedefType != NULL)
                            {
                              j++;
                            }
                       }
#else
                  {
#endif
                 // if ()
                       {
                         SgModifierType* X_modifierType = isSgModifierType(X_element_type);
                         SgModifierType* Y_modifierType = isSgModifierType(Y_element_type);

                         if (X_modifierType != NULL && X_modifierType == Y_modifierType)
                            {
                              isSame = true;
                              exit = true;
#if 1
                              printf ("In SgModifierType::operator==(): loop: these are the same modifier type: isSame = %s \n",isSame ? "true" : "false");
#endif
                            }
                           else
                            {
                              if (X_modifierType != NULL || Y_modifierType != NULL)
                                 {
                                   if (X_modifierType != NULL && Y_modifierType != NULL)
                                      {
                                        if (X_modifierType->get_typeModifier() == Y_modifierType->get_typeModifier())
                                           {
                                             i++;
                                             j++;
                                           }
                                          else
                                           {
                                             isSame = false;
                                             exit = true;
#if 1
                                             printf ("In SgModifierType::operator==(): loop: these are different modifier types: isSame = %s \n",isSame ? "true" : "false");
#endif
                                           }
                                      }
                                     else
                                      {
                                     // Skip past default modifiers.
                                        if (X_modifierType != NULL)
                                           {
                                             if (X_modifierType->get_typeModifier().isDefault() == true)
                                                {
                                                  i++;
                                                }
                                               else
                                                {
                                                  isSame = false;
                                                  exit = true;
#if 1
                                                  printf ("In SgModifierType::operator==(): loop: X is a non-default modifier type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                                }
                                           }
                                          else
                                           {
                                             isSame = false;
                                             exit = true;
#if 1
                                             printf ("In SgModifierType::operator==(): loop: X_element_type is not a modifier: X_element_type = %p = %s \n",X_element_type,X_element_type->class_name().c_str());
#endif
                                           }

                                     // Skip past default modifiers.
                                        if (Y_modifierType != NULL)
                                           {
                                             if (Y_modifierType->get_typeModifier().isDefault() == true)
                                                {
                                                  j++;
                                                }
                                               else
                                                {
                                                  isSame = false;
                                                  exit = true;
#if 1
                                                  printf ("In SgModifierType::operator==(): loop: Y is a non-default modifier type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                                }
                                           }
                                          else
                                           {
                                             isSame = false;
                                             exit = true;
#if 1
                                             printf ("In SgModifierType::operator==(): loop: Y_element_type is not a modifier: Y_element_type = %p = %s \n",Y_element_type,Y_element_type->class_name().c_str());
#endif
                                           }
                                      }
                                 }
                                else
                                 {
                                // if (X_typedefType != NULL || Y_typedefType != NULL)
                                // if (X_modifierType == NULL && Y_modifierType == NULL)
                                // if (X_typedefType == NULL && Y_typedefType == NULL && X_modifierType == NULL && Y_modifierType == NULL) 
                                   if ( (X_typedefType == NULL && X_modifierType == NULL) || (Y_typedefType == NULL && Y_modifierType == NULL) ) 
                                      {
#if 0
                                        printf ("In SgModifierType::operator==(): loop: one of both are neither a typedef or modifier type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                        if (X_element_type == Y_element_type)
                                           {
                                             isSame = true;
                                             exit = true;
#if 1
                                             printf ("In SgModifierType::operator==(): loop: X_element_type == Y_element_type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                           }
                                          else
                                           {
                                             isSame = false;
                                             exit = true;
#if 1
                                             printf ("In SgModifierType::operator==(): loop: X_element_type != Y_element_type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                           }
                                      }
#if 0
                                     else
                                      {
#if 1
                                        printf ("In SgModifierType::operator==(): loop: both of them are not a modifier or typedef type: isSame = %s \n",isSame ? "true" : "false");
#endif
                                        if (X_modifierType == NULL || Y_modifierType == NULL)
                                           {
                                           }
                                      }
#endif
                                 }
                            }
                       }
                  }
             }

       // Use a counter to avoid long type chains while we debug this code.
          counter++;
        }
#endif
#if 1
     printf ("In SgModifierType::operator==(): after using loop over type chains: isSame = %s \n",isSame ? "true" : "false");
#endif

#error "DEAD CODE!"

#if 0
     isSame = false;

  // SgType* X_type = X.get_base_type()->stripType();
  // SgType* Y_type = Y.get_base_type()->stripType();
  // SgType* X_type = X.get_base_type()->stripType( STRIP_MODIFIER_TYPE | STRIP_TYPEDEF_TYPE );
  // SgType* Y_type = Y.get_base_type()->stripType( STRIP_MODIFIER_TYPE | STRIP_TYPEDEF_TYPE );
     SgType* X_type = X.get_base_type()->stripType( STRIP_TYPEDEF_TYPE );
     SgType* Y_type = Y.get_base_type()->stripType( STRIP_TYPEDEF_TYPE );

     ROSE_ASSERT(X_type != NULL);
     ROSE_ASSERT(Y_type != NULL);

#if 1
     printf ("In SgModifierType::operator==(): base_type X = %p = %s Y = %p = %s \n",X.get_base_type(),X.get_base_type()->class_name().c_str(),Y.get_base_type(),Y.get_base_type()->class_name().c_str());
     printf ("   --- stripped base types: X = %p = %s Y = %p = %s \n",X_type,X_type->class_name().c_str(),Y_type,Y_type->class_name().c_str());
#endif

  // if (X.get_base_type() == Y.get_base_type())
     if (X_type == Y_type)
        {
#if 1
          printf ("In SgModifierType::operator==(): base_type are the same: get_base_type() = %p = %s \n",X.get_base_type(),X.get_base_type()->class_name().c_str());
          X.get_typeModifier().display("In SgModifierType::operator==()");
          Y.get_typeModifier().display("In SgModifierType::operator==()");
#endif
          if (X.get_typeModifier() == Y.get_typeModifier())
             {
#if 1
               printf ("In SgModifierType::operator==(): internal typeModifiers are the same \n");
#endif
               isSame = true;
             }
        }
       else
        {
#if 0
          SgModifierType* X_modifier = isSgModifierType(X_type);
          SgModifierType* Y_modifier = isSgModifierType(Y_type);
          if (X_modifier->get_typeModifier().isDefault())
             {
               X_type = X_modifier->get_base_type();
             }
#endif
        }
#endif

#if 1
     printf ("In SgModifierType::operator==(): isSame = %s \n",isSame ? "true" : "false");
#endif

#error "DEAD CODE!"

     return isSame;
   }
#endif



#if 0
bool
SgModifierType::isSync() const
   {
  // CC++ specific modifier!
     return p_bitfield & m_sync;
   }

bool
SgModifierType::isGlobal() const
   { return p_bitfield & m_global; }
#endif
#if 0
void
SgModifierType::unsetSync()
   { p_bitfield &= ~m_sync; }

void
SgModifierType::setSync()
   {
  // DQ (12/7/2003): != is meaningless
  // p_bitfield != m_sync;
     p_bitfield |= m_sync;
   }

void
SgModifierType::unsetGlobal()
   { p_bitfield &= ~m_global; }

void
SgModifierType::setGlobal()
   {
  // DQ (12/7/2003): != is meaningless
  // p_bitfield != m_global;
     p_bitfield |= m_global;
   }
#endif

#if 0
// Access the function at the lower level typeModifier, storageModifier, or accessModifier objects
bool $CLASSNAME::isRestrict() const    { return p_typeModifier.isRestrict(); }
bool $CLASSNAME::isConst() const       { return p_typeModifier.get_constVolatileModifier().isConst(); }
bool $CLASSNAME::isVolatile() const    { return p_typeModifier.get_constVolatileModifier().isVolatile(); }
bool $CLASSNAME::isUPC_Shared() const  { return p_typeModifier.get_upcModifier().isUPC_Shared(); }
bool $CLASSNAME::isUPC_Strict() const  { return p_typeModifier.get_upcModifier().isUPC_Strict(); }
bool $CLASSNAME::isUPC_Relaxed() const { return p_typeModifier.get_upcModifier().isUPC_Relaxed(); }

void $CLASSNAME::unsetRestrict()    { p_typeModifier.unsetRestrict(); }
void $CLASSNAME::setRestrict()      { p_typeModifier.setRestrict(); }
#endif

#if 0
void $CLASSNAME::unsetConst()       { p_typeModifier.get_constVolatileModifier().unsetConst(); }
void $CLASSNAME::setConst()         { p_typeModifier.get_constVolatileModifier().setConst();   }
void $CLASSNAME::unsetVolatile()    { p_typeModifier.get_constVolatileModifier().unsetVolatile(); }
void $CLASSNAME::setVolatile()      { p_typeModifier.get_constVolatileModifier().setVolatile();   }
void $CLASSNAME::unsetUPC_Shared()  { p_typeModifier.get_upcModifier().unsetUPC_Shared(); }
void $CLASSNAME::setUPC_Shared()    { p_typeModifier.get_upcModifier().setUPC_Shared(); }
void $CLASSNAME::unsetUPC_Strict()  { p_typeModifier.get_upcModifier().unsetUPC_Strict(); }
void $CLASSNAME::setUPC_Strict()    { p_typeModifier.get_upcModifier().setUPC_Strict(); }
void $CLASSNAME::unsetUPC_Relaxed() { p_typeModifier.get_upcModifier().unsetUPC_Relaxed(); }
void $CLASSNAME::setUPC_Relaxed()   { p_typeModifier.get_upcModifier().setUPC_Relaxed(); }
#endif

#if 0
bool $CLASSNAME::isExtern() const      { return p_storageModifier.isExtern(); }
bool $CLASSNAME::isStatic() const      { return p_storageModifier.isStatic(); }
bool $CLASSNAME::isAuto() const        { return p_storageModifier.isAuto(); }
bool $CLASSNAME::isUnspecified() const { return p_storageModifier.isUnspecified(); }
bool $CLASSNAME::isTypedef() const     { return p_storageModifier.isTypedef(); }
bool $CLASSNAME::isRegister() const    { return p_storageModifier.isRegister(); }
bool $CLASSNAME::isAsm() const         { return p_storageModifier.isAsm(); }
bool $CLASSNAME::isVirtual() const     { return p_accessModifier.isVirtual(); }
bool $CLASSNAME::isProtected() const   { return p_accessModifier.isProtected(); }
bool $CLASSNAME::isPrivate() const     { return p_accessModifier.isPrivate(); }
bool $CLASSNAME::isPublic() const      { return p_accessModifier.isPublic(); }

void $CLASSNAME::setExtern()        { p_storageModifier.setExtern(); }
void $CLASSNAME::setStatic()        { p_storageModifier.setStatic(); }
void $CLASSNAME::setAuto()          { p_storageModifier.setAuto();   }
void $CLASSNAME::setUnspecified()   { p_storageModifier.setUnspecified(); }
void $CLASSNAME::setTypedef()       { p_storageModifier.setTypedef(); }
void $CLASSNAME::setRegister()      { p_storageModifier.setRegister(); }
void $CLASSNAME::setAsm()           { p_storageModifier.setAsm(); }
void $CLASSNAME::setPrivate()       { p_accessModifier.setPrivate(); }
void $CLASSNAME::setProtected()     { p_accessModifier.setProtected(); }
void $CLASSNAME::setPublic()        { p_accessModifier.setPublic(); }
void $CLASSNAME::setVirtual()       { p_accessModifier.setVirtual(); }
#endif

#if 0
unsigned int
SgModifierType::bitfield(void)
   { return p_bitfield; }
#endif

// RV (1/31/2006): Removed dependence on SgUnparse_Info
SgName
SgModifierType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName mangled_name;

     const SgTypeModifier &          type_mod = get_typeModifier();
     const SgConstVolatileModifier & cv_mod   = type_mod.get_constVolatileModifier();
     const SgUPC_AccessModifier &    upc_mod  = type_mod.get_upcModifier();

     if (cv_mod.isConst())       mangled_name << "C";
     if (cv_mod.isVolatile())    mangled_name << "V";

  // DQ (4/22/2004): Removed support for CC++
  // if (isSync())        mangled_name << "SYN";
  // if (isGlobal())      mangled_name << "GLB";
     if (type_mod.isRestrict())    mangled_name << "RST";
  // if (upc_mod.isUPC_Shared())  mangled_name << "SHD";

  // \pp make mangled name depend on blocksize
     if (upc_mod.get_isShared())
        {
          mangled_name << "SHD";

          std::stringstream sstr;
          long              blocksize = upc_mod.get_layout();
          ROSE_ASSERT(blocksize >= -2);

       // \pp just add the blocksize as string to the mangled name.
       //     The TypeTable implementation needs to differentiate types
       //     with different shared blocksize.
          sstr << blocksize;
          mangled_name << sstr.str();
        }

     if (upc_mod.isUPC_Strict())  mangled_name << "STR";
     if (upc_mod.isUPC_Relaxed()) mangled_name << "RLX";

     mangled_name << get_base_type()->get_mangled().str();

     return mangled_name;
   }

#if 0
// Older code
SgName
SgModifierType::get_mangled(SgUnparse_Info& info)
   {
     SgName tmp;
     if (get_typeModifier().get_constVolatileModifier().isConst())    tmp << "C";
     if (get_typeModifier().get_constVolatileModifier().isVolatile()) tmp << "V";
  // DQ (4/22/2004): Removed support for CC++
  // if (isSync())        tmp << "SYN";
  // if (isGlobal())      tmp << "GLB";
     if (get_typeModifier().isRestrict())                             tmp << "RST";
     if (get_typeModifier().get_upcModifier().isUPC_Shared())         tmp << "SHD";
     if (get_typeModifier().get_upcModifier().isUPC_Strict())         tmp << "STR";
     if (get_typeModifier().get_upcModifier().isUPC_Relaxed())        tmp << "RLX";

     tmp << get_base_type()->get_mangled(info).str();

     return tmp;
   }
#endif

// DQ (7/24/2010): Adding post_construction_initialization() function.
void
SgModifierType::post_construction_initialization()
   {
     ROSE_ASSERT(p_base_type != NULL);

  // DQ (7/24/2010): There can be a number of different types of modifiers for a given base type and
  // the SgModifierType contains a list of them.  But I don't think it is used!
     if (isSgModifierType(p_base_type) == NULL)
        {
          ROSE_ASSERT(p_base_type->get_modifiers() == NULL);
        }

  // The local reference to the SgModifierType should also be NULL.
  // ROSE_ASSERT(get_modifiers() == NULL);
   }

SOURCE_MODIFIER_TYPE_END


SOURCE_QUALIFIED_NAME_TYPE_START
// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgQualifiedNameType::p_defaultQualifiedNamePtrList;

SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgQualifiedNameType::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgQualifiedNameType::set_qualifiedNameList( const SgQualifiedNamePtrList & x )
   {
     p_qualifiedNameList = x;
   }

SgName
SgQualifiedNameType::get_prefix() const
   {
     SgName tmp;

#if 1
     SgQualifiedNamePtrList::const_iterator i = p_qualifiedNameList.begin();
     while(i != p_qualifiedNameList.end())
        {
          printf ("Found a qualified name \n");
          if (isSgGlobal((*i)->get_scope()) != NULL)
             {
               printf ("Output the global scope qualifier \n");
               tmp << "::";
             }
            else
             {
            // Use the generated name until we are ready to select between generated or stored qualified names
               printf ("Use the generated name until we are ready to select between generated or stored qualified names \n");
             }
          i++;
        }
#else
     printf ("Error: SgQualifiedNameType::get_prefix() not used! \n");
     ROSE_ASSERT(false);
#endif

     return tmp;
   }

#if 1
// SgName $CLASSNAME::get_mangled (SgUnparse_Info & info)
SgName
SgQualifiedNameType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

     SgName tmp;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // info.set_name();
  // printf ("In $CLASSNAME::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled (SgNO_UNPARSE_INFO);

  // printf ("WARNING: The generated name in SgQualifiedNameType::get_mangled() should use a prefix generated from mangled names \n");

#if 1
  // SgName qualifiedName = get_prefix();

  // tmp << qualifiedName.str() << get_base_type()->get_mangled(info).str();

  // DQ (10/10/2006): The base_type should be fully qualified before mangling, so I don't think we need the prefix!
  // tmp << qualifiedName.str() << get_base_type()->get_mangled().str();
     tmp << "qualified_name_" << get_base_type()->get_mangled().str();
#else
     printf ("Error: SgQualifiedNameType::get_mangled() not used! \n");
     ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif

SOURCE_QUALIFIED_NAME_TYPE_END


SOURCE_FUNCTION_TYPE_START

// Specialized constructor
SgFunctionType::SgFunctionType(SgPartialFunctionType *ft)
   {
     assert(ft != NULL);
     p_return_type      = ft->p_return_type;
     p_has_ellipses     = ft->p_has_ellipses;

  // DQ (12/13/2012): We have to set this to NULL since it is checked in the call to post_construction_initialization().
     p_argument_list = NULL;

#if 0
     p_orig_return_type = ft->p_return_type;

  // DQ (6/25/2006): Handle the allocation of the SgFunctionParameterTypeList in one place if possible!
  // This is part of debugging the AST File I/O.

  /* process argument type */
     p_argument_list = new SgFunctionParameterTypeList();
     ROSE_ASSERT(p_argument_list != NULL);

  // DQ (5/11/2006): Set the parent to avoid having NULL pointers
     p_argument_list->set_parent(this);
#else
     post_construction_initialization();
#endif

     SgTypePtrList::iterator p = ft->get_arguments().begin();
  // printf ("PartialFunctionType->get_arguments().size() = %" PRIuPTR " \n",ft->get_arguments().size());
     while(p != ft->get_arguments().end())
        {
       // printf ("     function argument = %p = %s \n",*p,(*p)->sage_class_name());
          append_argument((*p));
          p++;
        }
   }

void
SgFunctionType::post_construction_initialization ()
   {
     p_orig_return_type = NULL;

  // DQ (12/6/2012): Added assertion.
     ROSE_ASSERT(p_argument_list == NULL);

     p_argument_list = new SgFunctionParameterTypeList();
     ROSE_ASSERT(p_argument_list != NULL);

  // DQ (6/25/2006): Commented out to allow File I/O to work, I don't understand why it is required!
  // DQ (5/11/2006): Set the parent to avoid having NULL pointers
     p_argument_list->set_parent(this);

  // DQ (6/22/2006): Initialize the orig_return_type
     ROSE_ASSERT(p_return_type != NULL);
     set_orig_return_type(p_return_type);
     ROSE_ASSERT(p_orig_return_type != NULL);

   }

const SgTypePtrList &
SgFunctionType::get_arguments() const
   { return p_argument_list->get_arguments(); }

SgTypePtrList &
SgFunctionType::get_arguments()
   { return p_argument_list->get_arguments(); }

void
SgFunctionType::append_argument( SgType* what)
   {
    p_argument_list->append_argument(what);
   }

void
SgFunctionType::insert_argument(const SgTypePtrList::iterator& where, SgType* what)
   {
     p_argument_list->insert_argument(where,what);
   }

SgName
SgFunctionType::get_mangled(SgType* ret_type, SgFunctionParameterTypeList * typeList) 
   {
  // Note that this is a static member function.
#if 0
     printf ("In SgFunctionType::get_mangled(SgType*,SgFunctionParameterTypeList*): TOP \n");
#endif

  // process argument type
     SgName arg_names;
     if (typeList != NULL)
        {
          const SgTypePtrList & args = typeList->get_arguments ();
          arg_names = mangleTypes (args.begin (), args.end ());
        }

#if 0
     printf ("In SgFunctionType::get_mangled(SgType*,SgFunctionParameterTypeList*): arg_names = %s \n",arg_names.str());
#endif

#if 0
     printf ("In SgFunctionType::get_mangled(SgType*,SgFunctionParameterTypeList*): ret_type = %p (%s) \n",ret_type, ret_type->class_name().c_str());
#endif

  // process return type
     ROSE_ASSERT (ret_type != NULL);
     SgName ret_name = ret_type->get_mangled();

#if 0
     printf ("In SgFunctionType::get_mangled(SgType*,SgFunctionParameterTypeList*): ret_name = %s \n",ret_name.str());
#endif

  // Build complete mangled name
     SgName mangled_name;
     mangled_name << "_Fb_" // begin function signature
                  << ret_name.str () // return type
                  << "_Gb_" // argument list begin
                  << arg_names.str () // argument types
                  << "_Fe_"; // end function signature

#if 0
     printf ("Leaving SgFunctionType::get_mangled(SgType*,SgFunctionParameterTypeList*): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

// RV (1/31/2006): Changed the form of the mangled name.
SgName
SgFunctionType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

  // TV (04/19/2011): I outlined the mangling of function type in a static function to avoid
  // building of a function type in 'SageBuilder::buildFunctionType' (This was used
  // to do a search in 'globalFunctionTypeTable')
  // return get_mangled(get_return_type(), get_argument_list());

     SgName name = get_mangled(get_return_type(), get_argument_list());

#if 0
     printf ("In SgFunctionType::get_mangled(void): name = %s \n",name.str());
#endif

     return name;
   }


#if 0
// virtual SgName SgFunctionType::get_mangled_name ( SgUnparse_Info & info );
SgName
SgFunctionType::get_mangled_name(SgUnparse_Info& info)
   {
     SgName rtmp;
  // SgDeclarationStatement *dstmt = info.get_decl_stmt();
     SgFunctionDeclaration *dstmt = isSgFunctionDeclaration(info.get_decl_stmt());
     ROSE_ASSERT (dstmt != NULL);
     SgName fname = info.get_name();

  // int len = strlen(fname.str());
  // SgName tmp(fname);
  // char *opstr  = "operator";
  // char *newstr = "new";
  // char *delstr = "delete";
  // int m = strlen(opstr);

#if 0
     printf ("In SgFunctionType::get_mangled_name(): fname = %s \n",fname.str());
     printf ("     unused function qualified name = %s \n",dstmt->get_qualified_name().str());
#endif

#if 0
  // DQ (4/28/2005): These should be false since this is not a member function
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isConstructor() == false);
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isConversion()  == false);
     ROSE_ASSERT(dstmt->get_specialFunctionModifier().isDestructor()  == false);

  // DQ (4/29/2005): This is all that we need since non-member function can never be
  // constructor, destructors, or conversion operators.
     rtmp = mangledNameSupport(fname,info);
#else
     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor()) rtmp << "__dt";
            else
               if (dstmt->get_specialFunctionModifier().isConversion())
                  {
                    rtmp << "__conversion__";
                 // rtmp = mangledNameSupport(fname,info);
                  }
                 else
                  {
                 // These are just normal functions
                 // ROSE_ASSERT (dstmt->get_specialFunctionModifier().isOperator());
                    rtmp = mangledNameSupport(fname,info);
                  }
#endif

     string mangledName = rtmp.str();
     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

#if 0
     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor())
               rtmp << "__dt";
            else
#if 1
             {
               rtmp = mangledNameSupport(fname,info);
             }
#else
               if (len > 0 && strncmp(fname.str(),opstr,m) == 0)
                  {
                    if (fname.str()[m]==' ')
                       {
                      // DQ (4/27/2005): "m+2" should be "m+1"
                         if (strncmp(&(fname.str()[m+1]),newstr,strlen(newstr)) == 0)
                            {
                           // DQ (4/27/2005): Added support for array new
                              int newStringLength = strlen(newstr);
                              int parenStart = m+1+newStringLength;
                              if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                   rtmp << "__na";
                                else
                                   rtmp << "__nw";
                            }
                           else
                            {
                           // DQ (4/27/2005): Added support for array delete
                              if (strncmp(&(fname.str()[m+1]),delstr,strlen(delstr)) == 0)
                                 {
                                   int deleteStringLength = strlen(delstr);
                                   int parenStart = m+1+deleteStringLength;
                                   if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                        rtmp << "__da";
                                     else
                                        rtmp << "__dl";
                                 }
                                else
                                 {
                                // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
                                 }
                            }
                       }
                      else
                       {
                      // real operator
                         SgName opname=&(fname.str()[m]);
                         if(opname==SgName("->"))        rtmp << "__rf";
                         else if (opname==SgName("->*")) rtmp << "__rm";
                         else if (opname==SgName("=="))  rtmp << "__eq";
                         else if (opname==SgName("<"))   rtmp << "__lt";
                         else if (opname==SgName(">"))   rtmp << "__gt";
                         else if (opname==SgName("!="))  rtmp << "__ne";
                         else if (opname==SgName("<="))  rtmp << "__le";
                         else if (opname==SgName(">="))  rtmp << "__ge";
                         else if (opname==SgName("+"))   rtmp << "__pl";
                         else if (opname==SgName("-"))   rtmp << "__mi";
                         else if (opname==SgName("*"))   rtmp << "__ml";
                         else if (opname==SgName("/"))   rtmp << "__dv";
                         else if (opname==SgName("%"))   rtmp << "__md";
                         else if (opname==SgName("&&"))  rtmp << "__aa";
                         else if (opname==SgName("!"))   rtmp << "__nt";
                         else if (opname==SgName("||"))  rtmp << "__oo";
                         else if (opname==SgName("^"))   rtmp << "__er";
                         else if (opname==SgName("&"))   rtmp << "__ad";
                         else if (opname==SgName("|"))   rtmp << "__or";
                         else if (opname==SgName(","))   rtmp << "__cm";
                         else if (opname==SgName("<<"))  rtmp << "__ls";
                         else if (opname==SgName(">>"))  rtmp << "__rs";
                         else if (opname==SgName("--"))  rtmp << "__mm";
                         else if (opname==SgName("++"))  rtmp << "__pp";
                         else if (opname==SgName("~"))   rtmp << "__co";
                         else if (opname==SgName("="))   rtmp << "__as";
                         else if (opname==SgName("+="))  rtmp << "__apl";
                         else if (opname==SgName("-="))  rtmp << "__ami";
                         else if (opname==SgName("&="))  rtmp << "__aad";
                         else if (opname==SgName("|="))  rtmp << "__aor";
                         else if (opname==SgName("*="))  rtmp << "__amu";
                         else if (opname==SgName("/="))  rtmp << "__adv";
                         else if (opname==SgName("%="))  rtmp << "__amd";
                         else if (opname==SgName("^="))  rtmp << "__aer";
                         else if (opname==SgName("<<=")) rtmp << "__als";
                         else if (opname==SgName(">>=")) rtmp << "__ars";
                         else if (opname==SgName("()"))  rtmp << "__cl";
                         else if (opname==SgName("[]"))  rtmp << "__xi";
                         else
                            {
                              printf ("In SgFunctionType::get_mangled_name(): This case should never be reached (fname = %s) \n",fname.str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
                 else
                    rtmp << fname.str();
#endif
#endif

     return rtmp;
   }
#endif

#if 0
// Old code

// this routine can do 2 things,
// mangle a type - without funcname and class name(if member function)
// mangle a complete function declaration with name and class name
SgName
SgFunctionType::get_mangled(SgUnparse_Info & info)
   {
     SgName tmp;

  // printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&) info.PrintName() = %s \n",(info.PrintName() == true) ? "true" : "false");

  /* should have a name to start with */
     if (info.PrintName())
        {
       // DQ (6/23/2005): This path is taken for constructors, destructors and conversion operators (I think!)
       // SgName name = get_mangled_name(info);
       // printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): (assuming info.PrintName() == true): name = %s \n",name.str());
       // tmp << get_mangled_name(info).str();
          tmp << name.str();
        }

     tmp << "__";
     tmp << "F";

  /* process argument type */
     SgTypePtrList::iterator p = get_arguments().begin();
     while(p != get_arguments().end())
        {
          tmp << (*p)->get_mangled(info).str();

       // DQ (5/2/2005): Added to handle function arguments which are templates
          tmp = fixupTemplateNameForMangledNameSupport(tmp);

          p++;
        }

  /* process return type */
     SgName returnTypeName = get_return_type()->get_mangled(info);
  // tmp << "_" << get_return_type()->get_mangled(info).str();
     tmp << "_" << returnTypeName.str();

  // DQ (5/2/2005): Added to handle function arguments which are templates
     tmp = fixupTemplateNameForMangledNameSupport(tmp);

#if 0
     printf ("########## In SgFunctionType::get_mangled(): tmp = %s (returnTypeName = %s is a %s) ########## \n",
          tmp.str(),returnTypeName.str(),get_return_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif

//! \deprecated by RV (1/31/2006)
SgName
SgFunctionType::get_mangled_type ()
   {
     ROSE_ASSERT(this != NULL);
     return get_mangled();
   }

#if 0
SgName
SgFunctionType::get_mangled_type ()
   {
     SgUnparse_Info info;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // info.set_name();
  // printf ("In $CLASSNAME::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled (SgNO_UNPARSE_INFO);
     return get_mangled (info);
   }
#endif


// SgFunctionType* SgFunctionType::mkAnotherType(SgType *);
// void sym_print(ostream& os);

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgFunctionType::get_symbol_from_symbol_table() const
   {
     return SgNode::get_globalFunctionTypeTable()->get_function_type_table()->find(this);
   }

SOURCE_FUNCTION_TYPE_END


SOURCE_MEMBER_FUNCTION_TYPE_START

SgMemberFunctionType::SgMemberFunctionType ( SgPartialFunctionType* ft )
   : SgFunctionType(ft)
   {
     p_class_type      = ft->p_class_type ;
     p_mfunc_specifier = ft->p_mfunc_specifier;
   }

void
SgMemberFunctionType::post_construction_initialization()
   {
  // DQ (3/8/2012): We want to avoid resetting the data members (just set in the SgMemberFunctionType constructor).
#if 0
     printf ("In SgMemberFunctionType::post_construction_initialization(): avoid resetting the data members. \n");
#endif
  // p_class_type =0;

  // DQ (3/8/2012): We can't assert that this is true (likely because of how SgPartialFunctionType is used to build non-memb4r function types.
  // ROSE_ASSERT(p_class_type != NULL);

  // p_mfunc_specifier = 0;

  // DQ (3/8/2012): Since we are not including support for restrict in the function type, don't allow it to be set (basic testing).
  // If we discover that we need this then we will have to re-enable restrict support, else we can eliminate the e_restrict value
  // in the enum type (either way this will be an improvement).
  // ROSE_ASSERT((e_restrict && p_mfunc_specifier) == 0);

  // DQ (3/10/2012): If this is non-zero then the SgPartialFunctionType should have somethin set internally.
     if (p_mfunc_specifier != 0)
        {
#if 0
          printf ("In SgMemberFunctionType::post_construction_initialization(): p_mfunc_specifier = %u isConstFunc()    = %s \n",p_mfunc_specifier,isConstFunc()    ? "true" : "false");
          printf ("In SgMemberFunctionType::post_construction_initialization(): p_mfunc_specifier = %u isVolatileFunc() = %s \n",p_mfunc_specifier,isVolatileFunc() ? "true" : "false");
          printf ("In SgMemberFunctionType::post_construction_initialization(): p_mfunc_specifier = %u isRestrictFunc() = %s \n",p_mfunc_specifier,isRestrictFunc() ? "true" : "false");
#endif
       // DQ (1/9/2020): Adding support for reference qualification.
       // ROSE_ASSERT(partialFunctionType->isConstFunc() == true || partialFunctionType->isVolatileFunc() == true);
       // ROSE_ASSERT(isConstFunc() == true || isVolatileFunc() == true || isRestrictFunc() == true);
       // ROSE_ASSERT( (isConstFunc() == true) || (isVolatileFunc() == true) || (isRestrictFunc() == true) );
          ROSE_ASSERT( (isConstFunc() == true) || (isVolatileFunc() == true) || (isRestrictFunc() == true) || (isLvalueReferenceFunc() == true) || (isRvalueReferenceFunc() == true));
        }
   }

// static SgMemberFunctionType* createType(SgPartialFunctionType *);

// RV (2/1/2006): Made a 'const' member function.
bool
SgMemberFunctionType::isConstFunc() const
   { return (p_mfunc_specifier & e_const); }

void
SgMemberFunctionType::setConstFunc()
   { p_mfunc_specifier |= e_const; }

void
SgMemberFunctionType::unsetConstFunc()
   { p_mfunc_specifier &= ~e_const; }

// RV (2/1/2006): Made a 'volatile' member function.
bool
SgMemberFunctionType::isVolatileFunc() const
   { return (p_mfunc_specifier & e_volatile); }

void
SgMemberFunctionType::setVolatileFunc()
   { p_mfunc_specifier |= e_volatile; }

void
SgMemberFunctionType::unsetVolatileFunc()
   { p_mfunc_specifier &= ~e_volatile; }


// DQ (3/8/2012): Added support for restict on member function types.
bool
SgMemberFunctionType::isRestrictFunc() const
   { return (p_mfunc_specifier & e_restrict); }

void
SgMemberFunctionType::setRestrictFunc()
   { p_mfunc_specifier |= e_restrict; }

void
SgMemberFunctionType::unsetRestrictFunc()
   { p_mfunc_specifier &= ~e_restrict; }

// DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
// L-value reference access/set/unset member functions and member function type
bool
SgMemberFunctionType::isLvalueReferenceFunc() const
   { return (p_mfunc_specifier & e_ref_qualifier_lvalue); }

void
SgMemberFunctionType::setLvalueReferenceFunc()
   { p_mfunc_specifier |= e_ref_qualifier_lvalue; }

void
SgMemberFunctionType::unsetLvalueReferenceFunc()
   { p_mfunc_specifier &= ~e_ref_qualifier_lvalue; }


// DQ (1/9/2020): Enabled the use of reference qualification recorded in the function type.
// R-value reference access/set/unset member functions and member function type
bool
SgMemberFunctionType::isRvalueReferenceFunc() const
   { return (p_mfunc_specifier & e_ref_qualifier_rvalue); }

void
SgMemberFunctionType::setRvalueReferenceFunc()
   { p_mfunc_specifier |= e_ref_qualifier_rvalue; }

void
SgMemberFunctionType::unsetRvalueReferenceFunc()
   { p_mfunc_specifier &= ~e_ref_qualifier_rvalue; }



SgName
SgMemberFunctionType::get_mangled_name (void) const
   {
     ROSE_ASSERT(this != NULL);
     return get_mangled ();
   }


// DQ (12/6/2012): Adding member function specifier data (since this will be a part of the generated mangled name).
// SgName SgMemberFunctionType::get_mangled(SgType* ret_type, SgFunctionParameterTypeList * typeList, SgClassType* classType )
SgName SgMemberFunctionType::get_mangled(SgType* ret_type, SgFunctionParameterTypeList * typeList, SgType* classType, unsigned int mfunc_specifier )
   {
  // DQ (12/3/2011): Added this static function to simplify (refactor) how mangled names are generated).
  // The advantage of refactoring this code to a static function is that the managle name generated to
  // support the global function type table hash key could be generated more directly that what we do 
  // now (which is the generate a SgMemberFunctionType, call the get_mangled() function, and then delete
  // the newly built SgMemberFunctionType if the name is alread in the global function type table.

  // Unfortunaely, this function makes too many calls to non-static member functions, and thus would be
  // harder than expected to turn into a simple static function.

  // Member-function specific information (class name, const/volatile qualifiers).
     SgName mangled_cls_tag;

  // ROSE_ASSERT(classType != NULL);

  // Compute class scope
  //! \todo Figure out why member function types are sometimes used
  //! incorrectly in place of plain function types.
  // const SgType* cls_type = get_class_type();
     const SgType* cls_type = classType;
     if (cls_type != NULL)
        {
          SgName class_scope = cls_type->get_mangled();
          mangled_cls_tag += class_scope;
        }

     SgName mangled_name;

#if 0
  // DQ (12/3/2011): Because of these member function calls this can't be refactored to be a static function.
  // Append modifiers
     if (isConstFunc())
          mangled_cls_tag << "_cf";
     if (isVolatileFunc())
          mangled_cls_tag << "_vf";

  // Mangle the function type without qualifiers
     SgName basic_func_type = SgFunctionType::get_mangled();
#else
  // DQ (12/6/2012): New version of this function using the input parameter (mfunc_specifier) so that we can 
  // have this be a static member function.  The goal is to use this function to rewite the SageBuilder::buildMemberFunctionType()
  // to both be more clear and fix the handling of SgFunctionParameterTypeList which appears to be a problem for 
  // the AST File I/O and the graphs that we generate of the AST in the new EDG 4.x branch.

#if 0
     printf ("mfunc_specifier = %u SgMemberFunctionType::e_const = %d SgMemberFunctionType::e_volatile = %d SgMemberFunctionType::e_restrict = %d \n",
          mfunc_specifier,SgMemberFunctionType::e_const,SgMemberFunctionType::e_volatile,SgMemberFunctionType::e_restrict);
#endif

     if (mfunc_specifier & SgMemberFunctionType::e_const)
        {
       // Mark as const
          mangled_cls_tag << "_cf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_volatile)
        {
       // Mark as volatile
          mangled_cls_tag << "_vf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_restrict)
        {
       // Mark as restrict
          mangled_cls_tag << "_rf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_ref_qualifier_lvalue)
        {
       // Mark as restrict
          mangled_cls_tag << "_lvf";
        }

     if (mfunc_specifier & SgMemberFunctionType::e_ref_qualifier_rvalue)
        {
       // Mark as restrict
          mangled_cls_tag << "_rvf";
        }

  // DQ (12/6/2012): Now use the static function taking extra parameters.
  // Mangle the function type without qualifiers 
     SgName basic_func_type = SgFunctionType::get_mangled(ret_type,typeList);

#if 0
  // DQ (12/3/2011): If the data fro these non-static member fucntions were passed in as parameters it might be possible to refactor this code.
     printf ("This function can be used as a refactored version of SgMemberFunctionType::get_mangled(void) \n");
     ROSE_ASSERT(false);
#endif
#endif

  // Compute mangled member function pointer type
  // SgName mangled_name;
     if (mangled_cls_tag.get_length () > 0)
          mangled_name << "__MFb_" << mangled_cls_tag.str (); // really is a member function

     mangled_name << "_" << basic_func_type.str (); // Append standard argument signature.

     return mangled_name;
   }

// RV (1/31/2006): Changed form of mangling to include begin/end tags.
SgName
SgMemberFunctionType::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);

#if 1
  // Member-function specific information (class name, const/volatile qualifiers)
     SgName mangled_cls_tag;

  // Compute class scope
  //! \todo Figure out why member function types are sometimes used
  //! incorrectly in place of plain function types.
     const SgType* cls_type = get_class_type ();
     if (cls_type)
        {
          SgName class_scope = cls_type->get_mangled ();
          mangled_cls_tag += class_scope;
        }
#if 0
     printf ("In SgMemberFunctionType::get_mangled(): after class scope evaluation: mangled_cls_tag = %s \n",mangled_cls_tag.str());
#endif

  // DQ (12/3/2011): Because of these member function calls this can't be refactored to be a static function.
  // Append modifiers
     if (isConstFunc() == true)
          mangled_cls_tag << "_cf";
     if (isVolatileFunc() == true)
          mangled_cls_tag << "_vf";

  // DQ (3/8/2012): Added support for restrict on member function types.
     if (isRestrictFunc() == true)
          mangled_cls_tag << "_rf";

#if 0
     printf ("In SgMemberFunctionType::get_mangled(): after function modifier evaluation: mangled_cls_tag = %s \n",mangled_cls_tag.str());
#endif

  // Mangle the function type without qualifiers
     SgName basic_func_type = SgFunctionType::get_mangled();

#if 0
     printf ("In SgMemberFunctionType::get_mangled(): after call to SgFunctionType::get_mangled(): basic_func_type = %s \n",basic_func_type.str());
#endif

  // Compute mangled member function pointer type
     SgName mangled_name;
     if (mangled_cls_tag.get_length () > 0)
        {
          mangled_name << "__MFb_" << mangled_cls_tag.str(); // really is a member function
        }

#if 0
     printf ("In SgMemberFunctionType::get_mangled(): after mangled member function pointer type evaluation: mangled_cls_tag = %s \n",mangled_name.str());
#endif

     mangled_name << "_" << basic_func_type.str (); // Append standard argument signature.

#if 0
     printf ("In SgMemberFunctionType::get_mangled(): returning: mangled_name = %s \n",mangled_name.str());
#endif

#else
  // DQ (12/3/2011): Not sure how to construct this case...leaving the older code (unrefactored).
     SgMemberFunctionType::get_mangled(get_return_type(),get_argument_list(),get_class_type());
#endif

     return mangled_name;
   }


#if 0
SgName
SgMemberFunctionType::get_mangled_type()
   {
     SgUnparse_Info info;

  // DQ (6/23/2005): Get the name (and qualified name) of the type into the mangled name
  // printf ("In $CLASSNAME::get_mangled_type(): calling info.set_PrintName() \n");
  // info.set_PrintName();
  // ROSE_ASSERT(info.PrintName() == true);

  // return get_mangled(SgNO_UNPARSE_INFO);
     return get_mangled(info);
   }
#endif

#if 0
// SgMemberFunctionType::get_mangled_name(SgUnparse_Info&);

//! This function repreents the name mangleing support for unparsing
SgName
SgMemberFunctionType::get_mangled_name(SgUnparse_Info& info)
   {
     SgName rtmp;
  // SgDeclarationStatement *dstmt = info.get_decl_stmt();
     SgFunctionDeclaration *dstmt = isSgFunctionDeclaration(info.get_decl_stmt());
     ROSE_ASSERT (dstmt != NULL);
     SgName fname = info.get_name();

  // int len = strlen(fname.str());
  // SgName tmp(fname);
  // char *opstr  = "operator";
  // char *newstr = "new";
  // char *delstr = "delete";
  // int m = strlen(opstr);

  // printf ("In SgMemberFunctionType::get_mangled_name(): fname = %s \n",fname.str());

#if 0
  // ***** What about cast operators !!! *****
     if (dstmt->get_specialFunctionModifier().isConversion())
        {
          printf ("Found a conversion operator in $CLASSNAME::get_mangled_name \n");
        }

     if (dstmt->get_specialFunctionModifier().isOperator())
        {
          printf ("Found an operator in $CLASSNAME::get_mangled_name \n");
        }
#endif

     if (dstmt->get_specialFunctionModifier().isConstructor())
          rtmp << "__ct";
       else
          if (dstmt->get_specialFunctionModifier().isDestructor()) rtmp << "__dt";
            else
               if (dstmt->get_specialFunctionModifier().isConversion())
                  {
                    rtmp << "__conversion__";
                 // rtmp = mangledNameSupport(fname,info);
                  }
                 else
                  {
                 // These are just normal member functions
                 // ROSE_ASSERT (dstmt->get_specialFunctionModifier().isOperator());
                    rtmp = mangledNameSupport(fname,info);
                  }

     string mangledName = rtmp.str();
     ROSE_ASSERT (mangledName.find("<") == string::npos);
     ROSE_ASSERT (mangledName.find(">") == string::npos);

     ROSE_ASSERT(mangledName.find('`') == string::npos);
     ROSE_ASSERT(mangledName.find('~') == string::npos);
     ROSE_ASSERT(mangledName.find('!') == string::npos);
     ROSE_ASSERT(mangledName.find('@') == string::npos);
     ROSE_ASSERT(mangledName.find('#') == string::npos);
     ROSE_ASSERT(mangledName.find('$') == string::npos);
     ROSE_ASSERT(mangledName.find('%') == string::npos);
     ROSE_ASSERT(mangledName.find('^') == string::npos);
     ROSE_ASSERT(mangledName.find('&') == string::npos);
     ROSE_ASSERT(mangledName.find('*') == string::npos);
     ROSE_ASSERT(mangledName.find('(') == string::npos);
     ROSE_ASSERT(mangledName.find(')') == string::npos);
     ROSE_ASSERT(mangledName.find('-') == string::npos);
     ROSE_ASSERT(mangledName.find('+') == string::npos);
     ROSE_ASSERT(mangledName.find('=') == string::npos);
     ROSE_ASSERT(mangledName.find('{') == string::npos);
     ROSE_ASSERT(mangledName.find('}') == string::npos);
     ROSE_ASSERT(mangledName.find('[') == string::npos);
     ROSE_ASSERT(mangledName.find(']') == string::npos);
     ROSE_ASSERT(mangledName.find('|') == string::npos);
     ROSE_ASSERT(mangledName.find('\\') == string::npos);
     ROSE_ASSERT(mangledName.find(':') == string::npos);
     ROSE_ASSERT(mangledName.find(';') == string::npos);
     ROSE_ASSERT(mangledName.find('\"') == string::npos);
     ROSE_ASSERT(mangledName.find('\'') == string::npos);
     ROSE_ASSERT(mangledName.find('?') == string::npos);
     ROSE_ASSERT(mangledName.find('.') == string::npos);
     ROSE_ASSERT(mangledName.find('/') == string::npos);
     ROSE_ASSERT(mangledName.find(',') == string::npos);

  // These are the most common cases that fail
     ROSE_ASSERT(mangledName.find('<') == string::npos);
     ROSE_ASSERT(mangledName.find('>') == string::npos);

  // printf ("Leaving SgMemberFunctionType::get_mangled_name(): mangledName = %s \n",mangledName.c_str());

#if 0
            // This code has been refactored and place in a separate function: mangledNameSupport()
               if (len > 0 && strncmp(fname.str(),opstr,m)==0)
                  {
                    if (fname.str()[m]==' ')
                       {
#if 0
                         if (strncmp(&(fname.str()[m+2]),newstr,strlen(newstr)))
                              rtmp << "__nw";
                           else
                              if (strncmp(&(fname.str()[m+2]),delstr, strlen(delstr)))
                                   rtmp << "__dl";
                                else
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
#else
                      // DQ (4/27/2005): "m+2" should be "m+1"
                         if (strncmp(&(fname.str()[m+1]),newstr,strlen(newstr)) == 0)
                            {
                           // DQ (4/27/2005): Added support for array new
                              int newStringLength = strlen(newstr);
                              int parenStart = m+1+newStringLength;
                              if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                   rtmp << "__na";
                                else
                                   rtmp << "__nw";
                            }
                           else
                            {
                           // DQ (4/27/2005): Added support for array delete
                              if (strncmp(&(fname.str()[m+1]),delstr,strlen(delstr)) == 0)
                                 {
                                   int deleteStringLength = strlen(delstr);
                                   int parenStart = m+1+deleteStringLength;
                                   if (len > parenStart && strncmp(&(fname.str()[parenStart]),"[]",2) == 0)
                                        rtmp << "__da";
                                     else
                                        rtmp << "__dl";
                                 }
                                else
                                 {
                                // DQ (4/27/2005): Not clear where this is used (unless it is used in casting operators)!
                                   rtmp << "__op" << get_return_type()->get_mangled(info).str();
                                 }
                            }
#endif
                       }
                      else
                       {
                      // real operator
                         SgName opname=&(fname.str()[m]);
                         if (opname==SgName("->"))       rtmp << "__rf";
                         else if (opname==SgName("->*")) rtmp << "__rm";
                         else if (opname==SgName("=="))  rtmp << "__eq";
                         else if (opname==SgName("<"))   rtmp << "__lt";
                         else if (opname==SgName(">"))   rtmp << "__gt";
                         else if (opname==SgName("!="))  rtmp << "__ne";
                         else if (opname==SgName("<="))  rtmp << "__le";
                         else if (opname==SgName(">="))  rtmp << "__ge";
                         else if (opname==SgName("+"))   rtmp << "__pl";
                         else if (opname==SgName("-"))   rtmp << "__mi";
                         else if (opname==SgName("*"))   rtmp << "__ml";
                         else if (opname==SgName("/"))   rtmp << "__dv";
                         else if (opname==SgName("%"))   rtmp << "__md";
                         else if (opname==SgName("&&"))  rtmp << "__aa";
                         else if (opname==SgName("!"))   rtmp << "__nt";
                         else if (opname==SgName("||"))  rtmp << "__oo";
                         else if (opname==SgName("^"))   rtmp << "__er";
                         else if (opname==SgName("&"))   rtmp << "__ad";
                         else if (opname==SgName("|"))   rtmp << "__or";
                         else if (opname==SgName(","))   rtmp << "__cm";
                         else if (opname==SgName("<<"))  rtmp << "__ls";
                         else if (opname==SgName(">>"))  rtmp << "__rs";
                         else if (opname==SgName("--"))  rtmp << "__mm";
                         else if (opname==SgName("++"))  rtmp << "__pp";
                         else if (opname==SgName("~"))   rtmp << "__co";
                         else if (opname==SgName("="))   rtmp << "__as";
                         else if (opname==SgName("+="))  rtmp << "__apl";
                         else if (opname==SgName("-="))  rtmp << "__ami";
                         else if (opname==SgName("&="))  rtmp << "__aad";
                         else if (opname==SgName("|="))  rtmp << "__aor";
                         else if (opname==SgName("*="))  rtmp << "__amu";
                         else if (opname==SgName("/="))  rtmp << "__adv";
                         else if (opname==SgName("%="))  rtmp << "__amd";
                         else if (opname==SgName("^="))  rtmp << "__aer";
                         else if (opname==SgName("<<=")) rtmp << "__als";
                         else if (opname==SgName(">>=")) rtmp << "__ars";
                         else if (opname==SgName("()"))  rtmp << "__cl";
                         else if (opname==SgName("[]"))  rtmp << "__xi";
                         else
                            {
                              printf ("In SgMemberFunctionType::get_mangled_name(): This case should never be reached (fname = %s) \n",fname.str());
                              ROSE_ASSERT(false);
                            }
                       }
                  }
                 else
                    rtmp << fname.str();
#endif

     return rtmp;
   }
#endif

#if 0
//! This function repreents the name mangling support for unparsing
/*! this routine can do 2 things,
    mangle a type with class name - without funcname
    mangle a complete function declaration with name and class name
 */
SgName
SgMemberFunctionType::get_mangled(SgUnparse_Info & info)
   {
     SgName tmp;

  // printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&) info.PrintName() = %s \n",(info.PrintName() == true) ? "true" : "false");

  /* should have a name to start with */
     if (info.PrintName())
        {
       // DQ (6/23/2005): This path is taken for constructors, destructors and conversion operators (I think!)
       // tmp << get_mangled_name(info).str();
       // SgName name = get_mangled_name(info);
       // printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): (assuming info.PrintName() == true): name = %s \n",name.str());
          tmp << name.str();
        }
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): #1 tmp = %s \n",tmp.str());
#endif
     tmp << "__";
  // if(info.PrintName()) { // only if needs to print name
     if (p_struct_name != NULL)
        {
       // a member function
          int cnt=0;
          SgName p_nm = p_struct_name->get_mangled_qualified_name(cnt);
          if(cnt>1)
               tmp << "Q" << cnt << p_nm.str();
            else
               tmp << p_nm.str();
        }
     // }
     tmp << "F";
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): #2 tmp = %s \n",tmp.str());
#endif
  /* process argument type */
     SgTypePtrList::iterator p = get_arguments().begin();
     while (p != get_arguments().end())
        {
          tmp << (*p)->get_mangled(info).str();

       // DQ (5/2/2005): Added to handle function arguments which are templates
          tmp = fixupTemplateNameForMangledNameSupport(tmp);

          p++;
        }
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): #3 tmp = %s \n",tmp.str());
#endif
  /* process return type */
     SgName returnTypeName = get_return_type()->get_mangled(info);
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): get_return_type() = %s returnTypeName = %s \n",
          get_return_type()->sage_class_name(),returnTypeName.str());
#endif

     returnTypeName = fixupTemplateNameForMangledNameSupport(returnTypeName);
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): #4 tmp = %s \n",tmp.str());
#endif
  // tmp << "_" << get_return_type()->get_mangled(info).str();
     tmp << "_" << returnTypeName.str();

     if (isConstFunc())
          tmp << "_cf";

     if (isVolatileFunc())
          tmp << "_vf";
#if 0
     printf ("In $CLASSNAME::get_mangled(SgUnparse_Info&): #5 tmp = %s \n",tmp.str());
#endif
#if 0
     printf ("###########  In SgMemberFunctionType::get_mangled(): tmp = %s (returnTypeName = %s is a %s) ########## \n",
          tmp.str(),returnTypeName.str(),get_return_type()->sage_class_name());
  // ROSE_ASSERT(false);
#endif

     return tmp;
   }
#endif


// SgMemberFunctionType * mkAnotherType(SgType *);
SgMemberFunctionType *
SgMemberFunctionType::mkAnotherType(SgType *rtype)
   {
     if (rtype == get_return_type())
          return NULL;

     SgPartialFunctionType *part_type = SgPartialFunctionType::createType(rtype);

  /* process argument type */
     SgTypePtrList::iterator p = this->get_arguments().begin();
     while (p != this->get_arguments().end())
        {
          part_type->append_argument((*p));
          p++;
        }
     part_type->set_class_type(this->get_class_type());
     part_type->set_mfunc_specifier(this->get_mfunc_specifier());

     SgMemberFunctionType *ntype = SgMemberFunctionType::createType(part_type);
     if (ntype == this)
          return NULL;
       else
          return ntype;
   }

// PC (10/29/2009): Deprecated compatibility routine for those still using get_struct_name()
SgClassDefinition*
SgMemberFunctionType::get_struct_name() const
   {
     if (get_class_type() == NULL)
          return NULL;
     SgClassType *clsType = isSgClassType(get_class_type()->stripTypedefsAndModifiers());
     ROSE_ASSERT(clsType != NULL);
     SgClassDeclaration *clsDecl = isSgClassDeclaration(clsType->get_declaration()->get_definingDeclaration());
     ROSE_ASSERT(clsDecl != NULL);
     return clsDecl->get_definition();
   }


SOURCE_MEMBER_FUNCTION_TYPE_END


SOURCE_PARTIAL_FUNCTION_TYPE_START
//! This is an empty function (no data to initialize)
void
SgPartialFunctionType::post_construction_initialization ()
   {
   }

SOURCE_PARTIAL_FUNCTION_TYPE_END


SOURCE_ARRAY_TYPE_START

#if 1
// DQ (3/22/2017): I would like to remove this function if possible (it is not sufficiently general).
// Note that this is used within ROSE (which might be worth checking out in more detail later).
SgName
SgArrayType::get_name(void) const {
    string dimensions = "[]";
    SgType *type = p_base_type;

    for (SgArrayType *array_type = isSgArrayType(type); array_type; array_type = isSgArrayType(type)) 
    {
        dimensions += "[]";
        type = array_type -> get_base_type();
    }

    string name;
    if (isSgTypeBool(type)) {
        name = "boolean";
    }
    else if (isSgTypeSignedChar(type)) {
        name = "byte";
    }
    else if (isSgTypeWchar(type)) {
        name = "char";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar16(type)) {
        name = "char16";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar32(type)) {
        name = "char32";
    }
    else if (isSgTypeInt(type)) {
        name = "int";
    }
    else if (isSgTypeShort(type)) {
        name = "short";
    }
    else if (isSgTypeFloat(type)) {
        name = "float";
    }
    else if (isSgTypeLong(type)) {
        name = "long";
    }
    else if (isSgTypeDouble(type)) {
        name = "double";
    }
    else if (isSgTypeVoid(type)) {
        name = "void";
    }
    else if (isSgTypeString(type)) {
        name = "String";
    }
    else 
    { 
   // DQ (3/19/2016): Klocworks reports this as an issue because the result of the 2nd call to isSgNamedType() 
   // is not clearly the same result as the first call.  The fix is to just make a single call and save the result.
   // if (isSgNamedType(type)) 
      SgNamedType* namedType = isSgNamedType(type);
      if (namedType != NULL) 
         {
        // name = isSgNamedType(type) -> get_name().getString();
           name = namedType -> get_name().getString();
         }
    }

    name += dimensions;

    return SgName(name);
}
#endif

SgName
SgArrayType::get_qualified_name(void) const {
    string dimensions = "[]";
    SgType *type = p_base_type;

    for (SgArrayType *array_type = isSgArrayType(type); array_type; array_type = isSgArrayType(type)) 
    {
        dimensions += "[]";
        type = array_type -> get_base_type();
    }

    string name;
    if (isSgTypeBool(type)) {
        name = "boolean";
    }
    else if (isSgTypeSignedChar(type)) {
        name = "byte";
    }
    else if (isSgTypeWchar(type)) {
        name = "char";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar16(type)) {
        name = "char16";
    }
 // DQ (2/16/2018): Adding support for char16_t and char32_t (C99 and C++11 specific types).
    else if (isSgTypeChar32(type)) {
        name = "char32";
    }
    else if (isSgTypeInt(type)) {
        name = "int";
    }
    else if (isSgTypeShort(type)) {
        name = "short";
    }
    else if (isSgTypeFloat(type)) {
        name = "float";
    }
    else if (isSgTypeLong(type)) {
        name = "long";
    }
    else if (isSgTypeDouble(type)) {
        name = "double";
    }
    else if (isSgTypeVoid(type)) {
        name = "void";
    }
    else if (isSgTypeString(type)) {
        name = "String";
    }
    else 
    {
   // DQ (3/19/2016): Klocworks reports this as an issue because the result of the 2nd call to isSgNamedType() 
   // is not clearly the same result as the first call.  The fix is to just make a single call and save the result.
   // if (isSgNamedType(type)) 
      SgNamedType* namedType = isSgNamedType(type);
      if (namedType != NULL) 
         {
        // name = isSgNamedType(type) -> get_qualified_name().getString();
           name = namedType -> get_qualified_name().getString();
         }
    }

    name += dimensions;

    return SgName(name);
}

// DQ (6/13/2015): Added forward declaration of namespace function for constant folding.
namespace ConstantFolding 
   {
  // ROSE_DLL_API void constantFoldingOptimization(SgNode* n, bool internalTestingAgainstFrontend = false);
     ROSE_DLL_API SgValueExp* returnConstantFoldedValueExpression(SgNode* n, bool internalTestingAgainstFrontend = false);
   }

// RV (1/31/2006): Changed the form of the mangled name to include begin/end tags.
SgName
SgArrayType::get_mangled(void) const
   {
     ROSE_ASSERT(this != NULL);

     const SgType* base_type = get_base_type();
     ROSE_ASSERT (base_type != NULL);
     SgName base_name = base_type->get_mangled();

#define DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING 0

#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
     printf ("In SgArrayType::get_mangled(): mangled base type name = %s \n",base_name.str());
#endif

  // DQ (2/14/2016): Adding support for variable length arrays.
     const bool is_variable_length_array = this->get_is_variable_length_array();

#if 0
     printf ("In SgArrayType::get_mangled(): is_variable_length_array = %s \n",is_variable_length_array ? "true" : "false");
#endif

     const SgExpression* index_exp = get_index();
     SgName index_name;
     if (index_exp != NULL)
        {
       // DQ (2/12/2011): Now that we support saving the original expression in an array type's size argument 
       // we want to generate the name from the constant folded expression instead of the original expression.
       // index_name = index_exp->unparseToString();
       // printf ("In SgArrayType::get_mangled(): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());
       // SgUnsignedLongVal* value = isSgUnsignedLongVal(index_exp);

       // DQ (9/23/2015): This code is important to the passing of test2015_78.C for both C++98 and C++11 modes.
       //    In C++98 mode a cast is not present and we see a SgIntVal expression, where as for C++11 mode we see a SgUnsignedLongVal expression.
       //    The result was that the variable "value" below was either NULL or non-NULL and the ROSE AST was different for for C++98 as for C++11.
       //    This is important for the Intel C++ compiler (version 14) because it defaults to C++11 instead of C++98.
       //    Forcing the false branch below does at least make the C++98 and C++11 modes uniform, and allows the test code to now pass uniformally 
       //    for both C++98 and C++11 modes, but does not really fix the problem well.  We want to where ever possible evaluate the expression to 
       //    a constant value literal, but this is part of a seperate issue specific to use of expressions in array bounds (test2015_.C).

       // DQ (6/13/2015): Changed from SgUnsignedLongVal to SgValueExp.  Or maybe we need to test for more general case where we handle the contant folding case below.
       // const SgValueExp* value = isSgUnsignedLongVal(index_exp);
       // const SgValueExp* value = isSgValueExp(index_exp);
       // const SgValueExp* value = isSgUnsignedLongVal(index_exp);
       // const SgValueExp* value = isSgValueExp(index_exp);
          const SgValueExp* value = NULL;

       // DQ (2/12/2011): I wonder if we can enforce this...No!
       // ROSE_ASSERT(value != NULL);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
          printf ("In SgArrayType::get_mangled() index_exp = %p = %s value = %p \n",index_exp,index_exp->class_name().c_str(),value);
#endif
          if (value != NULL)
             {
            // index_name = StringUtility::numberToString(value->get_value());
            // printf ("In SgArrayType::get_mangled() (special case of index as numberToString): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());

               index_name = value->get_constant_folded_value_as_string().c_str();
#if 1
               printf ("In SgArrayType::get_mangled() (special case of index as get_constant_folded_value_as_string): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());
#endif
             }
            else
             {
            // DQ (1/27/2015): Debugging test2015_05.C.  Not clear if this handles the case were there 
            // might be a more complex array index expressions that could have the same name.
            // index_name = index_exp->unparseToString();
               const SgVarRefExp* varRefExp = isSgVarRefExp(index_exp);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
               printf ("In SgArrayType::get_mangled() varRefExp = %p \n",varRefExp);
#endif
               if (varRefExp != NULL)
                  {
                 // index_name = index_exp->unparseToString();
                    SgSymbol* index_symbol = varRefExp->get_symbol();
                    ROSE_ASSERT(index_symbol != NULL);
#if 0
                    printf ("In SgArrayType::createType(): index_symbol = %p = %s \n",index_symbol,index_symbol->class_name().c_str());
#endif
                    SgVariableSymbol* variableSymbol = isSgVariableSymbol(index_symbol);
                    SgInitializedName* index_declaration = variableSymbol->get_declaration();
                    ROSE_ASSERT(index_declaration != NULL);
#if 0
                    printf ("In SgArrayType::createType(): index_declaration = %p = %s \n",index_declaration,index_declaration->class_name().c_str());
#endif
#if 0
                    SgScopeStatement* associatedScope = index_declaration->get_scope();
                    ROSE_ASSERT(associatedScope != NULL);
#if 0
                    printf ("In SgArrayType::createType(): associatedScope = %p = %s \n",associatedScope,associatedScope->class_name().c_str());
#endif
                 // t = associatedScope->get_type_table()->lookup_type(name);
                 // index_name = associatedScope->get_mangled_name();
#else
                 // DQ (2/14/2016): Adding support for VLA types (if we evaluate the mangled name we will cause endless recursion).
                 // index_name = index_declaration->get_mangled_name();
                    if (is_variable_length_array == true)
                       {
                         index_name = "vla_dimention";
                       }
                      else
                       {
                         index_name = index_declaration->get_mangled_name();
                       }
#endif
#if 0
                    printf ("SgInitializedName part of index_name = %s \n",index_name.str());
#endif
                    index_name += "_";
                    index_name += index_exp->unparseToString();                    
#if 0
                    printf ("final index_name = %s \n",index_name.str());
#endif
                  }
                 else
                  {
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                    printf ("In SgArrayType::get_mangled() index_exp = %p = %s \n",index_exp,index_exp->class_name().c_str());
#endif
#if 0
                 // DQ (6/13/2015): Original code causing expressions to be mixed into the mangled names.
                    index_name = index_exp->unparseToString();
#else
                 // DQ (6/13/2015): bugfix to permit constant valued expressions to be evaluated to constants and the constants used in the mangled names.
                    SgExpression* original_constant_index_exp = get_index();
                    ROSE_ASSERT(original_constant_index_exp != NULL);

                 // To narrow this further we could constrain the lhs and rhs to be SgInitVal nodes.

#define TEST_CONSTANT_FOLDING_IN_NAME_MANGLING_OF_TYPES 0

#if TEST_CONSTANT_FOLDING_IN_NAME_MANGLING_OF_TYPES
                 // DQ (6/14/2015): This is test code to evaluate if we want to use the constant folding in the name mangling.
                 // This appears to cause test2011_117.C to fail (C++ template issue) (also similar test code in test2014_143.C).

                 // if (isSgAddOp(original_constant_index_exp) != NULL && true)
                    if (true)
#else
                 // DQ (6/14/2015): This predicate will turn off this support for constant folding in the name mangling.
                    if (isSgAddOp(original_constant_index_exp) != NULL && false)
#endif
                       {
                      // This is a narrow case where this should work, but we need more general support.

                      // Build a shadow copy of the expression so that we can do the constant folding without sideffects on the array index expression.
                      // SgExpression* shadow_expr = SageInterface::deepCopy<SgExpression>(original_constant_index_exp);
                         SgExpression* shadow_expr = original_constant_index_exp;
                         ROSE_ASSERT(shadow_expr != NULL);
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("   --- BEFORE: shadow_expr = %p = %s \n",shadow_expr,shadow_expr->class_name().c_str());
                         printf ("   --- BEFORE: shadow_expr->get_parent() = %p \n",shadow_expr->get_parent());
#endif
                      // ConstantFolding::constantFoldingOptimization(const_cast<SgExpression*>(index_exp),false);
                      // ConstantFolding::constantFoldingOptimization(original_constant_index_exp,false);
                      // ConstantFolding::constantFoldingOptimization(shadow_expr,false);

                      // DQ (6/13/2015): Added support to return the SgValueExp holding the constant folded value.
                      // Note that constant folding will have to be extended to support more generality before this will work well.
                         SgExpression* shadow_constant_value_exp = ConstantFolding::returnConstantFoldedValueExpression(shadow_expr,false);
                      // index_name = "unknown_constant_valued_index";
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         if (shadow_constant_value_exp != NULL)
                            {
                              printf ("   --- AFTER: shadow_constant_value_exp->get_parent() = %p \n",shadow_constant_value_exp->get_parent());
                            }
#endif
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("   --- AFTER: shadow_expr = %p = %s \n",shadow_expr,shadow_expr->class_name().c_str());
                         printf ("   --- AFTER: shadow_constant_value_exp = %p = %s \n",shadow_constant_value_exp,shadow_constant_value_exp != NULL ? shadow_constant_value_exp->class_name().c_str() : "null");
#endif
                      // SgExpression* shadow_constant_value_exp = shadow_expr;
                         SgValueExp* shadow_constant_value = isSgValueExp(shadow_constant_value_exp);
                      // ROSE_ASSERT(shadow_constant_value != NULL);
                      // index_name = shadow_constant_value->get_constant_folded_value_as_string().c_str();
                         if (shadow_constant_value != NULL)
                            {
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                              printf ("Generate string from shadow_constant_value->get_constant_folded_value_as_string() \n");
#endif
                              index_name = shadow_constant_value->get_constant_folded_value_as_string().c_str();
                            }
                           else
                            {
                           // This may be the case where ConstantFolding::returnConstantFoldedValueExpression() returned a NULL pointer.
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                              printf ("Using backup plan #1: index_exp->unparseToString() \n");
#endif
                              index_name = index_exp->unparseToString();
                            }

                      // Remove node used to hold the constant value expression.
                         delete shadow_constant_value_exp;
                         shadow_constant_value_exp = NULL;
                         shadow_constant_value = NULL;

#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         SgExpression* constant_value_index_exp = get_index();
                         printf ("constant_value_index_exp = %p = %s \n",constant_value_index_exp,constant_value_index_exp->class_name().c_str());
#endif
                      // SgValueExp* constant_value = isSgValueExp(constant_value_index_exp);
                      // Now this should not be a constant value (since we now support in remaining the original expression).
                      // ROSE_ASSERT(constant_value != NULL);
                      // ROSE_ASSERT(constant_value == NULL);
                      // index_name = constant_value->get_constant_folded_value_as_string().c_str();
#endif
                       }
                      else
                       {
                      // DQ (6/13/2015): Original code causing expressions to be mixed into the mangled names.
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                         printf ("Using backup plan #2: index_exp->unparseToString() \n");
#endif
                         index_name = index_exp->unparseToString();
                       }
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
                    printf ("In SgArrayType::get_mangled(): after constant folding: index_name = %s \n",index_name.str());
#endif
                  }
#if DEBUG_ARRAY_TYPE_MANGLED_NAME_WITH_CONSTANT_FOLDING
               printf ("In SgArrayType::get_mangled(): index_name = %s index_exp = %p = %s = %s \n",index_name.str(),index_exp,index_exp->class_name().c_str(),SageInterface::generateUniqueName(index_exp,true).c_str());
#endif
             }
        }

  // DQ (6/21/2006): Use is_null() instead of counting the size (and fixed case were it is null)
  // ROSE_ASSERT (base_name.get_length ());
     if (base_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In $CLASSNAME::get_mangled(), empty base type name found \n");
          base_name = "unnamed_base_type";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     if (index_name.is_null() == true)
        {
       // This happens for code such as: "typedef struct {int id; } *XYZ;"
       // printf ("Warning: In $CLASSNAME::get_mangled(), no empty base type name found \n");
          index_name = "unnamed_index";
        }
     ROSE_ASSERT (base_name.is_null() == false);

     SgName mangled_name;
     mangled_name << "_Ab_"
                  << base_name.str ()
                  << "_index_"
                  << index_name.str ()
                  << "_Ae_";

#if 0
     printf ("SgArrayType::get_mangled(): mangled_name = %s \n",mangled_name.str());
#endif

     return mangled_name;
   }

SOURCE_ARRAY_TYPE_END

SOURCE_ADA_ACCESS_TYPE_START

SgName
SgAdaAccessType::get_mangled(void) const {
    const SgType* under_type = get_base_type();
     
    string name("a'");
    
    name.append(under_type->get_mangled());
    return SgName(name);
}
     
SOURCE_ADA_ACCESS_TYPE_END

SOURCE_ADA_SUBTYPE_START

SgName
SgAdaSubtype::get_mangled(void) const {
    const SgType* under_type = get_base_type();
    std::string   name(under_type->get_mangled());
    
    name += ":>";
    name += get_constraint()->displayString();
    return SgName(name);
}
     
SOURCE_ADA_SUBTYPE_END


SOURCE_ADA_FLOAT_TYPE_START

SgName
SgAdaFloatType::get_mangled(void) const {
    string name("f'");
    
    name.append(get_digits()->unparseToString());
    name.append("'");
    name.append(get_range()->displayString());
    return SgName(name);
}
     
SOURCE_ADA_FLOAT_TYPE_END


SOURCE_TYPE_ELLIPSE_TYPE_START
SgName
$CLASSNAME::get_mangled (void) const
   {
     ROSE_ASSERT(this != NULL);
     return SgName ("_E_");
   }
 SOURCE_TYPE_ELLIPSE_TYPE_END



// ###################################################################
// ###################################################################
//             CREATE TYPE MEMBER FUNCTION DEFINITIONS
// ###################################################################
// ###################################################################

SOURCE_COMMON_CREATE_TYPE_START

// DQ (1/31/2006): Modified to build all types in the memory pools
// $CLASSNAME $CLASSNAME::builtin_type;
// $CLASSNAME* $CLASSNAME::builtin_type = new $CLASSNAME();
$CLASSNAME* $CLASSNAME::p_builtin_type = NULL;


// DQ (10/4/2010): Added support for optional Fotran type_kind specification.
// $CLASSNAME* $CLASSNAME::createType(void)
$CLASSNAME*
$CLASSNAME::createType(SgExpression* optional_fortran_type_kind)
   {
  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type.p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type;

#if 0
     printf ("In $CLASSNAME::createType() (COMMON_CREATE_TYPE) \n");
#endif

  // DQ (10/4/2010): New version of code to support multiple kinds of bool as required for the Fortran type_kind support within ROSE.
  // Note that this implementation does not use p_builtin_type, since with the global type table it is not required.

     $CLASSNAME* temp_type = new $CLASSNAME();

#if 0
     printf ("In $CLASSNAME::createType() (COMMON_CREATE_TYPE): temp_type = %p \n",temp_type);
#endif

  // DQ (10/31/2016): Added assertion.
     ROSE_ASSERT(temp_type != NULL);

     if (optional_fortran_type_kind != NULL)
        {
       // DQ (10/31/2016): Added assertion.
          ROSE_ASSERT(temp_type != NULL);

          temp_type->set_type_kind(optional_fortran_type_kind);
        }
#if 0
       else
        {
       // Let p_builtin_type refer to the unadorned type (no type kind).
          p_builtin_type = temp_type;
        }
#endif

     SgName name = temp_type->get_mangled();

#if 0
     printf ("Mangled type name for $CLASSNAME = %s get_globalTypeTable()->get_type_table()->size() = %d \n",name.str(),get_globalTypeTable()->get_type_table()->size());
#endif

  // DQ (10/31/2016): Added assertion.
     ROSE_ASSERT(get_globalTypeTable() != NULL);

     SgType* t = get_globalTypeTable()->lookup_type(name);

#if 0
     printf ("In $CLASSNAME::createType(): type from lookup_type = %p \n",t);
#endif

     if (t == NULL)
        {
          get_globalTypeTable()->insert_type(name,temp_type);
        }
       else
        {
       // If t is the same as p_builtin_type then we can't delete it...(only comes up in merging AST's read from files).
          if (t != temp_type)
             {
#if 0
               printf ("In $CLASSNAME::createType(): deleting temp_type = %p \n",temp_type);
#endif
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete temp_type;
#endif
               temp_type = NULL;
#if 0
            // Should we clear the p_builtin_type? I think we have to, but it will be overwritten below.
               if (optional_fortran_type_kind != NULL)
                  {
                    p_builtin_type = NULL;
                  }
#endif
             }

       // Reuse this tempType variable so we can use the same code below.
          temp_type = is$CLASSNAME(t);
          ROSE_ASSERT(temp_type != NULL);
        }

#if 0
     printf ("Leaving $CLASSNAME::createType(): temp_type = %p \n",temp_type);
#endif

     return temp_type;
   }

SOURCE_COMMON_CREATE_TYPE_END


// DQ (8/17/2010): removed SOURCE_CREATE_TYPE_WITH_PARAMETER (not used).


SOURCE_CREATE_TYPE_FOR_PARTIAL_FUNCTION_TYPE_START
// $CLASSNAME* $CLASSNAME::createType(SgType* rtype)
$CLASSNAME*
$CLASSNAME::createType(SgType* rtype,SgExpression* optional_fortran_type_kind)
   {
  // return new $CLASSNAME(rtype);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In $CLASSNAME::createType() (CREATE_TYPE_FOR_PARTIAL_FUNCTION_TYPE) \n");
#endif

     $CLASSNAME* returnType = new $CLASSNAME(rtype);
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_PARTIAL_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_TYPEDEF_TYPE_START
// SgTypedefType* SgTypedefType::createType(SgTypedefDeclaration *decl)
SgTypedefType*
SgTypedefType::createType(SgTypedefDeclaration *decl, SgExpression* optional_fortran_type_kind)
   {
  // printf ("Inside of SgTypedefType::createType() \n");
     assert(decl != NULL);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgTypedefType::createType() (CREATE_TYPE_FOR_TYPEDEF_TYPE) \n");
#endif

  // if (!decl->get_type())
     if (decl->get_type() == NULL)
        {
          assert(decl->get_base_type() != NULL);

          ROSE_ASSERT (decl->get_base_type() != NULL);
          ROSE_ASSERT (decl->get_base_type()->p_typedefs != NULL);
       // printf ("Before loop over typedef chain: (decl->get_base_type()->p_typedefs)->get_typedefs().size() = %d \n",
       //      (decl->get_base_type()->p_typedefs)->get_typedefs().size());

          SgTypePtrList::iterator i = ((decl->get_base_type()->p_typedefs)->get_typedefs().begin());
          while (i != ((decl->get_base_type()->p_typedefs)->get_typedefs().end()))
             {
            // printf ("In loop over typedef chain \n");

            // SgName dname = decl->get_name();
            // SgTypedefType *tptr= isSgTypedefType((*i).irep());
               ROSE_ASSERT( (*i) != NULL);
               SgTypedefType *tptr = isSgTypedefType(*i);
               ROSE_ASSERT(tptr != NULL);

            // DQ (3/21/2012): No, test2004_48.C fails this test.
            // DQ (3/3/2012): I think this is always NULL pointer to a SgSymbol.
            // ROSE_ASSERT(decl->get_parent_scope() == NULL);

            // DQ (3/21/2012): No, test2003_08.C fails this test.
            // DQ (3/3/2012): I think this is always NULL pointer to a SgSymbol. 
            // ROSE_ASSERT(tptr->get_parent_scope() == NULL);

#if 0
            // DQ (2/27/2018): I think this is the wrong code because the value returned by get_name() contains 
            // the name of the template instantiation with template arguments, and the value of the function 
            // get_templateName() has the value of the associated template name (without template arguments).

               SgName name = decl->get_name();
            // SgTemplateTypedefDeclaration* templateTypedefDeclaration = isSgTemplateTypedefDeclaration(decl);
               SgTemplateInstantiationTypedefDeclaration* templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(decl);
               if (templateInstantiationTypedefDeclaration != NULL)
                 {
                   name = templateInstantiationTypedefDeclaration->get_templateName();
                   printf ("In SgTypedefType::createType(): case of SgTemplateInstantiationTypedefDeclaration: name = %s \n",name.str());
                   ROSE_ASSERT(name != "");
                 }
                else
                 {
                // DQ (2/25/2018): If this is a SgTemplateTypedefDeclaration then it might be that we can't just use the name (but I'm not ceertain).
                   SgTemplateTypedefDeclaration* templateTypedefDeclaration = isSgTemplateTypedefDeclaration(decl);
                   if (templateTypedefDeclaration != NULL)
                      {
                        printf ("In SgTypedefType::createType(): case of SgTemplateTypedefDeclaration: Need to handle this special case (I think)! \n");
                      }
                 }

               SgName i_name = decl->get_name();
            // SgTemplateTypedefDeclaration* i_templateTypedefDeclaration = isSgTemplateTypedefDeclaration(decl);
               SgTemplateInstantiationTypedefDeclaration* i_templateInstantiationTypedefDeclaration = isSgTemplateInstantiationTypedefDeclaration(tptr->get_declaration());
               if (i_templateInstantiationTypedefDeclaration != NULL)
                 {
                   i_name = i_templateInstantiationTypedefDeclaration->get_templateName();
                   printf ("In SgTypedefType::createType(): case of SgTemplateInstantiationTypedefDeclaration: i_name = %s \n",i_name.str());
                   ROSE_ASSERT(i_name != "");
                 }
                else
                 {
                // DQ (2/25/2018): If this is a SgTemplateTypedefDeclaration then it might be that we can't just use the name (but I'm not ceertain).
                   SgTemplateTypedefDeclaration* templateTypedefDeclaration = isSgTemplateTypedefDeclaration(tptr->get_declaration());
                   if (templateTypedefDeclaration != NULL)
                      {
                        printf ("In SgTypedefType::createType(): case of SgTemplateTypedefDeclaration: Need to handle this special case (I think)! \n");
                      }
                 }
#if 1
               printf ("In SgTypedefType::createType(): decl = %p decl->get_firstNondefiningDeclaration() = %p \n",decl,decl->get_firstNondefiningDeclaration());
               printf ("In SgTypedefType::createType(): decl = %p decl->get_definingDeclaration()         = %p \n",decl,decl->get_definingDeclaration());
               printf ("In SgTypedefType::createType(): case of %s: name   = %s \n",decl->class_name().c_str(),name.str());
               printf ("In SgTypedefType::createType(): case of %s: i_name = %s \n",tptr->get_declaration()->class_name().c_str(),i_name.str());
#endif
            // if ( (decl->get_name() == tptr->get_name()) && (decl->get_parent_scope() == tptr->get_parent_scope()) )
               if ( (name == i_name) && (decl->get_parent_scope() == tptr->get_parent_scope()) )
                  {
                    return (tptr);
                  }
#else
            // DQ (2/27/2018): This is the original code, and I think it maybe the best version.
               if ( (decl->get_name() == tptr->get_name()) && (decl->get_parent_scope() == tptr->get_parent_scope()) )
                  {
                    return tptr;
                  }
#endif
               i++;
             }

       // decl->set_type(new SgTypedefType(decl, decl->get_parent_scope()));

       // debugging code
       // decl->get_file_info()->display("declration used in $CLASSNAME::createType()");

       // Parent scope is NULL for declarations in global scope
       // ROSE_ASSERT (decl->get_parent_scope() != NULL);
#if 0
          SgTypedefType* tempType = new SgTypedefType(decl, decl->get_parent_scope());
#else
       // DQ (7/22/2010): Use the global type table to get the type.

       // We have to build the type before we can generate a mangle name for it.
          SgTypedefType* tempType = new SgTypedefType(decl, decl->get_parent_scope());
          SgName name = tempType->get_mangled();
          ROSE_ASSERT(name.is_null() == false);

          SgScopeStatement* currentScope = getCurrentScope();

       // ROSE_ASSERT(currentScope != NULL);
          if (currentScope != NULL)
             {
            // DQ (7/30/2010): If valid pointer then we are in the process of building the C/C++/Fortran AST.
               SgType* t = currentScope->get_type_table()->lookup_type(name);

               if (t == NULL)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (not available in type table) \n",name.str());
#endif
                 // get_globalTypeTable()->insert_type(name,tempType);
                    currentScope->get_type_table()->insert_type(name,tempType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (already exists in type table) \n",name.str());
#endif
                    ROSE_ASSERT(t != tempType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                 // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                 // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                 // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                    delete tempType;
#endif
                    tempType = NULL;

                 // Reuse this tempType variable so we can use the same code below.
                    tempType = is$CLASSNAME(t);
                  }
             }
#endif
          ROSE_ASSERT (tempType != NULL);
          decl->set_type(tempType);

          ROSE_ASSERT (decl->get_type() != NULL);
          ROSE_ASSERT (decl->get_base_type() != NULL);
          ROSE_ASSERT (decl->get_base_type()->p_typedefs != NULL);

       // printf ("Before updating list: (decl->get_base_type()->p_typedefs)->get_typedefs().size() = %d \n",
       //      (decl->get_base_type()->p_typedefs)->get_typedefs().size());

          (decl->get_base_type()->p_typedefs)->get_typedefs().push_back(decl->get_type());
        }

  // printf ("Leaving SgTypedefType::createType() \n");

     ROSE_ASSERT(decl != NULL);
     ROSE_ASSERT(decl->get_type() != NULL);  // I think we can assert this!

     ROSE_ASSERT ((decl->get_base_type()->p_typedefs)->get_typedefs().size() > 0);

     return decl->get_type();
   }

SOURCE_CREATE_TYPE_FOR_TYPEDEF_TYPE_END


SOURCE_CREATE_TYPE_FOR_FUNCTION_TYPE_START
// SgFunctionType* SgFunctionType::createType(SgPartialFunctionType* ft)
SgFunctionType*
SgFunctionType::createType(SgPartialFunctionType* ft, SgExpression* optional_fortran_type_kind)
   {
  // The problem with this function is that I have not added the name mangling into SAGE 3 yet!

     ROSE_ASSERT(ft != NULL);

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgFunctionType::createType() (CREATE_TYPE_FOR_FUNCTION_TYPE) \n");
#endif

#if 1
  // DQ (3/29/2006):
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is built (and parent pointers
  // are set).  If functions are created then the function type table must also be updated.
     SgFunctionType* theType = new SgFunctionType(ft);

  // DQ (6/21/2006): Since we mangle the return type into the mangled function as part of building
  // the symbol table we don't have to worry about sharing function types that would have different
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());
#else
  // printf ("In $CLASSNAME::createType(SgPartialFunctionType* ft): calling ft->get_mangled_type \n");
  // SgName nname = ft->get_mangled_type();

  // DQ (3/29/2006): experiment with generating a unique name for the function type table lookup
  // This will avoid calling the get_mangled_type() function durring the construction
  // of the AST.  Because the name will be unique there will be no collision in the
  // function type symbol table.  The function type symbol tabel will then have to
  // be rebuilt after the AST is build (in a post-processing phase).
     static int functionCounter = 0;
     string baseName = "function_";
     string mangleName = baseName + Rose::StringUtility::numberToString(functionCounter++);
     SgName nname = mangleName;

#if 0
     SgName nname = "NOT YET SUPPORTED IN SAGE3 YET"; // ft->get_mangled_type();
     printf ("WARNING: Name mangling not yet suppported in SAGE 3! (required in SgFunctionType::createType()) \n");
#endif

  // check the function type table
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // SgType *t = Sgfunc_type_table.lookup_function_type(nname);
     ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
     SgType *t = get_globalFunctionTypeTable()->lookup_function_type(nname);

     $CLASSNAME *theType = is$CLASSNAME(t);
  // if(!theType)
     if(theType == NULL)
        {
       // printf ("##### Building a default type since theType == NULL \n");
          theType = new $CLASSNAME(ft);
          ROSE_ASSERT(theType != NULL);
       // DQ (1/31/2006): Modified to build all types in the memory pools
       // Sgfunc_type_table.insert_function_type(nname, theType);
          ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
          get_globalFunctionTypeTable()->insert_function_type(nname, theType);
        }
       else
        {
          theType->set_orig_return_type(ft->get_return_type());
        }

  // Commented out to avoid deleting the input data (poor design, I think)
  // delete ft;
#endif

     ROSE_ASSERT(theType != NULL);
     return theType;
   }

SOURCE_CREATE_TYPE_FOR_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_MEMBER_FUNCTION_TYPE_START
// SgMemberFunctionType* SgMemberFunctionType::createType(SgPartialFunctionType* ft)
SgMemberFunctionType*
SgMemberFunctionType::createType(SgPartialFunctionType* ft, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(ft != NULL);
  // printf ("In $CLASSNAME::createType(SgPartialFunctionType* ft): calling ft->get_mangled_type \n");
  // SgName nname = ft->get_mangled_type();

  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgMemberFunctionType::createType() (CREATE_TYPE_FOR_MEMBER_FUNCTION_TYPE) \n");
#endif

#if 1
  // DQ (3/29/2006):
  // Simplify this function to not use the function type table, thus SgFunctionType nodes are not
  // shared. During function creation.  As a result we don't have to call the functions to mangle
  // the names of things (which traverse parents to compute scopes and can be a problem if called
  // before the parents are set, done in post processing of AST).  However, this design requires
  // that the funtion type symbol table be constructed after the AST is build (and parent pointers
  // are set).  If functions are created then the function type table must also be updated.
     SgMemberFunctionType* theType = new SgMemberFunctionType(ft);

  // DQ (6/22/2006): Since we mangle the return type into the mangled function as part of building
  // the symbol table we don't have to worry about sharing function types that would have different
  // return types.  Here we set the orig_return_type stored explicitly (it seems it is always the
  // same as the return_type.
     ROSE_ASSERT (ft->get_return_type() != NULL);
     theType->set_orig_return_type(ft->get_return_type());
#else
  // DQ (3/29/2006): experiment with generating a unique name for the function type table lookup
  // This will avoid calling the get_mangled_type() function durring the construction
  // of the AST.  Because the name will be unique there will be no collision in the
  // function type symbol table.  The function type symbol tabel will then have to
  // be rebuilt after the AST is build (in a post-processing phase).
     static int functionCounter = 0;
     string baseName = "memberfunction_";
     string mangleName = baseName + Rose::StringUtility::numberToString(functionCounter++);
     SgName nname = mangleName;

#if 0
     SgName nname = "NOT YET SUPPORTED"; // ft->get_mangled_type();
     printf ("WARNING: Name mangling not yet suppported in SAGE 3! (required in SgFunctionType::createType()) \n");
#endif

  // check the function type table
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // SgType *t = Sgfunc_type_table.lookup_function_type(nname);
     ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
     SgType *t = get_globalFunctionTypeTable()->lookup_function_type(nname);
     $CLASSNAME* theType = is$CLASSNAME(t);
  // if (!theType)
     if (theType == NULL)
        {
          theType = new $CLASSNAME(ft);
          ROSE_ASSERT(theType != NULL);
       // printf ("In $CLASSNAME::createType(): insert function type into symbol table: nname = %s \n",nname.str());
       // Sgfunc_type_table.insert_function_type(nname, theType);
          ROSE_ASSERT(get_globalFunctionTypeTable() != NULL);
          get_globalFunctionTypeTable()->insert_function_type(nname, theType);
        }
       else
        {
       // printf ("In $CLASSNAME::createType(): function type found in symbol table: nname = %s \n",nname.str());
          theType->set_orig_return_type(ft->get_return_type());
        }

  // DQ: commented out the delete of the input structure (poor design, I think)
  // delete ft;
#endif

     ROSE_ASSERT(theType != NULL);
     return theType;
   }

SOURCE_CREATE_TYPE_FOR_MEMBER_FUNCTION_TYPE_END


SOURCE_CREATE_TYPE_FOR_POINTER_MEMBER_TYPE_START
// $CLASSNAME* $CLASSNAME::createType ( SgType* base_type, SgType *class_type )
$CLASSNAME*
$CLASSNAME::createType ( SgType* base_type, SgType *class_type, SgExpression* optional_fortran_type_kind )
   {
  // DQ (10/4/2010): I don't think this type can have a fortran type kind parameter.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In $CLASSNAME::createType() (CREATE_TYPE_FOR_POINTER_MEMBER_TYPE) \n");
#endif

     $CLASSNAME* returnType = new $CLASSNAME(base_type,class_type);
     assert(returnType != NULL);
     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_POINTER_MEMBER_TYPE_END

SOURCE_CREATE_TYPE_FOR_TYPE_INT_TYPE_START
const int SgTypeInt::maxBitLength = ROSE_INTEGER_TYPE_MAX_BIT_LENGTH;
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgTypeInt SgTypeInt::builtin_type[maxBitLength];
#if 0
#if defined __x86_64__
// 64 bit support
SgTypeInt* SgTypeInt::p_builtin_type[maxBitLength] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
#else
// 32 bit support
SgTypeInt* SgTypeInt::p_builtin_type[maxBitLength] = { NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                     NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL };
#endif
#else
// DQ (1/31/2006): Convert to a single builtin pointer rather than an array of them.
// I don't think we really need an array of these internally.
SgTypeInt* SgTypeInt::p_builtin_type = NULL;
#endif

// DQ (10/4/2010): Added support for fortran type kind expressions.
// $CLASSNAME* $CLASSNAME::createType(int bitLength)
SgTypeInt*
SgTypeInt::createType(int bitLength, SgExpression* optional_fortran_type_kind)
   {
#if 0
     printf ("In SgTypeInt::createType() \n");
#endif

#if 0
     static bool firstCallToFunction = true;
     if (firstCallToFunction == true)
        {
       // printf ("Build the SgTypeInt objects within the builtin_type array (for bit modified types) \n");
       // Allocate all the required integer types (we require 32 of them for
       // 32 bit architectures because "int i:n" (where "n" is the number of
       // bits), forms a valid type).
          for (int i=0; i < maxBitLength; i++)
             {
               p_builtin_type[bitLength] = new $CLASSNAME();
             }
        }
     firstCallToFunction = false;

     ROSE_ASSERT(bitLength < maxBitLength);

  // DQ (12/22/2005): Jochen thinks that we need this because the SgNode constructor
  // is not called (likely because static initialization is compiler dependent).
  // DQ (1/31/2006): Modified to build all types in the memory pools
  // builtin_type[bitLength].p_freepointer = AST_FileIO::IS_VALID_POINTER();
  // return &builtin_type[bitLength];
     ROSE_ASSERT(p_builtin_type[bitLength] != NULL);
     p_builtin_type[bitLength]->p_freepointer = AST_FileIO::IS_VALID_POINTER();
     return p_builtin_type[bitLength];
#else
#if 0
  // DQ (1/31/2006): Convert to a single builtin pointer rather than an array of them.
  // I don't think we really need an array of these internally.
     if (p_builtin_type == NULL)
        {
#if 0
          p_builtin_type = new $CLASSNAME(bitLength);
#else
       // DQ (7/22/2010): Use the global type table to get the type.
          p_builtin_type = new $CLASSNAME(bitLength);

          if (optional_fortran_type_kind != NULL)
             {
            // DQ (10/4/2010): Added fortran type kind support (must be in place before the mangled name is generated).
               p_builtin_type->set_type_kind(optional_fortran_type_kind);
             }

          SgName name = p_builtin_type->get_mangled();
#if 0
          printf ("Mangled type name for $CLASSNAME = %s \n",name.str());
#endif
          get_globalTypeTable()->insert_type(name,p_builtin_type);
#endif
        }

     ROSE_ASSERT(p_builtin_type != NULL);
     return p_builtin_type;
#else
  // DQ (10/5/2010): New version of code to support multiple kinds of SgTypeInt as required for the Fortran type_kind support within ROSE.
  // Note that this implementation does not use p_builtin_type, since with the global type table it is not required.

     $CLASSNAME* temp_type = new $CLASSNAME();
     if (optional_fortran_type_kind != NULL)
        {
          temp_type->set_type_kind(optional_fortran_type_kind);
        }

     SgName name = temp_type->get_mangled();
#if 0
     printf ("Mangled type name for $CLASSNAME = %s get_globalTypeTable()->get_type_table()->size() = %d \n",name.str(),get_globalTypeTable()->get_type_table()->size());
#endif

     SgType* t = get_globalTypeTable()->lookup_type(name);
#if 0
     printf ("In $CLASSNAME::createType(): type from lookup_type = %p \n",t);
#endif
     if (t == NULL)
        {
          get_globalTypeTable()->insert_type(name,temp_type);
        }
       else
        {
       // If t is the same as p_builtin_type then we can't delete it...(only comes up in merging AST's read from files).
          if (t != temp_type)
             {
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete temp_type;
#endif
               temp_type = NULL;
             }

       // Reuse this tempType variable so we can use the same code below.
          temp_type = is$CLASSNAME(t);
          ROSE_ASSERT(temp_type != NULL);
        }

     return temp_type;
#endif
#endif
   }

#if 0
// DQ (12/26/2005): Supporting function for traverseMemoryPool
// where static IR nodes (only isn soem SgType IR nodes) are
// present and must be traversed using specially generated code.
void
$CLASSNAME::executeVisitorMemberFunctionOnBuiltinData(ROSE_Visitor & visitor)
   {
     for (int i=0; i < SgTypeInt::maxBitLength; i++)
          SgTypeInt::builtin_type[i].executeVisitorMemberFunction(visitor);
   }
#endif
SOURCE_CREATE_TYPE_FOR_TYPE_INT_TYPE_END


SOURCE_CREATE_TYPE_FOR_ENUM_TYPE_START
// SgEnumType* SgEnumType::createType(SgEnumDeclaration* cd)
SgEnumType*
SgEnumType::createType(SgEnumDeclaration* cd, SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgEnumType* returnType = NULL;
  // return cd->get_type() ? cd->get_type() : new $CLASSNAME(cd);

     assert(cd != NULL);

#if 0
     printf ("In SgEnumType::createType() \n");
#endif

     returnType = cd->get_type();
     if (returnType == NULL)
        {
#if 0
          returnType = new SgEnumType(cd);
#else
       // DQ (7/22/2010): Use the global type table to get the type.

          returnType = new SgEnumType(cd);
          ROSE_ASSERT(returnType != NULL);

       // We have to build the type before we can generate a mangle name for it.
          SgName name = returnType->get_mangled();

#if 0
          printf ("In SgEnumType::createType(): cd = %p = %s \n",cd,name.str());
#endif

          if (name.is_null() == true)
             {
#if 0
               printf ("Need to handle special case of SgEnumDeclaration of un-named class cd = %p = %s \n",cd,cd->class_name().c_str());
            // ROSE_ASSERT(cd->get_file_info() != NULL);
            // cd->get_file_info()->display("Need to handle special case of SgClassDeclaration of un-named class");
#endif
               name = SageInterface::generateUniqueName(returnType,/* ignoreDifferenceBetweenDefiningAndNondefiningDeclarations = */ true);
#if 0
               printf ("In SgEnumType::createType(): Generated a unique name (using SageInterface::generateUniqueName())= %s \n",name.str());
#endif
             }
          ROSE_ASSERT(name.is_null() == false);

          SgScopeStatement* currentScope = getCurrentScope();

#if 0
          printf ("In SgEnumType::createType(): currentScope = %p = %s \n",currentScope,currentScope != NULL ? currentScope->class_name().c_str() : "NULL");
#endif

          if (currentScope != NULL)
             {
            // DQ (7/30/2010): If valid pointer then we are in the process of building the C/C++/Fortran AST.
               SgType* t = currentScope->get_type_table()->lookup_type(name);
               if (t == NULL)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (not available in type table) \n",name.str());
#endif
                 // get_globalTypeTable()->insert_type(name,returnType);
                    currentScope->get_type_table()->insert_type(name,returnType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (already exists in type table) \n",name.str());
#endif
                    ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                 // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                 // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                 // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                    delete returnType;
#endif
                    returnType = NULL;

                 // Reuse this returnType variable so we can use the same code below.
                    ROSE_ASSERT(t != NULL);
                    returnType = isSgEnumType(t);

                    if (returnType == NULL)
                       {
                         printf ("ERROR: returnType == NULL --- t = %p = %s \n",t,t->class_name().c_str());
                         cd->get_file_info()->display("ERROR: returnType == NULL");
                       }
                    ROSE_ASSERT(returnType != NULL);
                  }
             }
#endif
        }
#if 0
     printf ("This SgEnumType::createType() function does NOT set the type in the SgEnumDeclaration = %p \n",cd);
#endif

     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_ENUM_TYPE_END


SOURCE_CREATE_TYPE_FOR_CLASS_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
// SgClassType* SgClassType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
SgClassType*
SgClassType::createType(SgDeclarationStatement* cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

#define DEBUG_CREATE_TYPE_FOR_CLASS_TYPE 0

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("In SgClassType::createType() \n");
#endif

  // DQ (12/4/2011): Adding template declaration support to AST.  An SgClassType is modified to hold a SgTemplateClassDeclaration or a SgClassDeclaration.
     SgClassDeclaration*         classDeclaration         = isSgClassDeclaration(cd);
     SgTemplateClassDeclaration* templateClassDeclaration = isSgTemplateClassDeclaration(cd);
     ROSE_ASSERT(classDeclaration != NULL || templateClassDeclaration != NULL);
     ROSE_ASSERT(classDeclaration != NULL);

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
  // These debugging statements don't deal with the modifications to handle SgTemplateClassDeclaration.
     printf ("In SgClassType::createType(): cd = %p = %s cd->get_definition() = %p = %s \n",classDeclaration,classDeclaration->class_name().c_str(),
          classDeclaration->get_definition(),(classDeclaration->get_definition() != NULL) ? classDeclaration->get_definition()->class_name().c_str() : "NULL");
     printf ("In SgClassType::createType(): cd->get_type() = %p \n",classDeclaration->get_type());
     printf ("In SgClassType::createType(): cd = %p cd->get_definingDeclaration()         = %p \n",classDeclaration,classDeclaration->get_definingDeclaration());
     printf ("In SgClassType::createType(): cd = %p cd->get_firstNondefiningDeclaration() = %p \n",classDeclaration,classDeclaration->get_firstNondefiningDeclaration());
#endif

     SgType* type_from_declaration = NULL;
  // if (classDeclaration != NULL)
     if (templateClassDeclaration == NULL)
        {
          ROSE_ASSERT(classDeclaration != NULL);
          type_from_declaration = classDeclaration->get_type();
       // ROSE_ASSERT(type_from_declaration != NULL);
        }
       else
        {
          ROSE_ASSERT(templateClassDeclaration != NULL);
          type_from_declaration = templateClassDeclaration->get_type();
       // ROSE_ASSERT(type_from_declaration != NULL);
        }

  // ROSE_ASSERT(type_from_declaration != NULL);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("Inside of SgClassType::createType(): cd = %p = %s type_from_declaration = %p \n",cd,cd->class_name().c_str(),type_from_declaration);
#endif

  // if (!cd->get_type())
     if (type_from_declaration == NULL)
        {
#if 0
          $CLASSNAME* newType = new $CLASSNAME(cd);
          ROSE_ASSERT(newType != NULL);
          cd->set_type(newType);
       // cd->set_type(new $CLASSNAME(cd));
#else
       // DQ (7/22/2010): Use the global type table to get the type.
          $CLASSNAME* newType = new $CLASSNAME(cd);
          ROSE_ASSERT(newType != NULL);

       // DQ (3/14/2012): Note that the new template support allows that classDeclaration is non-null (since template classes are derived from non-template classes).
          ROSE_ASSERT(classDeclaration != NULL);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): cd = %p = %s = %s newType = %p = %s \n",cd,cd->class_name().c_str(),classDeclaration->get_name().str(),newType,newType->class_name().c_str());
#endif
          SgScopeStatement* currentScope = getCurrentScope();
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): currentScope = %p = %s \n",currentScope,currentScope->class_name().c_str());
#endif
       // DQ (3/14/2012): Make sure that this is a valid pointer else it might explain why qualification is not being use to generate the mangled names.
       // ROSE_ASSERT(cd->get_scope() != NULL);
          if (cd->get_scope() == NULL && currentScope != NULL)
             {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Inside of SgClassType::createType(): Setting scope for cd = %p = %s to currentScope = %p = %s \n",cd,cd->class_name().c_str(),currentScope,currentScope->class_name().c_str());
#endif
               cd->set_scope(currentScope);
             }
          ROSE_ASSERT(cd->get_scope() != NULL);

       // We have to build the type before we can generate a mangled name for it.
          SgName name = newType->get_mangled();

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
          printf ("Inside of SgClassType::createType(): type name (newType->get_mangled()) = %s \n",name.str());
#endif
          if (name.is_null() == true)
             {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Need to handle special case of SgClassDeclaration of un-named class cd = %p = %s \n",cd,cd->class_name().c_str());
#endif
#if 0
               printf ("Need to handle special case of SgClassDeclaration of un-named class cd = %p = %s \n",cd,cd->class_name().c_str());
               ROSE_ASSERT(cd->get_file_info() != NULL);
               cd->get_file_info()->display("Need to handle special case of SgClassDeclaration of un-named class");
#endif
            // name = SageInterface::generateUniqueName(cd,/* ignoreDifferenceBetweenDefiningAndNondefiningDeclarations = */ true);
               name = SageInterface::generateUniqueName(newType,/* ignoreDifferenceBetweenDefiningAndNondefiningDeclarations = */ true);
#if 0
               printf ("Generated a unique name (using SageInterface::generateUniqueName())= %s \n",name.str());
#endif
            // name = SageInterface::get_name(newType);
            // printf ("Generated a unique name (using SageInterface::get_name()) = %s \n",name.str());
            // ROSE_ASSERT(false);
             }
          ROSE_ASSERT(name.is_null() == false);

       // SgScopeStatement* currentScope = getCurrentScope();

          if (currentScope != NULL)
             {
            // DQ (7/30/2010): If valid pointer then we are in the process of building the C/C++/Fortran AST.
            // SgType* t = currentScope->get_type_table()->lookup_type(name);
               SgType* t = currentScope->get_type_table()->lookup_type(name);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
               printf ("Inside of SgClassType::createType(): after calling lookup_type(): t = %p = %s \n",t,(t != NULL) ? t->class_name().c_str() : "null");
#endif
               if (t == NULL)
                  {
                 // If the type is not in the type table then insert it so that we can reuse it.
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("Mangled type name for SgClassType = %s (not available in type table) \n",name.str());
#endif
                 // get_globalTypeTable()->insert_type(name,newType);
                    currentScope->get_type_table()->insert_type(name,newType);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("This SgClassType::createType() function also sets the type in the SgClassDeclaration = %p \n",cd);
#endif

                 // DQ (12/4/2011): Modified to support template declarations in the AST.
                 // cd->set_type(newType);
                    if (classDeclaration != NULL)
                         classDeclaration->set_type(newType);
                      else
                         templateClassDeclaration->set_type(newType);
                  }
                 else
                  {
                 // If it is already present in the type table then delete the type (so that it will remain unique).
                    SgClassType* classType = isSgClassType(t);
                    ROSE_ASSERT(classType != NULL);
                    ROSE_ASSERT(classType->get_declaration() != NULL);
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("Mangled type classType = %p (classType->get_declaration() = %p = %s) name for SgClassType name = %s (already exists in type table) \n",t,classType->get_declaration(),classType->get_declaration()->class_name().c_str(),name.str());
#endif
                 // DQ (3/21/2012): New test.
                 // ROSE_ASSERT(t != newType);
                 // delete newType;
                 // newType = NULL;

                 // DQ (3/21/2012): New conditional test for t != newType (and delete new type only then).
                    if (t != newType)
                       {
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                         printf ("Deleting the just built exploritory type = %p (case of t != newType) t = %p = %s \n",newType,t,t->class_name().c_str());
#endif
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
                      // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
                      // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
                      // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
                         delete newType;
#endif
                         newType = NULL;
                       }
                      else
                       {
                         printf ("WARNING: In SgClassType::createType(): Found a case of t == newType \n");
                       }
#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
                    printf ("This SgClassType::createType() function also sets the type in the SgClassDeclaration = %p \n",cd);
#endif
                    $CLASSNAME* typeFromTypeTable = is$CLASSNAME(t);

                 // DQ (3/21/2012): New test.
                    ROSE_ASSERT(typeFromTypeTable != NULL);

                 // DQ (12/4/2011): Modified to support template declarations in the AST.
                 // cd->set_type(typeFromTypeTable);
                    if (classDeclaration != NULL)
                         classDeclaration->set_type(typeFromTypeTable);
                      else
                         templateClassDeclaration->set_type(typeFromTypeTable);
                  }
             }
            else
             {
            // Set the type using the generated type that might be redundant with a previously
            // generated type (something to sort out when we either merge local type tables or
            // when we connect the AST fragment being built (bottom up) into the large AST).

            // DQ (12/4/2011): Modified to support template declarations in the AST.
            // cd->set_type(newType);
            // if (classDeclaration != NULL)
               if (templateClassDeclaration == NULL)
                  {
                    ROSE_ASSERT(classDeclaration != NULL);
                    classDeclaration->set_type(newType);
                  }
                 else
                  {
                    ROSE_ASSERT(templateClassDeclaration != NULL);
                    templateClassDeclaration->set_type(newType);
                  }

             }
#endif
        }

  // return ($CLASSNAME*) cd->get_type();

  // ROSE_ASSERT(type_from_declaration != NULL);
  // return ($CLASSNAME*) type_from_declaration;

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("SgClassType::createType(): classDeclaration         = %p \n",classDeclaration);
     printf ("SgClassType::createType(): templateClassDeclaration = %p \n",templateClassDeclaration);
#endif

     SgClassType* returnType = NULL;
     if (classDeclaration != NULL)
        {
          ROSE_ASSERT(classDeclaration->get_type() != NULL);
          returnType = isSgClassType(classDeclaration->get_type());
          if (returnType == NULL)
             {
               printf ("Error: returnType == NULL: classDeclaration->get_type() = %p = %s \n",classDeclaration->get_type(),classDeclaration->get_type()->class_name().c_str());
             }
          ROSE_ASSERT(returnType != NULL);
        }
       else
        {
          returnType = isSgClassType(templateClassDeclaration->get_type());
          ROSE_ASSERT(returnType != NULL);
        }

     ROSE_ASSERT(returnType != NULL);

  // DQ (3/22/2012): Added assertions.
     if (returnType->get_declaration() != cd)
        {
#if 0
          printf ("In SgClassType::createType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
          printf ("In SgClassType::createType(): returnType->get_declaration() = %p = %s cd = %p = %s \n",returnType->get_declaration(),
               returnType->get_declaration()->class_name().c_str(),cd,cd->class_name().c_str());
          printf ("In SgClassType::createType(): returnType->get_declaration() = %p = %s cd = %p = %s \n",returnType->get_declaration(),
               isSgClassDeclaration(returnType->get_declaration())->get_name().str(),classDeclaration,classDeclaration->get_name().str());
#endif
          ROSE_ASSERT(returnType->get_declaration()->get_firstNondefiningDeclaration() != NULL);
          ROSE_ASSERT(cd->get_firstNondefiningDeclaration() != NULL);
#if 0
          printf ("In SgClassType::createType(): returnType->get_declaration()->get_firstNondefiningDeclaration() = %p = %s cd->get_firstNondefiningDeclaration() = %p = %s \n",
               returnType->get_declaration()->get_firstNondefiningDeclaration(),returnType->get_declaration()->get_firstNondefiningDeclaration()->class_name().c_str(),
               cd->get_firstNondefiningDeclaration(),cd->get_firstNondefiningDeclaration()->class_name().c_str());
#endif
        }
#if 0
  // DQ (1/22/2013): We can't assert this when we have complex template handling as in Boost.
  // This case is demonstrated in Boost as part of ROSE compiling ROSE in testRoseHeaders_01.C

  // DQ (8/23/2012): Restoring the original code...
     ROSE_ASSERT(returnType->get_declaration() == cd);
#else
  // DQ (8/23/2012): Note clear if this is helpful given the new name handling to resolve template instantiations when template arguments are NOT name qualified.
  // This fails for test2011_121.C.
  // ROSE_ASSERT(returnType->get_declaration() == cd);

#if 0
  // DQ (3/12/2015): This is failing the test for spurious output, so I will comment out the warning.
  // DQ (2/14/2015): Adding filter to throttle this output.  I think it is important, but it appears to not be critical at the moment.
  // It also appears to be a direct result of the bug fix that removed the collision of computed function types in test2015_11.C.
     if (returnType->get_declaration() != cd)
        {
          static int counter = 0;
          if (counter % 100 == 0)
             {
               printf ("WARNING: In SgClassType::createType(): commented out asertion returnType->get_declaration() == cd \n");
             }

          counter++;
        }
#endif
#endif

#if DEBUG_CREATE_TYPE_FOR_CLASS_TYPE
     printf ("Leaving SgClassType::createType(): returnType = %p = %s \n",returnType,returnType->class_name().c_str());
#endif

  // return ($CLASSNAME*) returnType;
     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_CLASS_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETERIZED_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
SgJavaParameterizedType*
SgJavaParameterizedType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgJavaParameterizedType::createType() \n");
#endif

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETERIZED_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_QUALIFIED_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
SgJavaQualifiedType*
SgJavaQualifiedType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgJavaQualifiedType::createType() \n");
#endif

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_QUALIFIED_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_WILDCARD_TYPE_START

SgJavaWildcardType*
SgJavaWildcardType::createType(SgClassDeclaration *cd, SgExpression* optional_fortran_type_kind)
   {
  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgJavaWildcardType::createType() \n");
#endif

     SgJavaWildcardType* returnType = new SgJavaWildcardType(cd);

     return returnType;
   }
SOURCE_CREATE_TYPE_FOR_JAVA_WILDCARD_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_UNION_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
SgJavaUnionType*
SgJavaUnionType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgJavaUnionType::createType() \n");
#endif

     return ($CLASSNAME*) cd->get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_UNION_TYPE_END


SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETER_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
SgJavaParameterType*
SgJavaParameterType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgJavaParameterType::createType() \n");
#endif

     if (! cd -> get_type()) {
         $CLASSNAME *newType = new $CLASSNAME(cd);
         cd -> set_type(newType);
     }
     return ($CLASSNAME *) cd -> get_type();
   }

SOURCE_CREATE_TYPE_FOR_JAVA_PARAMETER_TYPE_END


SOURCE_CREATE_TYPE_FOR_JOVIAL_TABLE_TYPE_START

// SgClassType* SgClassType::createType(SgClassDeclaration * cd)
// Rasmussen - why is optional_fortran_type_kind a parameter?
SgJovialTableType*
SgJovialTableType::createType(SgClassDeclaration * cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     if (! cd -> get_type()) {
         $CLASSNAME *newType = new $CLASSNAME(cd);
         cd -> set_type(newType);
     }
     return ($CLASSNAME *) cd -> get_type();
   }

SOURCE_CREATE_TYPE_FOR_JOVIAL_TABLE_TYPE_END


SOURCE_CREATE_TYPE_FOR_TEMPLATE_TYPE_START

SgTemplateType*
SgTemplateType::createType(SgTemplateDeclaration* cd, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(cd != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     printf ("SgTemplateType::createType(SgTemplateDeclaration*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

  // return ($CLASSNAME*) cd->get_type();
     return NULL;
   }

SOURCE_CREATE_TYPE_FOR_TEMPLATE_TYPE_END

SOURCE_CREATE_TYPE_FOR_NONREAL_TYPE_START

SgNonrealType*
SgNonrealType::createType(SgNonrealDecl* decl, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(decl != NULL);

     printf ("SgNonrealType::createType(SgTemplateDeclaration*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_CREATE_TYPE_FOR_NONREAL_TYPE_END

SOURCE_CREATE_TYPE_FOR_AUTO_TYPE_START

SgAutoType*
SgAutoType::createType(SgNode* n, SgExpression* optional_fortran_type_kind)
   {
     printf ("SgAutoType::createType(SgNode*,SgExpression*) implemented to return NULL \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_CREATE_TYPE_FOR_AUTO_TYPE_END

SOURCE_CREATE_TYPE_FOR_POINTER_TYPE_START
// SgPointerType* SgPointerType::createType(SgType* base_type)
SgPointerType*
SgPointerType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (10/4/2010): I think that pointer types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgPointerType::createType() \n");
#endif

     if (base_type->p_ptr_to != NULL)
        {
          return base_type->p_ptr_to;
        }
       else
        {
#if 0
          SgPointerType* newType = new SgPointerType(base_type);
          assert(newType != NULL);
#else
          SgPointerType* newType = new SgPointerType(base_type);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

#if 0
          printf ("Building a pointer to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif

       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
#if 0
            // This is too agressive and fails for some test codes!
               printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) \n",name.str());
               get_globalTypeTable()->insert_type(name,newType);
#else
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if 0
                    printf ("Mangled type name for SgPointerType = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if 0
                    printf ("Skip putting the SgPointerType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
#endif
             }
            else
             {
            // This should be only a pointer to a SgModifierType (e.g. a pointer to a const base_type) NOT TRUE.
            // ROSE_ASSERT(isSgModifierType(base_type) != NULL || isSgFunctionType(base_type) != NULL);

            // The pointer type was found in either the local or global table (but the base_type->p_ptr_to should have been valid).
            // printf ("WARNING: the pointer to a base type = %p = %s should exist, we need to find it! \n",base_type,base_type->class_name().c_str());
            // ROSE_ASSERT(false);

            // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
               printf ("Mangled type name for SgPointerType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgPointerType(t);
             }
#endif

          base_type->p_ptr_to = newType;
          assert(base_type->p_ptr_to != NULL);

          return base_type->p_ptr_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_POINTER_TYPE_END


SOURCE_CREATE_TYPE_FOR_REFERENCE_TYPE_START
// SgReferenceType* SgReferenceType::createType(SgType* base_type)
SgReferenceType*
SgReferenceType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgReferenceType::createType() \n");
#endif

     if (base_type->p_ref_to)
        {
          return base_type->p_ref_to;
        }
       else
        {
#if 0
          SgReferenceType* newType = new SgReferenceType(base_type);
          assert(newType != NULL);
#else
          SgReferenceType* newType = new SgReferenceType(base_type);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

#if 0
          printf ("Building a reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
#if 0
            // This is too agressive and fails for some test codes!
               printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) \n",name.str());
               get_globalTypeTable()->insert_type(name,newType);
#else
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if 0
                    printf ("Skip putting the SgReferenceType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
#endif
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
               printf ("Mangled type name for SgReferenceType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgReferenceType(t);
             }
#endif

          base_type->p_ref_to = newType;
          assert(base_type->p_ref_to != NULL);

          return base_type->p_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_REFERENCE_TYPE_END


SOURCE_CREATE_TYPE_FOR_RVALUE_REFERENCE_TYPE_START
SgRvalueReferenceType*
SgRvalueReferenceType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (7/29/2014): I think that rvalue reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgRvalueReferenceType::createType() \n");
#endif

     if (base_type->p_rvalue_ref_to)
        {
          return base_type->p_rvalue_ref_to;
        }
       else
        {
          SgRvalueReferenceType* newType = new SgRvalueReferenceType(base_type);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

#if 0
          printf ("Building a rvalue reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if 0
                    printf ("Skip putting the SgReferenceType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
               printf ("Mangled type name for SgReferenceType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgRvalueReferenceType(t);
             }

          base_type->p_rvalue_ref_to = newType;
          assert(base_type->p_rvalue_ref_to != NULL);

          return base_type->p_rvalue_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_RVALUE_REFERENCE_TYPE_END


SOURCE_CREATE_TYPE_FOR_DECL_TYPE_START
// SgDeclType* SgDeclType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
SgDeclType*
SgDeclType::createType(SgExpression* base_expression, SgExpression* optional_fortran_type_kind)
   {
#if 1
  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgDeclType* newType = new SgDeclType(base_expression);
     assert(newType != NULL);
#define INSERT_DECL_TYPE_IN_GLOBAL_TYPE_TABLE 1
#if INSERT_DECL_TYPE_IN_GLOBAL_TYPE_TABLE
     SgName name = newType->get_mangled();
     SgType* t = get_globalTypeTable()->lookup_type(name);
     ROSE_ASSERT(!(t != NULL) || isSgDeclType(t)); // (t != NULL) => isDeclType(t)
     if (t != NULL) {
       delete newType;
       newType = isSgDeclType(t);
     } else {
       get_globalTypeTable()->insert_type(name,newType);
     }
#endif
     return newType;
#else
  // DQ (8/2/2014): The decltype takes an expression (and stores it) but references the type of that expression.
     SgType* base_type = base_expression->get_type();
     ROSE_ASSERT(base_type != NULL);

  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgDeclType::createType() \n");
#endif

     if (base_type->p_decltype_ref_to)
        {
          return base_type->p_decltype_ref_to;
        }
       else
        {
          SgDeclType* newType = new SgDeclType(base_expression);
          assert(newType != NULL);

          SgName name = newType->get_mangled();

#if 0
          printf ("Building a decltype reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

       // DQ (2/23/2016): Add test and reset type returned from globalTypeTable if it is not a SgDeclType.
       // I have at least one case where the type table returns a SgModifierType (not clear if that is correct behavior).
       // Detect this case for now and make sure it can't happen in general.
          if (t != NULL && isSgDeclType(t) == NULL)
             {
               printf ("Error: This name = %s does not return the correct type from the globalTypeTable: t = %p = %s reset t == NULL \n",name.str(),t,t->class_name().c_str());

            // Note: were we detect that this is a SgModifierType it is a default built SgModifierType.
            // This kind of SgModifierType is only used in the frontend to support references to types 
            // in templates that have not been defined yet.  It is rare to see these.  In this case the
            // modifier's name mangling does not change the name and so that name can appear in the 
            // globalTypeTable() and a SgModifierType.  For now we are issuing a warning about this and
            // forcing a new SgDeclType type to be used.
               SgModifierType* modifierType = isSgModifierType(t);
               if (modifierType != NULL)
                  {
#if 0
                    SgTypeModifier & typeModifier = modifierType->get_typeModifier();
                    typeModifier.display("does not return the correct type from the globalTypeTable");
#endif
#if 0
                    printf ("Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
               t = NULL;
             }

          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if 0
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if 0
                    printf ("Skip putting the SgDeclType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
               printf ("Mangled type name for SgDeclType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgDeclType(t);

            // DQ (2/23/2016): Added assertion.
               if (newType == NULL)
                  {
                    printf ("In createType(SgExpression* base_expression, SgExpression* kind): isSgDeclType(t) == NULL: error: t = %p = %s \n",t,t->class_name().c_str());
                  }
               assert(newType != NULL);
             }

       // DQ (2/23/2016): Added assertion.
          assert(newType != NULL);

          base_type->p_decltype_ref_to = newType;
          assert(base_type->p_decltype_ref_to != NULL);

          return base_type->p_decltype_ref_to;
        }
#endif
   }

SOURCE_CREATE_TYPE_FOR_DECL_TYPE_END


SOURCE_CREATE_TYPE_FOR_TYPEOF_TYPE_START
// SgDeclType* SgDeclType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
SgTypeOfType*
SgTypeOfType::createType(SgExpression* base_expression, SgExpression* optional_fortran_type_kind)
   {
#if 0
     printf ("In SgTypeOfType::createType() \n");
#endif

  // DQ (8/2/2014): The decltype takes an expression (and stores it) but references the type of that expression.
     SgType* base_type = base_expression->get_type();
     ROSE_ASSERT(base_type != NULL);

  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#define DEBUG_TYPEOF_CREATETYPE_EXP 0

     if (base_type->p_typeof_ref_to != NULL)
        {
#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("In SgTypeOfType::createType(SgExpression*): test 1: base_type->p_typeof_ref_to = %p = %s \n",base_type->p_typeof_ref_to,base_type->p_typeof_ref_to->class_name().c_str());
#endif
          return base_type->p_typeof_ref_to;
        }
       else
        {
          SgTypeOfType* newType = new SgTypeOfType(base_expression,NULL);
          ROSE_ASSERT(newType != NULL);

          SgName name = newType->get_mangled();

#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("Building a typeoftype (expression argument) reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("Building a typeoftype (expression argument): t = get_globalTypeTable()->lookup_type(name): t = %p \n",t);
#endif
          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if DEBUG_TYPEOF_CREATETYPE_EXP
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if DEBUG_TYPEOF_CREATETYPE_EXP
                    printf ("Skip putting the SgTypeOfType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if DEBUG_TYPEOF_CREATETYPE_EXP
               printf ("Mangled type name for SgTypeOfType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgTypeOfType(t);
             }

#if 0
       // DQ (4/7/2015): We have to allow that all expressions could be different, so we can't reuse the same typeof type.
          base_type->p_typeof_ref_to = newType;
          assert(base_type->p_typeof_ref_to != NULL);
#if DEBUG_TYPEOF_CREATETYPE_EXP
          printf ("In SgTypeOfType::createType(SgExpression*): test 2: base_type->p_typeof_ref_to = %p = %s \n",base_type->p_typeof_ref_to,base_type->p_typeof_ref_to->class_name().c_str());
#endif
          return base_type->p_typeof_ref_to;
#else
       // DQ (4/7/2015): We have to allow that all expressions could be different, so we can't reuse the same typeof type (return the neType).
          return newType;
#endif
        }
   }

SgTypeOfType*
SgTypeOfType::createType(SgType* base_type, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/2/2014): The decltype takes an expression (and stores it) but references the type of that expression.
  // SgType* base_type = base_type;
     ROSE_ASSERT(base_type != NULL);

  // DQ (8/2/2014): I think that decltype reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#define DEBUG_TYPEOF_CREATETYPE_TYPE 0

#if DEBUG_TYPEOF_CREATETYPE_TYPE
     printf ("Building a typeoftype (type argument) base_type->p_typeof_ref_to = %p \n",base_type->p_typeof_ref_to);
#endif

#if 0
     printf ("In SgTypeOfType::createType() \n");
#endif

     if (base_type->p_typeof_ref_to)
        {
          return base_type->p_typeof_ref_to;
        }
       else
        {
          SgTypeOfType* newType = new SgTypeOfType(NULL,base_type);
          ROSE_ASSERT(newType != NULL);

          SgName name = newType->get_mangled();

#if DEBUG_TYPEOF_CREATETYPE_TYPE
          printf ("Building a typeoftype (type argument) reference to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif
       // Only look for pointers to type in the global type table.
          SgType* t = get_globalTypeTable()->lookup_type(name);

#if DEBUG_TYPEOF_CREATETYPE_TYPE
          printf ("Building a typeoftype (type argument) get_globalTypeTable()->lookup_type(name = %s) = %p = %s \n",name.str(),t,t != NULL ? t->class_name().c_str() : "null");
#endif
          if (t == NULL)
             {
            // The pointer type was not found in the type table, put it into the global type table.
               SgType* root_type = base_type->stripType();
               ROSE_ASSERT(root_type != NULL);
               if (handledUsingLocalTable(root_type) == false)
                  {
#if DEBUG_TYPEOF_CREATETYPE_TYPE
                    printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
                    get_globalTypeTable()->insert_type(name,newType);
                  }
                 else
                  {
#if DEBUG_TYPEOF_CREATETYPE_TYPE
                    printf ("Skip putting the SgTypeOfType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
                  }
             }
            else
             {
            // If it is already present in the type table then delete the type (so that it will remain unique).
#if DEBUG_TYPEOF_CREATETYPE_TYPE
               printf ("Mangled type name for SgTypeOfType = %s (already exists in type table) \n",name.str());
#endif
               ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
            // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
            // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
            // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
               delete newType;
#endif
               newType = NULL;

               newType = isSgTypeOfType(t);
             }

          base_type->p_typeof_ref_to = newType;
          assert(base_type->p_typeof_ref_to != NULL);

          return base_type->p_typeof_ref_to;
        }
   }

SOURCE_CREATE_TYPE_FOR_TYPEOF_TYPE_END


SOURCE_CREATE_TYPE_FOR_ARRAY_TYPE_START

// SgArrayType* SgArrayType::createType ( SgType* base_type, SgExpression* idx )
SgArrayType*
SgArrayType::createType ( SgType* base_type, SgExpression* idx, SgExpression* optional_fortran_type_kind)
   {
  // DQ (8/11/2010): It is OK for idx to be NULL, since it implies a declaration such as: "int array[]" which can be OK.

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
     printf ("In SgArrayType::createType() \n");
#endif

     SgArrayType* returnType = new SgArrayType(base_type, idx);
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

#if 0
     printf ("In SgArrayType::createType(): Building an array [exp = %p] of base_type = %p = %s name = %s \n",idx,base_type,base_type->class_name().c_str(),name.str());
     printf ("   --- idx = %p = %s \n",idx,idx->class_name().c_str());
#endif

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

#if 0
     printf ("In SgArrayType::createType(): After get_globalTypeTable()->lookup_type(%s) t = %p \n",name.str(),t);
#endif

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
       // This is too agressive and fails for some test codes!
          printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) \n",name.str());
          get_globalTypeTable()->insert_type(name,returnType);
#else
          SgType* root_type = base_type->stripType();
          ROSE_ASSERT(root_type != NULL);
          if (handledUsingLocalTable(root_type) == false)
             {
#if 0
               printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
               get_globalTypeTable()->insert_type(name,returnType);
             }
            else
             {
#if 0
               printf ("Skip putting the SgArrayType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
             }
#endif
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
          printf ("Mangled type name for SgArrayType = %s (already exists in type table) t = %p returnType = %p \n",name.str(),t,returnType);
#endif
          ROSE_ASSERT(t != returnType);

       // DQ (9/25/2011): the array index can be an expression tree (not just one node) and it can have valid 
       // original expression trees from constant folding.  So we don't want to delete the index unless we are 
       // going to do the job completely. so we want to:
       //    1) Avoid having it be deleted by the SgArrayType destructor.
       //    2) Delete it using the SageInterface::deleteAST() function.
          if (idx != NULL)
             {
#if 0
               printf ("In SgArrayType::createType(): idx = %p (deleting the index subtree) \n",idx);
#endif
               ROSE_ASSERT(idx->get_parent() == NULL);

            // Let the parent point to the SgArrayType that we will return.
               idx->set_parent(t);

               returnType->set_index(NULL);
            // SageInterface::deleteAST(idx);
               SageInterface::deleteExpressionTreeWithOriginalExpressionSubtrees(idx);
               idx = NULL;
             }
          ROSE_ASSERT(returnType->get_index() == NULL);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgArrayType(t);
        }

#if 0
     printf ("In SgArrayType::createType(): idx = %p \n",idx);
#endif

  // DQ (2/20/2007): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (idx != NULL)
        {
#if 0
          printf ("In SgArrayType::createType(): fixing up the array index idx = %p = %s \n",idx,idx->class_name().c_str());
#endif
       // DQ (9/25/2011): If we have deleted the array index then it should be listed as V_SgNode (which would be an error we would want to catch).
          ROSE_ASSERT(idx->variantT() != V_SgNode);

          ROSE_ASSERT(idx->get_parent() == NULL);
          idx->set_parent(returnType);
        }

     return returnType;
  // return new $CLASSNAME(base_type, idx);
   }

SOURCE_CREATE_TYPE_FOR_ARRAY_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_ACCESS_TYPE_START

SgAdaAccessType*
SgAdaAccessType::createType (SgType* base_type, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaAccessType  proto(base_type); // \pp not sure if stack allocation works
  SgName           name = proto.get_mangled();
  SgType*          ty = get_globalTypeTable()->lookup_type(name);
  
  if (SgAdaAccessType* unified = isSgAdaAccessType(ty))
    return unified;
   
  ROSE_ASSERT(ty == NULL); 
  SgAdaAccessType* res = new SgAdaAccessType(base_type);
  
  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_ACCESS_TYPE_END

SOURCE_CREATE_TYPE_FOR_ADA_SUBTYPE_START

SgAdaSubtype*
SgAdaSubtype::createType (SgType* base_type, SgAdaTypeConstraint* constraint, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaSubtype  proto(base_type, constraint); // \pp not sure if stack allocation works
  SgName        name = proto.get_mangled();
  SgType*       ty = get_globalTypeTable()->lookup_type(name);
  
  if (SgAdaSubtype* unified = isSgAdaSubtype(ty))
    return unified;
   
  ROSE_ASSERT(ty == NULL); 
  SgAdaSubtype* res = new SgAdaSubtype(base_type, constraint);
  
  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_SUBTYPE_END


SOURCE_CREATE_TYPE_FOR_ADA_FLOAT_TYPE_START

SgAdaFloatType*
SgAdaFloatType::createType (SgExpression* digits, SgAdaRangeConstraint* range, SgExpression* /*optional_fortran_type_kind*/)
{
  SgAdaFloatType   proto(digits, range); 
  SgName           name = proto.get_mangled();
  SgType*          ty   = get_globalTypeTable()->lookup_type(name);
  
  if (SgAdaFloatType* unified = isSgAdaFloatType(ty))
    return unified;
   
  ROSE_ASSERT(ty == NULL); 
  SgAdaFloatType* res = new SgAdaFloatType(digits, range);
  
  get_globalTypeTable()->insert_type(name, res);
  return res;
}

SOURCE_CREATE_TYPE_FOR_ADA_FLOAT_TYPE_END


// Rasmussen (2/19/2020): Added SgTypedFixed (primitive type in Jovial)
SOURCE_CREATE_TYPE_FOR_TYPE_FIXED_START

SgTypeFixed*
SgTypeFixed::createType ( SgExpression* scale, SgExpression* fraction, SgExpression* optional_fortran_type_kind )
   {
  // There is no size (equivalent to Fortran kind) parameter for Jovial fixed type
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

     SgTypeFixed* return_type = new SgTypeFixed(scale, fraction);
     ROSE_ASSERT(return_type != NULL);

     SgName name = return_type->get_mangled();

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);
     if (t == NULL)
        {
           get_globalTypeTable()->insert_type(name,return_type);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          ROSE_ASSERT(t != return_type);
          delete return_type;
#endif
          return_type = isSgTypeFixed(t);
        }

     return return_type;
   }

SOURCE_CREATE_TYPE_FOR_TYPE_FIXED_END


SOURCE_CREATE_TYPE_FOR_STRING_TYPE_START

// SgTypeString* SgTypeString::createType ( SgExpression* idx, size_t length, SgExpression* optional_fortran_type_kind )
SgTypeString*
SgTypeString::createType ( SgExpression* lengthExpression, SgExpression* optional_fortran_type_kind )
   {
  // DQ (8/17/2010): This is the new SgStringType IR node (now used in Fortran, but not previously used in C/C++).

  // DQ (8/17/2010): lengthExpression can be NULL, and even the length could be zero (e.g. for a empty string).
  // ROSE_ASSERT(idx != NULL);
  // ROSE_ASSERT((idx != NULL) || (length > 0));

#if 0
     printf ("In SgTypeString::createType() \n");
#endif

  // SgTypeString* returnType = new SgTypeString(lengthExpression,length);
     SgTypeString* returnType = new SgTypeString(lengthExpression);
     if (optional_fortran_type_kind != NULL)
        {
          returnType->set_type_kind(optional_fortran_type_kind);
          optional_fortran_type_kind->set_parent(returnType);
        }
     ROSE_ASSERT(returnType != NULL);

     SgName name = returnType->get_mangled();

#if 0
     printf ("In SgTypeString::createType(): Building an character string [exp = %p] mangled name = %s \n",lengthExpression,name.str());
#endif

  // Only look for pointers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
          printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
          get_globalTypeTable()->insert_type(name,returnType);
        }
       else
        {
       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
          printf ("Mangled type name for SgStringType = %s (already exists in type table) \n",name.str());
#endif
          ROSE_ASSERT(t != returnType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete returnType;
#endif
          returnType = NULL;

          returnType = isSgTypeString(t);
        }

  // DQ (2/20/2007): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (lengthExpression != NULL)
        {
          ROSE_ASSERT(lengthExpression->get_parent() == NULL);
          lengthExpression->set_parent(returnType);
        }

  // DQ (10/9/2010): Added setting the parent (which should not have been set already)
  // note also that the index expression is not required to be specified.
     if (optional_fortran_type_kind != NULL && optional_fortran_type_kind->get_parent() == NULL)
        {
       // ROSE_ASSERT(optional_fortran_type_kind->get_parent() == NULL);
          optional_fortran_type_kind->set_parent(returnType);
        }

     return returnType;
   }

SOURCE_CREATE_TYPE_FOR_STRING_TYPE_END


SOURCE_CREATE_TYPE_FOR_MODIFIER_TYPE_START

// SgModifierType* SgModifierType::createType(SgType* base_type, unsigned int f)
SgModifierType*
SgModifierType::createType(SgType* base_type, unsigned int f, SgExpression* optional_fortran_type_kind )
   {
  // DQ (7/28/2010): Now we make it an error to call this function!
     printf ("ERROR: This function should not be called (replaced by different API plus insertModifierTypeIntoTypeTable()) \n");
     ROSE_ASSERT(false);

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

#if 0
  // DQ (7/26/2010): Note that "unsigned int f" is not used!
     ROSE_ASSERT(base_type != NULL);

  // DQ (4/13/2004): See if we can get rid of this function, but first lets find out where it is called!
  // This is part of the work to reorganize now modifiers are used internally.
  // return base_type->matchModifiers(f);
  // printf ("Error, no longer supported! \n");
  // ROSE_ASSERT (false);
  // return NULL;

#if 0
  // DQ (7/26/2010): Alternative code which does NOT properly abstract the creation of the type using the new type table.
     SgModifierType* newType = new SgModifierType(base_type);
     ROSE_ASSERT(newType != NULL);
  // base_type->matchModifiers(f);
#else
     SgModifierType* newType = new SgModifierType(base_type);
     ROSE_ASSERT(newType != NULL);
  // base_type->matchModifiers(f);

     SgName name = newType->get_mangled();

#if 0
     printf ("Building a modifier type to base_type = %p = %s name = %s \n",base_type,base_type->class_name().c_str(),name.str());
#endif

  // Only look for modifiers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
       // This is too agressive and fails for some test codes!
          printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) \n",name.str());
          get_globalTypeTable()->insert_type(name,newType);
#else
          SgType* root_type = base_type->stripType();
          ROSE_ASSERT(root_type != NULL);
          if (handledUsingLocalTable(root_type) == false)
             {
#if 0
               printf ("Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
               get_globalTypeTable()->insert_type(name,newType);
             }
            else
             {
            // For now we can skip this case and then later use the local type table from the scope of the declaration.
#if 0
               printf ("Skip putting the SgModifierType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
             }
#endif
        }
       else
        {
       // This should be only a pointer to a SgModifierType (e.g. a pointer to a const base_type) NOT TRUE.
       // ROSE_ASSERT(isSgModifierType(base_type) != NULL || isSgFunctionType(base_type) != NULL);

       // The pointer type was found in either the local or global table (but the base_type->p_ptr_to should have been valid).
       // printf ("WARNING: the pointer to a base type = %p = %s should exist, we need to find it! \n",base_type,base_type->class_name().c_str());
       // ROSE_ASSERT(false);

       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
           printf ("Mangled type name for SgModifierType = %s t = %p = %s (already exists in type table) \n",name.str(),t,t->class_name().c_str());
#endif
          ROSE_ASSERT(t != newType);

#if ALLOW_DELETE_OF_EXPLORATORY_NODE
       // DQ (10/26/2016): Suppress the delete to test mergeTest_04 behavior.
       // It might be that in the memory pool traversal we can't be allocating and deallocating IR nodes that we might be traversing.
       // This is now fixed by making a copy of the nodes to be traversed with the visit function before calling the visit function on those IR nodes.
          delete newType;
#endif
          newType = NULL;

          newType = isSgModifierType(t);
          ROSE_ASSERT(newType != NULL);
        }
#endif

     ROSE_ASSERT(newType != NULL);
     return newType;
#else
     return NULL;
#endif
   }

SgModifierType*
SgModifierType::insertModifierTypeIntoTypeTable( SgModifierType* result )
   {
  // DQ (7/28/2010): Insert result type into type table and return it, or
  // replace the result type, if already available in the type table, with
  // the type from type table.

  // An assumption (that I don't know how to check currently) is that this is a newly built
  // type not previously used and not yet returned from any of the following functions
  // calling this function. Thus is has not been added yet to any (global or local) type table.
     ROSE_ASSERT(result != NULL);

#if 0
  // DQ (7/26/2010): Alternative code which does NOT properly abstract the creation of the type using the new type table.
     return result;
#else
  // This is the type after some specification (setting) via type modifier flags. We could verify
  // this by testing that at least one type modifier flag was set, not done yet.
     SgName name = result->get_mangled();

#if 0
     printf ("insertModifierTypeIntoTypeTable(): result is modifier type to base_type = %p = %s name = %s \n",result->get_base_type(),result->get_base_type()->class_name().c_str(),name.str());
#endif

  // Only look for modifiers to type in the global type table.
     SgType* t = get_globalTypeTable()->lookup_type(name);

     if (t == NULL)
        {
       // The pointer type was not found in the type table, put it into the global type table.
#if 0
       // This is too agressive and fails for some test codes!
          printf ("insertModifierTypeIntoTypeTable(): Mangled type name for $CLASSNAME = %s (does NOT exist in type table) \n",name.str());
          get_globalTypeTable()->insert_type(name,newType);
#else
       // DQ (4/15/2019): Adding pointer to member support: not using SgType::STRIP_POINTER_MEMBER_TYPE
       // printf ("In SgModifierType::insertModifierTypeIntoTypeTable(): Adding pointer to member support: not using SgType::STRIP_POINTER_MEMBER_TYPE \n");

       // DQ (7/30/2018): This function can't just strip down to the bae type (past typedefs, since we need 
       // to resolve different typedefs in different classes to be different, we need to stop at typedefs.
       // This issue is important ot Cxx11_tests/test2018_134.C where a typedef is not to be shared since it 
       // exists in two different classes.  Basically typedefs have a declaration which make then have a local 
       // scope which is different from other types (such a modifiers, references, pointers, and array types).
       // SgType* root_type = result->stripType();
       // unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE;
       // unsigned char bit_array = STRIP_ARRAY_TYPE | STRIP_TYPEDEF_TYPE;
          unsigned char bit_array = STRIP_MODIFIER_TYPE | STRIP_REFERENCE_TYPE | STRIP_RVALUE_REFERENCE_TYPE | STRIP_POINTER_TYPE | STRIP_ARRAY_TYPE;
          SgType* root_type = result->stripType(bit_array);
          ROSE_ASSERT(root_type != NULL);
#if 0
          printf ("insertModifierTypeIntoTypeTable(): result not previously seen (or not in globalTypeTable) result = %p = %s name = %s \n",result,result->class_name().c_str(),name.str());
          printf ("insertModifierTypeIntoTypeTable(): root_type = %p = %s \n",root_type,root_type->class_name().c_str());
#endif
          if (handledUsingLocalTable(root_type) == false)
             {
#if 0
               printf ("insertModifierTypeIntoTypeTable(): Mangled type name for $CLASSNAME = %s (does NOT exist in type table) inserting it... \n",name.str());
#endif
               get_globalTypeTable()->insert_type(name,result);
             }
            else
             {
            // For now we can skip this case and then later use the local type table from the scope of the declaration.
#if 0
               printf ("insertModifierTypeIntoTypeTable(): Skip putting the SgModifierType into the global type table for specific root types = %s name = %s \n",root_type->class_name().c_str(),name.str());
#endif
             }
#endif
        }
       else
        {
       // TV (07/13/2018): At the very least they should have the same stripped type... (it would happen if the base types have colliding mangled name)
       // ROSE_ASSERT(t->stripType() == result->stripType());
          if (t->stripType() != result->stripType())
             {
               printf ("insertModifierTypeIntoTypeTable(): result is modifier type to base_type = %p = %s name = %s \n",result->get_base_type(),result->get_base_type()->class_name().c_str(),name.str());
               printf ("t      = %p = %s \n",t,t->class_name().c_str());
               printf ("result = %p = %s \n",result,result->class_name().c_str());
               SgType* t_stripped      = t->stripType();
               SgType* result_stripped = result->stripType();
               printf ("t_stripped           = %p = %s \n",t_stripped,t_stripped->class_name().c_str());
               printf ("result_stripped      = %p = %s \n",result_stripped,result_stripped->class_name().c_str());

               SgName t_name      = t->get_mangled();
               SgName result_name = result->get_mangled();

               printf ("t_name      = %s \n",t_name.str());
               printf ("result_name = %s \n",result_name.str());

               bool t_isTypeEquivalent          = t->isEquivalentType(result);
               bool t_stripped_isTypeEquivalent = t_stripped->isEquivalentType(result_stripped);

               printf ("t_isTypeEquivalent          = %s \n",t_isTypeEquivalent ? "true" : "false");
               printf ("t_stripped_isTypeEquivalent = %s \n",t_stripped_isTypeEquivalent ? "true" : "false");

               SgNamedType* t_namedType      = isSgNamedType(t_stripped);
               SgNamedType* result_namedType = isSgNamedType(result_stripped);
               if (t_namedType != NULL && result_namedType != NULL)
                  {
                    SgDeclarationStatement* t_declaration = isSgDeclarationStatement(t_namedType->get_declaration());
                    ROSE_ASSERT(t_declaration != NULL);
                    SgDeclarationStatement* result_declaration = isSgDeclarationStatement(result_namedType->get_declaration());
                    ROSE_ASSERT(result_declaration != NULL);

                    printf ("t_declaration      = %p = %s \n",t_declaration,t_declaration->class_name().c_str());
                    printf ("result_declaration = %p = %s \n",result_declaration,result_declaration->class_name().c_str());

                    printf ("t_namedType->get_name()      = %s \n",t_namedType->get_name().str());
                    printf ("result_namedType->get_name() = %s \n",result_namedType->get_name().str());

                    SgName t_stripped_name      = t_stripped->get_mangled();
                    SgName result_stripped_name = result_stripped->get_mangled();

                    printf ("t_stripped_name      = %s \n",t_stripped_name.str());
                    printf ("result_stripped_name = %s \n",result_stripped_name.str());

                    SgNonrealDecl* t_nonreal_declaration      = isSgNonrealDecl(t_declaration);
                    SgNonrealDecl* result_nonreal_declaration = isSgNonrealDecl(result_declaration);

                    if (t_nonreal_declaration != NULL && result_nonreal_declaration != NULL)
                       {
                         printf ("t_nonreal_declaration->get_name()      = %s \n",t_nonreal_declaration->get_name().str());
                         printf ("result_nonreal_declaration->get_name() = %s \n",result_nonreal_declaration->get_name().str());
                       }
                  }
             }
       // DQ (12/15/2019): Comment out as a test!
          ROSE_ASSERT(t->stripType() == result->stripType());

       // This should be only a pointer to a SgModifierType (e.g. a pointer to a const base_type) NOT TRUE.
       // ROSE_ASSERT(isSgModifierType(base_type) != NULL || isSgFunctionType(base_type) != NULL);

       // The pointer type was found in either the local or global table (but the base_type->p_ptr_to should have been valid).
       // printf ("WARNING: the pointer to a base type = %p = %s should exist, we need to find it! \n",base_type,base_type->class_name().c_str());
       // ROSE_ASSERT(false);

       // If it is already present in the type table then delete the type (so that it will remain unique).
#if 0
          printf ("insertModifierTypeIntoTypeTable(): Mangled type name for SgModifierType = %s t = %p = %s (already exists in type table) \n",name.str(),t,t->class_name().c_str());
          printf ("insertModifierTypeIntoTypeTable(): t = %p result = %p \n",t,result);
#endif

#if 0
          if (t != result)
             {
            // Never delete the input type!
            // delete result;
            // result = NULL;

               result = isSgModifierType(t);
             }
#else
       // DQ (7/30/2010): Because SageBuilder::buildModifierType(SgType*) can be still
       // called by mistake, we have to handle the case of where the type in the table is
       // not a SgModifierType.
          if (isSgModifierType(t) != NULL)
             {
#if 0
               printf ("insertModifierTypeIntoTypeTable(): Reset result (the return variabel) to be the SgModifier found in the type table (t = %p) \n",t);
#endif
               result = isSgModifierType(t);
             }
#if 0
       // DQ (8/27/2010): There is no problem with t not being a SgModifierType.
            else
             {
            // We want to later make this an error (the cause for this problem is the change to the build API for modifiers.
               ROSE_ASSERT(t != NULL);
               printf ("Error: SageBuilder::buildModifierType(SgType*) was called inapropriately internally t = %p = %s \n",t,t->class_name().c_str());
             }
#endif
#endif
          ROSE_ASSERT(result != NULL);
        }
#endif

     ROSE_ASSERT(result != NULL);

     return result;
   }

SOURCE_CREATE_TYPE_FOR_MODIFIER_TYPE_END

SOURCE_CREATE_TYPE_FOR_QUALIFIED_NAME_TYPE_START
// $CLASSNAME* $CLASSNAME::createType(SgType* base_type, unsigned int f)
$CLASSNAME*
$CLASSNAME::createType(SgType* base_type, unsigned int f, SgExpression* optional_fortran_type_kind)
   {
     ROSE_ASSERT(base_type != NULL);

  // DQ (10/4/2010): I think that reference types can't have a kind parameter, so this should be NULL.
     ROSE_ASSERT(optional_fortran_type_kind == NULL);

  // DQ (12/21/2005): This is a copy of the function from SgModifierType
  // (I think we need it to override the base class implementation).

     printf ("Error, this function $CLASSNAME should not have been called! \n");
     ROSE_ASSERT (false);

     return NULL;
   }

SOURCE_CREATE_TYPE_FOR_QUALIFIED_NAME_TYPE_END


SOURCE_CREATE_TYPE_FOR_COMPLEX_TYPE_START

// DQ (8/27/2006): This code is used for both SgTypeComplex and SgTypeImaginary.

$CLASSNAME*
$CLASSNAME::createType(SgType* t, SgExpression* optional_fortran_type_kind)
   {
#if 0
     printf ("In $CLASSNAME::createType() (CREATE_TYPE_FOR_COMPLEX_TYPE) \n");
#endif

  // Not clear why this is using a map???
     static std::map<SgType*, $CLASSNAME*> cache;

     $CLASSNAME*& returnType = cache[t];

     if (returnType == NULL)
        {
          returnType = new $CLASSNAME(t);
        }
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SgExpression *
$CLASSNAME::get_type_kind () const
   {
     return this->get_base_type()->get_type_kind();
   }

void
$CLASSNAME::set_type_kind ( SgExpression* type_kind )
   {
     this->get_base_type()->set_type_kind(type_kind);
   }

SOURCE_CREATE_TYPE_FOR_COMPLEX_TYPE_END
