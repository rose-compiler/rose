// -*- c++ -*-
HEADER_NODE_PREDECLARATION_START

#include <semaphore.h>

// tps (01/27/10): Added essential files..
//#include "sage3basic.h"
#include <rosePublicConfig.h>
#include "setup.h"
#include "rangemap.h"
#include "Map.h"

#include <boost/format.hpp>
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/version.hpp>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include <Sawyer/CommandLine.h>
#include <Sawyer/Interval.h>
#include <Sawyer/IntervalSet.h>

#include "Cxx_Grammar.h"

#include "processSupport.h"
#define __builtin_constant_p(exp) (0)


class PreprocessingInfo;
class AstRegExAttribute;
class AstAttribute;
class AstAttributeMechanism;

// DQ (4/21/2009): This is not handled uniformally in sage3.h.
// DQ (8/8/2008): This is required to process the "stat64 struct in SgAsmGenericFile
// JJW (8/26/2008): Changed to struct stat with _FILE_OFFSET_BITS == 64 (see
// http://www.gnu.org/software/libc/manual/html_node/Reading-Attributes.html)
// #define _FILE_OFFSET_BITS 64 // Use 64-bit offsets on 32-bit machines when available
// #include <sys/stat.h>

// DQ (6/14/2008): Include the Exec format support.
// #include "ExecGeneric.h"

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <Sawyer/Set.h>
namespace Rose {
  namespace BinaryAnalysis {
    typedef Sawyer::Container::Set<rose_addr_t> AddressSet;
  }
}

#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
using rose_rva_t = Rose::BinaryAnalysis::RelativeVirtualAddress;

#include <Rose/BinaryAnalysis/AddressInterval.h>
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>

// deprecated. Use Rose::BinaryAnalysis::AddressInterval instead for all new code.
typedef Range<rose_addr_t> Extent;

/** Specialized printing for ROSE addresses. */
template<>
void Range<rose_addr_t>::print(std::ostream &o) const;

// deprecated. Use Rose::BinaryAnalysis::AddressIntervalSet instead for all new code.
class ExtentMap: public RangeMap<Extent> {
public:
        ExtentMap(): RangeMap<Extent>() {}
        template<class Other> ExtentMap(const Other &other): RangeMap<Extent>(other) {}
        static char category(const Extent &a, const Extent &b);
        ExtentMap subtract_from(const Extent &e) const {
                return invert_within<ExtentMap>(e);
        }
        void allocate_at(const Extent &request);
        Extent allocate_best_fit(const rose_addr_t size);
        Extent allocate_first_fit(const rose_addr_t size);
        void dump_extents(std::ostream&, const std::string &prefix="", const std::string &label="") const;
        void dump_extents(FILE *f, const char *prefix, const char *label, bool pad=true) const;
};

// deprecated. Conversion functions, to be deleted when the old types are no longer needed.
Extent toExtent(const Rose::BinaryAnalysis::AddressInterval&);
Rose::BinaryAnalysis::AddressInterval toAddressInterval(const Extent&);
ExtentMap toExtentMap(const Rose::BinaryAnalysis::AddressIntervalSet&);
Rose::BinaryAnalysis::AddressIntervalSet toAddressIntervalSet(const ExtentMap&);

/** Settings that control how the lowest-level SgAsmExecutableFileFormat::hexdump function behaves. */
struct HexdumpFormat {
    HexdumpFormat()
        : width(16), colsize(8), multiline(false), show_numeric(true), pad_numeric(true),
          show_chars(true), pad_chars(false) {}

    /* General settings */
    std::string prefix;         /**< Characters to emit after internal linefeeds. */
    size_t width;               /**< Bytes per line of output (default 16). */
    size_t colsize;             /**< Bytes per column group (default 8). */
    std::string addr_fmt;       /**< Printf format for addresses (default "0x%08llx: "). */
    bool multiline;             /**< Emit prefix at beginning and line feed at end of output. */

    /* Settings for numeric output of bytes */
    bool show_numeric;          /**< Show numeric format of bytes (default true). */
    std::string numeric_fmt;    /**< Printf format for bytes (default "%02x"). */
    std::map<unsigned char,std::string> numeric_fmt_special; /**< Special formatting for certain values. */
    std::string numeric_sep;    /**< String to print between numeric values (default " "). */
    bool pad_numeric;           /**< Pad numeric part of output with spaces for partial final line (default true). */

    /* Settings for ASCII output of bytes */
    bool show_chars;            /**< Show ASCII characters after bytes (default true). */
    bool pad_chars;             /**< Pad character part of output with spaces for partial final line (default true). */
};

#include <Rose/BinaryAnalysis/RegisterDescriptor.h>

/** Mapping from instruction virtual address to instruction. */
typedef Map<rose_addr_t, SgAsmInstruction*> InstructionMap;
#endif

// DQ (8/21/2008): these are from the GenericExec.h (from before we used Robb's work in the new IR nodes).
#define NELMTS(X)       (sizeof(X)/sizeof((X)[0]))      /* number of elements in a static-sized array */
#define DUMP_FIELD_WIDTH        64                      /* min columns to use for member names in dump() functions */
#include <semaphore.h>
#ifndef _MSC_VER
// mutex does not work on Windows
// Pei-Hung (07/28/2016) 'sem_init' has been explicitly marked deprecated in OSX El Capitan
#if defined(__APPLE__) && defined(__MACH__)
// mutex does not work on Mac
#else
class mutex
   {
  // This class was added by Valentin David (summer of 2007) as part of support for Stratego using a Java interface.

     private:
          sem_t mut;

     public:
          mutex()
             {
               sem_init(&mut, 1, 1);
             }

          void lock()
             {
               sem_wait(&mut);
             }

          void unlock ()
             {
               sem_post(&mut);
             }
   };
#endif
#endif
//! Declarations to be placed at the top of the header file for this grammar
/*! The typedefs simplify the resulting generated code.  Note that the use of STL
    for the list types requires the use of an additional typedef to a pointer of that
    list<Type> so that the generation of the code can be done using types that don't
    explicitly have the "*" in the type string.  This avoids the automatic assumption
    (currently hard coded within ROSETTA) that "*"'d types have a specific interface
    which includes set_parent and get_parent member functions.  This is assumption
    within ROSETTA may be eliminated in the future.
 */

// endif for ifndef ROSE_USE_SWIG_SUPPORT
// #endif

// #include "virtualCFG.h"

// Turn on internal debugging by default during development
#define SAGE_INTERNAL_DEBUG

#define ROSE_INTEGER_TYPE_MAX_BIT_LENGTH 32

//! declaration of variable to control internal output of debugging information (default = 0)
extern int SAGE_DEBUG;

// Introduce a way to change from std::list to std::vector easily as a test to improve performance of traversals.
// This is now moved to ROSE/util/commandLineProcessing/setup.h so that all of ROSE will see it.
// define Rose_STL_Container std::list
// define Rose_STL_Container std::vector

class SgInitializedName;
// DQ (6/1/2004): Change this to be a list of pointers to SgInitializedName (to fix Beata's Bug beata.C)
typedef Rose_STL_Container<SgInitializedName*> SgInitializedNamePtrList;
typedef SgInitializedNamePtrList*              SgInitializedNamePtrListPtr;

class SgDeclarationStatement;

// DQ (1/28/2016): Different ways of documenting typedefs (none appear to be working with Doxygen).
/** \typedef SgDeclarationStatementPtrList
    \brief This is socumentation for the following typedef
 */
typedef Rose_STL_Container<SgDeclarationStatement*> SgDeclarationStatementPtrList;

/** \typedef SgDeclarationStatementPtrListPtr
    \brief This is socumentation for the following typedef
 */
typedef SgDeclarationStatementPtrList*              SgDeclarationStatementPtrListPtr;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
// tps (8/20/2007): Added support for binaries.
/** \typedef SgAsmBlockPtrList
    This is socumentation for the following typedef
 */
typedef Rose_STL_Container<SgAsmBlock*>     SgAsmBlockPtrList;

/** This is socumentation for the following typedef */
typedef SgAsmBlockPtrList*                  SgAsmBlockPtrListPtr;

// JJW (8/28/2008): Added SgAsmInterpretation
typedef Rose_STL_Container<SgAsmInterpretation*> SgAsmInterpretationPtrList;

// DQ (6/14/2008): Added to support new exec format IR nodes
typedef Rose_STL_Container<SgAsmGenericSection*> SgAsmGenericSectionPtrList;
typedef SgAsmGenericSectionPtrList*              SgAsmGenericSectionPtrListPtr;

typedef Rose_STL_Container<SgAsmGenericFile*> SgAsmGenericFilePtrList;
typedef SgAsmGenericSectionPtrList*           SgAsmGenericFilePtrListPtr;

// DQ (6/14/2008): Added to support new exec format IR nodes
// typedef Rose_STL_Container<SgAsmGenericSegment*> SgAsmGenericSegmentPtrList;
// typedef SgAsmGenericSegmentPtrList*              SgAsmGenericSegmentPtrListPtr;

// DQ (6/14/2008): Added to support new exec format IR nodes
// typedef Rose_STL_Container<SgAsmElfSegmentEntry*> SgAsmElfSegmentEntryPtrList;
// typedef SgAsmElfSegmentEntryPtrList*              SgAsmElfSegmentEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmPEImportItem*> SgAsmPEImportItemPtrList;
typedef SgAsmPEImportItemPtrList*              SgAsmPEImportItemPtrListPtr;

typedef Rose_STL_Container<SgAsmPEImportDirectory*> SgAsmPEImportDirectoryPtrList;
typedef SgAsmPEImportDirectoryPtrList*              SgAsmPEImportDirectoryPtrListPtr;

typedef Rose_STL_Container<SgAsmPEImportItem*> SgAsmPEImportItemPtrList;
typedef SgAsmPEImportItemPtrList*              SgAsmPEImportItemPtrListPtr;

// DQ (6/14/2008): Added to support new exec format IR nodes
typedef Rose_STL_Container<SgAsmElfSymbol*> SgAsmElfSymbolPtrList;
typedef SgAsmElfSymbolPtrList*              SgAsmElfSymbolPtrListPtr;

// DQ (8/4/2008): Added to support new exec format IR nodes
typedef Rose_STL_Container<SgAsmCoffSymbol*> SgAsmCoffSymbolPtrList;
typedef SgAsmCoffSymbolPtrList*              SgAsmCoffSymbolPtrListPtr;

// DQ (8/8/2008): Added to support new exec format IR nodes
typedef Rose_STL_Container<SgAsmGenericSymbol*> SgAsmGenericSymbolPtrList;
typedef SgAsmGenericSymbolPtrList*              SgAsmGenericSymbolPtrListPtr;
#endif

class SgStatement;
typedef Rose_STL_Container<SgStatement*>    SgStatementPtrList;
typedef SgStatementPtrList*                 SgStatementPtrListPtr;

class SgBaseClass;
// DQ (6/21/2005): Change from list of SgBaseClass to list of SgBaseClass*
typedef Rose_STL_Container<SgBaseClass*>    SgBaseClassPtrList;
typedef SgBaseClassPtrList*                 SgBaseClassPtrListPtr;

class SgNode;
typedef Rose_STL_Container<SgNode*>         SgNodePtrList;
typedef SgNodePtrList*                      SgNodePtrListPtr;

class SgType;
typedef Rose_STL_Container<SgType*>         SgTypePtrList;
typedef SgTypePtrList*                      SgTypePtrListPtr;

class SgExpression;
typedef Rose_STL_Container<SgExpression*>   SgExpressionPtrList;
typedef SgExpressionPtrList*                SgExpressionPtrListPtr;

class SgKeyDatumPair;
typedef Rose_STL_Container<SgKeyDatumPair*>  SgKeyDatumPairPtrList;

class SgComprehension;
typedef Rose_STL_Container<SgComprehension*>  SgComprehensionPtrList;

typedef Rose_STL_Container<VariantT>       VariantTList;

// Liao 9/27/2010: new typedef for SgVarRefExp list
class SgVarRefExp;
typedef Rose_STL_Container<SgVarRefExp*>   SgVarRefExpPtrList;
typedef SgVarRefExpPtrList*                SgVarRefExpPtrListPtr;

class SgAttribute;
typedef Rose_STL_Container<SgAttribute*>    SgAttributePtrList;
typedef SgAttributePtrList*                 SgAttributePtrListPtr;

// DQ (6/14/2008): I think this should be unsigned char
// typedef Rose_STL_Container<char*>           SgCharPtrList;
// typedef SgCharPtrList*                      SgCharPtrListPtr;
typedef Rose_STL_Container<unsigned char>   SgCharList;
typedef SgCharList*                         SgCharListPtr;

typedef SgExpression*                       SgExpressionPtr;
typedef SgStatement*                        SgStatementPtr;
typedef SgInitializedName*                  SgInitializedNamePtr;

// DQ (4/7/2001) Add SgFile list support for multi-file support within SgProject
class SgFile;
typedef std::vector<SgFile*>                SgFilePtrList;
typedef SgFilePtrList*                      SgFilePtrListPtr;

// DQ (2/27/2019): Modified to add the line number so that we could support adding comments
// and CPP directives to shared IR nodes to support multi-file compilation.
// DQ (5/22/2006): Added this support so that we could have general way of interpreting STL
// containers so that we could simplify that code used to generated code for the destructors.
// JJW (6/21/2008): Changed to a unordered vector for performance
typedef int                                   SgFileId;
typedef std::vector<SgFileId>                 SgFileIdList;
// typedef struct { int file_id; int line_number; } SgFileIdLineNumber;
// typedef std::vector<SgFileIdLineNumber>          SgFileIdList;
typedef int                                   SgFileLineNumber;
typedef std::vector<SgFileLineNumber>         SgFileLineNumberList;

// DQ (5/22/2006): Added this support so that we could have general way of interpreting STL
// containers so that we could simplify that code used to generated code for the destructors.
typedef Rose_STL_Container<std::string>     SgStringList;
typedef SgStringList*                       SgStringListPtr;

// DQ (3/10/2007): Added STL set of SgNode* so that we could support existence tests in the
// symbol table without a linear search of the symbol table (where we don't use the name).
// This test helps detect where symbols may have been inserted into the symbol table using
// two different names, or there names changed without properly unloading and reloading the
// associated symbol.
typedef std::set<SgNode*>                   SgNodeSet;
typedef SgNodeSet*                          SgNodeSetPtr;

class ROSEAttributesList;
typedef ROSEAttributesList*                 ROSEAttributesListPtr;

class ROSEAttributesListContainer;
typedef ROSEAttributesListContainer*        ROSEAttributesListContainerPtr;

// I don't think these are needed
// typedef vector<ROSEAttributesListContainer*>         ROSEAttributesListContainerList;
// typedef ROSEAttributesListContainerList*             ROSEAttributesListContainerListPtr;

// MK: The data member p_nodes of the SgModifierNodes class is now an
// STL vector, therefore we define the following data types
typedef std::vector<SgModifierType*>        SgModifierTypePtrVector;
// DQ (12/19/2005): This is not used anywhere!
// typedef SgModifierTypePtrVector          SgModifierTypePtrVectorPtr;

// DQ (12/6/2003): added bit vector typedef to support addition of more flags
// that can be held in a long integer for the Unparse_Info object.
typedef std::vector<bool>                   SgBitVector;

// DQ (3/12/2004): Added for template support
class SgTemplateParameter;
typedef Rose_STL_Container<SgTemplateParameter*> SgTemplateParameterPtrList;
typedef SgTemplateParameterPtrList*              SgTemplateParameterPtrListPtr;

// DQ (3/12/2004): Added for template support
class SgTemplateArgument;
typedef Rose_STL_Container<SgTemplateArgument*>  SgTemplateArgumentPtrList;
typedef SgTemplateArgumentPtrList*               SgTemplateArgumentPtrListPtr;

// DQ (9/6/2004): Added for qualified name support (e.g. A::B::C::dataMember)
// This form of qualified name support was later removed!
// class SgSymbol;
// typedef list<SgSymbol*>      SgSymbolPtrList;
// typedef SgSymbolPtrList*     SgSymbolPtrListPtr;

// DQ (5/6/2005): Added support for SgDirectory IR node!
class SgDirectory;
typedef std::vector<SgDirectory*>           SgDirectoryPtrList;
typedef SgDirectoryPtrList*                 SgDirectoryPtrListPtr;

// DQ (12/21/2005): Added to support explicit name qualifiers (this provides only global qualifier info so far)
class SgQualifiedName;
typedef Rose_STL_Container<SgQualifiedName*> SgQualifiedNamePtrList;
typedef SgQualifiedNamePtrList*              SgQualifiedNamePtrListPtr;

// DQ (10/4/2006): Add support for storing unique numbers with SgBasicBlock IR nodes.
// This mechanism premits unique numbers to be computed and cached and the cache to
// be easily invalidated.
// Name this as a list since the ROSETTA code generation will use this information.
class SgBasicBlock;
typedef SgBasicBlock*                       SgBasicBlockPtr;
// typedef std::map<SgBasicBlock*,int>      SgBasicBlockPtrList;
typedef std::vector<SgBasicBlockPtr>        SgBasicBlockPtrList;
typedef SgBasicBlockPtrList*                SgBasicBlockPtrListPtr;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
// DQ (3/15/2007): Added support for binaries.
typedef Rose_STL_Container<SgAsmStatement*> SgAsmStatementPtrList;
typedef SgAsmStatementPtrList*              SgAsmStatementPtrListPtr;

typedef Rose_STL_Container<SgAsmInstruction*> SgAsmInstructionPtrList;
typedef SgAsmInstructionPtrList*              SgAsmInstructionPtrListPtr;

// DQ (3/15/2007): Added support for binaries.
typedef Rose_STL_Container<SgAsmExpression*> SgAsmExpressionPtrList;
typedef SgAsmExpressionPtrList*              SgAsmExpressionPtrListPtr;

typedef Rose_STL_Container<SgAsmIntegerValueExpression*> SgAsmIntegerValuePtrList;
typedef SgAsmIntegerValuePtrList*                SgAsmIntegerValuePtrListPtr;

// DQ (3/15/2007): Added support for binaries.
typedef Rose_STL_Container<SgAsmSynthesizedDeclaration*> SgAsmSynthesizedDeclarationPtrList;
typedef SgAsmSynthesizedDeclarationPtrList*              SgAsmSynthesizedDeclarationPtrListPtr;

typedef Rose_STL_Container<SgAsmX86Instruction*> SgAsmX86InstructionPtrList;
#ifdef ROSE_ENABLE_ASM_AARCH64
typedef Rose_STL_Container<SgAsmAarch64Instruction*> SgAsmAarch64InstructionPtrList;
#endif
#endif

// DQ (11/19/2007): Added support for Fortran namelist statement.
typedef Rose_STL_Container<SgNameGroup*>           SgNameGroupPtrList;
typedef SgNameGroupPtrList*                        SgNameGroupPtrListPtr;

// DQ (11/20/2007): Added support for Fortran data statement.
typedef Rose_STL_Container<SgDataStatementGroup*>  SgDataStatementGroupPtrList;
typedef SgDataStatementGroupPtrList*               SgDataStatementGroupPtrListPtr;

// DQ (11/20/2007): Added support for Fortran data statement.
typedef Rose_STL_Container<SgDataStatementObject*> SgDataStatementObjectPtrList;
typedef SgDataStatementObjectPtrList*              SgDataStatementObjectPtrListPtr;

// DQ (11/20/2007): Added support for Fortran data statement.
typedef Rose_STL_Container<SgDataStatementValue*>  SgDataStatementValuePtrList;
typedef SgDataStatementValuePtrList*               SgDataStatementValuePtrListPtr;

// DQ (11/21/2007): Added support for common block statements (which can have multiple common blocks)
typedef Rose_STL_Container<SgCommonBlockObject*>   SgCommonBlockObjectPtrList;
typedef SgCommonBlockObjectPtrList*                SgCommonBlockObjectPtrListPtr;

// DQ (11/21/2007): Added support for dimension statements (which can have multiple entries)
typedef Rose_STL_Container<SgDimensionObject*>     SgDimensionObjectPtrList;
typedef SgDimensionObjectPtrList*                  SgDimensionObjectPtrListPtr;

// DQ (11/21/2007): Added support for dimension statements (which can have multiple entries)
typedef Rose_STL_Container<SgLabelSymbol*>     SgLabelSymbolPtrList;
typedef SgLabelSymbolPtrList*                  SgLabelSymbolPtrListPtr;

// DQ (11/21/2007): Added support for format statements (which can have multiple entries)
typedef Rose_STL_Container<SgFormatItem*>      SgFormatItemPtrList;
typedef SgFormatItemPtrList*                   SgFormatItemPtrListPtr;

// DQ (8/21/2008): Use the reference built for rose_addr_t instead.
// DQ (8/21/2008): Moved this from Node.code to make it local since
// we can't reference the nested addr_t directly from glogal scope.
// typedef uint64_t addr_t; // address and size (file and memory)
typedef Rose_STL_Container<rose_addr_t>  SgAddressList;
typedef SgAddressList*                   SgAddressListPtr;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
typedef Rose_STL_Container<rose_rva_t>         SgRVAList;
typedef SgRVAList*                             SgRVAListPtr;

typedef Rose_STL_Container<SgAsmPEExportEntry*> SgAsmPEExportEntryPtrList;
typedef SgAsmPEExportEntryPtrList*              SgAsmPEExportEntryPtrListPtr;
#endif

typedef Rose_STL_Container<uint16_t>           SgUnsigned16List;
typedef SgUnsigned16List*                      SgUnsigned16ListPtr;

typedef Rose_STL_Container<unsigned>           SgUnsignedList;
typedef SgUnsignedList*                        SgUnsignedListPtr;

// DQ (8/7/2008): Added list of size_t types for binary format support.
typedef Rose_STL_Container<size_t>             SgSizeTList;
typedef SgSizeTList*                           SgSizeTListPtr;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
typedef Rose_STL_Container<SgAsmNEEntryPoint*> SgAsmNEEntryPointPtrList;
typedef SgAsmNEEntryPointPtrList*              SgAsmNEEntryPointPtrListPtr;

typedef Rose_STL_Container<SgAsmNERelocEntry*> SgAsmNERelocEntryPtrList;
typedef SgAsmNERelocEntryPtrList*              SgAsmNERelocEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmLEPageTableEntry*> SgAsmLEPageTableEntryPtrList;
typedef SgAsmLEPageTableEntryPtrList*              SgAsmLEPageTableEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmLEEntryPoint*> SgAsmLEEntryPointPtrList;
typedef SgAsmLEEntryPointPtrList*              SgAsmLEEntryPointPtrListPtr;

// The OS/2 SgAsmLERelocEntry reused the Windows SgAsmNERelocEntry
typedef SgAsmNERelocEntry SgAsmLERelocEntry;
typedef Rose_STL_Container<SgAsmLERelocEntry*> SgAsmLERelocEntryPtrList;
typedef SgAsmLERelocEntryPtrList*              SgAsmLERelocEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmGenericHeader*> SgAsmGenericHeaderPtrList;
typedef SgAsmGenericHeaderPtrList*              SgAsmGenericHeaderPtrListPtr;

typedef Rose_STL_Container<SgAsmGenericDLL*> SgAsmGenericDLLPtrList;
typedef SgAsmGenericDLLPtrList*              SgAsmGenericDLLPtrListPtr;
#endif

typedef Rose_STL_Container<unsigned char>    SgUnsignedCharList;
typedef SgUnsignedCharList*                  SgUnsignedCharListPtr;

// DQ (10/1/2008): Added support for lists of SgModuleStatement where they are
// not a part of the current translation unit.  A place for the information in
// the *.mod files to be put.  This is just the type declaration for the list.
typedef Rose_STL_Container<SgModuleStatement*> SgModuleStatementPtrList;
typedef SgModuleStatementPtrList*              SgModuleStatementPtrListPtr;

// TOO1 (5/16/2013)
typedef Rose_STL_Container<SgJavaPackageDeclaration*> SgJavaPackageDeclarationPtrList;

// DQ (6/12/2013): Added to support use in Java support (in SgSourceFile).
typedef Rose_STL_Container<SgJavaImportStatement*> SgJavaImportStatementPtrList;

// DQ (6/12/2013): Added to support use in Java support (in SgSourceFile).
typedef Rose_STL_Container<SgClassDeclaration*> SgClassDeclarationPtrList;

// DQ (10/4/2008): Support for list of names or rename entries for the SgUseStatement (Fortran 90 support)
typedef Rose_STL_Container<SgRenamePair*> SgRenamePairPtrList;
typedef SgRenamePairPtrList*              SgRenamePairPtrListPtr;

// DQ (10/6/2008): Added improved support for F90 interfaces using interface bodies.
typedef Rose_STL_Container<SgInterfaceBody*> SgInterfaceBodyPtrList;
typedef SgInterfaceBodyPtrList*              SgInterfaceBodyPtrListPtr;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
// DQ (11/5/2008): Addes as part of general Dwarf support in the AST for binary executables.
typedef Rose_STL_Container<SgAsmDwarfLine*> SgAsmDwarfLinePtrList;
typedef SgAsmDwarfLinePtrList*              SgAsmDwarfLinePtrListPtr;

typedef Rose_STL_Container<SgAsmDwarfMacro*> SgAsmDwarfMacroPtrList;
typedef SgAsmDwarfMacroPtrList*              SgAsmDwarfMacroPtrListPtr;

typedef Rose_STL_Container<SgAsmDwarfConstruct*> SgAsmDwarfConstructPtrList;
typedef SgAsmDwarfConstructPtrList*              SgAsmDwarfConstructPtrListPtr;

typedef Rose_STL_Container<SgAsmDwarfCompilationUnit*> SgAsmDwarfCompilationUnitPtrList;
typedef SgAsmDwarfCompilationUnitPtrList*              SgAsmDwarfCompilationUnitPtrListPtr;
#endif

// DQ (11/28/2008): Added support for list of integers (used for flag list in SgLinemarkerDirectiveStatement).
// typedef std::vector<int>                     SgIntegerList;
// Liao, 5/30/2009 types for OpenMP support
typedef Rose_STL_Container<SgOmpClause*>   SgOmpClausePtrList;
typedef SgOmpClausePtrList*                SgOmpClausePtrListPtr;

typedef Rose_STL_Container<SgOmpSectionStatement*>   SgOmpSectionStatementPtrList;
typedef SgOmpSectionStatementPtrList*                SgOmpSectionStatementPtrListPtr;

// DQ (1/13/2014): Added support for Java annotations.
typedef Rose_STL_Container<SgJavaMemberValuePair*> SgJavaMemberValuePairPtrList;
typedef SgJavaMemberValuePairPtrList* SgJavaMemberValuePairPtrListPtr;

// DQ (3/6/2014): Added support for Untyped IR nodes.

// Rasmussen (08/25/2022): Removed all untyped Sage nodes. Ultimately it proved easier to
// construct regular IR nodes from the Jovial parser. Using the untyped system just led to an
// unnecessary step and wasted effort.

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
class SgAsmRegisterReferenceExpression;
typedef Rose_STL_Container<SgAsmRegisterReferenceExpression*> SgAsmRegisterReferenceExpressionPtrList;
typedef SgAsmRegisterReferenceExpressionPtrList* SgAsmRegisterReferenceExpressionPtrListPtr;
#endif

// DQ (9/3/2014): Added support for C++11 Lambda expressions.
typedef Rose_STL_Container<SgLambdaCapture*>     SgLambdaCapturePtrList;
typedef SgLambdaCapturePtrList*                  SgLambdaCapturePtrListPtr;

// DQ (9/15/2018) Add SgSourceFile list support for header file reporting (for unparse headers option).
class SgSourceFile;
typedef Rose_STL_Container<SgSourceFile*>        SgSourceFilePtrList;
typedef SgSourceFilePtrList*                     SgSourceFilePtrListPtr;

// DQ (9/18/2018) Add SgIncludeFile list support for header file reporting (for unparse headers option).
class SgIncludeFile;
typedef Rose_STL_Container<SgIncludeFile*>        SgIncludeFilePtrList;
typedef SgIncludeFilePtrList*                     SgIncludeFilePtrListPtr;

// PP (11/24/2020) Add support for Ada representation clauses
class SgAdaComponentClause;
typedef Rose_STL_Container<SgAdaComponentClause*> SgAdaComponentClausePtrList;
typedef SgAdaComponentClausePtrList*              SgAdaComponentClausePtrListPtr;

// DQ (10/28/2013): Forward declaration for new token unparsing support.
class TokenStreamSequenceToNodeMapping;
class FrontierNode;
class PreviousAndNextNodeData;

// DQ (11/30/2015): Added support for mapping of the AST to macro expansions.
class MacroExpansion;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <SgSharedVector.h>

typedef SgSharedVector<unsigned char>             SgFileContentList;
typedef SgFileContentList*                        SgFileContentListPtr;

typedef Rose_STL_Container<SgAsmElfRelocEntry*>   SgAsmElfRelocEntryPtrList;
typedef SgAsmElfRelocEntryPtrList*                SgAsmElfRelocEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfNoteEntry*>    SgAsmElfNoteEntryPtrList;
typedef SgAsmElfNoteEntryPtrList*                 SgAsmElfNoteEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfDynamicEntry*> SgAsmElfDynamicEntryPtrList;
typedef SgAsmElfDynamicEntryPtrList*              SgAsmElfDynamicEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfEHFrameEntryCI*> SgAsmElfEHFrameEntryCIPtrList;
typedef SgAsmElfEHFrameEntryCIPtrList*              SgAsmElfEHFrameEntryCIPtrListPtr;

typedef Rose_STL_Container<SgAsmElfEHFrameEntryFD*> SgAsmElfEHFrameEntryFDPtrList;
typedef SgAsmElfEHFrameEntryFDPtrList*              SgAsmElfEHFrameEntryFDPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSegmentTableEntry*> SgAsmElfSegmentTableEntryPtrList;
typedef SgAsmElfSegmentTableEntryPtrList* SgAsmElfSegmentTableEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSymverEntry*> SgAsmElfSymverEntryPtrList;
typedef SgAsmElfSymverEntryPtrList*              SgAsmElfSymverEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSymverDefinedEntry*> SgAsmElfSymverDefinedEntryPtrList;
typedef SgAsmElfSymverDefinedEntryPtrList*              SgAsmElfSymverDefinedEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSymverDefinedAux*> SgAsmElfSymverDefinedAuxPtrList;
typedef SgAsmElfSymverDefinedAuxPtrList*              SgAsmElfSymverDefinedAuxPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSymverNeededEntry*> SgAsmElfSymverNeededEntryPtrList;
typedef SgAsmElfSymverNeededEntryPtrList*              SgAsmElfSymverNeededEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmElfSymverNeededAux*> SgAsmElfSymverNeededAuxPtrList;
typedef SgAsmElfSymverNeededAuxPtrList*              SgAsmElfSymverNeededAuxPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmAttribute*> SgAsmJvmAttributePtrList;
typedef SgAsmJvmAttributePtrList*              SgAsmJvmAttributePtrListPtr;

typedef Rose_STL_Container<SgAsmJvmBootstrapMethod*> SgAsmJvmBootstrapMethodPtrList;
typedef SgAsmJvmBootstrapMethodPtrList*              SgAsmJvmBootstrapMethodPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmInnerClassesEntry*> SgAsmJvmInnerClassesEntryPtrList;
typedef SgAsmJvmInnerClassesEntryPtrList*              SgAsmJvmInnerClassesEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmConstantPoolEntry*> SgAsmJvmConstantPoolEntryPtrList;
typedef SgAsmJvmConstantPoolEntryPtrList*              SgAsmJvmConstantPoolEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmExceptionHandler*> SgAsmJvmExceptionHandlerPtrList;
typedef SgAsmJvmExceptionHandlerPtrList*              SgAsmJvmExceptionHandlerPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmField*> SgAsmJvmFieldPtrList;
typedef SgAsmJvmFieldPtrList*              SgAsmJvmFieldPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmMethodParametersEntry*> SgAsmJvmMethodParametersEntryPtrList;
typedef SgAsmJvmMethodParametersEntryPtrList*              SgAsmJvmMethodParametersEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmLineNumberEntry*> SgAsmJvmLineNumberEntryPtrList;
typedef SgAsmJvmLineNumberEntryPtrList*              SgAsmJvmLineNumberEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmLocalVariableEntry*> SgAsmJvmLocalVariableEntryPtrList;
typedef SgAsmJvmLocalVariableEntryPtrList*              SgAsmJvmLocalVariableEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmLocalVariableTypeEntry*> SgAsmJvmLocalVariableTypeEntryPtrList;
typedef SgAsmJvmLocalVariableTypeEntryPtrList*              SgAsmJvmLocalVariableTypeEntryPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmMethod*> SgAsmJvmMethodPtrList;
typedef SgAsmJvmMethodPtrList*              SgAsmJvmMethodPtrListPtr;

typedef Rose_STL_Container<SgAsmJvmStackMapFrame*> SgAsmJvmStackMapFramePtrList;
typedef SgAsmJvmStackMapFramePtrList*              SgAsmJvmStackMapFramePtrListPtr;

typedef Rose_STL_Container<SgAsmJvmStackMapVerificationType*> SgAsmJvmStackMapVerificationTypePtrList;
typedef SgAsmJvmStackMapVerificationTypePtrList*              SgAsmJvmStackMapVerificationTypePtrListPtr;

typedef Rose_STL_Container<SgAsmPERVASizePair*> SgAsmPERVASizePairPtrList;
typedef SgAsmPERVASizePairPtrList* SgAsmPERVASizePairPtrListPtr;
#endif

// DQ (11/20/2010): Added type for SgToken list
// Build a type for the SgToken list.
typedef Rose_STL_Container<SgToken*> SgTokenPtrList;
typedef SgTokenPtrList* SgTokenPtrListPtr;


// DQ (11/4/2009): Trying to use the boost hash_map support
namespace rose_hash
   {
  // The condition here is not needed for GCC 4.2, but is needed (and does not completely work) for earlier versions
     using boost::unordered_map;
     using boost::unordered_multimap;
     using boost::unordered_set;
     using boost::hash;

  // DQ (4/23/2009): These should be put into this namespace so that we don't contaminate the global scope.
  // DQ (8/19/2008): This is already defined in src/frontend/SageIII/astMerge/buildMangledNameMap.h
     struct eqstr_string
        {
          bool operator()(const std::string & s1, const std::string & s2) const
             {
               return s1 == s2;
             }
        };

/*! \brief Hash name support for symbol tables within ROSE.
 */
     struct hash_integer
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const int n) const
             {
               return n;
             }
        };

     struct hash_integer_pair
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const std::pair<int,int> & p) const
             {
            // DQ (4/30/2009): This subject should be reviewed!
            // Since this is a hash function, it might not a problem if we have
            // overflow (also the values should not be so large as to be a problem).
               return p.first+p.second;
             }
        };

  // DQ (4/30/2009): This might already exist for std::pair<>
     struct eqstr_integer_pair
        {
          bool operator()(const std::pair<int,int> & p1, const std::pair<int,int> & p2) const
             {
               return (p1.first == p2.first) && (p1.second == p2.second);
             }
        };

     struct eqstr_graph_node
        {
          bool operator()(const SgGraphNode* p1, const SgGraphNode* p2) const
             {
               return p1 == p2;
             }
        };

     struct eqstr_graph_edge
        {
          bool operator()(const SgGraphNode* p1, const SgGraphNode* p2) const
             {
               return p1 == p2;
             }
        };

     struct hash_graph_node
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const SgGraphNode* ptr) const
             {
               return (size_t) ptr;
             }
        };
   }


/*! \brief Hash table support for graph IR nodes within ROSE (uses strings to lookup nodes).
 */

// DQ (8/19/2008): Note that "rose_hash" is a namespace defined above.
// class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<std::string, SgGraphNode*> rose_graph_string_node_hash_multimap_base_type;

class rose_graph_string_node_hash_multimap : public rose_graph_string_node_hash_multimap_base_type
   {
  // Need to document why we are using hash_multimap type here.  Why a hash (obvious), then why a multimap?
  // I think a multimap is used to support having no names on the nodes if they are unlabeled.  If the
  // nodes are labled then operations on the labled edges are possible using the multimap.  But is there
  // a performance trade-off for these choices?

     protected:

       // DQ (4/25/2009): We need to change this name since I think we just want the
       // associated IR node in the AST, and not any concept of parent in the graph.
          SgNode* parent;

     public:
          rose_graph_string_node_hash_multimap()
             : rose_graph_string_node_hash_multimap_base_type(), parent(nullptr)
             {}
                         // tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
          rose_graph_string_node_hash_multimap(const rose_graph_string_node_hash_multimap & rhs)
             : rose_graph_string_node_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}
       // See note (above) about name change to the associated data member for these access functions.
          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_string_node_hash_multimap()
             {
               delete_elements();

               parent = nullptr;
             }


        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_string_node_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_string_node_hash_multimap::iterator & rhm_it );

// DQ (5/1/2009): Temporary typedef to use older name for compatability.
typedef rose_graph_string_node_hash_multimap rose_graph_hash_multimap;



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using nodes).

    \internal This class is depricated and it's functionality will be produced using two other hash maps.
 */

// DQ (4/29/2009): Added to support ROSE Graph IR nodes
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<SgGraphNode*, SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node> rose_graph_node_edge_hash_multimap_base_type;
class rose_graph_node_edge_hash_multimap : public rose_graph_node_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
          SgNode * parent;

     public:
          rose_graph_node_edge_hash_multimap()
             : rose_graph_node_edge_hash_multimap_base_type()
             {}
         // tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
          rose_graph_node_edge_hash_multimap(const rose_graph_node_edge_hash_multimap& rhs)
          // DQ (4/30/2009): This fixed a problem reported by Thomas Panas relative to seg-faults when using the copy constructor (forced his code to use references).
          // : rose_hash::unordered_multimap<SgGraphNode*, SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node>((rose_graph_node_edge_hash_multimap)rhs)
             : rose_graph_node_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_node_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_node_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_node_edge_hash_multimap::iterator & rhm_it );


/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup nodes using node index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphNode*, rose_hash::hash_integer, rose_hash::eqstr_graph_node> rose_graph_integer_node_hash_map_base_type
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_map<int, SgGraphNode*, rose_hash::hash_integer> rose_graph_integer_node_hash_map_base_type;
class rose_graph_integer_node_hash_map : public rose_graph_integer_node_hash_map_base_type
   {
     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_node_hash_map()
             : rose_graph_integer_node_hash_map_base_type()
             {}
// tps (11/18/2009) : Is this constructor wrong? Should it be a pair of (int,SgGraphNode)?
          rose_graph_integer_node_hash_map(const rose_graph_integer_node_hash_map& rhs)
             : rose_graph_integer_node_hash_map_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_node_hash_map()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_node_hash_map*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_node_hash_map::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using edge index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer, rose_hash::eqstr_graph_edge> rose_graph_integer_edge_hash_map_base_type;
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer> rose_graph_integer_edge_hash_map_base_type;
class rose_graph_integer_edge_hash_map : public rose_graph_integer_edge_hash_map_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_edge_hash_map()
             : rose_graph_integer_edge_hash_map_base_type()
             {}
          rose_graph_integer_edge_hash_map(const rose_graph_integer_edge_hash_map& rhs)
             : rose_graph_integer_edge_hash_map_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_edge_hash_map()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_edge_hash_map*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_edge_hash_map::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using edge index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer, rose_hash::eqstr_graph_edge> rose_graph_integer_edge_hash_multimap_base_type;

typedef rose_hash::unordered_multimap<int,SgGraphEdge*> rose_graph_integer_edge_hash_multimap_base_type;
class rose_graph_integer_edge_hash_multimap : public rose_graph_integer_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_edge_hash_multimap()
             : rose_graph_integer_edge_hash_multimap_base_type()
             {}
          rose_graph_integer_edge_hash_multimap(const rose_graph_integer_edge_hash_multimap& rhs)
             : rose_graph_integer_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_edge_hash_multimap::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using node index pairs).
 */
typedef rose_hash::unordered_multimap<std::pair<int,int>,SgGraphEdge*, rose_hash::hash_integer_pair> rose_graph_integerpair_edge_hash_multimap_base_type;
class rose_graph_integerpair_edge_hash_multimap : public rose_graph_integerpair_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integerpair_edge_hash_multimap()
             : rose_graph_integerpair_edge_hash_multimap_base_type()
             {}
          rose_graph_integerpair_edge_hash_multimap(const rose_graph_integerpair_edge_hash_multimap& rhs)
             : rose_graph_integerpair_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integerpair_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integerpair_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integerpair_edge_hash_multimap::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup nodes and edges index values from lables).
 */

// DQ (5/1/2009): This is added to support lookup of indexes based on labels (can be used for nodes or edges).
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<std::string, int> rose_graph_string_integer_hash_multimap_base_type;
class rose_graph_string_integer_hash_multimap : public rose_graph_string_integer_hash_multimap_base_type
   {
     protected:
       // DQ (4/25/2009): We need to change this name since I think we just want the
       // associated IR node in the AST, and not any concept of parent in the graph.
          SgNode* parent;

     public:
          rose_graph_string_integer_hash_multimap()
             : rose_graph_string_integer_hash_multimap_base_type(), parent(nullptr)
             {}
          rose_graph_string_integer_hash_multimap(const rose_graph_string_integer_hash_multimap & rhs)
             : rose_graph_string_integer_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

       // See note (above) about name change to the associated data member for these access functions.
          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_string_integer_hash_multimap()
             {
               delete_elements();

               parent = nullptr;
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_string_integer_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_string_integer_hash_multimap::iterator & rhm_it );







// DQ (11/6/2008): This is the support for mapping instructions to source code and back.
// When it is further along it will be moved to the SgAsmDwarfCompilationUnit as a member
// function which will built it if it has not previously been built.
// This is how a triplet would be built (in the future), instead of a pair, but for now use a pair.
// std::tr1::tuple<int, int, int> tp;
typedef std::pair<int,int> LineColumnFilePosition;
typedef std::pair<int,LineColumnFilePosition> FileIdLineColumnFilePosition;

typedef std::pair<uint64_t,FileIdLineColumnFilePosition> AddressFileIdLineColumnFilePositionPair;
typedef std::pair<FileIdLineColumnFilePosition,uint64_t> FileIdLineColumnFilePositionAddressPair;

// typedef std::multimap<uint64_t,FileIdLineColumnFilePosition> SgInstructionAddressSourcePositionMapPtrList;
// typedef std::multimap<FileIdLineColumnFilePosition,uint64_t> SgSourcePositionInstructionAddressMapPtrList;
typedef std::multimap<uint64_t,FileIdLineColumnFilePosition> SgInstructionAddressSourcePositionMapPtrList;
typedef std::multimap<FileIdLineColumnFilePosition,uint64_t> SgSourcePositionInstructionAddressMapPtrList;

typedef std::pair<SgInstructionAddressSourcePositionMapPtrList*,SgSourcePositionInstructionAddressMapPtrList*> DwarfInstructionSourceMapReturnType;


// DQ (11/26/2005): Support for visitor pattern.
class ROSE_VisitTraversal;
class ROSE_VisitorPattern;

// DQ (3/12/2007): Added mangle name map
// typedef std::map<SgNode*,std::string>       SgMangledNameList;
// typedef SgMangledNameList*                  SgMangledNameListPtr;

// DQ (12/23/2005): support for traversal of AST using visitor pattern
ROSE_DLL_API void traverseMemoryPoolNodes          ( ROSE_VisitTraversal & traversal );
ROSE_DLL_API void traverseMemoryPoolVisitorPattern ( ROSE_VisitorPattern & visitor );

// DQ (2/9/2006): Added to support traversal over single representative of each IR node
// This traversal helps support intrnal tools that call static member functions.
ROSE_DLL_API void traverseRepresentativeNodes ( ROSE_VisitTraversal & traversal );

// DQ (6/7/2010): Change the return type to size_t to support larger number of IR nodes
// using values that overflow signed values of int.
// DQ (1/2/2006): Support for computing the total number of IR nodes in use within an AST
// computation is done based on the memory pools (so it is exact).
// int numberOfNodes();
// int memoryUsage();
ROSE_DLL_API size_t numberOfNodes();
ROSE_DLL_API size_t memoryUsage();

// DQ: This function is used by the SgNode object to connect the unparser (in ROSE) to the AST.
ROSE_DLL_API std::string globalUnparseToString ( const SgNode* astNode, SgUnparse_Info* inputUnparseInfoPointer = nullptr );

// DQ: These functions are used by soem specific STL containers to connect the unparser (in ROSE) to the AST (mostly for name qualification).
// DQ (9/13/2014): Added support for more general unparsing of STL containers of IR nodes (at least these).
ROSE_DLL_API std::string globalUnparseToString ( const SgTemplateParameterPtrList* templateParameterList, SgUnparse_Info* inputUnparseInfoPointer = nullptr );
ROSE_DLL_API std::string globalUnparseToString ( const SgTemplateArgumentPtrList* templateArgumentList, SgUnparse_Info* inputUnparseInfoPointer = nullptr );


// MS 2002: global type
/*! \brief Access to C++ Run Time Information (RTI)

    I'm unclear as to where this is used (Markus put it here, I think).

    \internal This is not a part of the public interface to SAGE III.

 */
class RTIMemberData
   {
  // DQ (12/31/2005): Note that we can't use "using namespace std;"
  // to simplify this code, or so it seems.
     public:
          // The first two of these fields are constants, and so this avoids the constructor
          const char* type;
          const char* name;
          std::string value;

          RTIMemberData(): type(nullptr), name(nullptr), value() {}

          RTIMemberData(const char* type0, const char* name0, const std::string& value0)
             : type(type0), name(name0), value(value0)
             {}
   };

typedef std::vector<RTIMemberData> RTIReturnType;

struct ReferenceToPointerHandler;


/*! \brief Supporting class from copy mechanism within ROSE.

    This class forms a base class for the SgShallowCopy and SgTreeCopy
    classes to support the control of copying of subtrees (what IR nodes
    are copied by a deep or shallow copy).

    To tailor a specific type of copy operation derive a class from this
    abstract class and define the clone_node function as required.
    context information if required muyst be obtained through local
    analysis inside the function using the parent or scope information
    at each IR node.

    \note This is an abstract class.

    \internal Used in ROSETTA generated copy functions on each IR node.
              The location of this code should perhaps be changed to be in the
              generate copy code rather than Node.code in ROSETTA/Grammar.
 */
class SgCopyHelp
   {
     public:
      // STL map type
         typedef std::map<const SgNode*,SgNode*> copiedNodeMapType;

     private:
      // DQ (10/8/2007): Added support for the depth to be kept track of in the AST copy mechansim.
     //! This data member records the depth of the traversal (root node == 0)
         int depth;

      // This is mostly used for SgSymbol IR nodes (but will likely be used for other IR nodes in the future.
     //! This is internal state used to asscociate pairs of IR nodes copied instead of shared.
         copiedNodeMapType copiedNodeMap;

     public:

      // STL map iterator type
         typedef copiedNodeMapType::iterator copiedNodeMapTypeIterator;

          virtual SgNode *copyAst( const SgNode *n ) = 0;

       // Default constructor (required to initialize the depth
          SgCopyHelp() : depth(0) {}

       // Defined the virtual destructor
          virtual ~SgCopyHelp() {}

       // DQ (10/8/2007): Access functions for the depth (inlined for performance).
          int get_depth() { return depth; }
          void incrementDepth() { depth++; }
          void decrementDepth() { depth--; }
          copiedNodeMapType & get_copiedNodeMap() { return copiedNodeMap; }

       // Reset the state saved
          void clearState() { depth = 0; copiedNodeMap.clear(); }

       // Added things that generate symbols to the state (could be SgDeclarationStatement or SgInitializedName objects).
          void insertCopiedNodePair( const SgNode* key, SgNode* value );

   };


/*! \brief Supporting class for "Shallow" copies of the AST.
    This class supports only shallow copies of the AST.
 */
class SgShallowCopy : public SgCopyHelp
   {
     public:
          SgNode *copyAst( const SgNode *n ) { return const_cast<SgNode *>(n); }
   };


/*! \brief Supporting class for "Deep" copies of the AST.

    This class supports only deep copies of the AST.

\internal The name of this class should perhaps be changed to reflect that it is a "deep" copy.

 */
class ROSE_DLL_API SgTreeCopy : public SgCopyHelp
   {
     public:
          SgNode *copyAst( const SgNode *n );
   };

// PC (8/3/2006): Support for subnode capturing
/*! \brief Supporting template class for "capturing" copies of the AST.

This class allows for retrieval of the clone of arbitrary source nodes
underneath the copied node.

*/
template <class CopyType>
class SgCapturingCopy : public CopyType
   {
     protected:
          std::vector<SgNode *> origList;
          std::vector<SgNode *> copyList;
     public:
          SgCapturingCopy( std::vector<SgNode *> origList, const CopyType &base = CopyType() )
          // : origList(origList), CopyType(base)
             :  CopyType(base), origList(origList), copyList(origList.size())
             { }
          virtual ~SgCapturingCopy() { }
          SgNode *copyAst( const SgNode *n )
             {
               SgNode *newNode = CopyType::copyAst(n);
               int listSize = origList.size();
               for (int i = 0; i < listSize; i++)
                  {
                    if (origList[i] == n)
                       {
                         copyList[i] = newNode;
                       }
                  }
               return newNode;
             }
          const std::vector<SgNode *> &get_copyList()
             {
               return copyList;
             }
   };

// DQ (12/22/2005): Jochen's support for a constant (non-NULL) valued pointer
// to use to distinguish valid from invalid IR nodes within the memory pools.
/*! \brief This Namespace supports the file I/O for the AST.
 */
namespace AST_FileIO
   {
  /*! \brief This function returns a static pointer used with SgNode::p_freepointer.

      This function returns
      returns an internally held (function local data) static pointer value
      used by SgNode::p_freepointer to identify non-NULL value representing
      valid IR node in memory pool.  A NULL pointer represents last entry in
      the memory pool.  This value allows us to distinguish the entries, and not
      require additional memory storage on each IR node.
   */
     SgNode* IS_VALID_POINTER();

  /*! \brief Similar value as above function for reprentation of subsets of the AST
   */
     SgNode* TO_BE_COPIED_POINTER();
   }

// DQ (12/26/2005): Simple traversal base class for use with ROSE style
// traversals.  Need to move this to a different location later.
class ROSE_VisitTraversal
   {
     public:
          virtual ~ROSE_VisitTraversal() {};
          virtual void visit (SgNode* node) = 0;
          void traverseMemoryPool()
             {
               traverseMemoryPoolNodes(*this);
             }
          void traverseRepresentativeIRnodes()
             {
               traverseRepresentativeNodes(*this);
             }
   };


// DQ (3/18/2006): Forward declarations of classes used to control and tailor the code generation.
class UnparseDelegate;
class UnparseFormatHelp;

// DQ (4/19/2006): forward declaration of PreprocessingInfo so that
// PreprocessingInfo can follow Sage III class declarations and contain
// a Sg_File_Info object (to record the filename of the comments and
// CPP directoves).
// class PreprocessingInfo;

// DQ (4/32/2006): g++ 4.0.2 requires a forward declaration for this (a friend class declaration is not sufficient!)
class AstSpecificDataManagingClassStorageClass;

// DQ (4/23/2006): The friend declaration the SgProject class is not enough this must be defined outside of the class (for g++ 4.1.0).
std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<std::string> & l );

#ifndef SWIG

// DQ (8/8/2008): Added support for std::multimap<rose_addr_t, rose_addr_t> used in binary file format.
std::ostream & operator<< ( std::ostream & os, const std::multimap<rose_addr_t, rose_addr_t> & m );
std::ostream & operator<< ( std::ostream & os, const std::vector<std::pair<rose_addr_t, rose_addr_t> > & l );
// struct SgAsmGenericFormat::fileDetails;
// std::ostream & operator<< ( std::ostream & os, const SgAsmGenericFormat::fileDetails & sb );
std::ostream & operator<< ( std::ostream & os, const struct stat & sb );

// endif for ifndef ROSE_USE_SWIG_SUPPORT
#endif

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
// DQ (3/15/2007): Added support for binaries
std::ostream & operator<< ( std::ostream & os, const Rose_STL_Container<SgAsmStatement*> & l );
#endif

// DQ (5/8/2007): Added support for type elaboration lists, hidden type lists, and hidden declaration lists.
std::ostream & operator<< ( std::ostream & os, const std::set<SgSymbol*> & l );


// DQ (8/21/2006): Jeremiah Willcock's Virtual CFG mechanism.
//#include "virtualCFG.h"
// tps (8/13/2007): working on binary cfg mechanism.
//#include "virtualBinCFG.h"

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
// Version numbers for SgAsm* nodes. Used for backward compatibility. */
BOOST_CLASS_VERSION(SgAsmInstruction, 1);
#endif

HEADER_NODE_PREDECLARATION_END


HEADER_START
     public:

      // DQ (7/23/2005): Let these be automatically generated by ROSETTA!
      // Opps, these can't be generated by ROSETTA, since it would result
      // in the recursive call to set_isModified (endless recursion).

      /*! \brief All nodes in the AST contain a isModified flag used to track changes to the AST.

           This flag can be set but this is typically an internal function used to track the modifications to AST.
           Within future unparsing this flag will control where the token stream is used alternatively to the
           code generation from the AST.
       */
          void set_isModified( bool isModified );

      /*! \brief Many nodes can hide other AST nodes and we need to track when outer nodes contain modified nodes even if they are not themselves modified.

          This flag is required to support the unparsing using the token stream.
       */
          void set_containsTransformation( bool containsTransformation );


      /*! \brief Acess function for isModified flag

          This flag records if the current IR node has been modified.
          It is set to false after and ROSE front-end processing.
       */
          bool get_isModified() const;

      /*! \brief Acess function for containsTransformation flag

          This flag records if the current IR node has a nested AST node that is marked as being modified.
       */
          bool get_containsTransformation() const;

#if 0
       // DQ (5/2/2021): I think we need a flag to record when a transformation is contained directly in the current file.
      /*! \brief Many nodes can hide other AST nodes and we need to track when outer nodes contain modified nodes even if they are not themselves modified.

          This flag is required to support the unparsing using the token stream.
       */
          void set_containsTransformationRelativeToNodeFile( bool containsTransformationRelativeToNodeFile );

      /*! \brief Acess function for containsTransformationRelativeToNodeFile flag

          This flag records if the current IR node has a nested AST node that is marked as being modified.
       */
          bool get_containsTransformationRelativeToNodeFile() const;
#endif
      //! All nodes in the AST contain a reference to a parent node
          void set_parent ( SgNode* parent );

      //! Access function for parent node.
          SgNode* get_parent () const;

       // DQ (3/4/2022): Added access function for p_parent for debugging.
      //! Access function for direct access to uncomputed value of parent node.
          SgNode* get_raw_parent () const;

      //! Query function for if the input IR nodes is a child of the current IR node.
          bool isChild ( SgNode* node ) const;

        // DQ (4/4/2006): Added optional parameter to customize unparsing
       //! This function unparses the AST node (excluding comments and unnecessary white space)
        // virtual std::string unparseToString(SgUnparse_Info* info = NULL) const;
        // Jeremiah (11/9/2007): The default value is not recognized by gdb.
           virtual std::string unparseToString(SgUnparse_Info* info) const;

        // DQ (9/6/2010): Move this to the source file (we want to eliminate function definitions in header files).
        // The existence of this function addresses a bug in gdb (see comment from Jeremiah (11/9/2007) above).
        // inline std::string unparseToString() const { return this->unparseToString(NULL); }
           std::string unparseToString() const;

       //! This function unparses the AST node (including comments and white space)
          std::string unparseToCompleteString();

      /*! \brief Command line support for this compilation
          The command line is saved as a static variable so that it will be available to
          support the rewrite mechanism.

          \param argv - vector of strings holding command line arguments
          \param newFileName - current file name being used (part of support for multiple files on command line).
          \return returns vector of strings.
       */
          static std::vector<std::string> buildCommandLineToSubstituteTransformationFile( const std::vector<std::string>& argv, std::string newFileName );

       // JJW (10/16/2008): Replace variant() by variantT() and a cast (the
       // numbers are the same, but the enumerator names are different)
          int variant() const ROSE_DEPRECATED_FUNCTION {return (int)this->variantT();}

       // AS (10/22/2007): build function to return class hierachy subtree of a VariantT
          static std::vector<VariantT> getClassHierarchySubTreeFunction( VariantT v);
          static void getClassHierarchySubTreeFunction( VariantT v, std::vector<VariantT>&);

      /*! \brief DOCS IN HEADER: Access function for p_isVisited flag used previously by the AST traversals.

          \deprecated This function is not used and will be removed.
          \return Returns bool; true if previously visited within current AST traversal.
       */
          bool get_isVisited () const ROSE_DEPRECATED_FUNCTION;

      /*! \brief Access function for p_isVisited flag used previously by the AST traversals.

          \deprecated This function is not used and will be removed.
       */
          void set_isVisited ( bool isVisited ) ROSE_DEPRECATED_FUNCTION;

      /*! \brief Access function for performance optimizing global mangled name map.

          This mangle name caching is implemented to support better performance.
       */
          static std::map<SgNode*,std::string> & get_globalMangledNameMap();

      /*! \brief Support to clear the performance optimizing global mangled name map.
       */
          static void clearGlobalMangledNameMap();

      /*! \brief Access function for lower level optimizing of global mangled name map.

          This mangle name caching is implemented to shorter strings used in the globalMangledNameMap
          mechanism.
       */
          static std::map<std::string, int> & get_shortMangledNameCache();

      /*! \brief Access function for name qualification support (for names).

          This qualified name is stored with reference to where the name is used (as required) instead
          of with the IR node of what is names (e.g. function declaration, variable declaration, etc.).
       */
          static std::map<SgNode*,std::string> & get_globalQualifiedNameMapForNames();

      /*! \brief Access function for name qualification support (for names).

          This qualified name is stored with reference to where the name is used (as required) instead
          of with the IR node of what is names (e.g. function declaration, variable declaration, etc.).
       */
          static void set_globalQualifiedNameMapForNames ( const std::map<SgNode*,std::string> & X );

      /*! \brief Access function for name qualification support (for type).

          This qualified name is stored with reference to where the type is used (as required) instead
          of with the IR node representing the type (which are typically shared) (e.g. function return
          type, variable type, etc.).
       */
          static std::map<SgNode*,std::string> & get_globalQualifiedNameMapForTypes();

      /*! \brief Access function for name qualification support (for type).

          This qualified name is stored with reference to where the type is used (as required) instead
          of with the IR node representing the type (which are typically shared) (e.g. function return
          type, variable type, etc.).
       */
          static void set_globalQualifiedNameMapForTypes ( const std::map<SgNode*,std::string> & X );

       // DQ (3/13/2019): Added name qualification support for references to types than can embed many types.
      /*! \brief Access function for name qualification support (for maps of types).

          This qualified name is stored with reference to where the type is used (as required) instead
          of with the IR node representing the type (which are typically shared) (e.g. function return
          type, variable type, etc.).
       */
          static std::map<SgNode*,std::map<SgNode*,std::string> > & get_globalQualifiedNameMapForMapsOfTypes();

       // DQ (3/13/2019): Added name qualification support for references to types than can embed many types.
      /*! \brief Access function for name qualification support (for maps of types).

          This qualified name is stored with reference to where the type is used (as required) instead
          of with the IR node representing the type (which are typically shared) (e.g. function return
          type, variable type, etc.).
       */
          static void set_globalQualifiedNameMapForMapsOfTypes ( const std::map<SgNode*,std::map<SgNode*,std::string> > & X );

      /*! \brief Access function for name qualification support (for template headers in template declarations).

          This name is stored with reference to where the template declaration is used (as required) instead
          of with the IR node (where it could be incorrect).  This design allows it to be computed as needed.
          Note that template headers are the substrings "template<typename T>" that apepar in header declarations.
          These can be repeated as required for deeply nested templated classes and thus are associated with
          name qualification of template declarations (along with the more common form of name qualication
          that also applies to template declarations).
       */
          static std::map<SgNode*,std::string> & get_globalQualifiedNameMapForTemplateHeaders();

      /*! \brief Access function for name qualification support (for template headers in template declarations).

          See documentation in get_globalQualifiedNameMapForTemplateHeaders() (above).
       */
          static void set_globalQualifiedNameMapForTemplateHeaders ( const std::map<SgNode*,std::string> & X );

      /*! \brief Access function for name qualification support (for names of types).

          This type name is stored with reference to where the type is used (as required) instead
          of with the IR node representing the type (which are typically shared) (e.g. function return
          type, variable type, etc.).
       */
          static std::map<SgNode*,std::string> & get_globalTypeNameMap();

      /*! \brief Access function for name qualification support (for names of types).

          This qualified name is stored with reference to where the name is used (as required) instead
          of with the IR node of what is names (e.g. function declaration, variable declaration, etc.).
       */
          static void set_globalTypeNameMap ( const std::map<SgNode*,std::string> & X );

     /* name Persistant Attribute Mechanism

         This is the persistant attribute mechanism for attaching attributed to IR nodes across
         multiple passes. Note that these attributes are persistant in that they are preserved
         if the AST is written out to a file and read in from a file.  However, virtual function
         in the user-defined class derived from the AstAttribute must be defined for the attribute
         to be defined across the boundary of File I/O (simple pack and unpack functions).  More
         sophisticated mechanisms are available within the AstAttributeMechanism object
         (e.g iterating though attributes, etc; get_attributeMechanism() is available if direct
         access is required, however mostly only internal tools use this lower level support).

         \internal This used to be a public data member, but has been changed to be a protected
         pointer instead.  The functional interface of the AstAttributeMechanism is presevered
         but some of the names and the syntax for calling the interface have changed. The
         pointer to the AstAttributeMechanism is now generated by ROSETTA.
      */
     /* */
     //! Add a new attribute represented by the named string.
         virtual void addNewAttribute(std::string s,AstAttribute* a);
     //! Returns attribute of name 's'.
         virtual AstAttribute* getAttribute(std::string s) const;
     //! Replace existing attribute of name 's' with new AstAttribute.
         virtual void updateAttribute(std::string s,AstAttribute* a);  // formerly called: replace in AstAttributeMechanism
     /*! \brief This is a wrapper function with the following semantics:
         if no attribute of name 's' exists then \b addNewAttribute(s,a); is called,
         otherwise \b updateAttribute(s,a); is called.
      */
         virtual void setAttribute(std::string s,AstAttribute* a);
     //! Remove attribute of name 's' if present.
         virtual void removeAttribute(std::string s);
     //! Tests if attribute of name 's' is present.
         virtual bool attributeExists(std::string s) const;
     //! Returns the number of attributes on this IR node.
         virtual int numberOfAttributes() const;

     /*! \brief \b FOR \b INTERNAL \b USE Access function; if an attribute exists then
                a pointer to it is returned, else error.

         This is an access function used for getting the interally held pointer to a valid
         AstAttributeMechanism. It provides access to lower level functionality of the
         AstAttributeMechanism, put is mostly of use to internal tools.
      */
         virtual AstAttributeMechanism* get_attributeMechanism() const;
     /*!
         \brief \b FOR \b INTERNAL \b USE Access function; sets poiner to value AstAttributeMechanism.

         This is an access function used for setting the interally held pointer to a valid
         AstAttributeMechanism.
      */
         virtual void set_attributeMechanism(AstAttributeMechanism* a);
     /* */

#if ALT_FIXUP_COPY
      /* name AST Copy Support Functions

          Support for IR node specific fixup of copy operation.
          This function helps reset scopes and build untraversed parts of the
          AST that are difficult to have be constructed using the automatically
          generated copy functions.

          \implementation These functions are used internally inside the AST copy mechanism.
           The public interface for this functionality is given below this section.
       */
      /* */
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const;
      /* */
#else
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      /* name Source Position Information
          \brief Support for source code position information of all IR nodes.

          These are the virtual function definitions, they are overloaded for SgLocatedNode
          and a few of the SgSupport IR nodes.
       */
      /* */
      /*! \brief File information containing filename, line number, column number,
                 and if the SgNode is a part of a new transformation, etc.

          \internal This function is only defined here to make get_file_info usable
                    without casting for for different types in polymorphic lists
                    actually only defined in SgLocatedNode(s).  It used to be defined
                    in the SgLocatedNode class.
       */
          virtual Sg_File_Info* get_file_info(void) const { return nullptr; }

      /*! \brief New function interface for Sg_File_Info data stores starting
                 location of contruct (typically the opening brace or first letter of keyword).
       */
          virtual Sg_File_Info* get_startOfConstruct(void) const {return nullptr;}

    /*! \brief New function interface for Sg_File_Info data stores ending
               location of contruct (typically the closing brace).
     */
          virtual Sg_File_Info* get_endOfConstruct(void) const { return nullptr; }
      /* */

      /* name Control flow graph public functions

          These functions return control flow graph nodes for various positions
          around a construct. */
      /* */

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     /*! \brief Returns the CFG node for just before this AST node */
          VirtualCFG::CFGNode cfgForBeginning();
      /*! \brief Returns the CFG node for just after this AST node */
          VirtualCFG::CFGNode cfgForEnd();
#endif

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
      /* name Control flow graph view helper functions

          These functions are used internally inside the control flow graph
          view code.  The public interface for this functionality is given
          below this section. */
      /* */

      /*! \brief Determine the CFG index for the end of this construct. */
          virtual unsigned int cfgIndexForEnd() const;

      /*! \brief Determine whether a particular CFG node index is "interesting"
          for this kind of node. */
          virtual bool cfgIsIndexInteresting(unsigned int index) const;

      /*! \brief Find the index of n in this node's CFG children. */
          virtual unsigned int cfgFindChildIndex(SgNode* n);

      /*! \brief Find the index just after n in this node's CFG children. */
          virtual unsigned int cfgFindNextChildIndex(SgNode* n);

      /*! \brief Find the out edges of a CFG node -- internal version. */
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index = false);

      /*! \brief Find the in edges of a CFG node -- internal version. */
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index = false);
#endif
      /* */

       // DQ (1/31/2006): These must be built to be static access member functions (so they can't be built by ROSETTA).
      /* name Function Type Information
             Support for global view of function types used in ROSE.
       */
      /* */
       //! Access function for symbol table specific to function types.
          static SgFunctionTypeTable* get_globalFunctionTypeTable();
       //! Access function for symbol table specific to function types.
          static void set_globalFunctionTypeTable(SgFunctionTypeTable* globalFunctionTypeTable);
      /* */

       // DQ (7/22/2010): Added seperate type table to support construction of unique types.
       //! Access function for symbol table specific to non-function types.
          static SgTypeTable* get_globalTypeTable();
       //! Access function for symbol table specific to non-function types.
          static void set_globalTypeTable(SgTypeTable* globalTypeTable);

     protected:
          static std::vector<std::tuple<unsigned char*, unsigned, VariantT>> all_pools;
     public:
          static VariantT variantFromPool(SgNode const * n);

      /* \brief Mangled name cache for improved performance of mangled name generation
          This mangle name caching is implemented to support better performance.
       */
       // static std::map<SgNode*,std::string> & get_globalMangledNameMap();

      /*! \brief Computes the number of nodes in the defined subtree of the AST.

          This function is used as a basis for steps in AST isomophism tests.
          The implementation uses a traversal of the AST subtree to count the
          number of IR nodes. So the complexity if order N in the size of the subtree.
       */
          int numberOfNodesInSubtree();

      /*! \brief Computes the depth of the current defined subtree of the AST.

          This function is used as a basis for steps in AST isomophism tests.
          The implementation uses a traversal of the AST subtree to count the
          depth of the AST traversal. So the complexity if order N in the size
          of the subtree.
       */
          int depthOfSubtree();

     protected:

        /*! \brief Final initialization for constructors
            This function is called at the end of generated constructors
            to allow the specification writer to add special initialization
            functions or tests.  Default is to do nothing.  Otherwise it should
            be overridden in the spec file, in NewHeaderCode/NewOutlinedCode.
        */
          virtual void post_construction_initialization();

     private:
       // Make the copy constructor private (to avoid it being used)
       /* We have to make the copy constructor available so that the SgUnparse_Info
          copy constructor can access it, I'm not clear if this is a good idea.
        */
       // $CLASSNAME(const $CLASSNAME &); /* private so it can't be used. */

      //! Make the operator= private (to avoid it being used externally)
          $CLASSNAME & operator= ( const $CLASSNAME & X );

public:
    /** Allocate and return a new node after setting its parent.
     *
     *  ROSE's AST has this annoying, error-prone process for adding a node to the tree. One has to not only add the downward edge
     *  from parent to child, but also explicitly add the upward edge from child to parent. This two-step process makes it difficult
     *  to create child nodes and link them into the parent while the parent is being constructed. This function attempts to make
     *  this easier by doing everything in one step.
     *
     *  Use it like this:
     *
     * @code
     *  Parent::Parent(int foo, int bar)
     *      : p_child(createAndParent<Child>(this), p_foo(foo), p_bar(bar) {}
     * @endcode */
    template<class T>
    static typename std::enable_if<std::is_base_of<SgNode, T>::value, T*>::type
    createAndParent(SgNode *parent) {
        auto node = new T;
        node->set_parent(parent);
        return node;
    }

    /** Generated for tree edge data member initializations.
     *
     *  When initializing a data member that's an edge in the tree, this sets the nodes parent pointer to this object and then
     *  returns the node. It is used in generated code for constructors, like this:
     *
     * @code
     *  Foo::Foo(Bar *bar)
     *      : p_bar(adjustParent(bar, this)) {}
     * @endcode */
    template<class T>
    T* initParentPointer(T *child, SgNode *parent) {
        ASSERT_not_null(parent);
        if (child) {
#ifndef NDEBUG
            auto toString = [](SgNode *node) {
                if (node) {
                    return (boost::format("(%s*)%p") % node->class_name() % node).str();
                } else {
                    return std::string("nullptr");
                }
            };

            ASSERT_require2(child->get_parent() == nullptr,
                            "child " + toString(child) +
                            " cannot be inserted into " + toString(parent) +
                            " because it is already a child of " + toString(child->get_parent()));
#endif
            child->set_parent(this);
        }
        return child;
    }

    /** Set a child edge in a tree to point to a specific child.
     *
     *  Normally one has to remember to set the parent pointer when adding a child to a tree, and also be careful that the result is
     *  still a tree. This helper function tries to make that easier by checking some things and setting the parent pointer
     *  automatically.
     *
     *  For instance, this should work:
     *
     * @code
     *  SgAsmBinaryExpression *parent = ...;
     *  SgAsmBinaryExpression *child1 = ...;
     *  SgAsmBinaryExpression *child2 = ...;
     *
     *  parent->set_lhs(child1);
     *  ASSERT_require(child1->get_parent() == parent);
     *
     *  parent->set_lhs(child2);
     *  ASSERT_require(child1->get_parent() == nullptr);
     *  ASSERT_require(child2->get_parent() == parent);
     *
     *  parent->set_lhs(nullptr);
     *  ASSERT_require(child2->get_parent() == nullptr);
     * @endcode
     *
     *  The following should not work when assertions are enabled:
     *
     * @code
     *  SgAsmBinaryExpression *parent = ...;
     *  SgAsmBinaryExpression *child1 = ...;
     *  SgAsmBinaryExpression *child2 = ...;
     *
     *  parent->set_lhs(child1);
     *  parent->set_rhs(child1); // no longer a tree, but still acyclic
     * @endcode
     *
     * @{ */
    template<class T>
    typename std::enable_if<
        std::is_pointer<T>::value,
        void>::type
    changeChildPointer(T& edge, T const& child) {
#ifndef NDEBUG
        auto toString = [](SgNode *node) {
            if (node) {
                return (boost::format("(%s*)%p") % node->class_name() % node).str();
            } else {
                return std::string("nullptr");
            }
        };
#endif

        if (child != edge) {
            // If there is an old child, check that it has the correct parent and then remove it.
            if (edge) {
                ASSERT_require2(edge->get_parent() == this,
                                "node " + toString(edge) +
                                " is a child of " + toString(this) +
                                " but has wrong parent " + toString(edge->get_parent()));
                edge->set_parent(nullptr);
                edge = nullptr;
            }

            // If there is a new child, check its parent pointer and then insert it.
            if (child) {
                ASSERT_require2(child->get_parent() == nullptr,
                                "node " + toString(child) +
                                " is to be a child of " + toString(this) +
                                " but is already a child of " + toString(child->get_parent()));
                child->set_parent(this);
                edge = child;
            }
        }
    }

    // This gets called for non-pointers, which is the situation for nodes that are only lists of other nodes. We're currently
    // not checking them because the ROSETTA-generated API has too many ways to get around this check, most of which make it
    // impossible to enforce constraints regarding the parent/child consistency. For example:
    //
    //    node->children().clear(); // removes a whole bunch of children but doesn't clear their parent pointers
    //    node->children()[i] = child; // changes the ith child, but doesn't clear the previous ith child's parent pointer
    //    for (auto &tmp: node->children()) tmp = nullptr; // changes each child but doesn't clear parent pointers
    //    ad nausiam...
    template<class T>
    typename std::enable_if<
        !std::is_pointer<T>::value,
        void>::type
    changeChildPointer(T& edge, T const& child) {
        edge = child;
    }
    /** @} */


private:
    // This is called by the debugSerializationBegin and debugSerializationEnd that are in turn called at the beginning and end of
    // each AST node's serialization function. The implementation below uses two counters: classSerializationDepth shared by all
    // instances of this class, and objectSerializationDepth_ which is a per-instance counter. The relationship of these two
    // counters can tell us how deeply nested these recursive calls are, and which of those recursion levels are due to traversing
    // through the base classes versus traversing through data members. In the output, we use one character of indentation per
    // recursion level, with spaces (' ') representing recursion due to data members and dots ('.') representing recursion due to
    // base classes.
#if 0
    // Debugging version
    size_t objectSerializationDepth_ = 0;               // incremented as we traverse through base classes
    void debugSerializationHelper(const char *className, bool isBegin) {
        static size_t classSerializationDepth = 0;      // incremented by both base classes and data members
        if (isBegin) {
            ASSERT_require(classSerializationDepth >= objectSerializationDepth_);
            const size_t memberTraversalDepth = classSerializationDepth - objectSerializationDepth_;
            std::cerr <<"serializing: " <<std::string(memberTraversalDepth, ' ') <<std::string(objectSerializationDepth_, '.')
                      <<className <<" " <<this <<"\n";
            ++classSerializationDepth;
            ++objectSerializationDepth_;
        } else {
            ASSERT_require2(classSerializationDepth > 0, className);
            ASSERT_require2(objectSerializationDepth_ > 0, className);
            --classSerializationDepth;
            --objectSerializationDepth_;
        }
    }
#else
    // Production version
    void debugSerializationHelper(const char*, bool) {}
#endif

protected:
    /** This gets called by all Rosebud-generated destructors.
     *
     *  Rosebud generates a call to @p destructorHelper from every destructor implementation. This gives the user a chance to
     *  do something special. There are some things to be aware of when reimplementing this function, and you should be well
     *  versed in the C++ rules about calling virtual functions from destructors.
     *
     *  @li The implementation must not attempt to access any data members of derived classes. These data members have already
     *  been destroyed by time this function is called.
     *
     *  @li Any calls you make to virtual functions declared in this class will dispatch only to implementations in this class
     *  or its base classes, not any derived classes.
     *
     *  @li Your implementation must expect to be called multiple times for the same object. This occurs when this class implements
     *  this function but its derived class does not. During destruction of a derived object, the derived class's Rosebud-generated
     *  destructor will call @p destructorHelper, which will dispatch to the implementation in this class. Then, when the part of
     *  the object corresponding to this class is being destroyed, the destructor will call @p destructorHelper again, which will
     *  dispatch to this implementation again. This may happen recursively mutliple times.
     *
     *  @li Your implementation should not destroy anything that a subclass might need during its destruction. This follows from the
     *  rule above, but is generally not a problem in practice. The reason it's not a problem is that the derived classes are
     *  usually Rosebud-generated and thus their destructors only call @p destructorHelper. Therefore, in order for any derived
     *  class to any work, it must be done in its @p destructorHelper, which would be called before the implementation of @p
     *  destructorHelper in this class is called.
     *
     *  All attempts should be made to avoid having to implement a @p destructorHelper in any class but the most base class (and
     *  that one does nothing). Instead, use data members whose own destructors do their cleanup. For instance, if this class needs
     *  a pointer to data allocated on the stack, then instead of using a raw pointer which needs to be deleted in this class's
     *  destructor, use a smart pointer whose own destructor deletes the data. If you follow this advice, then you don't need to
     *  be well-versed in the details of C++ object destruction. */
     virtual void destructorHelper() {}

protected:
    /** Called by generated serializers.
     *
     *  All generated serialization functions call this function as the first or last thing they do. This is a convenient place to
     *  put temporary debugging code or breakpoints if you're trying to figure out what went wrong. You can also override it in
     *  particular derived classes if you need to debug just one class.
     *
     * @{ */
    virtual void debugSerializationBegin(const char *className) {
        debugSerializationHelper(className, true);
    }
    virtual void debugSerializationEnd(const char *className) {
        debugSerializationHelper(className, false);
    }
    /** @} */

     public:

HEADER_END


HEADER_IS_CLASSNAME_START
     // the generated cast function
     // friend ROSE_DLL_API $CLASSNAME* is$CLASSNAME ( SgNode* s );

          typedef $BASECLASS base_node_type;
HEADER_IS_CLASSNAME_END

HEADER_PARSER_START
      //! Parser from AST using parent grammar (lower level less specific grammar).
      /*! We parse from a lower level grammar into a higher level grammar
          An element (or root of s subtree of elements) of a lower level
          grammar is also an element (or root of) a higher level grammar
          This text is located in parserPrototype.macro and is used only
          for non-child terminals/nonterminals.
       */
          friend SgNode* Sgparse ( $PARENT_GRAMMARS_PREFIX_$CLASS_BASE_NAME* X );

HEADER_PARSER_END


SOURCE_START


// ########################################
// Some global variables used within SAGE 3
// ########################################

// declaration of variable to control internal output of debuging information
int SAGE_DEBUG = 0;  // default value is zero

// ###############################
// Start of source code for SgNode
// ###############################

// Specialize printing for ROSE addresses.  A better place for this would be ExtentMap.C along
// with all the other Extent-related methods.  Unfortunately, that file is compiled only if
// ROSE is configured with binary support.
template<>
void Range<rose_addr_t>::print(std::ostream &o) const
{
    if (empty()) {
        o <<"<empty>";
    } else if (1==size()) {
        char buf[64];
     // DQ (10/20/2015): Note that whitespace is required before PRIx64 (to avoid compiler warning).
        snprintf(buf, sizeof(buf), "0x%08" PRIx64, first());
        o << buf;
    } else {
        char buf[64];
     // DQ (10/20/2015): Note that whitespace is required before PRIx64 (to avoid compiler warning).
        snprintf(buf, sizeof(buf), "0x%08" PRIx64 "+0x%08" PRIx64 "=0x%08" PRIx64, first(), size(), first()+size());
        o <<buf;
    }
}

// This resolves a linker error when building ROSE with Visual Studio.
// If the above function is not called within the same file, the compiler
// fails to generate the symbol, so we use explicit instantiation.
#ifdef _MSC_VER
template class Range<rose_addr_t>;
#endif

// Support for global function type symbol table (moved to be static data pointer)
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgFunctionTypeTable* SgNode::Sgfunc_type_table = new SgFunctionTypeTable();
// SgFunctionTypeTable* SgNode::p_globalFunctionTypeTable = new SgFunctionTypeTable();
SgFunctionTypeTable* SgNode::p_globalFunctionTypeTable = nullptr;

// DQ (7/22/2010): Added type table for non-function types (supports construction of unique types).
SgTypeTable*         SgNode::p_globalTypeTable         = nullptr;

// Static variable used to hold language specific information for each IR node
// long SgNode::language_classification_bit_vector;

// DQ (3/12/2007): Added mangled name map to improve performance of generating mangled names
std::map<SgNode*,std::string> SgNode::p_globalMangledNameMap;
std::map<std::string,int> SgNode::p_shortMangledNameCache;

// DQ (5/28/2011): Added central location for qualified name maps (for names and types).
// these maps store the required qualified name for where an IR node is referenced (not
// at the IR node which has the qlocal qualifier).  Thus we can support multiple references
// to an IR node which might have different qualified names.  This is critical to the
// qualified name support.
std::map<SgNode*,std::string> SgNode::p_globalQualifiedNameMapForNames;
std::map<SgNode*,std::string> SgNode::p_globalQualifiedNameMapForTypes;
std::map<SgNode*,std::string> SgNode::p_globalQualifiedNameMapForTemplateHeaders;
std::map<SgNode*,std::string> SgNode::p_globalTypeNameMap;

// DQ (3/13/2019): The fix for referencing types than contain many parts is to have a map of maps
// to the generated name qualification substrings for each type, all associted with a single reference
// node to the statement refering to the type.
std::map<SgNode*,std::map<SgNode*,std::string> > SgNode::p_globalQualifiedNameMapForMapsOfTypes;

// DQ (7/22/2011): array dimensions may include expressions that require name qualification.
// std::map<SgNode*,std::string> SgNode::p_globalQualifiedNameMapForArrayTypeDimensions;


#if ALT_FIXUP_COPY
void
SgNode::fixupCopy_scopes(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
   }

void
SgNode::fixupCopy_symbols(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
   }

void
SgNode::fixupCopy_references(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
   }
#else
// DQ (10/5/2007): Added IR node specific function to permit copies, via AST copy(), to be fixedup
// Usually this will correct scopes and in a few cases build child IR nodes that are not traversed
// (and thus shared in the result from the automatically generated copy function).
void
SgNode::fixupCopy(SgNode* copy, SgCopyHelp & help) const
   {
  // This is the empty default inplementation, not a problem if it is called!
   }
#endif

// DQ (1/31/2006): We might want this function to be automaticaly generated
// except that then we could not support the assertion.  Also we
// don't have to set this function, though perhaps the interface function
// should be implemented to set it just on general principles.
SgFunctionTypeTable*
SgNode::get_globalFunctionTypeTable()
   {
  // DQ (1/31/2006): If there is no global function type symbol table then build one
     if (p_globalFunctionTypeTable == nullptr)
        {
          p_globalFunctionTypeTable = new SgFunctionTypeTable();
        }

     ASSERT_not_null(p_globalFunctionTypeTable);
     return p_globalFunctionTypeTable;
   }

void
SgNode::set_globalFunctionTypeTable ( SgFunctionTypeTable* globalFunctionTypeTable )
   {
     p_globalFunctionTypeTable = globalFunctionTypeTable;
   }

SgTypeTable*
SgNode::get_globalTypeTable()
   {
  // DQ (1/31/2006): If there is no global function type symbol table then build one
     if (p_globalTypeTable == nullptr)
        {
          p_globalTypeTable = new SgTypeTable();
        }

     ASSERT_not_null(p_globalTypeTable);
     return p_globalTypeTable;
   }

void
SgNode::set_globalTypeTable ( SgTypeTable* globalTypeTable )
   {
     p_globalTypeTable = globalTypeTable;
   }

// DQ (3/17/2007): return reference to the global mangled name map (the use
// of this map is a performance optimization).
std::map<SgNode*,std::string> &
SgNode::get_globalMangledNameMap()
   {
     return p_globalMangledNameMap;
   }

std::map<std::string, int> &
SgNode:: get_shortMangledNameCache()
   {
     return p_shortMangledNameCache;
   }

// DQ (3/17/2007): return reference to the global mangled name map (the use
// of this map is a performance optimization).
void
SgNode::clearGlobalMangledNameMap()
   {
  // Remove all elements from the globalMangledNameMap
     p_globalMangledNameMap.clear();

  // DQ (6/26/2007): The function types require the same mangled names be generated across
  // clears of the p_globalMangledNameMap cache. Clearing the short name map breaks this.
  // It might be that we don't want to clear the short name map to permit the same mangled
  // names to be regenerated. However, for the purposes of AST merge this is not a problem.
  // p_shortMangledNameCache.clear();
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
std::map<SgNode*,std::string> &
SgNode::get_globalQualifiedNameMapForNames()
   {
     return p_globalQualifiedNameMapForNames;
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
void
SgNode::set_globalQualifiedNameMapForNames(const std::map<SgNode*,std::string> & X)
   {
     p_globalQualifiedNameMapForNames = X;
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
std::map<SgNode*,std::string> &
SgNode::get_globalQualifiedNameMapForTypes()
   {
     return p_globalQualifiedNameMapForTypes;
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
void
SgNode::set_globalQualifiedNameMapForTypes(const std::map<SgNode*,std::string> & X)
   {
     p_globalQualifiedNameMapForTypes = X;
   }

// DQ (3/13/2019): Added support for holding the name qualification map.
std::map<SgNode*,std::map<SgNode*,std::string> > &
SgNode::get_globalQualifiedNameMapForMapsOfTypes()
   {
     return p_globalQualifiedNameMapForMapsOfTypes;
   }

// DQ (3/13/2019): Added support for holding the name qualification map.
void
SgNode::set_globalQualifiedNameMapForMapsOfTypes(const std::map<SgNode*,std::map<SgNode*,std::string> > & X)
   {
     p_globalQualifiedNameMapForMapsOfTypes = X;
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
std::map<SgNode*,std::string> &
SgNode::get_globalQualifiedNameMapForTemplateHeaders()
   {
     return p_globalQualifiedNameMapForTemplateHeaders;
   }

// DQ (5/28/2011): Added support for holding the name qualification map.
void
SgNode::set_globalQualifiedNameMapForTemplateHeaders(const std::map<SgNode*,std::string> & X)
   {
     p_globalQualifiedNameMapForTemplateHeaders = X;
   }

// DQ (6/3/2011): Added support for holding the map of type names that require qualification and at this position dependent.
std::map<SgNode*,std::string> &
SgNode::get_globalTypeNameMap()
   {
     return p_globalTypeNameMap;
   }

// DQ (6/3/2011): Added support for holding the map of type names that require qualification and at this position dependent.
void
SgNode::set_globalTypeNameMap(const std::map<SgNode*,std::string> & X)
   {
     p_globalTypeNameMap = X;
   }

// DQ (4/10/2006): These are the default virtual function definitions (each returns an error)
void
SgNode::addNewAttribute( std::string s, AstAttribute* a )
   {
     printf ("Error: calling SgNode::addNewAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

void
SgNode::setAttribute( std::string s, AstAttribute* a )
   {
     printf ("Error: calling SgNode::setAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

AstAttribute*
SgNode::getAttribute(std::string s) const
   {
     printf ("Error: calling SgNode::getAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);

     return nullptr;
   }

void
SgNode::updateAttribute( std::string s, AstAttribute* a )
   {
  // formerly called: replace
     printf ("Error: calling SgNode::updateAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

void
SgNode::removeAttribute(std::string s)
   {
     printf ("Error: calling SgNode::removeAttribute(%s) \n",s.c_str());
     ROSE_ASSERT(false);
   }

bool
SgNode::attributeExists(std::string s) const
   {
     printf ("Error: calling SgNode::attributeExists(%s) on node = %s \n",s.c_str(),class_name().c_str());
     ROSE_ASSERT(false);

  // tps (12/9/2009) : MSC requires a return value
     return false;
   }

int
SgNode::numberOfAttributes() const
   {
     int returnValue = 0;
     return returnValue;
   }

AstAttributeMechanism*
SgNode::get_attributeMechanism() const
   {
  // DQ (4/10/2006): virtual function defined at the SgNode and redefined whereever there is
  // an AstAttributeMechanism defined!  Note that there is no set function defined.
     return nullptr;
   }

void
SgNode::set_attributeMechanism(AstAttributeMechanism* a)
   {
  // Nothing to do here, but we need this virtual function so that the correct access
  // function will be call on IR nodes where the AstAttributeMechanism is defined as
  // a data member.

     printf ("Error: SgNode::set_attributeMechanism(AstAttributeMechanism* a) has been called \n");
     ROSE_ASSERT(false);
   }

void
SgNode::post_construction_initialization()
   {
  // default implementation does nothing!
   }

// DQ (7/23/2005): Let these be automatically generated by ROSETTA!
// See note above where these are proptotyped, they have to be defined
// explicitly to avoid endless recursion!


// DQ (6/22/2021): Adding debugging information.
// bool isModified_debug_access = false;

void
SgNode::set_isModified ( bool isModified)
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ASSERT_not_null(this);
     ROSE_ASSERT(this != NULL);

#if 0
  // DQ (6/4/2019): Use this to debug the outlining to seperate file mechanism (remove some spew by ignoring some IR nodes).
     if (variantT() != V_Sg_File_Info && variantT() != V_SgUnparse_Info)
        {
          printf ("SgNode::set_isModified(%s) called for node = %p = %s \n",isModified ? "true" : "false",this,this->class_name().c_str());
        }
#endif

#if 0
  // DQ (6/22/2021): Adding debugging information.
     if (isModified_debug_access == true)
        {
          printf ("SgNode::set_isModified(%s): isModified_debug_access == true: called for node = %p = %s \n",isModified ? "true" : "false",this,this->class_name().c_str());

          if (isModified == true)
             {
#if 1
               printf ("Exiting as a test in SgNode::set_isModified \n");
               ROSE_ASSERT(false);
#endif
             }
        }
#endif

#if 0
  // DQ (6/6/2019): Testing where isModified is being reset.
     SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(this);
     if (functionDeclaration != NULL && functionDeclaration == functionDeclaration->get_firstNondefiningDeclaration())
        {
          if (functionDeclaration->get_name() == "OUT_1_transformation_0")
             {
               printf ("%%%%%%%%%%%%%%%%%% Setting SgFunctionDeclaration: OUT_1_transformation_0: isModified = %s \n",isModified ? "true" : "false");
#if 0
               printf ("Exiting as a test! \n");
               ROSE_ASSERT(false);
#endif
             }
        }
#endif

#if 0
  // DQ (4/14/2015): Adding testing to identify side-effects in the AST.
     if (SgProject::get_verbose() >= 3)
        {
       // DQ (10/6/2015): Skip the output of this debug info for SgUnparse_Info IR nodes.
       // printf ("SgNode::set_isModified(%s) called for node = %p = %s \n",isModified ? "true" : "false",this,this->class_name().c_str());
       // if (!(isSgUnparse_Info(this) != NULL || isSgToken(this) != NULL))
          if (isSgUnparse_Info(this) == NULL && isSgToken(this) == NULL)
             {
               printf ("SgNode::set_isModified(%s) called for node = %p = %s \n",isModified ? "true" : "false",this,this->class_name().c_str());
#if 0
               if (SgProject::get_verbose() >= 4)
                  {
                    printf ("Exiting as a test (when verbose >= 3) in SgNode::set_isModified \n");
                    ROSE_ASSERT(false);
                  }
#endif
             }
#if 0
       // DQ (10/13/2015): Chasing a issue in the move tool.
          if (isSgForStatement(this) != NULL)
             {
               printf ("Exiting as a test in SgNode::set_isModified (found SgForStatemen) \n");
               ROSE_ASSERT(false);
             }
#endif
#if 0
          printf ("Exiting as a test in SgNode::set_isModified \n");
          ROSE_ASSERT(false);
#endif
        }
#endif

     p_isModified = isModified;
   }

bool
SgNode::get_isModified () const
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ASSERT_not_null(this);

     return p_isModified;
   }

// DQ (12/3/2014): Added support to recode when an AST subtree holds an AST node (or subtree) that has been modified.
void
SgNode::set_containsTransformation ( bool containsTransformation)
   {
  // DQ (4/14/2015): Detect if this is called from a NULL pointer.
     ASSERT_not_null(this);

     p_containsTransformation = containsTransformation;
   }

// DQ (12/3/2014): Added support to recode when an AST subtree holds an AST node (or subtree) that has been modified.
bool
SgNode::get_containsTransformation () const
   {
     ASSERT_not_null(this);

     return p_containsTransformation;
   }


bool
SgNode::get_isVisited () const
   {
  // The p_isVisited flag has been removed, it is an error to call this function.

     ASSERT_not_null(this);

     printf ("Error: The p_isVisited flag has been removed, it is an error to call this function (get_isVisited). \n");
     ROSE_ASSERT(false);

     return true;
   }

void
SgNode::set_isVisited ( bool isVisited )
   {
  // The p_isVisited flag has been removed, it is an error to call this function.
     ASSERT_not_null(this);

     printf ("Error: The p_isVisited flag has been removed, it is an error to call this function (set_isVisited). \n");
     ROSE_ASSERT(false);

     set_isModified(true);
   }


//  ! Permits specification of parent node (connects the AST tree)
/*  ! This function is called internally to connect the elements of the grammar to form the AST.
 */
void
SgNode::set_parent ( SgNode* parent )
   {
  // ROSE_ASSERT (parent != NULL);  // QY: should allow setting parent to NULL when detaching SgNodes
  // DQ (9/24/2004): Enforce this simple rule!
     ASSERT_not_null(this);
     ROSE_ASSERT(this != parent);

#if 0
     printf ("In SgNode::set_parent():\n");
     printf (" - this     = %p (%s)\n", this,     class_name().c_str());
     printf (" - parent   = %p (%s)\n", parent,   parent ? parent->class_name().c_str() : "" );
     printf (" - p_parent = %p (%s)\n", p_parent, p_parent ? p_parent->class_name().c_str() : "" );
#endif
     p_parent = parent;

  // I think this should be always be true, so let's inforce it (this happends for test2005_64.C)
     if ( ( variantT() == V_SgClassDeclaration ) && ( parent != nullptr && parent->variantT() == V_SgFunctionParameterList ) )
        {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("Warning: Found case in set_parent() where this is a SgClassDeclaration and parent is a SgFunctionParameterList \n");
#endif
        }

     if ( ( variantT() == V_SgTemplateDeclaration ) && ( parent != nullptr && parent->variantT() == V_SgTemplateInstantiationFunctionDecl ) )
        {
          printf ("Warning: Found case in set_parent() where this is a SgTemplateDeclaration and parent is a SgTemplateInstantiationFunctionDecl \n");
          ROSE_ASSERT(false);
        }

     if ( ( variantT() == V_SgClassDeclaration ) && ( parent != nullptr && parent->variantT() == V_SgGlobal ) )
        {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
          printf ("Warning: Found case in set_parent() where this is a SgClassDeclaration and parent is a SgGlobal \n");
#endif
        }

     if ( ( variantT() == V_SgTemplateInstantiationDecl ) && ( parent != nullptr && parent->variantT() == V_SgClassType ) )
        {
          printf ("Warning: Found case in set_parent() where this is a SgTemplateInstantiationDecl and parent is a SgClassType \n");

          printf ("Exiting in this case! \n");
          ROSE_ASSERT(false);
        }
#if 0
  // DQ (3/3/2022): Adding debugging support for where the parent pointer is used and to make sure 
  // it is not used for types in some specific instances.
     const SgType* type = isSgType(this);
     if (type != NULL)
        {
#if 0
          printf ("In SgNode::set_parent(): this = %p = %s \n",this,this->class_name().c_str());
#endif
        }

  // DQ (3/4/2022): This may be a simpler solution, ant least to get started.
  // SgNode* tmp_parent = get_parent();
     SgNode* tmp_parent = p_parent;

     if (tmp_parent == NULL)
        {
#if 0
          printf ("In SgNode::set_parent(): this = %p = %s tmp_parent == NULL \n",this,this->class_name().c_str());
#endif
        }
       else
        {
#if 0
          printf ("In SgNode::set_parent(): this = %p = %s tmp_parent = %p = %s \n",this,this->class_name().c_str(),tmp_parent,tmp_parent->class_name().c_str());
#endif
          if (type != NULL)
             {
#if 0
               printf ("Error SgNode::set_parent(): this is a SgType IR node: this = %p = %s \n",this,this->class_name().c_str());
#endif
               if (isSgNonrealType(type) != NULL)
                  {
                    SgDeclarationScope* declarationScope = isSgDeclarationScope(tmp_parent);
                    SgTypeTraitBuiltinOperator* typeTraitBuiltinOperator = isSgTypeTraitBuiltinOperator(tmp_parent);
                    if (declarationScope != NULL || typeTraitBuiltinOperator != NULL)
                       {
                         if (declarationScope != NULL)
                            {
                           // This appears to be a common case.
                            }
                           else
                            {
                           // This is less typical case... tracking it.
                              printf ("In SgNode::set_parent(): this = %p = %s tmp_parent = %p = %s \n",this,this->class_name().c_str(),tmp_parent,tmp_parent->class_name().c_str());
                            }
                       }
                      else
                       {
                         printf ("In SgNode::set_parent(): this is a SgNonrealType, however the parent is not a SgDeclarationScope: Exiting as a test! \n");
                         ROSE_ASSERT(false);
                       }
                  }
                 else
                  {
                    if ( ( (isSgTypedefType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) )         ||
                         ( (isSgClassType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) )           ||
                         ( (isSgReferenceType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) )       ||
                         ( (isSgRvalueReferenceType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) ) ||
                         ( (isSgPointerType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) )         ||
                         ( (isSgTypeOfType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) )          ||
                         ( (isSgArrayType(type) != NULL) && (isSgTypeTraitBuiltinOperator(tmp_parent) != NULL) ) )
                       {
                      // I think this may be an error...
#if 1
                         printf ("In SgNode::set_parent(): this = %p = %s tmp_parent = %p = %s \n",this,this->class_name().c_str(),tmp_parent,tmp_parent->class_name().c_str());
#endif
                       }
                      else
                       {
                         SgSymbol* symbol = isSgSymbol(tmp_parent);
                         if (symbol == NULL)
                            {
                           // printf ("In SgNode::set_parent(): parent is not a SgSymbol: Exiting as a test! \n");
                              printf ("In SgNode::set_parent(): this = %p = %s parent = %p = %s is not a SgSymbol: Exiting as a test! \n",
                                   this,this->class_name().c_str(),tmp_parent,(tmp_parent != NULL) ? tmp_parent->class_name().c_str() : "");
                              ROSE_ASSERT(false);
                            }
                       }
                  }
             }
        }
#endif
   }

/*! \brief Get the parent node.
    This function is called internally to connect the elements of the grammar to form the
    AST.  This is the backward reference up the tree.

    \internal We can't have ROSETTA build these access functions since we want specific
    checking of values for NULL pointers (parent point is NULL only for SgProject).
    In the case of a SgType this function returns NULL, because types are shared by design.
 */
SgNode*
SgNode::get_parent () const
   {
     ASSERT_not_null(this);

     SgNode* returnNode = p_parent;

  // DQ (3/3/2022): Tristan commented out the logic below that returned NULL for SgType nodes. After some
  // discussion, I will try a different approach so that we can at least always see the value of p_parent.
  // DQ (5/24/2006): I would like to allow SgSymbols to have a valid parent pointer since it can be used to reference
  // the symbol table as a way to support better debugging within the AST merge mechanims.
  // Sage II semantics: Types and Symbols always have a NULL parent (This is the way it is implemented (from Sage II))


#if 0
#if 0
     printf ("In SgNode::get_parent(): calling checkDataMemberPointersIfInMemoryPool() virtual function to check child IR node pointer values \n");
#endif

  // DQ (3/5/2022): We would not need to cast away const if this function was a const function, and I think it could be trivialy.
     SgNode* this_pointer = const_cast<SgNode*>(this);
     ROSE_ASSERT(this_pointer != NULL);
     this_pointer->checkDataMemberPointersIfInMemoryPool();

#if 0
     printf ("In SgNode::get_parent(): DONE: calling checkDataMemberPointersIfInMemoryPool() virtual function to check child IR node pointer values \n");
#endif
#endif

#if 0
  // DQ (3/3/2022): After discussion with Tristan, this is alternative semantics to assert for NULL value 
  // instead of returning NULL value.
  // if ( isSgType( const_cast<SgNode*>(this) ) != NULL )
  // if ( (isSgType( const_cast<SgNode*>(this) ) != NULL) || (isSgSymbol( const_cast<SgNode*>(this) ) != NULL) )
     if ( (isSgType( const_cast<SgNode*>(this) ) != NULL) || (isSgSymbol( const_cast<SgNode*>(this) ) != NULL) )
        {
#if 0
       // printf ("this = %p = %s p_parent = %p = %s \n",this,this->class_name().c_str(),p_parent,p_parent->class_name().c_str());
          printf ("this = %p p_parent = %p \n",this,p_parent);
          printf ("this class_name = %s \n",this->class_name().c_str());

          if (p_parent != NULL)
             {
               unsigned int* bytePointer = (unsigned int*)p_parent;
            // printf ("*bytePointer = %p \n",*bytePointer);
               printf ("*bytePointer = %u \n",*bytePointer);

               printf ("p_parent->get_freepointer() = %p \n",p_parent->get_freepointer());
             }

          if (isSgPointerType( const_cast<SgNode*>(this) ) == NULL)
             {
               printf ("p_parent variantT = %d \n",(p_parent != NULL) ? p_parent->variantT() : -1);
               printf ("p_parent class_name = %s \n",(p_parent != NULL) ? p_parent->class_name().c_str() : "");
               printf ("this = %p = %s p_parent = %p = %s \n",this,this->class_name().c_str(),p_parent,(p_parent != NULL) ? p_parent->class_name().c_str() : "");
             }
#endif
       // DQ (3/3/2022): The case of a SgType will have a vailid p_parent pointer, but only to a SgSymbol.
#if 0
       // if (isSgType( const_cast<SgNode*>(this) ) != NULL && (isSgSymbol( const_cast<SgNode*>(this) ) == NULL) )
          if (isSgType( const_cast<SgNode*>(this) ) != NULL && (isSgSymbol(returnNode) == NULL) )
             {
               ROSE_ASSERT(returnNode == NULL);
             }
            else
             {
            // I don't think we have to worry aboud this case.
             }
#else
       // DQ (3/4/2022): The code below implements the testing and as a result defines the rule that is implmented (independent of 
       // what might have been a simpler goal for the symantics).

          if (isSgType( const_cast<SgNode*>(this) ) != NULL)
             {
            // DQ (3/5/2022): This should prevend the error from happening in the isSgFunctionTypeSymbol() function when 
            // the point is not a valid pointer to a node in the memory pool.
               if (p_parent != NULL)
                  {
                    ROSE_ASSERT(p_parent->get_freepointer() == AST_FileIO::IS_VALID_POINTER());
                  }

               if ( isSgFunctionTypeSymbol(returnNode) != NULL )
                  {
                 // The parent pointer on SgType nodes is used to point to the entry in the global symbol table (which is a SgFunctionTypeSymbol).
                 // This was a change in ROSE around 2010, to provide more information specific to the global type table information.
                    ROSE_ASSERT(returnNode != NULL);
#if 0
                 // Debugging code to support understanding if non SgNamedType nodes have a valie p_parent pointer.
                    printf ("In SgNode::get_parent(): this is a SgType and the parent is SgFunctionTypeSymbol: Exiting as a test! \n");
                    ROSE_ASSERT(false);
#endif
                  }
                 else
                  {
                    if ( ( (isSgNonrealType( const_cast<SgNode*>(this) ) != NULL) && (isSgDeclarationScope(returnNode) != NULL) ) ||
                         ( (isSgNonrealType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) ) )
                       {
                      // The parent pointer on SgNonrealType nodes is used to point to an associated SgDeclarationScope.
#if 1
                         printf ("In SgNode::get_parent(): this == SgNonrealType && parent is SgDeclarationScope or SgTypeTraitBuiltinOperator \n");
#endif
                         ROSE_ASSERT(returnNode != NULL);
                       }
                      else
                       {
                      // In this case the p_parent pointer should be NULL, but I don't know if this case ever happens.
                      // if ( (isSgTypedefType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) )
                         if ( ( (isSgTypedefType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) )   ||
                              ( (isSgTypeOfType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) )    ||
                              ( (isSgReferenceType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) ) ||
                              ( (isSgClassType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) )     ||
                              ( (isSgRvalueReferenceType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) ) ||
                              ( (isSgArrayType( const_cast<SgNode*>(this) ) != NULL) && (isSgTypeTraitBuiltinOperator(returnNode) != NULL) ) )
                            {
                           // This case may be an error.
#if 1
                              printf ("In SgNode::get_parent(): found case of this = SgTypedefType and p_parent == SgTypeTraitBuiltinOperator \n");
#endif
                              ROSE_ASSERT(returnNode != NULL);
                            }
                           else
                            {
                              ROSE_ASSERT(returnNode == NULL);

                              if ( (isSgTypeComplex( const_cast<SgNode*>(this) ) != NULL)         ||
                                   (isSgTypeDefault( const_cast<SgNode*>(this) ) != NULL)         ||
                                   (isSgModifierType( const_cast<SgNode*>(this) ) != NULL)        ||
                                   (isSgFunctionType( const_cast<SgNode*>(this) ) != NULL)        ||
                                   (isSgArrayType( const_cast<SgNode*>(this) ) != NULL)           ||
                                   (isSgPointerType( const_cast<SgNode*>(this) ) != NULL)         ||
                                   (isSgReferenceType( const_cast<SgNode*>(this) ) != NULL)       ||
                                   (isSgRvalueReferenceType( const_cast<SgNode*>(this) ) != NULL) ||
                                   (isSgTypeOfType( const_cast<SgNode*>(this) ) != NULL)          ||
                                   (isSgAutoType( const_cast<SgNode*>(this) ) != NULL) )
                                 {
                                // these are the cases we are allowing... as part of testing.
                                   printf ("Note: testing in get_parent(): SgTypeComplex and SgTypeDefault have NULL p_parent values \n");
                                 }
                                else
                                 {
                                // These cases are not allowed to be NULL.
#if 1
                                // Debugging code to support understanding if non SgNamedType nodes have a valie p_parent pointer.
                                   printf ("In SgNode::get_parent(): this is a SgType but the parent is NOT a SgSymbol: Exiting as a test! \n");
                                   ROSE_ASSERT(false);
#endif
                                 }
                            }
#if 0
                      // Debugging code to support understanding if non SgNamedType nodes have a valie p_parent pointer.
                         printf ("In SgNode::get_parent(): this is a SgType but the parent is NOT a SgSymbol: Exiting as a test! \n");
                         ROSE_ASSERT(false);
#endif
                       }
                  }
             }
            else
             {
            // Everything else should have a parent pointer unless it is under construction or is the SgProject (root of the AST).
               if (isSgProject( const_cast<SgNode*>(this) ) == NULL)
                  {
                 // ROSE_ASSERT(returnNode != NULL);
                    if (isSgVariableSymbol( const_cast<SgNode*>(this) ) != NULL)
                       {
                         if (returnNode == NULL)
                            {
                              printf ("In SgNode::get_parent(): Found a case of this SgVariableSymbol: parent == NULL \n");
                            }
                       }
                      else
                       {
                         ROSE_ASSERT(returnNode != NULL);
                       }
                  }
             }
#endif
        }
#endif

     return returnNode;
   }


/*! \brief Get the parent node.
    This function is provides access to the p_parent value directly. It is provided for debugging purposes only.
    The existance of this function is to preserve the original semantics of the get_parent() function which returns
    a NULL value for SgType nodes.
 */
SgNode*
SgNode::get_raw_parent () const
   {
  // DQ (3/4/2022): Added access function for p_parent for debugging.
     ROSE_ASSERT(this != NULL);

     SgNode* returnNode = p_parent;

     return returnNode;
   }


// DQ (3/8/2007): Added more efficent implementation to support AST consitency tests and other work.
//! Query function for if the input IR nodes is a child of the current IR node.
bool
SgNode::isChild ( SgNode* node ) const
   {
     return (getChildIndex(node) != -1);
   }


vector<string>
$CLASSNAME::buildCommandLineToSubstituteTransformationFile( const vector<string>& argv, std::string newFileName )
   {
     int fileNameCounter  = 0;
     int fileNameLocation = 0;

  // return a copy of the commandline input to this function
     vector<string> transformation_argv(argv.size());

  // printf ("In buildCommandLineToSubstituteTransformationFile(): argc = %d \n",argc);

  // copy all the entries in the command line.
     for (unsigned int i=0; i < argv.size(); i++)
        {
       // Count up the number of filenames (if it is ZERO then this is likely a link line called
       // using the compiler (required for template processing in C++ with most compilers) if there
       // is ONE then this is the source file.  Currently their can only be ONE source file specified.

       // most options appear as -<option>
       // have to process +w2 (warnings option) on some compilers so include +<option>
          if ( argv[i].size() < 1 || (argv[i][0] != '-') || (argv[i][0] != '+') )
             {
               unsigned int length = argv[i].size();
            // printf ("Look for file names:  argv[%d] = %s length = %d \n",i,argv[i],length);

            // look only for .c and .C files (source code files)
            // The length has to be greater then 2 or else we will generate a purify error!
               if ( (length > 2) && (argv[i][length-2] == '.') && ( (argv[i][length-1] == 'c') || (argv[i][length-1] == 'C') ) )
                  {
                 // printf ("Found a filename = %s \n",argv[i]);
                    transformation_argv[i] = strdup(newFileName.c_str());

                 // record the location of the filename in the command line and the number of filenames
                    fileNameLocation = i;
                    fileNameCounter++;
                  }
                 else
                  {
                    transformation_argv [i] = argv[i];
                  }
             }
            else
             {
               transformation_argv [i] = argv[i];
             }
        }

  // For now ets only debug the case of a single file specified on the command line
     ROSE_ASSERT (fileNameCounter == 1);
     ROSE_ASSERT (fileNameLocation > 0);

  // We have found the location of the filename in the command line (now modify it)

     return transformation_argv;
   }

std::string
$CLASSNAME::unparseToString(SgUnparse_Info* info) const
   {
  // DQ (4/4/2006): Added optional parameter to customize unparsing
  // Generate the string (don't pass a SgUnparse_Info object so that we can use the
  // default settings).
     std::string outputString = globalUnparseToString(this,info);
     return outputString;
   }

std::string
$CLASSNAME::unparseToString() const
   {
  // DQ (9/6/2010): Move this to the source file (we want to eliminate function definitions in header files).
     return this->unparseToString(nullptr);
   }

std::string
$CLASSNAME::unparseToCompleteString()
   {
  // Generate the string (pass a SgUnparse_Info object)
     SgUnparse_Info* inputUnparseInfoPointer = new SgUnparse_Info();
     inputUnparseInfoPointer->unset_SkipComments();    // generate comments
     inputUnparseInfoPointer->unset_SkipWhitespaces(); // generate all whitespaces to format the code
     std::string outputString = globalUnparseToString(this,inputUnparseInfoPointer);

  // DQ (2/18/2013): Added fix to delete SgUnparse_Info built to support unparseToCompleteString().
     delete inputUnparseInfoPointer;
     inputUnparseInfoPointer = nullptr;

     return outputString;
   }

void
SgCopyHelp::insertCopiedNodePair( const SgNode* key, SgNode* value )
   {
  // DQ (10/8/2007): This function support the saving of state used to associated original IR nodes with the copies made of them so that symbols can be updated.

     if (copiedNodeMap.find(key) == copiedNodeMap.end())
        {
       // Add the node to the map...
          copiedNodeMap[key] = value;
        }
   }


SgNode*
SgTreeCopy::copyAst( const SgNode *n )
   {
  // DQ (10/8/2007): I have modified this function to have a single return.
  // This function is called by the copy mechanism to copy AST child trees.

     SgNode *nCopy = nullptr;

  // If this is a SgType, then force it to be shared, since all SgTypes are shared.
     if (isSgType(n) != nullptr)
        {
       // Share the reference to the IR node.
          nCopy = const_cast<SgNode *>(n);
        }
       else
        {
       // If this is a class definition then only do a deep copy if it is from a defining class declaration.
          const SgClassDefinition* classDefinition = isSgClassDefinition(n);
          if (classDefinition != nullptr)
             {
               ASSERT_not_null(classDefinition->get_parent());
               SgClassDeclaration* classDeclaration = isSgClassDeclaration(classDefinition->get_parent());
               if (classDeclaration == classDeclaration->get_definingDeclaration())
                  {
                 // Do a deep copy on this IR node.
                    nCopy = n->copy(*this);
                  }
                 else
                  {
                 // Share the reference to the IR node.
                    nCopy = const_cast<SgNode *>(n);
                  }
             }
            else
             {
            // Do a deep copy on this IR node.
               nCopy = n->copy(*this);
             }

       // Set the parent to NULL, the copy mechanism we set it correctly ...
          nCopy->set_parent(nullptr);
        }

     return nCopy;
   }

// DQ (8/10/2008): Added to support binary file format.
std::ostream &
operator<< ( std::ostream & os, const std::multimap<rose_addr_t, rose_addr_t> & m )
   {
     return os;
   }

// DQ (8/10/2008): Added to support binary file format.
std::ostream &
operator<< ( std::ostream & os, const struct stat & sb )
   {
     return os;
   }

// DQ (4/5/2017): Moved these function definition out of the header file to avoid warnings from
// assertion from the header file (OK if it appears once from compiling the source file).
VirtualCFG::CFGNode
SgNode::cfgForBeginning()
   {
     ASSERT_not_null(this);
     return VirtualCFG::CFGNode(this, 0);
   }

VirtualCFG::CFGNode
SgNode::cfgForEnd()
   {
     ASSERT_not_null(this);
     return VirtualCFG::CFGNode(this, this->cfgIndexForEnd());
   }

VariantT SgNode::variantFromPool(SgNode const * n) {
  for (std::tuple<unsigned char*, unsigned, VariantT> const & pool: all_pools) {
    auto & base = std::get<0>(pool);
    auto & size = std::get<1>(pool);
    auto offset = ((unsigned char*)n - base);
    if ( offset >= 0 && offset < size ) return std::get<2>(pool);
  }
  return (VariantT)0;
}

SOURCE_END

SOURCE_ROOT_NODE_ERROR_FUNCTION_START

SOURCE_ROOT_NODE_ERROR_FUNCTION_END


SOURCE_ERROR_FUNCTION_START

SOURCE_ERROR_FUNCTION_END
