// #########################################################
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START
     public:
       // DQ (8/19/2004): Remove old attribute mechanism
       // void output_pragma(ostream& os);
       // void set_pragma();

       // DQ (11/17/2004): Make this a virtual function since we have several different implementations
       // (e.g. where the scope is stored explicitly) Effected declarations:
       //     class declarations (and derived classes (e.g. template instantiation declarations)
       //     template declarations (which covers all forms of template declarations for classes, functions, and member functions)
       //     function declarations (including member functions, template functions and template member functions)
       //     variable declarations
          virtual SgScopeStatement *get_scope(void) const;

          virtual void setExtern() ROSE_DEPRECATED_FUNCTION;
          virtual void setStatic() ROSE_DEPRECATED_FUNCTION;

      protected:
          virtual bool replace_child(SgStatement *target,SgStatement * newStmt, bool extractListFromBasicBlock = false);
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false);

       public:

      /*
          name Low-Level Rewrite Support
          \brief Support for mutation of the AST.

          This is the lowest level of support for the mutation of the AST.  From these
          primitives we have built more sophisticated mechanisms which are simpler to
          use and which automate many details (not handled within these functions):
             -# Preservation of attached comments
             -# Marking new IR nodes with correct file info position objects
                (often just the specification of the new code as a transformation).
             -# ...\n

          Higher level mechanism for the manipulation of the AST are available in the
          \ref ASTRewriteMechanism. These higher-level interfaces simplify the
          manipulation of the AST.

          \internal Need to document this section more fully.
       */

          /*!
             \brief This function inserts a single statement at the position indicated by target.

             This function handles the insertion of the specified statement at the target location.
             The boolean variable specifies if the new statement is inserted before or after the target
             statement.

             \param target - location in the AST where new statement is to be inserted.
             \param newstmt - New statement to be placed into the AST.
             \param inFront - if true the new statement is inserted before the target statement, else
                              the new statement is inserted after the target statement (default = true).
             \return Function returns void.
          */
          void insert_statement(SgStatement* target, SgStatement* newstmt, bool inFront = true);
          /*!
             \brief This function inserts a list of statements at the position indicated by target.

             This function handles the insertion of a list of statements at the target location.
             The boolean variable specifies if the new statements are inserted before or after the target
             statement.

             \param target - location in the AST where new statements are to be inserted.
             \param newstmt - List of new statements to be placed into the AST.
             \param inFront - if true the new statements are inserted before the target statement, else
                              the new statements are inserted after the target statement (default = true).
             \return Function returns void.
          */
          void insert_statement(SgStatement* target, const SgStatementPtrList& newstmtList, bool inFront = true);
         /*!
             \brief This function replaces the target statement with a single statement.

             This function handles the replacement of the specified target statement with a new statement.

             \param target - location of the statement to be replaced.
             \param newstmt - New statement to replace target statement in the AST.
             \return Function returns void.
          */
           void replace_statement(SgStatement* target, SgStatement* newstmt);
          /*!
             \brief This function replaces the target statement with a list of statements.

             This function handles the replacement of the specified target statement with
             a list of statements at the target location.

             \param target - location of the statement to be replaced.
             \param newstmt - List of new statements to replace the target statement in the AST.
             \return Function returns void.
          */
           void replace_statement(SgStatement* target, const SgStatementPtrList& newstmtList);
         /*!
             \brief This function removes the target statement from the AST.

             This function handles the removal of the target statement from the AST.
             Any comments or C preprocessor directives associated with the statement
             are also removed.  This is a low level primitive for higher level functions
             (in the higher level interfaces) which take care to preserve such attributes.

             \param target - location of the statement to be removed.
             \return Function returns void.
          */
           void remove_statement(SgStatement *);

          /*!
             \brief This function inserts a statement at the position indicated by target.
             If newstmt is a basicBlock, statements inside newstmt are extracted and then inserted.

             This function handles the insertion of the specified statement at the target location.
             The boolean variable specifies if the new statement is inserted before or after the target
             statement.  This function has somewhat unusual semantics.

             \internal This function is low level support (only used by Qing)

             \param target - location in the AST where new statement is to be inserted.
             \param newstmt - New statement to be placed into the AST.
             \param inFront - if true the new statement is inserted before the target statement, else
                              the new statement is inserted after the target statement (default = true).
             \return Function returns void.

             \deprecated This function is used only in Qing's code and not clearly a part of the preferred interface.
          */
          void insert_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt, bool inFront = true);

          /*!
             \brief This function replaces the target statement with a new statement.
             If newstmt is a basicBlock, statements inside newstmt are extracted and then inserted.

             This function handles the replacement of the target statement with the new statement.
             This function has somewhat unusual semantics.

             \internal This function is low level support (only used by Qing)

             \param target - statement in AST to be replaced..
             \param newstmt - New statement to be placed into the AST.
             \return Function returns void.

             \deprecated This function is used only in Qing's code and not clearly a part of the preferred interface.
          */
          void replace_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt);

       // DQ (12/6/2006): Added to support general replace functions (used in statements that
       // directly contain SgExpression IR nodes, e.g. SgForStatement's increment expression).
          /*!
             \brief support general replace functions, used in statements that directly contain SgExpression IR nodes.
          */
          virtual int replace_expression(SgExpression* original_expression, SgExpression* new_expression );

       /* */

      // DQ (12/5/2004): Support for setting explicit scopes (where stored explicitly).
      //! Support for setting scopes (only meaningful on IR statements that store the scope explicitly).
          virtual void set_scope ( SgScopeStatement* newScope );

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const;

      // DQ (2/6/2007): Added support for getting the symbol from the declaration (I think that Beata ask for this at some point).
      //! Get the associated symbol from the symbol table in the stored scope
          virtual SgSymbol* get_symbol_from_symbol_table() const;

#if 0
       // Commented out by Dan Quinlan (while we worry about other main-line features)
          void set_purecc();
          void unset_purecc();
          int get_is_purecc() const;
          void add_pragma(int cnt, SgPragma** plist);
          SgPragma* add_pragma(char *nm) ;
          SgPragma* get_pragma(char *nm) const;
          int remove_pragma(char *nm) ;

       // get attribute,
          SgAttribute* get_user_attribute(char *nm) const;
          SgAttribute* add_user_attribute(char *nm,SgAttribute *attr);
          int remove_user_attribute(char *nm);
#endif

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
       // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int index) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

          virtual void set_end_numeric_label(SgLabelRefExp* end_numeric_label);

       // Report if a construct has a concept of end_numeric_label
          virtual bool has_end_numeric_label() const;

      /*! \brief Some statement store internal SgType pointers explicitly.  This function is true if it has a data member that is a type (only applies to SgTypedefDeclaration).

          Result is true if it stores a type explicitly as a data member, else false.

          \internal True only if this is a SgTypedefDeclaration.
       */
          bool hasExplicitType();

HEADER_END


HEADER_X_STATEMENT_START
       // void post_construction_initialization();
HEADER_X_STATEMENT_END


HEADER_NON_X_STATEMENT_START
       // void post_construction_initialization();
HEADER_NON_X_STATEMENT_END


HEADER_SCOPE_STATEMENT_START

     public:

#if 0
       // DQ (5/23/2013): Put the get_symbol_table() function back to being public so that we can proceed with testing.
       // This fails for the GNU 4.4 compiler only. Sort it out later.

       // DQ (5/21/2013): This class needs access because it rebuilds the symbol tables.
          friend class FixupAstSymbolTables;

       // DQ (5/21/2013): This class needs access because it rebuilds the parent child links in the symbol table (for symbols).
          friend class ResetParentPointersInMemoryPool;
          friend class FixupAstDefiningAndNondefiningDeclarations;
          friend class ResetEmptyNames;
          friend class FixupAstSymbolTablesToSupportAliasedSymbols;

       // DQ (5/21/2013): This is a static function in sageInterface.C (it required some specific access to the symbol table).
          friend SgVariableSymbol * addArg(SgFunctionParameterList *paraList, SgInitializedName* initName, bool isPrepend);
          friend int  SageInterface::set_name ( SgInitializedName *initializedNameNode, SgName new_name );
          friend void SageInterface::replaceExpressionWithStatement(SgExpression* from, SageInterface::StatementGenerator* to);
          friend void SageInterface::rebuildSymbolTable ( SgScopeStatement* scope );
          friend void SageInterface::fixupReferencesToSymbols( const SgScopeStatement* this_scope,  SgScopeStatement* copy_scope, SgCopyHelp & help );
          friend int  SageInterface::suggestNextNumericLabel(SgFunctionDefinition* func_def);
          friend void SageInterface::deleteAST ( SgNode* n );
          friend void SageInterface::moveStatementsBetweenBlocks ( SgBasicBlock* sourceBlock, SgBasicBlock* targetBlock );

       // DQ (5/21/2013): From the AST consistancy tests.
          friend class TestAstSymbolTables;

       // DQ (5/21/2013): Support for the inliner.
          friend bool doInline(SgFunctionCallExp* funcall, bool allowRecursion);
          friend class FlattenBlocksVisitor;
          friend class RenameVariablesVisitor;
          friend class RenameLabelsVisitor;

       // DQ (5/21/2013): Support for the outliner.
          friend void ASTtools::moveStatements (SgBasicBlock* src, SgBasicBlock* dest);
          friend void ASTtools::collectLocalVisibleVarSyms (const SgStatement* root,const SgStatement* target,VarSymSet_t& syms);
#endif


       // Since we suppress the generation of the constructors we have to declare them explicitly
       // SgScopeStatement ();
          $CLASSNAME ( Sg_File_Info* file_info = NULL );

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const;

       // DQ (2/22/2007): Added mangled name support for scopes so that the
       // mangled names for declarations could have better support!
          virtual SgName get_mangled_name() const;

       // DQ (2/10/2007): Added member function.
      //! return number of entries in symbol table for the specified name
      //! (note that it is sometime OK for there to be more than 1).
          size_t count_symbol(const SgName& n);

       // DQ (5/14/2011): Added count for alias symbols (used in name qualification, since alias symbols of a base class are added to the derived class).
      //! Count for alias symbols of a specific name, used in name qualification support.
          size_t count_alias_symbol(const SgName& n);

      //! Return the size of the symbol table.
          size_t symbol_table_size();

       // Single interface for inserting symbol into symbol table
          void insert_symbol(const SgName& n, SgSymbol* s);

       // DQ (2/10/2007): I would like to deprecate this since it returns and integer and is not named well for such a return type!
       // see if this is in symbol table already
          int lookup_symbol( const SgName& n, SgSymbol* s) const ROSE_DEPRECATED_FUNCTION;

       // DQ (2/10/2007): Do we want an interface like this?
       // Note that these are relatively expensive functions since they do an exhaustive search of the symbol table.
          bool symbol_exists ( const SgName &, SgSymbol *sp ) const;
          bool symbol_exists ( const SgName & name ) const;
          bool symbol_exists ( const SgSymbol *sp ) const;

       // remove an existing symbol from the symbol table (does not call delete on the symbol)
          void remove_symbol ( SgSymbol* s );

       // DQ (1/30/2007): Many of these have been added back into ROSE, now we have examples showing they are
       // required to find the different types of symbols that can be placed into the same
       // scope using the same name.

       //! get the first symbol with name (note that "" is a valid name and is used for unnamed declarations)
       //! the input name is stored as internal state to support the use of next_XXX_symbol() member function.
          SgSymbol*          lookup_symbol            (const SgName& n, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentList = NULL) const;

          SgVariableSymbol*  lookup_var_symbol        (const SgName& n) const ROSE_DEPRECATED_FUNCTION;
          SgVariableSymbol*  lookup_variable_symbol   (const SgName& n) const;

       // DQ (8/22/2012): We need more information to disambiguate where template argument name qualification would be important. See test2012_195.C.
          SgClassSymbol*     lookup_class_symbol      (const SgName& n, SgTemplateArgumentPtrList* templateArgumentsList = NULL) const;

          SgNonrealSymbol*   lookup_nonreal_symbol    (const SgName& n, SgTemplateParameterPtrList* templateParameterList = NULL, SgTemplateArgumentPtrList* templateArgumentsList = NULL) const;

          SgFunctionSymbol*  lookup_function_symbol   (const SgName& n) const;

       // DQ (8/10/2013): Added to support function symbol lookup for template instantiations that would only be disambiguated by their template arguments.
          SgFunctionSymbol*  lookup_function_symbol   (const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList = NULL) const;

          SgTypedefSymbol*   lookup_typedef_symbol    (const SgName& n) const;
          SgEnumSymbol*      lookup_enum_symbol       (const SgName& n) const;
          SgEnumFieldSymbol* lookup_enum_field_symbol (const SgName& n) const;
          SgLabelSymbol*     lookup_label_symbol      (const SgName& n) const;
          SgJavaLabelSymbol* lookup_java_label_symbol (const SgName& n) const; // charles4: added 09/12/2011
          SgNamespaceSymbol* lookup_namespace_symbol  (const SgName& n) const;

       // DQ (12/12/2011): Added support for template declarations in the AST.
          SgTemplateClassSymbol* lookup_template_class_symbol    (const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList) const;

       // DQ (3/8/2017): Adding support for SgTemplateTypedefDeclaration IR nodes.
          SgTemplateTypedefSymbol* lookup_template_typedef_symbol (const SgName& n) const;

       // DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based on the
       // arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is being constructed).
          SgClassSymbol*     lookup_nontemplate_class_symbol (const SgName& n, SgTemplateArgumentPtrList* templateArgumentsList) const;

       // DQ (8/9/2013): Note that template functions can't be specialized, so we need to only handle SgTemplateParameterPtrList
       // DQ (12/27/2011): Added support for template declarations in the AST.
          SgTemplateFunctionSymbol*       lookup_template_function_symbol (const SgName& n, const SgType* t, SgTemplateParameterPtrList* templateParameterList) const;

          SgTemplateVariableSymbol*       lookup_template_variable_symbol (const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList) const;

       // DQ (8/10/2013): If there are template arguments then they are used to disambiguate template instantiations that might match existing non-template instantiations (normal functions).
          SgFunctionSymbol*               lookup_nontemplate_function_symbol (const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList = NULL) const;

          SgTemplateMemberFunctionSymbol* lookup_template_member_function_symbol (const SgName& n, const SgType* t, SgTemplateParameterPtrList* templateParameterList) const;

       // DQ (8/10/2013): If there are template arguments then they are used to disambiguate template instantiations that might match existing non-template instantiations (normal functions).
       // DQ (5/23/2013): Added API function so that we would not have to access the symbol tabel directly.
       // SgMemberFunctionSymbol* lookup_nontemplate_member_function_symbol (const SgName& n, const SgType* t) const;
          SgMemberFunctionSymbol* lookup_nontemplate_member_function_symbol (const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList = NULL) const;

       // DQ (1/23/2019): This function adds the support to find the SgAlias symbols of a given name.
       // This is important in handling the viability of symbols through base classes when private base
       // class derivation is used.
          SgAliasSymbol* lookup_alias_symbol(const SgName& n, SgSymbol* sp) const;

       // DQ (2/16/2019): Added to support detection of ambiguity that drives the generation of name qualification.
          bool hasAmbiguity(SgName & name, SgSymbol* symbol);

       //! get the first symbol independent of name (lack of name is stored as internal state)
          SgSymbol*          first_any_symbol        () const;
          SgVariableSymbol*  first_variable_symbol   () const;
          SgClassSymbol*     first_class_symbol      () const;
          SgFunctionSymbol*  first_function_symbol   () const;
          SgTypedefSymbol*   first_typedef_symbol    () const;
          SgEnumSymbol*      first_enum_symbol       () const;
          SgEnumFieldSymbol* first_enum_field_symbol () const;
          SgLabelSymbol*     first_label_symbol      () const;
          SgNamespaceSymbol* first_namespace_symbol  () const;
          SgTemplateSymbol*  first_template_symbol   () const;

       // Should we have a member function like this!
       // SgFunctionSymbol*  first_function_symbol  (const SgType* t) const;

       //! Only use after lookup_XXX_symbol(const SgName&) or after first_XXX_symbol()
       //! These functions use the stored state of the name or lack of name (from the
       //! lookup_XXX_symbol(const SgName&) or after first_XXX_symbol() member function)
       //! and return the next symbol.
          SgSymbol*          next_any_symbol        () const;
          SgVariableSymbol*  next_variable_symbol   () const;
          SgClassSymbol*     next_class_symbol      () const;
          SgFunctionSymbol*  next_function_symbol   () const;
          SgTypedefSymbol*   next_typedef_symbol    () const;
          SgEnumSymbol*      next_enum_symbol       () const;
          SgEnumFieldSymbol* next_enum_field_symbol () const;
          SgLabelSymbol*     next_label_symbol      () const;
          SgNamespaceSymbol* next_namespace_symbol  () const;
          SgTemplateSymbol*  next_template_symbol   () const;

       // Should we have a member function like this!
       // SgFunctionSymbol*  next_function_symbol  (const SgType* t) const;

       /* some symbol table printing utility routines */
          void print_symboltable(const std::string& str, std::ostream& os );
          void print_symboltable(const std::string & label, VariantT nodeType);
          void print_symboltable(const std::string & str);

       // DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
       // SgDeclarationStmt while others can contain any kind of SgStatement
      //! This function is used to indicate if either the getDeclarationList() or
      //! getStatementList() can be called to return a reference to the list of IR nodes
      //! (manipulation of the list is then possible).
          bool containsOnlyDeclarations() const;
          void insertStatementInScope ( SgStatement* newTransformationStatement, bool atTop );
          SgDeclarationStatementPtrList & getDeclarationList();
          SgStatementPtrList & getStatementList();

       // DQ (10/6/2007): Added to support const version of generateStatementList()
          const SgDeclarationStatementPtrList & getDeclarationList() const;
          const SgStatementPtrList & getStatementList() const;

       // DQ (2/1/2007): Made the return type const to reflect that the list is read-only.
      //! Generate s list of statements from either the existing list of statements or
      //! the list of declarations.  This permits access via a common type (SgStatement).
      //! (this list is constructed and manipulation of it will not effect the scope's
      //! SgStatementPtrList or SgDeclarationStatementPtrList. So this should be considered
      //! to be a read only list.
          const SgStatementPtrList generateStatementList() const;

       // DQ (6/26/2013): Added function to test for existence of statement in scope.
      //! Test for existence of statement is scope.
          bool statementExistsInScope ( SgStatement* statement );

       // DQ (5/22/2006): Added function here so that it could be defined for all scopes (instead of just a few)
       // virtual SgName get_mangled_name (void) const;

       // DQ (10/18/2006): Not all scopes permit function declarations.
       /*! \brief Reports if scope can support defining function declarations.
       // Not all scopes permit function declarations. Any function prototype in a
       // scope appropriate for a function definition triggers requirements for name qualification.
       // This function returns true if the scope is appropriate for the definition of a function
       // or member function (i.e. is a SgGlobal, SgClassDefinition, or SgNamespaceDefinitionStatement).
       */
          bool supportsDefiningFunctionDeclaration();

       // DQ (2/20/2007): Added support for AST merge (which requires unique names for even un-named
       // constructs (we use the position in scope as part of the unique name generation).  This has to
       // be non-const since it calls the non-const list functions.  This could all be fixed, I think.
      //! Generate a unique number for the statement in the scope.
          unsigned int generateUniqueStatementNumberForScope( SgStatement* statement );

      //! Helper for generateUniqueStatementNumberForScope: return true if the
      //! element is found, incrementing the counter once for each element of
      //! tree up to either the element of the end of the sub-statements in the
      //! current statement
          bool generateUniqueStatementNumberForScopeHelper( unsigned int& counter, SgStatement* statement );

       // DQ (6/5/2007): Build special operator to return by reference
      /*! \brief This list of symbols represent types that will require type elaboration when source code is generated.
       */
          std::set<SgSymbol*> & get_type_elaboration_list ();

      /*! \brief This list of symbols represent types that will require name qualification when the type name is output.
       */
          std::set<SgSymbol*> & get_hidden_type_list ();

      /*! \brief This list of symbols represent declarations that will require name qualification when the identifier name is output.
       */
          std::set<SgSymbol*> & get_hidden_declaration_list ();

       // DQ (6/5/2007): Build special operators set the hidden lists (not clear if these are used or required)
          void set_type_elaboration_list ( const std::set<SgSymbol*> & type_elaboration_list );
          void set_hidden_type_list ( const std::set<SgSymbol*> & hidden_type_list );
          void set_hidden_declaration_list ( const std::set<SgSymbol*> & hidden_declaration_list );

       // DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
      //! Higher level function to handle statements and declarations is scopes.
          void append_statement ( SgStatement* stmt );
          void prepend_statement ( SgStatement* stmt );

          SgStatement* firstStatement() const;
          SgStatement* lastStatement() const;

  // protected:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (11/28/2010): Added case sensitive/insensitive option to symbol table behavior.
      //! Query of scope symbol table behavior (is symbol table behavior case sensitive (C/C++) or case insensitive (Fortran).
          bool isCaseInsensitive() const;
          void setCaseInsensitive(bool b);

       // DQ (5/11/2011): Added support for new name qualification implementation.
      //! Some scopes have associated names for purposed of name qualification. This returns true if the scope has a name, false if not.
          bool isNamedScope();

       // DQ (5/11/2011): Added support for new name qualification implementation.
      //! Some scopes have associated names for purposed of name qualification. This generates the associated name.
          SgName associatedScopeName();

       // DQ (1/21/2013): Added test for equivalents (e.g. namespace definitions that might be different IR nodes, but for an equivalent namespace).
          static bool isEquivalentScope( SgScopeStatement* scope1, SgScopeStatement* scope2);
#if 0
  // DQ (5/23/2013): We want to make this private, and this works for C/C++, but not yet for Fortran (at least).
     private:
#else
  // DQ (5/23/2013): Restore this as public so that I can get the C/C++ work tested in Jenkins and fixup the Fortran support afterward.
     public:
#endif
       // DQ (5/21/2013): This function is removed from the SgScopeStatement API as a public member function.
       // It is replaced in the SgScopeStatement as a soon to be private member function.  This is done to
       // support hiding the namespace symbol table handling behind the SgScopeStatement level of support.
       // There is no reason for the symbol table to be directly accessible to users, if there is a problem
       // then the SgScopeStatement class API should be extended with the required functionality.
          SgSymbolTable* get_symbol_table () const;
          void set_symbol_table ( SgSymbolTable* symbol_table );

     public:
       // DQ (8/7/2013): Adding support for template function overloading using template parameters (info passed as template arguments for specialization).
       // DQ (5/21/2013): Added support for organizing how we match function declarations with function symbols.
       // This function was moved from the symbol table to the SgScopeStatement so that we could make the
       // symbol table access functions private as part of the new namespace symbol table handling.
          template<class T> SgFunctionSymbol* find_symbol_by_type_of_function (const SgName & name, const SgType* func_type, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList);

       // DQ (5/21/2013): This function is used by the get_symbol_from_symbol_table() functions.
          template<class T> SgSymbol* find_symbol_from_declaration(const T* node) const;

     public:


HEADER_SCOPE_STATEMENT_END


HEADER_STATEMENT_POSTDECLARATION_START

#if 0
       // DQ (5/23/2013): Put the get_symbol_table() function back to being public so that we can proceed with testing.
       // This fails for the GNU 4.4 compiler only. Sort it out later.

// DQ (5/21/2013): Inserted forward namespace declaration, so that we can reference the namespace
// in the friend functions of the SgScopeStatement.  It appears hat this is not allowed.
namespace SageInterface
   {
     class StatementGenerator;
     int  set_name ( SgInitializedName *initializedNameNode, SgName new_name );
     void replaceExpressionWithStatement(SgExpression* from, StatementGenerator* to);
     void rebuildSymbolTable ( SgScopeStatement* scope );
     void fixupReferencesToSymbols( const SgScopeStatement* this_scope,  SgScopeStatement* copy_scope, SgCopyHelp & help );
     int  suggestNextNumericLabel(SgFunctionDefinition* func_def);
     void deleteAST ( SgNode* n );
     void moveStatementsBetweenBlocks ( SgBasicBlock* sourceBlock, SgBasicBlock* targetBlock );
   }

namespace ASTtools
   {
     typedef std::set<const SgVariableSymbol *> VarSymSet_t;
     void moveStatements (SgBasicBlock* src, SgBasicBlock* dest);
     void collectLocalVisibleVarSyms (const SgStatement* root,const SgStatement* target,VarSymSet_t& syms);
   }
#endif


// DQ (12/30/2009): This has been moved from SOURCE_MAIN_STATEMENT to
// here so that ic can be referenced from the separate source files
// now optionally generated within ROSE to support smaller ROSETTA
// generated files.

// DQ (12/30/2009): This does not appear to be required to be a template function (base class will work just fine).

// Replace target with newstmt if target matches 'cur'
template <class Elemtype>
inline bool
StatementReplace(SgStatement* /*parent*/, Elemtype* &cur, SgStatement* target, SgStatement* newstmt)
   {
     if (cur == target)
        {
       // newstmt can be NULL or it must be compatible with cur's type
          ROSE_ASSERT (newstmt == 0 || dynamic_cast<Elemtype*>(newstmt));
#ifndef REMOVE_SET_PARENT_FUNCTION
       // DQ (9/24/2004): Parent will be set in the AST fixup (in post-processing of the AST in AST Fixup)
       // Should not be set within EDG/Sage III connection code!
          printf ("Warning: Temporarily skipping set_parent in StatementReplace \n");
#endif

          cur = static_cast<Elemtype *>(newstmt);
          return true;
        }
     return false;
   }

// Temporary while we move code to use generateMatchingFileInfo directly.
inline Sg_File_Info* New_File_Info( SgLocatedNode *p)
   {
     ROSE_ASSERT(p != NULL);
     return p->generateMatchingFileInfo();
   }

HEADER_STATEMENT_POSTDECLARATION_END


HEADER_POST_CONSTRUCTION_INITIALIZATION_START
          void post_construction_initialization() override;
HEADER_POST_CONSTRUCTION_INITIALIZATION_END


HEADER_FUNCTION_TYPE_TABLE_START

      //! Constructor
       // $CLASSNAME ();
          SgFunctionTypeTable();

          void insert_function_type(const SgName&, SgType *);

          SgType* lookup_function_type (const SgName&);

       // DQ (1/31/2007): Added to support AST merge.
          void remove_function_type(const SgName&);

          void print_functypetable(std::ostream& os = std::cout);

HEADER_FUNCTION_TYPE_TABLE_END

          void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what);
          void append_statement(const SgStatementPtrList::iterator& where, SgStatement *what);


HEADER_DECLARATION_STATEMENT_START

       // DQ (5/9/2005): Added support for template specialization!
       /*! \brief Template Specialization Support

           different forms of template specialization for - classes, functions, and variable declarations
        */
          enum template_specialization_enum
             {
               e_unknown                      = 0, /*!< unknown value (error value) */
               e_no_specialization            = 1, /*!< not a specialization (default value) */
               e_partial_specialization       = 2, /*!< partial specialization */
               e_specialization               = 3, /*!< specialization */
               e_template_specialization_last = 4  /*!< last value (unused) */
             };

      /*! \brief GNU extension for visibility modifier (only one value can be specified)

          Visibility modifier information about (unspecified, hidden, protected, internal).

          \internal Only one value can be specified.
       */
          enum gnu_extension_visability_attribute_enum
             {
            // Bit values can support multiple values in a single enum type
               e_gnu_attribute_visability_unknown     = 0, /*!< Unknown value (error) */
               e_gnu_attribute_visability_unspecified = 1, /*!< Default value */
               e_gnu_attribute_visability_hidden      = 2, /*!< hidden visibility attribute */
               e_gnu_attribute_visability_protected   = 3, /*!< protected visibility attribute */
               e_gnu_attribute_visability_internal    = 4, /*!< internal visibility attribute */
               e_last_gnu_visability_attribute   /*!< last visibility attribute value (upper bound on range of values, used in error checking) */
             };

       // DQ (4/25/2004): Part of new interface to declaration modifiers (refactoring).
       // The following access functions are not technically modifiers as defined
       // in the language. They act like modifiers to the unparser and to the
       // representation of the original source structure within the AST.

       // this is to distinguish a forward declaration (class or function)
       // class X;
       // class X { };

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isForward() const;
          void setForward();
          void unsetForward();

       // this is to distinguish cases like this
       // class-P pvar;            -- isNameOnly=1
       // class-P { int a; } pvar; -- isNameOnly=0

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isNameOnly() const;
          void setNameOnly();
          void unsetNameOnly();

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  isExternBrace() const;
          void setExternBrace();
          void unsetExternBrace();

       // this is to distinguish cases like this
       // class P var;
       // P var;

       // DQ (11/28/2009): Changed return type from "int" to "bool"
          bool  skipElaborateType() const;
          void setSkipElaborateType();
          void unsetSkipElaborateType();

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const;

     protected:
       // Protected support for templates used within SgTemplateInstantiationDeclaration
       // SgTemplateInstantiationFunctionDecl and SgTemplateInstantiationMemberFunctionDecl
          void resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name );

       // Tests names generated specific to templates (such names should exclude
       // "<<" and ">>" since that will cause generated code to not compile).
          void testForBadGenerateTemplateName( const std::string & name );

       // Support for skipping the "<" and ">" when the output of the template argument list would be empty.
          bool skipEmptyTemplateArgumentListTest ( SgFunctionDeclaration* functionDeclaration );

          SgName fixupTemplateNameForMangledNameSupport( const SgName & s) const;

       // DQ (6/2/2006): Support for name mangling of unnamed classes embedded in
          SgName generate_alternative_name_for_unnamed_declaration ( SgNode* parent ) const;

       // DQ (6/3/2006): Support for unnamed declaration is scopes.
          SgName generate_alternative_name_for_unnamed_declaration_in_scope ( SgScopeStatement* scope ) const;

     public:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (10/10/2006): Handle qualified name list at the declarations directly, instead of at the types.
       // At present these are useful for SgVariableDeclaration and SgTypedefDeclaration, but likely others
       // at some point.
          SgQualifiedNamePtrList & get_qualifiedNameList();
          const SgQualifiedNamePtrList & get_qualifiedNameList() const;
          void set_qualifiedNameList( const SgQualifiedNamePtrList & x );

       // DQ (2/10/2007): Added virtual function to make it easier to use this on
       // the specific declarations where it is meaningful (ones associated with symbols).
       // This appears to have already been done a few days ago!
       // virtual SgSymbol* get_symbol_from_symbol_table();

       // DQ (2/11/2007): Added to support the virtual function in derived classes
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // DQ (7/4/2007): Get the declaration for which get_symbol_from_symbol_table() returns a valid pointer.
          SgDeclarationStatement* get_declaration_associated_with_symbol() const;

       // DQ (7/4/2007): Search for a symbol from either the first non-defining
       // declaration or the defining declaration (this should always return a valid symbol).
          SgSymbol* search_for_symbol_from_symbol_table() const;

       // DQ (7/26/2007): report which declarations can be expected to have an associated symbol,
       // since not all declarations are associated with a symbol.  This is mostly used for internal
       // testing so that we can know when to verify rules about associated symbols.
          bool hasAssociatedSymbol() const;

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the named declaration (only applied to restricted set of declarations where name qualification can be used).
          SgName get_qualified_name_prefix() const;

       // DQ (12/23/2011): This is part of work to reorganize the templates in the AST (and a recent redesign of this work, because the first approach could not be supported in more complex code examples).
      //! This function returns the template name (taken from the template declaration for the class, function, member function, or variable template declaration).
          SgName get_template_name() const;

       // DQ (1/26/2013): Added non-automatically generated version so that additional testing could be added.
          SgDeclarationStatement* get_definingDeclaration() const;
          void set_definingDeclaration(SgDeclarationStatement* definingDeclaration);
          SgDeclarationStatement* get_firstNondefiningDeclaration() const;
          void set_firstNondefiningDeclaration(SgDeclarationStatement* firstNondefiningDeclaration);

       // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
       // template low-level symbol table support function would compile cleanly.  Note that it is an error to
       // call this function and it is not a virtual function that will cause derived class versions to be called
       // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).
          SgType* get_type() const;

       // DQ (3/10/2018): Adding support to output the name, useful for debugging template instantiations which have more complex name using template arguments.
          std::string unparseNameToString();

HEADER_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_SPECIALIZATION_SUPPORT_START

     public:
          bool isSpecialization() const;
          bool isPartialSpecialization() const;

HEADER_TEMPLATE_SPECIALIZATION_SUPPORT_END


HEADER_LIST_DECLARATIONS_START
     public:
          virtual void append_LIST_FUNCTION_NAME  ( LIST_ELEMENT_DATA_TYPE element );
          virtual void prepend_LIST_FUNCTION_NAME ( LIST_ELEMENT_DATA_TYPE element );

     public:
       // New functions added
       // LIST_FUNCTION_RETURN_TYPE append_LIST_FUNCTION_NAME  ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );
       // LIST_FUNCTION_RETURN_TYPE prepend_LIST_FUNCTION_NAME ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );

       // LIST_FUNCTION_RETURN_TYPE insert_LIST_FUNCTION_NAME  ( const LIST_DATA_TYPE::iterator & list, LIST_ELEMENT_DATA_TYPE element );


     public:

HEADER_LIST_DECLARATIONS_END


HEADER_GLOBAL_START

       // DQ (9/8/2004): Added to support general name qualification
          virtual SgName get_qualified_name() const override;

       // DQ (2/22/2007): Added support for mangled name of SgGlobal to better support generation of
       // mangled names which include the scope! Previously the mangled name of some declarations used
       // the qualified name of the scope which put "::" substrings into the mangled names!  This is
       // inappropriate because the mangled names have to be able to be variable names and must follow
       // C/C++ standards for construction of variable names.
          virtual SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
          virtual bool cfgIsIndexInteresting(unsigned int idx) const override;
          virtual unsigned int cfgIndexForEnd() const override;
#endif

       // DQ (10/1/2009): Adding support for new name qualification.
          void buildStatementNumbering();

HEADER_LIST_DECLARATIONS

     protected:
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

     public:

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_GLOBAL_END


HEADER_BASIC_BLOCK_START

       // DQ (9/8/2004): Added to support general name qualification
          virtual SgName get_qualified_name() const override;

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

       // Special case constructor
          SgBasicBlock ( Sg_File_Info* info = NULL, SgStatement* stmt = NULL );
       // SgBasicBlock ( Sg_File_Info* info);
          SgBasicBlock ( SgStatement* stmt );

HEADER_LIST_DECLARATIONS

       // DQ (6/18/2007): Added these required function declarations explicitly so that we could test
       // removing them from the template where they are generated excessively (and definitions are not
       // implemented).
       // void append_statement (const SgStatementPtrList::iterator& where, SgStatement* what);
       // void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement* what);

       protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;

      public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // void prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what);
       // void append_statement(const SgStatementPtrList::iterator& where, SgStatement *what);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
HEADER_BASIC_BLOCK_END


HEADER_BASIC_BLOCK_POSTDECLARATION_START
// Previous home to StatementListInsertChild() template function , moved to DECLARATION_STATEMENT_POSTDECLARATION
HEADER_BASIC_BLOCK_POSTDECLARATION_END


HEADER_DECLARATION_STATEMENT_POSTDECLARATION_START
// The following template function requires the definition of SgBasicBlock, so
// we put it in the POSTDECLARATION.

#if 1
// DQ (6/15/2019): Renamed function parameter to make code more clear for debugging.
// Note: Rose_STL_Container<Elemtype*> will be either an STL vector of SgStatement* or SgDeclarationStatement*.

// DQ (12/30/2009): This has been moved to the header file since it was a used in
// several places and could not be supported in the source file now that we
// support the generation of smaller and more numerous files by ROSETTA.
// template <class Elemtype> inline bool
// StatementListInsertChild( SgStatement *parent, Rose_STL_Container<Elemtype*>& l,  SgStatement *target,
//                        SgStatement *n, bool inFront, bool extractFromBasicBlock, bool removeCurrent)
template <class Elemtype>
inline bool
StatementListInsertChild( SgStatement *parent, Rose_STL_Container<Elemtype*>& statement_or_declaration_container,  SgStatement *target,
                          SgStatement *n, bool inFront, bool extractFromBasicBlock, bool removeCurrent)
   {
  // DQ (4/3/2012): Simple globally visible function to call (used for debugging in ROSE).
  // void testAstForUniqueNodes ( SgNode* node );

#if 0
     printf ("In StatementListInsertChild: statement_or_declaration_container.size() = %" PRIuPTR " \n",statement_or_declaration_container.size());
     printf ("In StatementListInsertChild: inFront                                   = %s \n",inFront ? "true" : "false");
     printf ("In StatementListInsertChild: parent                                    = %p \n",parent);
     printf ("In StatementListInsertChild: target                                    = %p \n",target);
     printf ("In StatementListInsertChild: n                                         = %p \n",n);
#endif

     ROSE_ASSERT(parent != NULL);
     ROSE_ASSERT(target != NULL);

     bool targetLocated = find(statement_or_declaration_container.begin(),statement_or_declaration_container.end(),target) != statement_or_declaration_container.end();
     if (targetLocated == false)
        {
          printf ("Error: target statement = %p not found in list of statements provided. \n",target);
          ROSE_ASSERT(false);
        }

     unsigned int size = statement_or_declaration_container.size();
     for (unsigned int p = 0; p < size; ++p)
        {
          if ( statement_or_declaration_container[p] == target )
             {
               if (removeCurrent)
                  {
                 // DQ (9/27/2007): Reported as an error by STL debugging mode, fixed as part of move from std::list to std::vector uniformly in ROSE.
                    statement_or_declaration_container.erase(statement_or_declaration_container.begin() + p);
#if 0
                    if (SgProject::get_verbose() >= 1)
                       {
                         printf ("In StatementListInsertChild: test 1: Supress marking parent = %p = %s as isModified \n",parent,parent->class_name().c_str());
                       }
#endif
                 // DQ (4/16/2015): Supress marking parent as isModified (we might want to mark this as containing a transformation).
                 // parent->set_isModified(true);
                  }

               if (!inFront)
                    ++p;
#if 0
            // DQ (12/6/2004): This interfers with the execution of the EDG/Sage III translation!
            // DQ (12/5/2004): There should be a valid scope (set before passing the statement to this function!)
               ROSE_ASSERT(n == NULL || n->get_scope() != NULL);
#endif
#if 0
            // DQ (3/9/2012): Added debugging code for testing test2004_77.C.
               SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(n);
               if (declarationStatement != NULL)
                  {
                    printf ("In Cxx_Grammar.h StatementListInsertChild(): declarationStatement = %p = %s declarationStatement->get_firstNondefiningDeclaration() = %p declarationStatement->get_definingDeclaration() = %p \n",
                         declarationStatement,declarationStatement->class_name().c_str(),declarationStatement->get_firstNondefiningDeclaration(),declarationStatement->get_definingDeclaration());
                  }
#endif

               SgBasicBlock *bn = extractFromBasicBlock? isSgBasicBlock(n) : NULL;
               if (bn == NULL)
                  {
                    assert(n == 0 || dynamic_cast<Elemtype*>(n) != 0);
                    if (n != 0)
                       {
                      // DQ (10/17/2004): We MUST set the parent here, the string based AST rewrite mechanism
                      // requires this semantics. Previously it was removed as part of the movement toward an
                      // initialization of the parent pointers within a post processing phase.  This post-processing
                      // phase was a result of an attempt (successful) to remove side-effects from the set_xxx
                      // access functions generated by ROSETTA.  At some point parents will be be initialized within
                      // the EDG/Sage interface, but we will be more careful how it is done and not reintroduce the
                      // previous side-effects back into the access functions.
#if 0
                      // n->set_parent(parent);
                         printf ("*** WARNING: In Cxx_Grammar.h StatementListInsertChild(): (part 1) parent now set only if already NULL (statement = %p parent = %p statement = %s) \n",n,n->get_parent(),n->class_name().c_str());
                         if (n->get_parent() == NULL)
                            {
                              n->set_parent(parent);
                            }

                      // DQ (3/21/2012): Make sure that it would have been set to the same value.
                         if (parent != n->get_parent())
                            {
                              ROSE_ASSERT(parent != NULL);
                              ROSE_ASSERT(n->get_parent());
                              printf ("parent = %d = %s while n= %p = %s \n",parent,parent->class_name().c_str(),n,n->class_name().c_str());
                              printf ("parent = %d = %s while n->get_parent() = %p = %s \n",parent,parent->class_name().c_str(),n->get_parent(),n->get_parent()->class_name().c_str());
                            }
                         ROSE_ASSERT(parent == n->get_parent());
#else
                      // DQ (3/21/2012): We always want to set the parent based on the structure, sometimes it is built
                      // and initialy defined with a parent based on the scope, since at that point the structural location
                      // for the statement might not be know.  but we update that here and set the parent to match the
                      // structure of the AST (ALWAYS).

                         if (n->get_parent() == NULL)
                            {
#if 0
                              printf ("In Cxx_Grammar.h StatementListInsertChild(): n->get_parent() == NULL for statement = %p = %s it will be set to parent = %p = %s \n",n,n->class_name().c_str(),parent,parent->class_name().c_str());
#endif
                            }
                           else
                            {
                              if (parent != n->get_parent())
                                 {
                                   ROSE_ASSERT(parent != NULL);
                                   ROSE_ASSERT(n->get_parent());
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                                   printf ("In Cxx_Grammar.h StatementListInsertChild(): n->get_parent() != NULL and is set incorrectly to %p = %s for statement = %p = %s it will be set to parent = %p = %s \n",
                                        n,n->class_name().c_str(),n->get_parent(),n->get_parent()->class_name().c_str(),parent,parent->class_name().c_str());
#endif
                                 }
                            }

                         n->set_parent(parent);

#endif
                      // DQ (12/5/2004): Later in the day I discovered that this allows member functions to be defined
                      // as have a scope which is not a class definition (which is an error caught in the unparser!).
                      // So it would be good to make the scope correctly (this could be a start at marking all other
                      // pointers within a new node added by the rewrite system correctly!).  I think the solution is
                      // to set the scope before it gets to this function since this is a general mechanism for inserting
                      // statements and not one which should have such a side-effect as setting or resetting the scope
                      // of statements containing explicit scope pointers.

                      // DQ (6/24/2006): The scope is not explicitly represented and this is not required
                      // ("n->set_scope(parentScope);" was already commented out so this is unused code).

                      // DQ (12/5/2004): If the scope is stored explicitly then we must also set the scope of the new
                      // statement.  But we will not know the scope, so for now derive it structurally (using the parent).
                      // But not all statements have a set_scope function, so see if this one does.
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);

                         if (parentScope == NULL)
                              parentScope = parent->get_scope();

                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         statement_or_declaration_container.insert(statement_or_declaration_container.begin() + p, static_cast<Elemtype*>(n));
#if 0
                         if (SgProject::get_verbose() >= 1)
                            {
                              printf ("In StatementListInsertChild: test 2: Supress marking parent = %p = %s as isModified \n",parent,parent->class_name().c_str());
                            }
#endif
                      // DQ (4/16/2015): Supress marking parent as isModified (we might want to mark this as containing a transformation).
                      // parent->set_isModified(true);

                      // DQ (4/3/2012): Added test to make sure that the pointers are unique.
                      // testAstForUniqueNodes(parentScope);
                       }
                  }
                 else
                  { // extract statements from n ,which is a basic block
                    SgStatementPtrList& nl = bn->get_statements();
                    for (SgStatementPtrList::iterator pp = nl.begin(); pp != nl.end(); ++pp)
                       {
                         SgStatement* stmt = *pp;
                         assert(dynamic_cast<Elemtype*>(stmt) != NULL);

                      // DQ (10/17/2004): We MUST set the parent here, see note in true part of conditional (above).
                      // stmt->set_parent(parent);
                         printf ("*** WARNING: In Cxx_Grammar.h StatementListInsertChild(): (part 2) parent now set only if already NULL n->get_parent() = %p \n",n->get_parent());
                         if (n->get_parent() == NULL)
                            {
                              stmt->set_parent(parent);
                            }

                      // DQ (12/5/2004): We MUST set the scope here, see note in true part of conditional (above).
                         SgScopeStatement* parentScope = isSgScopeStatement(parent);
                         if (parentScope == NULL)
                              parentScope = parent->get_scope();

                      // This is simple error checking
                         ROSE_ASSERT(parentScope != NULL);
                      // n->set_scope(parentScope);

                         statement_or_declaration_container.insert(statement_or_declaration_container.begin() + p, static_cast<Elemtype*>(stmt));
#if 0
                         if (SgProject::get_verbose() >= 1)
                            {
                              printf ("In StatementListInsertChild: test 3: Supress marking parent = %p = %s as isModified \n",parent,parent->class_name().c_str());
                            }
#endif
                      // DQ (4/16/2015): Supress marking parent as isModified (we might want to mark this as containing a transformation).
                      // parent->set_isModified(true);

                      // DQ (4/3/2012): Added test to make sure that the pointers are unique.
                      // testAstForUniqueNodes(parentScope);
                       }
                  }

               return true;
             }
        }

     return false;
   }
#endif

// HEADER_ BASIC_BLOCK_ POSTDECLARATION_END
HEADER_DECLARATION_STATEMENT_POSTDECLARATION_END


HEADER_IF_STATEMENT_START

      protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

      public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_IF_STATEMENT_END

HEADER_FOR_STATEMENT_START

HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): This is now computed at runtime
       // void set_mangled_name();

          $CLASSNAME(SgForInitStatement *, SgStatement *, SgExpression *, SgStatement *);

          SgStatementPtrList & get_init_stmt();
          const SgStatementPtrList & get_init_stmt() const;

       protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

       public:

       // DQ (11/25/2005): Support for previous interface function.
          SgExpression*     get_test_expr () const                                 ROSE_DEPRECATED_FUNCTION;
          void              set_test_expr (SgExpression* expression )              ROSE_DEPRECATED_FUNCTION;
       // SgExpressionRoot* get_test_expr_root () const                            ROSE_DEPRECATED_FUNCTION;
       // void              set_test_expr_root (SgExpressionRoot* expressionRoot ) ROSE_DEPRECATED_FUNCTION;

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FOR_STATEMENT_END


HEADER_FOR_INIT_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
          virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_LIST_DECLARATIONS
HEADER_FOR_INIT_STATEMENT_END

HEADER_FORALL_STATEMENT_START
  //! This class represents forall statements and the Fortran do concurrent construct.
  //
     public:
       // Rasmussen (11/08/2018): Needed because of addition of do-concurrent-stmt
          enum forall_statement_kind_enum
             {
               e_unknown,
               e_forall_statement,
               e_do_concurrent_statement,
               e_last_forall_statement_kind
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_FORALL_STATEMENT_END


HEADER_JOVIAL_FOR_THEN_STATEMENT_START
  //! This class represents the various versions of Jovial loop statements.
  //
     public:
          enum loop_statement_type_enum
             {
               e_unknown,
               e_for_only_stmt,        /* no WHILE, THEN, or BY expressions */
               e_for_while_stmt,       /* WHILE no optional BY or THEN expression */
               e_for_while_by_stmt,    /* WHILE then optional BY (increment expression), C style */
               e_for_while_then_stmt,  /* WHILE then optional THEN */
               e_for_then_while_stmt,  /* THEN (increment expression) then optional WHILE */
               e_for_by_while_stmt     /* BY (increment expression) then optional WHILE */
             };

/*#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif*/
HEADER_JOVIAL_FOR_THEN_STATEMENT_END


HEADER_JOVIAL_COMPOOL_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
      virtual SgName get_mangled_name (void) const override;
#endif
HEADER_JOVIAL_COMPOOL_STATEMENT_END


HEADER_JOVIAL_TABLE_STATEMENT_START
      virtual SgName get_mangled_name (void) const override;

      //! Enum for words-per-entry in a Jovial table
          enum class WordsPerEntry
             {
               e_default = 0,    /*!< words-per-entry is unspecified */
               e_fixed_length,   /*!< fixed-length-entry specified table */
               e_variable_length /*!< variable-length-entry specified table */
             };
HEADER_JOVIAL_TABLE_STATEMENT_END


HEADER_MATLAB_FOR_STATEMENT_START
/*#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif*/
HEADER_MATLAB_FOR_STATEMENT_END


HEADER_RANGE_BASED_FOR_STATEMENT_START

       // void post_construction_initialization() override;

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

     public:
       // DQ (3/28/2018): Get the range variable (target container, name used for unparser).
       // SgInitializedName* range_variable();
       // SgVarRefExp* range_variable_reference();
          SgExpression* range_expression();

HEADER_RANGE_BASED_FOR_STATEMENT_END


HEADER_CATCH_STATEMENT_SEQ_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CATCH_STATEMENT_SEQ_END


HEADER_STATIC_ASSERTION_DECLARATION_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // We need this to be defined to avoid calling the base class version (which is an error).
          SgName get_mangled_name() const override;

          bool hasExplicitScope() const override;

HEADER_STATIC_ASSERTION_DECLARATION_END


HEADER_FUNCTION_PARAMETER_SCOPE_START

// PP (06/01/20)
SgName get_mangled_name() const override;

HEADER_LIST_DECLARATIONS

// Rasmussen (09/24/2020): Finishing implementation of SgFunctionParameterScope for Jovial
  protected:
    virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
    virtual bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;

HEADER_FUNCTION_PARAMETER_SCOPE_END


HEADER_DECLARATION_SCOPE_START

       // DQ (7/19/2017): Adding support for mangled name support for new scope.
          virtual SgName get_mangled_name(void) const override;

       // DQ (7/19/2017): Added to support general name qualification
          virtual SgName get_qualified_name() const override;

HEADER_DECLARATION_SCOPE_END


HEADER_FUNCTION_DECLARATION_STATEMENT_START

      //! Support for C++ covariant return types (used in virtual function overloading).
          SgType* get_orig_return_type() const;

       // Empty declaration substitution
       // void set_mangled_name();
       // SgName get_mangled_name() const override;

       // RV (1/31/2006): Removed dependence on SgUnparse_Info, and made virtual.
          virtual SgName get_mangled_name(void) const override;

       // DQ (4/28/2005): functions that are SgTemplateInstatiationMemberFunctionDecl can be non-template
       // functions in a class that is a template class or a nested class in a templated class, this function
       // identifies the SgTemplateInstatiationMemberFunctionDecl as being a template function if it has
       // template parameters.
          bool isTemplateFunction() const;

          SgInitializedNamePtrList & get_args() ;
          const SgInitializedNamePtrList & get_args() const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_LIST_DECLARATIONS

#if 0
       // DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
       // for example: "template <typename T> class X { X(); }; X<int>::X() {}"

       // DQ (10/20/2004): This function should be different from those that are automatically generated
       // via ROSETTA.  In the case of a constructor or destructor the class name should be used.  This
       // is particularly important in the case of constructors and destructors of templated classes since
       // the mangled form or the template class should not be used since it will not allow the generated
       // code to compile.  Instead of names of the form "ABC____L8" we want names of the form "ABC<int>".
       // These functions are now implemented explicitly instead of being automatically generated via ROSETTA.
          SgName get_name() const;
          void set_name( SgName & functionName );
#endif

          void hasEllipses();

       // DQ (5/3/2005): Added get_qualified_name() function for interface symmetry (and because
       // it makes sense given that the same function can exist in two different namespaces and
       // that only the qualified name would distinguish them).
          virtual SgName get_qualified_name() const;

       // DQ (9/7/2014): Added to support template headers in template declarations (member and non-member function declarations).
          SgName get_template_header() const;

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

     public:  // (see comment above)

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (5/29/2011): Added support for return type name qualification.
      //! This function generates the qualified name prefix to be used with the return type.
          SgName get_qualified_name_prefix_for_return_type() const;

       // DQ (10/11/2014): Adding support for aterm translation to ROSE AST.
       // Rasmussen (04/17/2019): Support for ATerms has been deprecated.
       // static SgFunctionDeclaration* build_node_from_nonlist_children(SgType* return_type, SgFunctionParameterList* parameterList, SgScopeStatement* scope, Sg_File_Info* startOfConstruct, SgName name, SgFunctionType* type, SgFunctionDefinition* definition);

       // DQ (12/22/2014): Adding support for EDG normalized template member and non-member functions.
          bool isNormalizedTemplateFunction() const;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_return_type() const;
          void set_name_qualification_length_for_return_type(int name_qualification_length_for_return_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_return_type() const;
          void set_type_elaboration_required_for_return_type(bool type_elaboration_required_for_return_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_return_type() const;
          void set_global_qualification_required_for_return_type(bool global_qualification_required_for_return_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresNameQualificationOnReturnType () const;
          void set_requiresNameQualificationOnReturnType ( bool requiresNameQualificationOnReturnType );

HEADER_FUNCTION_DECLARATION_STATEMENT_END

HEADER_FUNCTION_PARAMETER_LIST_START
HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FUNCTION_PARAMETER_LIST_END

HEADER_ADA_PARAMETER_LIST_START
HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#if 0
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
#endif /* 0 */

HEADER_ADA_PARAMETER_LIST_END


HEADER_CTOR_INITIALIZER_LIST_START
HEADER_LIST_DECLARATIONS

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
       // MD (7/09/2010): Added virtual CFG methods
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_CTOR_INITIALIZER_LIST_END


HEADER_FUNCTION_DEFINITION_STATEMENT_START

          SgFunctionDeclaration* get_declaration() const;
          void set_declaration(SgFunctionDeclaration* new_val);

          SgFunctionDefinition(Sg_File_Info* f, SgFunctionDeclaration* d, SgBasicBlock* body = 0);
          SgFunctionDefinition(SgFunctionDeclaration* d, SgBasicBlock* body);

          void append_statement  ( SgStatement* what );
          void prepend_statement ( SgStatement* what );

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

        public:

       // RV (2/5/2006): Added name mangling for function definitions
          virtual SgName get_mangled_name (void) const override;

       // DQ (10/5/2006): Added support for storing unique block numbering within functions
       // (cache values in a map instead of recomputing them, this also permits cache invalidation).
          std::map<SgNode*,int> & get_scope_number_list();
          int get_scope_number ( const SgNode* scope ) const;
          void clearScopeNumbers();
          void resetScopeNumbers();

          SgName get_qualified_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // MD (09/20/2010): Accessor for preinitialization lists associated with
       // this (constructor) definition. NULL if this has no such list.
          virtual SgCtorInitializerList* get_CtorInitializerList() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_FUNCTION_DEFINITION_STATEMENT_END


HEADER_MEMBER_FUNCTION_DECLARATION_STATEMENT_START

          bool isDefinedInClass() const;

HEADER_LIST_DECLARATIONS

          virtual SgName get_qualified_name() const override;
          void set_orig_return_type( SgType *);

         SgInitializedNamePtrList & get_ctors();
         const SgInitializedNamePtrList & get_ctors() const;

      protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

     public:

       // DQ (11/16/2004): Added local get_class_scope function to support version of get_scope which would
       // return a SgClassDefinition rather than a SgScopeStatement.  This version is more consistent with
       // the former get_scope() function which is not defined in the base class and must return a
       // SgScopeStatement to be sufficiently general.
       /* \brief This function returns the scope if it exists (is defined in the current translation unit).

          This function is different from the get_scope() member function is that it can return a NULL pointer.
          A NULL pointer indicates that the class definition does not exist (was not defined in the current
          translation unit), this can happen for pointers to member functions only.
        */
          SgScopeStatement* get_class_scope(void) const;

       /* \brief This returns the associated class (even if the class definition is unavailable).

          This is a public function with a special custom implementation that always returns a valid pointer
          to a class declaration even if the get_class_scope() function returns a NULL pointer. This is the
          case for a pointer to a member function (see test2007_116.C).

          \implementation This is much more than a simple access function for the p_associatedClassDeclaration data member.
        */
          SgDeclarationStatement* get_associatedClassDeclaration () const;

      //! This is an access function for the p_associatedClassDeclaration data member.
          void set_associatedClassDeclaration ( SgDeclarationStatement* associatedClassDeclaration );

          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_MEMBER_FUNCTION_DECLARATION_STATEMENT_END


HEADER_VARIABLE_DECLARATION_STATEMENT_START

      /*! \brief GNU extension for declaration modifiers (multiple values may be specified)

          GNU specific declaration modifiers.

          \internal Only one value can be specified.
       */
          enum gnu_extension_declaration_attributes_enum
             {
            // Bit values can support multiple values in a single enum type
               e_gnu_attribute_unknown              = 0, /*!< Unknown value (error) */
               e_gnu_attribute_unspecified          = 1, /*!< Default value */
               e_gnu_attribute__weak__              = 2, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__unused__            = 3, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__deprecated__        = 4, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__nocommon__          = 5, /*!< GNU specific attribute for (GNU extension) */
               e_gnu_attribute__transparent_union__ = 6, /*!< GNU specific attribute for (GNU extension) */
               e_last_gnu_declaration_attribute /*!< last gnu declaration attribute value (upper bound on range of values, used in error checking) */
             };

       // Special constructor (not generated, I don't know why this is here)
       // SgVariableDeclaration (Sg_File_Info*, const SgName &, SgType*, SgInitializer*);

       // Special constructor
       // SgVariableDeclaration (Sg_File_Info *info, const SgName& var_name,
       //                     SgType *type, SgInitializer *initializer = NULL );
          SgVariableDeclaration ( Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer = NULL );
          SgVariableDeclaration ( const SgName& var_name, SgType *type, SgInitializer *initializer );

       // DQ (11/10/2006): This function is called by the custom written constructors (refactored code to simplify their implementation).
          void initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer);

       // DQ (7/18/2012): New constructors and initializations to support building a SgVariableDeclaration from an existing SgInitializedName
          SgVariableDeclaration( Sg_File_Info *info, SgInitializedName* c_item );
          SgVariableDeclaration( SgInitializedName* c_item );
          void initializeData(Sg_File_Info *info, SgInitializedName* c_item);

          void setDeclarationOnly() ROSE_DEPRECATED_FUNCTION;
          void setExtern() override ROSE_DEPRECATED_FUNCTION;
          void setStatic() override ROSE_DEPRECATED_FUNCTION;
          SgVariableDefinition *get_definition( SgInitializedName* ditem = 0 );
          SgInitializedName *get_decl_item(const SgName&);
       // SgInitializedName *get_defn_item(const SgName&);

       // DQ (1/20/2014): This must be a SgValueExp, it is a constant expression ROSE uses a SgValueExp for this).
       // SgUnsignedLongVal *get_bitfield();
       // void set_bitfield (SgUnsignedLongVal*);
          SgExpression* get_bitfield();
          void set_bitfield (SgExpression*);

       // Only on the first variable declaration's
          int reset_initializer(SgInitializer *);

       // void printVariableName(int);
       // void printVariables(SgUnparse_Info&, ostream& os=cout);

          SgStatement *get_next(int &) const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // DQ (6/1/2006): Get the type (base type if more than one variable) used for all variables in this variable declaration.
       // SgType *get_type();

       // DQ (7/19/2005): SgVariableDeclaration should have a structural definition of its scope (based on position in
       // source code) while the variables declared should (and do) have a possibly different scope (via name qualification).
       // DQ (7/4/2005): implement get_scope to query the initialized names in the initialized name list (SgInitializedNamePtrList)
       // without this function we evaluate the scope using a traversal of the parents!
       // SgScopeStatement* get_scope(void) const;

// HEADER_LIST_DECLARATIONS
     public:
#if 0
          SgInitializedNamePtrList::iterator append_variable  ( const SgInitializedName & what, SgInitializer* init );
          SgInitializedNamePtrList::iterator prepend_variable ( const SgInitializedName & what, SgInitializer* init );
          SgInitializedNamePtrList::iterator insert_variable  ( const SgInitializedNamePtrList::iterator & where, const SgInitializedName & what );
#else
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          void append_variable  ( SgInitializedName* what, SgInitializer* init );
          void prepend_variable ( SgInitializedName* what, SgInitializer* init );
          // void insert_variable  ( const SgInitializedNamePtrList::iterator & where, SgInitializedName* what );
#endif

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      //! Returns the defining declaration if get_variableDeclarationContainsBaseTypeDefiningDeclaration() is true, otherwise NULL.
          SgDeclarationStatement* get_baseTypeDefiningDeclaration() const;
          void set_baseTypeDefiningDeclaration(SgDeclarationStatement* d);

#if 0
       // This is now stored in the type modifier (I think this is a better implementation)

       // DQ (11/18/2007): Support for Fortran declaration attributes
       /* Fortran Specific Declaration Attributes
               e_unknown_attribute_spec,
               e_accessStatement,
               e_allocatableStatement,
               e_asynchronousStatement,
               e_bindStatement,
               e_dataStatement,
               e_dimensionStatement,
               e_externalStatement,
               e_intentStatement,
               e_intrinsicStatement,
               e_optionalStatement,
               e_parameterStatement,
               e_pointerStatement,
               e_protectedStatement,
               e_saveStatement,
               e_targetStatement,
               e_valueStatement,
               e_volatileStatement,
               e_last_attribute_spec
        */

       // Notes:
       //      access_x_Statement could be mapped to C++ access specifiers
       //      bind is more complex than just using a flag here
       //      dimension details are specified within the SgArrayType, the flag here indicates that it was used in the variable declaration explicitly.

          bool testAccess_private_Attribute() const;
          void setAccess_private_Attribute();
          void unsetAccess_private_Attribute();

          bool testAccess_protected_Attribute() const;
          void setAccess_protected_Attribute();
          void unsetAccess_protected_Attribute();

          bool testAccess_public_Attribute() const;
          void setAccess_public_Attribute();
          void unsetAccess_public_Attribute();

          bool testAllocatableAttribute() const;
          void setAllocatableAttribute();
          void unsetAllocatableAttribute();

          bool testAsynchronousAttribute() const;
          void setAsynchronousAttribute();
          void unsetAsynchronousAttribute();

          bool testBindAttribute() const;
          void setBindAttribute();
          void unsetBindAttribute();

          bool testDataAttribute() const;
          void setDataAttribute();
          void unsetDataAttribute();

          bool testDimensionAttribute() const;
          void setDimensionAttribute();
          void unsetDimensionAttribute();

          bool testExternalAttribute() const;
          void setExternalAttribute();
          void unsetExternalAttribute();

          bool testIntent_in_Attribute() const;
          void setIntent_in_Attribute();
          void unsetIntent_in_Attribute();

          bool testIntent_out_Attribute() const;
          void setIntent_out_Attribute();
          void unsetIntent_out_Attribute();

          bool testIntent_inout_Attribute() const;
          void setIntent_inout_Attribute();
          void unsetIntent_inout_Attribute();

          bool testIntrinsicAttribute() const;
          void setIntrinsicAttribute();
          void unsetIntrinsicAttribute();

          bool testOptionalAttribute() const;
          void setOptionalAttribute();
          void unsetOptionalAttribute();

          bool testParameterAttribute() const;
          void setParameterAttribute();
          void unsetParameterAttribute();

          bool testPointerAttribute() const;
          void setPointerAttribute();
          void unsetPointerAttribute();

          bool testProtectedAttribute() const;
          void setProtectedAttribute();
          void unsetProtectedAttribute();

          bool testSaveAttribute() const;
          void setSaveAttribute();
          void unsetSaveAttribute();

          bool testTargetAttribute() const;
          void setTargetAttribute();
          void unsetTargetAttribute();

          bool testValueAttribute() const;
          void setValueAttribute();
          void unsetValueAttribute();

          bool testVolatileAttribute() const;
          void setVolatileAttribute();
          void unsetVolatileAttribute();
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType () const;
          void set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType );

  // DQ (12/21/2011): Modified to support SgTemplateVariableDeclaration to use this function.
  // private:
     protected:
       // GB (09/25/2007): Added this function as part of the traversal island fix.
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;

HEADER_VARIABLE_DECLARATION_STATEMENT_END


HEADER_VARIABLE_DEFINITION_STATEMENT_START
       // SgInitializedName *get_defn_item();
       // SgInitializedName *get_decl_item();
      //  void set_initializer(SgInitializer *);

          SgVariableDeclaration *get_declaration();

          SgType *get_type();

       // Special constructor used by SgVariableDefinition
          SgVariableDefinition( Sg_File_Info *info, SgInitializedName *decl_item, SgInitializer *initializer);
          SgVariableDefinition( SgInitializedName *decl_item, SgInitializer *initializer);

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

HEADER_VARIABLE_DEFINITION_STATEMENT_END


HEADER_CLASS_DECLARATION_STATEMENT_START

      /*! A declaration can be of either class, struct, union, or ... */
          enum class_types
             {
               e_class,              /*!< class declaration (default) */
               e_struct,             /*!< struct declaration */
               e_union,              /*!< union declaration */
               e_template_parameter, /*!< type parameter in a template declaration */
               e_fortran_module,     /*!< A Fortran module declaration */
               e_java_interface,     /*!< A Java interface type declaration */
               e_java_enum,          /*!< A Java enum type declaration */
               e_java_parameter,     /*!< A Java parameter type declaration */
               e_jovial_block,       /*!< A Jovial block type declaration */
               e_jovial_table        /*!< A Jovial table type declaration */
             };

          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added this mangler to replace 'get_mangled_qualified_name'
          virtual SgName get_mangled_name (void) const override;

      //! \deprecated by RV (1/31/2006)
          SgName get_mangled_qualified_name(int & cnt );

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

     public:

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/10/2007): I think this should have been marked virtual
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

     protected:
       // GB (09/26/2007): Added this function as part of the move to index-based traversals.
          SgClassDefinition *compute_classDefinition() const;

HEADER_CLASS_DECLARATION_STATEMENT_END


HEADER_CLASS_DEFINITION_STATEMENT_START

HEADER_LIST_DECLARATIONS_1

HEADER_LIST_DECLARATIONS_2

          virtual SgName get_qualified_name() const override;

       // RV (1/31/2006): Added this mangler to replace 'get_mangled_qualified_name'
          virtual SgName get_mangled_name (void) const override;

      //! \deprecated
          SgName get_mangled_qualified_name(int& i);

          protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
          virtual bool insert_child( SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;

        public:

          SgClassDeclaration* get_declaration() const;
          void set_declaration(SgClassDeclaration* new_val);

          SgClassDefinition( Sg_File_Info *f, SgClassDeclaration* d);
          SgClassDefinition( SgClassDeclaration* d);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CLASS_DEFINITION_STATEMENT_END

HEADER_STMT_DECLARATION_STATEMENT_START
          virtual SgName get_mangled_name (void) const override;
HEADER_STMT_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_START

       // DQ (3/18/2004): Generate template name with arguments
       //                 overrides base class implementation.
       // SgName get_name () const;

       // DQ (9/8/2004): overrides base class implementation
          virtual SgName get_qualified_name() const override;

          SgTemplateInstantiationDefn( Sg_File_Info *f, SgTemplateInstantiationDecl* d);
          SgTemplateInstantiationDefn( SgTemplateInstantiationDecl* d);

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/31/2012): Added to support mangled name testing (at least).
          virtual SgName get_mangled_name(void) const override;

HEADER_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_END


HEADER_ENUM_DECLARATION_STATEMENT_START
HEADER_LIST_DECLARATIONS

     public:
       // DQ (10/15/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Implemented mangler for enum declarations.
          virtual SgName get_mangled_name (void) const override;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

       // DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/18/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (2/14/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (2/14/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (2/14/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

HEADER_ENUM_DECLARATION_STATEMENT_END


HEADER_EXPRESSION_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (12/6/2006): Added to support general replace functions.
          int replace_expression(SgExpression *,SgExpression *) override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_EXPRESSION_STATEMENT_END


HEADER_LABEL_STATEMENT_START

      /*! Type of a label statement. */
          enum label_type_enum
             {
               e_default = 0,
               e_jovial_label_decl,    /*!<     LABEL name */
               e_jovial_label_def,     /*!< DEF LABEL name */
               e_jovial_label_ref      /*!< REF LABEL name */
             };


     // DQ (1/15/2018): Need to support this member function now that we traverse the statement of the label statement.
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

        public:

       // DQ (10/20/2004): This is not part of a uniform interface for all statements
       // so it is not a particularly useful interface within a minimalist design.
       // Thus I have deprecated this function, users should use the get_label()
       // function instead.
          SgName get_name() const ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
       // DQ (1/7/2018): Fix this to reflect design change in AST required to represent labels as compound statements.
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;

          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

       // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
       // template low-level symbol table support function would compile cleanly.  Note that it is an error to
       // call this function and it is not a virtual function that will cause derived class versions to be called
       // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).
          SgType* get_type() const;

HEADER_LABEL_STATEMENT_END


HEADER_JAVA_LABEL_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int idx) const override;
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

// CAVE3 (09/30/2011): Not sure what we need to fixup for java label
/*
#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
*/
      // charles4: 09/13/2011 added to support Java (DQ (2/10/2007): Marked as virtual to be consistent)
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
       // template low-level symbol table support function would compile cleanly.  Note that it is an error to
       // call this function and it is not a virtual function that will cause derived class versions to be called
       // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).
          SgType* get_type() const;

HEADER_JAVA_LABEL_STATEMENT_END


HEADER_WITH_STATEMENT_START
HEADER_WITH_STATEMENT_END

HEADER_WHILE_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgIndexForEnd() const override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_WHILE_STATEMENT_END


HEADER_DO_WHILE_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

         public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_DO_WHILE_STATEMENT_END


HEADER_SWITCH_STATEMENT_START

// HEADER_LIST_DECLARATIONS

          void prepend_case(SgCaseOptionStmt *&);
          void append_case(SgCaseOptionStmt *&);
          void prepend_default(SgDefaultOptionStmt *&);
          void append_default(SgDefaultOptionStmt *&);

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
          void prepend_append_normalization();
        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_SWITCH_STATEMENT_END


HEADER_CASE_OPTION_STATEMENT_START
        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CASE_OPTION_STATEMENT_END

HEADER_ASYNC_STATEMENT_START
HEADER_ASYNC_STATEMENT_END

HEADER_FINISH_STATEMENT_START
HEADER_FINISH_STATEMENT_END

HEADER_AT_STATEMENT_START
HEADER_AT_STATEMENT_END

HEADER_ATOMIC_STATEMENT_START
HEADER_ATOMIC_STATEMENT_END

HEADER_WHEN_STATEMENT_START
HEADER_WHEN_STATEMENT_END


HEADER_TRY_STATEMENT_START

          SgStatementPtrList & get_catch_statement_seq();
          const SgStatementPtrList & get_catch_statement_seq() const;

HEADER_LIST_DECLARATIONS

#if 0
          SgStatement *get_next (int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

         public:
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TRY_STATEMENT_END


HEADER_CATCH_OPTION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

       // DQ (2/22/2007): Added mangled name support for scopes so that the
       // mangled names for declarations could have better support!
          virtual SgName get_mangled_name() const override;

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

         public:
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_CATCH_OPTION_STATEMENT_END


HEADER_DEFAULT_OPTION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement* get_next(int&) const;
#endif

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/20/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_DEFAULT_OPTION_STATEMENT_END


HEADER_BREAK_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_BREAK_STATEMENT_END


HEADER_CONTINUE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_CONTINUE_STATEMENT_END


HEADER_FORTRAN_CONTINUE_STATEMENT_START
HEADER_FORTRAN_CONTINUE_STATEMENT_END


HEADER_RETURN_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

       // get lvalue
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL
HEADER_RETURN_STATEMENT_END


HEADER_GOTO_STATEMENT_START
       // void post_construction_initialization();

        protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_GOTO_STATEMENT_END

HEADER_ADA_EXIT_STATEMENT_START
       // void post_construction_initialization();

        protected:
          virtual bool replace_child(SgStatement*, SgStatement*, bool extractListFromBasicBlock = false) override;
          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_ADA_EXIT_STATEMENT_END

HEADER_ADA_DELAY_STATEMENT_START
       // void post_construction_initialization();

        protected:
          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_ADA_DELAY_STATEMENT_END

HEADER_ADA_LOOP_STATEMENT_START
       // void post_construction_initialization();

        protected:
          virtual bool replace_child(SgStatement*, SgStatement*, bool extractListFromBasicBlock = false) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_ADA_LOOP_STATEMENT_END

HEADER_ADA_ACCEPT_STATEMENT_START
       // void post_construction_initialization();

        protected:
          virtual bool replace_child(SgStatement*, SgStatement*, bool extractListFromBasicBlock = false) override;
          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

        public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_ADA_ACCEPT_STATEMENT_END


HEADER_PYTHON_GLOBAL_STMT_START
HEADER_LIST_DECLARATIONS
HEADER_PYTHON_GLOBAL_STMT_END

HEADER_PYTHON_PRINT_STMT_START
HEADER_PYTHON_PRINT_STMT_END

HEADER_ASM_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
       // DQ (7/26/2006): Need a type for the list of registers used in the clobber list
          typedef std::vector<SgInitializedName::asm_register_name_enum> AsmRegisterNameList;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // DQ (7/22/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
          SgExpressionPtrList& get_operands();
          const SgExpressionPtrList& get_operands() const;

       // DQ (7/27/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
          AsmRegisterNameList& get_clobberRegisterList();
          const AsmRegisterNameList& get_clobberRegisterList() const;

HEADER_ASM_STATEMENT_END


HEADER_SPAWN_STATEMENT_START

HEADER_SPAWN_STATEMENT_END


HEADER_JAVA_THROW_STATEMENT_START

HEADER_JAVA_THROW_STATEMENT_END


HEADER_JAVA_FOREACH_STATEMENT_START

       public:
       // charles4 (9/07/2011): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int idx) const override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_JAVA_FOREACH_STATEMENT_END


HEADER_JAVA_SYNCHRONIZED_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_JAVA_SYNCHRONIZED_STATEMENT_END


HEADER_ASSERT_STMT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ASSERT_STMT_END


HEADER_NULL_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_NULL_STATEMENT_END

HEADER_PASS_STATEMENT_START
HEADER_PASS_STATEMENT_END

HEADER_EXEC_STATEMENT_START
HEADER_EXEC_STATEMENT_END

HEADER_VARIANT_STATEMENT_START

HEADER_VARIANT_STATEMENT_END


HEADER_TYPEDEF_DECLARATION_STATEMENT_START
       // void post_construction_initialization();
#if 0
          SgStatement *get_next(int&) const;
#endif

     protected:
          virtual bool replace_child(SgStatement *,SgStatement *,bool extractListFromBasicBlock = false) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

     public:
       // DQ (10/15/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added this mangler for typedef declarations.
          virtual SgName get_mangled_name (void) const override;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

      //! Returns the defining declaration if get_typedefBaseTypeContainsDefiningDeclaration() is true, otherwise NULL. Also same as get_declaration().
          SgDeclarationStatement* get_baseTypeDefiningDeclaration() const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/14/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the base type of the typedef declaration.
          SgName get_qualified_name_prefix_for_base_type() const;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_base_type() const;
          void set_name_qualification_length_for_base_type(int name_qualification_length_for_base_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_base_type() const;
          void set_type_elaboration_required_for_base_type(bool type_elaboration_required_for_base_type);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_base_type() const;
          void set_global_qualification_required_for_base_type(bool global_qualification_required_for_base_type);

       // DQ (4/10/2019): These are added to support when the the base type is a SgMemberPointer (which van have name qualification in two locations).
       // DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (4/10/2019): These are added to support when the the base type is a SgMemberPointer (which van have name qualification in two locations).
       // DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (4/10/2019): These are added to support when the the base type is a SgMemberPointer (which van have name qualification in two locations).
       // DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

     private:
       // GB (09/25/2007): Added this function as part of the traversal island fix.
      //! Internal support for the traversal mechanism.
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;

HEADER_TYPEDEF_DECLARATION_STATEMENT_END

HEADER_NONREAL_DECL_START

          SgName get_name (void) const;
          void set_name (SgName name);

          SgNonrealType* get_type (void) const;
          void set_type (SgNonrealType* t);

          SgName get_mangled_name (void) const override;

          virtual SgSymbol* get_symbol_from_symbol_table() const override;
          SgName get_qualified_name() const;

HEADER_NONREAL_DECL_END

HEADER_TEMPLATE_DECLARATION_STATEMENT_START
       // void post_construction_initialization();

      /*! Type of template declaration */
          enum template_type_enum
             {
               e_template_none       = 0, /*!< error value */
               e_template_class      = 1, /*!< class template */
               e_template_m_class    = 2, /*!< nested class template */
               e_template_function   = 3, /*!< function template */
               e_template_m_function = 4, /*!< member function template */
               e_template_m_data     = 5  /*!< member data template (typically static member data) */
             };

       // DQ (9/8/2004): added support for qualified names
          virtual SgName get_qualified_name() const;

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // This is generated by ROSETTA, though we might want to implement
       // it differently if we want to get the name from the declaration!
       // SgName get_name() const;

      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // DQ (12/12/2011): Explicit access function.
          SgType* get_type();

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_DECLARATION_STATEMENT_END


HEADER_TEMPLATE_CLASS_DECLARATION_STATEMENT_START

          typedef SgTemplateInstantiationDecl instantiation_kind_t;

      /*! A template declaration can be of either class, struct, or union */
          enum class_types
             {
               e_class,             /*!< class declaration (default) */
               e_struct,            /*!< struct declaration */
               e_union,             /*!< union declaration */
               e_template_parameter /*!< type parameter in a template declaration */
             };

// DQ (9/26/2012): We can't use these macros in the header files else they would require the rose_config.h
// file to be defined for all user source code (which we can't allow for portability reasons).
       // DQ (9/10/2012): Added general name mangling for new template class declaration IR node.
          virtual SgName get_mangled_name(void) const override;

HEADER_TEMPLATE_CLASS_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_FUNCTION_DECLARATION_STATEMENT_START

          typedef SgTemplateInstantiationFunctionDecl instantiation_kind_t;

HEADER_TEMPLATE_FUNCTION_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT_START

          typedef SgTemplateInstantiationMemberFunctionDecl instantiation_kind_t;

HEADER_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_CLASS_DEFINITION_STATEMENT_START

     public:
          SgTemplateClassDeclaration* get_declaration() const;
          void set_declaration(SgTemplateClassDeclaration* new_val);

          SgName get_qualified_name() const override;
          SgName get_mangled_name (void) const override;
          SgName get_mangled_qualified_name (int& i);

       // DQ (11/19/2011): Added constructor to match SgClassDefinition API.
          SgTemplateClassDefinition( SgTemplateClassDeclaration *decl);

HEADER_TEMPLATE_CLASS_DEFINITION_STATEMENT_END

HEADER_TEMPLATE_FUNCTION_DEFINITION_STATEMENT_START

       // DQ (12/1/2011): Adding support for template declarations in the AST.
          SgTemplateFunctionDefinition(Sg_File_Info* f, SgTemplateFunctionDeclaration* d, SgBasicBlock* body = 0);
          SgTemplateFunctionDefinition(SgTemplateFunctionDeclaration* d, SgBasicBlock* body);

          SgTemplateFunctionDeclaration* get_declaration() const;
          void set_declaration(SgTemplateFunctionDeclaration* new_val);

          virtual SgName get_mangled_name (void) const override;

HEADER_TEMPLATE_FUNCTION_DEFINITION_STATEMENT_END




HEADER_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_START

          typedef SgTemplateClassDeclaration template_kind_t;

       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

          virtual SgName get_qualified_name () const override;

       // RV (1/31/2006): Added mangler for template instantiation declarations.
          virtual SgName get_mangled_name (void) const override;

       // DQ (9/23/2004): Added function to hide base class interface so that we would only set the
       // definition for a template instantiation declaration using a template instantiation definition.
       // At a later point the template instantiation definition will contain more information specific
       // to it being a part of a template.
          void set_definition( SgTemplateInstantiationDefn* definition );

       // DQ (10/10/2014): Implemented to support Aterm constructor functions.
       // Rasmussen (04/17/2019): Support for ATerms has been deprecated. But this may be used elsewhere.
          void set_definition( SgClassDefinition* definition );

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (11/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_END


HEADER_TEMPLATE_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_START

          typedef SgTemplateFunctionDeclaration template_kind_t;

       // DQ (2/15/2005): Added resetTemplateName function to handle templated functions
       // DQ (5/8/2004): Not clear that this is useful for function name which
       //                don't include the Template parameters in the name.
       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

       // RV (1/31/2006): Added mangler for template function instantiations.
          virtual SgName get_mangled_name (void) const override;

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (11/27/2011): Adding support for uniform interface to support template build interface.
          SgTemplateInstantiationFunctionDecl ( SgName name, SgFunctionType* type, SgFunctionDefinition* definition);

HEADER_TEMPLATE_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_MEMBER_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_START

          typedef SgTemplateMemberFunctionDeclaration template_kind_t;

       // DQ (2/15/2005): Added resetTemplateName function to handle templated member functions
       // DQ (5/8/2004): Not clear that this is useful for function name which
       //                don't include the Template parameters in the name.
       // DQ (3/21/2004): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();
       // SgName get_name () const;
       // void set_name (SgName name);

       // RV (1/31/2006): Added mangler for template member function instantiations.
      //! Returns a mangled name.
          virtual SgName get_mangled_name (void) const override;

       // DQ (2/11/2007): Add this to the derived class so that the SgSymbolTable::find() function will work properly
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (11/6/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (11/27/2011): Adding support for uniform interface to support template build interface.
          SgTemplateInstantiationMemberFunctionDecl ( SgName name, SgFunctionType* type, SgFunctionDefinition* definition);

HEADER_TEMPLATE_MEMBER_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT_END


HEADER_TEMPLATE_VARIABLE_DECLARATION_STATEMENT_START
          typedef SgTemplateVariableInstantiation instantiation_kind_t;
          $CLASSNAME ( const SgName& var_name, SgType *type, SgInitializer *initializer );
     private:
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;
HEADER_TEMPLATE_VARIABLE_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_VARIABLE_INSTANTIATION_STATEMENT_START
          typedef SgTemplateVariableDeclaration template_kind_t;
          $CLASSNAME ( const SgName& var_name, SgType *type, SgInitializer *initializer );
     private:
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;
HEADER_TEMPLATE_VARIABLE_INSTANTIATION_STATEMENT_END


HEADER_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT_START

          typedef SgTemplateInstantiationTypedefDeclaration instantiation_kind_t;

       // DQ (12/28/2011): We need a constructor similar to the base class.
       // $CLASSNAME ( const SgName& var_name, SgType *type, SgInitializer *initializer );
// BH (11/13/2015) on windows this caused incosistent defines of this
// so that it was not defined in the .h but used in the cxx file
     private:
       // DQ (12/29/2011): This is added to support backward compatability.
          SgDeclarationStatement *compute_baseTypeDefiningDeclaration() const;

       // DQ (2/25/2018): This appears to be built as a function prototype by default, so I think we don't need this here (redundant).
       // DQ (2/25/2018): Added a specific version of the post_construction_initialization() function
       // to allow it to be run after the SgTypedefDeclaration::post_construction_initialization() function.
       // void post_construction_initialization();

HEADER_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT_END


HEADER_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT_START

          typedef SgTemplateTypedefDeclaration template_kind_t;

       // DQ (2/26/2018): get_name assembles the full template name with arguments (e.g. "ABC<int>")
          void resetTemplateName();

       // DQ (2/28/2018): Added function
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // PP (7/29/2025): Added function
          SgName get_mangled_name() const override;

HEADER_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT_END


HEADER_PRAGMA_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_PRAGMA_STATEMENT_END


HEADER_EMPTY_DECLARATION_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (11/24/2020): Adding support for explicit scope to be false.
          virtual bool hasExplicitScope() const override;

HEADER_EMPTY_DECLARATION_END


HEADER_NAMESPACE_DECLARATION_STATEMENT_START

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const;

       // RV (1/31/2006): Added mangler for namespace declarations.
          virtual SgName get_mangled_name (void) const override;

#if 0
       // Wrong, this should be structural and not explicitly stored
       // DQ (2/19/2006): The scope needs to be stored explicitly so that we can reference a single scope
       // (that of the first declaration, referenced from the firstNondefiningDeclaration()  member function,
       // instead of all the possible different scopes that could be referenced.  Ths allows simple rules
       // to be applied to all IR SgDeclaration IR nodes and makes for better testing.  The parent pointer
       // maintains the source code structural relationships, which the scope represents the semantic
       // relationships.
      //! Support for where the scope is explicitly required
          virtual bool hasExplicitScope() const override;
#endif

       // DQ (2/10/2007): Marked as virtual to be consistent
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // DQ (6/5/2007): Since namespaces are re-entrant we define a simple function to test if two namespaces
       // are the same (not the same SgNamespaceDeclarationStatement, but the same namespace).
      //! Check if two namespaces are the same
          bool isSameNamespace( const SgNamespaceDeclarationStatement* n ) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_NAMESPACE_DECLARATION_STATEMENT_END

HEADER_NAMESPACE_DEFINITION_STATEMENT_START

       // DQ (9/8/2004): Added to support qualified name generation
          virtual SgName get_qualified_name() const override;

       // RV (1/31/2006): Added mangler for namespace definitions.
          virtual SgName get_mangled_name (void) const override;

      //! Compare if to namespaces are the same namespace (may be different scopes).
          bool isSameNamespace(const SgNamespaceDefinitionStatement* n ) const;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/19/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif
       // DQ (5/9/2013): Added functions to generate index into total number of reentrant namespaces.
          size_t namespaceIndex() const;
          size_t numberOfNamespaceDefinitions() const;

#if 0
       // DQ (5/16/2013): This is now a seperate data member access function (to a specially constructed
       // SgNamespaceDefinitionStatement used to hold the SgAliasSymbols that are the union of those across
       // all of the many re-entrant namespace definitions.
       // DQ (5/9/2013): Added function to return a single associated scope for all declaration in the multiple namespace definitions.
          SgNamespaceDefinitionStatement* get_global_definition() const;
#endif

     protected:
          virtual bool replace_child ( SgStatement *,SgStatement *, bool extractListFromBasicBlock = false ) override;
          virtual bool insert_child ( SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false ) override;

HEADER_LIST_DECLARATIONS

HEADER_NAMESPACE_DEFINITION_STATEMENT_END

HEADER_NAMESPACE_ALIAS_DECLARATION_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // DQ (8/30/2009): Added namespace alias support.
          virtual SgSymbol* get_symbol_from_symbol_table() const override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

HEADER_NAMESPACE_ALIAS_DECLARATION_STATEMENT_END

HEADER_USING_DIRECTIVE_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

HEADER_USING_DIRECTIVE_STATEMENT_END

HEADER_USING_DECLARATION_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

// DQ (7/21/2005): The using declaration can reference either a SgDeclarationStatement or a SgInitializedName
// object thus we need a single more general function to return whatever it is.  Maybe not!

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const;
          void set_name_qualification_length(int name_qualification_length);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const;
          void set_type_elaboration_required(bool type_elaboration_required);

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const;
          void set_global_qualification_required(bool global_qualification_required);

HEADER_USING_DECLARATION_STATEMENT_END

HEADER_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_START

       // DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
          virtual SgName get_mangled_name(void) const override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (10/15/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

HEADER_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_END

HEADER_ADA_PACKAGE_SPEC_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
bool hasExplicitScope() const override;
HEADER_ADA_PACKAGE_SPEC_DECL_STATEMENT_END

HEADER_ADA_PACKAGE_BODY_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
bool hasExplicitScope() const override;
HEADER_ADA_PACKAGE_BODY_DECL_STATEMENT_END

HEADER_ADA_PACKAGE_SPEC_STATEMENT_START
  SgName get_mangled_name() const override;
  SgName get_qualified_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_PACKAGE_SPEC_STATEMENT_END

HEADER_ADA_PACKAGE_BODY_STATEMENT_START
  SgName get_mangled_name() const override;
  SgName get_qualified_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_PACKAGE_BODY_STATEMENT_END

HEADER_ADA_GENERIC_DECL_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
bool hasExplicitScope() const override;
HEADER_ADA_GENERIC_DECL_END

HEADER_ADA_GENERIC_INSTANCE_DECL_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
bool hasExplicitScope() const override;
HEADER_ADA_GENERIC_INSTANCE_DECL_END

HEADER_ADA_FORMAL_TYPE_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
bool hasExplicitScope() const override;
HEADER_ADA_FORMAL_TYPE_DECL_STATEMENT_END

HEADER_ADA_FORMAL_PACKAGE_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
SgName get_qualified_name() const;
HEADER_ADA_FORMAL_PACKAGE_DECL_STATEMENT_END

HEADER_ADA_GENERIC_DEFN_START
  SgName get_mangled_name() const override;
  SgName get_qualified_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_GENERIC_DEFN_END

HEADER_ADA_TASK_SPEC_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
HEADER_ADA_TASK_SPEC_DECL_STATEMENT_END

HEADER_ADA_PROTECTED_SPEC_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
HEADER_ADA_PROTECTED_SPEC_DECL_STATEMENT_END

HEADER_ADA_TASK_TYPE_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
bool hasExplicitScope() const override;
HEADER_ADA_TASK_TYPE_DECL_STATEMENT_END

HEADER_ADA_PROTECTED_TYPE_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
bool hasExplicitScope() const override;
HEADER_ADA_PROTECTED_TYPE_DECL_STATEMENT_END

HEADER_ADA_TASK_BODY_DECL_STATEMENT_START
  SgSymbol* get_symbol_from_symbol_table() const override;
  SgName get_mangled_name() const override;
  void set_scope(SgScopeStatement*) override;
  SgScopeStatement* get_scope() const override;
HEADER_ADA_TASK_BODY_DECL_STATEMENT_END

HEADER_ADA_PROTECTED_BODY_DECL_STATEMENT_START
  SgSymbol* get_symbol_from_symbol_table() const override;
  SgName get_mangled_name() const override;
  void set_scope(SgScopeStatement*) override;
  SgScopeStatement* get_scope() const override;
HEADER_ADA_PROTECTED_BODY_DECL_STATEMENT_END

HEADER_ADA_TASK_SPEC_STATEMENT_START
  SgName get_mangled_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_TASK_SPEC_STATEMENT_END

HEADER_ADA_PROTECTED_SPEC_STATEMENT_START
  SgName get_mangled_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_PROTECTED_SPEC_STATEMENT_END

HEADER_ADA_TASK_BODY_STATEMENT_START
  SgName get_mangled_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_TASK_BODY_STATEMENT_END

HEADER_ADA_PROTECTED_BODY_STATEMENT_START
  SgName get_mangled_name() const override;
protected:
  bool insert_child(SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false) override;
  bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;
HEADER_ADA_PROTECTED_BODY_STATEMENT_END

HEADER_ADA_SELECT_STATEMENT_START
     public:
       enum select_type_enum
         {
           e_unknown,
           e_selective_accept,
           e_asynchronous,
           e_conditional_entry,
           e_timed_entry
         };
HEADER_ADA_SELECT_STATEMENT_END

HEADER_ADA_SELECT_ALTERNATIVE_STATEMENT_START
HEADER_ADA_SELECT_ALTERNATIVE_STATEMENT_END

HEADER_ADA_TERMINATE_STATEMENT_START
HEADER_ADA_TERMINATE_STATEMENT_END

HEADER_ADA_UNSCOPED_BLOCK_START
HEADER_LIST_DECLARATIONS
HEADER_ADA_UNSCOPED_BLOCK_END

HEADER_ADA_VARIANT_WHEN_STMT_START
HEADER_ADA_VARIANT_WHEN_STMT_END

HEADER_ADA_RENAMING_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
HEADER_ADA_RENAMING_DECL_STATEMENT_END

HEADER_ADA_VARIANT_DECL_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
HEADER_ADA_VARIANT_DECL_END

HEADER_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT_START
SgSymbol* get_symbol_from_symbol_table() const override;
SgName get_mangled_name() const override;
HEADER_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT_END

HEADER_ADA_RECORD_REPRESENTATION_CLAUSE_START

// HEADER_LIST_DECLARATIONS

SgName get_mangled_name() const override;

HEADER_ADA_RECORD_REPRESENTATION_CLAUSE_END

HEADER_ADA_COMPONENT_CLAUSE_START
SgName get_mangled_name() const override;
HEADER_ADA_COMPONENT_CLAUSE_END

HEADER_ADA_ATTRIBUTE_CLAUSE_START
SgName get_mangled_name() const override;
HEADER_ADA_ATTRIBUTE_CLAUSE_END


HEADER_PROGRAM_HEADER_STATEMENT_START
  /* HEADER_LIST_DECLARATIONS */
  // DQ (3/20/2007): These are automatically generated access functions from p_name (also added as a data member)
  // SgName get_name() const;
  // void set_name(SgName);

  // DQ (3/20/2007): These are no longer explicitly stored in the AST (they can be looked up in the symbol table)
  // SgFunctionType* get_type () const;
  // void set_type ( SgFunctionType* type );

  // DQ (3/20/2007): This is not required for a Fortran Program Header, I think. If it is it should be the
  // return_type and should be added as a data member with the access functions automatically generated.
  // SgType* get_orig_return_type() const;

  // DQ (3/20/2007): I think we need this
     SgName get_mangled_name() const override;

  // DQ (3/20/2007): This should be added as a data member with automatically generated access functions.
  // void set_parameterList ( SgFunctionParameterList* );

  // DQ (3/20/2007): Fortran Program's can't use arguments in this situation (rule 1102, Fortran 2003 Standard 04-007).
  // SgInitializedNamePtrList & get_args() ;
  // const SgInitializedNamePtrList & get_args() const;

     protected:
          virtual bool replace_child($GRAMMAR_PREFIX_Statement *,$GRAMMAR_PREFIX_Statement *, bool extractListFromBasicBlock = false) override;

     public:
       // DQ (3/20/2007): Fortran Program does not have this concept.
       // void hasEllipses();

HEADER_PROGRAM_HEADER_STATEMENT_END

HEADER_PROCEDURE_HEADER_STATEMENT_START

       // DQ (3/20/2007): These should be generated automatically from ROSETTA.
       // SgName get_name() const;
       // void set_name(SgName);
       // SgFunctionType* get_type () const;
       // void set_type ( SgFunctionType* type );
       // SgType* get_orig_return_type() const;
       // void set_parameterList ( SgFunctionParameterList* );

      /*! \brief Classification for different types of Fortran subprograms.
       */
          enum subprogram_kind_enum
             {
               e_unknown_kind,               /*!< error value */
               e_function_subprogram_kind,   /*!< Fortran function value */
               e_subroutine_subprogram_kind, /*!< Fortran subroutine value */
               e_block_data_subprogram_kind, /*!< Fortran data block value */
               e_last_subprogram_kind        /*!< last value (upper bound on range of values, used in error checking) */
             };

          SgName get_mangled_name() const override;

       /* HEADER_LIST_DECLARATIONS */

       // $GRAMMAR_PREFIX_InitializedNamePtrList & get_args() ;
       // const $GRAMMAR_PREFIX_InitializedNamePtrList & get_args() const;

     protected:
       // DQ (3/20/2007): Unclear if we need this, it references p_definition, which does not appear to be defined!
       // virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false);

     public:
          bool isFunction()   const;
          bool isSubroutine() const;
          bool isBlockData()  const;

       // DQ (3/20/2007): Fortran does not have this concept (I think)
       // void hasEllipses();
HEADER_PROCEDURE_HEADER_STATEMENT_END

HEADER_ENTRY_STATEMENT_START

          SgName get_mangled_name() const override;

HEADER_ENTRY_STATEMENT_END

HEADER_ADA_ENTRY_DECL_STMT_START

          SgName get_mangled_name() const override;

          /// returns the entry index type or a SgVoidType if the entry index is not used
          SgType* get_entryIndexType() const;

HEADER_ADA_ENTRY_DECL_STMT_END

HEADER_ADA_FUNCTION_RENAMING_DECL_STMT_START

          SgName get_mangled_name() const override;

HEADER_ADA_FUNCTION_RENAMING_DECL_STMT_END

HEADER_FORTRAN_DO_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
          // Added for uniform support of mangled names, Liao, 3/11/2009
          virtual SgName get_mangled_name() const override;

HEADER_FORTRAN_DO_END

HEADER_FORTRAN_NONBLOCKED_DO_START
HEADER_FORTRAN_NONBLOCKED_DO_END

HEADER_INTERFACE_STATEMENT_START

          enum generic_spec_enum
             {
               e_error_interface_type      = 0, /*!< error value */
               e_default_interface_type    = 1, /*!< default value */
               e_unnamed_interface_type    = 2, /*!< default value */
               e_named_interface_type      = 3, /*!< named interface value */
               e_operator_interface_type   = 4, /*!< operator value */
               e_assignment_interface_type = 5, /*!< assignement operator value */
               e_last_interface_type       = 6  /*!< last value (upper bound on range of values, used in error checking) */
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;
HEADER_INTERFACE_STATEMENT_END

HEADER_PARAMETER_STATEMENT_START
HEADER_PARAMETER_STATEMENT_END

HEADER_COMMON_BLOCK_STATEMENT_START
          SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          const SgCommonBlockObjectPtrList & get_block_list() const;
          SgCommonBlockObjectPtrList & get_block_list();
HEADER_COMMON_BLOCK_STATEMENT_END

HEADER_MODULE_STATEMENT_START
          virtual SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          std::vector<SgInterfaceStatement*> get_interfaces() const;

       // const SgDeclarationStatementPtrList & get_members() const;
       // SgDeclarationStatementPtrList & get_members();

  // protected:
       // virtual bool replace_child ( SgStatement *,SgStatement *, bool extractListFromBasicBlock = false );
       // virtual bool insert_child  ( SgStatement*, SgStatement*, bool inFront = true, bool extractListFromBasicBlock = false );

HEADER_MODULE_STATEMENT_END

HEADER_CONTAINS_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;
HEADER_CONTAINS_STATEMENT_END

HEADER_USE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;
HEADER_USE_STATEMENT_END

HEADER_PROCESS_CONTROL_STATEMENT_START
     public:
       // Rasmussen (7/11/2020): Renamed SgStopOrPauseStatement to SgProcessControlStatement
       // PP (2/11/22): added requeue and requeue_with_abort to support Ada
          enum control_enum
             {
               e_unknown,
               e_abort,
               e_stop,
               e_error_stop,
               e_exit,
               e_fail_image,
               e_pause,
               e_requeue,
               e_requeue_with_abort,
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_PROCESS_CONTROL_STATEMENT_END

// Rasmussen (9/20/2018): Added image control statements
//
HEADER_IMAGE_CONTROL_STATEMENT_START
  // This is a base class for all the image control statements.
  // Except for allocate and deallocate statements

     public:
      //! Fortran specific classification for image control statements
          enum image_control_statement_enum
             {
               e_unknown,
               e_sync_all,
               e_sync_images,
               e_sync_memory,
               e_sync_team,
               e_change_team,
               e_critical,
               e_event_post,
               e_event_wait,
               e_form_team,
               e_lock,
               e_unlock,
            // e_allocate,      /* does not derive from SgImageControlStatement */
            // e_deallocate,    /* does not derive from SgImageControlStatement */
               e_last_image_control_statement
             };

HEADER_IMAGE_CONTROL_STATEMENT_END

HEADER_SYNC_ALL_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_SYNC_ALL_STATEMENT_END

HEADER_SYNC_IMAGES_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_SYNC_IMAGES_STATEMENT_END

HEADER_SYNC_MEMORY_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_SYNC_MEMORY_STATEMENT_END

HEADER_SYNC_TEAM_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_SYNC_TEAM_STATEMENT_END

HEADER_LOCK_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_LOCK_STATEMENT_END

HEADER_UNLOCK_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_UNLOCK_STATEMENT_END


HEADER_IO_STATEMENT_START
  // This is a base class for all the I/O statements: read, write, open, close, inquire
  // In addition it fully represents the statements: backspace, endfile, rewind

     public:
      //! Fortran specific classification
          enum io_statement_enum
             {
               e_unknown,
               e_read,
               e_print,
               e_write,
               e_open,
               e_close,
               e_inquire,
               e_backspace,
               e_endfile,
               e_rewind,
               e_last_io_statment_kind
             };

HEADER_IO_STATEMENT_END

HEADER_PRINT_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_PRINT_STATEMENT_END

HEADER_READ_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_READ_STATEMENT_END

HEADER_WRITE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_WRITE_STATEMENT_END

HEADER_OPEN_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_OPEN_STATEMENT_END

HEADER_CLOSE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_CLOSE_STATEMENT_END

HEADER_INQUIRE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_INQUIRE_STATEMENT_END

HEADER_FLUSH_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_FLUSH_STATEMENT_END

HEADER_REWIND_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_REWIND_STATEMENT_END

HEADER_BACKSPACE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_BACKSPACE_STATEMENT_END

HEADER_ENDFILE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_ENDFILE_STATEMENT_END

HEADER_WAIT_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
HEADER_WAIT_STATEMENT_END



HEADER_BLOCK_DATA_STATEMENT_START
HEADER_BLOCK_DATA_STATEMENT_END

HEADER_IMPLICIT_STATEMENT_START

    /*! Specifiers for the implicit-none-spec-list */
          enum implicit_spec_enum
            {
               e_unknown_implicit_spec = 0,
               e_has_implicit_spec_list,  /*!< In future this could replace set/get_implicit_none()  */
               e_none,                    /*!< IMPLICIT NONE */
               e_none_external,           /*!< IMPLICIT NONE (EXTERNAL) */
               e_none_type,               /*!< IMPLICIT NONE (TYPE) */
               e_none_external_and_type   /*!< IMPLICIT NONE (EXTERNAL, TYPE) : order not specified */
            };

     SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_IMPLICIT_STATEMENT_END

HEADER_STATEMENT_FUNCTION_STATEMENT_START
     SgName get_mangled_name() const override;
HEADER_STATEMENT_FUNCTION_STATEMENT_END

HEADER_WHERE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_WHERE_STATEMENT_END

HEADER_ELSE_WHERE_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ELSE_WHERE_STATEMENT_END

HEADER_NULLIFY_STATEMENT_START
HEADER_NULLIFY_STATEMENT_END

HEADER_EQUIVALENCE_STATEMENT_START
     SgName get_mangled_name() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_EQUIVALENCE_STATEMENT_END

HEADER_DERIVED_TYPE_STATEMENT_START
     SgName get_mangled_name() const override;
HEADER_DERIVED_TYPE_STATEMENT_END

HEADER_ATTRIBUTE_SPECIFICATION_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
     virtual unsigned int cfgIndexForEnd() const override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
     virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

     public:
      //! Fortran specific classification of attribute statements (each corresponds to a declaration attribute).
          enum attribute_spec_enum
             {
               e_unknown_attribute_spec,
               e_accessStatement_private,
               e_accessStatement_public,
               e_allocatableStatement,
               e_asynchronousStatement,
               e_bindStatement,
               e_dataStatement,
               e_dimensionStatement,
               e_externalStatement,
               e_intentStatement,
               e_intrinsicStatement,
               e_optionalStatement,
               e_parameterStatement,
               e_pointerStatement,
               e_protectedStatement,
               e_saveStatement,
               e_targetStatement,
               e_valueStatement,
               e_volatileStatement,
               e_last_attribute_spec
             };

          virtual SgName get_mangled_name() const override;

          const SgStringList & get_name_list() const;
          SgStringList & get_name_list();

      //! Support for Fortran data statement
          const SgDataStatementGroupPtrList & get_data_statement_group_list() const;
          SgDataStatementGroupPtrList & get_data_statement_group_list();

      //! Support for Fortran data statement
          const SgDimensionObjectPtrList & get_dimension_object_list() const;
          SgDimensionObjectPtrList & get_dimension_object_list();

       // DQ (12/9/2007): Added special support for this case.
          SgSymbol* search_for_symbol_from_symbol_table() const;

HEADER_ATTRIBUTE_SPECIFICATION_STATEMENT_END


HEADER_ALLOCATE_STATEMENT_START
HEADER_ALLOCATE_STATEMENT_END


HEADER_DEALLOCATE_STATEMENT_START
HEADER_DEALLOCATE_STATEMENT_END


HEADER_CONTAINS_STATEMENT_START
HEADER_CONTAINS_STATEMENT_END


HEADER_SEQUENCE_STATEMENT_START
HEADER_SEQUENCE_STATEMENT_END


HEADER_ARITHMETIC_IF_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ARITHMETIC_IF_STATEMENT_END


HEADER_ASSIGN_STATEMENT_START
HEADER_ASSIGN_STATEMENT_END


HEADER_COMPUTED_GOTO_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

#if 0
       // DQ (12/30/2007): This list is no longer requires since we ave build the IR node for a SgLabelRefExp
       // and we can hold this information using an more common ExprListExp instead.
          const SgLabelSymbolPtrList & get_labelList() const;
          SgLabelSymbolPtrList & get_labelList();
          void set_labelList(const SgLabelSymbolPtrList & labelList);
#endif

HEADER_COMPUTED_GOTO_STATEMENT_END


HEADER_ASSIGNED_GOTO_STATEMENT_START
HEADER_ASSIGNED_GOTO_STATEMENT_END


HEADER_NAMELIST_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;

          const SgNameGroupPtrList & get_group_list() const;
          SgNameGroupPtrList & get_group_list();
HEADER_NAMELIST_STATEMENT_END


HEADER_IMPORT_STATEMENT_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;

          const SgExpressionPtrList & get_import_list() const;
          SgExpressionPtrList & get_import_list();
HEADER_IMPORT_STATEMENT_END


HEADER_ASSOCIATE_STATEMENT_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          virtual SgName get_mangled_name() const override;
HEADER_ASSOCIATE_STATEMENT_END


HEADER_FORMAT_STATEMENT_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif
          virtual SgName get_mangled_name() const override;

       // const SgFormatItemPtrList & get_format_item_list() const;
       // SgFormatItemPtrList & get_format_item_list();
       // void set_format_item_list(const SgFormatItemPtrList & format_item_list);

HEADER_FORMAT_STATEMENT_END

HEADER_FORTRAN_INCLUDE_LINE_START
       // Not sure if we need these...
       // virtual unsigned int cfgIndexForEnd() const override;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;

          virtual SgName get_mangled_name() const override;
HEADER_FORTRAN_INCLUDE_LINE_END


HEADER_UPC_NOTIFY_STATEMENT_START
HEADER_UPC_NOTIFY_STATEMENT_END

HEADER_UPC_WAIT_STATEMENT_START
HEADER_UPC_WAIT_STATEMENT_END

HEADER_UPC_BARRIER_STATEMENT_START
HEADER_UPC_BARRIER_STATEMENT_END

HEADER_UPC_FENCE_STATEMENT_START
HEADER_UPC_FENCE_STATEMENT_END

HEADER_UPC_FORALL_STATEMENT_START
HEADER_LIST_DECLARATIONS

       $CLASSNAME(SgForInitStatement *, SgStatement *, SgExpression *, SgExpression *, SgStatement * = NULL);

       // Liao, 6/17/2008 Copied from HEADER_FOR_STATEMENT_START
         SgStatementPtrList & get_init_stmt();
          const SgStatementPtrList & get_init_stmt() const;
       protected:
          virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

       public:

       // DQ (11/25/2005): Support for previous interface function.
          SgExpression*     get_test_expr () const                                 ROSE_DEPRECATED_FUNCTION;
          void              set_test_expr (SgExpression* expression )              ROSE_DEPRECATED_FUNCTION;

          int replace_expression(SgExpression * original_expression, SgExpression * new_expression ) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

         // DQ (2/22/2007): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

HEADER_UPC_FORALL_STATEMENT_END


HEADER_JOVIAL_DEFINE_DECLARATION_START

          virtual SgName get_mangled_name() const override;

HEADER_JOVIAL_DEFINE_DECLARATION_END


HEADER_JOVIAL_DIRECTIVE_STATEMENT_START

      /*! A Jovial directive can be types */
          enum directive_types
             {
               e_unknown = 0,
               e_compool,              /*!< 9.1 COMPOOL DIRECTIVE */
                                       /*!< 9.2 TEXT DIRECTIVES */
               e_copy,                 /*!< 9.2.1 COPY DIRECTIVE */
               e_skip,                 /*!< 9.2.2 SKIP DIRECTIVE */
               e_begin,                /*!<       BEGIN DIRECTIVE */
               e_end,                  /*!<       END DIRECTIVE */
               e_linkage,              /*!< 9.3 LINKAGES DIRECTIVES */
               e_trace,                /*!< 9.4 TRACE DIRECTIVES */
               e_interference,         /*!< 9.5 INTERFERENCE DIRECTIVES */
               e_reducible,            /*!< 9.6 REDUCIBLE DIRECTIVES */
                                       /*!< 9.7 LISTING DIRECTIVES */
                                       /*!< 9.7.1 SOURCE-LISTING DIRECTIVES */
               e_nolist,               /*!<       NOLIST DIRECTIVE */
               e_list,                 /*!<       LIST DIRECTIVE */
               e_eject,                /*!<       EJECT DIRECTIVE */
                                       /*!< 9.7.1 DEFINE-LISTING DIRECTIVES */
               e_listinv,              /*!<       LISTINV DIRECTIVE */
               e_listexp,              /*!<       LISTEXP DIRECTIVE */
                                       /*!< 9.8 REGISTER DIRECTIVES */
               e_base,                 /*!<     BASE DIRECTIVE */
               e_isbase,               /*!<     ISBASE DIRECTIVE */
               e_drop,                 /*!<     DROP DIRECTIVE */
                                       /*!< 9.9 EXPRESSION EVALUATION ORDER DIRECTIVES */
               e_left_right,           /*!<     LEFTRIGHT DIRECTIVE */
               e_rearrange,            /*!<     REARRANGE DIRECTIVE */
               e_initialize,           /*!< 9.10 INITIALIZATION DIRECTIVES */
               e_order,                /*!< 9.11 ALLOCATION ORDER DIRECTIVES */

               e_align,                /*!< ALIGN DIRECTIVE, non-standard */
               e_always                /*!< ALWAYS'STORE DIRECTIVE, non-standard */
             };

          virtual SgName get_mangled_name() const override;

HEADER_JOVIAL_DIRECTIVE_STATEMENT_END

HEADER_JOVIAL_LABEL_DECLARATION_START

      /*! 15.3.4.2 Statement Name Declaration. A Jovial label can be a variable! */
          enum label_type_enum
             {
               e_unknown = 0,
               e_jovial_label_decl,    /*!<     LABEL name */
               e_jovial_label_def,     /*!< DEF LABEL name */
               e_jovial_label_ref      /*!< REF LABEL name */
             };

          virtual SgName get_mangled_name() const override;

HEADER_JOVIAL_LABEL_DECLARATION_END


HEADER_JOVIAL_OVERLAY_DECLARATION_START
      virtual SgName get_mangled_name (void) const override;
HEADER_JOVIAL_OVERLAY_DECLARATION_END


HEADER_PREPROCESSOR_DIRECTIVE_STATEMENT_START

       // DQ (11/23/2008): I think this is defined in the base class so we can't redefine it here.
       // void post_construction_initialization();

          static SgC_PreprocessorDirectiveStatement* createDirective ( PreprocessingInfo* currentPreprocessingInfo );

       // DQ (11/29/2008): Added for uniform support of mangled names
          virtual SgName get_mangled_name() const override;

HEADER_PREPROCESSOR_DIRECTIVE_STATEMENT_END

HEADER_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_START

HEADER_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_END


HEADER_JAVA_IMPORT_STATEMENT_START
       // We might need to be able to read this file in and process it..., but hopefully the ECJ frontend takes care of that.

          virtual SgName get_mangled_name (void) const override;

HEADER_JAVA_IMPORT_STATEMENT_END

HEADER_JAVA_PACKAGE_DECLARATION_START
          virtual SgName get_mangled_name() const override;
HEADER_JAVA_PACKAGE_DECLARATION_END

HEADER_JAVA_PACKAGE_STATEMENT_START
          virtual SgName get_mangled_name() const override;
HEADER_JAVA_PACKAGE_STATEMENT_END


HEADER_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT_START

       // We need this to be defined to avoid calling the base class version (which is an error).
          SgName get_mangled_name() const override;

          bool hasExplicitScope() const override;

HEADER_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT_END

// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################


SOURCE_MAIN_STATEMENT_START

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgStatement::get_symbol_from_symbol_table() called on base class SgStatement = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
  // tps (12/9/2009) : MSC requires a return value
     return NULL;
   }

void
SgStatement::remove_statement(SgStatement *target)
   {
     bool r = replace_child(target, 0);
     assert(r);
   }

//! Insert newstmt before or after the target statement, which should be a child statement of this statement
void
SgStatement::insert_statement(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
#if 0
     printf ("In SgStatement::insert_statement(): insert newstmt = %p = %s before/after target = %p = %s \n",newstmt,newstmt->class_name().c_str(),target,target->class_name().c_str());
#endif

     bool r = insert_child( target, newstmt, inFront, false);
     assert(r);
   }

void
SgStatement::insert_statement(SgStatement* target, const SgStatementPtrList& newstmtList, bool inFront)
   {
#if 0
      printf ("In SgStatement::insert_statement(): insert newstmtList.size() = %" PRIuPTR " before/after target = %p = %s \n",newstmtList.size(),target,target->class_name().c_str());
#endif

     SgBasicBlock* tmp = new SgBasicBlock();
     tmp->get_statements() = newstmtList;
     bool r = insert_child( target, tmp, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, SgStatement* newstmt)
   {
  // DQ (6/24/2006): Allow structurally oriented operations to set the parent (now that we store the scope explicitly this is OK).
     ROSE_ASSERT(newstmt != NULL);
     ROSE_ASSERT(target != NULL);
     ROSE_ASSERT(target->get_parent() != NULL);
  // ROSE_ASSERT(target->get_parent() != newstmt);
     if (newstmt->get_parent() == NULL)
          newstmt->set_parent(target->get_parent());

     bool r = replace_child(target, newstmt, false);
     assert(r);
   }

void
SgStatement::replace_statement(SgStatement* target, const SgStatementPtrList& newstmtList)
   {
     SgBasicBlock* tmp = new SgBasicBlock();
     tmp->get_statements() = newstmtList;
     bool r = replace_child( target, tmp, true);
     assert(r);
   }

 // if newstmt is a basicBlock, statements inside newstmt are extracted and then inserted
void
SgStatement::insert_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt, bool inFront)
   {
#if 0
     printf ("In SgStatement::insert_statement_from_basicBlock(): insert newstmt = %p = %s before/after target = %p = %s \n",newstmt,newstmt->class_name().c_str(),target,target->class_name().c_str());
#endif

     bool r = insert_child( target, newstmt, inFront, true);
     assert(r);
   }

void
SgStatement::replace_statement_from_basicBlock(SgStatement* target, SgStatement* newstmt)
   {
     bool r = replace_child( target, newstmt, true);
     assert(r);
   }

void
SgStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// DQ (12/5/2004): Support for setting scopes (only meaningful on IR statements that store the scope explicitly)
void
SgStatement::set_scope ( SgScopeStatement* newScope )
   {
     ROSE_ASSERT(this != NULL);
     printf ("Warning: It is meaningless to set the scope in this %s IR node, the scope is not explicitly stored on this IR node! \n",class_name().c_str());
     ROSE_ASSERT(false);
   }

bool
SgStatement::hasExplicitScope() const
   {
  // This function reports that this IR node (by default) does NOT store its scope explicitly.

     return false;
   }

void
SgStatement::setExtern()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatement::setExtern() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

void
SgStatement::setStatic()
   {
     ROSE_ASSERT(this != NULL);
     printf ("Error: SgStatement::setStatic() is deprecated (it is now an error to call this) \n");
     ROSE_ASSERT(false);
   }

#if 0
void
SgStatement::set_pragma()
   {
  // if(found_pragma_cnt)
  //    {
  //      add_pragma(found_pragma_cnt,found_pragma_list);
  //      found_pragma_cnt=0;
  //    }
   }
#endif

bool
SgStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractListFromBasicBlock)
   {
     printf ("$CLASSNAME::replace_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",this->class_name().c_str());

  // DQ (6/15/2019): Output more information when this error occures.
     ROSE_ASSERT(target != NULL);
     printf (" --- target = %p = %s \n",target,target->class_name().c_str());
     ROSE_ASSERT(newstmt != NULL);
     printf (" --- newstmt = %p = %s \n",newstmt,newstmt->class_name().c_str());
     printf (" --- extractListFromBasicBlock = %s \n",extractListFromBasicBlock ? "true" : "false");

     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from $CLASSNAME::replace_child()");
     ROSE_ASSERT(false);

     return false;
   }

bool
SgStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractListFromBasicBlock)
   {
     printf ("$CLASSNAME::insert_child(): ERROR: virtual function called in base class by mistake in %s (exiting at ...) \n",this->class_name().c_str());

  // DQ (6/15/2019): Output more information when this error occurs.
     ROSE_ASSERT(target != NULL);
     printf (" --- target = %p = %s \n",target,target->class_name().c_str());
     SgNode* target_parent = target->get_parent();
     printf (" --- target_parent = %p \n",target_parent);
     if (target_parent != NULL)
        {
          printf (" --- target_parent = %p = %s \n",target_parent,target_parent->class_name().c_str());
        }
     ROSE_ASSERT(newstmt != NULL);
     printf (" --- newstmt = %p = %s \n",newstmt,newstmt->class_name().c_str());
     printf (" --- inFront = %s extractListFromBasicBlock = %s \n",inFront ? "true" : "false",extractListFromBasicBlock ? "true" : "false");

     ROSE_ASSERT(newstmt->get_file_info() != NULL);
     newstmt->get_file_info()->display("called from $CLASSNAME::insert_child()");
     ROSE_ASSERT(false);

     return false;
   }


// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
     printf ("Error: base class of virtual SgStatement::replace_expression called by mistake for statement: %s \n",class_name().c_str());

  // DQ (6/15/2019): Output more information when this error occures.
     ROSE_ASSERT(original_expression != NULL);
     printf (" --- original_expression = %p = %s \n",original_expression,original_expression->class_name().c_str());
     ROSE_ASSERT(new_expression != NULL);
     printf (" --- new_expression = %p = %s \n",new_expression,new_expression->class_name().c_str());

     ROSE_ASSERT(original_expression->get_file_info() != NULL);
     original_expression->get_file_info()->display("called from $CLASSNAME::replace_expression()");
     ROSE_ASSERT(new_expression->get_file_info() != NULL);
     new_expression->get_file_info()->display("called from $CLASSNAME::replace_expression()");

     ROSE_ASSERT(false);

     return 0;
   }

SgScopeStatement*
SgStatement::get_scope(void) const
   {
     ASSERT_this();

  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Important exception: The SgFunctionParameterList should have as it's scope the
  // SgFunctionDefinition, but it is a sibling of the SgFunctionDefinition (both the
  // SgFunctionParameterList and the SgFunctionDefinition have the SgFunctionDeclaration
  // as a parent.  Thus the scope of the SgFunctionParameterList is computed to be the
  // SgGlobal (global scope) most often; which is an error).  So we handle this case
  // explicitly.

     SgStatement *stmt = const_cast<SgStatement*>(this);
     ASSERT_not_null(stmt);

  // Make sure that parents have been set already (assume this means that all parents have been set)
#define WARN_NULL_PARENT_IN_GET_SCOPE 0
#if WARN_NULL_PARENT_IN_GET_SCOPE
     if (get_parent() == NULL)
        {
          printf ("Note: found IR node where parent was not set = %p = %s (may not be required) \n",this,class_name().c_str());
       // ROSE_ASSERT(get_file_info() != NULL);
          if (get_file_info() != NULL)
             {
               get_file_info()->display("Location of problematic IR node");
             }
        }
#endif

  // ROSE_ASSERT (get_parent() != NULL);

#if 0
     printf ("In SgStatement::get_scope(): this = %s \n",class_name().c_str());
#endif

     SgScopeStatement *returnScope = NULL;
     switch (variantT())
        {
       // DQ (11/7/03) : If we are a SgGlobal then return NULL (is this the best return value???)
       // DQ (11/25/03): If we are a SgGlobal then return "this" (I think it's more useful)
       // So the scope of global scope is now the global scope (hope this does not cause
       // any loops to never terminate!).

          case V_SgGlobal:
             {
            // returnScope = NULL;
               returnScope = isSgScopeStatement(stmt);
               ROSE_ASSERT (returnScope != NULL);
               break;
             }

       // DQ (9/24/2005): This should be handled the same as SgFunctionParameterList
          case V_SgCtorInitializerList:

       // DQ (11/21/2003): Handle special case of SgFunctionParameterList (attached to the
       //                  SgFunctionDeclaration instead of the SgFunctionDefinition)
          case V_SgFunctionParameterList:
             {
            // Handle case of SgFunctionDeclaration or SgMemberFunctionDeclaration
               if (stmt->get_parent() == NULL)
                  {
                 // DQ (9/16/2019): Adding debugging support.
                    ROSE_ASSERT (stmt != NULL);
                    printf ("Error: SgStatement::get_scope(): stmt->get_parent() == NULL: stmt = %p = %s \n",stmt,stmt->class_name().c_str());
                  }
               ROSE_ASSERT (stmt->get_parent() != NULL);

               if ( SageInterface::is_Python_language() && isSgLambdaRefExp(stmt->get_parent()) ) {
                   std::cout << "warning: python. Fetching scope of lambda parameters from lambda's scope." << std::endl;
                   returnScope = SageInterface::getScope(stmt->get_parent());
                   ROSE_ASSERT( returnScope != NULL );
                   break;
               }


               SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(stmt->get_parent());
               if (functionDeclaration != NULL)
                  {
                 // DQ (2/12/2006): provide a consistent definition of the scope for SgFunctionParameterList
                 // instead of a definition that depends on if it is a defining or non-defining declaration.
                    returnScope = functionDeclaration->get_scope();
                  }
               else if (SgAdaAcceptStmt* adaAccept = isSgAdaAcceptStmt(stmt->get_parent()))
                  {
                    returnScope = adaAccept->get_parameterScope();
                  }
               else if (SgAdaSubroutineType* adaSubroutine = isSgAdaSubroutineType(stmt->get_parent()))
                  {
                    returnScope = adaSubroutine->get_functionParameterScope();
                  }
               else
                  {
                 // DQ (11/25/2011): Added support for SgTemplateFunctionDeclaration (and SgTemplateMemberFunctionDeclaration)
                 // which uses a SgFunctionParameterList internally.
                    SgTemplateFunctionDeclaration* templateFunctionDeclaration = isSgTemplateFunctionDeclaration(stmt->get_parent());
                    ROSE_ASSERT(templateFunctionDeclaration != NULL);
                    returnScope = templateFunctionDeclaration->get_scope();
                  }

               ROSE_ASSERT (returnScope != NULL);
               break;
             }

          // Ada parameter list follows the design of SgFunctionParameterList
          case V_SgAdaParameterList:
             {
               SgNode* parent = stmt->get_parent();
               SgAdaDiscriminatedTypeDecl* discdcl = isSgAdaDiscriminatedTypeDecl(parent);
               ASSERT_not_null(discdcl);

               returnScope = discdcl->get_discriminantScope();
               ROSE_ASSERT (returnScope != NULL);
               break;
             }


       // TV (05/28/2018): It can happen for SgDeclarationScope created to hold non-real declarations to be missing their parent...
          case V_SgDeclarationScope:
             {
               SgStatement * pstmt = isSgStatement(get_parent());
               returnScope = isSgScopeStatement(pstmt);
               if (returnScope == NULL && pstmt != NULL) {
                 returnScope = pstmt->get_scope();
               }
               return returnScope; // Skipping assert at the end
               break;
             }
       // DQ (11/7/03): If we are a ScopeStatment then reset the starting point for the search
       //               for the scopeStatement to the parent of the current node.
          default:
             {
               ROSE_ASSERT(stmt != NULL);
#if 0
               printf ("In SgScopeStatement::get_scope() default case: stmt = %s \n",stmt->sage_class_name());
               ROSE_ASSERT(stmt->get_parent() != NULL);
               printf ("In SgScopeStatement::get_scope() default case: stmt->get_parent() = %s \n",stmt->get_parent()->sage_class_name());
#endif

            // DQ (11/3/2007): Added comment to existing code. If the input node is a scope then move up one using
            // the parent (since scopes are not explicitly stored in SgScopeStatement objects).
               if (isSgScopeStatement(stmt) != NULL)
                  {
                    if (stmt->get_parent() == NULL)
                       {
                         printf ("Error: SgStatement has NULL parent at node = %p = %s \n",stmt,stmt->class_name().c_str());
                         if (stmt->get_file_info() != NULL)
                            {
                              stmt->get_file_info()->display("Error: SgStatement has NULL parent");
                            }
                       }
                    ROSE_ASSERT(stmt->get_parent() != NULL);

                 // DQ (2/17/2014): We need to account for when we now can ask for the scope of a GNU statement expression
                 // inside of an array bound defining an array type.
                 // JJW (10/10/2007) -- the non-NULL parent of a statement may not be a statement in the case of a statement
                 // expression (test case is tests/nonsmoke/functional/CompileTests/Cxx_tests/test2006_148.C), so we need to skip over non-statements
                    SgNode* stmtTemp = stmt;
                    do {
#if 0
                         printf ("In SgStatement::get_scope(): (do-while loop) stmtTemp = %p = %s \n",stmtTemp,stmtTemp->class_name().c_str());
#endif
                         stmtTemp = stmtTemp->get_parent();
                       }
                 // while (stmtTemp && !isSgStatement(stmtTemp));
                 // while ((stmtTemp != NULL) && !isSgStatement(stmtTemp));
                 // while ((stmtTemp != NULL) && (isSgStatement(stmtTemp) == NULL) && (isSgArrayType(stmtTemp) == NULL));
                    while ((stmtTemp != NULL) && (isSgStatement(stmtTemp) == NULL) && (isSgArrayType(stmtTemp) == NULL) && (isSgTypeOfType(stmtTemp) == NULL) );

                 // DQ (5/13/2015): Added debugging support.
                    if (stmtTemp == NULL)
                       {
                          printf ("Error: stmtTemp == NULL: in loop over parents from stmt = %p = %s \n",stmt,stmt->class_name().c_str());
                          ROSE_ASSERT(stmt->get_file_info() != NULL);
                          stmt->get_file_info()->display("Error: SgStatement has NULL parent");
                       }
                    ROSE_ASSERT (stmtTemp != NULL);
                    stmt = isSgStatement(stmtTemp);

                 // DQ (2/17/2014): Handle the case where the scope is queried on a statement appearing in array type bound expression.
                    if (stmt != NULL)
                       {
                      // DQ (11/3/2007): Here is the fix for the case of calling the get_scope from a class definition.
                      // Because the definition of a class could be in an alternative location (structurally) from its
                      // initial declaration, we have to be careful if the parent of the initial input node to this function
                      // is a declaration which has an explicitly stored scope (since we will just use the parents and not
                      // the explicitly stored scope in the code below.  The fix is to check if the value of "stmt" is a
                      // declaration with an explicitly stored scope (and if so use that value). Note that we can only
                      // return the explicitly stored scope, else we have to use parents to track backwards up the tree.
                      // This problem is demonstrated by test2005_153.C and test2005_172.C (smaller test code).
                         if (stmt->hasExplicitScope() == true)
                            {
                              ROSE_ASSERT(isSgScopeStatement(stmt) == NULL);
                              return stmt->get_scope();
                            }
                       }
                      else
                       {
                      // DQ (5/16/2015): This can also be the SgTypeOf operator.
                      // DQ (2/17/2014): This must be the case of an SgArrayType (not clear what to do here, return NULL).
                         SgArrayType* arrayType = isSgArrayType(stmtTemp);
                         SgTypeOfType* typeOfType = isSgTypeOfType(stmtTemp);
                      // ROSE_ASSERT(arrayType != NULL);
                         ROSE_ASSERT(arrayType != NULL || typeOfType != NULL);
#if 0
                         printf ("In get_scope(): identified input node to be part of SgArrayType: returning NULL \n");
#endif
                         return NULL;
                       }
                  }
               ROSE_ASSERT(stmt != NULL);

               int counter = 0;
               while(stmt && !(returnScope = isSgScopeStatement(stmt)))
                  {
#if 0
                    printf ("stmt->sage_class_name() = %s \n",stmt->sage_class_name());
#endif

                    if (isSgNonrealDecl(stmt) != NULL && isSgStatement(stmt->get_parent()) == NULL) {
                      printf("WARNING: In SgStatement::get_scope(): case of a non-real declaration with a parent which is not a SgStatement!!!\n");
                      printf("  - stmt = %p (%s)\n", stmt, stmt ? stmt->class_name().c_str() : "");
                      printf("  - stmt->get_parent() = %p (%s)\n", stmt->get_parent(), stmt->get_parent() ? stmt->get_parent()->class_name().c_str() : "");
                      return NULL;
                    }

                    if (stmt->get_parent() == NULL)
                       {
                         if (isSgJovialCompoolStatement(stmt) || isSgEmptyDeclaration(stmt)) return NULL; // TODO dangling SgJovialCompoolStatement without parent AND SgEmptyDeclaration generate in "collect" phase of the translator but files are created later leading to pool traversal in post-processing.

                         printf ("Error: NULL parent pointer not allowed for statement = %p = %s = %s \n",stmt,stmt->class_name().c_str(),SageInterface::get_name(stmt).c_str());
                         ROSE_ASSERT(stmt->get_file_info() != NULL);
                         stmt->get_file_info()->display("Error: NULL parent pointer not allowed for statement");
                       }
                    ROSE_ASSERT (stmt->get_parent() != NULL);
#if 0
                    printf ("stmt->get_parent()->sage_class_name() = %s \n",stmt->get_parent()->sage_class_name());
#endif

                 // stmt = isSgStatement(stmt->get_parent());
                    SgInitializedName* initializedName = isSgInitializedName(stmt->get_parent());
                    if (initializedName != NULL)
                       {
#if 0
                         printf ("Get the stmt pointer from the initializedName->get_parent() = %p = %s \n",initializedName->get_parent(),initializedName->get_parent()->class_name().c_str());
#endif
                      // DQ (12/16/2007): Added error handling (reporting)
                         if (isSgStatement(initializedName->get_parent()) == NULL)
                            {
                              printf ("Error: isSgStatement(initializedName->get_parent()) == NULL (initializedName = %p = %s) \n",initializedName,initializedName->get_name().str());
                            }
                         ROSE_ASSERT(initializedName->get_parent() != NULL);
                         stmt = isSgStatement(initializedName->get_parent());
                         ROSE_ASSERT(stmt != NULL);
                       }
                    else if (SgAdaParameterList* adaparmlst = isSgAdaParameterList(stmt->get_parent()))
                       { return adaparmlst->get_scope();
                       }
                    else
                       {
                      // DQ (12/16/2007): Added error handling (reporting)
                         if (isSgStatement(stmt->get_parent()) == NULL)
                            {
                              printf ("Error: isSgStatement(stmt ->get_parent()) == NULL (statement = %p = %s) (numeric_label = %p) \n",stmt,stmt->class_name().c_str(),stmt->get_numeric_label());
                            }
                         ROSE_ASSERT(stmt->get_parent() != NULL);
                         stmt = isSgStatement(stmt->get_parent());
                         ROSE_ASSERT(stmt != NULL);
                       }
                    ROSE_ASSERT(stmt != NULL);

                 // DQ (9/23/2004): Avoid infinite loops, break out (abort) after some reasonable scope depth!
                    counter++;
                    if (counter > 1000)
                       {
                         printf ("Error max nesting depth exceeded, this is likely an error of some sort for a %s \n",sage_class_name());
                         printf ("\"this\" IR node %p = %s \n",this,sage_class_name());
                         get_file_info()->display("Error max nesting depth exceeded");
                         printf ("         stmt is %p = %s \n",stmt,stmt->sage_class_name());
                         stmt->get_file_info()->display("Error max nesting depth exceeded");

                      // DQ (3/19/2016): Klocworks reports ths as an issue, since the value of stmt->get_parent() is dereferenced below. Adding an assertion.
                         ROSE_ASSERT(stmt->get_parent() != NULL);

                         printf ("    has a parent %p = %s \n",stmt->get_parent(),stmt->get_parent()->sage_class_name());
                         ROSE_ASSERT(false);
                       }
                  }
               break;
             }
        }

  // DQ (11/25/2003): I think we can now assert this to be true!
  // DQ (11/27/2003): SgFunctionParameterList in a function prototype will cause
  //                  returnScope == NULL.  So we can't assert this.
  // DQ (11/27/2003): Force SgFunctionParameterList case to use scope of the
  //                  function declaration
     ROSE_ASSERT (returnScope != NULL);

  // Error checking!
     SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(returnScope);
     if (defn != NULL)
        {
          SgTemplateInstantiationDecl * decl = isSgTemplateInstantiationDecl(defn->get_declaration());
          ROSE_ASSERT(decl != NULL);
          if (decl->get_nameResetFromMangledForm() == false)
             {
#if PRINT_DEVELOPER_WARNINGS
               printf ("In get_scope(): Found template definition containing template declaration (%s) with nameResetFromMangledForm == false \n",decl->get_name().str());
#endif
#if 0
            // Uncomment this to find out where this construct is located in teh source code
               decl->get_file_info()->display("In $CLASSNAME::get_scope(): debug");
#endif
             }
        }


#if 0
     printf ("In $CLASSNAME::get_scope(): returnScope->sage_class_name() = %s \n",returnScope->sage_class_name());
#endif

     return returnScope;
   }

// DQ (12/16/2007): Added virtual function so that we could set the end_numeric_label on all relevant Fortran constructs
// void SgStatement::set_end_numeric_label(SgLabelSymbol* end_numeric_label)
void
SgStatement::set_end_numeric_label(SgLabelRefExp* end_numeric_label)
   {
     printf ("Error: base class implementation SgStatement::set_end_numeric_label(%p) should not be called \n",end_numeric_label);
     ROSE_ASSERT(false);
   }


// Report if a construct has a concept of end_numeric_label
bool
SgStatement::has_end_numeric_label() const
   {
     bool returnValue = false;

     switch(variantT())
        {
       // List of statements that contain an end_numeric_label concept
          case V_SgIfStmt:
          case V_SgWhileStmt:
          case V_SgSwitchStatement:
          case V_SgProgramHeaderStatement:
          case V_SgProcedureHeaderStatement:
          case V_SgInterfaceStatement:
          case V_SgModuleStatement:
          case V_SgFortranDo:
          case V_SgWhereStatement:
          case V_SgDerivedTypeStatement:
             {
               returnValue = true;
               break;
             }

          default:
             {
            // Nothing to do here
             }
        }

     return returnValue;
   }

bool
SgStatement::hasExplicitType()
   {
  // DQ (3/7/2014):  This could be implemented as a virtual function but would require multiple functions to be
  // implemented. I have thus instead implemented it as a single function on the SgStatement instead. We
  // can review this if it is important.

  // This function returns true only if this is a SgTypedefDeclaration.

     bool returnValue = false;

     if ( isSgTypedefDeclaration(this) != NULL )
        {
          returnValue = true;
        }

     return returnValue;
   }


SOURCE_MAIN_STATEMENT_END


SOURCE_X_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_X_STATEMENT_END


SOURCE_X_STATEMENT_UNKNOWN_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_X_STATEMENT_UNKNOWN_END


SOURCE_NON_X_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_NON_X_STATEMENT_END


SOURCE_SCOPE_STATEMENT_START


// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::prepend_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().begin(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().begin(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/14/2007): Added to support simpler handling of general scopes (used in EDG/Sage translation).
void
SgScopeStatement::append_statement ( SgStatement* stmt )
   {
  // Higher level function to handle statements and declarations is scopes.

     ROSE_ASSERT(stmt != NULL);
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(stmt);
          if (declaration == NULL)
             {
               printf ("Error: SgScopeStatement::append in a scope such as %s must provide a SgDeclarationStatement = %s \n",class_name().c_str(),stmt->class_name().c_str());
             }
          ROSE_ASSERT(declaration != NULL);

       // Access the STL list directly
          getDeclarationList().insert(getDeclarationList().end(),declaration);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          declaration->set_parent(this);
          ROSE_ASSERT(declaration->get_parent() != NULL);
        }
       else
        {
       // Access the STL list directly
          getStatementList().insert(getStatementList().end(),stmt);

       // Set the parent (to have uniform semantics as with the other insert functions defined in SgStatement.
          stmt->set_parent(this);
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_type_elaboration_list ()
   {
     assert (this != NULL);
     return p_type_elaboration_list;
   }

void
SgScopeStatement::set_type_elaboration_list ( const std::set<SgSymbol*> & type_elaboration_list )
   {
     assert (this != NULL);

#if 1
  // DQ (6/12/2015): Need to evluate if this is used, if it is part of the API that must not set the isModified, etc.
     printf ("Inside of SgScopeStatement::set_type_elaboration_list(): we need to know if this is called! \n");
     ROSE_ASSERT(false);
#endif

     set_isModified(true);
     p_type_elaboration_list = type_elaboration_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_type_list ()
   {
     assert (this != NULL);
     return p_hidden_type_list;
   }

void
SgScopeStatement::set_hidden_type_list ( const std::set<SgSymbol*> & hidden_type_list )
   {
     assert (this != NULL);

#if 1
  // DQ (6/12/2015): Need to evluate if this is used, if it is part of the API that must not set the isModified, etc.
     printf ("Inside of SgScopeStatement::set_type_elaboration_list(): we need to know if this is called! \n");
     ROSE_ASSERT(false);
#endif

     set_isModified(true);
     p_hidden_type_list = hidden_type_list;
   }

// DQ (6/5/2007): Build special operator to return by reference
std::set<SgSymbol*> &
SgScopeStatement::get_hidden_declaration_list ()
   {
     assert (this != NULL);
     return p_hidden_declaration_list;
   }

void
SgScopeStatement::set_hidden_declaration_list ( const std::set<SgSymbol*> & hidden_declaration_list )
   {
     assert (this != NULL);

#if 1
  // DQ (6/12/2015): Need to evluate if this is used, if it is part of the API that must not set the isModified, etc.
     printf ("Inside of SgScopeStatement::set_type_elaboration_list(): we need to know if this is called! \n");
     ROSE_ASSERT(false);
#endif

     set_isModified(true);
     p_hidden_declaration_list = hidden_declaration_list;
   }


std::ostream & operator<< ( std::ostream & os, const std::set<SgSymbol*> & l )
   {
     os << "output operator for std::set<SgSymbol*> not implemented";
     return os;
   }

SgScopeStatement::SgScopeStatement ( Sg_File_Info* file_info )
   : $BASECLASS(file_info)
   {
  // Make the global scope hash multimap larger since it typically supports more symbols.
  // Use a prime number (better!)
     if (variantT() == V_SgGlobal || variantT() == V_SgNamespaceDefinitionStatement)
        {
          p_symbol_table = new SgSymbolTable(101);
        }
       else
        {
          if (variantT() == V_SgClassDefinition || variantT() == V_SgTemplateInstantiationDefn)
             {
               p_symbol_table = new SgSymbolTable(51);
             }
            else
             {
            // Use the default size of hash_multimap
               p_symbol_table = new SgSymbolTable();
             }
        }

     ROSE_ASSERT(p_symbol_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_symbol_table->set_parent(this);

  // DQ (7/23/2010): Build the local type table.
     p_type_table = new SgTypeTable();
     p_type_table->set_parent(this);

  // DQ (9/23/2020): Add a pointer to hold a SgPragma that can be attached to a log of scope IR nodes.
     p_pragma = NULL;
   }

void
SgScopeStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgScopeStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// DQ (9/8/2004): Added to support qualified name generation
// RV (1/31/2006): Modified to return a fully qualified name by recursion.
SgName
SgScopeStatement::get_qualified_name() const
   {
  // Compute name of this scope -- by default, an unnamed (or empty) string.
     SgName local_qual_name;

  // Compute parent scope's qualified name
     SgName par_qual_name;
     const SgScopeStatement* parent_scope = get_scope();
     if (parent_scope)
          par_qual_name = parent_scope->get_qualified_name();

     return SgName::assembleQualifiedName (par_qual_name, local_qual_name);
   }

SgName
SgScopeStatement::get_mangled_name(void) const
   {
     printf ("Error: this is a virtual function call on a base class implementation! scope = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);

     return SgName ("__error__");
   }

size_t
SgScopeStatement::count_symbol(const SgName& n)
   {
  // DQ (2/10/2007): Added function to count entries in symbol table with same name!
  // This can be more than 1, e.g. "typedef struct X{} X;"
     assert (p_symbol_table != NULL);
     return p_symbol_table->count(n);
   }

size_t
SgScopeStatement::count_alias_symbol(const SgName& n)
   {
  // DQ (5/14/2011): Added support to count just the alias symbols that match the input name (key).
     assert (p_symbol_table != NULL);
     return p_symbol_table->count_aliases(n);
   }

//! Return the size of the symbol table.
size_t
SgScopeStatement::symbol_table_size()
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->size();
   }



// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm , SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm,sp);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgName & nm ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(nm);
   }

// DQ (2/10/2007): Added test function for existence of symbols
bool
SgScopeStatement::symbol_exists ( const SgSymbol *sp ) const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->exists(sp);
   }

// DQ (5/21/2013): This function is removed from the SgScopeStatement API as a public member function.
// It is replaced in the SgScopeStatement as a soon to be private member function.  This is done to
// support hiding the namespace symbol table handling behind the SgScopeStatement level of support.
// There is no reason for the symbol table to be directly accessible to users, if there is a problem
// then the SgScopeStatement class API should be extended with the required functionality.
SgSymbolTable*
SgScopeStatement::get_symbol_table () const
   {
     ROSE_ASSERT (this != NULL);
     return p_symbol_table;
   }

// DQ (5/21/2013): This function is removed from the SgScopeStatement API as a public member function (see comment above).
void
SgScopeStatement::set_symbol_table ( SgSymbolTable* symbol_table )
   {
     ROSE_ASSERT (this != NULL);
     set_isModified(true);
     p_symbol_table = symbol_table;
   }

#define DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL 0

void
SgScopeStatement::insert_symbol ( const SgName& n, SgSymbol* s )
   {
#if DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL
     printf("SgScopeStatement::insert_symbol\n");
     printf(" -- n = %s\n", n.getString().c_str());
     printf(" -- s = %p (%s)\n", s, s ? s->class_name().c_str() : "");
#endif
     assert (p_symbol_table != NULL);

     SgNode * symbol_basis = s->get_symbol_basis();
     ROSE_ASSERT(symbol_basis != NULL);
#if DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL
     printf(" -- symbol_basis = %p (%s)\n", symbol_basis, symbol_basis->class_name().c_str());
#endif
     SgDeclarationStatement * declstmt = isSgDeclarationStatement(symbol_basis);
     SgInitializedName * iname = isSgInitializedName(symbol_basis);
     if (iname != NULL) {
       declstmt = isSgVariableDeclaration(iname->get_declaration());
     }
#if DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL
     printf(" -- declstmt = %p (%s)\n", declstmt, declstmt ? declstmt->class_name().c_str() : "");
#endif
     bool is_static_decl = false;
     if (declstmt != NULL) {
       const SgDeclarationModifier & decl_mod = declstmt->get_declarationModifier();
       const SgStorageModifier & storage_mod = decl_mod.get_storageModifier();
       is_static_decl = storage_mod.isStatic();
     }
#if DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL
     printf(" -- is_static_decl = %s\n", is_static_decl ? "true" : "false");
#endif

     const SgNamespaceDefinitionStatement * namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (namespaceDefinitionStatement != NULL && !is_static_decl)
        {
          SgAliasSymbol* aliasSymbol = new SgAliasSymbol(s);

          SgNamespaceDefinitionStatement * gnds = namespaceDefinitionStatement->get_global_definition();
          if (gnds != NULL && namespaceDefinitionStatement != gnds) {
            gnds->get_symbol_table()->insert(n,aliasSymbol);
          }
        }

     SgGlobal * global_scope = isSgGlobal(this);
     if (global_scope != NULL && !is_static_decl) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);

         // DQ (2/28/2015): they can be the same for snippet injection and for some java support.
         if (global_scope != globalScopeAcrossFiles) {
           SgSymbolTable * symtab = globalScopeAcrossFiles->get_symbol_table();
           ROSE_ASSERT(symtab != NULL);
           SgAliasSymbol * asym = symtab->find_aliased_symbol(n,s);
           if (asym == NULL) {
             asym = isSgAliasSymbol(s);
             if (asym != NULL) {
               asym = new SgAliasSymbol(*asym);
             } else {
               asym = new SgAliasSymbol(s);
             }
             ROSE_ASSERT(asym != NULL);
#if DEBUG__SGSCOPESTATEMENT__INSERT_SYMBOL
             printf(" -- asym = %p (%s)\n", asym, asym->class_name().c_str());
#endif
             globalScopeAcrossFiles->get_symbol_table()->insert(n, asym);
           }
         } else {
           mprintf ("Warning: In SgScopeStatement::insert_symbol(): global_scope == globalScopeAcrossFiles: skip insertion of redundant SgAliasSymbol \n");
         }
       } else {
         mprintf ("In SgScopeStatement::insert_symbol(): project == NULL \n");
       }
     }

  // Make sure that this specific symbol and name combination don't already exist in the AST.
     bool symbolAlreadyPresentLookupName = p_symbol_table->exists(n,s);
     if (symbolAlreadyPresentLookupName == true)
        {
          printf ("Error in insert_symbol(n=%s,s=%p): (exists(n,s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               n.str(),s,s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
          printf ("     s->get_symbol_basis() = %p = %s \n",s->get_symbol_basis(),s->get_symbol_basis()->class_name().c_str());
          s->get_symbol_basis()->get_file_info()->display("Error in insert_symbol(n,s)");
        }
     ROSE_ASSERT(symbolAlreadyPresentLookupName == false);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Also test the symbol directly (this is an expensive test, linear in complexity)
  // We don't want to do this except for testing!
     bool symbolAlreadyPresent = p_symbol_table->exists(s);
     if (symbolAlreadyPresent == true)
        {
          printf ("Error: (exists(s) == true) symbol = %p = %s = %s already present in symbol table = %p in scope = %p = %s \n",
               s,s->class_name().c_str(),SageInterface::get_name(s).c_str(),p_symbol_table,this,this->class_name().c_str());
        }
     ROSE_ASSERT(symbolAlreadyPresent == false);
#endif

#if 1
  // DQ (11/21/2013): Adding test as a result of debugging with Philippe.
  // This test is not a test for a bug, since we require that symbols in base classes be aliased in the derived classes.
     SgClassSymbol* class_symbol = isSgClassSymbol(s);
     if (class_symbol != NULL)
        {
          SgClassDeclaration* class_declaration = isSgClassDeclaration(class_symbol->get_declaration());
          ROSE_ASSERT(class_declaration != NULL);

       // DQ (10/22/2016): If this is a namespace definition then only compare to the global_definition.
          SgScopeStatement* classScope = class_declaration->get_scope();
          SgScopeStatement* thisScope = this;

          SgNamespaceDefinitionStatement* namespaceDefinition_class = isSgNamespaceDefinitionStatement(classScope);
          SgNamespaceDefinitionStatement* namespaceDefinition_this  = isSgNamespaceDefinitionStatement(this);
          if (namespaceDefinition_class != NULL && namespaceDefinition_this != NULL)
             {
               classScope = namespaceDefinition_class->get_global_definition();
               thisScope  = namespaceDefinition_this->get_global_definition();

            // printf ("In SgScopeStatement::insert_symbol(): classScope = %p thisScope = %p \n",classScope,thisScope);
             }

       // DQ (10/22/2016): If this is global scope then suppress the output below (this is only an issue for the astMerge option (feature) in ROSE.
          SgGlobal* globalScope_class = isSgGlobal(classScope);
          SgGlobal* globalScope_this  = isSgGlobal(this);
          if (globalScope_class != NULL && globalScope_this != NULL)
             {
               classScope = globalScope_this;

            // printf ("In SgScopeStatement::insert_symbol(): classScope = %p thisScope = %p \n",classScope,thisScope);
             }

          if (classScope != thisScope)
             {
            // DQ (3/6/2017): Added support for message logging to control output from ROSE tools.
               mprintf ("Warning: SgScopeStatement::insert_symbol(): class_declaration->get_scope() != this \n");
               mprintf ("   --- scope = %p = %s \n",this,this->class_name().c_str());
               mprintf ("   --- class_declaration = %p = %s \n",class_declaration,class_declaration->class_name().c_str());
               mprintf ("   --- class_declaration->get_scope() = %p = %s \n",class_declaration->get_scope(),class_declaration->get_scope()->class_name().c_str());
            // class_declaration->get_file_info()->display("class_declaration: debug");
             }
       // ROSE_ASSERT(class_declaration->get_scope() == this);
        }
#endif

#if 0
     printf ("In SgScopeStatement::insert_symbol(%s,%p) into scope = %p = %s symbol = %p = %s \n",n.str(),s,this,this->class_name().c_str(),s,s->class_name().c_str());
#endif

     p_symbol_table->insert(n,s);

#if 0
     printf ("Leaving SgScopeStatement::insert_symbol() \n");
#endif
   }

void
SgScopeStatement::remove_symbol ( SgSymbol* s )
   {
     assert (p_symbol_table != NULL);

#if SYMBOL_TABLE_ERROR_CHECKING
  // Make sure that the symbol exists before we try to remove it
     ROSE_ASSERT(p_symbol_table->exists(s) == true);
#endif

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (namespaceDefinitionStatement != NULL) {
       ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
       const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
       ROSE_ASSERT(globalNamespaceDefinitionStatement != NULL);
       ROSE_ASSERT(namespaceDefinitionStatement != globalNamespaceDefinitionStatement);

       SgName n = s->get_name();

       SgSymbol* aliasSymbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_aliased_symbol(n,s);
       if (aliasSymbol != NULL) {
         globalNamespaceDefinitionStatement->get_symbol_table()->remove(aliasSymbol);
       }
     }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);

         SgName n = s->get_name();

         SgSymbol * aliasSymbol = globalScopeAcrossFiles->get_symbol_table()->find_aliased_symbol(n,s);
         if (aliasSymbol != NULL)
           globalScopeAcrossFiles->get_symbol_table()->remove(aliasSymbol);
       }
     }

     p_symbol_table->remove(s);
   }

int SgScopeStatement::lookup_symbol(const SgName& n, SgSymbol *s) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     if (p_symbol_table->find(n,s)) return true;

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();

          return globalNamespaceDefinitionStatement->get_symbol_table()->find(n,s);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         return globalScopeAcrossFiles->get_symbol_table()->find(n,s);
       }
     }

     return false;
   }

// DQ (7/14/2025): Adding timers to support Matt's tool.
#define USING_PERFORMANCE_TRACING 0

SgSymbol*
SgScopeStatement::lookup_symbol(const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

  // DQ (7/14/2025): Adding timers to support Matt's tool.
#if USING_PERFORMANCE_TRACING
     TimingPerformance timer1 ("SgScopeStatement::lookup_symbol: whole function:");
#endif

     SgSymbol * symbol = p_symbol_table->find_any(n,templateParameterList,templateArgumentList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
#if USING_PERFORMANCE_TRACING
       // DQ (7/14/2025): Adding timers to support Matt's tool.
          TimingPerformance timer1 ("SgScopeStatement::lookup_symbol: looking in global namespace definition:");
#endif
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_any(n,templateParameterList,templateArgumentList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL)
        {
#if USING_PERFORMANCE_TRACING
       // DQ (7/14/2025): Adding timers to support Matt's tool.
          TimingPerformance timer1 ("SgScopeStatement::lookup_symbol: symbol not found::");
#endif
          SgProject * project = SageInterface::getProject(global_scope);
          if (project != NULL)
             {
#if USING_PERFORMANCE_TRACING
            // DQ (7/14/2025): Adding timers to support Matt's tool.
               TimingPerformance timer1 ("SgScopeStatement::lookup_symbol: symbol not found: looking in other global scopes:");
#endif
               SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
               assert(globalScopeAcrossFiles != NULL);
               symbol = globalScopeAcrossFiles->get_symbol_table()->find_any(n,templateParameterList,templateArgumentList);
             }
        }

     return symbol;
   }

SgTypedefSymbol*
SgScopeStatement::lookup_typedef_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTypedefSymbol * symbol = p_symbol_table->find_typedef(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement * globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_typedef(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_typedef(n);
       }
     }

     return symbol;
   }

SgEnumSymbol*
SgScopeStatement::lookup_enum_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgEnumSymbol * symbol = p_symbol_table->find_enum(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_enum(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_enum(n);
       }
     }

     return symbol;
   }

SgEnumFieldSymbol*
SgScopeStatement::lookup_enum_field_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgEnumFieldSymbol * symbol = p_symbol_table->find_enum_field(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_enum_field(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_enum_field(n);
       }
     }

     return symbol;
   }

SgVariableSymbol*
SgScopeStatement::lookup_var_symbol(const SgName& n) const
   {
  // DQ (2/4/2007): This function is part of an older interface which is deprecated.
     return lookup_variable_symbol(n);
   }

SgVariableSymbol*
SgScopeStatement::lookup_variable_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgVariableSymbol * symbol = p_symbol_table->find_variable(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_variable(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_variable(n);
       }
     }

     return symbol;
   }

SgClassSymbol*
SgScopeStatement::lookup_class_symbol(const SgName& n, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgClassSymbol * symbol = p_symbol_table->find_class(n,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_class(n,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_class(n,templateArgumentsList);
       }
     }

     return symbol;
   }

SgNonrealSymbol*
SgScopeStatement::lookup_nonreal_symbol(const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgNonrealSymbol * symbol = p_symbol_table->find_nonreal(n,templateParameterList,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_nonreal(n,templateParameterList,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_nonreal(n,templateParameterList,templateArgumentsList);
       }
     }

     return symbol;
   }

SgLabelSymbol*
SgScopeStatement::lookup_label_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgLabelSymbol * symbol = p_symbol_table->find_label(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_label(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_label(n);
       }
     }

     return symbol;
   }

//
// charles4: function added 09/12/2011 identical with the same function for SgLabelSymbol
//
SgJavaLabelSymbol*
SgScopeStatement::lookup_java_label_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     return p_symbol_table->find_java_label(n);
   }

SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgFunctionSymbol * symbol = p_symbol_table->find_function(n,t,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_function(n,t,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         ROSE_ASSERT(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_function(n,t,templateArgumentsList);
       }
     }

     return symbol;
   }

SgFunctionSymbol*
SgScopeStatement::lookup_function_symbol(const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgFunctionSymbol * symbol = p_symbol_table->find_function(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_function(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_function(n);
       }
     }

     return symbol;
   }

SgNamespaceSymbol*
SgScopeStatement::lookup_namespace_symbol ( const SgName & n ) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgNamespaceSymbol * symbol = p_symbol_table->find_namespace(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement * globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_namespace(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_namespace(n);
       }
     }

     return symbol;
   }

SgTemplateClassSymbol*
SgScopeStatement::lookup_template_class_symbol (const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateSpecializationArgumentList ) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTemplateClassSymbol * symbol = p_symbol_table->find_template_class(n, templateParameterList, templateSpecializationArgumentList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_template_class(n, templateParameterList, templateSpecializationArgumentList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_template_class(n, templateParameterList, templateSpecializationArgumentList);
       }
     }

     return symbol;
   }

SgTemplateTypedefSymbol*
SgScopeStatement::lookup_template_typedef_symbol (const SgName& n) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTemplateTypedefSymbol * symbol = p_symbol_table->find_template_typedef(n);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_template_typedef(n);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_template_typedef(n);
       }
     }

     return symbol;
   }

// DQ (8/22/2012): If we have template arguments then we have a chance to disambiguate SgTemplateInstantiationDecl IR nodes based on the
// arguments which would otherwise require qulified names (which are difficult to robustly support using as the AST is being constructed).
SgClassSymbol*
SgScopeStatement::lookup_nontemplate_class_symbol (const SgName& n, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgClassSymbol * symbol = p_symbol_table->find_nontemplate_class(n,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_nontemplate_class(n,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_nontemplate_class(n,templateArgumentsList);
       }
     }

     return symbol;
   }

SgTemplateFunctionSymbol*
SgScopeStatement::lookup_template_function_symbol (const SgName& n, const SgType* t, SgTemplateParameterPtrList* templateParameterList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTemplateFunctionSymbol * symbol = p_symbol_table->find_template_function(n,t,templateParameterList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_template_function(n,t,templateParameterList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_template_function(n,t,templateParameterList);
       }
     }

     return symbol;
   }

SgTemplateVariableSymbol*
SgScopeStatement::lookup_template_variable_symbol(const SgName& n, SgTemplateParameterPtrList* templateParameterList, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTemplateVariableSymbol * symbol = p_symbol_table->find_template_variable(n, templateParameterList, templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_template_variable(n, templateParameterList, templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_template_variable(n, templateParameterList, templateArgumentsList);
       }
     }

     return symbol;
   }

SgFunctionSymbol*
SgScopeStatement::lookup_nontemplate_function_symbol (const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgFunctionSymbol * symbol = p_symbol_table->find_nontemplate_function(n,t,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_nontemplate_function(n,t,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_nontemplate_function(n,t,templateArgumentsList);
       }
     }

     return symbol;
   }

SgTemplateMemberFunctionSymbol*
SgScopeStatement::lookup_template_member_function_symbol (const SgName& n, const SgType* t, SgTemplateParameterPtrList* templateParameterList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgTemplateMemberFunctionSymbol * symbol = p_symbol_table->find_template_member_function(n,t,templateParameterList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_template_member_function(n,t,templateParameterList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_template_member_function(n,t,templateParameterList);
       }
     }

     return symbol;
   }


// SgMemberFunctionSymbol* SgScopeStatement::lookup_nontemplate_member_function_symbol (const SgName& n, const SgType* t) const
SgMemberFunctionSymbol*
SgScopeStatement::lookup_nontemplate_member_function_symbol (const SgName& n, const SgType* t, SgTemplateArgumentPtrList* templateArgumentsList) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgMemberFunctionSymbol * symbol = p_symbol_table->find_nontemplate_member_function(n,t,templateArgumentsList);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_nontemplate_member_function(n,t,templateArgumentsList);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_nontemplate_member_function(n,t,templateArgumentsList);
       }
     }

     return symbol;
   }

SgAliasSymbol*
SgScopeStatement::lookup_alias_symbol(const SgName& n, SgSymbol* sp) const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (p_symbol_table != NULL);

     SgAliasSymbol * symbol = p_symbol_table->find_aliased_symbol(n,sp);

     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
     if (symbol == NULL && namespaceDefinitionStatement != NULL)
        {
          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
          symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find_aliased_symbol(n,sp);
        }

     const SgGlobal * global_scope = isSgGlobal(this);
     if (symbol == NULL && global_scope != NULL) {
       SgProject * project = SageInterface::getProject(global_scope);
       if (project != NULL) {
         SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
         assert(globalScopeAcrossFiles != NULL);
         symbol = globalScopeAcrossFiles->get_symbol_table()->find_aliased_symbol(n,sp);
       }
     }

     return symbol;
   }

#define DEBUG__SgScopeStatement__find_symbol_from_declaration 0

template<class T>
SgSymbol * SgScopeStatement::find_symbol_from_declaration(const T* node) const {
#if DEBUG__SgScopeStatement__find_symbol_from_declaration
  printf("In SgScopeStatement::find_symbol_from_declaration():\n");
  printf("  this = %p : %s\n", this, this->class_name().c_str());
  printf("  node = %p : %s\n", node, node->class_name().c_str());
#endif
  assert (p_symbol_table != NULL);

  SgSymbol * symbol = p_symbol_table->find(node);
#if DEBUG__SgScopeStatement__find_symbol_from_declaration
  printf("  symbol = %p : %s\n", symbol, symbol ? symbol->class_name().c_str() : "");
#endif

  const SgNamespaceDefinitionStatement * namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);
  if (symbol == NULL && namespaceDefinitionStatement != NULL) {
    const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();
    ROSE_ASSERT(globalNamespaceDefinitionStatement != nullptr);
    symbol = globalNamespaceDefinitionStatement->get_symbol_table()->find(node);
  }
#if DEBUG__SgScopeStatement__find_symbol_from_declaration
  printf("  symbol = %p : %s\n", symbol, symbol ? symbol->class_name().c_str() : "");
#endif

  const SgGlobal * global_scope = isSgGlobal(this);
  if (symbol == NULL && global_scope != NULL) {
    SgProject * project = SageInterface::getProject(global_scope);
    if (project != NULL) {
      SgGlobal * globalScopeAcrossFiles = project->get_globalScopeAcrossFiles();
      assert(globalScopeAcrossFiles != NULL);
      symbol = globalScopeAcrossFiles->get_symbol_table()->find(node);
    }
  }
#if DEBUG__SgScopeStatement__find_symbol_from_declaration
  printf("  symbol = %p : %s\n", symbol, symbol ? symbol->class_name().c_str() : "");
#endif

  SgAliasSymbol * alias = isSgAliasSymbol(symbol);
  if (alias != NULL) {
    symbol = alias->get_alias();
    ROSE_ASSERT(!isSgAliasSymbol(symbol));
  }
#if DEBUG__SgScopeStatement__find_symbol_from_declaration
  printf("  symbol = %p : %s\n", symbol, symbol ? symbol->class_name().c_str() : "");
#endif

  return symbol;
}

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::first_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::first_variable_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::first_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_class();
   }
// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::first_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->find_function();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgTypedefSymbol*
SgScopeStatement::first_typedef_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_typedef();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgEnumSymbol*
SgScopeStatement::first_enum_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgEnumFieldSymbol*
SgScopeStatement::first_enum_field_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_enum_field();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgLabelSymbol*
SgScopeStatement::first_label_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_label();
   }

// DQ (2/1/2007): Added to ROSE to make the interface consistent.
SgNamespaceSymbol*
SgScopeStatement::first_namespace_symbol() const
   {
     ROSE_ASSERT (p_symbol_table != NULL);
     return p_symbol_table->find_namespace();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgSymbol*
SgScopeStatement::next_any_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_any();
   }

// DQ (9/7/2006): Previously removed functionality, restored by request from Beata at ANL.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgVariableSymbol*
SgScopeStatement::next_variable_symbol() const
   {
  // use this function after lookup_XXX_symbol(const SgName&) or after first_XXX_symbol()
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_variable();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgClassSymbol*
SgScopeStatement::next_class_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_class();
   }

// DQ (1/30/2007): Added these back into ROSE.
// DQ (5/22/2006): I would like to restrict support of a number of functions that I
// think are redundant with the simple lookup_symbol(const SgName& n) (above).
SgFunctionSymbol*
SgScopeStatement::next_function_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_function();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgTypedefSymbol*
SgScopeStatement::next_typedef_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_typedef();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumSymbol*
SgScopeStatement::next_enum_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgEnumFieldSymbol*
SgScopeStatement::next_enum_field_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_enum_field();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgLabelSymbol*
SgScopeStatement::next_label_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_label();
   }

// DQ (2/1/2007): Added new member function to ROSE.
SgNamespaceSymbol*
SgScopeStatement::next_namespace_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_namespace();
   }

// DQ (2/4/2007): Added new member function to ROSE.
SgTemplateSymbol*
SgScopeStatement::next_template_symbol() const
   {
     assert (p_symbol_table != NULL);
     return p_symbol_table->next_template();
   }




void
SgScopeStatement::print_symboltable( const std::string& str, ostream& os )
   {
     os << endl << "...SymTbl(" << str << ")... " << endl;
  // printf ("ERROR: not supported in SAGE 3 \n");
  // abort();
  // p_symbol_table->print(os);
     ROSE_ASSERT (p_symbol_table != NULL);
     p_symbol_table->print("Called from SgScopeStatement::print_symboltable",V_SgSymbol);
   }


void
SgScopeStatement::print_symboltable( const std::string& str, VariantT nodeType )
   {
     printf ("In SgScopeStatement::print_symboltable(label = %s): \n",str.c_str());
     ROSE_ASSERT (p_symbol_table != NULL);
     p_symbol_table->print("Called from SgScopeStatement::print_symboltable",nodeType);
   }


void
SgScopeStatement::print_symboltable( const std::string& str )
   {
     printf ("In SgScopeStatement::print_symboltable(label = %s): \n",str.c_str());
     ROSE_ASSERT (p_symbol_table != NULL);

#if 0
     p_symbol_table->print("Called from SgScopeStatement::print_symboltable",V_SgSymbol);
#else
  // DQ (3/5/2018): If this is a namespace then test to make sure we are inserting the symbol into the correct scope.
     const SgNamespaceDefinitionStatement* namespaceDefinitionStatement = isSgNamespaceDefinitionStatement(this);

     if (namespaceDefinitionStatement != NULL)
        {
          printf ("In SgScopeStatement::print_symboltable(): \n");
          printf ("   --- namespaceDefinitionStatement->get_symbol_table()->size()                          = %d \n",namespaceDefinitionStatement->get_symbol_table()->size());
          printf ("   --- namespaceDefinitionStatement->get_global_definition()->get_symbol_table()->size() = %d \n",namespaceDefinitionStatement->get_global_definition()->get_symbol_table()->size());
          printf ("Symbols: \n");

          ROSE_ASSERT(namespaceDefinitionStatement->get_global_definition() != NULL);
          const SgNamespaceDefinitionStatement* globalNamespaceDefinitionStatement = namespaceDefinitionStatement->get_global_definition();

          ROSE_ASSERT(namespaceDefinitionStatement != globalNamespaceDefinitionStatement);

          globalNamespaceDefinitionStatement->get_symbol_table()->print("Called from SgScopeStatement::print_symboltable",V_SgSymbol);
        }
       else
        {
       // Case of not a SgNamespaceDefinitionStatement.
          p_symbol_table->print("Called from SgScopeStatement::print_symboltable",V_SgSymbol);
        }
#endif

   }

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
bool
SgScopeStatement::containsOnlyDeclarations() const
   {
  // DQ (9/25/2009): This was a problem in an example reported by Keasler.
     ROSE_ASSERT(this != NULL);

  // All but two of the derived classes contain one or more list of SgStatements while two of them
  // contain a list of SgDeclarationStmt which complicates the design of a simple implementation of
  // functions that operate on scopes generally.
     bool returnValue = false;
     switch ( variantT() )
        {
       // DQ (9/5/2011): Added support for SgJavaLabelStatement
          case V_SgJavaLabelStatement:
       // charles4 (9/7/2011): Added support for SgJavaForEachStatement
          case V_SgJavaForEachStatement:

       // DQ (11/30/2007): Added more Fortran support.
          case V_SgAssociateStatement:

          case V_SgBasicBlock:
          case V_SgCatchOptionStmt:
          case V_SgDoWhileStmt:
          case V_SgForStatement:

       // DQ (3/26/2018): Added support for new C++11 IR node.
          case V_SgRangeBasedForStatement:

       // Liao, 6/17/2008, upc_forall
          case V_SgUpcForAllStatement:

          case V_SgFunctionDefinition:

       // DQ (11/27/2011): Adding more support for template declarations in the AST.
          case V_SgTemplateFunctionDefinition:

       // Rasmussen (11/12/2018): Support for Jovial COMPOOL module
          case V_SgJovialCompoolStatement:

       // Rasmussen (10/22/2018): Adding node specific to Jovial for statements with a then construct.
          case V_SgJovialForThenStatement:

      // SK (08/06/2015): Adding SgMatlabForStatement that represents Matlab for loop
          case V_SgMatlabForStatement:

          case V_SgIfStmt:
          case V_SgSwitchStatement:
          case V_SgWhileStmt:
          case V_SgFortranDo:
          case V_SgForAllStatement:
          case V_SgCAFWithTeamStatement: //FMZ (2/18/2009)
      // PP (05/11/20) - Ada support
          case V_SgAdaPackageBody:
          case V_SgAdaAcceptStmt:
          case V_SgAdaTaskBody:
          case V_SgAdaProtectedBody:
          case V_SgAdaGenericDecl:
          case V_SgAdaGenericInstanceDecl:
               returnValue = false;
               break;

       // DQ (6/11/2011): Added support for new Template IR nodes.
          case V_SgTemplateClassDefinition:

          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
          case V_SgGlobal:
          case V_SgFunctionParameterScope: // Rasmussen (09/24/2020): finishing implementation for Jovial
          case V_SgModuleStatement:
          case V_SgDeclarationScope:
      // PP (05/11/20) - Ada support
          case V_SgAdaPackageSpec:
          case V_SgAdaTaskSpec:
          case V_SgAdaProtectedSpec:
          case V_SgAdaGenericDefn:
               returnValue = true;
               break;

          default:
             printf ("ERROR: default reached in switch (SgScopeStatement::containsOnlyDeclarations() is called from a %s) \n",class_name().c_str());
               ROSE_ASSERT(false);
               break;
        }

     return returnValue;
   }


bool
SgScopeStatement::supportsDefiningFunctionDeclaration()
   {
  // DQ (10/18/2006): Not all scopes permit function declarations. Any function prototype in a
  // scope appropriate for a function definition triggers requirements for name qualification.
  // This function returns true if the scope is appropriate for the definition of a function
  // or member function (i.e. is a SgGlobal, SgClassDefinition, or SgNamespaceDefinitionStatement).

  // This is equivalent to the test for if the scope only permits declarations.
     return containsOnlyDeclarations();
   }


bool
SgScopeStatement::statementExistsInScope ( SgStatement* statement )
   {
  // DQ (6/26/2013): Added test for if this statement already exists in the current scope.
     ROSE_ASSERT(statement != NULL);

     bool result = false;
     if (containsOnlyDeclarations() == true)
        {
          SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatement* declarationStatement = isSgDeclarationStatement(statement);
          ROSE_ASSERT(declarationStatement != NULL);
          result = (find(declarationList.begin(),declarationList.end(),declarationStatement) != declarationList.end());
        }
       else
        {
          SgStatementPtrList & statementList = getStatementList();
          result = (find(statementList.begin(),statementList.end(),statement) != statementList.end());
        }

     return result;
   }


// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
void
SgScopeStatement::insertStatementInScope ( SgStatement* newTransformationStatement, bool atTop )
   {
  // Put the new statement at the front (without regard to any dependencies on declared types)

  // We have only debugged this case so far
  // ROSE_ASSERT (atTop == true);

#if 0
     printf ("SgScopeStatement::insertStatementInScope(): newTransformationStatement = %p = %s atTop = %s \n",
          newTransformationStatement,newTransformationStatement->class_name().c_str(),atTop ? "true" : "false");
#endif

     bool inFront = (atTop == true);
     SgScopeStatement* currentScope = this;
     if (atTop == true)
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::iterator declaration = declarationList.begin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

            // DQ (6/26/2013): Added test for if this statement already exists in the current scope (declaration list).
               ROSE_ASSERT(find(declarationList.begin(),declarationList.end(),newDeclarationStatement) == declarationList.end());

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newDeclarationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);

#if 0
               printf ("Exiting after call to insert_statement in $CLASSNAME::insertStatementInScope() \n");
               ROSE_ASSERT(false);
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::iterator statement = statementList.begin();

            // DQ (12/29/2015): Added more debugging info.
               if (find(statementList.begin(),statementList.end(),newTransformationStatement) != statementList.end())
                  {
                    printf ("ERROR: already present in scope: newTransformationStatement = %p = %s \n",newTransformationStatement,newTransformationStatement->class_name().c_str());
                  }

            // DQ (6/26/2013): Added test for if this statement already exists in the current scope (declaration list).
               ROSE_ASSERT(find(statementList.begin(),statementList.end(),newTransformationStatement) == statementList.end());

               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ASSERT_not_null(*statement);
                    insert_statement (*statement,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
        }
       else
        {
          if (currentScope->containsOnlyDeclarations() == true)
             {
               SgDeclarationStatementPtrList & declarationList = currentScope->getDeclarationList();
               SgDeclarationStatementPtrList::reverse_iterator declaration = declarationList.rbegin();
               ROSE_ASSERT ( isSgDeclarationStatement(newTransformationStatement) != NULL );
               SgDeclarationStatement* newDeclarationStatement = isSgDeclarationStatement(newTransformationStatement);

               ROSE_ASSERT(newDeclarationStatement != NULL);

            // DQ (6/26/2013): Added test for if this statement already exists in the current scope (declaration list).
               ROSE_ASSERT(find(declarationList.begin(),declarationList.end(),newDeclarationStatement) == declarationList.end());

               unsigned oldSize = declarationList.size();
            // if (declarationList.size() == 0)
               if (declarationList.empty() == true)
                  {
                 // append_declaration(newTransformationStatement);
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newDeclarationStatement->set_parent(currentScope);
#endif
                 // printf ("Case declarationList.size() == 0: parent of newDeclarationStatement may not be set properly (same for scope) \n");
                    declarationList.push_back(newDeclarationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newDeclarationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ROSE_ASSERT ( *declaration != NULL );
                    insert_statement (*declaration,newTransformationStatement,inFront);

                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
               ROSE_ASSERT (declarationList.size() == oldSize+1);

            // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
               ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
#if 0
               printf ("Exiting after call to insert_statement in $CLASSNAME::insertStatementInScope() \n");
               ROSE_ASSERT(false);
#endif
             }
            else
             {
               SgStatementPtrList & statementList = currentScope->getStatementList();
               SgStatementPtrList::reverse_iterator statement = statementList.rbegin();

            // DQ (12/29/2015): Added more debugging info.
               if (find(statementList.begin(),statementList.end(),newTransformationStatement) != statementList.end())
                  {
                    printf ("ERROR: already present in scope: newTransformationStatement = %p = %s \n",newTransformationStatement,newTransformationStatement->class_name().c_str());
                  }

            // DQ (6/26/2013): Added test for if this statement already exists in the current scope (declaration list).
               ROSE_ASSERT(find(statementList.begin(),statementList.end(),newTransformationStatement) == statementList.end());

               if (statementList.empty() == true)
                  {
#ifndef REMOVE_SET_PARENT_FUNCTION
                    newTransformationStatement->set_parent(currentScope);
#endif
                 // printf ("Case statementList.size() == 0: parent of newTransformationStatement may not be set properly (same for scope) \n");
                    statementList.push_back(newTransformationStatement);

                 // DQ (6/24/2006): We have to handle this case explicitly
                    newTransformationStatement->set_parent(currentScope);
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
                 else
                  {
                    ASSERT_not_null(*statement);
#if 0
                    printf ("In SgScopeStatement::insertStatementInScope(): calling insert_statement(): this = %p = %s \n",this,this->class_name().c_str());
                    SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(this);
                    if (functionDefinition != NULL)
                       {
                         printf (" --- functionDefinition->get_body() = %p \n",functionDefinition->get_body());
                       }

                    printf (" --- *statement                 = %p = %s \n",*statement,(*statement)->class_name().c_str());
                    printf (" --- newTransformationStatement = %p = %s \n",newTransformationStatement,newTransformationStatement->class_name().c_str());
                    printf (" --- inFront                    = %s \n",inFront ? "true" : "false");
#endif
#if 1
                 // DQ (3/27/2021): The base class implementation of insert_statement is being called by mistake, use the this poitner explicitly.
                    insert_statement (*statement,newTransformationStatement,inFront);
#else
                    if (functionDefinition != NULL)
                       {
#if 1
                         printf ("Found functionDefinition, so insert new statement into the function body \n");
#endif
                         SgBasicBlock* body = functionDefinition->get_body();
                         ROSE_ASSERT(body != NULL);
#if 1
                         printf ("Skipping call to body->insert_statement \n");
#endif
                      // DQ (3/28/2021): Set the parent to pass the assertion below.
                         newTransformationStatement->set_parent(body);
                       }
                      else
                       {
                         this->insert_statement (*statement,newTransformationStatement,inFront);
                       }
#endif
                 // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
                    ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
                  }
             }
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(newTransformationStatement->get_parent() != NULL);
   }


// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList ()
// $CLASSNAME::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
       // DQ (6/11/2011): Added support for new template IR nodes.
          case V_SgTemplateClassDefinition:
          case V_SgClassDefinition:
             {
               SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
               currentStatementList = &(classDefinitionScope->get_members());
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
               currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               break;
             }

          case V_SgGlobal:
             {
               SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
               currentStatementList = &(globalScope->get_declarations());
               break;
             }

          case V_SgAdaTaskSpec:
             {
               SgAdaTaskSpec* taskScope = isSgAdaTaskSpec(currentScope);
               ROSE_ASSERT (taskScope != NULL);
               currentStatementList = &(taskScope->get_declarations());
               break;
             }

          case V_SgAdaProtectedSpec:
             {
               SgAdaProtectedSpec* protectedScope = isSgAdaProtectedSpec(currentScope);
               ROSE_ASSERT (protectedScope != NULL);
               currentStatementList = &(protectedScope->get_declarations());
               break;
             }

          case V_SgAdaPackageSpec:
             {
               SgAdaPackageSpec* pkgScope = isSgAdaPackageSpec(currentScope);
               ROSE_ASSERT (pkgScope != NULL);
               currentStatementList = &(pkgScope->get_declarations());
               break;
             }

          case V_SgAdaGenericDefn:
             {
               SgAdaGenericDefn* defn = isSgAdaGenericDefn(currentScope);
               ROSE_ASSERT (defn != NULL);
               currentStatementList = &(defn->get_declarations());
               break;
             }

          case V_SgFunctionParameterScope:
             {
               SgFunctionParameterScope* paramScope = isSgFunctionParameterScope(currentScope);
               ROSE_ASSERT (paramScope != NULL);
               currentStatementList = &(paramScope->get_declarations());
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
               currentStatementList = &(namespaceScope->get_declarations());
               break;
             }
#if 1
          case V_SgNonrealDecl:
          case V_SgDeclarationScope:
             {
            // TV (09/16/2018): (ROSE-1378) TODO
               ROSE_ASSERT(!"ROSE-1378");
               break;
             }
#endif
          default:
               printf ("ERROR: default reached in switch (getDeclarationList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     return *currentStatementList;
   }

const SgDeclarationStatementPtrList &
SgScopeStatement::getDeclarationList () const
// $CLASSNAME::getDeclarationList ( SgScopeStatement* currentScope )
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

  // SgDeclarationStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
       // DQ (6/11/2011): Added support for new template IR nodes.
          case V_SgTemplateClassDefinition:
          case V_SgClassDefinition:
             {
               const SgClassDefinition* classDefinitionScope = isSgClassDefinition(currentScope);
               ROSE_ASSERT (classDefinitionScope != NULL);
            // currentStatementList = &(classDefinitionScope->get_members());
               return classDefinitionScope->get_members();
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               const SgTemplateInstantiationDefn* templateInstantiationDefinitionScope = isSgTemplateInstantiationDefn(currentScope);
               ROSE_ASSERT (templateInstantiationDefinitionScope != NULL);
            // currentStatementList = &(templateInstantiationDefinitionScope->get_members());
               return templateInstantiationDefinitionScope->get_members();
               break;
             }

          case V_SgGlobal:
             {
               const SgGlobal* globalScope = isSgGlobal(currentScope);
               ROSE_ASSERT (globalScope != NULL);
               return globalScope->get_declarations();
               break;
             }

          case V_SgAdaTaskSpec:
             {
               const SgAdaTaskSpec* taskScope = isSgAdaTaskSpec(currentScope);
               ROSE_ASSERT (taskScope != NULL);
               return taskScope->get_declarations();
               break;
             }

          case V_SgAdaProtectedSpec:
             {
               const SgAdaProtectedSpec* protectedScope = isSgAdaProtectedSpec(currentScope);
               ROSE_ASSERT (protectedScope != NULL);
               return protectedScope->get_declarations();
               break;
             }

          case V_SgAdaPackageSpec:
             {
               const SgAdaPackageSpec* pkgScope = isSgAdaPackageSpec(currentScope);
               ROSE_ASSERT (pkgScope != NULL);
               return pkgScope->get_declarations();
               break;
             }

          case V_SgAdaGenericDefn:
             {
               const SgAdaGenericDefn* genericDefn = isSgAdaGenericDefn(currentScope);
               ROSE_ASSERT (genericDefn != NULL);
               return genericDefn->get_declarations();
               break;
             }

          case V_SgFunctionParameterScope:
             {
               const SgFunctionParameterScope* paramScope = isSgFunctionParameterScope(currentScope);
               ROSE_ASSERT (paramScope != NULL);
               return paramScope->get_declarations();
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               const SgNamespaceDefinitionStatement* namespaceScope = isSgNamespaceDefinitionStatement(currentScope);
               ROSE_ASSERT (namespaceScope != NULL);
            // currentStatementList = &(namespaceScope->get_declarations());
               return namespaceScope->get_declarations();
               break;
             }

          case V_SgNonrealDecl:
          case V_SgDeclarationScope:
             {
            // TV (09/16/2018): (ROSE-1378) TODO
               ROSE_ASSERT(!"ROSE-1378");
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getDeclarationList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
     static SgDeclarationStatementPtrList defaultList;
     return defaultList;
   }

// DQ (7/17/2002) Added to support rewrite mechanism some scopes can only contain
// SgDeclarationStmt while others can contain any kind of SgStatement
SgStatementPtrList &
SgScopeStatement::getStatementList ()
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
               currentStatementList = &(basicBlock->get_statements());
               break;
             }

          case V_SgCatchOptionStmt:
             {
               SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfCatch(catchOptionScope)->getStatementList());
               break;
             }

       // DQ (6/11/2011): Added support for new template IR nodes.
          case V_SgTemplateClassDefinition:
       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfDoWhile(doWhileScope)->getStatementList());
               break;
             }

          case V_SgForStatement:
             {
               SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
            // Liao, 9/29/2008, This function could be called during parsing and
            // the loop body is not yet filled up
            //   ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfFor(forScope)->getStatementList());
               break;
             }

       // DQ (11/27/2011): Adding more support for template declarations in the AST.
          case V_SgTemplateFunctionDefinition:
          case V_SgFunctionDefinition:
             {
               SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
               currentStatementList = &(functionScope->get_body()->getStatementList());
               break;
             }

          case V_SgAdaAcceptStmt:
             {
               ROSE_ASSERT(!"SgAdaAcceptStmt may not have a statement list! (use generateStatementList() to form copy of merges lists)");
              /*
               SgAdaAcceptStmt* adanode = isSgAdaAcceptStmt(currentScope);
               ROSE_ASSERT(adanode && adanode->get_body());

               currentStatementList = &adanode->get_body()->getStatementList();
              */
               break;
             }

          case V_SgAdaPackageBody:
             {
               SgAdaPackageBody* adabody = isSgAdaPackageBody(currentScope);
               ROSE_ASSERT(adabody);

               currentStatementList = &(adabody->get_statements());
               break;
             }

          case V_SgAdaTaskBody:
             {
               SgAdaTaskBody* adabody = isSgAdaTaskBody(currentScope);
               ROSE_ASSERT(adabody);

               currentStatementList = &(adabody->get_statements());
               break;
             }

          case V_SgAdaProtectedBody:
             {
               SgAdaProtectedBody* adabody = isSgAdaProtectedBody(currentScope);
               ROSE_ASSERT(adabody);

               currentStatementList = &(adabody->get_statements());
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");

               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() return value not defined for SgIfStmt containing true and false bodies (use generateStatementList() to form copy of merges lists) \n");
               printf ("NOTE: This error has been generated when C99 code was incorrectly assumed to be C89 (e.g. compiled without the correct flag) code (see test2012_104.c on edg4x branch)\n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() called by mistake, use SgScopeStatement::getDeclarationList() instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfSwitch(switchStatement)->getStatementList());
               break;
             }

          case V_SgWhileStmt:
             {
               SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
               currentStatementList = &(SageInterface::ensureBasicBlockAsBodyOfWhile(whileStatement)->getStatementList());
               break;
             }

          case V_SgFortranDo:
             {
               SgFortranDo* doStatement = isSgFortranDo(currentScope);
               ROSE_ASSERT (doStatement != NULL);
               ROSE_ASSERT (doStatement->get_body() != NULL);
               currentStatementList = &(doStatement->get_body()->getStatementList());
               break;
             }

       // Rasmussen (10/22/2018): Adding node specific to Jovial for statements with a then construct.
          case V_SgJovialForThenStatement:
             {
               SgJovialForThenStatement* forStatement = isSgJovialForThenStatement(currentScope);
               ROSE_ASSERT (forStatement != NULL);
               ROSE_ASSERT (forStatement->get_loop_body() != NULL);
               currentStatementList = &(forStatement->get_loop_body()->getStatementList());
               break;
             }

       //SK(08/06/2015): Adding support for MatlabForStatement:
          case V_SgMatlabForStatement:
              {
                SgMatlabForStatement *matlabForStatement = isSgMatlabForStatement(currentScope);
                ROSE_ASSERT(matlabForStatement != NULL);
                ROSE_ASSERT (matlabForStatement->get_body() != NULL);

                currentStatementList = &(matlabForStatement->get_body()->getStatementList());
                break;
              }

          default:
               printf ("ERROR: default reached in switch (getStatementList()) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     return *currentStatementList;
   }


// DQ (10/6/2007): Added const version of this function to support const version of generateStatementList()
const SgStatementPtrList &
SgScopeStatement::getStatementList () const
   {
  // Supporting function for SynthesizedAttributeBaseClassType::insertAtTopOfScope().  This should
  // perhaps be moved to the SgScopeStatement object at some point.

  // If this were a virtual member function then this would be far simpler :-).

     const SgScopeStatement* currentScope = this;
     ROSE_ASSERT (currentScope != NULL);

     static const SgStatementPtrList emptyStatementList;

  // SgStatementPtrList* currentStatementList = NULL;
     switch ( currentScope->variantT() )
        {
          case V_SgBasicBlock:
             {
               const SgBasicBlock* basicBlock = isSgBasicBlock(currentScope);
               ROSE_ASSERT (basicBlock != NULL);
            // currentStatementList = &(basicBlock->get_statements());
               return basicBlock->get_statements();
               break;
             }

          case V_SgCatchOptionStmt:
             {
               const SgCatchOptionStmt* catchOptionScope = isSgCatchOptionStmt(currentScope);
               ROSE_ASSERT (catchOptionScope != NULL);
               ROSE_ASSERT (catchOptionScope->get_body() != NULL);
            // currentStatementList = &(catchOptionScope->get_body()->getStatementList());
               return isSgBasicBlock(catchOptionScope->get_body()) ? isSgBasicBlock(catchOptionScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }

       // DQ (6/11/2011): Added support for new template IR nodes.
          case V_SgTemplateClassDefinition:
       // DQ (1/30/2007): Added this case!
          case V_SgClassDefinition:
             {
               printf ("case SgClassDefinition in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgDoWhileStmt:
             {
               const SgDoWhileStmt* doWhileScope = isSgDoWhileStmt(currentScope);
               ROSE_ASSERT (doWhileScope != NULL);
               ROSE_ASSERT (doWhileScope->get_body() != NULL);
            // currentStatementList = &(doWhileScope->get_body()->getStatementList());
               return isSgBasicBlock(doWhileScope->get_body()) ? isSgBasicBlock(doWhileScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgForStatement:
             {
               const SgForStatement* forScope = isSgForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

       // DQ (3/26/2018): Added support for new C++11 IR node.
          case V_SgRangeBasedForStatement:
             {
               const SgRangeBasedForStatement* forScope = isSgRangeBasedForStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgJavaForEachStatement:
             {
               const SgJavaForEachStatement* forScope = isSgJavaForEachStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // charles4: 9/07/2011
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

       // Liao, 6/17/2008, upc_forall statement
          case V_SgUpcForAllStatement:
             {
               const SgUpcForAllStatement* forScope = isSgUpcForAllStatement(currentScope);
               ROSE_ASSERT (forScope != NULL);
               ROSE_ASSERT (forScope->get_loop_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return isSgBasicBlock(forScope->get_loop_body()) ? isSgBasicBlock(forScope->get_loop_body())->getStatementList() : emptyStatementList;
               break;
             }

       // DQ (11/27/2011): Adding more support for template declarations in the AST.
          case V_SgTemplateFunctionDefinition:
          case V_SgFunctionDefinition:
             {
               const SgFunctionDefinition* functionScope = isSgFunctionDefinition(currentScope);
               ROSE_ASSERT (functionScope != NULL);
               ROSE_ASSERT (functionScope->get_body() != NULL);
            // currentStatementList = &(functionScope->get_body()->getStatementList());
               return functionScope->get_body()->getStatementList();
               break;
             }

          case V_SgAdaAcceptStmt:
             {
               const SgAdaAcceptStmt* adanode = isSgAdaAcceptStmt(currentScope);
               ROSE_ASSERT(adanode && adanode->get_body());

               const SgBasicBlock*    block = isSgBasicBlock(adanode->get_body());

               return block ? block->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgAdaPackageBody:
             {
               const SgAdaPackageBody* adabody = isSgAdaPackageBody(currentScope);
               ROSE_ASSERT(adabody);

               return adabody->get_statements();
               break;
             }

          case V_SgAdaTaskBody:
             {
               const SgAdaTaskBody* adabody = isSgAdaTaskBody(currentScope);
               ROSE_ASSERT(adabody);

               return adabody->get_statements();
               break;
             }

          case V_SgAdaProtectedBody:
             {
               const SgAdaProtectedBody* adabody = isSgAdaProtectedBody(currentScope);
               ROSE_ASSERT(adabody);

               return adabody->get_statements();
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgTemplateInstantiationDefn:
             {
               printf ("case SgTemplateInstantiationDefn in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgGlobal:
             {
               printf ("case SgGlobal in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");

               ROSE_ASSERT(false);
               break;
             }

          case V_SgIfStmt:
             {
               const SgIfStmt* ifStatement = isSgIfStmt(currentScope);
               ROSE_ASSERT (ifStatement != NULL);

#if 0
            // Merge the different lists from the true and false blocks (this might not
            // provide the correct semantics for some uses of the final list).
               ROSE_ASSERT (ifStatement->true_body() != NULL);
               currentStatementList  =  new SgStatementPtrList (ifStatement->true_body()->getStatementList());
               ROSE_ASSERT (ifStatement->false_body() != NULL);
               currentStatementList->merge(ifStatement->false_body()->getStatementList());
#endif

               printf ("getStatementList() const return value not defined for SgIfStmt containing true and false bodies (use generateStatementList() const to form copy of merges lists) \n");
               ROSE_ASSERT(false);
               break;
             }

       // DQ (1/30/2007): Added this case!
          case V_SgNamespaceDefinitionStatement:
             {
               printf ("case SgNamespaceDefinitionStatement in SgScopeStatement::getStatementList() const called by mistake, use SgScopeStatement::getDeclarationList() const instead. \n");
               printf ("     this scope contains a list of SgDeclarationStatement objects not a list of SgStatement objects (critical difference since we return a reference to the internal list \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgSwitchStatement:
             {
               const SgSwitchStatement* switchStatement = isSgSwitchStatement(currentScope);
               ROSE_ASSERT (switchStatement != NULL);
               ROSE_ASSERT (switchStatement->get_body() != NULL);
            // currentStatementList = &(switchStatement->get_body()->getStatementList());
               return (isSgBasicBlock(switchStatement->get_body()) != NULL) ? isSgBasicBlock(switchStatement->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgWhileStmt:
             {
               const SgWhileStmt* whileStatement = isSgWhileStmt(currentScope);
               ROSE_ASSERT (whileStatement != NULL);
               ROSE_ASSERT (whileStatement->get_body() != NULL);
            // currentStatementList = &(whileStatement->get_body()->getStatementList());
               return (isSgBasicBlock(whileStatement->get_body()) != NULL) ? isSgBasicBlock(whileStatement->get_body())->getStatementList() : emptyStatementList;
               break;
             }

          case V_SgAssociateStatement:
             {
            // Not clear if we should include the list of SgVariableDeclarations in this list or not!
               const SgAssociateStatement* associateStatement = isSgAssociateStatement(currentScope);
               ROSE_ASSERT (associateStatement != NULL);
               ROSE_ASSERT (associateStatement->get_body() != NULL);
               return associateStatement->get_body()->getStatementList();
               break;
             }

          case V_SgFortranDo:
             {
               const SgFortranDo* doStatement = isSgFortranDo(currentScope);
               ROSE_ASSERT (doStatement != NULL);
               ROSE_ASSERT (doStatement->get_body() != NULL);
               return doStatement->get_body()->getStatementList();
               break;
             }

          case V_SgJovialForThenStatement:
             {
               const SgJovialForThenStatement* forStatement = isSgJovialForThenStatement(currentScope);
               ROSE_ASSERT (forStatement != NULL);
               ROSE_ASSERT (forStatement->get_loop_body() != NULL);
               return forStatement->get_loop_body()->getStatementList();
               break;
             }

  case V_SgMatlabForStatement:
      {
        const SgMatlabForStatement *matlabForStatement = isSgMatlabForStatement(currentScope);
        ROSE_ASSERT(matlabForStatement != NULL);
        ROSE_ASSERT(matlabForStatement->get_body() != NULL);

        return matlabForStatement->get_body()->getStatementList();
        break;
      }

          case V_SgForAllStatement:
             {
               const SgForAllStatement* forAllScope = isSgForAllStatement(currentScope);
               ROSE_ASSERT (forAllScope != NULL);
               ROSE_ASSERT (forAllScope->get_body() != NULL);
            // Should this be defined given that there are two SgBasicBlock objects in a SgForStatement
            // currentStatementList = forScope->get_init_stmt();
            // currentStatementList = &(forScope->get_loop_body()->getStatementList());
               return forAllScope->get_body()->getStatementList();
               break;
             }

       // FMZ (CoArray with team)
          case V_SgCAFWithTeamStatement:
             {
               const SgCAFWithTeamStatement* teamScope = isSgCAFWithTeamStatement(currentScope);
               ROSE_ASSERT (teamScope != NULL);
               ROSE_ASSERT (teamScope->get_body() != NULL);
               return isSgBasicBlock(teamScope->get_body()) ? isSgBasicBlock(teamScope->get_body())->getStatementList() : emptyStatementList;
               break;
             }

       // DQ (9/5/2011): Added support for SgJavaLabelStatement, but not certain if this is correct implementation.
          case V_SgJavaLabelStatement:
             {
               const SgJavaLabelStatement* javaLabelStatement = isSgJavaLabelStatement(currentScope);
               ROSE_ASSERT (javaLabelStatement != NULL);
               return isSgBasicBlock(javaLabelStatement->get_statement()) ? isSgBasicBlock(javaLabelStatement->get_statement())->getStatementList() : emptyStatementList;
               break;
             }

          default:
               printf ("ERROR: default reached in switch (getStatementList() const) currentScope = %s \n",currentScope->sage_class_name());
               printf ("Note: this function is not defined for all IR nodes derived from SgScopeStatement (use SgScopeStatement::containsOnlyDeclarations() to check)\n");
               ROSE_ASSERT(false);
               break;
        }

     printf ("This should be unreachable code! \n");
     ROSE_ASSERT(false);
  // return *currentStatementList;
  // return SgStatementPtrList();
     static SgStatementPtrList defaultList;
     return defaultList;
   }


const SgStatementPtrList
SgScopeStatement::generateStatementList() const
   {
  // This function permits access to the statements or declarations as a list of statements
  // since declarations are derived from statements.  This function generates a copy of the
  // list in both cases (symmetrically for both types).

#if 0
     printf ("In $CLASSNAME::generateStatementList() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif


     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
               returnList.push_back(*i);

          ROSE_ASSERT (returnList.size() == declarationList.size());

#if 0
       // error checking
          const SgStatementPtrList::const_iterator j = returnList.begin();
          for (i = declarationList.begin(); i != declarationList.end(); i++)
             {
               ROSE_ASSERT ( (*i) == (*j) );
               printf ("     declaration = %s \n",(*i)->unparseToString().c_str());
               j++;
             }
#endif
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list)
          const SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               if (isSgScopeStatement(ifStatement->get_true_body()))
                  {
                    returnList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                  }
               if (isSgScopeStatement(ifStatement->get_false_body()))
                  {
                    const SgStatementPtrList& falseList = isSgScopeStatement(ifStatement->get_false_body())->getStatementList();
                    returnList.insert(returnList.end(), falseList.begin(), falseList.end());
                  }
             }
            else
             {
               returnList = getStatementList();
             }
        }

  // printf ("In generateStatementList(): returnList.size() = %" PRIuPTR " \n",returnList.size());

     return returnList;
   }

unsigned int
SgScopeStatement::generateUniqueStatementNumberForScope( SgStatement* statement )
   {
     unsigned int counter = 0;
     bool found = this->generateUniqueStatementNumberForScopeHelper(counter, statement);
     ROSE_ASSERT (found);
     return counter;
   }

bool
SgScopeStatement::generateUniqueStatementNumberForScopeHelper(unsigned int& counter, SgStatement* statement)
   {
  // DQ (2/20/2007): This function supports the AST merge mechanism, but is general
  // and may be useful for the mangled name generation in the future.

  // This function generates a unique number for each statement in the scope by returning
  // its position value countered from the top of the list of statements of declarations.
  // It is used in the AST merge within the mechanism to generate unique names for both
  // un-named enums and class declarations and template declarations of overloaded
  // functions in a templated class (since at the point of instantiation of the outer class
  // the names of any overloaded functions are all the same).  The value of returned
  // by this function should only be relied upon to be unique for the given scope (nothing more).
  // This function may be useful for naming unnamed scopes such as though in loop constructs.

#if 0
     printf ("In SgScopeStatement::generateUniqueStatementNumberForScope() containsOnlyDeclarations() = %s \n",
          containsOnlyDeclarations() ? "true" : "false");
#endif

     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatement* declaration = isSgDeclarationStatement(statement);
          ROSE_ASSERT(declaration != NULL);

          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          SgDeclarationStatementPtrList::const_iterator i = declarationList.begin();
          while ( (i != declarationList.end()) && ( (*i)->get_definingDeclaration() != declaration->get_definingDeclaration()) )
             {
               printf ("counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
               counter++;
               i++;
             }

          if (i == declarationList.end())
             {
               printf ("statement = %p = %s not found in scope (declaration list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
               return false;
             }
            else
             {
               printf ("END: counter = %d *i = %p = %s defining declaration = %p statement = %p = %s statement defining declaration = %p \n",
                    counter,*i,(*i)->class_name().c_str(),(*i)->get_definingDeclaration(),statement,statement->class_name().c_str(),declaration->get_definingDeclaration());
               return true;
             }

        }
       else
        {
       // Handle special case of two lists in a single statement (just add the 2nd list to the 1st result)
          SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
               // The calls to generateUniqueStatementNumberForScopeHelper both
               // increment the counter for the number of nested statements
               // found in their respective regions of the program.
               // Note that the condition of the if is not checked -- this
               // matches the previous behavior, but may not be correct.
               bool foundTrue = false;
               if (isSgBasicBlock(ifStatement->get_true_body())) {
                 foundTrue = isSgBasicBlock(ifStatement->get_true_body())->generateUniqueStatementNumberForScopeHelper(counter, statement);
               } else {
                 foundTrue = (statement == ifStatement->get_true_body());
                 if (!foundTrue) ++counter;
               }
               if (foundTrue) {
                 return true;
               } else {
                 bool foundFalse = false;
                 if (isSgBasicBlock(ifStatement->get_false_body())) {
                   foundFalse = isSgBasicBlock(ifStatement->get_false_body())->generateUniqueStatementNumberForScopeHelper(counter, statement);
                 } else {
                   foundFalse = (statement != NULL && statement == ifStatement->get_false_body());
                   if (!foundFalse) ++counter;
                 }
                 if (foundFalse) {
                   return true;
                 } else {
                   return false;
                 }
               }
             }
            else
             {
               const SgStatementPtrList & statementList = getStatementList();
               SgStatementPtrList::const_iterator i = statementList.begin();
               while ( (i != statementList.end()) && (*i != statement) )
                  {
                    counter++;
                    i++;
                  }

               if (i == statementList.end())
                  {
                    printf ("statement = %p = %s not found in scope (statement list) = %p = %s \n",statement,statement->class_name().c_str(),this,this->class_name().c_str());
                    ROSE_ASSERT(counter == statementList.size());
                  }
             }
        }

     printf ("In generateUniqueStatementNumberForScope(): counter = %u \n",counter);

     return counter;
   }

SgStatement*
SgScopeStatement::firstStatement() const
   {
     SgStatement* first = NULL;

#if 0
  // DQ (5/27/2019): Need to handle the case where this is a scope containing declaration statements, this code does not do this.
     const SgStatementPtrList & statementList = getStatementList();

     if (statementList.empty() == false)
          first = *(statementList.begin());
#else
  // DQ (5/27/2019): This code handles the case where this is a scope containing declaration statements.
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          if (declarationList.empty() == false)
               first = *(declarationList.begin());
        }
       else
        {
          const SgStatementPtrList & statementList = getStatementList();

          if (statementList.empty() == false)
               first = *(statementList.begin());
        }
#endif

     return first;
   }

SgStatement*
SgScopeStatement::lastStatement() const
   {
     SgStatement* last = NULL;

#if 0
     const SgStatementPtrList & statementList = getStatementList();
     if (statementList.empty() == false)
          last = *(statementList.rbegin());
#else
  // This function has to handle the details of looking for the last statement dependent
  // upon if the scope contains a list of SgDeclarationStatement or SgStatement.
     SgStatementPtrList returnList;
     if (containsOnlyDeclarations() == true)
        {
          const SgDeclarationStatementPtrList & declarationList = getDeclarationList();
          if (declarationList.empty() == false)
               last = *(declarationList.rbegin());
        }
       else
        {
       // Handle special case of two lists in a single statement (just append the 2nd list to the 1st list)
          const SgIfStmt* ifStatement = isSgIfStmt(this);
          if (ifStatement != NULL)
             {
            // Both the true and false bodies can be either a SgBasicBlock or any SgStatement.
            // NOTE: If the false body is empty then use the last statement of the true body.
            // Having an empty false body is a common normalization within the IR, though less
            // so for C/C++ recently and more for Fortrna (as I recall).
               SgScopeStatement* ifScopeFalseBody = isSgScopeStatement(ifStatement->get_false_body());
               if (ifScopeFalseBody != NULL && ifScopeFalseBody->getStatementList().empty() == false)
                  {
                 // const SgStatementPtrList& falseList = isSgScopeStatement(ifStatement->get_false_body())->getStatementList();
                 // returnList.insert(returnList.end(), falseList.begin(), falseList.end());
                    const SgStatementPtrList & statementList = ifScopeFalseBody->getStatementList();
#if 1
                    ROSE_ASSERT (statementList.empty() == false);
                    last = *(statementList.rbegin());
#else
                    if (statementList.empty() == false)
                       {
                         last = *(statementList.rbegin());
                       }
                      else
                       {
                      // I think that this path should not be possible!
                         printf ("ERROR: false branch statementList.empty() == true \n");
                         ROSE_ASSERT(false);
                       }
#endif
                  }
                 else
                  {
                    SgStatement* falseStatement = ifStatement->get_false_body();
                    if (falseStatement != NULL)
                       {
                         last = falseStatement;
                       }
                      else
                       {
                      // If there is no false body then we have to look at the bottom of the true body.
                      // Both the true and false bodies can be either a SgBasicBlock or any SgStatement.
                         if (isSgScopeStatement(ifStatement->get_true_body()) != NULL)
                            {
                           // returnList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                              const SgStatementPtrList & statementList = isSgScopeStatement(ifStatement->get_true_body())->getStatementList();
                              if (statementList.empty() == false)
                                 {
                                   last = *(statementList.rbegin());
                                 }
                                else
                                 {
                                   printf ("ERROR: true branch statementList.empty() == true \n");
                                   ROSE_ASSERT(false);
                                 }
                            }
                           else
                            {
                              SgStatement* trueStatement = ifStatement->get_true_body();
                              last = trueStatement;
                            }

                         ROSE_ASSERT(last != NULL);
                       }

                    ROSE_ASSERT(last != NULL);
                  }

               ROSE_ASSERT(last != NULL);
             }
            else
             {
            // returnList = getStatementList();
               const SgStatementPtrList & statementList = getStatementList();
               if (statementList.empty() == false)
                    last = *(statementList.rbegin());
             }
        }
#endif

     return last;
   }

bool
SgScopeStatement::isCaseInsensitive() const
   {
  // Case sensitive scopes are for C/C++ and case insensitive scopes are for Fortran.
  // The case sensitive behavior is property of the symbol table only, but it represented
  // in the scope API to be consistatn with the symbol table handling API being presented
  // at the scope level (SgScopeStatment).

     ROSE_ASSERT(p_symbol_table != NULL);
     return p_symbol_table->isCaseInsensitive();
   }

void
SgScopeStatement::setCaseInsensitive(bool b)
   {
  // Case sensitive scopes are for C/C++ and case insensitive scopes are for Fortran.
  // The case sensitive behavior is property of the symbol table only, but it represented
  // in the scope API to be consistatn with the symbol table handling API being presented
  // at the scope level (SgScopeStatment).

     ROSE_ASSERT(p_symbol_table != NULL);
     p_symbol_table->setCaseInsensitive(b);
   }


bool
SgScopeStatement::isNamedScope()
   {
  // DQ (5/11/2011): Added support for new name qualification.  If this is associated with
  // a scope that has a name then return true, else false. This is used to support the name
  // qualification.

     bool result = false;
     switch (this->variantT())
        {
       // Though it might seem incorrect, since functions have names, the SgFunctionDefinition
       // is not a named scope for purposes of name qualification.
       // case SgFunctionDefinition:

          case V_SgBasicBlock:
             {
            // A SgBasicBlock is used inside of a few declarations to define a new scope.
            // This for this case, the enum can't nest other scopes. But field values can
            // be qualified, so this is a named scope when it is used in an SgEnumDeclaration.
               SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(this->get_parent());
               if (enumDeclaration != NULL)
                  {
                    result = true;
                  }
               break;
             }

       // case V_SgGlobal:  // global has the name "::" but it does not have an associated declaration.

       // DQ (11/27/2011): Adding more support for template declarations in the AST.
          case V_SgTemplateClassDefinition:

          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
             {
               result = true;
               break;
             }

          case V_SgDeclarationScope:
             {
               result = true;
               break;
             }

          default:
             {
               printf ("Default reached in SgScopeStatement::isNamedScope(): scope = %s \n",this->class_name().c_str());
#if 0
               ROSE_ASSERT(false);
#endif
             }
        }

     return result;
   }

// DQ (5/11/2011): Added support for new name qualification implementation.
//! Some scopes have associated names for purposed of name qualification. This generates the associated name.
SgName
SgScopeStatement::associatedScopeName()
   {
     SgName name;
     if (isNamedScope() == true)
        {
          SgDeclarationStatement* declaration = isSgDeclarationStatement(this->get_parent());
          ROSE_ASSERT(declaration != NULL);
          switch (declaration->variantT())
             {
               case V_SgTemplateClassDeclaration:
                  {
                 // DQ (6/11/2011): Since we don't handle the case of SgTemplateDeclaration, I don't think we have to handle this case.
                    printf ("ERROR: I think this should be an error for now at least...\n");
                    ROSE_ASSERT(false);
                    break;
                  }

               case V_SgClassDeclaration:
                  {
                    SgClassDeclaration* namedDeclaration = isSgClassDeclaration(declaration);
                    name = namedDeclaration->get_name();
                    break;
                  }

            // The name stored in a SgTemplateInstantiationDecl is different from that in the SgClassDeclaration base class, as I recall.
               case V_SgTemplateInstantiationDecl:
                  {
                    SgTemplateInstantiationDecl* namedDeclaration = isSgTemplateInstantiationDecl(declaration);
                    name = namedDeclaration->get_name();
                    break;
                  }

               case V_SgNamespaceDeclarationStatement:
                  {
                    SgNamespaceDeclarationStatement* namedDeclaration = isSgNamespaceDeclarationStatement(declaration);
                    name = namedDeclaration->get_name();
                    break;
                  }

               case V_SgEnumDeclaration:
                  {
                    SgEnumDeclaration* namedDeclaration = isSgEnumDeclaration(declaration);
                    name = namedDeclaration->get_name();
                    break;
                  }
#if 0
               case V_SgGlobal:
                  {
                 // The name of global scope (as used for name qualification).
                    name = "::";
                    break;
                  }
#endif
               default:
                  {
                    printf ("Default reached in SgScopeStatement::associatedScopeName(): scope = %s \n",this->class_name().c_str());
                    ROSE_ASSERT(false);
                  }
             }
        }
#if 0
       else
        {
          if (isSgGlobal(this) != NULL)
             {
               name = "::";
             }
        }
#endif

     return name;
   }


bool
SgScopeStatement::isEquivalentScope( SgScopeStatement* scope1, SgScopeStatement* scope2)
   {
  // DQ (1/21/2013): Test for equivcalant scopes.  The only example I can think of for equivalent scopes
  // when the pointers are not equal is a SgNamespaceDefinition.  Since namespaces can be reintrant, a
  // declaration can be in two more more scope that would have different pointers, yet still be considered
  // to be in the same namespace.  This test is used in the name qualification generation.

#if 0
     printf ("currentScope = %p = %s \n",currentScope,currentScope->class_name().c_str());
     printf ("classDeclaration->get_scope() = %p = %s \n",classDeclaration->get_scope(),classDeclaration->get_scope()->class_name().c_str());
#endif
  // DQ (1/21/2013): If these are both namespace scopes then do a more sophisticated test for equivalent namespace.
  // Note that over qualification of generated code can be an error.
     SgNamespaceDefinitionStatement* scope1_NamespaceDefinition = isSgNamespaceDefinitionStatement(scope1);
     SgNamespaceDefinitionStatement* scope2_NamespaceDefinition = isSgNamespaceDefinitionStatement(scope2);
     bool isSameNamespace = false;
     if (scope1_NamespaceDefinition != NULL && scope2_NamespaceDefinition != NULL)
        {
#if 0
          printf ("These are both in namespaces and we need to check if it is the same namespace (instead of just matching scope pointers) \n");
#endif
          SgNamespaceDeclarationStatement* scope1_NamespaceDeclaration = isSgNamespaceDeclarationStatement(scope1_NamespaceDefinition->get_namespaceDeclaration());
          SgNamespaceDeclarationStatement* scope2_NamespaceDeclaration = isSgNamespaceDeclarationStatement(scope2_NamespaceDefinition->get_namespaceDeclaration());

          ROSE_ASSERT(scope1_NamespaceDeclaration != NULL);
          ROSE_ASSERT(scope2_NamespaceDeclaration != NULL);

       // Test for equivalent namespaces.
          if (scope1_NamespaceDeclaration->get_firstNondefiningDeclaration() == scope2_NamespaceDeclaration->get_firstNondefiningDeclaration())
             {
               isSameNamespace = true;
             }
            else
             {
#if 0
               printf ("These namespaces are different \n");
#endif
             }

#if 0
          printf ("SgClassDeclaration: (detected equivalent namespaces) isSameNamespace = %s \n",isSameNamespace ? "true" : "false");
#endif
        }

     return isSameNamespace;
   }

SOURCE_SCOPE_STATEMENT_END


SOURCE_FUNCTION_TYPE_TABLE_STATEMENT_START

/* \brief Hash table of function types (table is stored on global scope).

   Hash table of function types (table is stored on global scope and includes data
   from all scopes). Function types are placed into and retrieved from this data
   base (simple hash table) of function types.
 */
// DQ (1/31/2006): Modified to build all types in the memory pools
// SgFunctionTypeTable Sgfunc_type_table;

// SgFunctionTypeTable::SgFunctionTypeTable( bool case_insensitive )
SgFunctionTypeTable::SgFunctionTypeTable()
  // DQ (12/17/2012): Set the source position as compiler generated to avoid a filename of "" in the static filename tables.
   : SgStatement( Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode ())
   {
  // DQ (11/27/2010): Added support for case sensitive and insensitive matching (for C/C++ and Fortran, respectively).
  // DQ (2/19/2007): Use a much larger size symbol table for the function types (the input value is the hash table size, which should be a prime number)!
  // p_function_type_table = new SgSymbolTable();
  // p_function_type_table = new SgSymbolTable(1001,case_insensitive);
     p_function_type_table = new SgSymbolTable();
     ROSE_ASSERT(p_function_type_table != NULL);

  // DQ (2/16/2006): Set this parent directly (now tested)
     p_function_type_table->set_parent(this);

  // Set the parent of the Sg_File_Info object
  // ROSE_ASSERT(get_file_info() != NULL);
     ROSE_ASSERT(get_startOfConstruct() != NULL);
  // get_file_info()->set_parent(this);
  // p_startOfConstruct->set_parent(this);
     this->get_startOfConstruct()->set_parent(this);

  // DQ (12/17/2012): Set the source position as compiler generated.
     ROSE_ASSERT(get_endOfConstruct() == NULL);
     this->set_endOfConstruct(Sg_File_Info::generateDefaultFileInfoForCompilerGeneratedNode());
     this->get_endOfConstruct()->set_parent(this);

  // DQ (11/27/2010): In retrospect I think that should should always be false!
  // Note that the function type table is global and could include translation
  // units from both C/C++ and Fortran.
  // ROSE_ASSERT(case_insensitive == false);
   }

// DQ (2/19/2007): This appears to not be called but is here because
// the ROSETTA code requires it (I think).
void
SgFunctionTypeTable::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgFunctionTypeTable::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgFunctionTypeTable::print_functypetable(std::ostream& os)
   {
  // printf ("ERROR: Sage $CLASSNAME::print_functypetable function called! \n");
  // abort();

     os << endl << "...FuncTypeTbl..." << endl;
  // p_function_type_table.print(os);

     ROSE_ASSERT(p_function_type_table != NULL);
  // p_function_type_table->print(os);
     p_function_type_table->print("Called from $CLASSNAME::print_functypetable");
   }

void
SgFunctionTypeTable::insert_function_type(const SgName& n, SgType *t)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     ROSE_ASSERT (t != NULL);

     SgFunctionTypeSymbol* newSymbol = new SgFunctionTypeSymbol(n,t);
     ROSE_ASSERT (newSymbol != NULL);
#if 0
     printf ("Inside of SgFunctionTypeTable::insert_function_type(SgName,SgType*): n = %s type = %s = %s \n",
          n.str(),t->sage_class_name(),t->unparseToString().c_str());
#endif
  // printf ("Is the qualified name being used! \n");
  // ROSE_ASSERT(false);

     p_function_type_table->insert(n, newSymbol);
  // p_function_type_table->insert(n, new SgFunctionTypeSymbol(n,t));
   }

// DQ (1/31/2007): Added support for removing function type symbols (used in AST merge)
void
SgFunctionTypeTable::remove_function_type(const SgName& n)
   {
     ROSE_ASSERT (p_function_type_table != NULL);
     p_function_type_table->remove_function_type(n);
   }

SgType*
SgFunctionTypeTable::lookup_function_type(const SgName& n)
   {
  // printf ("In SgFunctionTypeTable::lookup_function_type: Looking for %s \n",n.str());
     ROSE_ASSERT (p_function_type_table != NULL);
  // SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(p_function_type_table->findfunctype(n));
     SgSymbol *symbol = p_function_type_table->find_function_type(n);
     SgFunctionTypeSymbol *fsymb = isSgFunctionTypeSymbol(symbol);
     SgType* returnType = NULL;

     if (fsymb != NULL)
        {
          returnType = fsymb->get_type();
          ROSE_ASSERT(returnType != NULL);
       // printf ("In SgFunctionTypeTable::lookup_function_type(): found function type %s \n",returnType->class_name().c_str());
        }

     return returnType;
   }

SOURCE_FUNCTION_TYPE_TABLE_STATEMENT_END


SOURCE_GLOBAL_STATEMENT_START


// DQ (9/8/2004): Added to support qualified name generation
SgName
SgGlobal::get_qualified_name() const
   {
  // DQ (8/25/2005): This is the case where we previously names the global scope as "::"
  // within name qualification.  This was done to handle test2005_144.C but it broke
  // test2004_80.C So we have moved to an explicit marking of IR nodes using global scope
  // qualification (since it clearly seems to be required).
  // DQ (8/22/2005): Added global scope qualifier (see test2005_144.C) it is sometimes
  // required to prevent base class types from being used instead of globally defined types.
  // Note that this will still evaluate so that "returnName.is_null()" will be true

  // DQ (10/11/2006): Under the new name qualification, we must traverse all the way
  // to global scope, and include global scope to get test2006_157.C correct.
  // return SgName ("");

     std::string globalScopeDelimiter;
     if (SageInterface::is_Java_language())
         globalScopeDelimiter = "";
     else if (SageInterface::is_Ada_language())
     {
         // In Ada, the prefix is almost always optional, but if it is needed
         //   to disambiguate names, "Standard" is used. However, it cannot
         //   be used when withing packages.
         // \begincode
         //   procedure P is
         //     p : integer := 0 ;
         //   begin
         //     Standard.P; -- call P recursively;
         //     -- uses Standard to refer to procedure P instead of local variable P.
         //   end P;
         // -- however:
         //   use Standard.P; -- NOT allowed.
         // \endcode

         globalScopeDelimiter = "";
         // globalScopeDelimiter = "Standard";
     }
     else
         globalScopeDelimiter = "::";
     return SgName (globalScopeDelimiter);
   }

SgName
SgGlobal::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
  // DQ (3/12/2007): This is likely faster than using the mangled name map
     return SgName ("__global__");
   }

void
SgGlobal::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgGlobal::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgGlobal::append_declaration(SgDeclarationStatement * what)
   {
  // DQ (3/10/2007): Make sure that the statement does not already exist in the scope
  // It may be OK if is is marked explicitly as shared. Note that this is a linear time test.
#if 0
  // printf ("In SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
     if (find(get_declarations().begin(),get_declarations().end(),what) != get_declarations().end() && what->get_file_info()->isShared() == false)
        {
          printf ("Error: SgGlobal::append_declaration(): what = %p = %s \n",what,what->class_name().c_str());
          what->get_startOfConstruct()->display("statement does not already exists: debug");
        }

  // Since we have later error checking we don't require this here as it introduces a performance problem.
     ROSE_ASSERT(find(get_declarations().begin(),get_declarations().end(),what) == get_declarations().end() || what->get_file_info()->isShared() == true);
#endif

     get_declarations().push_back(what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgGlobal::prepend_declaration(SgDeclarationStatement * what)
   {
     get_declarations().insert(get_declarations().begin(), what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

bool
SgGlobal::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool
SgGlobal:: replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }

#if 0
std::map<SgNode*,std::string> &
SgGlobal:: get_mangledNameCache()
   {
     return p_mangledNameCache;
   }

std::map<std::string, uint64_t> &
SgGlobal:: get_shortMangledNameCache()
   {
     return p_shortMangledNameCache;
   }
#endif

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,std::string> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,std::string> not implemented";
     return os;
   }

SOURCE_GLOBAL_STATEMENT_END

SOURCE_GLOBAL_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_Global* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* fileInfo =
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (fileInfo != NULL);

     $CLASSNAME* returnValuePtr = new $CLASSNAME(fileInfo);
     ROSE_ASSERT (returnValuePtr != NULL);

     printf ("Call to parse declarations in global scope! \n");

  // Only declarations are allows in the global scope
#if 1
     SgDeclarationStatementPtrList::iterator p = Xptr->get_declarations().begin();
     while(p != Xptr->get_declarations().end())
#else
     SgDeclarationStatementPtrList::iterator p = Xptr->get_declarations().begin();
     while(p != Xptr->get_declarations().end())
#endif
        {
       // parse the statement and see what sort of statement we get

          printf (".");

          ROSE_ASSERT( isSgDeclarationStatement(*p) != NULL );
       // SgDeclarationStatement* newstmt = returnValuePtr->parse (Xptr);

       // Comment this out for now while we get existing code debugged
#if 1
       // Each statement in the global scope is a declaration statement (but we want to consider
       // that they could be an X_DeclarationStatement, so we assume they are all SgStatements
       // SgStatement* newstmt = Sgparse (*p);
       // But the return type of all parse functions is a SgNode pointer (so use that)
          SgNode* newstmt = Sgparse (*p);
          ROSE_ASSERT(newstmt != NULL);

          returnValuePtr->append_declaration( (SgDeclarationStatement*) newstmt );
#endif
          p++;
        }

     printf ("\nEnd of declarations \n");
     return returnValuePtr;
   }

SOURCE_GLOBAL_STATEMENT_PARSER_END


SOURCE_DECLARATION_STATEMENT_START

// DQ (12/21/2005): Build the static empty list to use as a default argument for the SgQualifiedNameType constructor
// SgQualifiedNamePtrList SgDeclarationStatement::p_defaultQualifiedNamePtrList;

SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList()
   {
     return p_qualifiedNameList;
   }

const SgQualifiedNamePtrList &
SgDeclarationStatement::get_qualifiedNameList() const
   {
     return p_qualifiedNameList;
   }

void
SgDeclarationStatement::set_qualifiedNameList( const SgQualifiedNamePtrList & x )
   {
     p_qualifiedNameList = x;
   }

SgName
SgDeclarationStatement::get_qualified_name_prefix() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.
  // This only applies to specific IR nodes:
  //    SgFunctionDeclaration (for the function name)
  //    SgFunctionDeclaration (for the return type)
  //    SgUsingDeclarationStatement (for references to a declaration (e.g. namespace or class))
  //    SgUsingDeclarationStatement (for references to a SgInitializedName)
  //    SgUsingDirectiveStatement
  //    SgVariableDeclaration
  //    SgTypedefDeclaration

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(const_cast<SgDeclarationStatement*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForNames().end())
        {
          nameQualifier = i->second;
       // printf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
        }

  // printf ("nameQualifier for SgDeclarationStatement = %s = %s \n",class_name().c_str(),nameQualifier.str());

     return nameQualifier;
   }

void
SgDeclarationStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgDeclarationStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isForward() const
   { return get_forward(); }

void
SgDeclarationStatement::setForward()
   { set_forward(true); }

void
SgDeclarationStatement::unsetForward()
   { set_forward(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isNameOnly() const
   { return get_nameOnly(); }

void
SgDeclarationStatement::setNameOnly()
   { set_nameOnly(true); }

void
SgDeclarationStatement::unsetNameOnly()
   { set_nameOnly(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::isExternBrace() const
   { return get_externBrace(); }

void
SgDeclarationStatement::setExternBrace()
   { set_externBrace(true); }

void
SgDeclarationStatement::unsetExternBrace()
   { set_externBrace(false); }

// DQ (11/28/2009): Changed return type from "int" to "bool"
bool
SgDeclarationStatement::skipElaborateType() const
   { return get_skipElaborateType(); }

void
SgDeclarationStatement::setSkipElaborateType()
   { set_skipElaborateType(true); }

void
SgDeclarationStatement::unsetSkipElaborateType()
   { set_skipElaborateType(false); }


void
SgDeclarationStatement::testForBadGenerateTemplateName( const std::string & name )
   {
  // DQ (2/20/2005): Error checking on existence of substrings that can be common
  // in building template name and which are a source of errors in generated code.
     if ( (name.find("<<") != string::npos) || (name.find(">>") != string::npos) )
        {
       // This could just be the input or output operators so make sure this is not that case!
          if ( (name.find("operator<<") == string::npos) && (name.find("operator>>") == string::npos) )
             {
#if 0
            // OK, we have some sort of error to report!
               printf ("\n\n");
               printf ("Error: \"<<\" or \">>\" found in generated name, this could lead to an error in compiling the generated code later \n");
               printf ("..... name generated in processing a %s IR node \n",sage_class_name());
               printf ("..... generated name = %s \n",name.c_str());
               printf ("\n\n");
#endif
            // DQ (7/27/2012): Modify this to handle a wide range of function names.
               if (name.find("operator") != string::npos)
                  {
#if 0
                    printf ("This is an operator and so can have names that can violate our test for template names (but still not template arguments; these are rare). \n");
#endif
                  }
                 else
                  {
                    // PP (4/10/2025): refined message and commented out ROSE_ASSERT(false)
                    // example code where this warning is issued:
                    //   \code
                    //   template <class...> struct make_void {};
                    //   struct require_left_shift : make_void<decltype(1 << 1)> {};
                    //   \endcode
                    // other example: boost::lexical_cast<std::string>(7);
                    printf ("WARNING: \"<<\" or \">>\" found in generated name, this could lead to an error in compiling the generated code later\n");
                    printf ("..... name generated in processing a %s IR node \n",class_name().c_str());
                    printf ("..... generated name = %s \n",name.c_str());
                    printf ("** This may be a rule violation, so this is a warning in ROSE **\n");
                    // ROSE_ASSERT (false);
                  }
            // ROSE_ASSERT (returnName.find("<<") == string::npos);
            // ROSE_ASSERT (returnName.find(">>") == string::npos);
             }
        }

  // Search for common substring of unconverted EDG generated typenames...
     if ( name.find("____") != string::npos )
        {
          printf ("Error: \"____\" found in ROSE generated type name = %s (likely and unconverted EDG name) \n",name.c_str());
          printf ("Error: SgDeclarationStatement (this) = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
          get_file_info()->display("Error: likely and unconverted EDG name");
          ROSE_ASSERT (false);
        }
   }


bool
SgDeclarationStatement::skipEmptyTemplateArgumentListTest ( SgFunctionDeclaration* functionDeclaration )
   {
  // DQ (4/13/2005): Avoid output of empty lists of template arguments in function names
  // as in "endl<>" (which is a bug in g++ version 3.4, see test2005_55.C).  This
  // should only apply to function and member functions since they alone can skip the output of "<>".
  // What we do below is skip the "<" and ">" when the list of template arguments would be empty.
  // It would be empty when either there are no arguments or non were explicitly specified in the
  // source code.

  // Note that this function can only be applied to functions (since only they are explicitly
  // mark with if there template arguments are specified or not!)

     ROSE_ASSERT(functionDeclaration != NULL);

  // default is true, so empty lists are not output (could this be an error?)
     bool skipEmptyTemplateArgumentList = true;

     string functionName;
     SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;

  // One or the other of these are valid pointers, but not both!
     SgTemplateInstantiationFunctionDecl       *templateInstantiationFunctionDeclaration       =
          isSgTemplateInstantiationFunctionDecl(functionDeclaration);
     SgTemplateInstantiationMemberFunctionDecl *templateInstantiationMemberFunctionDeclaration =
          isSgTemplateInstantiationMemberFunctionDecl(functionDeclaration);

     if (templateInstantiationFunctionDeclaration != NULL)
        {
          functionName       = templateInstantiationFunctionDeclaration->get_templateName().str();
          templateArgListPtr = &templateInstantiationFunctionDeclaration->get_templateArguments();
        }
       else
        {
          ROSE_ASSERT(templateInstantiationMemberFunctionDeclaration != NULL);
          functionName       = templateInstantiationMemberFunctionDeclaration->get_templateName().str();
          templateArgListPtr = &templateInstantiationMemberFunctionDeclaration->get_templateArguments();
        }

#if 0
     printf ("In skipEmptyTemplateArgumentListTest: Handling function name = %s \n",functionName.c_str());
#endif

     ROSE_ASSERT(templateArgListPtr != NULL);

     SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
     while (i != templateArgListPtr->end())
        {
#if 0
          printf ("templateArgList element *i = %s \n",(*i)->sage_class_name());
#endif

       // DQ (2/27/2005): Added support for output of only template arguments
       // that were explicit in the source code.  Only meaningful for function
       // and member function template arguments.
          bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
       // bool outputTemplateArgument = false;
          if ( templateArgumentWasExplicitlySpecified == true )
             {
            // outputTemplateArgument = true;
               skipEmptyTemplateArgumentList = false;
             }

#if 0
          printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif

          i++;
        }

#if 0
     printf ("skipEmptyTemplateArgumentList = %s \n",(skipEmptyTemplateArgumentList == true) ? "true" : "false");
#endif

     return skipEmptyTemplateArgumentList;
   }


void
resetTemplateNamesInScope ( SgScopeStatement* scope )
   {
  // DQ (8/11/2005): This function loops over all parent scopes to reset
  // any possibly unset names in instantiated templated classes.

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(scope != NULL);

#if 0
     printf ("In resetTemplateNamesInScope: traversing through parent scopes (scope = %p = %s) \n",scope,scope->class_name().c_str());
#endif

#if 0
  // DQ (6/30/2018): Returning from top of function to test infinit loop over declarations in typedef base types.
     printf ("In resetTemplateNamesInScope: Skipping body of function, return \n");
     return;
#endif

  // DQ (7/24/2017): Allow both SgGlobal and SgDeclarationScope to be stoping criteria for this iteration.
  // Unless this causes name collissions because we truncated the scope names.
  // while ( scope != NULL && isSgGlobal(scope) == NULL )
     while ( scope != NULL && isSgGlobal(scope) == NULL && isSgDeclarationScope(scope) == NULL )
        {
#if 0
          printf ("In resetTemplateNamesInScope(%s) \n",scope->class_name().c_str());
#endif
          switch(scope->variantT())
             {
               case V_SgTemplateFunctionDefinition: // Liao, 11/2/2012
               case V_SgFunctionDefinition:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

               case V_SgGlobal:
               case V_SgBasicBlock:
               case V_SgCatchOptionStmt:
               case V_SgSwitchStatement:
               case V_SgIfStmt:
               case V_SgWhileStmt:
               case V_SgDoWhileStmt:
               case V_SgForStatement:
               case V_SgJavaForEachStatement:
                  {
                 // Nothing to do here, I think, unless we have to reset template function names
                    break;
                  }

            // DQ (2/12/2012): Adding support for SgTemplateClassDefinition (not previously used).
               case V_SgTemplateClassDefinition:
               case V_SgClassDefinition:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgClassDefinition(scope)->get_declaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

            // This turns out to be the only important case!
               case V_SgTemplateInstantiationDefn:
                  {
                    SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(scope);
                    ROSE_ASSERT(defn != NULL);
                    ROSE_ASSERT(defn->get_declaration() != NULL);
                    SgTemplateInstantiationDecl *decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                    ROSE_ASSERT(decl != NULL);

                 // DQ (10/24/2015): Make sure that the class declaration is not recorded as existing in the scope represented by it's class definition (that would be BAD).
                    ROSE_ASSERT(decl->get_scope() != defn);

                    decl->resetTemplateName();
                    break;
                  }

               case V_SgNamespaceDefinitionStatement:
                  {
                    SgDeclarationStatement* parentDeclaration = NULL;
                    parentDeclaration = isSgNamespaceDefinitionStatement(scope)->get_namespaceDeclaration();
                    ROSE_ASSERT(parentDeclaration != NULL);
                 // Nothing to do here!
                    break;
                  }

            // DQ (7/20/2017): I don't think we have anything to do here, since there can only be class declarations in this scope, where it exists.
               case V_SgDeclarationScope:
                  {
                 // Nothing to do here!
                    break;
                  }

               default:
                  {
                    printf ("Error: default reached in evaluation of scope within resetTemplateNamesInScope scope = %s \n",scope->sage_class_name());
                    ROSE_ASSERT(false);
                    break;
                  }
             }

       // DQ (10/24/2015): Break this up so that we can enforce that we are making progress through the scopes.
       // scope = scope->get_scope();
          ROSE_ASSERT(scope != NULL);
          SgScopeStatement* next_scope = scope->get_scope();
#if 0
          printf ("In resetTemplateNamesInScope(): next_scope = %p \n",next_scope);
          if (next_scope != NULL)
             {
               printf ("In resetTemplateNamesInScope(): next_scope = %p = %s \n",next_scope,next_scope->class_name().c_str());
             }
#endif
          ROSE_ASSERT(scope != next_scope);
          scope = next_scope;
        }

#if 0
     printf ("Leaving resetTemplateNamesInScope: after traversing through parent scopes \n");
#endif
   }



// DQ (2/15/2005): This is the former SgTemplateInstantitionDecl::resetTemplateName()
// member function.  It has been moved to a global supporting function so that similar
// support can be added to the SgTemplateInstantiationFunctionDecl and the
// SgTemplateInstantiationMemberFunctionDecl IR nodes.  With this design function names
// are not known, except through their mangled names, until after the AST fixup phase.
// I think that this will not be an issue within ROSE.
// Several input parameters are passed, these are the private variables within the
// IR nodes.
// void $CLASSNAME::resetTemplateName ()
void
SgDeclarationStatement::resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name )
   {
  // This function generates the full template name (e.g. "ABC<int>") instead of the mangled name
  // stored in the p_name variable.  Note that the templateArguments must be defined, we can't
  // seem to just set this in the EDG interface since not all the pieces are in place as SAGE III
  // IR nodes. It resets the mangled name in p_name to the full template name.

  // DQ (7/23/2012): This is one of three locations where the template arguments are assembled and where
  // the name generated idically (in each case) is critical.  Not clear how to best refactor this code.
  // The other two are:
  //      SgName SageBuilder::appendTemplateArgumentsToName( const SgName & name, const SgTemplateArgumentPtrList & templateArgumentsList)
  // and in:
  //      void SgDeclarationStatement::resetTemplateNameSupport ( bool & nameResetFromMangledForm, SgName & name )
  // It is less clear how to refactor this code.

  // DQ (9/27/2004) Note: This is the only place within the construction of the Sage III AST (from EDG)
  // where the unparser is called.  It is in general unsafe to do this and it may be that this should
  // be reserved for after the Sage III AST is fully constructed and all post processing fixup
  // (currently limited to setting all parent pointers) is complete.

  // DQ (3/1/2018): Note: the name generated here can contain extra spaces between template arguments,
  // different from the name generated by the SageBuilder::appendTemplateArgumentsToName() function.
  // So this function should not be called in the initial construction of the AST (and serves a different
  // purpose) than the function in SageBuilder.  This function is intended to be called as part of the
  // postprocessing normalization of name.  Still it would be good to refactor this code so that the names
  // generated would be identical (and tested to be identical).

#if 0
     printf ("In SgDeclarationStatement::resetTemplateNameSupport(): CRITICAL FUNCTION TO BE REFACTORED \n");
#endif

     ROSE_ASSERT (this != NULL);
     string returnName;

#if 0
  // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
     printf ("$$$$$$$$$$$$$$ In resetTemplateNameSupport(): this = %p = %s name = %s \n",this,this->class_name().c_str(),name.str());
#endif

#if 0
  // DQ (9/25/2007): Old test, no longer valid.
  // DQ (10/11/2004): Error checking for infinite recursion (just in case it could happen)
     static int counter = 0;
     if (counter > 10000)
        {
          printf ("resetTemplateNameSupport could be in endless recursion ... \n");
          ROSE_ASSERT(false);
        }
#endif

  // DQ (11/23/2004): Check any possible template declarations in higher-level scopes
  // (in which this declaration may be nested).  Such unreset names show up in qualified
  // names that may be generated.  Note that this should be an explicit loop over all
  // parent scopes since any non-template parent scope would break the handling of all
  // templates between here and the global scope!  Handle this case after we debug the
  // current simpler case!
#if 0
     printf ("Implementation of resetTemplateNameSupport() requires loop over parent scopes!!! \n");
#endif

     SgScopeStatement* parentScope = get_scope();

#if 0
     printf ("In resetTemplateNameSupport(): At %s parentScope = %s \n",class_name().c_str(),parentScope->class_name().c_str());
#endif

  // DQ (2/10/2007): I hope we can assert this!
     ROSE_ASSERT(parentScope != NULL);

  // DQ (10/26/2015): Moved into the conditional test below.
  // This function loops over all parent scopes
  // resetTemplateNamesInScope(parentScope);

#if 0
     printf ("In SgDeclarationStatement::resetTemplateNameSupport(): nameResetFromMangledForm = %s \n",nameResetFromMangledForm ? "true" : "false");
#endif

  // If the name has not been reset to the form "ABC<int>" then reset it now!
  // DQ (2/15/2005): Modified to reference input parameters
  // if (get_nameResetFromMangledForm() == false)
     if (nameResetFromMangledForm == false)
        {
       // DQ (10/26/2015): Moved from the end of the loop to avoid infinite
       // recursive calls from the evaluation of the template arguments.
          nameResetFromMangledForm = true;

#if 0
       // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
          printf ("In resetTemplateNameSupport(): Calling resetTemplateNamesInScope(): parentScope = %p = %s \n",parentScope,parentScope->class_name().c_str());
#endif

       // DQ (10/26/2015): Moved to after the conditional test to avoid resetting the template name again on this declaration.
       // This function loops over all parent scopes
          resetTemplateNamesInScope(parentScope);

#if 0
       // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
          printf ("DONE: In resetTemplateNameSupport(): Calling resetTemplateNamesInScope(): parentScope = %p = %s \n",parentScope,parentScope->class_name().c_str());
#endif

       // returnName = get_templateName().str();
       // SgTemplateArgumentPtrListPtr templateArgListPtr = get_templateArguments();

          bool appendTemplateArguments   = true;

          bool skipEmptyTemplateArgumentList = false;

       // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
          bool functionTemplateArguments = false;
          SgTemplateArgumentPtrListPtr templateArgListPtr = NULL;
          switch(variantT())
             {
               case V_SgTemplateInstantiationDecl:
                  {
                    SgTemplateInstantiationDecl* node = isSgTemplateInstantiationDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();
#if 0
                    printf ("In resetTemplateNameSupport(): case V_SgTemplateInstantiationDecl: node = %p templateName = %s name = %s \n",node,node->get_templateName().str(),node->get_name().str());
#endif
                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }

            // DQ (4/13/2005): Combine these two cases since they are identical (error: both cases must be separate!)
               case V_SgTemplateInstantiationFunctionDecl:
            // case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationFunctionDecl* node = isSgTemplateInstantiationFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>"
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
                 // printf ("function name = %s \n",returnName.c_str());
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
                      // printf ("Skipping appending the templates arguments to this overloaded operator \n");
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#if 1
               case V_SgTemplateInstantiationMemberFunctionDecl:
                  {
                    SgTemplateInstantiationMemberFunctionDecl* node = isSgTemplateInstantiationMemberFunctionDecl(this);
                    ROSE_ASSERT(node != NULL);
#if 0
                    printf ("node = %p = (templateName) %s = (name) %s \n",node,node->get_templateName().str(),node->get_name().str());
#endif
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/28/2005): function templates need to be separated out since for them the marker of being explicit make sense.
                    functionTemplateArguments = true;

                 // DQ (2/17/2005): We can't translate "operator+" into "operator+<int>" since it will become "+<int>"
                 // in the unparser so make sure that this is not a name of an overloaded operator function.
#if 0
                    printf ("member function name = %s \n",returnName.c_str());
#endif
                 // if (TransformationSupport::classifyOverloadedOperator(returnName) != TransformationSupport::FUNCTION_CALL_OPERATOR_CODE)
                    if (node->get_specialFunctionModifier().isOperator() == true)
                       {
#if 0
                         printf ("Skipping appending the templates arguments to this overloaded operator \n");
#endif
                         appendTemplateArguments = false;
                       }

                 // DQ (4/13/2005): Avoid output of empty template lists where not required (e.g. "std::endl<>" ).
                    skipEmptyTemplateArgumentList = skipEmptyTemplateArgumentListTest(node);

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }
#endif

            // DQ (2/26/2018): Added support for the template instantiation typedef declaration.
               case V_SgTemplateInstantiationTypedefDeclaration:
                  {
                    SgTemplateInstantiationTypedefDeclaration* node = isSgTemplateInstantiationTypedefDeclaration(this);
                    ROSE_ASSERT(node != NULL);
#if 0
                    printf ("In resetTemplateNameSupport(): case V_SgTemplateInstantiationTypedefDeclaration:node = %p = (templateName) %s = (name) %s \n",
                         node,node->get_templateName().str(),node->get_name().str());
#endif
                    returnName         = node->get_templateName().str();
                    templateArgListPtr = &node->get_templateArguments();

                 // DQ (2/21/2005): Error checking on existence of substrings that can be common
                 // in building template name and which are a source of errors in generated code.
                    testForBadGenerateTemplateName(returnName);
                    break;
                  }

               default:
                  {
                 // ... nothing to do here
                  }
             }

          ROSE_ASSERT(templateArgListPtr != NULL);

#if 0
          printf ("In resetTemplateNameSupport(): Handle the template arguments (where available) \n");
#endif

       // DQ (4/13/2005): Sometimes template parameters are present but were not specified in the source code and if so we
       // should also not output "<>".  This is a stronger test than that implemented previously (fixes output of "std::endl<>" as well).
       // DQ (2/17/2005): We want to avoid "<>" appearing where template arguments are meant to be used (e.g. in function names)
       // if (templateArgListPtr != NULL)
       // if ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) )
          if ( ( (appendTemplateArguments == true) && (templateArgListPtr->size() > 0) ) && (skipEmptyTemplateArgumentList == false) )
             {
#if 0
               printf ("In $CLASSNAME::resetTemplateName(): templateArgListPtr->size() = %" PRIuPTR " \n",templateArgListPtr->size());
#endif

               returnName += " < ";
               SgTemplateArgumentPtrList::const_iterator i = templateArgListPtr->begin();
               while (i != templateArgListPtr->end())
                  {
#if 0
                    printf ("templateArgList element *i = %p = %s \n",*i,(*i)->sage_class_name());
#endif

                    if ((*i)->get_argumentType() == SgTemplateArgument::start_of_pack_expansion_argument) {
                      i++;
                      continue;
                    }

                 // DQ (2/27/2005): Added support for output of only template arguments
                 // that were explicit in the source code.  Only meaningful for function
                 // and member function template arguments.
                    bool templateArgumentWasExplicitlySpecified = (*i)->get_explicitlySpecified();
                    bool outputTemplateArgument = false;
                    if ( ( (*i)->get_argumentType() != SgTemplateArgument::start_of_pack_expansion_argument) &&
                         ( (functionTemplateArguments == false) ||
                         ( (functionTemplateArguments == true) && (templateArgumentWasExplicitlySpecified == true) ) ) )
                       {
                         outputTemplateArgument = true;
                       }
#if 0
                    printf ("functionTemplateArguments = %s \n",(functionTemplateArguments == true) ? "true" : "false");
                    printf ("outputTemplateArgument = %s \n",(outputTemplateArgument == true) ? "true" : "false");
#endif
                    if (outputTemplateArgument == true)
                       {
                         ROSE_ASSERT( *i != NULL);
#if 0
                         printf ("In $CLASSNAME::resetTemplateName(): (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
#endif
                         switch((*i)->get_argumentType())
                            {
                              case SgTemplateArgument::argument_undefined:
                                 {
                                   printf ("Error: SgTemplateArgument::argument_undefined not allowed \n");
                                   ROSE_ASSERT(false);
                                   break;
                                 }

                              case SgTemplateArgument::type_argument:
                                 {
                                   ROSE_ASSERT((*i)->get_type() != NULL);
                                   SgType* argumentType = (*i)->get_type();
#if 0
                                   printf ("SgTemplateArgument::type_argument: argumentType = %p = %s \n",argumentType,argumentType->sage_class_name());
#endif
                                   switch(argumentType->variantT())
                                      {
                                        case V_SgClassType:
                                           {
                                          // DQ (10/13/2004): If this is a template declaration then we might have to reset its name
                                             SgClassType* classType = isSgClassType(argumentType);
                                          // printf ("Found a class declaration ... \n");
                                             SgDeclarationStatement* declaration = classType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                                             ROSE_ASSERT(classDeclaration != NULL);
                                             SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
                                             if (templateClassDeclaration != NULL)
                                                {
                                               // printf ("Found a template instantiation declaration  (call resetTemplateName) ... \n");
                                                  templateClassDeclaration->resetTemplateName();
                                                }
                                             break;
                                           }

                                        case V_SgTypedefType:
                                           {
                                             SgTypedefType* typedefType = isSgTypedefType(argumentType);
                                          // printf ("Found a typedef declaration ... \n");
                                             SgDeclarationStatement* declaration = typedefType->get_declaration();
                                             ROSE_ASSERT(declaration != NULL);
                                             SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(declaration);
                                             ROSE_ASSERT(typedefDeclaration != NULL);
                                             SgTemplateInstantiationDefn* defn = isSgTemplateInstantiationDefn(typedefDeclaration->get_scope());
                                             if (defn != NULL)
                                                {
                                               // If we start the resetTemplateName() function here in the parent scope of the typedef
                                               // type's declaration then it should continue to call resetTemplateName() through the
                                               // rest of the scopes to the root (global scope).  Unless there is a non-template in the
                                               // chain!  So I guess the code above must be an explicit loop over all parent scopes
                                               // until we reach global scope!
                                                  SgTemplateInstantiationDecl* decl = isSgTemplateInstantiationDecl(defn->get_declaration());
                                                  ROSE_ASSERT(decl != NULL);
                                                  decl->resetTemplateName();
                                                }
                                             break;
                                           }

                                     // DQ (9/11/2005): Handle these cases together
                                        case V_SgPointerType:
                                        case V_SgModifierType:
                                        case V_SgReferenceType:
                                           {
                                          // Need to reach in and see if this is a template instantiation of a class type and then reset its name
#if 0
#error "DEAD CODE!"
#else
                                          // Handle this explicitly so that we can see the full type chain (in case there is a unset template name in the chain!)
                                             SgType* currentType = argumentType;

                                             SgModifierType*  modType     = NULL;
                                             SgPointerType*   pointType   = NULL;
                                             SgReferenceType* refType     = NULL;
                                             SgArrayType*     arrayType   = NULL;
                                             SgTypedefType*   typedefType = NULL;

                                          // Loop through the chain of types (modifiers, references, pointers, array types, and typedefs
                                             while (true)
                                                {
#if 0
                                               // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
                                                  printf ("In while(true) loop over all modifiers: currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
                                                  if ( (modType = isSgModifierType(currentType)) )
                                                     {
                                                       currentType = modType->get_base_type();
#if 0
                                                    // DQ (10/26/2015): Added test to detect simple cycle in types.
                                                       ROSE_ASSERT( isSgModifierType(currentType) != NULL &&
                                                                    isSgTypedefType(isSgModifierType(currentType)->get_base_type()) != NULL &&
                                                                    isSgTypedefType(isSgModifierType(currentType)->get_base_type())->get_base_type() != currentType);
#endif
#if 0
                                                    // DQ (10/26/2015): Added test to detect simple cycle in types.
                                                       SgType* baseType = currentType;
                                                       SgTypedefType*  tmp_typedefType = isSgTypedefType(baseType);
                                                       if (tmp_typedefType != NULL)
                                                          {
                                                            ROSE_ASSERT(modType != tmp_typedefType->get_base_type());
                                                          }
#endif
                                                     }
                                                    else
                                                     {
                                                       if ( (refType = isSgReferenceType(currentType)) )
                                                          {
                                                            currentType = refType->get_base_type();
                                                          }
                                                         else
                                                          {
                                                            if ( (pointType = isSgPointerType(currentType)) )
                                                               {
                                                                 currentType = pointType->get_base_type();
                                                               }
                                                              else
                                                               {
                                                                 if ( (arrayType = isSgArrayType(currentType)) )
                                                                    {
                                                                      currentType = arrayType->get_base_type();
                                                                    }
                                                                   else
                                                                    {
                                                                   // DQ (6/21/2005): Added support for typedef types to be uncovered by findBaseType()
                                                                      if ( (typedefType = isSgTypedefType(currentType)) )
                                                                         {
                                                                        // DQ (10/27/2015): Added test for specific cycle in typedef types.
                                                                           ROSE_ASSERT( (isSgModifierType(isSgTypedefType(currentType)->get_base_type()) == NULL) ||
                                                                                        ( (isSgModifierType(isSgTypedefType(currentType)->get_base_type()) != NULL) &&
                                                                                          (isSgModifierType(isSgTypedefType(currentType)->get_base_type())->get_base_type() != currentType) ) );

                                                                        // DQ (10/26/2015): This should be true, I think. Debugging infinite loop problem (test2015_97.C).
                                                                           ROSE_ASSERT(currentType != typedefType->get_base_type());

                                                                           currentType = typedefType->get_base_type();
#if 0
                                                                           printf ("typedefType->get_base_type(): currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
                                                                         }
                                                                        else
                                                                         {
                                                                        // Exit the while(true){} loop!
                                                                           break;
                                                                         }
                                                                    }
                                                               }
                                                          }
                                                     }

                                               // printf ("In resetTemplateName: stripping type - currentType = %s hidden behind this = %s \n",
                                               //      currentType->sage_class_name(),argumentType->sage_class_name());

                                               // Check all typedefs that we find along the way (in this while loop through the modifiers)!
                                                  if (typedefType != NULL)
                                                     {
#if 1
                                                       SgDeclarationStatement* likelyTypedefDeclaration = typedefType->get_declaration();
                                                       ROSE_ASSERT( likelyTypedefDeclaration != NULL);
                                                       SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(likelyTypedefDeclaration);
                                                       ROSE_ASSERT( typedefDeclaration != NULL);
#endif
#if 0
                                                       printf ("In resetTemplateName: In loop over typedefs, modifiers, etc. found a typedef = %s \n",typedefDeclaration->get_name().str());
#endif
#if 0
                                                       typedefDeclaration->get_file_info()->display("In resetTemplateName: typedefDeclaration: debug");
#endif
                                                       SgType* baseType = typedefType->get_base_type();
                                                       ROSE_ASSERT(currentType == baseType);
                                                       ROSE_ASSERT(baseType != NULL);
                                                       SgClassType* classType = isSgClassType(baseType);
                                                       if (classType != NULL)
                                                          {
                                                         // printf ("In loop over typedefs, modifiers, etc. found a class type \n");
                                                            SgDeclarationStatement* declaration = classType->get_declaration();
                                                            ROSE_ASSERT(declaration != NULL);
                                                            SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                            if (classTemplateInstantiation != NULL)
                                                               {
                                                              // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                              //      classTemplateInstantiation->get_name().str());
                                                                 classTemplateInstantiation->resetTemplateName();
                                                               }
                                                          }

                                                    // ROSE_ASSERT(typedefType->get_declaration() != NULL);
                                                    // ROSE_ASSERT(isSgTypedefDeclaration(typedefType->get_declaration()) != NULL);
                                                    // SgTypedefDeclaration* typedefDeclaration = isSgTypedefDeclaration(typedefType->get_declaration());
                                                       SgScopeStatement* typedefScope = typedefDeclaration->get_scope();
                                                       ROSE_ASSERT(typedefScope != NULL);
#if 0
                                                    // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
                                                       printf ("In resetTemplateName: traversing through parent scopes to reset any instantiated template names: typedefScope = %p = %s \n",
                                                            typedefScope,typedefScope->class_name().c_str());
#endif

                                                    // DQ (6/30/2018): Detect an break cycles in typedefs (debugging test2018_118.C).
                                                    // resetTemplateNamesInScope(typedefScope);
                                                       static std::set<SgScopeStatement*> scopeSet;
                                                       if (scopeSet.find(typedefScope) == scopeSet.end())
                                                          {
                                                            scopeSet.insert(typedefScope);
                                                            resetTemplateNamesInScope(typedefScope);
                                                          }
                                                         else
                                                          {
#if 0
                                                         // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
                                                            printf ("In resetTemplateName: scope was previously seen: typedefScope = %p = %s \n",typedefScope,typedefScope->class_name().c_str());
#endif
                                                         // Exit the while(true){} loop!
                                                            break;
                                                          }
#if 0
                                                    // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
                                                    // DQ (10/24/2015): When we are in an infinite loop (current bug) we never get to this location in the code (I think).
                                                       printf ("DONE: In resetTemplateName: traversing through parent scopes to reset any instantiated template names: typedefScope = %p = %s \n",
                                                            typedefScope,typedefScope->class_name().c_str());
#endif
                                                     }

                                               // reset these to NULL (to avoid saving a history, this allows the typedefType to be checked)
                                                  modType     = NULL;
                                                  refType     = NULL;
                                                  pointType   = NULL;
                                                  arrayType   = NULL;
                                                  typedefType = NULL;

                                                  ROSE_ASSERT(currentType != NULL);
#if 0
                                               // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
                                                  printf ("END OF WHILE LOOP: currentType = %p = %s \n",currentType,currentType->class_name().c_str());
#endif
                                                }

                                             SgType* strippedType = currentType;
#endif
#if 0
                                             printf ("In resetTemplateName: process the strippedType = %p = %s \n",strippedType,strippedType->class_name().c_str());
#endif
                                             ROSE_ASSERT(strippedType != NULL);
                                             SgClassType* classType = isSgClassType(strippedType);
                                             if (classType != NULL)
                                                {
                                               // printf ("Found a class type \n");
                                                  SgDeclarationStatement* declaration = classType->get_declaration();
                                                  ROSE_ASSERT(declaration != NULL);
                                                  SgTemplateInstantiationDecl* classTemplateInstantiation = isSgTemplateInstantiationDecl(declaration);
                                                  if (classTemplateInstantiation != NULL)
                                                     {
                                                    // printf ("Found a instantiated class template inside the class type (resetting name = %s) \n",
                                                    //      classTemplateInstantiation->get_name().str());
                                                       classTemplateInstantiation->resetTemplateName();
                                                     }
                                                }
                                             break;
                                           }


                                     // DQ (7/23/2012): This appears to be a missing case.
                                        case V_SgTemplateType:
                                           {
                                          // DQ (10/13/2004): If this is a template declaration then we might have to reset its name
                                          // SgTemplateType* templateType = isSgTemplateType(argumentType);
#if 1
                                          // DQ (8/26/2012): Decrease the volume of warnings from this part of the code.
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                                             static int count = 0;

                                          // DQ (6/30/2018): Debuging infinite loop in test2018_117.C.
                                          // if (count++ % 1 == 0)
                                             if (count++ % 100 == 0)
                                                {
                                                  printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::type_argument: Found a SgTemplateType ... (nothing done in this case) \n");
                                                }
#endif
#else
                                             printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::type_argument: Found a SgTemplateType ... (nothing done in this case) \n");
#endif
                                          // SgDeclarationStatement* declaration = templateType->get_declaration();
                                          // ROSE_ASSERT(declaration != NULL);
                                          // printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::type_argument: declaration = %p = %s \n",declaration,declaration->class_name().c_str());
#if 1
                                          // Not clear if we have to reset the name of a template (unles it uses partial specialization,
                                          // but then it would be a partial template instantiation, I think.  We might also have to explicitly
                                          // handle each of the different types of template declarations directly (if resetTemplateName()
                                          // is not a virtual function).
                                          // printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::type_argument: Found a template instantiation declaration  (SKIP calling resetTemplateName) ... (do we need this?) \n");
                                          // declaration->resetTemplateName();
#else
                                          // OLD CODE...
                                             SgClassDeclaration* classDeclaration = isSgClassDeclaration(declaration);
                                             ROSE_ASSERT(classDeclaration != NULL);
                                             SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
                                             if (templateClassDeclaration != NULL)
                                                {
                                               // printf ("Found a template instantiation declaration  (call resetTemplateName) ... \n");
                                                  templateClassDeclaration->resetTemplateName();
                                                }
#endif
                                             break;
                                           }

                                     // DQ (8/29/2009): Added SgArrayType to eliminate error message about
                                     // default being reached (missed including this type previously).
                                        case V_SgArrayType:

                                     // Rasmussen (2/18/2020): Added SgTypeFixed (primitive type in Jovial)
                                        case V_SgTypeFixed:

                                     // DQ (2/28/2005): List of types used in compiling Kull
                                        case V_SgTypeChar:
                                        case V_SgTypeWchar:
                                        case V_SgTypeBool:
                                        case V_SgTypeSignedChar:
                                        case V_SgTypeUnsignedChar:
                                        case V_SgTypeShort:
                                        case V_SgTypeUnsignedShort:
                                        case V_SgTypeUnsignedInt:
                                        case V_SgTypeLong:
                                        case V_SgTypeUnsignedLong:
                                        case V_SgTypeLongLong:
                                        case V_SgTypeUnsignedLongLong:
                                        case V_SgTypeFloat:
                                        case V_SgTypeDouble:
                                        case V_SgTypeLongDouble:
                                        case V_SgTypeVoid:
                                        case V_SgTypeInt:
                                        case V_SgEnumType:
                                           {
                                          // Nothing to do here with these primitive types (listed explicitly to avoid compiler warnings)
                                             break;
                                           }

                                         default:
                                           {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                                             printf ("Default reached in switch over SgTemplateArgument::type_argument (argumentType = %p = %s) \n",argumentType,argumentType->class_name().c_str());
#endif
                                          // ROSE_ASSERT(false);
                                           }
                                      }
                                   break;
                                 }

                              case SgTemplateArgument::nontype_argument:
                                 {
                                // These can be boolean or integer values, for example.
                                // ROSE_ASSERT((*i)->get_expression() != NULL);
                                   ROSE_ASSERT((*i)->get_expression() != NULL || (*i)->get_initializedName() != NULL);
                                   ROSE_ASSERT((*i)->get_expression() == NULL || (*i)->get_initializedName() == NULL);

                                   if ((*i)->get_expression() != NULL)
                                      {
#if 0
                                        SgExpression* argumentExpression = (*i)->get_expression();
                                        printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::nontype_argument: argumentExpression = %p = %s \n",argumentExpression,argumentExpression->class_name().c_str());
#endif
                                      }
                                     else
                                      {
#if 0
                                        SgInitializedName* argumentInitializedName = (*i)->get_initializedName();
                                        printf ("In SgDeclarationStatement::resetTemplateNameSupport(): case SgTemplateArgument::nontype_argument: argumentInitializedName = %p = %s \n",argumentInitializedName,argumentInitializedName->get_name().str());
#endif
                                      }

                                   break;
                                 }

                              case SgTemplateArgument::template_template_argument:
                                 {
                                // DQ (8/24/2006): This is not a name that needs to be reset, so I think there is nothing to do here!
                                   ROSE_ASSERT((*i)->get_templateDeclaration() != NULL);

                                // printf ("Warning: SgTemplateArgument::template_template_argument not implemented \n");
                                // ROSE_ASSERT(false);
                                   break;
                                 }

                              case SgTemplateArgument::start_of_pack_expansion_argument:
                                 {
                                // DQ (5/19/2014): This is not a name that needs to be reset, so I think there is nothing to do here!
                                // ROSE_ASSERT((*i)->get_templateDeclaration() != NULL);
#if 0
                                   printf ("Warning: In SgDeclarationStatement::resetTemplateNameSupport(): SgTemplateArgument::start_of_pack_expansion_argument (no reset of name required) \n");
                                // ROSE_ASSERT(false);
#endif
                                   break;
                                 }

                              default:
                                 {
                                   printf ("Default reached in switch over (*i)->get_argumentType() = %d \n",(*i)->get_argumentType());
                                   ROSE_ASSERT(false);
                                 }
                            }

                      // DQ (2/21/2005): Error checking on existence of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);

                      // DQ (2/28/2005): Pass in an explicit unparse info object to control (and turn off) the
                      // unparsing of definitions within the unparsing of types used as template arguments.
                      // This avoids generation of bad code like "x6.foo<const enum values {zero,nonzero}>();"
                      // (see test2005_13.C for details on this bug).
                         SgUnparse_Info unparseInfo;
                         unparseInfo.set_SkipDefinition();
                         ROSE_ASSERT (unparseInfo.SkipDefinition() == true);

                      // DQ (2/28/2005): Set these to be consistent with unparseToString
                      // Skip all comments in unparsing
                         unparseInfo.set_SkipComments();
                         ROSE_ASSERT (unparseInfo.SkipComments() == true);
                      // Skip all whitespace in unparsing (removed in generated string)
                         unparseInfo.set_SkipWhitespaces();
                         ROSE_ASSERT (unparseInfo.SkipWhitespaces() == true);

                      // Skip all directives (macros are already substituted by the front-end, so this has no effect on those)
                         unparseInfo.set_SkipCPPDirectives();
                         ROSE_ASSERT (unparseInfo.SkipCPPDirectives() == true);

                      // DQ (6/9/2007): Set the scope from which the name qualification for the template arguments should be computed!
                         ROSE_ASSERT(*i != NULL);
                         SgScopeStatement* localScope = (*i)->get_scope();
                         unparseInfo.set_current_scope(localScope);

                      // DQ (2/28/2005): Call globalUnparseToString() so tht we can specify
                      // greater control over unparsing.
                      // DQ (10/12/2004): This can be called now the this function is called after the
                      // post-processing fixup of the parent nodes in the AST (after the EDG/Sage III translation).
                      // This simplifies the implementation and permits the unparser to call the functions
                      // required to generate qualified names (which require that the parent pointers be set).
                      // returnName += (*i)->unparseToString(unparseInfo);
#if 0
                         printf ("Before globalUnparseToString: returnName = %s \n",returnName.c_str());
#endif
                         returnName += globalUnparseToString(*i,&unparseInfo);
#if 0
                         printf ("After globalUnparseToString: returnName = %s \n",returnName.c_str());
#endif
                      // DQ (2/21/2005): Error checking on existence of substrings that can be common
                      // in building template name and which are a source of errors in generated code.
                         testForBadGenerateTemplateName(returnName);
                       }
#if 0
                    printf ("Increment the template argument iterator! \n");
#endif
                 // DQ (2/27/2005): Added support for output of only template arguments
                 // that were explicit in the source code.
                 // if (templateArgumentWasExplicitlySpecified == true)
                    if (outputTemplateArgument == true)
                       {
                      // Increment to next template argument
                         i++;

                         if (i != templateArgListPtr->end())
                            returnName += " , ";
                       }
                      else
                       {
                      // Increment to next template argument
                         i++;
                       }
                  }

            // Close off the template argument list
               returnName += " > ";

#if 0
            // DQ (2/20/2005): Error checking on existence of substrings that can be common
            // in building template name and which are a source of errors in generated code.
               if ( (returnName.find("<<") != string::npos) || (returnName.find(">>") != string::npos) )
                  {
                    printf ("returnName = %s \n",returnName.c_str());
                  }
               ROSE_ASSERT (returnName.find("<<") == string::npos);
               ROSE_ASSERT (returnName.find(">>") == string::npos);
#endif
             }
            else
             {
            // DQ (2/17/2005): This can be the case of a member function of a templated class which
            // would of course not have any template arguments specific to it as a function.
            // printf ("Error in resetTemplateName(): No valid template argument list \n");
            // ROSE_ASSERT(false);
             }

       // printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
       // SageInterface::outputLocalSymbolTables(parentScope);

#if 0
          printf ("In resetTemplateNameSupport(): Handle the symbol support \n");
#endif

#if 0
       // DQ (2/10/2007): Unload the associated symbol using the old name and reload it into the symbol table using the new name!
          printf ("\n\nCalling this->get_symbol_from_symbol_table() on %s parentScope = %p = %s name = %s count = %ld \n",
               this->class_name().c_str(),parentScope,parentScope->class_name().c_str(),name.str(),parentScope->count_symbol(name));
          printf ("     this = %p = %s definingDeclaration         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
          printf ("     this = %p = %s firstNondefiningDeclaration = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
          const SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(this);
          if (templateInstantiation != NULL)
             {
               printf ("templateInstantiation->get_name()  = %s get_templateName() = %s \n",templateInstantiation->get_name().str(),templateInstantiation->get_templateName().str());
               printf ("templateInstantiation->get_scope() = %p = %s \n",templateInstantiation->get_scope(),templateInstantiation->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationFunctionDecl* templateInstantiationFunction = isSgTemplateInstantiationFunctionDecl(this);
          if (templateInstantiationFunction != NULL)
             {
               printf ("templateInstantiationFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationFunction->get_name().str(),templateInstantiationFunction->get_templateName().str());
               printf ("templateInstantiationFunction->get_scope() = %p = %s \n",templateInstantiationFunction->get_scope(),templateInstantiationFunction->get_scope()->class_name().c_str());
             }
          const SgTemplateInstantiationMemberFunctionDecl* templateInstantiationMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateInstantiationMemberFunction != NULL)
             {
               printf ("templateInstantiationMemberFunction->get_name()  = %s get_templateName() = %s \n",templateInstantiationMemberFunction->get_name().str(),templateInstantiationMemberFunction->get_templateName().str());
               printf ("templateInstantiationMemberFunction->get_scope() = %p = %s \n",templateInstantiationMemberFunction->get_scope(),templateInstantiationMemberFunction->get_scope()->class_name().c_str());
             }
#endif

          SgSymbol* symbol = this->get_symbol_from_symbol_table();
          if (symbol == NULL)
             {
            // If searching for the old name returned a null symbol pointer then make sure that there is an entry for the new name
#if 0
               printf ("Searching for returnName = %s \n",returnName.c_str());
#endif
#if 0
               if (parentScope->count_symbol(returnName) >= 1)
                  {
                    printf ("Warning: symbol for returnName = %s is already in the symbol table but not associated with this = %p = %s count = %ld \n",
                         returnName.c_str(),this,this->class_name().c_str(),parentScope->count_symbol(returnName));
                    printf ("     (count too large) this = %p = %s this->get_definingDeclaration()         = %p \n",this,this->class_name().c_str(),this->get_definingDeclaration());
                    printf ("     (count too large) this = %p = %s this->get_firstNondefiningDeclaration() = %p \n",this,this->class_name().c_str(),this->get_firstNondefiningDeclaration());
                  }
#endif
            // ROSE_ASSERT(parentScope->count_symbol(returnName) >= 1);
#if 0
               printf ("There are a number of reasons why we could not have a valid symbol at this point: (parentScope = %p = %s = %s) \n",
                    parentScope,parentScope->class_name().c_str(),SageInterface::get_name(parentScope).c_str());
               printf ("   1) template used as base class in SgCtorInitializerList \n");
               printf ("   2) template used as in a type \n");
               printf ("   3) Either the processing of the defining or non-defining declaration already removed the symbol using the old name \n");
               printf ("******************** START **********************\n");
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table for scope = %p = %s: \n",parentScope,parentScope->class_name().c_str());
               SageInterface::outputLocalSymbolTables(parentScope);
               printf ("******************** DONE ***********************\n");
#endif
#if 0
               printf ("Exiting as a test in resetTemplateNameSupport(): symbol = %p returnName = %s \n",symbol,returnName.c_str());
               ROSE_ASSERT(false);
#endif
             }
            else
             {
            // Remove the symbol (previously inserted under the old name and hashed accordingly)
            // so that we can reinsert it into the symbol table after we change the name.
#if 0
               printf ("Removing the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               SgClassSymbol* classSymbol = isSgClassSymbol(symbol);
               if (classSymbol != NULL)
                  {
                    printf ("classSymbol->get_declaration() = %p = %s name = %s \n",classSymbol->get_declaration(),classSymbol->get_declaration()->class_name().c_str(),classSymbol->get_declaration()->get_name().str());
                  }
               SgFunctionSymbol* functionSymbol = isSgFunctionSymbol(symbol);
               if (functionSymbol != NULL)
                  {
                    printf ("functionSymbol->get_declaration() = %p = %s name = %s \n",functionSymbol->get_declaration(),functionSymbol->get_declaration()->class_name().c_str(),functionSymbol->get_declaration()->get_name().str());
                  }
               SgMemberFunctionSymbol* memberFunctionSymbol = isSgMemberFunctionSymbol(symbol);
               if (memberFunctionSymbol != NULL)
                  {
                    printf ("memberFunctionSymbol->get_declaration() = %p = %s name = %s \n",memberFunctionSymbol->get_declaration(),memberFunctionSymbol->get_declaration()->class_name().c_str(),memberFunctionSymbol->get_declaration()->get_name().str());
                  }
#endif
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): removing symbol = %p = %s for symbol_basis = %p = %s \n",
                    symbol,symbol->class_name().c_str(),symbol->get_symbol_basis(),symbol->get_symbol_basis()->class_name().c_str());
#endif
            // ROSE_ASSERT(false);

               parentScope->remove_symbol(symbol);
             }

       // DQ (2/15/2005): Modified to reference input parameters ("name" is an input parameter to this function!)
       // set_name( returnName.c_str());
          name = returnName.c_str();
       // DQ (2/10/2007): If we have a symbol then reinsert it into the symbol table using the new name
          if (symbol != NULL)
             {
            // printf ("Inserting the symbol = %p = %s name = %s from scope %p = %s \n",symbol,symbol->class_name().c_str(),name.str(),parentScope,parentScope->class_name().c_str());
               parentScope->insert_symbol(name,symbol);
#if 0
               printf ("In SgDeclarationStatement::resetTemplateNameSupport(): Output the symbol table: \n");
               SageInterface::outputLocalSymbolTables(parentScope);
#endif
             }

       // DQ (2/15/2005): Modified to reference input parameters
       // DQ (10/11/2004): Removed call to unparser since it often requires that the parents
       // be set.  Now we have to mark this template as no longer containing a mangled name
       // set_nameResetFromMangledForm(true);
       // nameResetFromMangledForm = true;
          ROSE_ASSERT(nameResetFromMangledForm == true);

       // DQ (2/20/2005): Error checking on existence of substrings that can be common
       // in building template name and which are a source of errors in generated code.
          testForBadGenerateTemplateName(returnName);
        }

#if 0
  // DQ (6/30/2018): This is helpful in tracing through typedef circular dependences possible with templates (see test2018_118.C).
     printf ("$$$$$$$$$$$$$$ Leaving SgDeclarationStatement::resetTemplateNameSupport(): name = %s \n",name.str());
#endif
   }


// This is a local file scope (support) function
static void
stringSupport ( string & sourceString, const string & targetString, const string & replacementString )
   {
     if (sourceString.find(targetString) != string::npos)
        {
          sourceString.replace(sourceString.find(targetString),targetString.size(),replacementString);
        }
   }

// SgName $CLASSNAME::fixupTemplateNameForMangledNameSupport( const SgName & name) const
// static SgName fixupTemplateNameForMangledNameSupport( const SgName & name)
SgName
SgDeclarationStatement::fixupTemplateNameForMangledNameSupport( const SgName & name) const
   {
  // Where template names are reset to the form "foo < int >" we can look for just
  // the " < " and " > " substrings which are guaranteed to exist by construction!
     string s = name.str();

  // printf ("In fixupTemplateNameForMangledNameSupport(): Before filtering s = %s \n",s.c_str());

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // To safely fixup all template syntax (e.g. "<x>") to remove the "<" and ">" we have to take care to not
  // change the name of any operator (such as "operator<<", "operator>>", "operator<", "operator>",
  // "operator<=", and "operator>="
  // Note that this is a current bug for:
  // __copy_backward_dispatch<std::vector <int,std::allocator<int>>::value_type*,std::vector<int,std::allocator<int>>::value_type*,__type_traits<int>::has_trivial_assignment_operator>

#if 0
     if (s.find("_operator>") != string::npos)
        {
          printf ("This name constains the substring \"_operator>\" which will not be translated into a mangled name correctly! \n");
          printf ("   Original name = %s \n",s.c_str());
       // ROSE_ASSERT(false);
        }
#endif

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator>","_operator?");

     stringSupport (s,"operator>>","operator??");
     stringSupport (s,"operator<<","operator$$");
     stringSupport (s,"operator>","operator?");
     stringSupport (s,"operator<","operator$");
     stringSupport (s,"operator*","operator@");

     string templateMarkerStart = "<";
     int length = templateMarkerStart.size();
     while (s.find(templateMarkerStart) != string::npos)
        {
       // s.replace(s.find(templateMarkerStart),3,"__templateArgs__");
          s.replace(s.find(templateMarkerStart),length,"__tas__"); // Template Arguments Start (TAS)
        }

     string templateMarkerEnd   = ">";
     length = templateMarkerEnd.size();
     while (s.find(templateMarkerEnd) != string::npos)
        {
       // s.replace(s.find(templateMarkerEnd),3,"__");
          s.replace(s.find(templateMarkerEnd),length,"__tae__"); // Template Arguments End (TAE)
        }

     string scopeOperator       = "::";
     length = scopeOperator.size();
     while (s.find(scopeOperator) != string::npos)
        {
          s.replace(s.find(scopeOperator),length,"__scope__"); // replace scope operator in qualified names
        }

     string commaSeparator      = ",";
     length = commaSeparator.size();
     while (s.find(commaSeparator) != string::npos)
        {
          s.replace(s.find(commaSeparator),length,"__comma__"); // replace the comma separator between template arguments
        }

     string referenceMarker     = "&";
     length = referenceMarker.size();
     while (s.find(referenceMarker) != string::npos)
        {
          s.replace(s.find(referenceMarker),length,"__ref__"); // replace the comma separator between template arguments
        }

     string pointerMarker       = "*";
     length = pointerMarker.size();
     while (s.find(pointerMarker) != string::npos)
        {
          s.replace(s.find(pointerMarker),length,"__ptr__"); // replace the comma separator between template arguments
        }

  // DQ (8/10/2005): This is a fix for a bug where a "-" shows up in some template
  // arguments within names generated from compiling boost (boost/mpl/if.hpp).
  // I think that is shows up with "-1" is passed as an argument to a template.
     string minusMarker         = "_-";
     length = minusMarker.size();
     while (s.find(minusMarker) != string::npos)
        {
          s.replace(s.find(minusMarker),length,"__minus__"); // replace the minus operator between template arguments
        }

  // DQ (6/22/2005): Special case handling for substring "_operator>"
     stringSupport (s,"_operator?","_operator__tae__");

     stringSupport (s,"operator??","operator>>");
     stringSupport (s,"operator$$","operator<<");
     stringSupport (s,"operator?","operator>");
     stringSupport (s,"operator$","operator<");
     stringSupport (s,"operator@","operator*");

  // Now remove any spaces (since we can't have spaces in mangled names)
     while (s.find(" ") != string::npos)
        {
          s.replace(s.find(" "),1,"");
        }

  // printf ("In fixupTemplateNameForMangledNameSupport(): after filtering s = %s \n",s.c_str());

     ROSE_ASSERT (s.find("::") == string::npos);
     if (s.find(":") != string::npos)
        {
       // sleep(2);
          printf ("Error: failed test for embedded \":\" in template name = %s \n",s.c_str());
        }
     ROSE_ASSERT (s.find(":") == string::npos);
     ROSE_ASSERT (s.find(",") == string::npos);

     return s;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName = "Not_yet_defined_mangled_name";

     printf ("Warning: mangled name for %s not yet defined, base class SgDeclarationStatement::get_mangled_name called \n",class_name().c_str());
     ROSE_ASSERT(false);

     return returnName;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope ( SgScopeStatement* scope ) const
   {
     SgName name;

     ROSE_ASSERT(scope != NULL);

  // First setup the prefix for the generated name
     switch (scope->variantT())
        {
          case V_SgGlobal:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how
            // to assign them unique names.  See the examples for each case below.
            // SgGlobal* definition = isSgGlobal(parent);

               name = string("unnamed_class_declaration_in_global_definition_");
               break;
             }

          case V_SgClassDefinition:
             {
               name = string("unnamed_class_declaration_in_class_definition_");
               break;
             }

          case V_SgTemplateInstantiationDefn:
             {
               name = string("unnamed_class_declaration_in_class_template_definition_");
               break;
             }

          case V_SgBasicBlock:
             {
               name = string("unnamed_class_declaration_in_basic_block_");
               break;
             }

          case V_SgNamespaceDefinitionStatement:
             {
               SgNamespaceDefinitionStatement* definition = isSgNamespaceDefinitionStatement(scope);

            // DQ (3/19/2016): Klocworks reports an issue because "definition" might be NULL.
               ROSE_ASSERT(definition != NULL);

            // It might be overkill to us the mangled name here
               name = string("unnamed_declaration_in_namespace_definition_") + definition->get_mangled_name();
#if 0
               printf ("This case should be implemented the same as for the SgGlobal case above \n");
               ROSE_ASSERT(false);
#endif
               break;
             }

          default:
             {
               printf ("Default reached in unnamed declaration within parent = %p = %s \n",scope,scope->class_name().c_str());
               get_file_info()->display("Error: location of problem unnamed SgClassDeclaration");
               ROSE_ASSERT(scope->get_file_info() != NULL);
               scope->get_file_info()->display("Error: location of problem unnamed SgClassDeclaration");
               ROSE_ASSERT(false);
             }

        }

  // Now generate the unique string for the declaration (use the data/enum members where possible)
     switch(variantT())
        {
          case V_SgTemplateClassDeclaration:
             {
               printf ("ERROR: case not handled for SgTemplateClassDeclaration \n");
               ROSE_ASSERT(false);
               break;
             }

          case V_SgClassDeclaration:
             {
            // case of "class { int x; }; in global scope
               const SgClassDeclaration* classDeclaration = isSgClassDeclaration(this);
               ROSE_ASSERT(classDeclaration != NULL);
               const SgClassDefinition* classDefinition = isSgClassDefinition(this);
            // ROSE_ASSERT(classDefinition != NULL);
               if (classDefinition != NULL)
                  {
                    name = name + "defining_declaration";
                    const SgDeclarationStatementPtrList & l = classDefinition->get_members();
                    SgDeclarationStatementPtrList::const_iterator i = l.begin();
                    while (i != l.end())
                       {
                      // name += (*i)->get_name() + "_class_member_";
                         name += (*i)->get_mangled_name() + "_class_member_";
                         i++;
                       }
                  }
                 else
                  {
                    name = name + "nondefining_declaration";
                  }
               break;
             }

          case V_SgEnumDeclaration:
             {
            // case of "enum { x,y,z; }; in global scope
               name = string("unnamed_enum_declaration_in_global_definition_");

               const SgEnumDeclaration* enumDeclaration = isSgEnumDeclaration(this);
               ROSE_ASSERT(enumDeclaration != NULL);
               const SgInitializedNamePtrList & l = enumDeclaration->get_enumerators();
               SgInitializedNamePtrList::const_iterator i = l.begin();
               while (i != l.end())
                  {
                    name += (*i)->get_name() + "_enum_field_";
                    i++;
                  }
               break;
             }

          default:
             {
               printf ("Default reached in SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope (this = %p = %s) \n",
                    this,class_name().c_str());
               break;
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope() returning name = %s \n",name.str());

     return name;
   }

SgName
SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration ( SgNode* parent ) const
   {
  // This function generates a name for a class, enum, or typedef (maybe) where the declaration
  // is not provided a name in the source code.  Examples include:
  //    typedef struct { int state;} my_struct_typedef;
  //    typedef enum { zero_enum_in_typedef } mynumbers_typedef;
  //    class { int x } variable_from_anonymous_class_declaration;
  //    enum { zero_enum_field } mynumbers_enum;
  // Without this feature different classes can be mangled to the same (empty) names.

     ROSE_ASSERT(parent != NULL);

     SgName name;

     switch (parent->variantT())
        {
          case V_SgVariableDeclaration:
             {
            // SgVariableDeclaration::p_variableDeclarationContainsBaseTypeDefiningDeclaration should also be true, I think.
               SgVariableDeclaration* declaration = isSgVariableDeclaration(parent);
            // It might be overkill to us the mangled name here

            // DQ (3/19/2016): Klocworks reports an issue because "declaration" might be NULL.
               ROSE_ASSERT(declaration != NULL);

               name = string("unnamed_declaration_in_variable_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgTypedefDeclaration:
             {
            // SgTypedefDeclaration::p_typedefBaseTypeContainsDefiningDeclaration should also be true, I think.
               SgTypedefDeclaration* declaration = isSgTypedefDeclaration(parent);
            // It might be overkill to us the mangled name here

            // DQ (3/19/2016): Klocworks reports an issue because "declaration" might be NULL.
               ROSE_ASSERT(declaration != NULL);

               name = string("unnamed_declaration_in_typedef_declaration_") + declaration->get_mangled_name();
               break;
             }

          case V_SgGlobal:
          case V_SgBasicBlock:
          case V_SgClassDefinition:
          case V_SgTemplateInstantiationDefn:
          case V_SgNamespaceDefinitionStatement:
             {
            // Some unnamed declarations can appear in global scope and we have to figure out how
            // to assign them unique names.  See the examples for each case below.
            // printf ("Unnamed declaration appears in a scope (instead of another declaration) \n");
               SgScopeStatement* scope = isSgScopeStatement(parent);
               ROSE_ASSERT(scope != NULL);
               name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration_in_scope(scope);
               break;
             }

          default:
             {
               printf ("Default reached in un-named declaration within parent = %p = %s \n",parent,parent->class_name().c_str());
               get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(parent->get_file_info() != NULL);
               parent->get_file_info()->display("Error: location of problem un-named SgClassDeclaration");
               ROSE_ASSERT(false);
             }
        }

  // printf ("SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration() returning name = %s \n",name.str());

     return name;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgDeclarationStatement::get_symbol_from_symbol_table() const
   {
     printf ("Error: virtual function SgDeclarationStatement::get_symbol_from_symbol_table() called on base class SgDeclarationStatement this = %p = %s \n",this,this->class_name().c_str());
     ROSE_ASSERT(false);
     return NULL;
   }

#define DEBUG__SgDeclarationStatement__search_for_symbol_from_symbol_table 0

SgSymbol*
SgDeclarationStatement::search_for_symbol_from_symbol_table() const
   {

#if DEBUG__SgDeclarationStatement__search_for_symbol_from_symbol_table
     printf("In search_for_symbol_from_symbol_table():\n");
     printf("  this = %p : %s\n", this, this->class_name().c_str());
#endif
     SgDeclarationStatement* declaration = get_declaration_associated_with_symbol();
     if (declaration == NULL)
        {
          printf ("Error: in SgDeclarationStatement::search_for_symbol_from_symbol_table(): declaration == NULL \n");
          printf ("     this = %p = %s = %s \n",this,this->class_name().c_str(),SageInterface::get_name(this).c_str());
        }
     ROSE_ASSERT(declaration != NULL);
     SgSymbol* symbol = declaration->get_symbol_from_symbol_table();
     ROSE_ASSERT(symbol != NULL);
     return symbol;
   }

#define DEBUG_SgDeclarationStatement_get_declaration_associated_with_symbol 0

// DQ (7/4/2007): Search for the declaration that would identify the associated symbol
SgDeclarationStatement*
SgDeclarationStatement::get_declaration_associated_with_symbol() const
   {
#if DEBUG__SgDeclarationStatement__search_for_symbol_from_symbol_table
     printf("In get_declaration_associated_with_symbol():\n");
     printf("  this = %p : %s\n", this, this->class_name().c_str());
#endif
     ROSE_ASSERT(this != NULL);

     // First try: the 1st non-defining declaration
     SgDeclarationStatement * declstmt = this->get_firstNondefiningDeclaration();
     SgSymbol * sym = declstmt ? declstmt->get_symbol_from_symbol_table() : NULL;
     if (sym == NULL) {
       declstmt = this->get_definingDeclaration();
     }
     // Second try: the defining declaration
     sym = declstmt ? declstmt->get_symbol_from_symbol_table() : NULL;
     if (sym == NULL) {
       declstmt = const_cast<SgDeclarationStatement*>(this);
     }
     // Finally try: the current declaration: DQ (6/25/2007): As a special case the friend function in test2005_06.C is defined in the class and has a forward declaration outside of the class in global scope.
     sym = declstmt ? declstmt->get_symbol_from_symbol_table() : NULL;
     if (sym == NULL) {
       declstmt = NULL;
     }
     return declstmt;
   }

// DQ (7/22/2007): This should be a member function of SgDeclarationStatement
bool
SgDeclarationStatement::hasAssociatedSymbol() const
   {
     bool returnValue = true;

  // SgFunctionParameterList should likely not even be a declaration, but at least it has
  // not associated symbol in the symbol table. SgVariableDeclaration contain a list of
  // SgInitializedName objects and those have associated symbols, the SgVariableDeclaration
  // does not have an associated symbol.
     if (isSgFunctionParameterList(this)    != NULL ||
         isSgCtorInitializerList(this)      != NULL ||
         isSgAdaDiscriminatedTypeDecl(this) != NULL || /* PP: 10/21/21 experimental */
         isSgPragmaDeclaration(this)        != NULL ||
         isSgVariableDeclaration(this)      != NULL ||
         isSgVariableDefinition(this)       != NULL )
        {
          returnValue = false;
        }

     return returnValue;
   }


SgName
SgDeclarationStatement::get_template_name() const
   {
  // DQ (12/22/2011): This is an ugly aspect of supporting template declarations as derived from that which they are associated.
  // (e.g. SgTemplateClassDeclaration derived from a SgClassDeclaration).

  // But at least it is now islolated to a single function.

     SgName templateDeclarationName;
  // switch (templateDeclaration->variantT())
     switch (this->variantT())
        {
          case V_SgNonrealDecl:
             {
               templateDeclarationName = isSgNonrealDecl(this)->get_name();
               break;
             }
          case V_SgTemplateClassDeclaration:
             {
               templateDeclarationName = isSgTemplateClassDeclaration(this)->get_name();
               break;
             }

          case V_SgTemplateFunctionDeclaration:
             {
               templateDeclarationName = isSgTemplateFunctionDeclaration(this)->get_name();
               break;
             }

          case V_SgTemplateMemberFunctionDeclaration:
             {
               templateDeclarationName = isSgTemplateMemberFunctionDeclaration(this)->get_name();
               break;
             }

          case V_SgTemplateVariableDeclaration:
             {
               const SgTemplateVariableDeclaration* templateVariableDeclaration = isSgTemplateVariableDeclaration(this);
               ROSE_ASSERT(templateVariableDeclaration->get_variables().empty() == false);
               SgInitializedName* initializedName = templateVariableDeclaration->get_variables()[0];
               templateDeclarationName = initializedName->get_name();
               break;
             }

       // DQ (1/21/2013): This is a rarely used IR node in the new template support (but needs to be included).
       // See testRoseHeaders_01_combined.C for an example of where this is generated.
          case V_SgTemplateDeclaration:
             {
               templateDeclarationName = isSgTemplateDeclaration(this)->get_name();
               break;
             }

       // DQ (11/22/2016): Added case to support C++11 specific SgTemplateTypedefDeclaration IR node.
          case V_SgTemplateTypedefDeclaration:
             {
               templateDeclarationName = isSgTemplateTypedefDeclaration(this)->get_name();
               break;
             }

          default:
             {
               printf ("Error: default reached templateDeclaration = %p = %s (not a template declaration for class, function, member function, or variable) \n",this,this->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     return templateDeclarationName;
   }


SgDeclarationStatement*
SgDeclarationStatement::get_definingDeclaration () const
   {
  // DQ (1/26/2013): Added non-automatically generated versions of this function so that we could implement more testing.
     ROSE_ASSERT (this != NULL);
     return p_definingDeclaration;
   }

void
SgDeclarationStatement::set_definingDeclaration ( SgDeclarationStatement* definingDeclaration )
   {
  // DQ (1/26/2013): Added non-automatically generated versions of this function so that we could implement more testing.

     ROSE_ASSERT (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_definingDeclaration != NULL && definingDeclaration != NULL && p_definingDeclaration != definingDeclaration)
        {
          printf ("Warning: definingDeclaration = %p overwriting valid pointer p_definingDeclaration = %p \n",definingDeclaration,p_definingDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_definingDeclaration != NULL && definingDeclaration != NULL && p_definingDeclaration != definingDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_definingDeclaration = definingDeclaration;

  // DQ (5/21/2013): Added debugging code.
     if (definingDeclaration != NULL)
        {
          if (this->variantT() != definingDeclaration->variantT())
             {
               printf ("ERROR: this = %p = %s and definingDeclaration = %p = %s \n",this,this->class_name().c_str(),definingDeclaration,definingDeclaration->class_name().c_str());
             }
        }

  // DQ (10/11/2015): Added debugging output.
  // DQ (1/24/2013): Added test to make sure that we always set defining declaration to be the same type or IR node.
     if (definingDeclaration != NULL && this->variantT() != definingDeclaration->variantT())
        {
          printf ("ERROR: this = %p = %s \n",this,this->class_name().c_str());
          printf ("ERROR: definingDeclaration = %p = %s \n",definingDeclaration,definingDeclaration->class_name().c_str());
        }
     ROSE_ASSERT(definingDeclaration == NULL || this->variantT() == definingDeclaration->variantT());
   }

// *** DATA ACCESS FUNCTION SECTION ENDS HERE ***


// End of memberFunctionString
// Start of memberFunctionString
/* #line 1 "/home/dquinlan/ROSE/git-dq-edg4x-rc/src/ROSETTA/Grammar/dataMemberAccessFunctions.macro" */

// *** DATA ACCESS FUNCTION SECTION BEGINS HERE ***

SgDeclarationStatement*
SgDeclarationStatement::get_firstNondefiningDeclaration () const
   {
  // DQ (1/26/2013): Added non-automatically generated versions of this function so that we could implement more testing.
     ROSE_ASSERT (this != NULL);
     return p_firstNondefiningDeclaration;
   }

void
SgDeclarationStatement::set_firstNondefiningDeclaration ( SgDeclarationStatement* firstNondefiningDeclaration )
   {
  // DQ (1/26/2013): Added non-automatically generated versions of this function so that we could implement more testing.
     ROSE_ASSERT (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_firstNondefiningDeclaration != NULL && firstNondefiningDeclaration != NULL && p_firstNondefiningDeclaration != firstNondefiningDeclaration)
        {
          printf ("Warning: firstNondefiningDeclaration = %p overwriting valid pointer p_firstNondefiningDeclaration = %p \n",firstNondefiningDeclaration,p_firstNondefiningDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_firstNondefiningDeclaration != NULL && firstNondefiningDeclaration != NULL && p_firstNondefiningDeclaration != firstNondefiningDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_firstNondefiningDeclaration = firstNondefiningDeclaration;

  // DQ (5/21/2013): Added debugging code.
     if (firstNondefiningDeclaration != NULL)
        {
          if (this->variantT() != firstNondefiningDeclaration->variantT())
             {
               printf ("ERROR: this = %p = %s and firstNondefiningDeclaration = %p = %s \n",this,this->class_name().c_str(),firstNondefiningDeclaration,firstNondefiningDeclaration->class_name().c_str());
             }
        }

  // DQ (5/17/2014): Added debugging code.
     if (firstNondefiningDeclaration != NULL && this->variantT() != firstNondefiningDeclaration->variantT())
        {
          printf ("ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): this = %p = %s IS NOT THE SAME AS firstNondefiningDeclaration = %p = %s \n",
               this,this->class_name().c_str(),firstNondefiningDeclaration,firstNondefiningDeclaration->class_name().c_str());

       // DQ (11/23/2015): When this is called from the frontend, the source position may not have been set yet.
       // ROSE_ASSERT(this->get_file_info() != NULL);
          if (this->get_file_info() != NULL)
             {
               this->get_file_info()->display("ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): this: debug");
             }
       // ROSE_ASSERT(firstNondefiningDeclaration->get_file_info() != NULL);
          if (firstNondefiningDeclaration->get_file_info() != NULL)
             {
               firstNondefiningDeclaration->get_file_info()->display("ERROR: In SgDeclarationStatement::set_firstNondefiningDeclaration(): firstNondefiningDeclaration: debug");
             }
      }

  // DQ (10/11/2015): Added debugging output.
  // DQ (1/24/2013): Added test to make sure that we always set defining declaration to be the same type or IR node.
     if (firstNondefiningDeclaration != NULL && this->variantT() != firstNondefiningDeclaration->variantT())
        {
          printf ("ERROR: this = %p = %s \n",this,this->class_name().c_str());
          printf ("ERROR: firstNondefiningDeclaration = %p = %s \n",firstNondefiningDeclaration,firstNondefiningDeclaration->class_name().c_str());
        }
     ROSE_ASSERT(firstNondefiningDeclaration == NULL || this->variantT() == firstNondefiningDeclaration->variantT());
   }

SgType*
SgDeclarationStatement::get_type() const
   {
  // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
  // template low-level symbol table support function would compile cleanly.  Note that it is an error to
  // call this function and it is not a virtual function that will cause derived class versions to be called
  // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).

  // DQ (3/15/2014): Added warning since we don't want to be calling this function (unless we make it virtual).
     printf ("WARNING: Non-virtual base class SgDeclarationStatement::get_type() called: this = %p = %s \n",this,this->class_name().c_str());

#if 1
     printf ("Exiting as a test! \n");
     ROSE_ASSERT(false);
#endif

     return NULL;
   }


// DQ (3/10/2018): Adding support to output the name, useful for debugging template instantiations which have more complex name using template arguments.
std::string
SgDeclarationStatement::unparseNameToString()
   {
  // DQ (3/10/2018): I think tis IR node is no longer being used, so I need to move this support to the declarations.
  // DQ (3/10/2018): Adding debugging support.

  // DQ (9/24/2012): Don't add "< >" if there are no template arguments (see test2012_221.C).
  // SgName returnName = name + " < ";
     string returnName;

     SgTemplateArgumentPtrList* templateArgumentsList = NULL;

     switch(this->variantT())
        {
       // DQ (8/17/2013): These cases do not use templates.
       // This function has to handle these cases because it is called in a general context
       // on many types of declarations as part of the name qualification support.
          case V_SgNamespaceDeclarationStatement:
          case V_SgEnumDeclaration:
          case V_SgVariableDeclaration:
          case V_SgTypedefDeclaration:
             {
               templateArgumentsList = NULL;
               break;
             }

       // PC (10/11/13):  Added case of SgJavaPackageDeclaration
       // DQ (8/11/2013): Added cases for SgFunctionDeclaration and SgMemberFunctionDeclaration
       // I forget why we needed this case...
          case V_SgJavaPackageDeclaration:
          case V_SgFunctionDeclaration:
          case V_SgMemberFunctionDeclaration:
          case V_SgClassDeclaration:
             {
               templateArgumentsList = NULL;
               break;
             }

          case V_SgTemplateInstantiationDecl:
             {
               SgTemplateInstantiationDecl* templateInstantiation = isSgTemplateInstantiationDecl(this);

               returnName = templateInstantiation->get_templateName();

               templateArgumentsList = &(templateInstantiation->get_templateArguments());
               break;
             }

          case V_SgTemplateClassDeclaration:
             {
               templateArgumentsList = &(isSgTemplateClassDeclaration(this)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateInstantiationFunctionDecl:
             {
               SgTemplateInstantiationFunctionDecl* templateInstantiation = isSgTemplateInstantiationFunctionDecl(this);
               templateArgumentsList = &(isSgTemplateInstantiationFunctionDecl(this)->get_templateArguments());
               returnName = templateInstantiation->get_templateName();
               break;
             }

          case V_SgTemplateFunctionDeclaration:
             {
               templateArgumentsList = &(isSgTemplateFunctionDeclaration(this)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               SgTemplateInstantiationMemberFunctionDecl* templateInstantiation = isSgTemplateInstantiationMemberFunctionDecl(this);
               templateArgumentsList = &(isSgTemplateInstantiationMemberFunctionDecl(this)->get_templateArguments());
               returnName = templateInstantiation->get_templateName();
               break;
             }

          case V_SgTemplateMemberFunctionDeclaration:
             {
               templateArgumentsList = &(isSgTemplateMemberFunctionDeclaration(this)->get_templateSpecializationArguments());
               break;
             }

          case V_SgTemplateVariableDeclaration:
             {
               templateArgumentsList = &(isSgTemplateVariableDeclaration(this)->get_templateSpecializationArguments());
               break;
             }

       // DQ (11/10/2014): Added support for template typedef declarations.
          case V_SgTemplateTypedefDeclaration:
             {
               templateArgumentsList = &(isSgTemplateTypedefDeclaration(this)->get_templateSpecializationArguments());
               break;
             }

       // DQ (11/10/2014): Added support for template typedef declarations.
          case V_SgTemplateInstantiationTypedefDeclaration:
             {
               SgTemplateInstantiationTypedefDeclaration* templateInstantiation = isSgTemplateInstantiationTypedefDeclaration(this);
               templateArgumentsList = &(isSgTemplateInstantiationTypedefDeclaration(this)->get_templateArguments());
               returnName = templateInstantiation->get_templateName();
               break;
             }
#if 0
     // DQ (12/14/2016): Added new case
        case V_SgFunctionDeclaration:
             {
               SgFunctionDeclaration* function_declaration = isSgFunctionDeclaration(this);
               printf ("In SageBuilder::getTemplateArgumentList(): function name = %s \n",function_declaration->get_name().str());

               function_declaration->get_file_info()->display("Not clear that we should need this case since there would not be any template arguments: debug");

               printf ("Error: Not clear that we should need this case since there would not be any template arguments \n");
               ROSE_ASSERT(false);
               break;
             }
#endif
          default:
             {
               printf ("In SgDeclarationStatement::unparseNameToString(): Default reched in switch: decl = %p = %s \n",this,this->class_name().c_str());
               ROSE_ASSERT(false);
             }
        }

     bool emptyArgumentList = true;
     if (templateArgumentsList != NULL)
        {
          emptyArgumentList = templateArgumentsList->empty();

          if (emptyArgumentList == false)
               returnName += " < ";

#define DEBUG_UNPARSE_DECLARATION_NAME 0

#if 1
          SgTemplateArgumentPtrList::const_iterator i = templateArgumentsList->begin();
          while (i != templateArgumentsList->end())
             {
#if DEBUG_UNPARSE_DECLARATION_NAME
               printf ("In SgDeclarationStatement::unparseNameToString(): label = %s \n",label.c_str());
#endif

               returnName += (*i)->unparseToStringSupport();

               i++;

            // If there are more arguments then we need a "," to seperate them.
               if (i != templateArgumentsList->end())
                  {
                 // Since we have a few places were these names are generated the code is sensative to names being
                 // generated exactly the same.  So the space on both sides of the "," is critical. This will be fixed
                 // and all locations where this is done are marked with "CRITICAL FUNCTION TO BE REFACTORED".
                 // returnName += ",";
                    returnName += " , ";
                  }

#if DEBUG_UNPARSE_DECLARATION_NAME
               printf ("In SgDeclarationStatement::unparseNameToString(): (bottom of loop) returnName = %s \n",returnName.str());
#endif
             }
#endif

       // DQ (9/24/2012): Don't add "< >" if there are no tempalte arguments.
          if (emptyArgumentList == false)
             {
               returnName += " > ";
             }
        }

     return returnName;
   }



SOURCE_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT_START

bool
$CLASSNAME::isSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_specialization);
     return returnValue;
   }

bool
$CLASSNAME::isPartialSpecialization() const
   {
     bool returnValue = false;
     returnValue = (p_specialization == SgDeclarationStatement::e_partial_specialization);
     return returnValue;
   }

SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT_END


SOURCE_BASIC_BLOCK_STATEMENT_START

SgBasicBlock::SgBasicBlock(Sg_File_Info* info, SgStatement* stmt)
:$BASECLASS(info)
   {
  /* now a call to the user defined initialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

SgBasicBlock::SgBasicBlock( SgStatement* stmt )
:$BASECLASS()
   {
  /* now a call to the user defined initialization function */
     post_construction_initialization();
     if (stmt != NULL)
        {
          append_statement(stmt);

       // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
          ROSE_ASSERT(stmt->get_parent() != NULL);
        }
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgBasicBlock::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgBasicBlock::get_mangled_name(void) const
   {
     return SgName ("");
   }

void
SgBasicBlock::post_construction_initialization()
   {
   // Call the base class post_construction_initialization() member function
   // SgScopeStatement::post_construction_initialization();

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgBasicBlock::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgBasicBlock::append_statement(SgStatement * what)
   {
//   printf ("In $CLASSNAME::append_statement(): Call to insert_statement() commented out \n");
//   ROSE_ASSERT(false);

     get_statements().push_back(what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

#if 1
void
SgBasicBlock::prepend_statement(SgStatement *what)
   {
     get_statements().insert(get_statements().begin(), what);
     what->set_parent(this);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::append_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
  // Alternative that allows for appending after any statement in the list
  // insert_statement(where,what);

     SgStatementPtrList::iterator tempIterator = where;
     tempIterator++;
  // Handle the case of appending at the end of the list
     if ( tempIterator == get_statements().end() )
        {
          append_statement (what);
        }
       else
        {
          insert_statement (tempIterator,what);
        }

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::prepend_statement(const SgStatementPtrList::iterator& where, SgStatement *what)
   {
  // Alternative that allows for prepending before any statement in the list
     insert_statement(where, what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }
#endif

#if 0
void
SgBasicBlock::insert_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

#if PRINT_SIDE_EFFECT_WARNINGS
     printf ("Warning Side-Effect: Calling set_parent on %p = %s (set to %p = %s) \n",what,what->sage_class_name(),this,sage_class_name());
#endif
     what->set_parent(this);

     get_statements().insert(where,what);
   }
#endif

bool
SgBasicBlock::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, true, extractBasicBlock, true);
   }
//! insert newstmt before or after target. If extractBasicBlock is true AND newstmt is a basic
//block, insert statements from newstmt instead of inserting newstmt.
//target should be a child statement within this SgBasicBlock.
bool
SgBasicBlock::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return  StatementListInsertChild( this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
   }

SOURCE_BASIC_BLOCK_STATEMENT_END


SOURCE_IF_STATEMENT_START
void
SgIfStmt::post_construction_initialization()
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

  // printf ("Note: modified SgIfStmt::post_construction_initialization() to set parents of conditional, true_body, and false_body \n");

// #ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_conditional() != NULL) get_conditional()->set_parent(this);
     if (get_true_body()   != NULL) get_true_body  ()->set_parent(this);
     if (get_false_body()  != NULL) get_false_body ()->set_parent(this);
// #endif

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgIfStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

bool
SgIfStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     if (StatementReplace(this, p_conditional, target, newstmt) == true)
        {
          return true;
        }
       else
        {
          if (StatementReplace(this, p_true_body, target, newstmt) == true)
             {
               return true;
             }
            else
             {
               if (StatementReplace(this, p_false_body, target, newstmt) == true)
                  {
                    return true;
                  }
                 else
                  {
                    return false;
                  }
             }
        }
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgIfStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_IF_STATEMENT_END

SOURCE_FOR_INIT_STATEMENT_START

void
SgForInitStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgForInitStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgForInitStatement::append_init_stmt(SgStatement * what)
   {
     get_init_stmt().push_back(what);
     what->set_parent(this);
   }

void
SgForInitStatement::prepend_init_stmt(SgStatement * what)
   {
     get_init_stmt().insert(get_init_stmt().begin(), what);
     what->set_parent(this);
   }

#if 0
void
SgForInitStatement::insert_init_stmt(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif

  // DQ (6/24/2006): This is a structural operation so it is OK to set the parent
     what->set_parent(this);

     get_init_stmt().insert(where,what);
   }
#endif

bool
SgForInitStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, p_init_stmt, target, newstmt, true, extractBasicBlock, true);
   }

bool
SgForInitStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, p_init_stmt, target, newstmt, inFront, extractBasicBlock, false);
   }

SOURCE_FOR_INIT_STATEMENT_END


SOURCE_FOR_STATEMENT_START

$CLASSNAME::$CLASSNAME(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgStatement * loop_body) :
  $BASECLASS(),
  p_for_init_stmt(init_stmt),
  p_test(test),
  p_increment(increment),
  p_loop_body(loop_body)
{
  post_construction_initialization();
}

void
SgForStatement::post_construction_initialization()
   {
  // DQ (6/24/2006): Refactored this code to build the SgForInitStatement
  // for all SgForStatement as part of constructor.
     if (p_for_init_stmt == NULL) {
    // SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
       SgForInitStatement* forInitStatement = NULL;
       if (get_startOfConstruct() != NULL)
          {
            forInitStatement = new SgForInitStatement(New_File_Info(this));

         // DQ (10/27/2006): This will have to be updated after construction,
         // since we don't know the ending position at this point!
            forInitStatement->set_endOfConstruct(New_File_Info(this));

         // DQ (12/17/2006): Fixup the parents of Sg_File_Info objects
            forInitStatement->get_startOfConstruct()->set_parent(forInitStatement);
            forInitStatement->get_endOfConstruct()->set_parent(forInitStatement);
          }
         else
          {
            forInitStatement = new SgForInitStatement();
          }

       ROSE_ASSERT(forInitStatement != NULL);

    // All SgForStatement IR nodes should have a valid SgForInitStatement (even if it is an empty list!).
       set_for_init_stmt(forInitStatement);
     }

     p_for_init_stmt->set_parent(this);

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_test != NULL)
        {
          p_test->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_increment != NULL)
        {
          p_increment->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgForStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// MS: moved StatementPtrList to ForInitStatement. Therefore the call is simply forwarded and the same interface
SgStatementPtrList &
SgForStatement::get_init_stmt()
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     return get_for_init_stmt()->get_init_stmt();
   }

const SgStatementPtrList &
SgForStatement::get_init_stmt() const
   {
  // DQ (6/24/2006): When we later simplify the append, prepend, insert functions this will be important.
     ROSE_ASSERT(p_for_init_stmt != NULL);

     return get_for_init_stmt()->get_init_stmt();
   }

void
SgForStatement::append_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->append_init_stmt(what);
   }

void
SgForStatement::prepend_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->prepend_init_stmt(what);
   }

bool
SgForStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
       if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_for_init_stmt, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_test, target, newstmt) == true )
           return true;
       else
           return false;
   }

// DQ (11/25/2005): preserve the previous interface so that
// the most common case of where a test is an expression can
// be handled as before.  We can deprecate this function later.
// Currently the test has been modified to allow it to be a SgStatement
// and in the case of an expression, it is just a SgExprStatement.
// This is required for C and C++ which allows declarations to be
// placed where the test is evaluated in a for loop (note that this
// is part of uniform changes to the IR to fixup such details).
SgExpression*
SgForStatement::get_test_expr () const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpression*    testExpression = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
       // testExpression = exprStatement->get_the_expr();
          testExpression = exprStatement->get_expression();
          ROSE_ASSERT(testExpression != NULL);
        }
       else
        {
          printf ("test in SgForStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpression != NULL);
     return testExpression;
   }

void
SgForStatement::set_test_expr (SgExpression* expr )
   {
  // DQ (11/25/2005): preserve the previous interface. This function
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (expr != NULL);

     Sg_File_Info* fileInfo = New_File_Info(expr);
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expr);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (10/27/2006): This might have to be reset later,
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(New_File_Info(expr));

     expressionStatement->get_startOfConstruct()->set_parent(expressionStatement);
     expressionStatement->get_endOfConstruct()->set_parent(expressionStatement);

     if (get_test() != NULL)
        {
          printf ("Warning SgForStatement::set_test_expr is clobbering the existing test statement \n");
        }
     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgForStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_increment);

     set_increment(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgForStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_FOR_STATEMENT_END

SOURCE_FORALL_STATEMENT_START

void
SgForAllStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgForAllStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

SOURCE_FORALL_STATEMENT_END


SOURCE_JOVIAL_COMPOOL_STATEMENT_START
void
SgJovialCompoolStatement::post_construction_initialization()
   {
     // Nothing to setup here.
   }

SgName
SgJovialCompoolStatement::get_mangled_name(void) const
   {
      return SgName("_compool_");
   }
SOURCE_JOVIAL_COMPOOL_STATEMENT_END

SOURCE_JOVIAL_FOR_THEN_STATEMENT_START
void
SgJovialForThenStatement::post_construction_initialization()
   {
   }
SOURCE_JOVIAL_FOR_THEN_STATEMENT_END

SOURCE_JOVIAL_TABLE_STATEMENT_START
void
SgJovialTableStatement::post_construction_initialization()
   {
     // Nothing to setup here.
   }

SgName
SgJovialTableStatement::get_mangled_name(void) const
   {
   // Don't believe name mangling required for Jovial
      return get_name();
   }
SOURCE_JOVIAL_TABLE_STATEMENT_END


SOURCE_MATLAB_FOR_STATEMENT_START
void
SgMatlabForStatement::post_construction_initialization()
   {
   }
SOURCE_MATLAB_FOR_STATEMENT_END


SOURCE_RANGE_BASED_FOR_STATEMENT_START

void
SgRangeBasedForStatement::post_construction_initialization()
   {
#if 0
     printf ("In SgRangeBasedForStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (3/24/2018): Uses the same semantics as for the normal for loop IR node.
  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_iterator_declaration != NULL)
        {
          p_iterator_declaration->set_parent(this);
        }

     if (p_range_declaration != NULL)
        {
          p_range_declaration->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_begin_declaration != NULL)
        {
          p_begin_declaration->set_parent(this);
        }

     if (p_end_declaration != NULL)
        {
          p_end_declaration->set_parent(this);
        }

     if (p_not_equal_expression != NULL)
        {
          p_not_equal_expression->set_parent(this);
        }

     if (p_increment_expression != NULL)
        {
          p_increment_expression->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }
   }


bool
SgRangeBasedForStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_iterator_declaration, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_range_declaration, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_begin_declaration, target, newstmt) == true )
           return true;
       else if ( StatementReplace(this, p_end_declaration, target, newstmt) == true )
           return true;
       else
           return false;
   }


int
SgRangeBasedForStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (3/25/2018): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

  // DQ (3/26/2018): I think we need to test for each case of an SgExpression IR date member in this class (similar to statements).
  // ROSE_ASSERT(original_expression == p_range_expression);
  // set_range_expression(new_expression);

     printf ("ERROR: Semantics of SgRangeBasedForStatement::replace_expression() not implemented! \n");

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (3/25/2018): Added to provide uniform support of mangle names for all scopes
SgName
SgRangeBasedForStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }


// SgVarRefExp* SgRangeBasedForStatement::range_variable_reference()
SgExpression*
SgRangeBasedForStatement::range_expression()
   {
  // DQ (3/28/2018): Get the range variable (target container, name used for unparser).

  // Note: The container being iterated upon by the range-based for loop is reference through the initializer to the range_declaration.

     SgVariableDeclaration* local_range_declaration = get_range_declaration();
     ROSE_ASSERT(local_range_declaration != NULL);

     SgInitializedName* local_range_variable = SageInterface::getFirstInitializedName(local_range_declaration);
     ROSE_ASSERT(local_range_variable != NULL);

     SgInitializer* initializer = local_range_variable->get_initializer();
     ROSE_ASSERT(initializer != NULL);

#if 1
  // It would be general to support just returning the initializer, since there can be different kinds
  // of initializers used (see test2018_61.C, test2018_63.C, and test2018_64.C).
     return initializer;
#else
     SgAssignInitializer* assign_initializer = isSgAssignInitializer(initializer);
     if (assign_initializer == NULL)
        {
          printf ("In SgRangeBasedForStatement::range_variable_reference(): initializer = %p = %s \n",initializer,initializer->class_name().c_str());
        }
     ROSE_ASSERT(assign_initializer != NULL);

     SgExpression* range_expression = assign_initializer->get_operand();
     ROSE_ASSERT(range_expression != NULL);

     SgVarRefExp* range_reference = isSgVarRefExp(range_expression);
     if (range_reference == NULL)
        {
          printf ("In SgRangeBasedForStatement::range_variable_reference(): range_expression = %p = %s \n",range_expression,range_expression->class_name().c_str());
        }
     ROSE_ASSERT(range_reference != NULL);

     return range_reference;
#endif
   }

SOURCE_RANGE_BASED_FOR_STATEMENT_END



SOURCE_UPC_FORALL_STATEMENT_START

$CLASSNAME::$CLASSNAME(SgForInitStatement * init_stmt, SgStatement * test, SgExpression * increment, SgExpression * affinity, SgStatement * loop_body) :
  $BASECLASS(),
  p_for_init_stmt(init_stmt),
  p_test(test),
  p_increment(increment),
  p_affinity(affinity),
  p_loop_body(loop_body)
{
  post_construction_initialization();
}

// Liao, we have to duplicate most code from SgForStatement since
// SgUpcForAllStatement and SgForStatement are not related
// Copy the member functions from SgForStatement below:
void
SgUpcForAllStatement::post_construction_initialization()
   {
    if (p_for_init_stmt == NULL) {
  // SgForInitStatement* forInitStatement = new SgForInitStatement(New_File_Info(this));
     SgForInitStatement* forInitStatement = NULL;
     if (get_startOfConstruct() != NULL)
        {
          forInitStatement = new SgForInitStatement(New_File_Info(this));

       // DQ (10/27/2006): This will have to be updated after construction,
       // since we don't know the ending position at this point!
          forInitStatement->set_endOfConstruct(New_File_Info(this));

       // DQ (12/17/2006): Fixup the parents of Sg_File_Info objects
          forInitStatement->get_startOfConstruct()->set_parent(forInitStatement);
          forInitStatement->get_endOfConstruct()->set_parent(forInitStatement);
        }
       else
        {
          forInitStatement = new SgForInitStatement();
        }

     ROSE_ASSERT(forInitStatement != NULL);

  // All SgUpcForAllStatement IR nodes should have a valid SgForInitStatement (even if it is an empty list!).
     set_for_init_stmt(forInitStatement);
   }

     p_for_init_stmt->set_parent(this);

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_test != NULL)
        {
          p_test->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_increment != NULL)
        {
          p_increment->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_affinity != NULL)
        {
          p_affinity->set_parent(this);
        }

  // DQ (12/17/2006): If these are available, then set their parents as well (ok, since this is a structural issue).
     if (p_loop_body != NULL)
        {
          p_loop_body->set_parent(this);
        }
   }

// MS: moved StatementPtrList to ForInitStatement. Therefore the call is simply forwarded and the same interface
SgStatementPtrList &
SgUpcForAllStatement::get_init_stmt()
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     return get_for_init_stmt()->get_init_stmt();
   }

const SgStatementPtrList &
SgUpcForAllStatement::get_init_stmt() const
   {
  // DQ (6/24/2006): When we later simplify the append, prepend, insert functions this will be important.
     ROSE_ASSERT(p_for_init_stmt != NULL);

     return get_for_init_stmt()->get_init_stmt();
   }

void
SgUpcForAllStatement::append_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->append_init_stmt(what);
   }

void
SgUpcForAllStatement::prepend_init_stmt(SgStatement * what)
   {
  // DQ (6/24/2006): If this is always true then we can simplify this function.
     ROSE_ASSERT(p_for_init_stmt != NULL);
     get_for_init_stmt()->prepend_init_stmt(what);
   }
bool
SgUpcForAllStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_loop_body, target, newstmt) == true )
          return true;
       else
          if ( StatementReplace(this, p_for_init_stmt, target, newstmt) == true )
               return true;
            else
               return false;
   }

SgExpression*
SgUpcForAllStatement::get_test_expr () const
   {
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT(p_test != NULL);
     ROSE_ASSERT(isSgStatement(p_test) != NULL);

     SgExpression*    testExpression = NULL;
     SgExprStatement* exprStatement  = isSgExprStatement(p_test);
     if (exprStatement != NULL)
        {
       // testExpression = exprStatement->get_the_expr();
          testExpression = exprStatement->get_expression();
          ROSE_ASSERT(testExpression != NULL);
        }
       else
        {
          printf ("test in SgUpcForAllStatement is a %s \n",p_test->class_name().c_str());
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(testExpression != NULL);
     return testExpression;
   }
void
SgUpcForAllStatement::set_test_expr (SgExpression* expr )
   {
  // DQ (11/25/2005): preserve the previous interface. This function
  // sets the SgStatement using a SgExpressionRoot IR node.
     ROSE_ASSERT (this != NULL);
     ROSE_ASSERT (expr != NULL);

    Sg_File_Info* fileInfo = New_File_Info(expr);
     SgExprStatement* expressionStatement = new SgExprStatement(fileInfo,expr);
     ROSE_ASSERT(expressionStatement != NULL);

  // DQ (10/27/2006): This might have to be reset later,
  // since at this point we might not know the exact size.
     expressionStatement->set_endOfConstruct(New_File_Info(expr));

     expressionStatement->get_startOfConstruct()->set_parent(expressionStatement);
     expressionStatement->get_endOfConstruct()->set_parent(expressionStatement);

     if (get_test() != NULL)
        {
          printf ("Warning SgUpcForAllStatement::set_test_expr is clobbering the existing test statement \n");
        }
     set_test(expressionStatement);

  // DQ (4/7/2006): Set the parents
     expressionStatement->set_parent(this);

     ROSE_ASSERT(isSgStatement(p_test) != NULL);
   }
int
SgUpcForAllStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_increment);

     set_increment(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgUpcForAllStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_UPC_FORALL_STATEMENT_END

SOURCE_UPC_NOTIFY_STATEMENT_START
void
SgUpcNotifyStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_NOTIFY_STATEMENT_END

SOURCE_UPC_WAIT_STATEMENT_START
void
SgUpcWaitStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_WAIT_STATEMENT_END

SOURCE_UPC_BARRIER_STATEMENT_START
void
SgUpcBarrierStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_BARRIER_STATEMENT_END

SOURCE_UPC_FENCE_STATEMENT_START
void
SgUpcFenceStatement::post_construction_initialization()
   {
   }

SOURCE_UPC_FENCE_STATEMENT_END


SOURCE_STATIC_ASSERTION_DECLARATION_START

void
SgStaticAssertionDeclaration::post_construction_initialization()
   {
  // Not sure we have to do anything here!
   }

// We need this to be defined to avoid calling the base class version (which is an error).
SgName
SgStaticAssertionDeclaration::get_mangled_name() const
   {
  // Not sure we have to do anything here!

#if 0
     printf ("Exiting as a test! (SgStaticAssertionDeclaration::get_mangled_name() not implemented) \n");
     ROSE_ASSERT(false);
#endif

     return "static_assertion";
   }

bool
SgStaticAssertionDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node does NOT store its scope explicitly.
     return false;
   }


SOURCE_STATIC_ASSERTION_DECLARATION_END


SOURCE_FUNCTION_PARAMETER_SCOPE_START

void
SgFunctionParameterScope::post_construction_initialization()
   {
  // Nothing to do here, but we need this function to be defined.
   }

// Rasmussen (09/24/2020): Finishing implementation of SgParameterScope for Jovial
SgName
SgFunctionParameterScope::get_mangled_name(void) const
   {
     // PP (06/01/20) - just return some name
     // (or should the name be composed form the parent declaration?)
     return SgName("__function_parameter_scope__");
   }

void
SgFunctionParameterScope::append_declaration(SgDeclarationStatement * what)
   {
     get_declarations().push_back(what);
     what->set_parent(this);
   }

void
SgFunctionParameterScope::prepend_declaration(SgDeclarationStatement * what)
   {
     get_declarations().insert(get_declarations().begin(), what);
     what->set_parent(this);
   }

bool
SgFunctionParameterScope::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool
SgFunctionParameterScope::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }

SOURCE_FUNCTION_PARAMETER_SCOPE_END


SOURCE_DECLARATION_SCOPE_START

void
SgDeclarationScope::post_construction_initialization()
   {
  // Nothing to do here, but we need this function to be defined.
   }

// DQ (7/20/2017): I think that the mangled name support requires the definition of this function.
SgName
SgDeclarationScope::get_mangled_name(void) const
   {
  // I think that for this scope we need not return anything.
     return SgName ("__declaration_scope__");
   }

// DQ (7/19/2017): Added to support qualified name generation
SgName
SgDeclarationScope::get_qualified_name() const
   {
     SgNode * p = get_parent();
     if (isSgTemplateFunctionDeclaration(p)) {
       return ((SgTemplateFunctionDeclaration *)p)->get_qualified_name();
     } else if (isSgTemplateClassDeclaration(p)) {
       return ((SgTemplateClassDeclaration *)p)->get_qualified_name();
     } else if (isSgTemplateTypedefDeclaration(p)) {
       return ((SgTemplateTypedefDeclaration *)p)->get_qualified_name();
//     } else if (is(p)) {
//       return (( *)p)->get_qualified_name();
     } else {
       std::string globalScopeDelimiter = "";
       return SgName (globalScopeDelimiter);
     }
   }

SOURCE_DECLARATION_SCOPE_END


SOURCE_FUNCTION_DECLARATION_STATEMENT_START

void
SgFunctionDeclaration::post_construction_initialization()
   {
  // Sg_File_Info* thisFileInfo = get_file_info();
  // ROSE_ASSERT (thisFileInfo != NULL);

  // DQ (10/25/2004): Force generation of new file info object (all such objects should be unique)
  // initialize the FunctionParameterList as an object that is referred to from FunctionDeclaration
  // Sg_File_Info* fileInfo = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (fileInfo != NULL);

  // DQ (11/12/2006): Modified to permit being called by constructor without Sg_File_Info objects.
  // DQ (7/19/2005): set parameter list on a single location (and independently of existence of function parameters)
  // p_args = new SgFunctionParameterList(fileInfo);
     SgFunctionParameterList* args = NULL;
     if (get_startOfConstruct() != NULL)
        {
          args = new SgFunctionParameterList(New_File_Info(this));
          args->get_startOfConstruct()->set_parent(args);
        }
       else
        {
       // DQ (11/12/2006): Use the new constructor.
          args = new SgFunctionParameterList();
        }
     ROSE_ASSERT (args != NULL);
     set_parameterList(args);

  // DQ (7/19/2005): set the parent explicitly
     get_parameterList()->set_parent(this);

  // DQ (3/6/2007): Set the firstNondefiningDeclaration of args to itself (this is now required
  // for the AST consistency tests after the AST merge).  Likely because one where a member function
  // is referenced before being declared in a class the member function was not previously visited by
  // the AST traversal and so one of its defining or non-defining declarations was not set and after
  // the merge this declaration is used (shared) and thus accessed where before it had been hidden.
  // DQ (3/15/2006): Let this be NULL so that it will be fixed by the fixupDeclarations function
  // within the post processing phase.
  // DQ (9/6/2005): Since a SgFunctionParameterList is a SgDeclarationStatement we should set
  // either its defining or non-defining declaration (I choose the non-defining declaration).
  // args->set_definingDeclaration(args);
  // args->set_firstNondefiningDeclaration(args);
     args->set_firstNondefiningDeclaration(args);

  // DQ (10/25/2004): Add a ending file info object for completeness (though this is not yet
  // initialized to the correct position, yet).  Initially let's get them in place then we can
  // work on the accuracy afterward!
  // Sg_File_Info* endingPosition = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (endingPosition != NULL);
  // p_args->set_endOfConstruct(endingPosition);

  // DQ (7/31/2006): Explicit initialization of this data member is required!
  // JJW (8/6/2008): It probably isn't now that p_exceptionSpecification is a vector
     p_exceptionSpecification.clear();

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length_for_return_type     = 0;
     p_type_elaboration_required_for_return_type     = false;
     p_global_qualification_required_for_return_type = false;

#if 0 // awaiting resolution of abstract handle bug
  // driscoll6 (6/15/11) Support for python function decorators.
     SgExprListExp* decorators = SageBuilder::buildExprListExp();
     set_decoratorList(decorators);
     decorators->set_parent(this);
#endif
   }

SgType*
SgFunctionDeclaration::get_orig_return_type() const
   {
     return get_type()->get_orig_return_type();
   }

void
SgFunctionDeclaration::hasEllipses()
   {
  // Record as true!
     get_type()->set_has_ellipses(1);
   }

#if 0
/* InitalizedName tuple : (SgName, DeclStmt, type, Initializer) */
SgInitializedNamePtrList::iterator
SgFunctionDeclaration::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->insert_arg(where,what);
   }
#endif

void
SgFunctionDeclaration::append_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     get_parameterList()->append_arg(what);
   }

void
SgFunctionDeclaration::prepend_arg( SgInitializedName* what)
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     get_parameterList()->prepend_arg(what);
   }

SgInitializedNamePtrList &
SgFunctionDeclaration::get_args()
   {
  // DQ (7/19/2005): This is now set in the post_construction_initialization()
     ROSE_ASSERT(get_parameterList() != NULL);

     return get_parameterList()->get_args();
   }

const SgInitializedNamePtrList &
SgFunctionDeclaration::get_args() const
   {
  // QY:11/2/04 should make sure get_parameterList() != 0
     assert(get_parameterList() != NULL);
     return get_parameterList()->get_args();
   }

// QY:11/2/04: Removed p_mangled_name member because it is always obtained from p_type anyway
// void $CLASSNAME::set_mangled_name()
//   {
//     SgUnparse_Info info;
//     info.set_decl_stmt((SgDeclarationStatement *)this);
//     info.set_name(p_name);
//     info.set_PrintName();
//     if(p_type)
//          p_mangled_name=p_type->get_mangled(info);
//   }

bool
SgFunctionDeclaration::isTemplateFunction() const
   {
  // DQ (4/28/2005): This function tests for a template function. It is non-trivial because
  // we combine both non-template member functions in templated classes (or nested classes
  // of templated classes) with member functions that are templated.

     bool returnValue = false;

     const SgTemplateInstantiationFunctionDecl *templateFunction = isSgTemplateInstantiationFunctionDecl(this);
     if (templateFunction != NULL)
        {
          returnValue = true;

       // Error checking
          ROSE_ASSERT(templateFunction->get_templateDeclaration() != NULL);

       // DQ (12/23/2011): With the new design we no long have this data member.
       // ROSE_ASSERT(templateFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
        }
       else
        {
          const SgTemplateInstantiationMemberFunctionDecl *templateMemberFunction = isSgTemplateInstantiationMemberFunctionDecl(this);
          if (templateMemberFunction != NULL)
             {
#if 0
            // DQ (12/23/2011): With the new design we no long use a SgTemplateDeclaration as the return value for get_templateDeclaration().

            // This is a template member function but we need to know if it is a member
            // function of a template class or a template function in a non template class.
               SgTemplateDeclaration *templateDeclaration = templateMemberFunction->get_templateDeclaration();
               ROSE_ASSERT(templateDeclaration != NULL);

            // printf ("type of template declaration = %d \n",templateDeclaration->get_template_kind());
#endif
#if 0
               SgTemplateParameterPtrList *templateParameterList = templateDeclaration->get_templateParameters();
               if (templateParameterList == NULL)
                  {
                    printf ("Null pointer to SgTemplateParameterPtrList in template declaration \n");
                  }
                 else
                  {
                    int numberOfTemplateParameters = templateParameterList->size();
                    printf ("Number of template parameters = %d \n",numberOfTemplateParameters);
                  }
            // ROSE_ASSERT(templateParameterList != NULL);
#endif
            // ROSE_ASSERT(templateMemberFunction->get_templateArguments() != NULL);
               int numberOfTemplateArguments  = templateMemberFunction->get_templateArguments().size();

            // printf ("Number of template arguments  = %d \n",numberOfTemplateArguments);

               if (numberOfTemplateArguments == 0)
                  {
                 // This is the case of a non-template member function in a templated class or nested class of a templated class!
                 // printf ("This is the case of a non-template member function in a templated class or nested class of a templated class \n");
                    returnValue = false;

                 // Error checking
                 // DQ (4/17/2016): We have to allow this in some more complex template instantiations (I think).
                 // It might be work some discussion and at some point.  The case where this happens is in the
                 // instatiation of nexted template inside of outer templates and we only have a record of the
                 // outer template from the instantiation (in EDG).
                    if (templateMemberFunction->get_templateDeclaration() == NULL)
                       {
#if 0
                         printf ("Note that templateMemberFunction->get_templateDeclaration() == NULL: We have to allow this in some cases of nested templates \n");
#endif
                       }
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);
#if 0
                 // DQ (12/23/2011): With the new design we no long have this data member.

                 // DQ (8/12/2005): This can also be a template declaration for a class (at least where the template declaration is stringified presently)
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_function /* 4 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_m_class /* 2 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_m_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }

                 // DQ (12/14/2005): Added acceptable case of e_template_m_class.
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_function /* 4 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_m_class /* 2 */);
#endif
                  }
                 else
                  {
                 // printf ("This is a valid templated member function! numberOfTemplateArguments = %d \n",numberOfTemplateArguments);
                    returnValue = true;
#if 0
                 // DQ (12/23/2011): With the new design we no long have this data member.

                 // Error checking
                    ROSE_ASSERT(templateMemberFunction->get_templateDeclaration() != NULL);
                 // if (templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */)
                    if ( templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_function /* 3 */ &&
                         templateMemberFunction->get_templateDeclaration()->get_template_kind() != SgTemplateDeclaration::e_template_class /* 1 */)
                       {
                         printf ("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind() = %d != e_template_function || e_template_class \n",
                              templateMemberFunction->get_templateDeclaration()->get_template_kind());
                      // templateMemberFunction->get_file_info()->display("Error: templateMemberFunction->get_templateDeclaration()->get_template_kind()");
                      // templateMemberFunction->get_file_info()->display("debug");
                       }
                 // DQ (7/4/2005): Commented out so that we can compile KULL (substituted warning message)
                 // ROSE_ASSERT(templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */);
                    ROSE_ASSERT( templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_function /* 3 */ ||
                                 templateMemberFunction->get_templateDeclaration()->get_template_kind() == SgTemplateDeclaration::e_template_class /* 1 */);
#endif
                  }

            // printf ("type of template declaration = %d returnValue = %s \n",templateDeclaration->get_template_kind(),returnValue ? "true" : "false");
             }
        }

     return returnValue;
   }


// DQ (2/7/2006): New version added by Rich Vuduc
SgName
SgFunctionDeclaration::get_mangled_name() const
   {
  // RV (1/31/2006): Changed this routine to include the name
  // qualification in the mangled name, to guarantee the returned
  // string identifies a function uniquely. Moreover, the
  // SgMemberFunctionDeclaration child class then automatically
  // inherits the correct behavior.
  //! \todo Update ROSE manual to document the revised mangling scheme.

  // DQ (4/27/2005): I have considered making this the qualified
  // name, but decided against it. See notes in the ROSE manual
  // appendix about mangled names and qualified names.

     ROSE_ASSERT(this != NULL);

#define DEBUG_FUNCDECL_MANGLED_NAMES 0

#if DEBUG_FUNCDECL_MANGLED_NAMES
     printf ("In SgFunctionDeclaration::get_mangled_name() for this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionDeclaration* function = const_cast<SgFunctionDeclaration*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(function);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionDeclaration*>(this));

#if DEBUG_FUNCDECL_MANGLED_NAMES
     printf ("Inside of SgFunctionDeclaration::get_mangled_name(): mangledNameString.empty() = %s \n",mangledNameString.empty() ? "true" : "false");
#endif

     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("RETURN FROM CACHE: Inside of SgFunctionDeclaration::get_mangled_name(): mangledNameString = %s \n",mangledNameString.c_str());
#endif
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // DQ (6/23/2010): Added support to maintain seperate "main()" functions as unique (to avoid them being merged).
          if (this->get_name() == "main")
             {
            // Append the pointer to the name to make this unique to avoid multiple function "main()" from being merged.
               mangledName = "main_";
               mangledName += Rose::StringUtility::numberToString(const_cast<SgFunctionDeclaration*>(this));
            // printf ("RETURN FROM DETECTED MAIN: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
               return mangledName;
             }

       // Compute a mangled name from this function's type
          SgName type_name;
          SgName ret_type_name;
          SgFunctionType const * func_type = get_type();
          if (func_type != NULL)
             {
               type_name = func_type->get_mangled();
               const SgType* ret_type = func_type->get_return_type();
               if (ret_type)
                    ret_type_name = ret_type->get_mangled();
             }
            else
             {
               type_name = "defaultFunctionTypeName";
             }

#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): type_name     = %s \n",type_name.str());
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): ret_type_name = %s \n",ret_type_name.str());
#endif
       // This function's name, transformed.
          SgName func_name = mangleFunctionName (get_name(), ret_type_name);
#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): func_name = %s \n",func_name.str());
#endif
       // Compute the name qualification, if any.
          const SgScopeStatement* par_scope = get_scope();
          SgName scope_name = mangleQualifiers(par_scope);
#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): scope_name = %s \n",scope_name.str());
#endif

       // Compute the translation unit qualification, if any.
          string xlation_unit_qual = mangleTranslationUnitQualifiers(this);
#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): xlation_unit_qual = %s \n",xlation_unit_qual.c_str());
#endif
       // Compute the final mangled name.
          mangledName = joinMangledQualifiers (scope_name, xlation_unit_qual + func_name + "__" + type_name);

       // DQ (6/22/2010): Better to use the function name with the paraleter list in the mangled name.  This helps disambiguate
       // code such as:
       //    typedef struct Domain_s { } Domain_t;
       //    int foo ( Domain_s *domain);
       //    int foo ( Domain_t *domain);
#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif

       // printf ("TEMP: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionDeclaration*>(this),mangledName);
       // printf ("TEMP RETURN: Inside of SgFunctionDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());


#if DISABLED_1
       // DQ (6/21/2022): This redundantly appends the mangled name for the parameter to the end and
       // results in a compressed version of the string that is not translation unit independent.
       // This results in infinite recursion in the evaluation.
          SgFunctionParameterList* parameterList = this->get_parameterList();
          ROSE_ASSERT(parameterList != NULL);
          SgName mangledParameterList = parameterList->get_mangled_name();
          mangledName += "__" + mangledParameterList;
       // printf ("Inside of SgFunctionDeclaration::get_mangled_name(): after adding parameter list mangledName = %s \n",mangledName.str());

#if 0
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): mangledParameterList = %s \n",mangledParameterList.str());
#endif
       // Reset the mangled name in the map.
       // p_globalMangledNameMap[function] = mangledName;
          SgNode::get_globalMangledNameMap()[const_cast<SgFunctionDeclaration*>(this)] = mangledName;
#endif /* DISABLED_1 */

#if DEBUG_FUNCDECL_MANGLED_NAMES
          printf ("Inside of SgFunctionDeclaration::get_mangled_name(): after resetting mangledName = %s \n",mangledName.str());
#endif

       // DQ (7/24/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          //if ( mangledName.getString().find('<') != string::npos )
          //   {
          //     printf ("In get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangledName.getString().c_str());
          //   }
          ROSE_ASSERT(mangledName.getString().find('<') == string::npos);

#if DEBUG_FUNCDECL_MANGLED_NAMES
       // DQ (7/24/2012): Output the mangled name being generated for debugging.
          printf (">>>>>>>>>> SgFunctionDeclaration::get_mangled_name(): returning mangledName = %s \n",mangledName.str());
#endif

          return mangledName;
        }
   }

// SgStatement* get_next(int&) const;

bool
SgFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_definition, target, newstmt) == true )
          return true;
     else
          return ( StatementReplace(this, p_parameterList, target, newstmt) == true );
   }

#if 0
// DQ (8/18/2004): Removing older attribute mechanism

/******  SgFunctionDeclaration ******/
/* suppress the printing of atomic keyword */
int
get_suppress_atomic ($CLASSNAME *node)
   {
     SgFuncDecl_attr *attr=
         (SgFuncDecl_attr *) Sgget_user_attribute
              (node->get_uattributes(),"SgFuncDecl_attr");
     if(attr)
        return attr->get_suppress_atomic();

     return 0;
   }
#endif

// DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
// for example: "template <typename T> class X { X(); }; X<int>::X() {}"

// DQ (10/20/2004): This function should be different from those that are automatically generated
// via ROSETTA.  In the case of a constructor or destructor the class name should be used.  This
// is particularly important in the case of constructors and destructors of templated classes since
// the mangled form or the template class should not be used since it will not allow the generated
// code to compile.  Instead of names of the form "ABC____L8" we want names of the form "ABC<int>".
// These functions are now implemented explicitly instead of being automatically generated via ROSETTA.
// SgName get_name() const
//    {
//      SgName returnName = p_name;
//      if ( get_specialFunctionModifier().isConstructor() ||
//           get_specialFunctionModifier().isDestructor()  ||
//           get_specialFunctionModifier().isConversion() )
//         {
//            printf ("In $CLASSNAME::get_name: case of a constructor, destructor or conversion operator \n");
//            returnName = "Use the class Name";
//         }
//
//      return returnName;
//    }

// SgName SgFunctionDeclaration::get_qualified_name();
SgName
SgFunctionDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     return returnName;
   }


bool
SgFunctionDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgFunctionDeclaration::get_symbol_from_symbol_table() const
   {
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (3/1/2014): This could be a scope from a deleted AST and if we would like to
  // think that the SgFunctionDeclaration would have been deleted, but it could have
  // been the first non-defining declaration constructed to support the symbol), and
  // thus not strictly in the AST. In this case so we would like return NULL.
  // The test for if this is a deletec IR node is if the variant is V_SgNode.
     if (scope->variantT() == V_SgNode)
        {
          printf ("SgFunctionDeclaration::get_symbol_from_symbol_table(): This is a deleted IR node (returning NULL) \n");
          return NULL;
        }
     ROSE_ASSERT(scope->variantT() != V_SgNode);

  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
     printf ("In SgFunctionDeclaration::get_symbol_from_symbol_table(): this = %p = %s = %s scope = %p = %s scope->get_symbol_table() = %p \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),scope,scope->class_name().c_str(),scope->get_symbol_table());
#endif
  // return scope->get_symbol_table()->find(this);
     return scope->find_symbol_from_declaration(this);

  // ROSE_ASSERT(get_scope() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
   }


SgName
SgFunctionDeclaration::get_qualified_name_prefix_for_return_type() const
   {
  // DQ (5/29/2011): Added to support for new qualified name generation.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgFunctionDeclaration*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
       // printf ("Found a valid name qualification: nameQualifier %s \n",nameQualifier.str());
        }

  // printf ("nameQualifier for SgFunctionDeclaration = %s = %s \n",class_name().c_str(),nameQualifier.str());

     return nameQualifier;
   }

SgName
SgFunctionDeclaration::get_template_header() const
   {
  // DQ (9/7/2014): Added to support template headers in template declarations (member and non-member function declarations).

     SgName template_header;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTemplateHeaders().find(const_cast<SgFunctionDeclaration*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

     if (i != SgNode::get_globalQualifiedNameMapForTemplateHeaders().end())
        {
          template_header = i->second;
#if 0
          printf ("Found a valid template header : template_header %s \n",template_header.str());
#endif
        }
#if 0
     printf ("template_header for SgFunctionDeclaration = %p = %s = %s \n",this,class_name().c_str(),template_header.str());
#endif

     return template_header;
   }


bool
SgFunctionDeclaration::isNormalizedTemplateFunction() const
   {
  // DQ (12/22/2014): Adding support for EDG normalized template member and non-member functions.
  // EDG normalizes member and non-member function definitions defined in template classes.
  // As a result we need to detect where this normalization is done in both the unparser and
  // the token mapping.  Where the normalization has been done the text string saved in EDG
  // and used in ROSE is only representing the body of the function and so the unparser must
  // know to generate the function prototype declaration to assemble with the function body
  // held as text.  In the future we will unparse the template declarations from the AST and/or
  // the token stream, but that is a later step.

     bool string_represents_function_body = false;
     const SgTemplateFunctionDeclaration*       templateFunctionDeclaration       = isSgTemplateFunctionDeclaration(this);
     const SgTemplateMemberFunctionDeclaration* templateMemberFunctionDeclaration = isSgTemplateMemberFunctionDeclaration(this);
     if (templateFunctionDeclaration != NULL)
        {
       // printf ("This is a SgTemplateFunctionDeclaration \n");
          string_represents_function_body = templateFunctionDeclaration->get_string_represents_function_body();
        }
       else
        {
          if (templateMemberFunctionDeclaration != NULL)
             {
            // printf ("This is a SgTemplateMemberFunctionDeclaration \n");
               string_represents_function_body = templateMemberFunctionDeclaration->get_string_represents_function_body();
            // template_function_name = templateMemberFunctionDeclaration->get_name();
             }
            else
             {
#if 0
            // This is likely a SgTemplateClassDeclaration
               if (isSgTemplateClassDeclaration(this) == NULL)
                  {
                    printf ("Error: In SgFunctionDeclaration::isNormalizedTemplateFunction(): What is this if not a template function or template member function stmt = %p = %s \n",this,this->class_name().c_str());
                  }
#endif
             }
        }

     return string_represents_function_body;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgFunctionDeclaration::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgFunctionDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgFunctionDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgFunctionDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgFunctionDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgFunctionDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

bool
SgFunctionDeclaration::get_requiresNameQualificationOnReturnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresNameQualificationOnReturnType;
   }

void
SgFunctionDeclaration::set_requiresNameQualificationOnReturnType ( bool requiresNameQualificationOnReturnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresNameQualificationOnReturnType = requiresNameQualificationOnReturnType;
   }


int
SgFunctionDeclaration::get_name_qualification_length_for_return_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_return_type;
   }

void
SgFunctionDeclaration::set_name_qualification_length_for_return_type(int name_qualification_length_for_return_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_return_type = name_qualification_length_for_return_type;
   }

bool
SgFunctionDeclaration::get_type_elaboration_required_for_return_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_return_type;
   }

void
SgFunctionDeclaration::set_type_elaboration_required_for_return_type(bool type_elaboration_required_for_return_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_return_type = type_elaboration_required_for_return_type;
   }

bool
SgFunctionDeclaration::get_global_qualification_required_for_return_type() const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_return_type;
   }

void
SgFunctionDeclaration::set_global_qualification_required_for_return_type(bool global_qualification_required_for_return_type)
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_return_type = global_qualification_required_for_return_type;
   }


SOURCE_FUNCTION_DECLARATION_STATEMENT_END


SOURCE_FUNCTION_PARAMETER_LIST_START

void
SgFunctionParameterList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Fixup parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgFunctionParameterList::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

#if 0
SgInitializedNamePtrList::iterator
SgFunctionParameterList::insert_arg(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/24/2004): this should be true but verify it!
     ROSE_ASSERT(what != NULL);

     SgInitializedNamePtrList::iterator new_item = get_args().insert(where, what);

  // DQ (9/24/2004): This code requires that parent pointers be set in the AST
  // (which we would like to defer to post-processing AST Fixup).  See if we can
  // eliminate this code.  The declaration in the InitializedName should have
  // already been set anyway, so I don't think it should be reset!  Though it
  // could be that it is not set to the function declaration!
#ifndef REMOVE_SET_PARENT_FUNCTION
     SgFunctionDeclaration* declStmt  = dynamic_cast<SgFunctionDeclaration*>(get_parent());
     ROSE_ASSERT(declStmt!=0);
     (*new_item)->set_declaration(declStmt); // MS: 'get_parent' instead of 'this'
#else
  // Verify that the declaration of all function parameters have been set to the function declaration!
    // ROSE_ASSERT((*new_item)->get_declaration() != NULL);
   //  ROSE_ASSERT ( isSgFunctionDeclaration( (*new_item)->get_declaration() ) != NULL );

//   if ( (*new_item)->get_declaration()->variantT() != V_SgFunctionDeclaration &&
//        (*new_item)->get_declaration()->variantT() != V_SgMemberFunctionDeclaration )
//      {
//        printf ("Error: function parameter declaration (not SgFunctionDeclaration or SgMemberFunctionDeclaration) set to %s \n",(*new_item)->get_declaration()->sage_class_name());
//      }
//   ROSE_ASSERT ( (*new_item)->get_declaration()->variantT() == V_SgFunctionDeclaration ||
//                 (*new_item)->get_declaration()->variantT() == V_SgMemberFunctionDeclaration );
#endif
     return new_item;
   }
#endif

void
SgFunctionParameterList::append_arg( SgInitializedName* what)
   {
     get_args().push_back(what);
     what->set_parent(this);
     // SgFunctionDeclaration* declStmt = isSgFunctionDeclaration(this->get_parent());
   }

void
SgFunctionParameterList::prepend_arg( SgInitializedName* what)
   {
     get_args().insert(get_args().begin(), what);
     what->set_parent(this);
     // SgFunctionDeclaration* declStmt = isSgFunctionDeclaration(this->get_parent());
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgFunctionParameterList::get_mangled_name(void) const
   {
#if 0
  // printf ("In $CLASSNAME::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames = "_args_";
     SgInitializedNamePtrList::const_iterator p = get_args().begin();
     while ( p != get_args().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_function_parameter_list_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
#else
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
  // SgFunctionParameterList* declaration = const_cast<SgFunctionParameterList*>(this);
  // std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
  // if (i != p_globalMangledNameMap.end())
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgFunctionParameterList*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName variableNames = "_args_";
          SgInitializedNamePtrList::const_iterator p = get_args().begin();
          while ( p != get_args().end() )
             {
            // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
               variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

               p++;
             }

       // DQ (6/22/2010): Better to use the function name instead of the scopes mangled name.  This helps disambiguate
       // code such as:
       //    typedef struct Domain_s { } Domain_t;
       //    int foo ( Domain_s *domain);
       //    int foo ( Domain_t *domain);
       // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
       // This is a poor way to handle the generation of a mangled name (will be improved)
          SgName mangledName = get_scope()->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;
       // SgFunctionDeclaration* functionDeclaration = isSgFunctionDeclaration(get_parent());
       // ROSE_ASSERT(functionDeclaration != NULL);
       // SgName mangledName = functionDeclaration->get_mangled_name() + SgName("_function_parameter_list_") + variableNames;
#if 0
          printf ("Inside of SgFunctionParameterList::get_mangled_name(void): mangledName = %s \n",mangledName.str());
#endif
       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgFunctionParameterList*>(this),mangledName);
       // printf ("RETURN: Inside of SgFunctionParameterList::get_mangled_name(void): mangledName = %s \n",mangledName.str());

          return mangledName;
        }
#endif
   }

SOURCE_FUNCTION_PARAMETER_LIST_END



SOURCE_ADA_PARAMETER_LIST_START

void
SgAdaParameterList::post_construction_initialization()
   {
     if (get_file_info() && !get_endOfConstruct())
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

          endingPosition->set_parent(this);
          set_endOfConstruct(endingPosition);
        }
   }

void
SgAdaParameterList::append_parameter( SgDeclarationStatement* what)
   {
     get_parameters().push_back(what);
     what->set_parent(this);
   }

void
SgAdaParameterList::prepend_parameter( SgDeclarationStatement* what)
   {
     get_parameters().insert(get_parameters().begin(), what);
     what->set_parent(this);
   }

SgName
SgAdaParameterList::get_mangled_name(void) const
   {
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgAdaParameterList*>(this));

     if (!mangledNameString.empty())
          return mangledNameString;

     mangledNameString = get_scope()->get_mangled_name().getString() + "_ada_parameter_list_";

     for (const SgDeclarationStatement* parm : get_parameters())
     {
        ASSERT_not_null(parm);

        mangledNameString += "_parameter_";
        mangledNameString += parm->get_mangled_name();
     }

     return SageInterface::addMangledNameToCache(const_cast<SgAdaParameterList*>(this), mangledNameString);
   }

SOURCE_ADA_PARAMETER_LIST_END



SOURCE_FUNCTION_DECLARATION_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_FunctionDeclaration* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of INCOMPLETE $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

#if 0
  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

     printf ("function declaration name = %s \n",Xptr->get_name().str());

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* new_fileInfo =
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (new_fileInfo != NULL);

#if 1
  // Build a new name object (all are identical to SgName)
     SgName* new_name = new SgName (Xptr->get_name().str());
     ROSE_ASSERT (new_name != NULL);

     printf ("WARNING: Need to specify more date to the $CLASSNAME constructor! \n");

     $CLASSNAME* returnValuePtr = new $CLASSNAME(new_fileInfo,new_name);
     ROSE_ASSERT (returnValuePtr != NULL);
#else
     $CLASSNAME* returnValuePtr = NULL; // new $CLASSNAME(new_fileInfo);
#endif
#endif

     $CLASSNAME* returnValuePtr = NULL;
     ROSE_ASSERT (returnValuePtr != NULL);

     return returnValuePtr;
   }

SOURCE_FUNCTION_DECLARATION_STATEMENT_PARSER_END



SOURCE_FUNCTION_DEFINTION_STATEMENT_START

// DQ (10/4/2006): Support for static map of SgBasicBlock IR nodes to integers.
// std::map<SgBasicBlockPtr, int> SgFunctionDefinition::p_block_number_map;

void
SgFunctionDefinition::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgFunctionDefinition::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

SgFunctionDefinition::SgFunctionDefinition(Sg_File_Info* f, SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(f), p_body(body)
   {
     set_declaration(d);
     if (d!=NULL) // Liao, 4/14/2009. Support bottom-up AST building: definition is built first, declaration may be still NULL
      d->set_definition(this);
   }

SgFunctionDefinition::SgFunctionDefinition( SgFunctionDeclaration* d, SgBasicBlock* body)
   : SgScopeStatement(), p_body(body)
   {
     set_declaration(d);
     if (d!=NULL)
      d->set_definition(this);
   }

SgFunctionDeclaration*
SgFunctionDefinition::get_declaration() const
   {
     SgNode* res = get_parent();
     SgFunctionDeclaration* res1 = isSgFunctionDeclaration(res);
     assert( res == 0 || res1 != 0);
     return res1;
   }

void
SgFunctionDefinition::set_declaration(SgFunctionDeclaration* new_val)
   {
     set_parent(new_val);
   }

bool
SgFunctionDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

void
SgFunctionDefinition::append_statement(SgStatement * what)
   {
     assert(this != NULL);
     if (!get_body())
        {
          set_body(new SgBasicBlock(New_File_Info(this)));
        }
     get_body()->append_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgFunctionDefinition::prepend_statement(SgStatement *what)
   {
     assert(this != NULL);
     if(!get_body()) {
          set_body(new SgBasicBlock(New_File_Info(this)));
     }
     get_body()->prepend_statement(what);

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// RV (2/5/2006): Added name mangling for function definitions
SgName
SgFunctionDefinition::get_mangled_name (void) const
   {
     const SgFunctionDeclaration* decl = get_declaration ();
     ROSE_ASSERT (decl);
     return decl->get_mangled_name ();
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique
// labels for scopes in a function (as required for name mangling).
std::map<SgNode*,int> &
SgFunctionDefinition::get_scope_number_list()
   {
     return p_scope_number_list;
   }

// DQ (10/5/2006): Added support for faster (non-quadratic) computation of unique
// labels for scopes in a function (as required for name mangling).
int
SgFunctionDefinition::get_scope_number ( const SgNode* scope ) const
   {
     SgFunctionDefinition* modifiableThis = const_cast<SgFunctionDefinition*>(this);
     SgNode* modifiableScope = const_cast<SgNode*>(scope);
     if (p_scope_number_list.empty() == true)
        {
       // Build a local reference that can be modified (cast cost from this cost function to get access).
          modifiableThis->resetScopeNumbers();
        }

     ROSE_ASSERT (p_scope_number_list.empty() == false);

  // int uniqueScopeNumber = p_scope_number_list[scope];

  // Make sure that the required entry is in the map!
     std::map<SgNode*, int>::const_iterator iter = this->p_scope_number_list.find(modifiableScope);
     if (iter == this->p_scope_number_list.end())
        {
#if 0
          printf ("In Function = %p = %s = %s \n",get_declaration(),get_declaration()->class_name().c_str(),SageInterface::get_name(get_declaration()).c_str());
          printf ("Looking for scope = %p = %s \n",scope,scope->class_name().c_str());
          scope->get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: input scope debug");
          get_startOfConstruct()->display("Error: SgFunctionDefinition::get_scope_number: debug");
          for (std::map<SgNode*,int>::const_iterator i = p_scope_number_list.begin(); i != p_scope_number_list.end(); i++)
             {
               printf ("i->first = %p = %s i->second = %d \n",i->first,i->first->class_name().c_str(),i->second);
             }
#else
          int n = (int)modifiableThis->p_scope_number_list.size() + 1;
          modifiableThis->p_scope_number_list[modifiableScope] = n;
          iter = this->p_scope_number_list.find(modifiableScope);
#endif
        }
     ROSE_ASSERT(iter != this->p_scope_number_list.end());

     int uniqueScopeNumber = iter->second;

#if 0
     printf ("uniqueScopeNumber = %d for scope = %p = %s of function = %s \n",
          uniqueScopeNumber,scope,scope->class_name().c_str(),get_declaration()->get_name().str());
#endif

     ROSE_ASSERT(uniqueScopeNumber > 0);

     return uniqueScopeNumber;
   }

void
SgFunctionDefinition::clearScopeNumbers()
   {
  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::clearScopeNumbers(this);
   }

void
SgFunctionDefinition::resetScopeNumbers()
   {
  // This function will be called automatically when get_scope_number() is call if the p_scope_number_list is empty.

  // std::map<SgNode*,int> & scopeMap = get_scope_number_list();
  // ROSE_ASSERT(scopeMap.empty() == true);

  // This functionality is moved out of the IR node to were it can be more easily developed (initially at least).
     SageInterface::resetScopeNumbers(this);
   }

std::ostream & operator<< ( std::ostream & os, std::map<SgNode*,int> & x )
   {
  // printf ("Error: Not implemented, operator<< ( std::ostream & os, std::map<SgNode*,int> & x ) \n");
  // os << " pair (" << (*x).first.str() << "," << ((*x).second) << ")";

     os << "output operator for std::map<SgNode*,int> not implemented";
     return os;
   }

// DQ (1/8/2007): Added to support qualified name generation (this forces
// function parameters to have the correct qualified name, same as local
// variables declared in the scope of the function more directly (which
// is handled by having a special implementation of "SgBasicBlock::get_qualified_name() const"
SgName
SgFunctionDefinition::get_qualified_name() const
   {
  // DQ (8/28/2005): This is where we might name blocks if we select to do so at some point
  // as a way of building unique names for qualified named declarations.

  // Note that this will still evaluate so that "returnName.is_null()" will be true
     SgName returnName = "";
     return returnName;
   }


// MD (09/20/2010): Accessor for preinitialization lists associated with
// this (constructor) definition. NULL if this has no such list.
SgCtorInitializerList*
SgFunctionDefinition::get_CtorInitializerList() const {
  SgMemberFunctionDeclaration* memDecl = NULL;
  SgCtorInitializerList* ctorList = NULL;
  if ((memDecl = isSgMemberFunctionDeclaration(get_declaration())) != NULL &&
      (ctorList = memDecl->get_CtorInitializerList()) != NULL)
      return ctorList;
  else
    return NULL;
}

SOURCE_FUNCTION_DEFINTION_STATEMENT_END

SOURCE_FUNCTION_DEFINTION_STATEMENT_PARSER_START

// This is a specialized parse function for the $CLASSNAME class defined in Statement.code

// We include the "Sg" in the name of the parse function because we want each grammar's
// collection of overloaded parse functions to return the root node of that grammar.  Since multiple
// grammars exist we have to have different collections of overloaded parse functions return different
// types, and overloaded functions must return the same type (C++ language constraint).  The solution is to have
// the overloaded parse functions for each grammar share the names that are unique to that grammar only.
// thus we prefix the parse member function name with "Sg".


SgNode*
Sgparse ( $PARENT_GRAMMARS_PREFIX_FunctionDefinition* Xptr )
   {
  // Function description:
  // This function parses the lower level grammar into a higher level grammar

  // Specifics of this function:
  // We could bury the reference to the project into this function since their is only one global scope
  // Or we could pass the project as a parameter to this function (since it is the root of all program trees?)

     printf ("Inside of $CLASSNAME friend function Sgparse($PARENT_GRAMMARS_PREFIX_Global*) \n");

#if 0
  // This makes no sense

  // Error checking
     ROSE_ASSERT(Xptr != NULL);
     ROSE_ASSERT(Xptr->getGrammar() != NULL);
     if (Xptr->getGrammar()->isRootGrammar() == true)
        {
       // it is an error for isRootGrammar() == true
          printf ("ERROR: isRootGrammar() == true in SgScopeStatement::parse ( $PARENT_GRAMMARS_PREFIX_ScopeStatement* X )! \n");
          ROSE_ASSERT(false);
        }

     ROSE_ASSERT(Xptr->getGrammar()->isRootGrammar() == false);
#endif

  // Later we will automate the generation of this code
  // $PARSE_CODE_FOR_LIST

  // printf ("function name = %s \n",p_name.str());

     $PARENT_GRAMMARS_PREFIX__File_Info* parentGrammarFileInfo = Xptr->get_file_info();
     ROSE_ASSERT (parentGrammarFileInfo != NULL);
     Sg_File_Info* fileInfo =
          new Sg_File_Info (parentGrammarFileInfo->get_filename(),
                                          parentGrammarFileInfo->get_line(),
                                          parentGrammarFileInfo->get_col());
     ROSE_ASSERT (fileInfo != NULL);

     printf ("WARNING Need more data for $CLASSNAME constructor! \n");

     $CLASSNAME* returnValuePtr = new $CLASSNAME(fileInfo);
     ROSE_ASSERT (returnValuePtr != NULL);

     return returnValuePtr;
   }

SOURCE_FUNCTION_DEFINTION_STATEMENT_PARSER_END


SOURCE_MEMBER_FUNCTION_DECLARATION_STATEMENT_START

bool
SgMemberFunctionDeclaration::isDefinedInClass() const
   {
     bool returnValue = false;

  // If the scopes are the same then the class is structurally defined in the class scope
     bool isDefiningDeclaration  = (get_definition() != NULL);
     bool isDeclaredInClassScope = (get_parent() == get_scope());
     if ( (isDefiningDeclaration == true) && (isDeclaredInClassScope == true) )
          returnValue = true;

     return returnValue;
   }


void
SgMemberFunctionDeclaration::post_construction_initialization()
   {
  // DQ (9/15/2005): Remove side-effect from get_ctors() member function.
  // This was a problem for the AST tests where the post processing saw a
  // NULL pointer and then the unparser was called in the rewrite mechanism
  // and then the AST tests failed because the pointer was non-NULL (and
  // also the SgCtorInitializerList had not been properly setup).
  // p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
     if (get_startOfConstruct() != NULL)
        {
          p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
        }
       else
        {
          p_CtorInitializerList = new SgCtorInitializerList();
        }
     ROSE_ASSERT(p_CtorInitializerList != NULL);

  // Like the "enum" declaration (SgEnumDeclaration) this can only be defined
  // once, so it is its defining declaration.  Well, not exactly.  The uniform
  // handling of the defining and non-defining declarations requires that this
  // be set as the firstNondefining declaration.  This might be an error and
  // should be reviewed.

  // DQ (9/20/2005): Need to set the nondefining declaration instead of the defining declaration!
  // p_CtorInitializerList->set_definingDeclaration(p_CtorInitializerList);
     p_CtorInitializerList->set_firstNondefiningDeclaration(p_CtorInitializerList);

  // DQ (9/21/2005): Added warning since this is an issue worth review!
  // printf ("Warning: Set p_CtorInitializerList = %p firstNondefiningDeclaration to self, unclear if this is correct \n",p_CtorInitializerList);

  // DQ (9/21/2005): set the parent so that the scope will be computed correctly
  // (scope is not stored explicitly on the SgCtorInitializerList IR node).
     p_CtorInitializerList->set_parent(this);

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgMemberFunctionDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgMemberFunctionDeclaration::append_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL)
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->append_ctor_initializer(iName);
   }

void
SgMemberFunctionDeclaration::prepend_ctor_initializer( SgInitializedName* iName)
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL)
  //     set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     get_CtorInitializerList()->prepend_ctor_initializer(iName);
   }

SgInitializedNamePtrList &
SgMemberFunctionDeclaration::get_ctors()
   {
     ROSE_ASSERT(p_CtorInitializerList != NULL);
  // if (get_CtorInitializerList() == NULL)
  //    set_CtorInitializerList(new SgCtorInitializerList(New_File_Info(this)));
     return get_CtorInitializerList()->get_ctors();
   }

const SgInitializedNamePtrList &
SgMemberFunctionDeclaration::get_ctors() const
   {
     ROSE_ASSERT(get_CtorInitializerList() != NULL);
     return get_CtorInitializerList()->get_ctors();
   }

// SgName SgMemberFunctionDeclaration::get_qualified_name();
SgName
SgMemberFunctionDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistent other get_qualified_name functions
  // It previously only returned the name of the class to which is was a member function!
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName::assembleQualifiedName (scope->get_qualified_name(), get_name ());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

void
SgMemberFunctionDeclaration::set_orig_return_type(SgType *t)
   {
   // QY: removed p_orig_return_type. reset p_type by making another member function type (the original p_type might be shared?)
  // DQ (10/6/2004): Not sure why this works this way!
     ROSE_ASSERT(t != NULL);

     SgMemberFunctionType *ntype = isSgMemberFunctionType(get_type())->mkAnotherType(t);
     ROSE_ASSERT (ntype != NULL);
     set_type(ntype); // reset function type if necessary
   }

bool
SgMemberFunctionDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( SgFunctionDeclaration::replace_child(target, newstmt,extractBasicBlock) == true )
        {
          return true;
        }
       else
        {
       // Handle other possible replacements
          if ( StatementReplace(this, p_scope, target, newstmt) == true )
             {
               return true;
             }
            else
             {
               return ( StatementReplace(this, p_CtorInitializerList, target, newstmt) == true );
             }
        }
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
SgDeclarationStatement*
SgMemberFunctionDeclaration::get_associatedClassDeclaration () const
   {
     assert (this != NULL);
  // return p_associatedClassDeclaration;

     SgDeclarationStatement* returnValue = NULL;

  // The p_associatedClassDeclaration is only set when the class definition is unavailable (not defined in the current
  // translation unit) and yet there is a class declared for there to be a member function declared.  This is always
  // the case of a pointer to a member function, since only in this case can the pointer to a member function be declared
  // without a member function having been declared.
     if (p_associatedClassDeclaration != NULL)
        {
       // If this is a valid pointer then it is only because the class definition has not been seen (and this backup
       // mechanism has been used to relate the member function to the class declaration).
          returnValue = p_associatedClassDeclaration;
        }
       else
        {
       // When p_associatedClassDeclaration == NULL, it is because the class definition exists (and the backup mechanism
       // of relating the member function to the class declaration was not required) and so the class declaration can be
       // obtained directly from the class definition.
          SgScopeStatement* scope = get_class_scope();
          SgClassDefinition * cdefn = isSgClassDefinition(scope);
          SgDeclarationScope * nrscope = isSgDeclarationScope(scope);

          if (cdefn != NULL) {
            returnValue = cdefn->get_declaration();
          } else if (nrscope != NULL) {
            SgNode * nrscope_parent = nrscope->get_parent();
            ROSE_ASSERT(nrscope_parent != NULL);
#if 0
            printf("nrscope_parent = %p (%s)\n", nrscope_parent, nrscope_parent ? nrscope_parent->class_name().c_str() : "");
#endif
            SgTemplateClassDeclaration * tpldecl = isSgTemplateClassDeclaration(nrscope_parent);
            SgNonrealDecl * nrdecl = isSgNonrealDecl(nrscope_parent);
            if (tpldecl != NULL) {
              returnValue = tpldecl;
            } else if (nrdecl != NULL) {
#if 0
              printf ("WARNING: retuning a non-real declaration from SgMemberFunctionDeclaration::get_associatedClassDeclaration \n");
#endif
              returnValue = nrdecl;
            } else {
              ROSE_ASSERT(false);
            }
          } else {
            printf ("ERROR: retuning NULL from SgMemberFunctionDeclaration::get_associatedClassDeclaration \n");
            returnValue = NULL;
          }
        }

     return returnValue;
   }

// DQ (10/12/2007): This is no longer a ROSETTA generated function, so that we can hide the get_associatedClassDeclaration
// member, making it private to only support the SgMemberFunctionDeclaration::get_class_scope() member function.
// This SgMemberFunctionDeclaration::set_associatedClassDeclaration() member function is public so that it can be set in
// construction of the AST.
void
SgMemberFunctionDeclaration::set_associatedClassDeclaration ( SgDeclarationStatement* associatedClassDeclaration )
   {
     assert (this != NULL);
     set_isModified(true);

#if DEBUG_SAGE_ACCESS_FUNCTIONS
     if (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration)
        {
          printf ("Warning: associatedClassDeclaration = %p overwriting valid pointer p_associatedClassDeclaration = %p \n",associatedClassDeclaration,p_associatedClassDeclaration);
#if DEBUG_SAGE_ACCESS_FUNCTIONS_ASSERTION
          printf ("Error fails assertion (p_associatedClassDeclaration != NULL && associatedClassDeclaration != NULL && p_associatedClassDeclaration != associatedClassDeclaration) is false\n");
          ROSE_ASSERT(false);
#endif
        }
#endif
     p_associatedClassDeclaration = associatedClassDeclaration;
   }

SgScopeStatement*
SgMemberFunctionDeclaration::get_class_scope(void) const
   {
  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!

  // DQ (12/5/2004): The scope is explicit and should be a valid pointer (if not it is an error!)
  // ROSE_ASSERT(p_scope != NULL);

  // DQ (11/17/2004): Note that get_scope returns a SgScopeStatement, but member functions are always part
  // of a SgClassDefinition and we want to reflect this and be as consistent as possible with the former
  // get_scope() function which was only defined on the SgMemberFunctionDeclaration but is now defined on
  // many different IR nodes (as a result of a major bug fix specific to scopes vs. parents handling).
  // SgClassDefinition *parentScope = isSgClassDefinition(get_scope());
     SgScopeStatement* parentScope = NULL;

  // DQ (10/12/2007): Modified to access the p_associatedClassDeclaration data member directly because
  // the get_associatedClassDeclaration() member function is more than an access function (no longer built be ROSETTA).
  // DQ (7/26/2007): Member function pointers don't require a SgClassDefinition so we have no scope
  // for such cases, to make up for this, we explicitly store the class declaration.
  // SgClassDeclaration* classDeclaration = this->get_associatedClassDeclaration();
     SgDeclarationStatement* decl = this->p_associatedClassDeclaration;
     if (decl != NULL) {
       decl = decl->get_definingDeclaration();
       ROSE_ASSERT(decl != NULL);

       SgClassDeclaration* xdecl = isSgClassDeclaration(decl);
       SgNonrealDecl* nrdecl = isSgNonrealDecl(decl);
       if (xdecl != NULL) {
         parentScope = xdecl->get_definition();
       } else if (nrdecl != NULL) {
         parentScope = nrdecl->get_nonreal_decl_scope();
       } else {
         ROSE_ASSERT(false);
       }
     } else {
       // DQ (7/26/2007): Moved from top of function
          ROSE_ASSERT(p_scope != NULL);

       // DQ (10/15/2007): Added assertion.
          ROSE_ASSERT(this->get_parent() != NULL);

          parentScope = get_scope();
          SgClassDefinition * cdefn = isSgClassDefinition(parentScope);
          SgDeclarationScope * nrscope = isSgDeclarationScope(parentScope);

       // The scope associated with a member function had better be a SgClassDefinition!
       // if (this->get_associatedClassDeclaration() != NULL || parentScope == NULL)
          if (cdefn == NULL && nrscope == NULL)
             {
            // DQ (12/5/2004): Note that new member function declarations added from the rewrite system
            // allow there scope to be derived from the parent node.  This results in incorrect information
            // which is later discovered in the unparser!  Need to do a better job of setting the scope of
            // all statements when introduced from the rewrite mechanism.

               ROSE_ASSERT(get_name().is_null() == false);
               printf ("Error in $CLASSNAME::get_class_scope() member function name = %s (can be incorrect due to rewrite system) \n",get_name().str());

            // DQ (3/19/2016): Klocworks reports this as an issue (fix by calling get_parent only once).
            // printf ("     get_parent() = %p = %s \n",get_parent(),(get_parent() != NULL) ? get_parent()->sage_class_name() : "NULL");
               SgNode* parent = get_parent();
               printf ("     get_parent() = %p = %s \n",parent,(parent != NULL) ? parent->sage_class_name() : "NULL");

               printf ("     p_scope      = %p = %s \n",p_scope,p_scope->sage_class_name());
             }
       // ROSE_ASSERT(parentScope != NULL);
        }

  // DQ (10/12/2007): It is OK for this to be NULL! If it is NULL, then the get_associatedClassDeclaration() has the class declaration!
  // ROSE_ASSERT(parentScope != NULL);
     return parentScope;
   }


// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgMemberFunctionDeclaration::get_symbol_from_symbol_table() const
   {
#if 0
     printf ("In SgMemberFunctionDeclaration::get_symbol_from_symbol_table(): this = %p = %s = %s scope = %p = %s scope->get_symbol_table() = %p \n",
          this,this->class_name().c_str(),SageInterface::get_name(this).c_str(),get_scope(),get_scope()->class_name().c_str(),get_scope()->get_symbol_table());
#endif

     SgSymbol* symbol = NULL;
     if (get_scope() == NULL)
        {
          printf ("In SgMemberFunctionDeclaration::get_symbol_from_symbol_table(): get_scope() == NULL for %p = %s \n",this,this->class_name().c_str());
          symbol = NULL;
        }
       else
        {
          ROSE_ASSERT(get_scope() != NULL);
       // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
       // symbol = get_scope()->get_symbol_table()->find(this);
          symbol = get_scope()->find_symbol_from_declaration(this);
        }

     return symbol;
   }

SOURCE_MEMBER_FUNCTION_DECLARATION_STATEMENT_END


SOURCE_CTOR_INITIALIZER_LIST_START

void
SgCtorInitializerList::post_construction_initialization()
   {
     if (get_file_info() != NULL)
        {
          Sg_File_Info* endingPosition = new Sg_File_Info(*(get_file_info()));
          ROSE_ASSERT (endingPosition != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          endingPosition->set_parent(this);

          set_endOfConstruct(endingPosition);
        }

     // Liao, 2020/4/29, borrow these two steps from SageBuilder::buildNondefiningMemberFunctionDeclaration() here
     // This is necessary to fix AST copy of member function declarations. The copy does not set defining declaration.
     this->set_definingDeclaration(this);
     this->set_firstNondefiningDeclaration(this);
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgCtorInitializerList::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

/* SgInitializedName tuple: (SgName, type, Initializer) */
void
SgCtorInitializerList::append_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().end(), iName);
   }

void
SgCtorInitializerList::prepend_ctor_initializer( SgInitializedName* iName)
   {
     get_ctors().insert(get_ctors().begin(), iName);
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgCtorInitializerList::get_mangled_name(void) const
   {
  // printf ("In $CLASSNAME::get_mangled_name() name = %s \n",SageInterface::get_name(this).c_str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName memberNames;
     SgInitializedNamePtrList::const_iterator p = get_ctors().begin();
     while ( p != get_ctors().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // memberNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          memberNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_constructor_initialization_list_") + memberNames;
     returnName = scope->get_mangled_name() + SgName("_constructor_initialization_list_") + memberNames;

  // printf ("Warning: mangled name for %s not yet defined (SgFunctionParameterList::get_mangled_name() called) \n",class_name().c_str());

     return returnName;
   }

SOURCE_CTOR_INITIALIZER_LIST_END


SOURCE_VARIABLE_DECLARATION_STATEMENT_START

SgVariableDeclaration::SgVariableDeclaration(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   : SgDeclarationStatement(info)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (info,var_name,type,initializer);
   }

SgVariableDeclaration::SgVariableDeclaration( const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgVariableDeclaration constructor taking all parameters \n");
     initializeData (NULL,var_name,type,initializer);
   }

SgVariableDeclaration::SgVariableDeclaration( Sg_File_Info *info, SgInitializedName* c_item )
   {
     ROSE_ASSERT (this != NULL);
     initializeData (info,c_item);
   }

SgVariableDeclaration::SgVariableDeclaration( SgInitializedName* c_item )
   {
     ROSE_ASSERT (this != NULL);
     initializeData (NULL,c_item);
   }

void
SgVariableDeclaration::initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
   {
     ROSE_ASSERT (this != NULL);

     SgInitializedName* c_item = SageBuilder::buildInitializedName_nfi(var_name, type, initializer, this);
     ROSE_ASSERT (c_item != NULL);

     initializeData (info, c_item);
   }


// DQ (7/18/2012): Add to the API so that we can build a SgVariableDeclaration from an existing SgInitializedName.
// void SgVariableDeclaration::initializeData(Sg_File_Info *info, const SgName& var_name, SgType *type, SgInitializer *initializer)
void
SgVariableDeclaration::initializeData(Sg_File_Info *info, SgInitializedName* c_item)
   {
     ROSE_ASSERT (this != NULL);

  // DQ (7/20/2006): Suggested by Peter to so that the initializer will be used.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName c_item(var_name, type, 0, this);
  // SgInitializedName* c_item = new SgInitializedName(var_name, type, NULL, this);
  // SgInitializedName* c_item = new SgInitializedName(var_name, type, initializer, this);
     ROSE_ASSERT (c_item != NULL);

     SgInitializer *initializer = c_item->get_initptr();

  // DQ (10/10/2007): Added fix for Liao, this is required when using the alternative constructors.
  // DQ (10/10/2007): fixed the segmentation fault occurred in liaOutliner for class ::A this__ptr__
     p_variableDeclarationContainsBaseTypeDefiningDeclaration = false;

  // DQ(10/10/2007): Added initialization of another data member.
     p_baseTypeDefiningDeclaration = NULL; // non list case

  // DQ(10/10/2007): Added initialization of another data member.
     p_specialization = SgDeclarationStatement::e_no_specialization;

  // DQ(10/10/2007): Added initialization of another data member.
     p_requiresGlobalNameQualificationOnType = false;

#if 0
  // DQ (9/11/2020): These data members are not set (p_builtFromUseOnly was identified using valgrind).
  // Unclear if this should go into the post_construction_initialization() function (better).
  // p_gnu_extension_section                 = "";
  // p_gnu_extension_alias                   = "";
     p_gnu_extension_initialization_priority = 0;
     p_gnu_extension_visability              = SgDeclarationStatement::e_gnu_attribute_visability_unspecified;
     p_gnu_extension_declaration_attribute   = SgVariableDeclaration::e_gnu_attribute_unspecified;
     p_name_qualification_length             = 0;
     p_type_elaboration_required             = false;
     p_global_qualification_required         = false;
     p_isAssociatedWithDeclarationList       = false;
     p_isFirstDeclarationOfDeclarationList   = true;
     p_is_thread_local                       = false;
     p_is_constexpr                          = false;
     p_builtFromUseOnly                      = false;
#endif

#if PRINT_DEVELOPER_WARNINGS
     printf ("Inside of SgVariableDeclaration::initializeData for constructor taking all parameters c_item = %p = %s \n",c_item,c_item->get_name().str());
#endif

  // DQ (6/8/2006): Need to set parent and scope of internally built variable
     c_item->set_parent(this);
  // c_item->set_scope();
  // ROSE_ASSERT(c_item->get_scope() != NULL);

#if 1
  // PC (7/14/2006): Set initializer's parent, as expected by inliner
  // DQ (7/20/2006): this would be better handled by the code calling this
  // constructor since this is now a side-effect on "initializer".
     if (initializer != NULL)
        {
          initializer->set_parent(c_item);
        }
#endif

  // DQ (11/10/2006): Added support for null file info pointer so that this could could be used by both constructors.
     if (info != NULL)
        {
       // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
          ROSE_ASSERT (copyOfFileInfo != NULL);

       // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
          copyOfFileInfo->set_parent(c_item);

       // DQ (1/18/2006): Changed name to be consistent with SgNode::get_file_info()
       // c_item->set_fileInfo(copyOfFileInfo);
       // c_item->set_file_info(copyOfFileInfo);
          c_item->set_startOfConstruct(copyOfFileInfo);

        }

  // DQ (12/15/2006): We are using the initializer in both the SgInitializedName and the
  // SgVariableDefinition.  We have to pass the initializer to append_variable() because
  // the SgVariableDefinition is built there and we we have removed the code below that
  // used to reset it.  This implementation is better because we don't reset the initializer
  // and the SgVariableDefinition, however that means we have to set it correctly the first time!
  // So we pass the initializer into the append_variable() member function.
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item=&(*(this->append_variable(c_item,0)));
  // SgInitializedName *decl_item = *(this->append_variable(c_item,NULL));
     /* SgInitializedName *decl_item = */ this->append_variable(c_item,initializer);

  // DQ (6/1/2004): Can we enforce this?
  // ROSE_ASSERT (decl_item == c_item);

  // DQ (10/6/2004): Adding documentation - this is to support the unparser and is always set to be true (so it seems).
  // A newer mechanism explicitly marks the variable declaration if it contains a class definition which must be output
  // when unparsing.
  // Older comment: for class-P var, the definition part of class-P won't get printed
     this->setNameOnly();

  // DQ (11/18/2007): This should have been called anyway, but this adds support for Fortran declaration attributes.
     post_construction_initialization();
   }

void
SgVariableDeclaration::post_construction_initialization()
   {
  // DQ (11/18/2007): Added support for Fortran declaration attributes
  // p_fortran_attribute_spec = SgBitVector(SgAttributeSpecificationStatement::e_last_attribute_spec,false);

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgVariableDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (4/21/2014): Try to set this so that we can avoid a possible valgrind waring about this being sometimes unitialized.
  // ==2562== 113 errors in context 34 of 34:
  // ==2562== Conditional jump or move depends on uninitialised value(s)
  // ==2562==    at 0x69758FB: Unparse_ExprStmt::unparseVarDeclStmt(SgStatement*, SgUnparse_Info&) (unparseCxx_statements.C:4421)
     p_isAssociatedWithDeclarationList = false; // non list case

  // DQ (8/15/2014): These were not previously set by default.
     p_isFirstDeclarationOfDeclarationList           = true;
     p_is_thread_local                               = false;
#if 0
  // Moved these to SgInitializedName
     p_using_C11_Alignas_keyword                     = false;
     p_constant_or_type_argument_for_Alignas_keyword = false;
#endif
     p_is_constexpr                                  = false;

#if 1
  // DQ (9/11/2020): I think this is a better place to do a centralized initialization.
  // DQ (9/11/2020): These data members are not set (p_builtFromUseOnly was identified using valgrind).
  // Unclear if this should go into the post_construction_initialization() function (better).
  // We don't need to initialize strings, which have a default constructor.
  // p_gnu_extension_section                 = "";
  // p_gnu_extension_alias                   = "";
     p_gnu_extension_initialization_priority = 0;
     p_gnu_extension_visability              = SgDeclarationStatement::e_gnu_attribute_visability_unspecified;
     p_gnu_extension_declaration_attribute   = SgVariableDeclaration::e_gnu_attribute_unspecified;
     p_name_qualification_length             = 0;
     p_type_elaboration_required             = false;
     p_global_qualification_required         = false;

  // DQ (9/11/2020): These are initialized above.
  // p_isAssociatedWithDeclarationList       = false;
  // p_isFirstDeclarationOfDeclarationList   = true;
  // p_is_thread_local                       = false;
  // p_is_constexpr                          = false;
     p_builtFromUseOnly                      = false;
#endif
   }


#if 0
// This is now stored in the type modifier (I think this is a better implementation)

bool SgVariableDeclaration::isDefault() const { return checkBit(e_default,p_fortran_attribute_spec); }
void SgVariableDeclaration::setDefault()      { setBit(e_default,p_fortran_attribute_spec); }
void SgVariableDeclaration::unsetDefault()    { unsetBit(e_default,p_fortran_attribute_spec); }

// Fortran specific declaration attribute support
bool testAccess_private_Attribute() const { return checkBit(e_default,p_fortran_attribute_spec); }
void setAccess_private_Attribute()        { setBit(e_default,p_fortran_attribute_spec); }
void unsetAccess_private_Attribute()      { unsetBit(e_default,p_fortran_attribute_spec); }

bool testAccess_protected_Attribute() const;
void setAccess_protected_Attribute();
void unsetAccess_protected_Attribute();

bool testAccess_public_Attribute() const;
void setAccess_public_Attribute();
void unsetAccess_public_Attribute();

bool testAllocatableAttribute() const;
void setAllocatableAttribute();
void unsetAllocatableAttribute();

bool testAsynchronousAttribute() const;
void setAsynchronousAttribute();
void unsetAsynchronousAttribute();

bool testBindAttribute() const;
void setBindAttribute();
void unsetBindAttribute();

bool testDataAttribute() const;
void setDataAttribute();
void unsetDataAttribute();

bool testDimensionAttribute() const;
void setDimensionAttribute();
void unsetDimensionAttribute();

bool testExternalAttribute() const;
void setExternalAttribute();
void unsetExternalAttribute();

bool testIntent_in_Attribute() const;
void setIntent_in_Attribute();
void unsetIntent_in_Attribute();

bool testIntent_out_Attribute() const;
void setIntent_out_Attribute();
void unsetIntent_out_Attribute();

bool testIntent_inout_Attribute() const;
void setIntent_inout_Attribute();
void unsetIntent_inout_Attribute();

bool testIntrinsicAttribute() const;
void setIntrinsicAttribute();
void unsetIntrinsicAttribute();

bool testOptionalAttribute() const;
void setOptionalAttribute();
void unsetOptionalAttribute();

bool testParameterAttribute() const;
void setParameterAttribute();
void unsetParameterAttribute();

bool testPointerAttribute() const;
void setPointerAttribute();
void unsetPointerAttribute();

bool testProtectedAttribute() const;
void setProtectedAttribute();
void unsetProtectedAttribute();

bool testSaveAttribute() const;
void setSaveAttribute();
void unsetSaveAttribute();

bool testTargetAttribute() const;
void setTargetAttribute();
void unsetTargetAttribute();

bool testValueAttribute() const;
void setValueAttribute();
void unsetValueAttribute();

bool testVolatileAttribute() const;
void setVolatileAttribute();
void unsetVolatileAttribute();

#endif


// given a decl_item
SgVariableDefinition*
SgVariableDeclaration::get_definition(SgInitializedName *ditem)
   {
     SgVariableDefinition *defn_stmt = NULL;
     SgInitializedName    *defn_item = NULL;
#if 0
     printf ("In SgVariableDeclaration::get_definition(): ditem = %p \n",ditem);
#endif
     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() && ditem )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
#if 0
          printf ("In SgVariableDeclaration::get_definition(): loop through variables *p = %p \n",*p);
#endif
          if (ditem == (*p))
             {
            // QY 11/2/04 set defn_item = *p
            //  defn_item = (*p)->get_named_item();
               defn_item = (*p);
               break;
             }
          p++;
        }

     if (ditem == NULL)
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // defn_item=(*p).get_named_item();
          ROSE_ASSERT ((*p) != NULL);
       // QY 11/2/04 set defn_item = *p
       //   defn_item=(*p)->get_named_item();
          defn_item = *p;
        }
       else
        {
          return NULL;
        }
#if 0
     printf ("In SgVariableDeclaration::get_definition(): defn_item = %p \n",defn_item);
#endif

  // if (defn_item)
     if (defn_item != NULL)
        {
#if 0
          printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %p \n",defn_item->get_definition());
          if (defn_item->get_definition() != NULL)
               printf ("In SgVariableDeclaration::get_definition(): defn_item->get_definition() = %s \n",defn_item->get_definition()->class_name().c_str());
#endif
          // DQ (9/9/2007): I think we can assert this for any SgInitializedName found in a SgVariableDeclaration,
          // else perhaps we should have this function return a SgDeclarationStatement instead of a SgVariableDefinition.
          /* MS (9/22/2020): removed ROSE_ASSERT(defn_item->get_definition() == NULL || isSgVariableDefinition(defn_item->get_definition()) );
             because the SageBuilder:::buildVariableDeclaration calls 'new SgVariableDeclaration(name, type, varInit);'
             which initializes SgInitializedName::p_declptr with a SgVariableDeclaration pointer and then this assertion is not correct */

          // can be 0 when SageBuilder:::buildVariableDeclaration is used
          defn_stmt = isSgVariableDefinition(defn_item->get_definition());
        }

     return defn_stmt;
   }

// DQ (1/20/2014): This must be a SgValueExp, it is a constant expression ROSE uses a SgValueExp for this).
// SgUnsignedLongVal* SgVariableDeclaration::get_bitfield()
SgExpression*
SgVariableDeclaration::get_bitfield()
   {

     /* MS (9/22/2020): in case a bitfield is not present, get_definition
        returns 0. Since this function is also used to determine
        whether a bitfield is present, returning 0 is necessary.  */
     if(get_definition()==0)
       return 0;
     return get_definition()->get_bitfield();
   }

// DQ (1/20/2014): This must be a SgValueExp, it is a constant expression ROSE uses a SgValueExp for this).
// void SgVariableDeclaration::set_bitfield (SgUnsignedLongVal *bfield)
void
SgVariableDeclaration::set_bitfield (SgExpression* bfield)
   {
     assert(get_definition() != 0);
     get_definition()->set_bitfield(bfield);
   }

void
SgVariableDeclaration::setStatic()
   {
     SgDeclarationStatement::setStatic();
  // if it is a static member data

     printf ("Error: SgVariableDeclaration::setStatic() is deprecated \n");

  // SgStatement* parentPointer = get_parent();
     SgStatement* parentPointer = isSgStatement(get_parent());
  // assert(parentPointer != NULL);
     bool isStaticDeclaration = (isSgClassDefinition(parentPointer) != NULL);

     if(isStaticDeclaration == true)
          setDeclarationOnly();
  // if(isSgClassDefinition(get_parent())) setDeclarationOnly();
   }

void
SgVariableDeclaration::setExtern()
   {
     printf ("Error: SgVariableDeclaration::setExtern() is deprecated \n");

     SgDeclarationStatement::setExtern();
     setDeclarationOnly();
   }

int
SgVariableDeclaration::reset_initializer(SgInitializer *initializer)
   {
/*
     SgVariableDefinition *vdefn = get_definition();
     if ( vdefn != NULL )
        {
          vdefn->set_initializer(initializer); // reset
          return true;
        }
     return false;
*/
    // QY 11/5/04
     if (get_variables().size()) {
        get_variables().front()->set_initializer(initializer);
        return true;
     }
     return false;
   }

// setForward in class variable declaration
void
SgVariableDeclaration::setDeclarationOnly()
   {
     SgInitializedName *defn_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
        // QY:11/3/04 removed get_named_item
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
          ROSE_ASSERT ((*p) != NULL);
       //   defn_item = (*p)->get_named_item();
          defn_item = (*p);
          if (defn_item->get_definition())
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // (*p).set_named_item(NULL);
            //   (*p)->set_named_item(NULL);
              (*p)->set_definition(NULL);
             }
          p++;
        }
     setForward();
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
void
SgVariableDeclaration::append_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     get_variables().push_back(what);
     what->set_parent(this);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
  // SgInitializedName *decl_item = *new_item;

  // printf ("Inside of SgVariableDeclaration::append_variable what = %p \n",what);
  // printf ("Inside of SgVariableDeclaration::append_variable decl_item = %p \n",decl_item);

  // DQ (6/1/2004): Can we assert this
  // ROSE_ASSERT (decl_item == what);

     assert(this != NULL);
     ROSE_ASSERT (what != NULL);

     SageBuilder::buildVariableDefinition_nfi (this, what, initializer);
#if 0
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

            // Note that the SgVariableDefinition will connect the new IR node into the AST.
               defn_stmt = new SgVariableDefinition(copyOfFileInfo,get_variables().back(),initializer);
               assert (defn_stmt != NULL);

               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (3/13/2007): We can't enforce that the endOfConstruct is set (if the interface using the startOfConstruct is used.
            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
            // ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               if (this->get_endOfConstruct() != NULL)
                  {
                    Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
                    defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
                    copyOfEndOfConstruct->set_parent(defn_stmt);
                  }
             }
            else
             {
            // Note that the SgVariableDefinition will connect the new IR node into the AST.
               defn_stmt = new SgVariableDefinition(get_variables().back(),initializer);
             }

          ROSE_ASSERT(defn_stmt != NULL);
       // printf ("In SgVariableDeclaration::append_variable(): SgVariableDefinition *defn_stmt = %p \n",defn_stmt);
        }
#endif
   }

// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
void
SgVariableDeclaration::prepend_variable( SgInitializedName* what, SgInitializer *initializer )
   {
     ROSE_ASSERT (what != NULL);

     get_variables().insert(get_variables().begin(),what);
     what->set_parent(this);

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // SgInitializedName *decl_item = &(*new_item);
  // SgInitializedName *decl_item = *new_item;

  // DQ (6/1/2004): Can we assert this
  // ROSE_ASSERT (decl_item == what);
   SageBuilder::buildVariableDefinition_nfi (this, what, initializer);
#if 0
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // if (!isSgFunctionType(what.get_type()))
     if (!isSgFunctionType(what->get_type()))
        {
#if 0
       // DQ (5/20/2006): Avoid sharing the Sg_File_Info object from the SgVariableDeclaration
          Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
          ROSE_ASSERT (copyOfFileInfo != NULL);
       // SgVariableDefinition *defn_stmt = new SgVariableDefinition(this->get_file_info(),decl_item,initializer);
          SgVariableDefinition *defn_stmt = new SgVariableDefinition(copyOfFileInfo,decl_item,initializer);
          assert (defn_stmt != NULL);
          copyOfFileInfo->set_parent(defn_stmt);
#endif
       // DQ (11/24/2006): This function is called from initializeData() which is required to work with or without a valid Sg_File_Info object.
          Sg_File_Info* copyOfFileInfo = NULL;
          SgVariableDefinition *defn_stmt = NULL;
          if (this->get_file_info() != NULL)
             {
               copyOfFileInfo = new Sg_File_Info(*(this->get_file_info()));
               ROSE_ASSERT (copyOfFileInfo != NULL);

            // Note that the SgVariableDefinition will connect the new IR node into the AST.
               defn_stmt = new SgVariableDefinition(copyOfFileInfo,get_variables().front(),initializer);

               assert (defn_stmt != NULL);
               copyOfFileInfo->set_parent(defn_stmt);

            // DQ (2/3/2007): Need to build the endOfConstruct position as well.
               ROSE_ASSERT(this->get_endOfConstruct() != NULL);
               Sg_File_Info* copyOfEndOfConstruct = new Sg_File_Info(*(this->get_endOfConstruct()));
               copyOfEndOfConstruct->set_parent(defn_stmt);
               defn_stmt->set_endOfConstruct(copyOfEndOfConstruct);
             }
            else
             {
            // Note that the SgVariableDefinition will connect the new IR node into the AST.
               defn_stmt = new SgVariableDefinition(get_variables().front(),initializer);
             }

          ROSE_ASSERT(defn_stmt != NULL);
       // printf ("In SgVariableDeclaration::prepend_variable(): SgVariableDefinition *defn_stmt = %p \n",defn_stmt);
        }
#endif
   }

#if 0
// DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
SgInitializedNamePtrList::iterator
SgVariableDeclaration::insert_variable( const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/27/2004): This function contains a side-effect on its input. For now just output a warning message.

     ROSE_ASSERT (what != NULL);
  // if (what->get_declaration()) // set parent() of definition's declaration
  //     what->get_declaration()->set_parent(this);
  // QY (11/3/04)
     what->set_parent(this);

     SgInitializedNamePtrList::iterator new_item = get_variables().insert(where,what);

  // DQ (6/1/2004): Can we assert this
     ROSE_ASSERT (*new_item == what);

     return new_item;
   }
#endif

//QY 11/5/04 not needed any more since removed named_item in SgInitializedName
#if 0
SgInitializedName*
SgVariableDeclaration::get_defn_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item=&(*p);
               decl_item = (*p);
               break;
             }
          p++;
        }

    // QY : 11/2/04 removed p_named_item
     //if (decl_item && decl_item->get_named_item())
     //     return decl_item->get_named_item();
     if (decl_item && decl_item->get_definition())
          return decl_item;
       else
          return NULL;
   }
#endif

SgInitializedName*
SgVariableDeclaration::get_decl_item(const SgName& nm)
   {
     SgInitializedName *decl_item = NULL;

     SgInitializedNamePtrList::iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // if (nm.is_null() || (*p).get_name()==nm)
          if (nm.is_null() || (*p)->get_name() == nm)
             {
            // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
            // decl_item = &(*p);
               decl_item = *p;
               break;
             }
          p++;
        }
     return decl_item;
   }

SgStatement*
SgVariableDeclaration::get_next(int & n) const
   {
     if (isNameOnly()) return 0;
     if (n == 0)
        {
          n++;
       // special case if type of variable declaration pt to a tag Reference which
       // maybe a statement of some sort
       // only need to worry about first variable's decl
          SgInitializedNamePtrList::const_iterator p = get_variables().begin();

       // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
       // SgType *tmp_type = (*p).get_type();
          ROSE_ASSERT ((*p) != NULL);
          SgType *tmp_type = (*p)->get_type();

          SgNamedType *ntype = isSgNamedType(tmp_type->findBaseType());
          SgDeclarationStatement* declStmt =
               (ntype) ? ntype->get_declaration() : (SgDeclarationStatement*)0L;
          if ( declStmt && !declStmt->isForward() &&
               (isSgClassDeclaration(declStmt) || isSgEnumDeclaration(declStmt) ) )
             {
               return declStmt;
             }
            else
               return 0;
        }
       else
          return 0;
   }

#if 0
// DQ (7/19/2005): SgVariableDeclaration should have a structural definition of its scope (based on position in
// source code) while the variables declared should (and do) have a posible different scope (via name qualification).
// DQ (7/4/2005): implement get_scope to query the initialized names in the initialized name list (SgInitializedNamePtrList)
// without this function we evaluate the scope using a traversal of the parents!
SgScopeStatement*
SgVariableDeclaration::get_scope(void) const
   {
     ROSE_ASSERT(this != NULL);

  // This function looks at the first SgInitializedName for file the scope which is stored there explicitly
     const SgInitializedNamePtrList & variableList = get_variables();
     ROSE_ASSERT(variableList.size() > 0);
     const SgInitializedName* firstVariable = *(variableList.begin());
     ROSE_ASSERT(firstVariable != NULL);

  // Note that if this function is called before the SgInitializedName's explicitly stored scope is set the result may be NULL
     SgScopeStatement* scope = firstVariable->get_scope();
  // ROSE_ASSERT(scope != NULL);

     return scope;
   }
#endif

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames;
     SgInitializedNamePtrList::const_iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
       // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
       // variableNames += SgName("_variable_name_") + (*p)->get_mangled_name();
          variableNames += SgName("_variable_type_") + (*p)->get_type()->get_mangled() + SgName("_variable_name_") + (*p)->get_mangled_name();

          p++;
        }

#if 0
     printf ("In SgVariableDeclaration::get_mangled_name(void): scope = %p = %s scope->get_qualified_name() = %s \n",
          scope,scope->class_name().c_str(),scope->get_qualified_name().str());
#endif

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_declaration_") + variableNames;
     returnName = scope->get_mangled_name() + SgName("_variable_declaration_") + variableNames;

     return returnName;
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. If this variable declaration contains the
// definition of its base type, that defining declaration is returned (computed via the type of the first initialized
// name in the list).
SgDeclarationStatement *
SgVariableDeclaration::compute_baseTypeDefiningDeclaration() const
   {
  // DQ (10/17/2007): It is likely that this function could be replaced with just:
  // return p_baseTypeDefiningDeclaration;
  // in the future.

     if (p_variableDeclarationContainsBaseTypeDefiningDeclaration == true)
        {
#if 0
          ROSE_ASSERT(!p_variables.empty());
          SgInitializedName *var = p_variables.front();
          SgNamedType *baseType = isSgNamedType(var->get_type()->findBaseType());
       // GB (09/25/2007): Can we assert this? The flag above seems to tell us that we can.
          ROSE_ASSERT(baseType != NULL);
          return baseType->get_declaration()->get_definingDeclaration();
#else
       // DQ (10/17/2007): Modified to permit the declaration to be stored and accessed so that the AST COPY mechanism
       // would not have to lookup the declaration through the type (which is a problem because types are shared and
       // so the declaration in the original AST is returned instead of the declaration form the copy of the AST).
          ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);
          return p_baseTypeDefiningDeclaration;
#endif
        }
       else
        {
       // DQ (7/15/2012): This fails for test2012_120.C
       // ROSE_ASSERT(p_baseTypeDefiningDeclaration == NULL);
          if (p_baseTypeDefiningDeclaration != NULL)
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("Warning: In SgVariableDeclaration::compute_baseTypeDefiningDeclaration(): p_baseTypeDefiningDeclaration != NULL but returning NULL \n");
#endif
             }

          return NULL;
        }
   }

SgDeclarationStatement *
SgVariableDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }

void
SgVariableDeclaration::set_baseTypeDefiningDeclaration(SgDeclarationStatement* d)
   {
  // DQ (10/17/2007): This is a non ROSETTA generated function so that the get_baseTypeDefiningDeclaration()
  // version can be written to use the compute_baseTypeDefiningDeclaration() member function.  However, we
  // are changing the compute_baseTypeDefiningDeclaration() member function to return the explicitly stored
  // defining declaration in a SgVariableDeclaration (if such a thing is defined).  An example of where this
  // happens is in: "struct { int x; } y;", here the structure declaration is in the variable declaration for "y".

  // DQ (10/11/2014): We need to handle the case where the input in NULL, required for more general processing
  // for ROSETTA generated ATerm support.
  // ROSE_ASSERT(d != NULL);
     if (d != NULL)
        {
          p_baseTypeDefiningDeclaration = d;
          ROSE_ASSERT(p_baseTypeDefiningDeclaration != NULL);

       // Mark the p_variableDeclarationContainsBaseTypeDefiningDeclaration as true so that the p_baseTypeDefiningDeclaration
       // declaration will be used (by compute_baseTypeDefiningDeclaration()).
          set_variableDeclarationContainsBaseTypeDefiningDeclaration(true);
        }
       else
        {
          p_baseTypeDefiningDeclaration = NULL;
          set_variableDeclarationContainsBaseTypeDefiningDeclaration(false);
        }
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgVariableDeclaration::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgVariableDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgVariableDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgVariableDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgVariableDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgVariableDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

bool
SgVariableDeclaration::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgVariableDeclaration::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

SOURCE_VARIABLE_DECLARATION_STATEMENT_END


SOURCE_VARIABLE_DEFINITION_STATEMENT_START
void
SgVariableDefinition::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgVariableDefinition::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

SgVariableDeclaration*
SgVariableDefinition::get_declaration()
   {
     assert(get_vardefn() != NULL);

     SgVariableDeclaration *rdecl = isSgVariableDeclaration(get_vardefn()->get_declaration());
     return rdecl;
   }

SgVariableDefinition::
SgVariableDefinition(Sg_File_Info *info, SgInitializedName *decl_item, SgInitializer *initializer)
   : $BASECLASS(info),
  // DQ (11/20/2004): Reordered pre-initialization list to avoid compiler warnings.
  // p_initializer_expr_root(new SgExpressionRoot(initializer == 0?New_File_Info(this) : new Sg_File_Info(*initializer->get_file_info()), initializer)),
  // QY:11/2/04 remove redundant coupled SgInitializedName nodes.
  // p_vardefn ( new SgInitializedName(decl_item->get_name(),NULL,initializer,this,NULL,NULL))
     p_vardefn(decl_item),
     p_bitfield(0)

   {
  // In many places this constructor is called (via the new operator) with the resulting
  // pointer returned by operator::new UNUSED.  The reason why this works is because the
  // call to "set_parent()" at the base of the constructor attaches this object to the
  // program tree (I think this is inelegant (since it is the only class that works this
  // way in SAGE), but I will leave it as is for now).

     ROSE_ASSERT(decl_item != NULL);

#if 0
  // DQ (10/29/2006): This only resets the file info in the SgInitilaizedName object (a memory
  // leak at least if it were not also an error, since now we set the source position more
  // precisely and this overwrites the correct value!)

  // DQ (8/3/2004): Need to set the file info on this SgInitializedName object (use a copy)
     Sg_File_Info* copyOfFileInfo = new Sg_File_Info(*info);
     ROSE_ASSERT (copyOfFileInfo != NULL);

  // DQ (1/18/2006): Changed name to be consistent with SgNode::get_file_info()
  // get_vardefn()->set_fileInfo(copyOfFileInfo);
     get_vardefn()->set_file_info(copyOfFileInfo);

  // This should be NULL to to avoid a cycle (set to NULL in call to constructor, above)
  //   ROSE_ASSERT (get_vardefn()->get_itemptr() == NULL);

  // printf ("In SgVariableDefinition constructor: defn_item = %p \n",defn_item);
#endif

  // QY:11/2/04    do not create a new  SgInitializedName. set p_vardefn = decl_item, then set the initializer in decl_item instead
  // This resets the itemptr pointer in the declaration to the SgInitializedName object
  //   decl_item->set_named_item(get_vardefn());
      set_parent(decl_item);
      get_vardefn()->set_initializer(initializer);
      get_vardefn()->set_definition(this);

  // Sage 2 includes this code (the body of post_construction_initialization()
  // instead of calling post_construction_initialization() directly) (?)
     ROSE_ASSERT(decl_item != NULL);
     //ROSE_ASSERT(decl_item->get_declaration() != NULL);
     //ROSE_ASSERT(isSgVariableDeclaration(decl_item->get_declaration()) != NULL);
   }

SgVariableDefinition::
SgVariableDefinition( SgInitializedName *decl_item, SgInitializer *initializer)
   : p_vardefn(decl_item),
     p_bitfield(0)
   {
  // DQ (11/10/2006): This is a version of the constructor that is separated from the source position initialization.
     ROSE_ASSERT(decl_item != NULL);

     set_parent(decl_item);
     get_vardefn()->set_initializer(initializer);
     get_vardefn()->set_definition(this);

     ROSE_ASSERT(decl_item != NULL);
   }

SgType*
SgVariableDefinition::get_type()
   {
     return get_vardefn()->get_type();
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgVariableDefinition::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_variable_definition_") + get_vardefn()->get_mangled_name();

     return returnName;
   }

SOURCE_VARIABLE_DEFINITION_STATEMENT_END


SOURCE_CLASS_DECLARATION_STATEMENT_START

void
SgClassDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.
#if 0
     if (get_type())
          get_type()->set_declaration(this);
       else
          set_type(SgClassType::createType(this));
#else
  // Only build a type if one does not exist
  // Liao, 10/30/2009. We should not create SgClassType during constructing
  // Since only the first nondefining class declaration should have a dedicated SgClassType node
  // the defining class declaration (and other nondefining declaration) just shared that SgClassType.
  // The constructor does not know if a defining or nondefining declaration is being built
  // so we have to let users to create SgClassType by themselves after calling the constructor
  // This will ultimately avoid duplicated SgClassType nodes in the AST
#if 0
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In $CLASSNAME::post_construction_initialization(): generating the SgClassType internally (from the declaration) \n");
#endif
#endif
          set_type(SgClassType::createType(this));
        }
#endif

#endif

#if 0
  // DQ (3/4/2018): relax this requirement for SgTemplateInstantiationClassDeclaration.
  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
     if (p_type != NULL)
        {
          printf ("Note: SgClassDeclaration::post_construction_initialization(): p_type != NULL: name = %s \n",p_name.str());
        }
  // ROSE_ASSERT(p_type == NULL);
#endif

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgClassDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// SgStatement *get_first() const;

bool
SgClassDeclaration::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
{
  return false;
}

SgName
SgClassDeclaration::get_qualified_name() const
   {
  //! \todo Find out why qualified name generation requires a special case for unions.

  // DQ (9/27/2004): This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // printf ("In SgClassDeclaration::get_qualified_name() name = %s isUnion = %s \n",get_name().str(),(isUnion == true) ? "true" : "false") ;

     SgName returnName;

#if 1
  // DQ (6/3/2006): I think we should handle unions uniformly with structs and classes.
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);
     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
#else
  // Ignore case of a union (why?)
     bool isUnion = (get_class_type() == SgClassDeclaration::e_union);

     if (isUnion == true)
        {
       // DQ (8/28/2005): I'm not clear on why this is handles as a special case!
          printf ("In SgClassDeclaration::get_qualified_name(): Special case of union, does not include scope information! \n");
          returnName = get_name();
        }
       else
        {
       // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
          SgScopeStatement* scope = get_scope();
          ROSE_ASSERT(scope != NULL);

       // ROSE_ASSERT(get_name().is_null() == false);

       // returnName = scope->get_qualified_name() << "::" << get_name().str();
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }
#endif

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

  // ROSE_ASSERT(returnName.is_null() == false);

     return returnName;
   }

#define DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME 0

// RV (1/31/2006): Added mangler for class declarations.
SgName
SgClassDeclaration::get_mangled_name(void) const
   {
#if 0
  // return joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());

     SgName name = get_name();

  // DQ (2/8/2007): See the note in the SgEnumDeclaration::get_mangled_name() function.
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_structure_tag_name_") != std::string::npos);

  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an
  // printf ("In SgClassDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     return joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgClassDeclaration* classDeclaration = const_cast<SgClassDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(classDeclaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif

     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgClassDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
          printf ("In SgClassDeclaration::get_mangled_name(): (FOUND in cache) mangledNameString = %s \n",mangledNameString.c_str());
#endif
          return mangledNameString;
        }
       else
        {
       // DQ (3/14/2012): Make sure that this is a valid pointer else it might explain why qualification is not being use to generate the mangled names.
          ROSE_ASSERT(get_scope() != NULL);
#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
          printf ("In SgClassDeclaration::get_mangled_name(): calling joinMangledQualifiers(mangleQualifiers(get_scope()),get_name()) --- get_name() = %s \n",get_name().str());
#endif
       // DQ (3/14/2012): Seperating the steps to computing the mangled name (which should include some qualification via non empty mangledScopeName)
       // SgName mangledName = joinMangledQualifiers(mangleQualifiers(get_scope()),get_name());
          SgName mangledScopeName = mangleQualifiers(get_scope());

#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
          printf ("In SgClassDeclaration::get_mangled_name(): mangleQualifiers(get_scope()) mangledScopeName = %s \n",mangledScopeName.str());
#endif
       // DQ (3/14/2012): I think that we can assert this.  No, if the scope is SgGlobal (for example) then the mangledName is empty.
       // ROSE_ASSERT(mangledScopeName.is_null() == false);

       // DQ (9/6/2016): We require a prefix to the name to avoid name collisions (see test2005_199.C and simplified test (but non-failing) in test2016_60.C).
       // SgName mangledName = joinMangledQualifiers(mangledScopeName,get_name());
          SgName prefixed_name = "class_" + get_name();
          SgName mangledName = joinMangledQualifiers(mangledScopeName,prefixed_name);
#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
          printf ("In SgClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s \n",mangledName.str());
#endif
          if (mangledName.is_null() == true)
             {
#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
               printf ("In SgClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s get_name() = %s \n",mangledName.str(),get_name().str());
#endif
               mangledName = "unknown_scope_and_name";
             }
          ROSE_ASSERT(mangledName.is_null() == false);

#if 0
       // DQ (6/23/2010): Added support to make classes with the same name different when they are
       // different classes containing different members.
          SgName memberNames = "_class_members_";
          if (get_definition() != NULL)
             {
               SgDeclarationStatementPtrList::const_iterator p = get_definition()->get_members().begin();
               while ( p != get_definition()->get_members().end() )
                  {
                 // DQ (2/22/2007): Added type to generated mangled name for each variable (supports AST merge generation of name for un-named classes)
                 // memberNames += SgName("_member_type_") + (*p)->get_type()->get_mangled() + SgName("_member_name_") + (*p)->get_mangled_name();
                    memberNames += SgName("_member_name_") + SageInterface::get_name(*p);

                    p++;
                  }
             }

          mangledName += memberNames;
#endif
       // p_globalMangledNameMap[classDeclaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgClassDeclaration*>(this),mangledName);
#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
          printf ("In SgClassDeclaration::get_mangled_name(): (AFTER adding to cache) mangledName = %s \n",mangledName.str());
#endif
       // DQ (5/31/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          string mangled_name = mangledName;
          if ( mangled_name.find('<') != string::npos )
             {
               printf ("In mangleQualifiersToString(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
             }
          ROSE_ASSERT(mangled_name.find('<') == string::npos);

#if DEBUG_CLASS_DECLARATION_GET_MANGLED_NAME
       // DQ (7/24/2012): Output the mangled name being generated for debugging.
          printf ("In SgClassDeclaration::get_mangled_name(): returning mangledName = %s \n",mangledName.str());
#endif

          return mangledName;
        }
#endif
   }

SgName
SgClassDeclaration::get_mangled_qualified_name ( int & cnt )
   {
  // This function is called during the construction of the SAGE AST.  As a result
  // it currently represents a dependence of the parent pointer.

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
  // ROSE_ASSERT (get_parent() != NULL);
  // ROSE_ASSERT (get_parent() == NULL);

     SgName nm;

  // if(isSgClassDefinition(get_parent()))
     SgNode* parentNode = get_parent();
     SgClassDefinition* parentDefinition = isSgClassDefinition(parentNode);
     if (parentDefinition != NULL)
        {
       // nm = (isSgClassDefinition(get_parent())->get_mangled_qualified_name(cnt));
          nm = (parentDefinition->get_mangled_qualified_name(cnt));
       // printf ("In $CLASSNAME::get_mangled_qualified_name(): nm = %s \n",nm.str());
        }
     cnt++;

  // DQ (4/28/2005):
  // nm << strlen(get_name().str());
  // nm << get_name().str();

     const SgTemplateInstantiationDecl* templateClassDeclaration = isSgTemplateInstantiationDecl(this);
     if (templateClassDeclaration != NULL)
        {
       // Need to remove " < " and " > " from template name so that can support name mangling
       // SgName className = "_"; // Avoid leading character being a number
          SgName className;
          className << get_name().getString().size();
          className += get_name();
          nm << fixupTemplateNameForMangledNameSupport(className).str();
        }
       else
        {
          nm << get_name().getString().size();
          nm << get_name().str();
        }

#if 0
     if (parentDefinition != NULL)
        {
//        printf ("In $CLASSNAME::get_mangled_qualified_name(cnt = %d) nm = %s \n",cnt-1,nm.str());
//        get_file_info()->display("Called from $CLASSNAME::get_mangled_qualified_name()");
        }
#endif

     return nm;
   }

bool
SgClassDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgClassDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

// GB (09/26/2007): Added this function as part of the move to index-based traversals: We only want the definition to be
// a traversal successor if isForward is false. This used to be handled in the AstSuccessorsSelectors code, but now it
// is isolated in this function (which is used by the traversal code generated by ROSETTA).
SgClassDefinition *
SgClassDeclaration::compute_classDefinition() const
   {
     if (isForward())
        {
          return NULL;
        }
     else
        {
          return p_definition;
        }
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgClassDeclaration::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgClassDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgClassDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgClassDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgClassDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgClassDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_CLASS_DECLARATION_STATEMENT_END

SOURCE_NONREAL_DECL_START

void
SgNonrealDecl::post_construction_initialization() {}

SgName SgNonrealDecl::get_name (void) const {
  return p_name;
}

void SgNonrealDecl::set_name (SgName name) {
  p_name = name;
}

SgNonrealType* SgNonrealDecl::get_type (void) const {
  return p_type;
}

void SgNonrealDecl::set_type (SgNonrealType* t) {
  p_type = t;
}

#define DEBUG_NONREAL_DECL_MANGLED 0
#define WARN_NONREAL_DECL_MANGLED 0

SgName
SgNonrealDecl::get_mangled_name (void) const {
#if DEBUG_NONREAL_DECL_MANGLED
  printf("In SgNonrealDecl::get_mangled_name():\n");
  printf("  - this = %p\n", this);
  printf("  - name = %s\n", get_name().str());
#endif
  ostringstream mangled_name;

  SgNode * parent_decl = NULL;
  SgScopeStatement * scope = get_scope();
  if (scope != NULL) {
#if DEBUG_NONREAL_DECL_MANGLED
    printf("  - scope = %p (%s)\n", scope, scope ? scope->class_name().c_str() : "");
#endif

    SgDeclarationScope * s_nrscope = isSgDeclarationScope(scope);
    if (s_nrscope == NULL) {
      printf("[ROSE-1881] SgNonrealDecl::get_mangled_name:\n> Scope is not an instantiation scope (nonreal)!\n> First observed for test2007_41.C in copyAST_tests.\n> Please report to nersc-rose-public@lbl.gov\n");
    }

    parent_decl = scope->get_parent();
  } else {
    parent_decl = get_parent();

    SgNonrealBaseClass * nrbaseclass = isSgNonrealBaseClass(parent_decl);
    if (nrbaseclass != NULL) {
      printf("[ROSE-1881] SgNonrealDecl::get_mangled_name:\n> Scope is not set when parent is nonreal base class!\n> First observed for test2006_79.C in copyAST_tests.\n> Please report to nersc-rose-public@lbl.gov\n");

      SgClassDefinition * xdefn = isSgClassDefinition(nrbaseclass->get_parent());
      ROSE_ASSERT(xdefn != NULL);
      parent_decl = xdefn->get_parent();
    } else {
      ROSE_ASSERT(false);
    }
    ROSE_ASSERT(parent_decl != NULL);
  }
#if DEBUG_NONREAL_DECL_MANGLED
  printf("  - parent_decl = %p (%s)\n", parent_decl, parent_decl ? parent_decl->class_name().c_str() : "");
#endif

  if (get_is_class_member()) {
    SgTemplateClassDeclaration * tplcdecl = isSgTemplateClassDeclaration(parent_decl);
    SgClassDeclaration * xdecl = isSgClassDeclaration(parent_decl);
    SgNonrealDecl * nrdecl = isSgNonrealDecl(parent_decl);
    if (tplcdecl != NULL) {
       SgDeclarationScope * nrscope = tplcdecl->get_nonreal_decl_scope();
#if DEBUG_NONREAL_DECL_MANGLED
       printf("  - nrscope = %p\n", nrscope);
#endif
       if (nrscope != scope) {
         mangled_name << tplcdecl->get_mangled_name().getString() << "___";
       }
    } else if (xdecl != NULL) {
       mangled_name << xdecl->get_mangled_name().getString() << "___";
    } else if (nrdecl != NULL) {
#if DEBUG_NONREAL_DECL_MANGLED
       SgDeclarationScope * nrscope = nrdecl->get_nonreal_decl_scope();
       printf("  - nrscope = %p\n", nrscope);
#endif
       mangled_name << nrdecl->get_mangled_name().getString() << "___";
    }
  }

  if (get_is_template_param()) {
#if 0
    ROSE_ASSERT(parent_decl != NULL);
    SgDeclarationStatement * parent_declstmt = isSgDeclarationStatement(parent_decl);

    SgScopeStatement * parent_scope = parent_declstmt != NULL ? parent_declstmt->get_scope() : NULL;
#if DEBUG_NONREAL_DECL_MANGLED
    printf("  - parent_scope = %p (%s)\n", parent_scope, parent_scope ? parent_scope->class_name().c_str() : "");
#endif

    SgDeclarationScope * parent_nrscope = isSgDeclarationScope(parent_scope);
#if DEBUG_NONREAL_DECL_MANGLED
    printf("  - parent_nrscope = %p (%s)\n", parent_nrscope, parent_nrscope ? parent_nrscope->class_name().c_str() : "");
#endif

    parent_declstmt = parent_nrscope != NULL ? isSgDeclarationStatement(parent_nrscope->get_parent()) : NULL;
#if DEBUG_NONREAL_DECL_MANGLED
    printf("  - parent_declstmt = %p\n", parent_declstmt);
#endif

    if (parent_declstmt != NULL) {
      mangled_name << parent_declstmt->get_mangled_name().getString() << "___";
    }
#endif
    if (p_template_parameter_depth > 1) {
      mangled_name << "__" << scope << "__";
    }
    mangled_name << "__templ_param_" << p_template_parameter_depth << "_" << p_template_parameter_position << "__";
  } else {
    mangled_name << get_name().getString();
  }

  SgName mangled(mangled_name.str());

  if (get_tpl_params().size() > 0)
    mangled = mangleTemplate(mangled,get_tpl_params(),get_scope());

  if (get_tpl_args().size() > 0)
    mangled = mangleTemplate(mangled,get_tpl_args(),get_scope());

#if DEBUG_NONREAL_DECL_MANGLED
    printf(" >> mangled = %s\n", mangled.getString().c_str());
#endif

  return mangled;
}

SgSymbol* SgNonrealDecl::get_symbol_from_symbol_table() const {
#if 0
  printf("In SgNonrealDecl::get_symbol_from_symbol_table():\n");
#endif
#if 0
  printf("  this   = %p (%s) = %s\n", this, this ? this->class_name().c_str() : "", this ? this->get_name().str() : "");
#endif
  SgNode * parent = get_parent();
  ROSE_ASSERT(parent != NULL);
#if 0
  printf("  parent = %p (%s)\n", parent, parent ? parent->class_name().c_str() : "");
#endif
  SgScopeStatement * scope = get_scope();
  ROSE_ASSERT(scope != NULL);

#if 0
    printf("  scope  = %p (%s)\n", scope, scope ? scope->class_name().c_str() : "");
#endif

  SgSymbol * res = scope->find_symbol_from_declaration(this);

  if (res == NULL) {

    SgGlobal * gscope = isSgGlobal(scope);
    if (gscope != NULL) {
      ROSE_ASSERT(false);
    } else {
      SgDeclarationStatement * parent = isSgDeclarationStatement(scope->get_parent());
      ROSE_ASSERT(parent != NULL);
#if 0
      printf("  parent  = %p (%s)\n", parent, parent ? parent->class_name().c_str() : "");
#endif
      SgTemplateClassDeclaration * tplcdecl = isSgTemplateClassDeclaration(parent);
      if (tplcdecl != NULL) {
        scope = tplcdecl->get_nonreal_decl_scope();
        ROSE_ASSERT(scope != NULL);
      } else {
        ROSE_ASSERT(false);
      }
    }
#if 0
    printf("  scope  = %p (%s)\n", scope, scope ? scope->class_name().c_str() : "");
#endif
    res = scope->find_symbol_from_declaration(this);
    ROSE_ASSERT(res != NULL);
  }

  return res;
}

SgName
SgNonrealDecl::get_qualified_name() const
   {
     SgName returnName;
     SgClassDeclaration * xdecl = isSgClassDeclaration(get_templateDeclaration());
     SgFunctionDeclaration * fdecl = isSgFunctionDeclaration(get_templateDeclaration());
     if (xdecl != NULL) {
       returnName = xdecl->get_qualified_name();
     } else if (fdecl != NULL) {
       returnName = fdecl->get_qualified_name();
     } else {
       returnName = get_name();
     }

     // TODO template argument

     return returnName;
   }

SOURCE_NONREAL_DECL_END

SOURCE_STMT_DECLARATION_STATEMENT_START

SgName
SgStmtDeclarationStatement::get_mangled_name (void) const {
    return SgName("__stmt__decl__stmt__");
}

SOURCE_STMT_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationDecl::post_construction_initialization()
   {
  // DQ (9/27/2004): This function should not modify the existing SgType which
  // in some cases is shared with other IR nodes within Sage III.  This is a bug
  // which effects the handling of defining vs. non-defining declarations.

  // printf ("p_templateArguments.size() = %" PRIuPTR " \n",p_templateArguments.size());

  // DQ (2/17/2007): Set the parents of all template arguments to the template instantiation
  // JJW (8/6/2008): p_templateArguments is not a pointer anymore
     SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
     while (i != p_templateArguments.end())
        {
          (*i)->set_parent(this);
          i++;
        }

#if 0
  // DQ (3/22/2012): Don't build the type here since we want it to share the type associated
  // with the first nondefining declaration and we don't know which this is yet.
  // defering the construction of the type makes this class's semantics the same as that for
  // the SgClassDeclaration.

  // DQ (7/29/2010): Build the type after setting the template aruments.
     if (get_type() == NULL)
        {
          set_type(SgClassType::createType(this));
        }
#endif

  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
  // ROSE_ASSERT(p_type == NULL);

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgTemplateInstantiationDecl::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

SgName
SgTemplateInstantiationDecl::get_qualified_name() const
   {
  // This is a function called after the parents have been set.  It is not called by the
  // EDG/SAGE interface and is only called after the SAGE AST has been built and the parent
  // pointers set within a separate phase.

  // Some error checking!

  // DQ (2/29/2012): Commented out because I think we use the scope pointer now, instead of the parent pointer.
  // printf ("In SgTemplateInstantiationDecl::get_qualified_name(): Commented out test of parent this->get_parent() = %p \n",this->get_parent());
  // ROSE_ASSERT (get_parent() != NULL);

  // DQ (11/23/2004): This name should have been reset already (before it is used here)
     if (get_nameResetFromMangledForm() == false)
        {
       // DQ (6/26/2005): It is OK for the EDG/Sage III translation to reference the qualified names
       // even before the names are properly set! As long as we consistently return EDG uniquely generated
       // names.  This will allow the symbols to be built and shared, but afterward the symbols will have
       // be in the wrong position in the hash table since the names used to place them will have changed.

       // printf ("Warning: In SgTemplateInstantiationDecl::get_qualified_name() (at %p) get_qualified_name() (get_nameResetFromMangledForm() == false) name = %s (skipping call to reset) \n",this,get_name().str());
        }
  // ROSE_ASSERT(get_nameResetFromMangledForm() == true);

  // DQ (8/28/2005): This function previously used the template declaration as a basis for
  // its qualified name generation.  I think this is a mistake and that the templates scope
  // should be used instead (same as for where qualified names are generated elsewhere).

#if 0
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

  // Make sure that parents have been set already
  // (assume this means that all parents have been set)
     if (get_parent() == NULL)
        {
          printf ("In $CLASSNAME::get_qualified_name() this = %p at: \n",this);
          get_file_info()->display("Error at this location in source code!");
        }
     ROSE_ASSERT (get_parent() != NULL);

     SgName returnName;

     SgTemplateDeclaration* templateDeclaration = get_templateDeclaration();
     ROSE_ASSERT(templateDeclaration != NULL);

     returnName = SgName::assembleQualifiedName(templateDeclaration->get_qualified_name(),get_name());

     return returnName;
#else
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }


#define DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME 0

// RV (2/1/2006): Added mangler for template instantiations.
SgName
SgTemplateInstantiationDecl::get_mangled_name (void) const
   {
#if 0
     return mangleTemplate (get_templateName(),
                            get_templateArguments (),
                            get_scope ());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationDecl* declaration = const_cast<SgTemplateInstantiationDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationDecl*>(this));

#if 0
     printf ("In SgTemplateInstantiationDecl::get_mangled_name(): this = %p name = %s mangledNameString.empty() = %s \n",this,get_name().str(),mangledNameString.empty() ? "true" : "false");
  // printf ("In SgTemplateInstantiationDecl::get_mangled_name(): associated definition = %p = %s \n",get_definition(),get_definition()->class_name().c_str());
     if (get_definition() != NULL)
        {
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): associated definition = %p = %s \n",get_definition(),get_definition()->class_name().c_str());
        }
       else
        {
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): (non-defining declaration): associated definition = %p \n",get_definition());
        }

  // DQ (10/29/2015): We need to check this since as the AST is being build the source position may not yet be set.
  // This function is called in the construction of types to insert new types into the global type tables, and to
  // check for existing types to support sharing of types in the AST (from the global type table).
     if (this->get_file_info() != NULL)
        {
          ROSE_ASSERT(this->get_file_info() != NULL);
          ROSE_ASSERT(this->get_startOfConstruct() != NULL);
          ROSE_ASSERT(this->get_endOfConstruct()   != NULL);

       // this->get_file_info()->display("In SgTemplateInstantiationDecl::get_mangled_name(): debug");
          this->get_startOfConstruct()->display("START: In SgTemplateInstantiationDecl::get_mangled_name(): debug");
          this->get_endOfConstruct  ()->display("END: In SgTemplateInstantiationDecl::get_mangled_name(): debug");
        }
#endif

     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): (FOUND in cache) mangledNameString = %s get_name() = %s \n",mangledNameString.c_str(),get_name().str());
#endif
          return mangledNameString;
        }
       else
        {
       // DQ (7/24/2010): Added to support type tables (at an early stage in AST construction, the get_templateName() might not be known yet.
       // ROSE_ASSERT(get_templateName().is_null() == false);
          SgName template_name = get_templateName();
          if (template_name.is_null() == true)
             {
            // Use the name of the template (as defined by EDG) so that we can generate a unique string
            // (later this is reset to excluse EDG geneated strings that don't map to the original source code).
               printf ("ERROR: In SgTemplateInstantiationDecl::get_mangled_name(): template_name.is_null() == true, using get_name() \n");
               template_name = get_name();

            // DQ (6/1/2012): Make this an error.
               printf ("SgTemplateInstantiationDecl::get_mangled_name(): Make this an error! \n");
               ROSE_ASSERT(false);
             }
          ROSE_ASSERT(template_name.is_null() == false);

#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): template_name = %s get_templateArguments().size() = %" PRIuPTR " get_scope() = %p \n",template_name.str(),get_templateArguments().size(),get_scope());
#endif

       // DQ (5/31/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          string mangled_name_1 = template_name;
          if ( mangled_name_1.find('<') != string::npos )
             {
               printf ("In SgTemplateInstantiationDecl::get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name_1.c_str());
             }
       // ROSE_ASSERT(mangled_name_1.find('<') == string::npos);

       // DQ (3/22/2012): Added assertion to detect bad (default) names being used.
          ROSE_ASSERT(template_name != "SETME_NONDEFINING_DECL<>");
#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
          printf ("Before mangleTemplate(): template_name = %s \n",template_name.str());
#endif
#if 0
       // DQ (6/1/2012): Turn this test on!
          if (get_templateArguments().size() == 0)
             {
            // DQ (6/1/2012): We are still in the process of building this type and the arguments have not been attached yet.  So use the declaration's name from "get_name()".
               printf ("In SgTemplateInstantiationDecl::get_mangled_name(): get_templateArguments().size() == 0, using get_name() \n");
               template_name = get_name();

               ROSE_ASSERT(template_name.getString().find('<') != string::npos);
             }

       // DQ (6/1/2012): We need the template arguments in order to generate the mangled name for the type!  This is the current problem.
       // If the instantiated template name has tmeplate argument syntax, then we need to be able to see the list of template arguments.
       // In some cases these template argument are not yet attached to the declaration, and so the wrong mangled name for the type will be generated.
       // If we use the template name from "get_name()", then we will generate unique names, but then we will fail the test to make sure
       // that there is no template argument syntax in the mangled names (AST Consistency tests).
          if (get_name().getString().find('<') != string::npos)
             {
               printf ("WARNING: In SgTemplateInstantiationDecl::get_mangled_name(): Skipping test for: get_templateArguments().size() > 0 \n");
            // ROSE_ASSERT(get_templateArguments().size() > 0);
             }

#endif

       // SgName mangledName = mangleTemplate (get_templateName(),get_templateArguments(),get_scope());
          SgName mangledName = mangleTemplate(template_name,get_templateArguments(),get_scope());
#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
          printf ("After mangleTemplate(): get_templateArguments().size() = %" PRIuPTR " mangledName = %s \n",get_templateArguments().size(),mangledName.str());
#endif
          ROSE_ASSERT(get_firstNondefiningDeclaration() != NULL);
#if 0
          printf ("After mangleTemplate(): get_firstNondefiningDeclaration()->get_templateArguments().size() = %" PRIuPTR " \n",isSgTemplateInstantiationDecl(get_firstNondefiningDeclaration())->get_templateArguments().size());
          if (get_definingDeclaration() != NULL)
               printf ("After mangleTemplate(): get_definingDeclaration()->get_templateArguments().size() = %" PRIuPTR " \n",isSgTemplateInstantiationDecl(get_definingDeclaration())->get_templateArguments().size());
#endif
#if 0
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): (NOT found in cache) mangledName = %s get_name() = %s get_templateName() = %s \n",mangledName.c_str(),get_name().str(),get_templateName().str());
#endif
       // DQ (7/24/2010): Added to support type tables.
          ROSE_ASSERT(mangledName.is_null() == false);

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationDecl*>(this),mangledName);
#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
          printf ("After SageInterface::addMangledNameToCache(): mangledName = %s \n",mangledName.str());
#endif
       // DQ (5/31/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          string mangled_name = mangledName;
          if ( mangled_name.find('<') != string::npos )
             {
               printf ("In SgTemplateInstantiationDecl::get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
             }
          ROSE_ASSERT(mangled_name.find('<') == string::npos);

#if DEBUG_TEMPLATE_INSTANTIATION_DECL_GET_MANGLED_NAME
       // DQ (7/24/2012): Output the mangled name being generated for debugging.
          printf ("In SgTemplateInstantiationDecl::get_mangled_name(): returning mangledName = %s \n",mangledName.str());
#endif

          return mangledName;
        }
#endif
   }



void
SgTemplateInstantiationDecl::set_definition( SgTemplateInstantiationDefn* definition )
   {
  // DQ (9/23/2004): Implement this function to hide the base class one so that the interface
  // to set_definition takes a SgTemplateInstantiationDefn instead of a SgClassDefinition.
  // Implement using explicit call to the base class set_definition function.
     SgClassDeclaration::set_definition(definition);
   }

void
SgTemplateInstantiationDecl::set_definition( SgClassDefinition* definition )
   {
  // DQ (10/10/2014): Implemented to support Aterm constructor functions.
  // We need a way for the automatically generated code to set the
  // definition data member in the base class.

  // DQ (10/10/2014): Make sure that this is a SgTemplateInstantiationDefn (or NULL).
     ROSE_ASSERT(definition == NULL || isSgTemplateInstantiationDefn(definition) != NULL);

     SgClassDeclaration::set_definition(definition);
   }

void
SgTemplateInstantiationDecl::resetTemplateName ()
   {
#if 0
  // DQ (6/30/2018): Adding debugging for infinite loop in test2018_117.C.
     printf ("In SgTemplateInstantiationDecl::resetTemplateName(): calling resetTemplateNameSupport(): p_nameResetFromMangledForm = %s p_name = %s \n",p_nameResetFromMangledForm ? "true" : "false",p_name.str());
#endif

  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationFunctionDecl::post_construction_initialization()
  {
     SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
     while (i != p_templateArguments.end()) {
        (*i)->set_parent(this);
        i++;
     }
  }

void
SgTemplateInstantiationFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template function instantiations.
SgName
SgTemplateInstantiationFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationFunctionDecl* declaration = const_cast<SgTemplateInstantiationFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
       // DQ (5/31/2012): Check that this name is set.
          ROSE_ASSERT(get_templateName().is_null() == false);

          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#if 0
          printf ("In SgTemplateInstantiationFunctionDecl::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationFunctionDecl*>(this),mangledName);

       // DQ (7/24/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          string mangled_name = mangledName;
          if ( mangled_name.find('<') != string::npos )
             {
               printf ("In get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
             }
          ROSE_ASSERT(mangled_name.find('<') == string::npos);

#if 0
       // DQ (7/24/2012): Output the mangled name being generated for debugging.
          printf (">>>>>>>>>> SgTemplateInstantiationFunctionDecl::get_mangled_name(): returning mangledName = %s \n",mangledName.str());
#endif

          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }


// DQ (11/27/2011): Adding support to hold the template declarations in the AST.
SgTemplateInstantiationFunctionDecl::SgTemplateInstantiationFunctionDecl ( SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
#if 0
// DQ (10/11/2014): Marking SgFunctionParameterList as a constructor parameter to support aterm to AST generation.
// : SgFunctionDeclaration(name, NULL, type, definition)
#else
   : SgFunctionDeclaration(name, type, definition)
#endif
   {
  // Custom constructor to support same interface and allow for a templated function to to build SgFunctionDeclaration,

     SgTemplateArgumentPtrList templateArguments;

  // Same code as in generated constructor.
     p_templateName = "";
     p_templateDeclaration = nullptr;

     p_templateArguments = templateArguments;
     p_nameResetFromMangledForm = false;

  // Test the variant virtual function
     assert(TEMPLATE_INST_FUNCTION_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationFunctionDecl() function since it has been problematic
     ASSERT_not_null(isSgTemplateInstantiationFunctionDecl(this));
   }

SOURCE_TEMPLATE_INSTANTIATION_FUNCTION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_MEMBER_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateInstantiationMemberFunctionDecl::post_construction_initialization()
  {
     SgTemplateArgumentPtrList::iterator i = p_templateArguments.begin();
     while (i != p_templateArguments.end()) {
        (*i)->set_parent(this);
        i++;
     }
  }

void
SgTemplateInstantiationMemberFunctionDecl::resetTemplateName ()
   {
  // local version of function to support generation of template names
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// RV (2/1/2006): Added mangler for template member function instantiations.
SgName
SgTemplateInstantiationMemberFunctionDecl::get_mangled_name (void) const
  {
#if 0
    return mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateInstantiationMemberFunctionDecl* declaration = const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = mangleTemplateFunction (get_templateName().getString(),get_templateArguments(),get_type(),get_scope());
#if 0
          printf ("In SgTemplateInstantiationMemberFunctionDecl::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateInstantiationMemberFunctionDecl*>(this),mangledName);

       // DQ (7/24/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
          string mangled_name = mangledName;
          if ( mangled_name.find('<') != string::npos )
             {
               printf ("In get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
             }
          ROSE_ASSERT(mangled_name.find('<') == string::npos);

#if 0
       // DQ (7/24/2012): Output the mangled name being generated for debugging.
          printf (">>>>>>>>>> SgTemplateInstantiationMemberFunctionDecl::get_mangled_name(): returning mangledName = %s \n",mangledName.str());
#endif

          return mangledName;
        }
#endif
  }

// DQ (2/11/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateInstantiationMemberFunctionDecl::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

// DQ (11/27/2011): Adding support to hold the template declarations in the AST.
SgTemplateInstantiationMemberFunctionDecl::SgTemplateInstantiationMemberFunctionDecl ( SgName name, SgFunctionType* type, SgFunctionDefinition* definition )
#if 0
// DQ (10/11/2014): Marking SgFunctionParameterList as a constructor parameter to support aterm to AST generation.
// : SgMemberFunctionDeclaration(name, NULL, type, definition)
#else
   : SgMemberFunctionDeclaration(name, type, definition)
#endif
   {
  // Custom constructor to support same interface and allow for a templated function to to build SgMemberFunctionDeclaration,

  // Only two lines of additional code to allow use of same code as in generated constructor (below).
     SgTemplateArgumentPtrList templateArguments;

  // Same code as in generated constructor.
     p_templateName = "";
     p_templateDeclaration = NULL;
     p_templateArguments = templateArguments;
     p_nameResetFromMangledForm = false;

  // Test the variant virtual function
     assert(TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT == variant());
     post_construction_initialization();

  // Test the isSgTemplateInstantiationMemberFunctionDecl() function since it has been problematic
     assert(isSgTemplateInstantiationMemberFunctionDecl(this) != NULL);
   }



SOURCE_TEMPLATE_INSTANTIATION_MEMBER_FUNCTION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_START

void
SgTemplateInstantiationDefn::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgTemplateInstantiationDefn::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }


// DQ (9/8/2004): overrides base class implementation
SgName
SgTemplateInstantiationDefn::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

  // It is a little less trivial to obtain the SgTemplateInstatiationDecl from the SgTemplateInstatiationDefn
  // since get_declaration() returns a SgClassDeclaration pointer and not a SgTemplateInstantiationDecl pointer.
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     SgTemplateInstantiationDecl* templateInstantiationDeclaration = isSgTemplateInstantiationDecl(classDeclaration);
     ROSE_ASSERT(templateInstantiationDeclaration != NULL);

  // DQ (10/16/2004): Not sure why this is not set!
  // ROSE_ASSERT (get_parent() != NULL);
     if (templateInstantiationDeclaration->get_parent() == NULL)
        {
       // DQ (3/6/2012): Commented out this code since the name qulification uses the scope and not the parent.
       // printf ("templateInstantiationDeclaration->get_parent() == NULL SgTemplateInstantiationDecl = %p SgClassDefinition = %p \n",templateInstantiationDeclaration,this);
       // get_file_info()->display("$CLASSNAME");
       // templateInstantiationDeclaration->get_file_info()->display("templateInstantiationDeclaration");
        }

  // DQ (3/5/2012): Allow the parent to be unset (since I thing it might not be required any more because we use the scope).
  // ROSE_ASSERT (templateInstantiationDeclaration->get_parent() != NULL);
  // printf ("Note: In SgTemplateInstantiationDefn::get_qualified_name(): we no longer assert that templateInstantiationDeclaration->get_parent() != NULL \n");

     return templateInstantiationDeclaration->get_qualified_name();
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( Sg_File_Info *f, SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(f,decl)
   {
   }

SgTemplateInstantiationDefn::SgTemplateInstantiationDefn( SgTemplateInstantiationDecl *decl)
   : SgClassDefinition(decl)
   {
   }


// DQ (5/31/2012): Added to support the generation of mangled names and permit testing for template syntax.
SgName
SgTemplateInstantiationDefn::get_mangled_name(void) const
   {
#if 0
     printf ("In SgTemplateInstantiationDefn::get_mangled_name(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (10/31/2015): This the actual detection in this function is commented out so that we can
  // use the mechanism to avoid template class instantiations from be processed recursively.
  // testForCycleInTemplateArgumentsOfTemplateDeclaration(this);

#if 0
     printf ("PASSED: In SgTemplateInstantiationDefn::get_mangled_name(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // SgName mangledName = get_declaration()->get_mangled_name();
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     SgName mangledName = classDeclaration->get_mangled_name();

#if 0
     printf ("In SgTemplateInstantiationDefn::get_mangled_name(): mangleName = %s \n",mangledName.str());
#endif

  // DQ (5/31/2012): Added test for template brackets that are caught later in AstConsistencyTests.
  // Make sure that there is no template specific syntax included in the mangled name
     string mangled_name = mangledName;
     if ( mangled_name.find('<') != string::npos )
        {
          printf ("In mangleQualifiersToString(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
        }
     ROSE_ASSERT(mangled_name.find('<') == string::npos);

     return  mangledName;
   }



SOURCE_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT_END

SOURCE_CLASS_DEFINITION_STATEMENT_START

void
SgClassDefinition::post_construction_initialization()
   {
  // DQ (9/5/2006): I don't think that this is called, but if it is then packingAlignment initialization is required.
     p_packingAlignment = 0;

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgClassDefinition::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
SgClassDefinition::set_declaration(SgClassDeclaration* new_val)
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     set_parent(new_val);
   }

SgClassDeclaration*
SgClassDefinition::get_declaration() const
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_parent() != NULL);
  // printf ("In SgClassDefinition::get_declaration(): get_parent() = %p = %s \n",get_parent(),get_parent()->class_name().c_str());

     SgClassDeclaration *decl = isSgClassDeclaration(get_parent());
     assert( get_parent() == NULL || decl != NULL );
     return decl;
   }

SgClassDefinition::SgClassDefinition( Sg_File_Info *f, SgClassDeclaration *decl)
   : SgScopeStatement(f)
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

SgClassDefinition::SgClassDefinition( SgClassDeclaration *decl)
   : SgScopeStatement()
   {
     set_declaration(decl);
     decl->set_definition(this);

  // DQ (9/5/2006): Added initialization of packingAlignment (required to be explicit in this constructor)
     p_packingAlignment = 0;
   }

#if 0
void
SgClassDefinition::insert_member(const SgDeclarationStatementPtrList::iterator& where, SgDeclarationStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_members().insert(where,what);
   }
#endif

void
SgClassDefinition::append_member(SgDeclarationStatement * what)
   {
     get_members().push_back(what);
     what->set_parent(this);
   }

void
SgClassDefinition::prepend_member(SgDeclarationStatement * what)
   {
     get_members().insert(get_members().begin(), what);
     what->set_parent(this);
   }

void
// $CLASSNAME::append_inheritance(const SgBaseClass & what)
SgClassDefinition::append_inheritance(SgBaseClass* what)
   {
     get_inheritances().push_back(what);
     what->set_parent(this);
   }

void
// $CLASSNAME::prepend_inheritance(const SgBaseClass & what)
SgClassDefinition::prepend_inheritance(SgBaseClass* what)
   {
     get_inheritances().insert(get_inheritances().begin(), what);
   }

#if 0
void
// $CLASSNAME::insert_inheritance(const SgBaseClassList::iterator & where, const SgBaseClass & what)
SgClassDefinition::insert_inheritance(const SgBaseClassPtrList::iterator & where, SgBaseClass* what)
   {
     get_inheritances().insert(where,what);
   }
#endif

SgName
SgClassDefinition::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_qualified_name();
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     return classDeclaration->get_qualified_name();
   }

// DQ (2/7/2006): code added by Rich Vuduc
SgName
SgClassDefinition::get_mangled_name (void) const
   {
  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_mangled_name();
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     return classDeclaration->get_mangled_name();
   }

SgName
SgClassDefinition::get_mangled_qualified_name (int& i)
   {
  // printf ("In $CLASSNAME::get_mangled_qualified_name(%d): Calling get_declaration()->get_mangled_qualified_name(%d) \n",i,i);

  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_mangled_qualified_name(i);
     SgClassDeclaration* classDeclaration = get_declaration();
     ROSE_ASSERT(classDeclaration != NULL);
     return classDeclaration->get_mangled_qualified_name(i);
   }

bool
SgClassDefinition::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return StatementListInsertChild(this, get_members(), target, newstmt, true, extractBasicBlock, true);
   }

bool
SgClassDefinition::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront,
                                 bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_members(), target, newstmt, inFront, extractBasicBlock, false);
   }

#if 0
// DQ (8/18/2004): removing this older pragma mechanism
/******  SgClassDeclaration ******/
int
get_suppress_global(SgClassDeclaration *node)
   {
     SgClassDecl_attr *attr= (SgClassDecl_attr *) Sgget_user_attribute(node->get_uattributes(),"SgClassDecl_attr");
     if(attr)
          return attr->get_suppress_global();

     return 0;
   }
#endif

SOURCE_CLASS_DEFINITION_STATEMENT_END




SOURCE_ENUM_DECLARATION_STATEMENT_START

void
SgEnumDeclaration::post_construction_initialization()
   {
  // DQ (9/27/2004): This should be conditional upon if the SgType was provided
  // in the constructor argument list (as in SgClassDeclaration).
  // set_type(SgEnumType::createType(this));
     if (get_type() == NULL)
        {
#if 0
#if PRINT_DEVELOPER_WARNINGS
          printf ("In $CLASSNAME::post_construction_initialization(): setting the SgEnumType type internally (using the declaration) \n");
#endif
#endif
       // DQ (2/27/2018): It is an inconsistancy that this class's semantics sets the type here (not done for other declaration IR nodes).
       // Note: that this is now the only IR node that constrcuts its type within its constructor (or post_construction_initialization() function).
          set_type(SgEnumType::createType(this));
        }

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgEnumDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

void
// $CLASSNAME::append_enumerator(const SgInitializedName & what)
SgEnumDeclaration::append_enumerator( SgInitializedName* what)
   {
     get_enumerators().push_back(what);
     what->set_parent(this);
   }

void
// $CLASSNAME::prepend_enumerator(const SgInitializedName & what)
SgEnumDeclaration::prepend_enumerator( SgInitializedName* what)
   {
     get_enumerators().insert(get_enumerators().begin(), what);
     what->set_parent(this);
   }

#if 0
SgInitializedNamePtrList::iterator
// $CLASSNAME::insert_enumerator(const SgInitializedNamePtrList::iterator& where, const SgInitializedName & what)
SgEnumDeclaration::insert_enumerator(const SgInitializedNamePtrList::iterator& where, SgInitializedName* what)
   {
  // DQ (9/27/2004): This function appears to have a side-effect on its input, not clear if this is appropriate.
     SgInitializedNamePtrList::iterator new_item = get_enumerators().insert(where,what);
     (*new_item)->set_parent(this);
     return new_item;
   }
#endif

SgName
SgEnumDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for enum declarations.
SgName
SgEnumDeclaration::get_mangled_name (void) const
   {
#if 0
     SgName mangled_name;
     SgName name = get_name();

#if 1
  // DQ (6/1/2006): Added special handling for case where the class name is empty as in an
  // printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

  // If this was originally a un-named enum then the astPostProcessing/fixupNames.C updated the name to reflect
  // a compiler generated tag name that could be references (and would be required) when multiple variables
  // might be used and the normalization of the AST (EDG) is done to reflect the separation into indivual
  // variable declarations.  This was a bug fix in response to a bug report from IBM (Fall 2006).
  // However the compiler generated names are inappropriate for the AST merge since they are not unique
  // (by design) and so they don't share properly.  So we now detect the ROSE compiler generated name
  // and proceed as though the enum had never need assigneda tag and generate a unique name that will
  // match appropriately to allow sharing (when ODR is not violated).  Basicaly we use the compiler generated
  // name to trigger this mechanism which used to be triggered when no name was available (specifically when
  // case: name.is_null() == true).
     bool specialCaseNameHandling = (name.getString().find("__rose_generated_enum_tag_name_") != std::string::npos);

  // DQ (3/10/2007): If the enum is un-named in a typedef (as the base type) then it should not be given another name by ROSE.
  // This is because the declaration can only be referred to once (handling multiple references is why we sometimes have to
  // provide a generated name (e.g. a variable declaration which has multiple variables).
  // Now that we reset empty name this should be true (unless fixup had not been called)
  // ROSE_ASSERT (name.is_null() == false);

  // DQ (8/20/2006): This will be a valid name for all C++ programs, but not for C programs (see Cxx_tests/math.C).
  // if (name.is_null() == true)

  // DQ (2/22/2007): I think that we don't use this sort of name internally any more!
  // We generate more comlex names approporate to support the AST merge mechanism.
     ROSE_ASSERT(specialCaseNameHandling == false);

     if (specialCaseNameHandling == true)
        {
       // DQ (8/20/2006): Using the parent can cause endless recursion for the code "typedef enum { enum_field } enum_typedef_type;"
       // so we have to assemble a unique name without resorting to the parent.
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
       // It the enum is unnamed then use the name of the first enum field (since it can't be redefied in the same scope, it is unique)
       // printf ("Using the parent of the enum to generate a name: parent = %p = %s \n",parent,parent->class_name().c_str());
       // This should be true for C but maybe not for C++!
       // name = SgDeclarationStatement::generate_alternative_name_for_unnamed_declaration(parent);
          const SgInitializedNamePtrList & fieldList = p_enumerators;
       // printf ("In SgEnumDeclaration::get_mangled_name(): fieldList.size() = %ld \n",fieldList.size());
       // ROSE_ASSERT(fieldList.empty() == false);
          if (fieldList.empty() == true)
             {
               printf ("WARNING in SgEnumDeclaration::get_mangled_name(): fieldList.empty() == true \n");
             }
          SgInitializedNamePtrList::const_iterator i = fieldList.begin();
          name = "__unnamed_enum__";
          while(i != fieldList.end())
             {
               name += (*i)->get_name();
               i++;
               if (i != fieldList.end())
                  {
                    name += "__COMMA__";
                  }
             }
        }

  // DQ (3/10/2007): Modified to let this pass. mangled names for enums would not be
  // used in so critial a situation as class declarations which are more complex.
  // ROSE_ASSERT(name.is_null() == false);
     mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#else
     if (name.get_length () == 0) // Is an anonymous enum in C
          mangled_name = SgName ("i"); // Treat like an integer
       else // Return a fully qualified mangled type name
          mangled_name = joinMangledQualifiers (mangleQualifiers(get_scope()),name);
#endif

     return mangled_name;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgEnumDeclaration* declaration = const_cast<SgEnumDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgEnumDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(void): name from getMangledNameFromCache: mangledNameString = %s \n",mangledNameString.c_str());
#endif
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
       // DQ (5/11/2007): If this is an enum type in a function definition then the mangled name for the type will
       // atempt to include the mangled name of the function definition (the scope of the function parameter) which
       // will cause infinit recursion in the evaluation of the mangled name of the function declaration which must
       // include the function parameter, and so on.  However, this only appears to be a problem for C and not C++.
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(void): get_scope() = %p = %s \n",get_scope(),get_scope()->class_name().c_str());

          static int counter = 0;
          counter++;
          ROSE_ASSERT(counter < 10);
#endif

          string mangleQualifiersString;
          if (isSgFunctionDefinition(get_scope()) != NULL)
             {
            // printf ("This is a parameter to a function and will cause infinite recursion in its evaluation \n");
               mangleQualifiersString = "_function_parameter_";
             }
            else
             {
            // DQ (3/14/2012): We want to have a valid scope so that we can build a properly
            // mangled name but the scope is not yet available unless we modify the constructor
            // (which would break some code).  So allow this to be built for now and we will
            // see if it is an issue.  Make it a warning to not have a valid scope. Note
            // that this is only an issue for C++.  We also might not want to add the name
            // to the cache if the scope was NULL.
            // mangleQualifiersString = mangleQualifiers(get_scope());
               if (get_scope() == NULL)
                  {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
                    printf ("WARNING: SgEnumDeclaration::get_mangled_name(): get_scope() == NULL, mangleQualifiers will be incomplete (empty) \n");
#endif
                  }
                 else
                  {
                 // DQ (1/12/13): Assert that this is not a previously deleted IR node (which will have the name = "SgNode").
                    ROSE_ASSERT(get_scope()->class_name() != "SgNode");

                 // DQ (1/12/13): Added assertion (only makes sense for non SgGlobal scopes).
                    if (isSgGlobal(get_scope()) == NULL)
                       {
                         ROSE_ASSERT(get_scope()->get_scope() != NULL);
                       }

                    mangleQualifiersString = mangleQualifiers(get_scope());
                  }
             }

       // DQ (9/6/2016): We require a prefix to the name to avoid name collisions (see test2005_199.C and simplified test (but non-failing) in test2016_60.C).
       // SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()),get_name());
       // SgName mangledName = joinMangledQualifiers (mangleQualifiersString,get_name());
          SgName prefixed_name = "enum_" + get_name();
          SgName mangledName = joinMangledQualifiers(mangleQualifiersString,prefixed_name);
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
       // DQ (4/23/2013): If the scope is not available, then don't put this into the MangleNameToCache.
       // It can be added later when the scope is available and at a point where the name will be more meanningful.
       // p_globalMangledNameMap[declaration] = mangledName;
       // mangledName = SageInterface::addMangledNameToCache(const_cast<SgEnumDeclaration*>(this),mangledName);
          if (get_scope() != NULL)
             {
#if 0
               printf ("In SgEnumDeclaration::get_mangled_name(void): PUT name into MangleNameToCache: mangledName = %s \n",mangledName.str());
#endif
               mangledName = SageInterface::addMangledNameToCache(const_cast<SgEnumDeclaration*>(this),mangledName);
             }
            else
             {
#ifdef ROSE_DEBUG_NEW_EDG_ROSE_CONNECTION
               printf ("In SgEnumDeclaration::get_mangled_name(void): SKIP putting name into MangleNameToCache: mangledName = %s \n",mangledName.str());
#endif
             }
#if 0
          printf ("In SgEnumDeclaration::get_mangled_name(void): generated name: mangledName = %s \n",mangledName.str());
#endif
          return mangledName;
        }
#endif
   }

bool
SgEnumDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgEnumDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
#if 0
  // DQ (5/30/2007): We might want to look for either the symbol for the defining or the non-defining declaration.
  // SgSymbol* returnSymbol = get_scope()->get_symbol_table()->find(this);
     SgSymbol* returnSymbol = NULL;
     if (returnSymbol == NULL)
        {
       // The symbol appears to be typically associated with the defining declaration (perhaps because forward enums are non-standard).
       // Though it might be that we should treat enums uniformly with other declarations now that we have recently added forward
       // enum declarations as a supported non-standard feature (because most frontends do (except for GNU curiously enough)).
          if (this->get_definingDeclaration() != NULL)
             {
               returnSymbol = get_scope()->get_symbol_table()->find(this->get_definingDeclaration());
             }
            else
             {
               if (this->get_firstNondefiningDeclaration() != NULL)
                  {
                    returnSymbol = get_scope()->get_symbol_table()->find(this->get_firstNondefiningDeclaration());
                  }
                 else
                  {
                 // This is an error!
                    ROSE_ASSERT(false);
                  }
             }
        }

     return returnSymbol;
#else
  // DQ (5/31/2007): This is the version that we want, it is consistent with the implementation elsewhere
  // and the correct fix was to handle the case where this is NULL (in src/frontend/SageIII/astMerge/collectAssocitateNodes.C).
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
#endif
   }


// DQ (2/14/2019): Added C++11 support for enum prototypes, which mens that name
// qualification can be required for the defining declarations.
int
SgEnumDeclaration::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgEnumDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgEnumDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgEnumDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgEnumDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgEnumDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }



SOURCE_ENUM_DECLARATION_STATEMENT_END


SOURCE_EXPRESSION_STATEMENT_START
// QY: 9/30/2004   removed the expr_i pointer in exprStatement. Use exprRoot directly as constructor parameter
void
SgExprStatement::post_construction_initialization()
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != NULL)
  //      get_expression_root()->set_statement(this);

  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.
     if (get_expression() != NULL)
          get_expression()->set_parent(this);

#if 0
  // DQ (1/12/13): This is code that can be helpful in debubbing subtle problems in astCopy and astDelete.
     printf ("In SgExprStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

// DQ (12/6/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgExprStatement::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

SOURCE_EXPRESSION_STATEMENT_END


SOURCE_LABEL_STATEMENT_START

bool
SgLabelStatement::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

void
SgLabelStatement::post_construction_initialization()
   {
#if 0
  // DQ (1/12/13): This is code that can be helpful in debugging subtle problems in astCopy and astDelete.
     printf ("In SgLabelStatement::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif
   }

SgName
SgLabelStatement::get_name() const
   {
     return get_label();
   }

SgSymbol*
SgLabelStatement::get_symbol_from_symbol_table() const
   {
     SgScopeStatement* tempScope = get_scope();
     ASSERT_not_null(tempScope);

  // PP (07/18/23): Ada inserts labels at the innermost scope
     if (SageInterface::is_Ada_language())
       return tempScope->find_symbol_from_declaration(this);

     while (tempScope != nullptr && isSgFunctionDefinition(tempScope) == nullptr)
        {
          tempScope = tempScope->get_scope();
        }

     SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(tempScope);
     if (functionDefinition == nullptr)
        {
          std::cerr << "[WARN]: Labels are stored in the SgFunctionDefinition (function scope), could not locate associated function scope\n";
        }
     ASSERT_not_null(functionDefinition);
     return functionDefinition->find_symbol_from_declaration(this);
   }

SgType*
SgLabelStatement::get_type() const
   {
  // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
  // template low-level symbol table support function would compile cleanly.  Note that it is an error to
  // call this function and it is not a virtual function that will cause derived class versions to be called
  // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).
     return NULL;
   }

bool
SgLabelStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
  // DQ (1/15/2018): Added support for the statement of the label to be traversed.
     return ( StatementReplace(this, p_statement, target, newstmt) == true );
   }

SOURCE_LABEL_STATEMENT_END


SOURCE_JAVA_LABEL_STATEMENT_START

void
SgJavaLabelStatement::post_construction_initialization()
   {
   }

// charles4: 09/13/2011 - Adapted from SgLabelStatement to support Java.
// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgJavaLabelStatement::get_symbol_from_symbol_table() const
   {
#if 0
     ROSE_ASSERT(get_scope() != NULL);
     ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
     return get_scope()->get_symbol_table()->find(this);
#else
     return this->find_symbol_from_declaration(this);
#endif
   }

SgType*
SgJavaLabelStatement::get_type() const
   {
  // DQ (8/21/2013): Added function to support calling get_type() from a SgDeclarationStatement so that the
  // template low-level symbol table support function would compile cleanly.  Note that it is an error to
  // call this function and it is not a virtual function that will cause derived class versions to be called
  // where appropriate (and it is not always appropriate, e.g a SgNamespaceDeclaration has no assocated SgType).
     return NULL;
   }

SOURCE_JAVA_LABEL_STATEMENT_END


SOURCE_WHILE_STATEMENT_START
void
SgWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgWhileStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_condition();
        }
       else
          if(n==1)
             {
               n++;
               return get_body();
             }
     return 0;
   }
#endif

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_WHILE_STATEMENT_END

SOURCE_WITH_STATEMENT_START
SOURCE_WITH_STATEMENT_END

SOURCE_DO_WHILE_STATEMENT_START
void
SgDoWhileStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

bool
SgDoWhileStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
          return true;
     else return ( StatementReplace(this, p_body, target, newstmt) == true );
}

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgDoWhileStmt::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_DO_WHILE_STATEMENT_END


SOURCE_SWITCH_STATEMENT_START
void
SgSwitchStatement::post_construction_initialization()
   {
  // if (get_item_selector_root() != 0)
  //      get_item_selector_root()->set_parent(this);
     if (get_item_selector() != NULL)
          get_item_selector()->set_parent(this);

  // DQ (11/2/2007): Reset the scope of any variables declared in the item_selector
     SgVariableDeclaration* variableDeclaration = isSgVariableDeclaration(get_item_selector());
     if (variableDeclaration != NULL)
        {
       // Check the scopes of the SgInitializedName objects
          SgInitializedNamePtrList & variableList = variableDeclaration->get_variables();
          SgInitializedNamePtrList::iterator i = variableList.begin();
          while ( i != variableList.end() )
             {
               SgInitializedName* variable = *i;
               ROSE_ASSERT(variable != NULL);

               if (variable->get_scope() != this)
                  {
                 // printf ("In SgSwitchStatement::post_construction_initialization() variable = %p not placed into SgSwitchStatement scope = %p (correcting by moving the symbol) \n",variable,this);

                 // Remove the SgVariableSymbol from the switch body and put it into the SgSwitchStatement scope!
                    SgVariableSymbol* variableSymbol = isSgVariableSymbol(variable->get_symbol_from_symbol_table());

                 // The AST copy mechanism can cause this to fail because the scope has not been reset at this point.
                 // ROSE_ASSERT(variableSymbol != NULL);

                    if (variableSymbol != NULL)
                       {
                      // Reset the scope in the variable (only do this if variableSymbol != NULL so that it is not
                      // set prematurely in the AST copy mechanism (else the pointer to the SgVariableDefinition
                      // will not be copied properly).
                         variable->set_scope(this);

                         this->insert_symbol(variable->get_name(),variableSymbol);
                       }
                  }

               i++;
             }

        }
   }

bool
SgSwitchStatement::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {

     if ( StatementReplace(this, p_body, target, newstmt) )
         return true;
     if ( StatementReplace(this, p_item_selector, target, newstmt) )
         return true;
     return false;
   }

#include "sageBuilder.h"

void
SgSwitchStatement::prepend_append_normalization() {
  if(!get_body()) {
    SgBasicBlock* newBlock = new SgBasicBlock ( this->get_file_info() );
    assert(newBlock != NULL);
    set_body(newBlock);
  }
  if (!isSgBasicBlock(get_body())) {
     set_body(SageBuilder::buildBasicBlock(get_body()));
     get_body()->set_parent(this);
  }
}

void
SgSwitchStatement::prepend_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     prepend_append_normalization();
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::prependStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::append_case(SgCaseOptionStmt *& what)
   {
     assert(this != NULL);
     prepend_append_normalization();
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::appendStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::prepend_default(SgDefaultOptionStmt *& what)
   {
     assert(this != NULL);
     prepend_append_normalization();
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::prependStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgSwitchStatement::append_default(SgDefaultOptionStmt *& what)
   {
     assert(this != NULL);
     prepend_append_normalization();
     ROSE_ASSERT (isSgBasicBlock(get_body()));
     SageInterface::appendStatement(what, isSgBasicBlock(get_body()));

  // DQ (6/24/2006): This should be set by the lower level insert_statement member function, verify this!
     ROSE_ASSERT(what->get_parent() != NULL);
   }

// DQ (2/22/2007): Added to provide uniform support of mangle names for all scopes
SgName
SgSwitchStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_SWITCH_STATEMENT_END


SOURCE_CASE_OPTION_STATEMENT_START

void
SgCaseOptionStmt::post_construction_initialization()
   {
  // if (get_key_root() != 0)
  //      get_key_root()->set_statement(this);
   }

bool
SgCaseOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

SOURCE_CASE_OPTION_STATEMENT_END

SOURCE_ASYNC_STATEMENT_START

void
SgAsyncStmt::post_construction_initialization()
   {
   }

SOURCE_ASYNC_STATEMENT_END

SOURCE_FINISH_STATEMENT_START

void
SgFinishStmt::post_construction_initialization()
   {
   }

SOURCE_FINISH_STATEMENT_END


SOURCE_AT_STATEMENT_START

void
SgAtStmt::post_construction_initialization()
       {
       }

SOURCE_AT_STATEMENT_END


SOURCE_ATOMIC_STATEMENT_START

void
SgAtomicStmt::post_construction_initialization()
   {
   }

SOURCE_ATOMIC_STATEMENT_END


SOURCE_WHEN_STATEMENT_START

void
SgWhenStmt::post_construction_initialization()
       {
       }

SOURCE_WHEN_STATEMENT_END


SOURCE_TRY_STATEMENT_START

void
SgTryStmt::post_construction_initialization()
   {
  // MS: C++98: compound-statement (SgBasicBlock in SAGE)
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_body())
          get_body()->set_parent(this);
#endif

     // MS: moved catch_statement_seq to CatchStatementSeq, therefore we need to init it here now
     if (get_catch_statement_seq_root() == NULL)
        {
          Sg_File_Info* fileInfo = NULL;
          if (this->get_file_info() != NULL)
             {
            // Get a copy of this to avoid sharing!
               fileInfo = new Sg_File_Info( *(this->get_file_info()) );
             }
       // assert (fileInfo != NULL);
          SgCatchStatementSeq* catchStatement = NULL;
          if (fileInfo != NULL)
             {
            // DQ (10/16/2007): This appears to be set to the wrong parent.
            // DQ (12/18/2006): Added to set all parents of Sg_File_Info objects.
               fileInfo->set_parent(this);

            // DQ (10/31/2006): Set the end of source for the SgCatchStatementSeq
            // set_catch_statement_seq_root( new SgCatchStatementSeq(fileInfo));
               catchStatement = new SgCatchStatementSeq(fileInfo);

            // DQ (10/16/2007): Set the parent of the fileInfo used for the SgCatchStatementSeq to the catchStatement
               fileInfo->set_parent(catchStatement);

               catchStatement->set_endOfConstruct(New_File_Info(catchStatement));

            // DQ (10/16/2007): Set the parent
               catchStatement->get_endOfConstruct()->set_parent(catchStatement);
             }
            else
             {
               catchStatement = new SgCatchStatementSeq();
             }

          set_catch_statement_seq_root( catchStatement );
          // Liao, 10/29/2009, missing parent pointer
          catchStatement->set_parent(this);
        }
   }

bool
SgTryStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_body, target, newstmt) == true )
          return true;
       else
          return ( StatementReplace( this, p_catch_statement_seq_root, target, newstmt) == true );
   }


// MS: C++98: handler_seq (catch_statement_seq in SAGE)
SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler_seq (catch_statement_seq in SAGE)
const SgStatementPtrList &
SgTryStmt::get_catch_statement_seq() const {
     return get_catch_statement_seq_root()->get_catch_statement_seq();
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::append_catch_statement(SgStatement * what)
   {
  // DQ (6/4/2008): The SgCatchOptionStmt should have a parent pointing to
  // the SgCatchStatementSeq in order for the Virtual CFG to work properly.

  // get_catch_statement_seq_root()->append_catch_statement(what);
  // what->set_parent(this);
  // get_catch_statement_seq_root()->append_catch_statement(what);
     SgCatchStatementSeq* catchStatementList = get_catch_statement_seq_root();
     ROSE_ASSERT(catchStatementList != NULL);
     catchStatementList->append_catch_statement(what);
     what->set_parent(catchStatementList);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::prepend_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq_root()->prepend_catch_statement(what);
     what->set_parent(this);
   }


#if 0
// MS: C++98: handler (catch_statement in SAGE)
void
SgTryStmt::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq_root()->insert_catch_statement(where,what);
   }
#endif

SOURCE_TRY_STATEMENT_END

SOURCE_CATCH_STATEMENT_SEQ_START

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::post_construction_initialization() {
  SgStatementPtrList::iterator p = get_catch_statement_seq().begin();
  for (p = get_catch_statement_seq().begin(); p != get_catch_statement_seq().end(); p++)
    {
      ROSE_ASSERT((*p) != NULL);
      delete (*p);
      (*p) = NULL;
    }
}

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::append_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq().push_back(what);
     what->set_parent(this);
   }

// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::prepend_catch_statement(SgStatement * what)
   {
     get_catch_statement_seq().insert(get_catch_statement_seq().begin(), what);
     what->set_parent(this);
   }

#if 0
// MS: C++98: handler (catch_statement in SAGE)
void
SgCatchStatementSeq::insert_catch_statement(const SgStatementPtrList::iterator& where, SgStatement * what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_catch_statement_seq().insert(where,what);
   }
#endif

SOURCE_CATCH_STATEMENT_SEQ_END



SOURCE_CATCH_OPTION_STATEMENT_START

void
SgCatchOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_condition()) get_condition()->set_parent(this);
     if(get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgCatchOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     if ( StatementReplace(this, p_condition, target, newstmt) == true )
         return true;
     else if ( StatementReplace(this, p_body, target, newstmt) == true )
         return true;
     else
         return false;
   }

#if 0
SgStatement*
SgCatchOptionStmt::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          if(get_condition())
               return get_condition();
            else
             {
               n++;
               return get_body();
             }
        }
       else
          if(n==1)
             {
               n++;
               get_body();
             }
     return 0;
   }
#endif

SgName
SgCatchOptionStmt::get_mangled_name(void) const
   {
  // DQ (2/22/2007): This function is added to prevent "::" substrings in mangled names of other declarations.
     return SgName("");
   }

SOURCE_CATCH_OPTION_STATEMENT_END


SOURCE_DEFAULT_OPTION_STATEMENT_START

void
SgDefaultOptionStmt::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if (get_body()) get_body()->set_parent(this);
#endif
   }

// SgStatement* get_next(int&) const;

bool
SgDefaultOptionStmt::replace_child(SgStatement *target,SgStatement *newstmt,
                              bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }

#if 0
SgStatement*
SgDefaultOptionStmt::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_body();
        }
   }
#endif

SOURCE_DEFAULT_OPTION_STATEMENT_END


SOURCE_BREAK_STATEMENT_START
void
SgBreakStmt::post_construction_initialization()
   {
   }

SOURCE_BREAK_STATEMENT_END


SOURCE_CONTINUE_STATEMENT_START

void
SgContinueStmt::post_construction_initialization()
   {
   }

SOURCE_CONTINUE_STATEMENT_END

SOURCE_FORTRAN_CONTINUE_STATEMENT_START

void
SgFortranContinueStmt::post_construction_initialization()
   {
   }

SOURCE_FORTRAN_CONTINUE_STATEMENT_END

SOURCE_RETURN_STATEMENT_START

void
SgReturnStmt::post_construction_initialization()
   {
  // DQ (11/7/2006): removed use of expression root
  // if (get_expression_root() != 0)
  //    get_expression_root()->set_statement(this);
   }

// DQ (12/15/2006): We need this sort of function now that we have removed the expression root node!
// The requirement of not being able to do operations uniformly on expressions may be the disadvantage
// of not having used the SgExpressionRoot IR node as a concept.
int
SgReturnStmt::replace_expression(SgExpression * original_expression, SgExpression * new_expression )
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(original_expression != NULL);
     ROSE_ASSERT(new_expression != NULL);

     ROSE_ASSERT(original_expression == p_expression);

     set_expression(new_expression);

     new_expression->set_parent(this);

  // DQ: Let this be a memory leak for now to avoid initial problems.
     ROSE_ASSERT(original_expression != NULL);
  // delete original_expression;

     return 0;
   }

SOURCE_RETURN_STATEMENT_END


SOURCE_GOTO_STATEMENT_START

void
SgGotoStatement::post_construction_initialization()
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     if(get_label())
        {
          get_label()->set_parent(this);
        }
#endif
   }

bool
SgGotoStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_label, target, newstmt) == true );
   }

SOURCE_GOTO_STATEMENT_END

SOURCE_ADA_EXIT_STATEMENT_START

void
SgAdaExitStmt::post_construction_initialization()
   {
     ROSE_ASSERT(get_loop() && get_condition());
#ifndef REMOVE_SET_PARENT_FUNCTION
      get_loop()->set_parent(this);
      get_condition()->set_parent(this);
#endif
   }

bool
SgAdaExitStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool /*extractBasicBlock*/)
{
  return StatementReplace(this, p_loop, target, newstmt);
}

int
SgAdaExitStmt::replace_expression(SgExpression* original_expression, SgExpression* new_expression)
{
  ROSE_ASSERT(original_expression && new_expression);
  ROSE_ASSERT(original_expression == get_condition());

  set_condition(new_expression);

  new_expression->set_parent(this);

  // Let this leak for now
  // delete original_expression;
  return 0;
}


SOURCE_ADA_EXIT_STATEMENT_END

SOURCE_ADA_DELAY_STATEMENT_START

void
SgAdaDelayStmt::post_construction_initialization()
   {
     ROSE_ASSERT(get_time());
#ifndef REMOVE_SET_PARENT_FUNCTION
      get_time()->set_parent(this);
#endif
   }

int
SgAdaDelayStmt::replace_expression(SgExpression* original_expression, SgExpression* new_expression)
{
  ROSE_ASSERT(original_expression && new_expression);
  ROSE_ASSERT(original_expression == get_time());

  set_time(new_expression);

  new_expression->set_parent(this);

  // Let this leak for now
  // delete original_expression;
  return 0;
}


SOURCE_ADA_DELAY_STATEMENT_END

SOURCE_ADA_ACCEPT_STATEMENT_START

void
SgAdaAcceptStmt::post_construction_initialization()
{}

bool
SgAdaAcceptStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool /*extractBasicBlock*/)
{
  ROSE_ASSERT(target && newstmt);
  ROSE_ASSERT(target == p_body);

  return StatementReplace(this, p_body, target, newstmt);
}

int
SgAdaAcceptStmt::replace_expression(SgExpression* original_expression, SgExpression* new_expression)
{
  ROSE_ASSERT(original_expression && new_expression);
  ROSE_ASSERT(original_expression == get_index());

  set_index(new_expression);
  new_expression->set_parent(this);

  // Let this leak for now
  // delete original_expression;
  return 0;
}

SOURCE_ADA_ACCEPT_STATEMENT_END

SOURCE_ADA_LOOP_STATEMENT_START

void
SgAdaLoopStmt::post_construction_initialization()
   {
   }

bool
SgAdaLoopStmt::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return StatementReplace(this, p_body, target, newstmt);
   }


SOURCE_ADA_LOOP_STATEMENT_END

SOURCE_PYTHON_PRINT_STMT_START

void
SgPythonPrintStmt::post_construction_initialization() {
    if (get_destination() != NULL)
        get_destination()->set_parent(this);
    if (get_values() != NULL)
        get_values()->set_parent(this);
}

SOURCE_PYTHON_PRINT_STMT_END

SOURCE_PYTHON_GLOBAL_STMT_START

void
SgPythonGlobalStmt::post_construction_initialization() {}

void
SgPythonGlobalStmt::append_name(SgInitializedName* name) {
    ROSE_ASSERT(name);
    name->set_parent(this);
    get_names().push_back(name);
}

void
SgPythonGlobalStmt::prepend_name(SgInitializedName* name) {
    ROSE_ASSERT(name);
    name->set_parent(this);
    get_names().insert(get_names().begin(), name);
}

SOURCE_PYTHON_GLOBAL_STMT_END

SOURCE_ASM_STATEMENT_START

void
SgAsmStmt::post_construction_initialization()
   {}

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgAsmStmt::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // This is a poor way to handle the generation of unique strings (it also
  // connects the unparser to the fronend handling which is not a great idea).
  // returnName = get_expr_root()->unparseToString();

  // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
     SgExpressionPtrList::const_iterator i = p_operands.begin();
     while (i != p_operands.end())
        {
          returnName += (*i)->get_type()->get_mangled();
          i++;
        }

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgAsmStmt* declaration = const_cast<SgAsmStmt*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgAsmStmt*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName;

       // This is a poor way to handle the generation of unique strings (it also
       // connects the unparser to the frontend handling which is not a great idea).
       // returnName = get_expr_root()->unparseToString();

       // DQ (7/22/2006): This IR node has been changed to have a list of SgAsmOp IR nodes
          SgExpressionPtrList::const_iterator i = p_operands.begin();
          while (i != p_operands.end())
             {
               mangledName += (*i)->get_type()->get_mangled();
               i++;
             }
#if 0
          printf ("In SgAsmStmt::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgAsmStmt*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (7/22/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgExpressionPtrList &
SgAsmStmt::get_operands()
   { return p_operands; }

const SgExpressionPtrList &
SgAsmStmt::get_operands() const
   { return p_operands; }

// DQ (7/27/2006): We need these to be explicit since we can't support reference parameter passing within ROSETTA.
SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList()
   { return p_clobberRegisterList; }

const SgAsmStmt::AsmRegisterNameList &
SgAsmStmt::get_clobberRegisterList() const
   { return p_clobberRegisterList; }

SOURCE_ASM_STATEMENT_END


SOURCE_SPAWN_STATEMENT_START

void
SgSpawnStmt::post_construction_initialization()
   {}

SOURCE_SPAWN_STATEMENT_END


SOURCE_JAVA_THROW_STATEMENT_START

void
SgJavaThrowStatement::post_construction_initialization()
   {}

SOURCE_JAVA_THROW_STATEMENT_END


SOURCE_JAVA_FOREACH_STATEMENT_START

void
SgJavaForEachStatement::post_construction_initialization()
   {}

// charles4 (9/07/2011): Added to provide uniform support of mangle names for all scopes
SgName
SgJavaForEachStatement::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_JAVA_FOREACH_STATEMENT_END

SOURCE_JAVA_SYNCHRONIZED_STATEMENT_START

void
SgJavaSynchronizedStatement::post_construction_initialization()
   {}

SOURCE_JAVA_SYNCHRONIZED_STATEMENT_END



SOURCE_NULL_STATEMENT_START

void
SgNullStatement::post_construction_initialization()
   {}

SOURCE_NULL_STATEMENT_END

SOURCE_PASS_STATEMENT_START

void
SgPassStatement::post_construction_initialization()
   {}

SOURCE_PASS_STATEMENT_END

SOURCE_ASSERT_STMT_START

void
SgAssertStmt::post_construction_initialization()
   {}

SOURCE_ASSERT_STMT_END

SOURCE_EXEC_STATEMENT_START
SOURCE_EXEC_STATEMENT_END

SOURCE_VARIANT_STATEMENT_START

void
SgVariantStatement::post_construction_initialization()
   {}

SOURCE_VARIANT_STATEMENT_END


SOURCE_TYPEDEF_DECLARATION_STATEMENT_START

void
SgTypedefDeclaration::post_construction_initialization()
   {
  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if 0
#if PRINT_DEVELOPER_WARNINGS
     printf ("In $CLASSNAME::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
#endif

#if 0
  // DQ (3/20/2012): We would like to assert this, but I don't think it is always possible. For example, test2001_19.C fails for this test.
  // ROSE_ASSERT(this->get_parent_scope() != NULL);
     if (this->get_parent_scope() == NULL)
        {
          printf ("WARNING: In SgTypedefDeclaration::post_construction_initialization(): this->get_parent_scope() == NULL \n");
        }
#endif

#if 0
     printf ("In SgTypedefDeclaration::post_construction_initialization(): NO LONGER calling SgTypedefType::createType() using this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (2/27/2018): It is an inconsistancy for the type to be set here.
  // set_type(SgTypedefType::createType(this));

#if 0
  // printf ("In SgTypedefDeclaration::post_construction_initialization(): DONE calling SgTypedefType::createType() using this = %p = %s \n",this,this->class_name().c_str());
#endif

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);

  // DQ (2/27/2018): Since we don't build the typedef type here, we have to modify this assertion.
  // ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() >= 0);
   }

// SgStatement *get_next(int&) const;

bool
SgTypedefDeclaration::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_declaration, target, newstmt) == true );
   }

#if 0
SgStatement*
SgTypedefDeclaration::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_declaration();
        }
   }
#endif

SgName
SgTypedefDeclaration::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

SgName
SgTypedefDeclaration::get_qualified_name_prefix_for_base_type() const
   {
  // DQ (2/14/2019): this feature to support name qualification on typedef base type
  // declarations appears to not be used, though the design for it is in place.

  // DQ (5/29/2011): Added to support for new qualified name generation.
  // this function has a different name from the base class since it requires
  // a different definition to support using the SgNode::get_globalQualifiedNameMapForTypes()
  // function instead of the SgNode::get_globalQualifiedNameMapForNames() function.
  // This function generates the qualified name prefix to be used with
  // the base type of the typedef declaration.

  // DQ (5/28/2011): We have to handle the name qualification directly since types can be qualified
  // different and so it depends upon where the type is referenced.  Thus the qualified name is
  // stored in a map to the IR node that references the type.
     SgName nameQualifier;
     std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTypedefDeclaration*>(this));
  // ROSE_ASSERT(i != SgNode::get_globalQualifiedNameMapForNames().end());

#if 0
     printf ("In SgTypedefDeclaration::get_qualified_name_prefix_for_base_type(): SgNode::get_globalQualifiedNameMapForTypes().size() = %zu \n",SgNode::get_globalQualifiedNameMapForTypes().size());
#endif

     if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
        {
          nameQualifier = i->second;
#if 0
          printf ("FOUND a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
        }
       else
        {
#if 0
          printf ("COULD NOT find a valid name qualification \n");
#endif
        }

#if 0
     printf ("nameQualifier for SgFunctionDeclaration = %s = %s \n",class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }

#define DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME 0

// RV (1/30/2006): Revised to follow typedef chains to their base types.
SgName SgTypedefDeclaration::get_mangled_name (void) const {
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTypedefDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
          std::cerr << "In SgTypedefDeclaration::get_mangled_name(): (from cache) " << mangledNameString
                    << "  " << this
                    << std::endl;
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */
          return mangledNameString;
        }
       else
        {
          SgName mangledName;
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
          printf ("In SgTypedefDeclaration::get_mangled_name(): before calling get_base_type() \n");
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */
          SgType* baseType = get_base_type();
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
       // DQ (5/23/2018): Added assertion prior to the debug statement below.
          ROSE_ASSERT(baseType != NULL);
          printf ("In SgTypedefDeclaration::get_mangled_name(): after calling get_base_type(): baseType = %p = %s \n",baseType,baseType->class_name().c_str());
          if (get_file_info() != NULL)
             {
               printf ("   --- typedef source position: line = %d \n",get_file_info()->get_line());
             }
            else
             {
               printf ("   --- typedef source position: line = (unknown) \n");
             }
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */

       // DQ (6/3/2006): I think this is a better implementation of name mangling for a typedef
       // (need to include the name and the type) but I'm not clear if we want the scope.
          ROSE_ASSERT(baseType != NULL);

       // DQ (3/14/2012): We want to have a valid scope so that we can build a properly
       // mangled name but the scope is not yet available unless we modify the constructor
       // (which would break some code).  So allow this to be built for now and we will
       // see if it is an issue.  Make it a warning to not have a valid scope. Note
       // that this is only an issue for C++.  We also might not want to add the name
       // to the cache if the scope was NULL.
       // mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name()) + baseType->get_mangled();

          string mangleQualifiersString;
       // mangleQualifiersString = mangleQualifiers(get_scope());

          SgScopeStatement* scope = get_scope();
          if (scope == NULL)
             {
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
               printf ("ERROR: SgTypedefDeclaration::get_mangled_name(): get_scope() == NULL, mangleQualifiers would be invalid\n");
               printf ("  -- this = %p (%s) = %s\n", this, this->class_name().c_str(), this->get_name().getString().c_str());
               SgNode * parent = get_parent();
               printf ("  -- parent = %p (%s)\n", parent, parent ? parent->class_name().c_str() : "");
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */
            // DQ (3/20/2012): Added for debugging.
            // ROSE_ASSERT(false);
             }
            else
             {
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
               printf ("In SgTypedefDeclaration::get_mangled_name(): scope = %p = %s (calling mangleQualifiers()) \n",scope,scope->class_name().c_str());
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */
               mangleQualifiersString = mangleQualifiers(scope);
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
               printf ("DONE: In SgTypedefDeclaration::get_mangled_name(): mangleQualifiersString = %s scope = %p = %s (calling mangleQualifiers()) \n",mangleQualifiersString.c_str(),scope,scope->class_name().c_str());
#endif /* DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME */
             }

       // DQ (9/6/2016): We require a prefix to the name to avoid name collisions (see test2005_199.C and simplified test (but non-failing) in test2016_60.C).
       // mangledName = joinMangledQualifiers (mangleQualifiersString,get_name()) + baseType->get_mangled();
          SgName prefixed_name = "typedef_" + get_name();

#if 0 /* 0_1 */
          printf ("In SgTypedefDeclaration::get_mangled_name(): prefixed_name = %s \n",prefixed_name.str());
#endif /* 0_1 */
#define ADD_MANGLED_NAME_OF_BASE_TYPE 0
#if ADD_MANGLED_NAME_OF_BASE_TYPE
       // DQ (6/30/2018): I think the call to the baseType->get_mangled() is the cause of the infinite loop in test2018_118.C.
       // mangledName = joinMangledQualifiers(mangleQualifiersString,prefixed_name) + baseType->get_mangled();
       // SgName baseTypeMangleName = baseType->get_mangled();

          static std::set<SgType*> baseTypeSet;

          SgName baseTypeMangleName;
          if (baseTypeSet.find(baseType) == baseTypeSet.end())
             {
               baseTypeSet.insert(baseType);
               baseTypeMangleName = baseType->get_mangled();
             }
            else
             {
            // Avoid infinite recursion in computation of mangled names.
               baseTypeMangleName = "_previously_seen_baseType_" + Rose::StringUtility::numberToString(baseType);
             }

#if 0
          static int base_type_counter = 0;
          printf ("In SgTypedefDeclaration::get_mangled_name(): calling baseType->get_mangled(): base_type_counter = %d baseType = %p = %s \n",base_type_counter++,baseType,baseType->class_name().c_str());
#endif

#if 0
          printf ("DONE: In SgTypedefDeclaration::get_mangled_name(): calling baseType->get_mangled(): baseType = %p = %s \n",baseType,baseType->class_name().c_str());
#endif
#if 0
          printf ("In SgTypedefDeclaration::get_mangled_name(): baseTypeMangleName = %s \n",baseTypeMangleName.str());
#endif
          mangledName = joinMangledQualifiers(mangleQualifiersString,prefixed_name) + baseTypeMangleName;
#else /* ADD_MANGLED_NAME_OF_BASE_TYPE */
          mangledName = joinMangledQualifiers(mangleQualifiersString,prefixed_name);
#endif /* ADD_MANGLED_NAME_OF_BASE_TYPE */
       // DQ (1/29/2007): We need to make this more specific to this IR nodes so that a typedef of an unnamed struct does not be mangled to be the same name
          mangledName += "__typedef_declaration";
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
          printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
          ROSE_ASSERT (mangledName.get_length() > 0);
#if 0
          printf ("In SgTypedefDeclaration::get_mangled_name(): calling SageInterface::addMangledNameToCache(): mangledName = %s \n",mangledName.str());
#endif

       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTypedefDeclaration*>(this),mangledName);
#if DEBUG_TYPEDEF_DECLARATION_GET_MANGLED_NAME
          printf ("In SgTypedefDeclaration::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
          return mangledName;
        }
   }

bool
SgTypedefDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTypedefDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);

#if 0
     printf ("In SgTypedefDeclaration::get_symbol_from_symbol_table(): calling get_scope()->find_symbol_from_declaration(this) \n");
#endif

  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

// GB (09/25/2007): Added this function as part of the traversal island fix. It returns the p_declaration data member,
// but only if this typedef statement is actually the place where the base type is defined.
SgDeclarationStatement *
SgTypedefDeclaration::compute_baseTypeDefiningDeclaration() const
   {
     if (p_typedefBaseTypeContainsDefiningDeclaration == true)
        {
          return p_declaration;
        }
       else
        {
          return NULL;
        }
   }

SgDeclarationStatement *
SgTypedefDeclaration::get_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2007): This provides an public (compute_baseTypeDefiningDeclaration() is private)
  // interface similar to that for SgVariableDeclaration and for the same purpose (types defined
  // in the typedef or variable declaration).

     return compute_baseTypeDefiningDeclaration();
   }

bool
SgTypedefDeclaration::get_requiresGlobalNameQualificationOnType () const
   {
     ROSE_ASSERT (this != NULL);
     return p_requiresGlobalNameQualificationOnType;
   }

void
SgTypedefDeclaration::set_requiresGlobalNameQualificationOnType ( bool requiresGlobalNameQualificationOnType )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_requiresGlobalNameQualificationOnType = requiresGlobalNameQualificationOnType;
   }

int
SgTypedefDeclaration::get_name_qualification_length_for_base_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length_for_base_type;
   }

void
SgTypedefDeclaration::set_name_qualification_length_for_base_type ( int name_qualification_length_for_base_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length_for_base_type = name_qualification_length_for_base_type;
   }

bool
SgTypedefDeclaration::get_type_elaboration_required_for_base_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required_for_base_type;
   }

void
SgTypedefDeclaration::set_type_elaboration_required_for_base_type ( bool type_elaboration_required_for_base_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required_for_base_type = type_elaboration_required_for_base_type;
   }

bool
SgTypedefDeclaration::get_global_qualification_required_for_base_type () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required_for_base_type;
   }

void
SgTypedefDeclaration::set_global_qualification_required_for_base_type ( bool global_qualification_required_for_base_type )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required_for_base_type = global_qualification_required_for_base_type;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
int
SgTypedefDeclaration::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
void
SgTypedefDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTypedefDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
void
SgTypedefDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
bool
SgTypedefDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

// DQ (4/10/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
void
SgTypedefDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_DECLARATION_STATEMENT_START
void
SgTemplateDeclaration::post_construction_initialization()
   {
  // Nothing to do here.
   }

// DQ (9/8/2004): added support for qualified names
SgName
SgTemplateDeclaration::get_qualified_name() const
   {
  // DQ (8/28/2005): Modified to make this function consistent other get_qualified_name functions
  // It previously only returned the name of the scope.
#if 0
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;
     string returnNameString;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (9/8/2004): Don't use the template name as is stored (which is a mangled name from EDG)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = scope->get_qualified_name();
  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#else
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
#endif
   }

bool
SgTemplateDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateDeclaration::get_mangled_name(void) const
   {
#if 0
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = get_qualified_name() + SgName("_template_declaration_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_template_declaration_") + get_name();

     return returnName;
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgTemplateDeclaration* declaration = const_cast<SgTemplateDeclaration*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
#if 0
          printf ("In SgTemplateDeclaration::get_mangled_name(): (FOUND in MangledNameFromCache): returning mangledNameString = %s \n",mangledNameString.c_str());
#endif
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
       // SgName mangledName = get_scope()->get_mangled_name() + SgName("_template_declaration_") + get_name();
          SgScopeStatement* scope = get_scope();
          ROSE_ASSERT(scope != NULL);
          SgName mangledName = scope->get_mangled_name() + SgName("_template_declaration_") + get_name();
#if 0
          printf ("In SgTemplateDeclaration::get_mangled_name(): (NOT found in MangledNameFromCache): returning mangledName = %s \n",mangledName.str());
#endif
       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateDeclaration*>(this),mangledName);
          return mangledName;
        }
#endif
   }

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgTemplateDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }


SgType*
SgTemplateDeclaration::get_type()
   {
  // DQ (12/12/2011): Added function to support "get_type()" on the derived IR nodes.  Maybe
  // this should be a virtual function, but no, because the return types at the derived classes
  // are different and some compilers (MS Visual Studio) do not support covariant return types.

     SgType* returnType = NULL;

#if 0
     switch (variantT())
        {
          case V_SgTemplateClassDeclaration:
             {
               SgTemplateClassDeclaration* decl = isSgTemplateClassDeclaration(this);
               returnType = decl->get_type();
               break;
             }

          case V_SgTemplateFunctionDeclaration:
             {
               SgTemplateFunctionDeclaration* decl = isSgTemplateFunctionDeclaration(this);
               returnType = decl->get_type();
               break;
             }

          case V_SgTemplateMemberFunctionDeclaration:
             {
               SgTemplateMemberFunctionDeclaration* decl = isSgTemplateMemberFunctionDeclaration(this);
               returnType = decl->get_type();
               break;
             }

          case V_SgTemplateVariableDeclaration:
             {
               SgTemplateVariableDeclaration* decl = isSgTemplateVariableDeclaration(this);
               returnType = decl->get_type();
               break;
             }

          default:
             {
               printf ("Default reached in SgTemplateDeclaration::get_type() variant = %d \n",variantT());
               ROSE_ASSERT(false);
             }
        }
#else
     printf ("This is a part of the new design for ROSE to have the SgTemplateClassDeclaration derived from the SgClassDeclaration (same for functions, member functions, and varaiable declarations). \n");
     ROSE_ASSERT(false);
#endif

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_TEMPLATE_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_CLASS_DECLARATION_STATEMENT_START
void
SgTemplateClassDeclaration::post_construction_initialization()
   {
  // DQ (12/21/2011): This is not what we want for the newer design with SgTemplateVariableDeclaration derived from SgVariableDeclaration.
  // this->set_template_kind(e_template_class);

#if 0
  // DQ (3/4/2018): relax this requirement for SgTemplateInstantiationClassDeclaration.
  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
     if (p_type != NULL)
        {
          printf ("Note: SgTemplateClassDeclaration::post_construction_initialization(): p_type != NULL: name = %s \n",p_name.str());
        }
  // ROSE_ASSERT(p_type == NULL);
#endif
   }

// DQ (9/10/2012): Added general name mangling for new template class declaration IR node.
SgName
SgTemplateClassDeclaration::get_mangled_name(void) const
   {
     string mangled_name;

  // DQ (2/13/2015): Fixing bug specific to adding mangle name of the scope of the template class to avoid collisions with other types
  // with the same name in different scopes when used as in function types.  The bud demonstrating this problem is in test2015_09.C and
  // test2015_10.C.  This problem was caught in the range.h header file for the GNU g++ version 4.8.1 header file system.  This was
  // an issue to the processing of the newest version of the LBL DSL specification.
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgTemplateClassDeclaration*>(this));
     if (mangledNameString.empty() == false)
        {
#if 0
          printf ("In SgTemplateClassDeclaration::get_mangled_name(): (FOUND in cache) mangledNameString = %s \n",mangledNameString.c_str());
#endif
          return mangledNameString;
        }
       else
        {
       // DQ (3/14/2012): Make sure that this is a valid pointer else it might explain why qualification is not being use to generate the mangled names.
          ROSE_ASSERT(get_scope() != NULL);
#if 0
          printf ("In SgTemplateClassDeclaration::get_mangled_name(): calling joinMangledQualifiers(mangleQualifiers(get_scope()),get_name()) --- get_name() = %s \n",get_name().str());
#endif
       // DQ (3/14/2012): Seperating the steps to computing the mangled name (which should include some qualification via non empty mangledScopeName)
       // SgName mangledName = joinMangledQualifiers(mangleQualifiers(get_scope()),get_name());
          SgName mangledScopeName = mangleQualifiers(get_scope());
#if 0
          printf ("In SgTemplateClassDeclaration::get_mangled_name(): mangleQualifiers(get_scope()) mangledScopeName = %s \n",mangledScopeName.str());
#endif
       // DQ (3/14/2012): I think that we can assert this.  No, if the scope is SgGlobal (for example) then the mangledName is empty.
       // ROSE_ASSERT(mangledScopeName.is_null() == false);

       // DQ (2/13/2015): Changed this to use the templateName which excludes the template arguments, I think this is enough to be unique.
       // SgName mangledName = joinMangledQualifiers(mangledScopeName,get_name());
          SgName mangledName = joinMangledQualifiers(mangledScopeName,get_templateName());
#if 0
          printf ("In SgTemplateClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s \n",mangledName.str());
#endif
          if (mangledName.is_null() == true)
             {
#if 0
               printf ("In SgTemplateClassDeclaration::get_mangled_name(): (NOT found in cache) mangledName = %s get_name() = %s \n",mangledName.str(),get_name().str());
#endif
               mangledName = "unknown_scope_and_name";
             }
          ROSE_ASSERT(mangledName.is_null() == false);

          // TODO add mangled template specialization arguments
          mangledName = mangleTemplate(mangledName,get_templateSpecializationArguments(),get_scope());

       // p_globalMangledNameMap[classDeclaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgTemplateClassDeclaration*>(this),mangledName);
#if 0
          printf ("In SgTemplateClassDeclaration::get_mangled_name(): (AFTER adding to cache) mangledName = %s \n",mangledName.str());
#endif
       // DQ (5/31/2012): Added test for template brackets that are caught later in AstConsistencyTests.
       // Make sure that there is no template specific syntax included in the mangled name
       // string mangled_name = mangledName;
          mangled_name = mangledName;
          if ( mangled_name.find('<') != string::npos )
             {
               printf ("In SgTemplateClassDeclaration::get_mangled_name(): this = %p = %s check mangled class name = %s \n",this,this->class_name().c_str(),mangled_name.c_str());
             }
          ROSE_ASSERT(mangled_name.find('<') == string::npos);
        }
#if 0
  // DQ (7/24/2012): Output the mangled name being generated for debugging.
     printf (">>>>>>>>>> SgTemplateClassDeclaration::get_mangled_name(): returning mangled_name = %s \n",mangled_name.c_str());
#endif

     return mangled_name;
   }

SOURCE_TEMPLATE_CLASS_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateFunctionDeclaration::post_construction_initialization()
   {
  // DQ (12/21/2011): This is not what we want for the newer design with SgTemplateVariableDeclaration derived from SgVariableDeclaration.
  // this->set_template_kind(e_template_function);

#if 0
  // DQ (12/28/2011): This will overwrite the existing SgFunctionParameterList the base class.
  // This code could be factored (copied from SgFunctionDeclaration::post_construction_initialization()).
     SgFunctionParameterList* args = NULL;
     if (get_startOfConstruct() != NULL)
        {
          args = new SgFunctionParameterList(New_File_Info(this));
          args->get_startOfConstruct()->set_parent(args);
        }
       else
        {
       // DQ (11/12/2006): Use the new constructor.
          args = new SgFunctionParameterList();
        }

     ROSE_ASSERT (args != NULL);
     set_parameterList(args);

  // DQ (7/19/2005): set the parent explicitly
     get_parameterList()->set_parent(this);

  // DQ (3/6/2007): Set the firstNondefiningDeclaration of args to itself (this is now required
  // for the AST consistency tests after the AST merge).  Likely because one where a member function
  // is referenced before being declared in a class the member function was not previously visited by
  // the AST traversal and so one of its defining or non-defining declarations was not set and after
  // the merge this declaration is used (shared) and thus accessed where before it had been hidden.
  // DQ (3/15/2006): Let this be NULL so that it will be fixed by the fixupDeclarations function
  // within the post processing phase.
  // DQ (9/6/2005): Since a SgFunctionParameterList is a SgDeclarationStatement we should set
  // either its defining or non-defining declaration (I choose the non-defining declaration).
  // args->set_definingDeclaration(args);
  // args->set_firstNondefiningDeclaration(args);
     args->set_firstNondefiningDeclaration(args);
#else
     ROSE_ASSERT (get_parameterList() != NULL);

  // DQ (12/28/2011): set the parent explicitly
     get_parameterList()->set_parent(this);
#endif


#if 0
  // This is already set in the constructor.

  // DQ (10/25/2004): Add a ending file info object for completeness (though this is not yet
  // initialized to the correct position, yet).  Initially let's get them in place then we can
  // work on the accuracy afterward!
  // Sg_File_Info* endingPosition = new Sg_File_Info(*thisFileInfo);
  // ROSE_ASSERT (endingPosition != NULL);
  // p_args->set_endOfConstruct(endingPosition);

  // DQ (7/31/2006): Explicit initialization of this data member is required!
  // JJW (8/6/2008): It probably isn't now that p_exceptionSpecification is a vector
     p_exceptionSpecification.clear();

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length     = 0;
     p_type_elaboration_required     = false;
     p_global_qualification_required = false;

  // DQ (5/14/2011): Added to support name qualification on types referenced by template arguments.
     p_name_qualification_length_for_return_type     = 0;
     p_type_elaboration_required_for_return_type     = false;
     p_global_qualification_required_for_return_type = false;
#endif

#if 0
  // DQ (3/4/2018): relax this requirement for SgTemplateInstantiationClassDeclaration.
  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
     if (p_type != NULL)
        {
          printf ("Note: SgTemplateFunctionDeclaration::post_construction_initialization(): p_type != NULL: name = %s \n",p_name.str());
        }
  // ROSE_ASSERT(p_type == NULL);
#endif
   }

SOURCE_TEMPLATE_FUNCTION_DECLARATION_STATEMENT_END

SOURCE_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT_START
void
SgTemplateMemberFunctionDeclaration::post_construction_initialization()
   {
  // DQ (12/21/2011): This is not what we want for the newer design with SgTemplateVariableDeclaration derived from SgVariableDeclaration.
  // this->set_template_kind(e_template_m_function);

#if 0
  // DQ (12/28/2011): This will overwrite the existing SgCtorInitializerList in the base class.
  // DQ (11/25/2011): This is copied from the SgMemberFunctionDeclaration (the semantics must match).
  // There is however an opportunity to refactor some of this code (even though it is a small amount of code).
     if (get_startOfConstruct() != NULL)
        {
          p_CtorInitializerList = new SgCtorInitializerList(New_File_Info(this));
        }
       else
        {
          p_CtorInitializerList = new SgCtorInitializerList();
        }

     ROSE_ASSERT(p_CtorInitializerList != NULL);
     p_CtorInitializerList->set_firstNondefiningDeclaration(p_CtorInitializerList);
#else
     ROSE_ASSERT(p_CtorInitializerList != NULL);
#endif

     p_CtorInitializerList->set_parent(this);

#if 0
  // DQ (3/4/2018): relax this requirement for SgTemplateInstantiationClassDeclaration.
  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
     if (p_type != NULL)
        {
          printf ("Note: SgTemplateMemberFunctionDeclaration::post_construction_initialization(): p_type != NULL: name = %s \n",p_name.str());
        }
  // ROSE_ASSERT(p_type == NULL);
#endif
   }

SOURCE_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_VARIABLE_DECLARATION_STATEMENT_START

void
SgTemplateVariableDeclaration::post_construction_initialization()
   {
  // DQ (12/21/2011): This is not what we want for the newer design with SgTemplateVariableDeclaration derived from SgVariableDeclaration.
  // this->set_template_kind(e_template_m_data);
   }


SgTemplateVariableDeclaration::SgTemplateVariableDeclaration( const SgName& var_name, SgType *type, SgInitializer *initializer)
   : SgVariableDeclaration(var_name,type,initializer), p_nonreal_decl_scope(NULL)
   {
  // DQ (11/10/2006): Ultimately, i think this constructor should be eliminated since it will be
  // redundant with a higher level interface which is planned and it is not automatically generated.
     ROSE_ASSERT (this != NULL);

  // printf ("Inside of SgTemplateVariableDeclaration constructor taking all parameters \n");
  // initializeData (NULL,var_name,type,initializer);
   }

// DQ (12/29/2011): The generate Cxx_Grammar.h header file will see the prototype for this function (even though I tried to make it NOT visible).
// As a result we need a function definition (but we need only call the base class version of the function).
SgDeclarationStatement *
SgTemplateVariableDeclaration::compute_baseTypeDefiningDeclaration() const
   {
     return SgVariableDeclaration::compute_baseTypeDefiningDeclaration();
   }

SOURCE_TEMPLATE_VARIABLE_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_VARIABLE_INSTANTIATION_STATEMENT_START

void SgTemplateVariableInstantiation::post_construction_initialization() {}


SgTemplateVariableInstantiation::SgTemplateVariableInstantiation(
  const SgName& var_name, SgType *type, SgInitializer *initializer
) :
  SgVariableDeclaration(var_name,type,initializer),
  p_templateName(""),
  p_templateHeader(""),
  p_templateDeclaration(nullptr),
  p_templateArguments()
{}

SgDeclarationStatement *
SgTemplateVariableInstantiation::compute_baseTypeDefiningDeclaration() const
   {
     return SgVariableDeclaration::compute_baseTypeDefiningDeclaration();
   }

SOURCE_TEMPLATE_VARIABLE_INSTANTIATION_STATEMENT_END


SOURCE_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT_START

#if 0
// DQ (2/25/2018): This function is more correctly represented below.
void
SgTemplateTypedefDeclaration::post_construction_initialization()
   {
  // DQ (12/21/2011): This is not what we want for the newer design with SgTemplateVariableDeclaration derived from SgVariableDeclaration.
  // this->set_template_kind(e_template_m_data);
   }
#endif





// DQ (12/29/2011): The generate Cxx_Grammar.h header file will see the prototype for this function (even though I tried to make it NOT visible).
// As a result we need a function definition (but we need only call the base class version of the function).
SgDeclarationStatement *
SgTemplateTypedefDeclaration::compute_baseTypeDefiningDeclaration() const
   {
  // DQ (10/14/2014): We need to skip the call to SgTypedefDeclaration::compute_baseTypeDefiningDeclaration() because it is a private function.
  // Not clear why this is not symetric to the case of SgTemplateVariableDeclaration.
  // return SgTypedefDeclaration::compute_baseTypeDefiningDeclaration();
     return NULL;
   }

void
SgTemplateTypedefDeclaration::post_construction_initialization()
   {
  // DQ (2/25/2018): Added this is new support to allos the SgTypedefType::createType() to be called with the
  // SgTemplateTypedefDeclaration's "this" pointer instead of the SgTypedefDeclaration's "this" pointer.

  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if 0
#if PRINT_DEVELOPER_WARNINGS
     printf ("In SgTemplateTypedefDeclaration::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
#endif

#if 0
  // DQ (3/20/2012): We would like to assert this, but I don't think it is always possible. For example, test2001_19.C fails for this test.
  // ROSE_ASSERT(this->get_parent_scope() != NULL);
     if (this->get_parent_scope() == NULL)
        {
          printf ("WARNING: In SgTypedefDeclaration::post_construction_initialization(): this->get_parent_scope() == NULL \n");
        }
#endif

  // Liao 2020/8/6: This is not always true: AST copy of SgTemplateTypedefDeclaration will pass the original type.
  // DQ (2/27/2018): This should be null, since we just changed the semantics to defer the construction of the type (now consistant with other IR nodes).
  // DQ (2/25/2018): This should be non-null, but we might hae to make sure it is not overwritten.
  // ROSE_ASSERT(p_type != NULL);
  // p_type = NULL;
  // ROSE_ASSERT(p_type == NULL);

#if 0
  // DQ (2/25/2018): Added debugging support.
     printf ("In SgTemplateTypedefDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (2/25/2018): Built the type seperately so that we can insert debugging.
  // set_type(SgTypedefType::createType(this));
  // SgTypedefType* typedefType = SgTypedefType::createType(this);
  // ROSE_ASSERT(typedefType != NULL);

  // DQ (2/27/2018): It is an inconsistancy for the type to be set here.
  // set_type(typedefType);

  // DQ (2/25/2018): This should be non-null, since we just built the new type.
  // ROSE_ASSERT(p_type != NULL);
  // ROSE_ASSERT(p_type == NULL);

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);

  // DQ (2/27/2018): Modified to reflect that we no longer build the type in the constructor
  // call (or the post_construction_initialization() function called by the constructor).
  // ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() >= 0);
   }

SOURCE_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT_START

#if 0
// DQ (2/25/2018): This function is more correctly represented below.
void
SgTemplateInstantiationTypedefDeclaration::post_construction_initialization()
   {
  // DQ (11/4/2014): I don't think we need to do anything here.
   }
#endif

SgName
SgTemplateInstantiationTypedefDeclaration::get_mangled_name() const
{
  SgTemplateInstantiationTypedefDeclaration* thisNonConst = const_cast<SgTemplateInstantiationTypedefDeclaration*>(this);
  std::string mangledName = SageInterface::getMangledNameFromCache(thisNonConst);

  if (mangledName.empty())
  {
    mangledName = mangleTemplate(get_templateName(), get_templateArguments(), get_scope());
    mangledName = SageInterface::addMangledNameToCache(thisNonConst,mangledName);
  }

  return mangledName;
}


void
SgTemplateInstantiationTypedefDeclaration::post_construction_initialization()
   {
  // DQ (2/25/2018): Added this is new support to allos the SgTypedefType::createType() to be called with the
  // SgTemplateInstantiationTypedefDeclaration's "this" pointer instead of the SgTypedefDeclaration's "this" pointer.

  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if 0
#if PRINT_DEVELOPER_WARNINGS
     printf ("In SgTemplateInstantiationTypedefDeclaration::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif
#endif

#if 0
  // DQ (3/20/2012): We would like to assert this, but I don't think it is always possible. For example, test2001_19.C fails for this test.
  // ROSE_ASSERT(this->get_parent_scope() != NULL);
     if (this->get_parent_scope() == NULL)
        {
          printf ("WARNING: In SgTemplateInstantiationTypedefDeclaration::post_construction_initialization(): this->get_parent_scope() == NULL \n");
        }
#endif

  // DQ (2/25/2018): This should be non-null, but we might hae to make sure it is not overwritten.
  // ROSE_ASSERT(p_type != NULL);
  // p_type = NULL;
     ROSE_ASSERT(p_type == NULL);

#if 0
  // DQ (2/25/2018): Added debugging support.
     printf ("In SgTemplateInstantiationTypedefDeclaration::post_construction_initialization(): this = %p = %s \n",this,this->class_name().c_str());
#endif

  // DQ (2/26/2018): We need to set the p_templateName, is this a reasonable place to do this?
  // The support to resetting the template name requires the parent to be set and this is only
  // done after the constructor, and post_construction_initialization() function, are called.
  // resetTemplateName();

#if 0
  // printf ("In SgTemplateInstantiationTypedefDeclaration::post_construction_initialization(): calling SgTypedefType::createType(this) \n");
#endif

#if 0
  // DQ (2/25/2018): Built the type seperately so that we can insert debugging.
  // set_type(SgTypedefType::createType(this));
     SgTypedefType* typedefType = SgTypedefType::createType(this);
     ROSE_ASSERT(typedefType != NULL);

  // DQ (2/27/2018): It is an inconsistancy for the type to be set here.
     set_type(typedefType);

  // DQ (2/25/2018): This should be non-null, since we just built the new type.
     ROSE_ASSERT(p_type != NULL);
#else
  // printf ("In SgTemplateInstantiationTypedefDeclaration::post_construction_initialization(): we have to defer the construction of the template instantiation name in the type to after the template name is reset \n");
#endif

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);

  // DQ (3/1/2018): Since we no longer set the type in this function (to be uniformally consistant
  // in where types are set accross all declarations), we have to modify this assertion.
  // ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() >= 0);
   }

void
SgTemplateInstantiationTypedefDeclaration::resetTemplateName()
   {
     resetTemplateNameSupport (p_nameResetFromMangledForm,p_name);
   }

// DQ (2/28/2018): Added support for getting the symbol from the declaration.
SgSymbol*
SgTemplateInstantiationTypedefDeclaration::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }


SOURCE_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_CLASS_DEFINITION_STATEMENT_START
void
SgTemplateClassDefinition::post_construction_initialization()
   {
   }

// DQ (6/11/2011): Added support for new template IR nodes.
void
SgTemplateClassDefinition::set_declaration(SgTemplateClassDeclaration* new_val)
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);
     set_parent(new_val);
   }

// DQ (6/11/2011): Added support for new template IR nodes.
SgTemplateClassDeclaration*
SgTemplateClassDefinition::get_declaration() const
   {
  // QY: 10-4-04 removed declaration pointer. use parent pointer instead
     ROSE_ASSERT(this != NULL);

     ROSE_ASSERT(get_parent() != NULL);

#if 0
     printf ("In SgTemplateClassDefinition::get_declaration(): get_parent() = %p = %s \n",get_parent(),get_parent()->class_name().c_str());
#endif

     SgTemplateClassDeclaration *decl = isSgTemplateClassDeclaration(get_parent());
     assert( get_parent() == NULL || decl != NULL );
     return decl;
   }

SgName
SgTemplateClassDefinition::get_qualified_name() const
   {
  // printf ("In SgClassDefinition::get_qualified_name() \n");

  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_qualified_name();
     SgTemplateClassDeclaration* templateClassDeclaration = get_declaration();
     ROSE_ASSERT(templateClassDeclaration != NULL);
     return templateClassDeclaration->get_qualified_name();
   }

// DQ (2/7/2006): code added by Rich Vuduc
SgName
SgTemplateClassDefinition::get_mangled_name (void) const
   {
  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_mangled_name ();
     SgTemplateClassDeclaration* templateClassDeclaration = get_declaration();
     ROSE_ASSERT(templateClassDeclaration != NULL);
     return templateClassDeclaration->get_mangled_name ();
   }

SgName
SgTemplateClassDefinition::get_mangled_qualified_name (int& i)
   {
  // printf ("In SgClassDefinition::get_mangled_qualified_name(%d): Calling get_declaration()->get_mangled_qualified_name(%d) \n",i,i);

     printf ("Sorry, SgTemplateClassDefinition::get_mangled_qualified_name(int) not implemented! \n");
     ROSE_ASSERT(false);

     return "error_no_name";
   }

SgTemplateClassDefinition::SgTemplateClassDefinition( SgTemplateClassDeclaration *decl)
   : SgClassDefinition()
   {
     set_declaration(decl);
     decl->set_definition(this);
   }

SOURCE_TEMPLATE_CLASS_DEFINITION_STATEMENT_END

SOURCE_TEMPLATE_FUNCTION_DEFINITION_STATEMENT_START
void
SgTemplateFunctionDefinition::post_construction_initialization()
   {
   }

// DQ (12/1/2011): Added support for template declarations in the AST.
SgTemplateFunctionDefinition::SgTemplateFunctionDefinition(Sg_File_Info* f, SgTemplateFunctionDeclaration* d, SgBasicBlock* body)
// : SgScopeStatement(f), p_body(body)
   : SgFunctionDefinition(f,NULL,body)
   {
     set_declaration(d);
     if (d!=NULL) // Liao, 4/14/2009. Support bottom-up AST building: definition is built first, declaration may be still NULL
      d->set_definition(this);
   }

// DQ (12/1/2011): Added support for template declarations in the AST.
SgTemplateFunctionDefinition::SgTemplateFunctionDefinition( SgTemplateFunctionDeclaration* d, SgBasicBlock* body)
// : SgScopeStatement(), p_body(body)
   : SgFunctionDefinition((SgFunctionDeclaration*)NULL,body)
   {
     set_declaration(d);
     if (d!=NULL)
      d->set_definition(this);
   }


SgTemplateFunctionDeclaration*
SgTemplateFunctionDefinition::get_declaration() const
   {
  // This is copied and modified from the similar function for SgFunctionDefinition::get_declaration()
     SgNode* res = get_parent();
     SgTemplateFunctionDeclaration* res1 = isSgTemplateFunctionDeclaration(res);

     assert( res == 0 || res1 != 0);

     return res1;
   }

void
SgTemplateFunctionDefinition::set_declaration(SgTemplateFunctionDeclaration* new_val)
   {
  // This is copied from the similar function for SgFunctionDefinition::set_declaration()
     set_parent(new_val);
   }

SgName
SgTemplateFunctionDefinition::get_mangled_name (void) const
   {
  // DQ (3/19/2016): Klocworks reports this as an issue, since get_declaration() might be NULL.
  // return get_declaration()->get_mangled_name();
     SgTemplateFunctionDeclaration* templateFunctionDeclaration = get_declaration();
     ROSE_ASSERT(templateFunctionDeclaration != NULL);
     return templateFunctionDeclaration->get_mangled_name();
   }

SOURCE_TEMPLATE_FUNCTION_DEFINITION_STATEMENT_END


SOURCE_PRAGMA_STATEMENT_START
void
SgPragmaDeclaration::post_construction_initialization()
   {
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgPragmaDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
  // SgScopeStatement* scope = get_scope();
  // ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
     returnName = "pragma_statement";

     return returnName;
   }

SOURCE_PRAGMA_STATEMENT_END


SOURCE_EMPTY_DECLARATION_START
void
SgEmptyDeclaration::post_construction_initialization()
   {
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgEmptyDeclaration::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
  // SgScopeStatement* scope = get_scope();
  // ROSE_ASSERT(scope != NULL);

  // This is a poor way to handle the generation of a mangled name (will be improved)
     returnName = "empty_declaration";

     return returnName;
   }

// DQ (11/24/2020): Adding support for explicit scope to be false.
bool
SgEmptyDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node does NOT store its scope explicitly.
     return false;
   }

SOURCE_EMPTY_DECLARATION_END


SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT_END



SOURCE_NAMESPACE_DECLARATION_STATEMENT_START

bool
SgNamespaceDeclarationStatement::isSameNamespace( const SgNamespaceDeclarationStatement* n ) const
   {
  // DQ (6/5/2007): Since namespaces are re-entrant we define a simple function to test if two namespaces
  // are the same (not the same SgNamespaceDeclarationStatement, but the same namespace).
     ROSE_ASSERT(get_firstNondefiningDeclaration() != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(n->get_firstNondefiningDeclaration() != NULL);

     return ( get_firstNondefiningDeclaration() == n->get_firstNondefiningDeclaration() );
   }

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDeclarationStatement::get_qualified_name() const
   {
     SgName returnName;

  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope!= NULL);

  // DQ (8/24/2006): Need to test for unnamed namespaces since we have to ignore the extra "::" that would be generated in this case!
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
  // returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
     if (get_name().is_null() == true)
        {
       // DQ (10/12/2006): Return and empty name instead of the qualified name
       // of the current scope (see test2004_33.C using un-named namespaces).

       // Ignore the namespace name if it is a unnamed namespace
       // returnName = scope->get_qualified_name();

       // DQ (10/14/2006): Correction for un-named namespaces in nested scopes!
          if (isSgGlobal(scope) != NULL)
             {
            // If this is an un-named namespace in global scope then we are finished and the qualifier is empty.
               returnName = "";
             }
            else
             {
            // If we are not yet in global scope then go further!
               returnName = scope->get_qualified_name();
             }
        }
       else
        {
          returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());
        }

  // printf ("In SgNamespaceDeclarationStatement::get_qualified_name() : get_name().is_null == %s for name '%s'\n",get_name().is_null() ? "true" : "false", get_name().str());

     return returnName;
   }

// RV (2/1/2006): Added mangler for namespace declarations.
SgName
SgNamespaceDeclarationStatement::get_mangled_name (void) const
   {
#if 0
     return joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#else
#if 0
  // DQ (3/12/2007): Experiment with mangled name map (caching for performance improvement)
     SgNamespaceDeclarationStatement* declaration = const_cast<SgNamespaceDeclarationStatement*>(this);
     std::map<SgNode*,std::string>::iterator i = p_globalMangledNameMap.find(declaration);
     if (i != p_globalMangledNameMap.end())
        {
          return i->second.c_str();
        }
#endif
     std::string mangledNameString = SageInterface::getMangledNameFromCache(const_cast<SgNamespaceDeclarationStatement*>(this));
     if (mangledNameString.empty() == false)
        {
       // return i->second.c_str();
          return mangledNameString;
        }
       else
        {
          SgName mangledName = joinMangledQualifiers (mangleQualifiers(get_scope()), get_name());
#if 0
          printf ("In SgNamespaceDeclarationStatement::get_mangled_name(): mangledName = %s \n",mangledName.str());
#endif
       // p_globalMangledNameMap[declaration] = mangledName;
          mangledName = SageInterface::addMangledNameToCache(const_cast<SgNamespaceDeclarationStatement*>(this),mangledName);
          return mangledName;
        }
#endif
   }

#if 0
// DQ (2/19/2006): Added to handle case destribed in the header file.
bool
SgNamespaceDeclarationStatement::hasExplicitScope() const
   {
  // This function reports that this IR node stores its scope explicitly.

     return true;
   }
#endif

// DQ (2/6/2007): Get the associated symbol from the symbol table in the stored scope
SgSymbol*
SgNamespaceDeclarationStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

SOURCE_NAMESPACE_DECLARATION_STATEMENT_END

SOURCE_NAMESPACE_ALIAS_DECLARATION_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgNamespaceAliasDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_namespace_alias_") + get_name();
     returnName = scope->get_mangled_name() + SgName("_namespace_alias_") + get_name();

     return returnName;
   }

SgSymbol*
SgNamespaceAliasDeclarationStatement::get_symbol_from_symbol_table() const
   {
     ROSE_ASSERT(get_scope() != NULL);
  // ROSE_ASSERT(get_scope()->get_symbol_table() != NULL);
  // return get_scope()->get_symbol_table()->find(this);
     return get_scope()->find_symbol_from_declaration(this);
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgNamespaceAliasDeclarationStatement::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgNamespaceAliasDeclarationStatement::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgNamespaceAliasDeclarationStatement::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgNamespaceAliasDeclarationStatement::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgNamespaceAliasDeclarationStatement::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgNamespaceAliasDeclarationStatement::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_NAMESPACE_ALIAS_DECLARATION_STATEMENT_END

SOURCE_NAMESPACE_DEFINITION_STATEMENT_START

bool
SgNamespaceDefinitionStatement::isSameNamespace(const SgNamespaceDefinitionStatement* n ) const
   {
     ROSE_ASSERT(this != NULL);
     ROSE_ASSERT(n != NULL);
     ROSE_ASSERT(this->get_namespaceDeclaration() != NULL);
     ROSE_ASSERT(n->get_namespaceDeclaration() != NULL);

     return this->get_namespaceDeclaration()->isSameNamespace(n->get_namespaceDeclaration());
   }

void
SgNamespaceDefinitionStatement::append_declaration(SgDeclarationStatement * what)
   {
     get_declarations().push_back(what);
     what->set_parent(this);
   }

void
SgNamespaceDefinitionStatement::prepend_declaration(SgDeclarationStatement * what)
   {
     get_declarations().insert(get_declarations().begin(), what);
     what->set_parent(this);
   }

#if 0
void
SgNamespaceDefinitionStatement::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where,
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }
#endif

// DQ (8/27/2004): Turn this back on!
#if 1
bool
SgNamespaceDefinitionStatement::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool
SgNamespaceDefinitionStatement::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }
#endif

// DQ (9/8/2004): Added to support qualified name generation
SgName
SgNamespaceDefinitionStatement::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() \n");

     ROSE_ASSERT(get_namespaceDeclaration() != NULL);
     return get_namespaceDeclaration()->get_qualified_name();
   }

// RV (2/1/2006): Added mangler for namespace definitions.
SgName
SgNamespaceDefinitionStatement::get_mangled_name (void) const
  {
    if (get_namespaceDeclaration() == NULL)
       {
         printf ("In SgNamespaceDefinitionStatement::get_mangled_name(): get_namespaceDeclaration() == NULL: this = %p \n",this);
       }

    ROSE_ASSERT(get_namespaceDeclaration() != NULL);
    return get_namespaceDeclaration()->get_mangled_name ();
  }

void
SgNamespaceDefinitionStatement::post_construction_initialization()
   {
   }

#if 0
// DQ (5/9/2013): This is an older version of the code.
void
SgNamespaceDefinitionStatement::append_declaration(SgDeclarationStatement * what)
   {
     insert_declaration(get_declarations().end(),what);
   }

// DQ (5/9/2013): This is an older version of the code.
void
SgNamespaceDefinitionStatement::prepend_declaration(SgDeclarationStatement * what)
   {
     insert_declaration(get_declarations().begin(),what);
   }
#endif

size_t
SgNamespaceDefinitionStatement::namespaceIndex() const
   {
     size_t result = 0;
     SgNamespaceDefinitionStatement* i = const_cast<SgNamespaceDefinitionStatement*>(this);
     while (i->get_previousNamespaceDefinition() != NULL)
        {
          result++;
          i = i->get_previousNamespaceDefinition();
        }

     return result;
   }

size_t
SgNamespaceDefinitionStatement::numberOfNamespaceDefinitions() const
   {
     size_t result = 0;

     SgNamespaceDefinitionStatement* i = const_cast<SgNamespaceDefinitionStatement*>(this);

     if (this == this->get_global_definition())
        {
       // If this is the namespace definiton used to accumulate all of the symbols in the namespace then find the name space defintion associated with the first non-defining declaration.
          ROSE_ASSERT(this->get_namespaceDeclaration() == this->get_namespaceDeclaration()->get_firstNondefiningDeclaration());

       // DQ (5/19/2013): Added assertion.
          ROSE_ASSERT(this->get_isUnionOfReentrantNamespaceDefinitions() == true);

          i = this->get_namespaceDeclaration()->get_definition();
        }
       else
        {
       // DQ (5/19/2013): Added assertion.
          ROSE_ASSERT(this->get_isUnionOfReentrantNamespaceDefinitions() == false);
        }

     while (i->get_nextNamespaceDefinition() != NULL)
        {
          result++;
          i = i->get_nextNamespaceDefinition();
        }

     result += namespaceIndex() + 1;

     return result;
   }

#if 0
// DQ (5/16/2013): This is now a seperate data member access function (to a specially constructed
// SgNamespaceDefinitionStatement used to hold the SgAliasSymbols that are the union of those across
// all of the many re-entrant namespace definitions.
SgNamespaceDefinitionStatement*
SgNamespaceDefinitionStatement::get_global_definition() const
   {
  // DQ (5/9/2013): Traverse back through the scopes to the first one. Later
  // we might want to return an especially constructed SgNamespaceDefinitionStatement
  // for this purpose.
     SgNamespaceDefinitionStatement* i = const_cast<SgNamespaceDefinitionStatement*>(this);
     while (i->get_previousNamespaceDefinition() != NULL)
        {
          i = i->get_previousNamespaceDefinition();
        }

     return i;
   }
#endif

SOURCE_NAMESPACE_DEFINITION_STATEMENT_END

SOURCE_USING_DIRECTIVE_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_using_directive_") + get_namespaceDeclaration()->get_mangled_name();

     return returnName;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgUsingDirectiveStatement::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgUsingDirectiveStatement::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgUsingDirectiveStatement::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgUsingDirectiveStatement::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgUsingDirectiveStatement::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgUsingDirectiveStatement::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_USING_DIRECTIVE_STATEMENT_END

SOURCE_USING_DECLARATION_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgUsingDeclarationStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName name;
     if (get_declaration() != NULL)
          name = get_declaration()->get_mangled_name();
       else
        {
          ROSE_ASSERT(get_initializedName() != NULL);
          name = get_initializedName()->get_mangled_name();
        }

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_using_declaration_") + name;
     returnName = scope->get_mangled_name() + SgName("_using_declaration_") + name;

     return returnName;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgUsingDeclarationStatement::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgUsingDeclarationStatement::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgUsingDeclarationStatement::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgUsingDeclarationStatement::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgUsingDeclarationStatement::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgUsingDeclarationStatement::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

SOURCE_USING_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_START

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgTemplateInstantiationDirectiveStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (2/22/2007): Use mangled name support in scopes instead of the qualified name (to avoid "::" substrings in mangled names).
  // This is a poor way to handle the generation of a mangled name (will be improved)
  // returnName = scope->get_qualified_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();
     returnName = scope->get_mangled_name() + SgName("_template_instantiation_directive_") + get_declaration()->get_mangled_name();

     return returnName;
   }

SOURCE_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT_END



// DQ (3/19/2007): Fortran IR node support
SOURCE_PROGRAM_HEADER_STATEMENT_START
void
SgProgramHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProgramHeaderStatement::get_mangled_name() const
   {
  // DQ (8/17/2007): This Fortran specific IR node can be as simple a mangled name as we like, I think.

  // printf ("SgProgramHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
  // return get_name();
     return SgFunctionDeclaration::get_mangled_name();
   }


bool
SgProgramHeaderStatement::replace_child(SgStatement *target, SgStatement *newstmt, bool extractBasicBlock)
   {
     if(StatementReplace(this, p_definition, target, newstmt))
          return true;
     else
          return (StatementReplace(this, p_parameterList, target, newstmt));
   }

SOURCE_PROGRAM_HEADER_STATEMENT_END

SOURCE_PROCEDURE_HEADER_STATEMENT_START

void
SgProcedureHeaderStatement::post_construction_initialization()
   {
   }

SgName
SgProcedureHeaderStatement::get_mangled_name() const
   {
  // DQ (8/23/2007): Use the get_mangled_name() member function from the base class.
  // printf ("SgProcedureHeaderStatement::get_mangled_name() not implemented \n");
  // ROSE_ASSERT(false);
     return SgFunctionDeclaration::get_mangled_name();
   }

bool
SgProcedureHeaderStatement::isFunction() const
   {
     bool result = false;
     if (p_subprogram_kind == e_function_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isSubroutine() const
   {
     bool result = false;
     if (p_subprogram_kind == e_subroutine_subprogram_kind)
        result = true;

     return result;
   }

bool
SgProcedureHeaderStatement::isBlockData() const
   {
     bool result = false;
     if (p_subprogram_kind == e_block_data_subprogram_kind)
        result = true;

     return result;
   }

SOURCE_PROCEDURE_HEADER_STATEMENT_END


SOURCE_ENTRY_STATEMENT_START

void
SgEntryStatement::post_construction_initialization()
   {
   }

SgName
SgEntryStatement::get_mangled_name() const
   {
     return SgFunctionDeclaration::get_mangled_name();
   }

SOURCE_ENTRY_STATEMENT_END

SOURCE_ADA_ENTRY_DECL_STMT_START

void
SgAdaEntryDecl::post_construction_initialization() {}

SgName
SgAdaEntryDecl::get_mangled_name() const
{
  return SgFunctionDeclaration::get_mangled_name();
}

SgType*
SgAdaEntryDecl::get_entryIndexType() const
{
  ROSE_ASSERT(p_entryIndex);

  return p_entryIndex->get_type();
}


SOURCE_ADA_ENTRY_DECL_STMT_END

SOURCE_ADA_FUNCTION_RENAMING_DECL_STMT_START

void
SgAdaFunctionRenamingDecl::post_construction_initialization() {}

SgName
SgAdaFunctionRenamingDecl::get_mangled_name() const
{
  return SgFunctionDeclaration::get_mangled_name();
}

SOURCE_ADA_FUNCTION_RENAMING_DECL_STMT_END

SOURCE_TYPEDEF_DECLARATION_STATEMENT_START

void
$CLASSNAME::post_construction_initialization()
   {
  // DQ (10/6/2004): I think this should be dependent upon if the type was provided as an input in
  // the constructor parameter list (else why bother specifying it in the constructor parameter list!)
#if PRINT_DEVELOPER_WARNINGS
     printf ("In $CLASSNAME::post_construction_initialization(): generating SgTypedefType internally! \n");
#endif

  // DQ (2/27/2018): I think this is a redundant implementation, not used by ROSETTA.
     printf ("I think this implementation of this function via ROSETTA is not used! \n");
     ROSE_ASSERT(false);

  // DQ (2/27/2018): It is inconsistant for thetype to be set here.
  // set_type($GRAMMAR_PREFIX_$GRAMMAR_X_MARKER_TypedefType::createType(this));

     ROSE_ASSERT (get_base_type() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs() != NULL);
     ROSE_ASSERT (get_base_type()->get_typedefs()->get_typedefs().size() > 0);
   }

// $GRAMMAR_PREFIX_Statement *get_next(int&) const;

bool
$CLASSNAME::replace_child($GRAMMAR_PREFIX_Statement *target,$GRAMMAR_PREFIX_Statement *newstmt, bool extractBasicBlock)
{
    return StatementReplace(this, p_declaration, target, newstmt);
}

#if 0
$GRAMMAR_PREFIX_Statement*
$CLASSNAME::get_next(int& n) const
   {
     if(n)
          return 0;
       else
        {
          n++;
          return get_declaration();
        }
   }
#endif

$GRAMMAR_PREFIX_Name
$CLASSNAME::get_qualified_name() const
   {
  // DQ (10/15/2004): This function is similar to the one for SgClassDeclaration.
  // This function calls get_scope() which uses the parent pointers, thus
  // it should not be called before the parent pointers are set (within the AST fixup after
  // the Sage III AST is fully constructed).

     printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = SgName::assembleQualifiedName(scope->get_qualified_name(),get_name());

     printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

// DQ (4/10/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
int
SgTypedefDeclaration::get_name_qualification_length() const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTypedefDeclaration::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

// DQ (4/10/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool
SgTypedefDeclaration::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTypedefDeclaration::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

// DQ (4/10/2019): Added support for name qualification on the SgInitializedName (as part fo support for SgMemberPointerType).
bool
SgTypedefDeclaration::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTypedefDeclaration::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }


SOURCE_TYPEDEF_DECLARATION_STATEMENT_END


SOURCE_TEMPLATE_DECLARATION_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
  // DQ (2/27/2018): Enforce that this is not already set (should be set after the constructor to
  // simplify how derived classes (e.g. SgTemplateInstantiationClassDeclaration statements) work.
     ROSE_ASSERT(p_type == NULL);

  // DQ (2/27/2018): I think this is a redundant implementation, not used by ROSETTA.
     printf ("I think this implementation of this function via ROSETTA is not used! \n");
     ROSE_ASSERT(false);
   }

// DQ (9/8/2004): added support for qualified names
SgName
$CLASSNAME::get_qualified_name() const
   {
  // printf ("In $CLASSNAME::get_qualified_name() name = %s \n",get_name().str());

     SgName returnName;
     string returnNameString;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

  // DQ (9/8/2004): Don't use the template name as is stored (which is a mangled name from EDG)
  // returnName = scope->get_qualified_name() << "::" << get_name().str();
     returnName = scope->get_qualified_name();
  // printf ("In $CLASSNAME::get_qualified_name() returnName = %s \n",returnName.str());

     return returnName;
   }

#if 0
SgName
$CLASSNAME::get_name() const
   {

   }
#endif

SOURCE_TEMPLATE_DECLARATION_STATEMENT_END


SOURCE_PRAGMA_STATEMENT_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_PRAGMA_STATEMENT_END


SOURCE_COMMON_BLOCK_STATEMENT_START

void
SgCommonBlock::post_construction_initialization()
   {
   }

SgName
SgCommonBlock::get_mangled_name() const
   {
  // printf ("Sorry, SgCommonBlock::get_mangled_name() not implemented! \n");
     return SgName("");
   }

const SgCommonBlockObjectPtrList &
SgCommonBlock::get_block_list() const
   {
     return p_block_list;
   }

SgCommonBlockObjectPtrList &
SgCommonBlock::get_block_list()
   {
     return p_block_list;
   }

SOURCE_COMMON_BLOCK_STATEMENT_END

SOURCE_MODULE_STATEMENT_START

void
SgModuleStatement::post_construction_initialization()
   {}

SgName
SgModuleStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgModuleStatement::get_mangled_name() not implemented! \n");
     return SgName("_module_");
   }

#if 0
const SgDeclarationStatementPtrList &
SgModuleStatement::get_members() const
   {
     return p_members;
   }

SgDeclarationStatementPtrList &
SgModuleStatement::get_members()
   {
     return p_members;
   }

void
$CLASSNAME::append_declaration(SgDeclarationStatement * what)
   {
     insert_declaration(get_declarations().end(),what);
   }

void
$CLASSNAME::prepend_declaration(SgDeclarationStatement * what)
   {
     insert_declaration(get_declarations().begin(),what);
   }

void
$CLASSNAME::insert_declaration ( const SgDeclarationStatementPtrList::iterator& where,
                                 SgDeclarationStatement* what)
   {
#ifndef REMOVE_SET_PARENT_FUNCTION
     what->set_parent(this);
#endif
     get_declarations().insert(where,what);
   }

// DQ (8/27/2004): Turn this back on!
#if 1
bool
$CLASSNAME::insert_child($GRAMMAR_PREFIX_Statement* target, $GRAMMAR_PREFIX_Statement* newstmt, bool inFront, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
   }

bool
$CLASSNAME::replace_child($GRAMMAR_PREFIX_Statement *target ,$GRAMMAR_PREFIX_Statement * newstmt, bool extractBasicBlock)
   {
     return StatementListInsertChild( this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
   }
#endif
#endif

SOURCE_MODULE_STATEMENT_END

SOURCE_CONTAINS_STATEMENT_START

void
SgContainsStatement::post_construction_initialization()
   {
   }

SgName
SgContainsStatement::get_mangled_name() const
   {
     return SgName("_contains_");
   }

SOURCE_CONTAINS_STATEMENT_END

SOURCE_USE_STATEMENT_START

void
SgUseStatement::post_construction_initialization()
   {}

SgName
SgUseStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgUseStatement::get_mangled_name() not implemented! \n");
     return SgName("_use_");
   }

SOURCE_USE_STATEMENT_END

SOURCE_PROCESS_CONTROL_STATEMENT_START

void
SgProcessControlStatement::post_construction_initialization()
   {
  // Set the parent of any input expression.
     if (p_code != NULL)
        {
          p_code->set_parent(this);
        }
   }

SOURCE_PROCESS_CONTROL_STATEMENT_END

SOURCE_IMAGE_CONTROL_STATEMENT_START

void
SgImageControlStatement::post_construction_initialization()
   {}

SOURCE_IMAGE_CONTROL_STATEMENT_END

SOURCE_SYNC_ALL_STATEMENT_START

void
SgSyncAllStatement::post_construction_initialization()
   {}

SOURCE_SYNC_ALL_STATEMENT_END

SOURCE_SYNC_IMAGES_STATEMENT_START

void
SgSyncImagesStatement::post_construction_initialization()
   {}

SOURCE_SYNC_IMAGES_STATEMENT_END

SOURCE_SYNC_MEMORY_STATEMENT_START

void
SgSyncMemoryStatement::post_construction_initialization()
   {}

SOURCE_SYNC_MEMORY_STATEMENT_END

SOURCE_SYNC_TEAM_STATEMENT_START

void
SgSyncTeamStatement::post_construction_initialization()
   {}

SOURCE_SYNC_TEAM_STATEMENT_END


SOURCE_LOCK_STATEMENT_START

void
SgLockStatement::post_construction_initialization()
   {}

SOURCE_LOCK_STATEMENT_END


SOURCE_UNLOCK_STATEMENT_START

void
SgUnlockStatement::post_construction_initialization()
   {}

SOURCE_UNLOCK_STATEMENT_END


SOURCE_IO_STATEMENT_START

void
SgIOStatement::post_construction_initialization()
   {}

SOURCE_IO_STATEMENT_END

SOURCE_PRINT_STATEMENT_START

void
SgPrintStatement::post_construction_initialization()
   {}

SOURCE_PRINT_STATEMENT_END


SOURCE_READ_STATEMENT_START

void
SgReadStatement::post_construction_initialization()
   {}

SOURCE_READ_STATEMENT_END


SOURCE_WRITE_STATEMENT_START

void
SgWriteStatement::post_construction_initialization()
   {}

SOURCE_WRITE_STATEMENT_END


SOURCE_OPEN_STATEMENT_START

void
SgOpenStatement::post_construction_initialization()
   {}

SOURCE_OPEN_STATEMENT_END


SOURCE_CLOSE_STATEMENT_START

void
SgCloseStatement::post_construction_initialization()
   {}

SOURCE_CLOSE_STATEMENT_END


SOURCE_INQUIRE_STATEMENT_START

void
SgInquireStatement::post_construction_initialization()
   {}

SOURCE_INQUIRE_STATEMENT_END


SOURCE_FLUSH_STATEMENT_START

void
SgFlushStatement::post_construction_initialization()
   {}

SOURCE_FLUSH_STATEMENT_END


SOURCE_REWIND_STATEMENT_START

void
SgRewindStatement::post_construction_initialization()
   {}

SOURCE_REWIND_STATEMENT_END


SOURCE_BACKSPACE_STATEMENT_START

void
SgBackspaceStatement::post_construction_initialization()
   {}

SOURCE_BACKSPACE_STATEMENT_END


SOURCE_ENDFILE_STATEMENT_START

void
SgEndfileStatement::post_construction_initialization()
   {}

SOURCE_ENDFILE_STATEMENT_END


SOURCE_WAIT_STATEMENT_START

void
SgWaitStatement::post_construction_initialization()
   {}

SOURCE_WAIT_STATEMENT_END


SOURCE_FORTRAN_DO_STATEMENT_START
void
SgFortranDo::post_construction_initialization()
   {
   }

// Liao (3/11/2009): Added to provide uniform support of mangle names for all scopes
SgName
SgFortranDo::get_mangled_name(void) const
   {
     return SgName ("");
   }

SOURCE_FORTRAN_DO_STATEMENT_END


SOURCE_FORTRAN_NONBLOCKED_DO_STATEMENT_START
void
SgFortranNonblockedDo::post_construction_initialization()
   {
   }

SOURCE_FORTRAN_NONBLOCKED_DO_STATEMENT_END


SOURCE_INTERFACE_STATEMENT_START
void
SgInterfaceStatement::post_construction_initialization()
   {
#if 0
     if (p_function != NULL)
        {
          p_function->set_parent(this);
        }
#endif
   }

SgName
SgInterfaceStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgInterfaceStatement::get_mangled_name() not implemented! \n");
     return SgName("_interface_");
   }

SOURCE_INTERFACE_STATEMENT_END


SOURCE_PARAMETER_STATEMENT_START
void
SgParameterStatement::post_construction_initialization()
   {
   }

SOURCE_PARAMETER_STATEMENT_END


SOURCE_BLOCK_DATA_STATEMENT_START
void
SgBlockDataStatement::post_construction_initialization()
   {}
SOURCE_BLOCK_DATA_STATEMENT_END


SOURCE_IMPLICIT_STATEMENT_START
void
SgImplicitStatement::post_construction_initialization()
   {}

SgName
SgImplicitStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgImplicitStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_IMPLICIT_STATEMENT_END


SOURCE_STATEMENT_FUNCTION_STATEMENT_START
void
SgStatementFunctionStatement::post_construction_initialization()
   {}

SgName
SgStatementFunctionStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgStatementFunctionStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_STATEMENT_FUNCTION_STATEMENT_END


SOURCE_WHERE_STATEMENT_START
void
SgWhereStatement::post_construction_initialization()
   {}
SOURCE_WHERE_STATEMENT_END


SOURCE_ELSE_WHERE_STATEMENT_START
void
SgElseWhereStatement::post_construction_initialization()
   {}
SOURCE_ELSE_WHERE_STATEMENT_END


SOURCE_NULLIFY_STATEMENT_START
void
SgNullifyStatement::post_construction_initialization()
   {}
SOURCE_NULLIFY_STATEMENT_END


SOURCE_EQUIVALENCE_STATEMENT_START

void
SgEquivalenceStatement::post_construction_initialization()
   {}

SgName
SgEquivalenceStatement::get_mangled_name() const
   {
  // printf ("Sorry, SgEquivalenceStatement::get_mangled_name() not implemented! \n");
     return SgName("");
   }
SOURCE_EQUIVALENCE_STATEMENT_END


SOURCE_DERIVED_TYPE_STATEMENT_START
void
SgDerivedTypeStatement::post_construction_initialization()
   {}

SgName
SgDerivedTypeStatement::get_mangled_name() const
   {
  // DQ (12/27/2010): This causes endless recursion when the type is defined locally to the
  // function and the function uses the type as a return type (which seems like a language
  // design mistake). Testcode test2010_179.f90 demonstrates this and it is actually a part
  // of the gfortran test suite, so I gather it is legal code.
  // To address this complexity I will make the fix in this IR node (which is fortran specific)
  // to use only the name plus the function and qualified name of the function's scope instead
  // of the generated function definition's mangled name which causes the endless recursion.
  // This will be done only for the case were we detect that the type is used as the return type of
  // the function.  I don't think that modules can be defined in functions, so I think this is OK.
  // return SgClassDeclaration::get_mangled_name();
     SgName mangleName;
     ROSE_ASSERT(this->get_parent() != NULL);
     SgFunctionDeclaration* functionDeclaration = TransformationSupport::getFunctionDeclaration(this->get_parent());

     bool defineShorterName = false;
     if (functionDeclaration != NULL)
        {
          SgFunctionType* functionType = isSgFunctionType(functionDeclaration->get_type());
          ROSE_ASSERT(functionType != NULL);
       // printf ("functionType = %p = %s \n",functionType,functionType->class_name().c_str());

          SgType* returnType = functionType->get_return_type();
          ROSE_ASSERT(returnType != NULL);
          if (returnType == this->get_type())
             {
               defineShorterName = true;
             }
        }

     if (defineShorterName == true)
        {
       // This defines a short (none endlessly recursive name) for the derived type mangled name.
          mangleName = "__NESTED_TYPE_USED_IN_FUNCTION_RETURN_TYPE_" + functionDeclaration->get_name() + "__" + this->get_name() + "__";
        }
       else
        {
          mangleName = SgClassDeclaration::get_mangled_name();
        }

     return mangleName;
   }
SOURCE_DERIVED_TYPE_STATEMENT_END

SOURCE_ATTRIBUTE_SPECIFICATION_STATEMENT_START
void
SgAttributeSpecificationStatement::post_construction_initialization()
   {}

SgName
SgAttributeSpecificationStatement::get_mangled_name(void) const
   {
     return SgName ("__attribute_specification_statement__");
   }

const SgStringList &
SgAttributeSpecificationStatement::get_name_list() const
   {
     return p_name_list;
   }

SgStringList &
SgAttributeSpecificationStatement::get_name_list()
   {
     return p_name_list;
   }

const SgDataStatementGroupPtrList &
SgAttributeSpecificationStatement::get_data_statement_group_list() const
   {
     return p_data_statement_group_list;
   }

SgDataStatementGroupPtrList &
SgAttributeSpecificationStatement::get_data_statement_group_list()
   {
     return p_data_statement_group_list;
   }

const SgDimensionObjectPtrList &
SgAttributeSpecificationStatement::get_dimension_object_list() const
   {
     return p_dimension_object_list;
   }

SgDimensionObjectPtrList &
SgAttributeSpecificationStatement::get_dimension_object_list()
   {
     return p_dimension_object_list;
   }

SgSymbol*
SgAttributeSpecificationStatement::search_for_symbol_from_symbol_table() const
   {
  // If we are searching for a symbol associated with this declaration, then it could only be a numeric label
  // in which case we have to search for it in the function scope (SgFunctionDefinition).

     SgScopeStatement* tempScope = get_scope();
     ROSE_ASSERT(tempScope != NULL);
     while (tempScope != NULL && isSgFunctionDefinition(tempScope) == NULL)
        {
          tempScope = tempScope->get_scope();
        }

     SgFunctionDefinition* functionDefinition = isSgFunctionDefinition(tempScope);
     if (functionDefinition == NULL)
        {
          printf ("Labels are stored in the SgFunctionDefinition (function scope), could not locate associated function scope \n");
        }
     ROSE_ASSERT(functionDefinition != nullptr);

     return functionDefinition->find_symbol_from_declaration(this);
   }

SOURCE_ATTRIBUTE_SPECIFICATION_STATEMENT_END


SOURCE_ALLOCATE_STATEMENT_START
void
SgAllocateStatement::post_construction_initialization()
   {}
SOURCE_ALLOCATE_STATEMENT_END


SOURCE_DEALLOCATE_STATEMENT_START
void
SgDeallocateStatement::post_construction_initialization()
   {}
SOURCE_DEALLOCATE_STATEMENT_END


SOURCE_CONTAINS_STATEMENT_START
void
SgContainsStatement::post_construction_initialization()
   {}
SOURCE_CONTAINS_STATEMENT_END


SOURCE_SEQUENCE_STATEMENT_START
void
SgSequenceStatement::post_construction_initialization()
   {}
SOURCE_SEQUENCE_STATEMENT_END



SOURCE_ARITHMETIC_IF_STATEMENT_START
void
SgArithmeticIfStatement::post_construction_initialization()
   {}
SOURCE_ARITHMETIC_IF_STATEMENT_END


SOURCE_ASSIGN_STATEMENT_START
void
SgAssignStatement::post_construction_initialization()
   {}
SOURCE_ASSIGN_STATEMENT_END


SOURCE_COMPUTED_GOTO_STATEMENT_START

void
SgComputedGotoStatement::post_construction_initialization()
   {}

#if 0
// DQ (12/30/2007): This list is no longer requires since we ave build the IR node for a SgLabelRefExp
// and we can hold this information using an more common ExprListExp instead.
const SgLabelSymbolPtrList &
SgComputedGotoStatement::get_labelList() const
   {
     return p_labelList;
   }

SgLabelSymbolPtrList &
SgComputedGotoStatement::get_labelList()
   {
     return p_labelList;
   }

void
SgComputedGotoStatement::set_labelList(const SgLabelSymbolPtrList & labelList)
   {
     p_labelList = labelList;
   }
#endif

SOURCE_COMPUTED_GOTO_STATEMENT_END


SOURCE_ASSIGNED_GOTO_STATEMENT_START
void
SgAssignedGotoStatement::post_construction_initialization()
   {}
SOURCE_ASSIGNED_GOTO_STATEMENT_END


SOURCE_NAMELIST_STATEMENT_START
void
SgNamelistStatement::post_construction_initialization()
   {}

SgName
SgNamelistStatement::get_mangled_name(void) const
   {
     return SgName ("__namelist__");
   }

const SgNameGroupPtrList &
SgNamelistStatement::get_group_list() const
   {
     return p_group_list;
   }

SgNameGroupPtrList &
SgNamelistStatement::get_group_list()
   {
     return p_group_list;
   }

SOURCE_NAMELIST_STATEMENT_END



SOURCE_IMPORT_STATEMENT_START
void
SgImportStatement::post_construction_initialization()
   {}

SgName
SgImportStatement::get_mangled_name(void) const
   {
     return SgName ("__import__");
   }

const SgExpressionPtrList &
SgImportStatement::get_import_list() const
   {
     return p_import_list;
   }

SgExpressionPtrList &
SgImportStatement::get_import_list()
   {
     return p_import_list;
   }

SOURCE_IMPORT_STATEMENT_END

SOURCE_ASSOCIATE_STATEMENT_START

void
SgAssociateStatement::post_construction_initialization()
   {}

SgName
SgAssociateStatement::get_mangled_name(void) const
   {
     return SgName ("__associate__");
   }

void
SgAssociateStatement::prepend_associate(SgDeclarationStatement *what)
   {
     get_associates().insert(get_associates().begin(), what);
     what->set_parent(this);
     ROSE_ASSERT(what->get_parent() != NULL);
   }

void
SgAssociateStatement::append_associate(SgDeclarationStatement *what)
   {
     get_associates().push_back(what);
     what->set_parent(this);
     ROSE_ASSERT(what->get_parent() != NULL);
   }
SOURCE_ASSOCIATE_STATEMENT_END


SOURCE_FORMAT_STATEMENT_START

void
SgFormatStatement::post_construction_initialization()
   {}

SgName
SgFormatStatement::get_mangled_name(void) const
   {
     return SgName ("__format__");
   }

SOURCE_FORMAT_STATEMENT_END


SOURCE_FORTRAN_INCLUDE_LINE_START

SgName
SgFortranIncludeLine::get_mangled_name(void) const
   {
     return SgName ("__fortran_include_line__");
   }

SOURCE_FORTRAN_INCLUDE_LINE_END


SOURCE_JOVIAL_DEFINE_DECLARATION_START

void
SgJovialDefineDeclaration::post_construction_initialization()
   {
   }

SgName SgJovialDefineDeclaration::get_mangled_name() const
   {
     return "__jovial_language_directive__";
   }

SOURCE_JOVIAL_DEFINE_DECLARATION_END

SOURCE_JOVIAL_DIRECTIVE_STATEMENT_START

void
SgJovialDirectiveStatement::post_construction_initialization()
   {
   }

SgName SgJovialDirectiveStatement::get_mangled_name() const
   {
     return "__jovial_language_directive__";
   }

SOURCE_JOVIAL_DIRECTIVE_STATEMENT_END

SOURCE_JOVIAL_LABEL_DECLARATION_START

void
SgJovialLabelDeclaration::post_construction_initialization()
   {
   }

SgName
SgJovialLabelDeclaration::get_mangled_name(void) const
   {
     return get_label();
   }

SOURCE_JOVIAL_LABEL_DECLARATION_END

SOURCE_JOVIAL_OVERLAY_DECLARATION_START
void
SgJovialOverlayDeclaration::post_construction_initialization()
   {
   }

SgName SgJovialOverlayDeclaration::get_mangled_name() const
   {
     return SgName{"__jovial_overlay_declaration__"};
   }
SOURCE_JOVIAL_OVERLAY_DECLARATION_END


SOURCE_PREPROCESSOR_DIRECTIVE_STATEMENT_START

void
SgC_PreprocessorDirectiveStatement::post_construction_initialization()
   {
   }

// DQ (11/29/2008): Added for uniform support of mangled names
SgName SgC_PreprocessorDirectiveStatement::get_mangled_name() const
   {
     return "__c_language_preprocessor_directive__";
   }

SOURCE_PREPROCESSOR_DIRECTIVE_STATEMENT_END


SOURCE_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_START
SOURCE_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT_END

HEADER_OMP_PARALLEL_STATEMENT_START

HEADER_OMP_PARALLEL_STATEMENT_END

SOURCE_OMP_PARALLEL_STATEMENT_START
void
SgOmpParallelStatement::post_construction_initialization()
   {}
SOURCE_OMP_PARALLEL_STATEMENT_END

SOURCE_OMP_MASTER_STATEMENT_START
void
SgOmpMasterStatement::post_construction_initialization()
   {}
SOURCE_OMP_MASTER_STATEMENT_END


SOURCE_OMP_FLUSH_STATEMENT_START
void
SgOmpFlushStatement::post_construction_initialization()
   {}
SOURCE_OMP_FLUSH_STATEMENT_END

HEADER_OMP_DECLARE_SIMD_STATEMENT_START
//! Required for any declaration statement
     virtual SgName get_mangled_name(void) const override;
HEADER_OMP_DECLARE_SIMD_STATEMENT_END

SOURCE_OMP_DECLARE_SIMD_STATEMENT_START
void
SgOmpDeclareSimdStatement::post_construction_initialization()
   {}

SgName
SgOmpDeclareSimdStatement::get_mangled_name(void) const
   {
     SgName returnName;
       // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     returnName = scope->get_mangled_name() + SgName("_omp_declaration_simd_");
      //TODO: need more unique name adding clauses, followed function, etc.
     return returnName;
   }

SOURCE_OMP_DECLARE_SIMD_STATEMENT_END

SOURCE_OMP_DO_STATEMENT_START
void
SgOmpDoStatement::post_construction_initialization()
   {}
SOURCE_OMP_DO_STATEMENT_END


SOURCE_OMP_SINGLE_STATEMENT_START
void
SgOmpSingleStatement::post_construction_initialization()
   {}
SOURCE_OMP_SINGLE_STATEMENT_END


SOURCE_OMP_CRITICAL_STATEMENT_START
void
SgOmpCriticalStatement::post_construction_initialization()
   {}
SOURCE_OMP_CRITICAL_STATEMENT_END

HEADER_OMP_THREADPRIVATE_STATEMENT_START
 //! Required for any declaration statement
     virtual SgName get_mangled_name(void) const override;
HEADER_OMP_THREADPRIVATE_STATEMENT_END

SOURCE_OMP_THREADPRIVATE_STATEMENT_START
void
SgOmpThreadprivateStatement::post_construction_initialization()
   {}

SgName
SgOmpThreadprivateStatement::get_mangled_name(void) const
   {
     SgName returnName;

  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName variableNames;
     SgVarRefExpPtrList::const_iterator p = get_variables().begin();
     while ( p != get_variables().end() )
        {
          ROSE_ASSERT ((*p)->get_symbol() != NULL);
          SgVariableSymbol * sym = isSgVariableSymbol ((*p)->get_symbol());
          ROSE_ASSERT (sym != NULL);
          ROSE_ASSERT (sym->get_declaration() != NULL);
          variableNames += SgName("_variable_type_") + (*p)->get_symbol()->get_type()->get_mangled() +
                        SgName("_variable_name_") + sym->get_declaration()->get_mangled_name();

          p++;
        }
     returnName = scope->get_mangled_name() + SgName("_omp_threadprivate_declaration_") + variableNames;

     return returnName;
   }

SOURCE_OMP_THREADPRIVATE_STATEMENT_END


SOURCE_OMP_SECTIONS_STATEMENT_START
void
SgOmpSectionsStatement::post_construction_initialization()
   {}
SOURCE_OMP_SECTIONS_STATEMENT_END

SOURCE_OMP_TARGET_STATEMENT_START
void
SgOmpTargetStatement::post_construction_initialization()
   {}
SOURCE_OMP_TARGET_STATEMENT_END

SOURCE_OMP_TARGET_DATA_STATEMENT_START
void
SgOmpTargetDataStatement::post_construction_initialization()
   {}
SOURCE_OMP_TARGET_DATA_STATEMENT_END


SOURCE_OMP_TASKWAIT_STATEMENT_START
void
SgOmpTaskwaitStatement::post_construction_initialization()
   {}
SOURCE_OMP_TASKWAIT_STATEMENT_END

SOURCE_OMP_ATOMIC_STATEMENT_START
void
SgOmpAtomicStatement::post_construction_initialization()
   {}
SOURCE_OMP_ATOMIC_STATEMENT_END



SOURCE_OMP_ORDERED_STATEMENT_START
void
SgOmpOrderedStatement::post_construction_initialization()
   {}
SOURCE_OMP_ORDERED_STATEMENT_END


SOURCE_OMP_WORKSHARE_STATEMENT_START
void
SgOmpWorkshareStatement::post_construction_initialization()
   {}
SOURCE_OMP_WORKSHARE_STATEMENT_END


SOURCE_OMP_FOR_STATEMENT_START
void
SgOmpForStatement::post_construction_initialization()
   {}
SOURCE_OMP_FOR_STATEMENT_END

SOURCE_OMP_FOR_SIMD_STATEMENT_START
void
SgOmpForSimdStatement::post_construction_initialization()
   {}
SOURCE_OMP_FOR_SIMD_STATEMENT_END



SOURCE_OMP_SECTION_STATEMENT_START
void
SgOmpSectionStatement::post_construction_initialization()
   {}
SOURCE_OMP_SECTION_STATEMENT_END


SOURCE_OMP_TASK_STATEMENT_START
void
SgOmpTaskStatement::post_construction_initialization()
   {}
SOURCE_OMP_TASK_STATEMENT_END

HEADER_OMP_BODY_STATEMENT_START
      virtual bool replace_child(SgStatement *,SgStatement *, bool extractListFromBasicBlock = false) override;

      public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
      virtual unsigned int cfgIndexForEnd() const override;
      virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
      virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_OMP_BODY_STATEMENT_END

SOURCE_OMP_BODY_STATEMENT_START
void
SgOmpBodyStatement::post_construction_initialization()
   {}

bool
SgOmpBodyStatement::replace_child(SgStatement *target,SgStatement *newstmt, bool extractBasicBlock)
   {
     return ( StatementReplace(this, p_body, target, newstmt) == true );
   }
SOURCE_OMP_BODY_STATEMENT_END


HEADER_OMP_CLAUSEBODY_STATEMENT_START
      public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
      virtual unsigned int cfgIndexForEnd() const override;
      virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
      virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_OMP_CLAUSEBODY_STATEMENT_END

SOURCE_OMP_CLAUSEBODY_STATEMENT_START
void
SgOmpClauseBodyStatement::post_construction_initialization()
   {}
SOURCE_OMP_CLAUSEBODY_STATEMENT_END


SOURCE_OMP_BARRIER_STATEMENT_START
void
SgOmpBarrierStatement::post_construction_initialization()
   {}
SOURCE_OMP_BARRIER_STATEMENT_END

// FMZ (2/3/2009): Added for co-array fortran "withteam" stmt
HEADER_WITH_TEAM_STATEMENT_START

HEADER_WITH_TEAM_STATEMENT_END

SOURCE_WITH_TEAM_STATEMEMT_START
void
SgCAFWithTeamStatement::post_construction_initialization()
{
}

SOURCE_WITH_TEAM_STATEMEMT_END

SOURCE_JAVA_IMPORT_STATEMENT_START

void
SgJavaImportStatement::post_construction_initialization()
   {
  // Nothing to setup here.
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgJavaImportStatement::get_mangled_name(void) const
   {
  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName("_java_import_stmt_") + get_path();

     if (get_containsWildCard() == true)
        {
          returnName += "_dot_regx_star_";
        }

#if 0
     printf ("In SgJavaImportStatement::get_mangled_name(void): scope = %p = %s scope->get_qualified_name() = %s returnName = %s \n",
          scope,scope->class_name().c_str(),scope->get_qualified_name().str(),returnName.str());
#endif

     return returnName;
   }

SOURCE_JAVA_IMPORT_STATEMENT_END

SOURCE_JAVA_PACKAGE_DECLARATION_START
void
SgJavaPackageDeclaration::post_construction_initialization()
   {
     // Nothing to setup here.
   }

SgName
SgJavaPackageDeclaration::get_mangled_name() const
   {
     return SgName("_package_" + SgClassDeclaration::get_mangled_name()); // PC: 06/21/2013
   }
SOURCE_JAVA_PACKAGE_DECLARATION_END

SOURCE_JAVA_PACKAGE_STATEMENT_START
void
SgJavaPackageStatement::post_construction_initialization()
   {
     // Nothing to setup here.
   }

// DQ (2/18/2006): Added general name mangling for all declarations (and some other IR nodes).
SgName
SgJavaPackageStatement::get_mangled_name(void) const
   {
  // The semantics of get_scope is that it can never be NULL (SgGlobal returns itself as its scope!)
     SgScopeStatement* scope = get_scope();
     ROSE_ASSERT(scope != NULL);

     SgName returnName = SgName("_java_package_stmt_") + get_name();

     return returnName;
   }

SOURCE_JAVA_PACKAGE_STATEMENT_END

SOURCE_OMP_SIMD_STATEMENT_START
void
SgOmpSimdStatement::post_construction_initialization()
   {}
SOURCE_OMP_SIMD_STATEMENT_END


SOURCE_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT_START

void
SgMicrosoftAttributeDeclaration::post_construction_initialization()
   {
  // Not sure we have to do anything here!
   }

// We need this to be defined to avoid calling the base class version (which is an error).
SgName
SgMicrosoftAttributeDeclaration::get_mangled_name() const
   {
  // Not sure we have to do anything here!

#if 0
     printf ("Exiting as a test! (SgMicrosoftAttributeDeclaration::get_mangled_name() not implemented) \n");
     ROSE_ASSERT(false);
#endif

     return "microsoft_attribute";
   }

bool
SgMicrosoftAttributeDeclaration::hasExplicitScope() const
   {
  // This function reports that this IR node does NOT store its scope explicitly.
     return false;
   }
SOURCE_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT_END

// Ada support
// - packages

SOURCE_ADA_PACKAGE_SPEC_DECL_STATEMENT_START
void SgAdaPackageSpecDecl::post_construction_initialization() {}

SgSymbol*
SgAdaPackageSpecDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaPackageSpecDecl::get_mangled_name() const
{
  std::string name = "ada$pkg$";

  name.append(get_name());
  return name;
}

SgName
SgAdaPackageSpecDecl::get_qualified_name() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}

bool SgAdaPackageSpecDecl::hasExplicitScope() const { return true; }

SOURCE_ADA_PACKAGE_SPEC_DECL_STATEMENT_END

SOURCE_ADA_PACKAGE_BODY_DECL_STATEMENT_START
// PP implement header declarations (currently empty)
void SgAdaPackageBodyDecl::post_construction_initialization() {}

SgSymbol*
SgAdaPackageBodyDecl::get_symbol_from_symbol_table() const
{
/*
  PP (04/16/21)
  Package bodies do not have their own symbol currently,
  as a body must have seen the spec.
  ==> Return the spec's symbol.

  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
*/
  SgAdaPackageSpecDecl* specdecl = get_spec();
  ROSE_ASSERT(specdecl);

  return specdecl->search_for_symbol_from_symbol_table();
}

SgName
SgAdaPackageBodyDecl::get_mangled_name() const
{
  std::string name = "ada$pkg$";

  name.append(get_name());
  return name;
}

SgName
SgAdaPackageBodyDecl::get_qualified_name() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}

bool SgAdaPackageBodyDecl::hasExplicitScope() const { return true; }

SOURCE_ADA_PACKAGE_BODY_DECL_STATEMENT_END

SOURCE_ADA_PACKAGE_SPEC_STATEMENT_START
void SgAdaPackageSpec::post_construction_initialization() {}

SgName
SgAdaPackageSpec::get_mangled_name() const
{
  std::stringstream manglr;

  manglr << "ada$pkg$spec$" << this;
  return manglr.str();
}

SgName
SgAdaPackageSpec::get_qualified_name() const
{
  SgAdaPackageSpecDecl* decl = isSgAdaPackageSpecDecl(get_parent());

  ROSE_ASSERT(decl);
  return decl->get_qualified_name();
}

bool
SgAdaPackageSpec::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaPackageSpec::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
}


SOURCE_ADA_PACKAGE_SPEC_STATEMENT_END

SOURCE_ADA_PACKAGE_BODY_STATEMENT_START
void SgAdaPackageBody::post_construction_initialization() {}

SgName
SgAdaPackageBody::get_mangled_name() const
{
  return "ada$pkg$body";
}

SgName
SgAdaPackageBody::get_qualified_name() const
{
  SgAdaPackageBodyDecl* decl = isSgAdaPackageBodyDecl(get_parent());

  ROSE_ASSERT(decl);
  return decl->get_qualified_name();
}


bool
SgAdaPackageBody::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaPackageBody::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_PACKAGE_BODY_STATEMENT_END

SOURCE_ADA_GENERIC_DECL_START
void SgAdaGenericDecl::post_construction_initialization() {}

SgSymbol*
SgAdaGenericDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaGenericDecl::get_mangled_name() const
{
  std::string mangled = "ada$<>$decl";

  mangled += get_name();
  return mangled;
}

SgName
SgAdaGenericDecl::get_qualified_name() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}

bool SgAdaGenericDecl::hasExplicitScope() const { return true; }
SOURCE_ADA_GENERIC_DECL_END

SOURCE_ADA_GENERIC_INSTANCE_DECL_START
void SgAdaGenericInstanceDecl::post_construction_initialization() {}

SgSymbol*
SgAdaGenericInstanceDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ASSERT_not_null(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaGenericInstanceDecl::get_mangled_name() const
{
  std::string mangled = "ada$<I>$decl";

  mangled += get_name();
  return mangled;
}

SgName
SgAdaGenericInstanceDecl::get_qualified_name() const
{
  SgScopeStatement* scope = get_scope();

  ASSERT_not_null(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}

bool SgAdaGenericInstanceDecl::hasExplicitScope() const { return true; }
SOURCE_ADA_GENERIC_INSTANCE_DECL_END

SOURCE_ADA_FORMAL_TYPE_DECL_STATEMENT_START
void SgAdaFormalTypeDecl::post_construction_initialization()
{
  set_type(SgAdaFormalType::createType(this));
}

SgSymbol*
SgAdaFormalTypeDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaFormalTypeDecl::get_mangled_name() const
{
  std::string mangled = "ada$formal$type$";

  mangled += get_name();
  return mangled;
}

SgName
SgAdaFormalTypeDecl::get_qualified_name() const
{
  SgScopeStatement* scope = SageInterface::getEnclosingScope(const_cast<SgAdaFormalTypeDecl*>(this));

  ASSERT_not_null(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}

bool SgAdaFormalTypeDecl::hasExplicitScope() const { return true; }
SOURCE_ADA_FORMAL_TYPE_DECL_STATEMENT_END

SOURCE_ADA_FORMAL_PACKAGE_DECL_STATEMENT_START
void SgAdaFormalPackageDecl::post_construction_initialization() {}

SgSymbol* SgAdaFormalPackageDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName SgAdaFormalPackageDecl::get_mangled_name() const
{
  std::string mangled = "ada$formal$pkg$";

  mangled += get_name();
  return mangled;
}

SgName SgAdaFormalPackageDecl::get_qualified_name() const
{
  SgScopeStatement* scope = get_scope();

  ASSERT_not_null(scope);
  return SgName::assembleQualifiedName(scope->get_qualified_name(), get_name());
}
SOURCE_ADA_FORMAL_PACKAGE_DECL_STATEMENT_END


SOURCE_ADA_GENERIC_DEFN_START
void SgAdaGenericDefn::post_construction_initialization() {}

SgName
SgAdaGenericDefn::get_mangled_name() const
{
  return "ada$generic$defn";
}

SgName
SgAdaGenericDefn::get_qualified_name() const
{
  SgAdaGenericDecl* decl = isSgAdaGenericDecl(get_parent());

  ROSE_ASSERT(decl);
  return decl->get_qualified_name();
}

bool
SgAdaGenericDefn::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaGenericDefn::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_GENERIC_DEFN_END


// - tasks

SOURCE_ADA_TASK_SPEC_DECL_STATEMENT_START
void SgAdaTaskSpecDecl::post_construction_initialization()
{
  set_type(SgAdaTaskType::createType(this));
}

SgSymbol*
SgAdaTaskSpecDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaTaskSpecDecl::get_mangled_name() const
{
  std::string name = "ada$tsk$";

  name.append(get_name());
  return name;
}

SOURCE_ADA_TASK_SPEC_DECL_STATEMENT_END

SOURCE_ADA_TASK_TYPE_DECL_STATEMENT_START
void SgAdaTaskTypeDecl::post_construction_initialization()
{
  set_type(SgAdaTaskType::createType(this));
}

SgSymbol*
SgAdaTaskTypeDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaTaskTypeDecl::get_mangled_name() const
{
  static const std::string name = "$ada$tsk$";

  SgScopeStatement* scope = get_scope();
  ROSE_ASSERT(scope != NULL);

  return scope->get_mangled_name() + name + get_name();
}

bool SgAdaTaskTypeDecl::hasExplicitScope() const { return true; }

SOURCE_ADA_TASK_TYPE_DECL_STATEMENT_END

SOURCE_ADA_TASK_BODY_DECL_STATEMENT_START
void SgAdaTaskBodyDecl::post_construction_initialization() {}

SgSymbol*
SgAdaTaskBodyDecl::get_symbol_from_symbol_table() const
{
/*
  PP (9/16/22)
  Package bodies do not have their own symbol currently,
  as a body must have seen the spec.
  ==> Return the specificationDeclaration's
*/
  SgDeclarationStatement* specdecl = get_specificationDeclaration();
  ROSE_ASSERT(specdecl);

  return specdecl->search_for_symbol_from_symbol_table();
}

SgName
SgAdaTaskBodyDecl::get_mangled_name() const
{
  std::string name = "ada$tsk$";

  name.append(get_name());
  return name;
}

void SgAdaTaskBodyDecl::set_scope(SgScopeStatement*) { /* should this be an error? */ }

SgScopeStatement* SgAdaTaskBodyDecl::get_scope() const
{
  SgDeclarationStatement* specdecl = get_specificationDeclaration();
  ROSE_ASSERT(specdecl);

  return specdecl->get_scope();
}

SOURCE_ADA_TASK_BODY_DECL_STATEMENT_END


// - protected

SOURCE_ADA_PROTECTED_SPEC_DECL_STATEMENT_START
void SgAdaProtectedSpecDecl::post_construction_initialization()
{
  set_type(SgAdaProtectedType::createType(this));
}

SgSymbol*
SgAdaProtectedSpecDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaProtectedSpecDecl::get_mangled_name() const
{
  std::string name = "ada$prtctd$";

  name.append(get_name());
  return name;
}

SOURCE_ADA_PROTECTED_SPEC_DECL_STATEMENT_END

SOURCE_ADA_PROTECTED_TYPE_DECL_STATEMENT_START
void SgAdaProtectedTypeDecl::post_construction_initialization()
{
  set_type(SgAdaProtectedType::createType(this));
}

SgSymbol*
SgAdaProtectedTypeDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaProtectedTypeDecl::get_mangled_name() const
{
  static const std::string name = "$ada$prot$";

  SgScopeStatement* scope = get_scope();
  ROSE_ASSERT(scope != NULL);

  return scope->get_mangled_name() + name + get_name();
}

bool SgAdaProtectedTypeDecl::hasExplicitScope() const { return true; }

SOURCE_ADA_PROTECTED_TYPE_DECL_STATEMENT_END

SOURCE_ADA_PROTECTED_BODY_DECL_STATEMENT_START
void SgAdaProtectedBodyDecl::post_construction_initialization() {}

SgSymbol*
SgAdaProtectedBodyDecl::get_symbol_from_symbol_table() const
{
/*
  PP (1/11/22)
  Protected bodies do not have their own symbol currently,
  as a body must have seen the spec.
  ==> Return the spec's symbol.
  see also SgAdaPackageBodyDecl::get_symbol_from_symbol_table

  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
*/

  SgDeclarationStatement* specdecl = get_specificationDeclaration();
  ROSE_ASSERT(specdecl);

  return specdecl->search_for_symbol_from_symbol_table();
}

SgName
SgAdaProtectedBodyDecl::get_mangled_name() const
{
  std::string name = "ada$prtctd$";

  name.append(get_name());
  return name;
}

void SgAdaProtectedBodyDecl::set_scope(SgScopeStatement*) { /* should this be an error? */ }

SgScopeStatement* SgAdaProtectedBodyDecl::get_scope() const
{
  SgDeclarationStatement* specdecl = get_specificationDeclaration();
  ROSE_ASSERT(specdecl);

  return specdecl->get_scope();
}

SOURCE_ADA_PROTECTED_BODY_DECL_STATEMENT_END



SOURCE_ADA_SELECT_STATEMENT_START

void SgAdaSelectStmt::post_construction_initialization() {}

SOURCE_ADA_SELECT_STATEMENT_END


SOURCE_ADA_SELECT_ALTERNATIVE_STATEMENT_START

void SgAdaSelectAlternativeStmt::post_construction_initialization() {}

SOURCE_ADA_SELECT_ALTERNATIVE_STATEMENT_END


SOURCE_ADA_TERMINATE_STATEMENT_START
void SgAdaTerminateStmt::post_construction_initialization() {}
SOURCE_ADA_TERMINATE_STATEMENT_END

SOURCE_ADA_VARIANT_WHEN_STMT_START
void SgAdaVariantWhenStmt::post_construction_initialization() {}
SOURCE_ADA_VARIANT_WHEN_STMT_END

SOURCE_ADA_UNSCOPED_BLOCK_START
void
SgAdaUnscopedBlock::post_construction_initialization() {}

void
SgAdaUnscopedBlock::append_statement(SgStatement* element)
{
  get_statements().push_back(element);
}

void
SgAdaUnscopedBlock::prepend_statement(SgStatement* element)
{
  get_statements().insert(get_statements().begin(), element);
}

SOURCE_ADA_UNSCOPED_BLOCK_END

SOURCE_ADA_RENAMING_DECL_STATEMENT_START
void SgAdaRenamingDecl::post_construction_initialization() {}

SgSymbol*
SgAdaRenamingDecl::get_symbol_from_symbol_table() const
{
  SgScopeStatement* scope = get_scope();

  ROSE_ASSERT(scope);
  return scope->find_symbol_from_declaration(this);
}

SgName
SgAdaRenamingDecl::get_mangled_name() const
{
  std::string name = "ada$ren$";

  name.append(get_name());
  return name;
}
SOURCE_ADA_RENAMING_DECL_STATEMENT_END

SOURCE_ADA_VARIANT_DECL_START
void
SgAdaVariantDecl::post_construction_initialization() {}

SgName
SgAdaVariantDecl::get_mangled_name() const
{
  std::stringstream ns;

  ns << "ada$variantswitch$" << this;
  return SgName(ns.str());
}

SgSymbol*
SgAdaVariantDecl::get_symbol_from_symbol_table() const
{
  return nullptr; // FIXME \todo PP: what else?
}


SOURCE_ADA_VARIANT_DECL_END


SOURCE_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT_START
void SgAdaDiscriminatedTypeDecl::post_construction_initialization()
{
  set_type(SgAdaDiscriminatedType::createType(this));
}

SgSymbol*
SgAdaDiscriminatedTypeDecl::get_symbol_from_symbol_table() const
{
  // SgScopeStatement* scope = get_scope();
  // ROSE_ASSERT(scope);
  // return scope->find_symbol_from_declaration(this);

  // or:
  // return nullptr;

  SgDeclarationStatement* child = get_discriminatedDecl();
  ROSE_ASSERT(child);

  return child->get_symbol_from_symbol_table();
}

SgName
SgAdaDiscriminatedTypeDecl::get_mangled_name() const
{
  static const std::string name = "ada$disc$";

  SgScopeStatement* scope = get_scope();
  ROSE_ASSERT(scope != NULL);

  SgDeclarationStatement* child = get_discriminatedDecl();
  ROSE_ASSERT(child);

  return scope->get_mangled_name() + name + child->get_mangled_name();
}

SOURCE_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT_END


HEADER_ADA_REPRESENTATION_CLAUSE_START

// HEADER_LIST_DECLARATIONS

SgName get_mangled_name() const override;

/// returns if this node is a record representation clause
/// \details
///   a record representation clause has get_components() != nullptr
bool isRecordRepresentationClause() const;

/// returns if this is an at clause
/// \details
///   a at clause has get_components() == nullptr
bool isAtClause() const;

HEADER_ADA_REPRESENTATION_CLAUSE_END

SOURCE_ADA_REPRESENTATION_CLAUSE_START
void SgAdaRepresentationClause::post_construction_initialization() {}

SgName
SgAdaRepresentationClause::get_mangled_name() const
{
  std::string res = "ada$rep$clause";

  res += get_recordType()->get_mangled();
  return res;
}

bool SgAdaRepresentationClause::isRecordRepresentationClause() const
{
  return get_components() != nullptr;
}

bool SgAdaRepresentationClause::isAtClause() const
{
  return !isRecordRepresentationClause();
}


SOURCE_ADA_REPRESENTATION_CLAUSE_END

HEADER_ADA_ENUM_REPRESENTATION_CLAUSE_START

SgName get_mangled_name() const override;

HEADER_ADA_ENUM_REPRESENTATION_CLAUSE_END

SOURCE_ADA_ENUM_REPRESENTATION_CLAUSE_START
void SgAdaEnumRepresentationClause::post_construction_initialization() {}

SgName
SgAdaEnumRepresentationClause::get_mangled_name() const
{
  std::string res = "ada$enumrep$clause";

  res += get_enumType()->get_mangled();
  return res;
}

SOURCE_ADA_ENUM_REPRESENTATION_CLAUSE_END


SOURCE_ADA_ATTRIBUTE_CLAUSE_START
void SgAdaAttributeClause::post_construction_initialization() {}

SgName
SgAdaAttributeClause::get_mangled_name() const
{
  std::string res = "ada$length$clause";

  res += get_attribute()->unparseToString();
  return res;
}
SOURCE_ADA_ATTRIBUTE_CLAUSE_END

SOURCE_ADA_COMPONENT_CLAUSE_START
void SgAdaComponentClause::post_construction_initialization() {};

SgName
SgAdaComponentClause::get_mangled_name () const
{
  ROSE_ASSERT(get_range() && get_offset() && get_component());

  SgExpression* lb = get_range()->get_start();
  SgExpression* ub = get_range()->get_end();

  ROSE_ASSERT(lb && ub);

  std::string res("ada$component$clause");

  res += get_component()->unparseToString();
  res += "at ";
  res += get_offset()->unparseToString();
  res += ": ";
  res += lb->unparseToString();
  res += "..";
  res += ub->unparseToString();

  return res;
}

SOURCE_ADA_COMPONENT_CLAUSE_END

// - tasks

SOURCE_ADA_TASK_SPEC_STATEMENT_START
void SgAdaTaskSpec::post_construction_initialization() {}

SgName
SgAdaTaskSpec::get_mangled_name() const
{
  return "ada$tsk$spec";
}

bool
SgAdaTaskSpec::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaTaskSpec::replace_child(SgStatement* target, SgStatement* newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_TASK_SPEC_STATEMENT_END

SOURCE_ADA_TASK_BODY_STATEMENT_START
void SgAdaTaskBody::post_construction_initialization() {}

SgName
SgAdaTaskBody::get_mangled_name() const
{
  return "ada$tsk$body";
}

bool
SgAdaTaskBody::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaTaskBody::replace_child(SgStatement* target, SgStatement* newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_TASK_BODY_STATEMENT_END

// - protected objects

SOURCE_ADA_PROTECTED_SPEC_STATEMENT_START
void SgAdaProtectedSpec::post_construction_initialization() {}

SgName
SgAdaProtectedSpec::get_mangled_name() const
{
  return "ada$prtctd$spec";
}

bool
SgAdaProtectedSpec::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaProtectedSpec::replace_child(SgStatement *target ,SgStatement * newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, get_declarations(), target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_PROTECTED_SPEC_STATEMENT_END

SOURCE_ADA_PROTECTED_BODY_STATEMENT_START
void SgAdaProtectedBody::post_construction_initialization() {}

SgName
SgAdaProtectedBody::get_mangled_name() const
{
  return "ada$prtctd$body";
}

bool
SgAdaProtectedBody::insert_child(SgStatement* target, SgStatement* newstmt, bool inFront, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, inFront, extractBasicBlock, false);
}

bool
SgAdaProtectedBody::replace_child(SgStatement* target, SgStatement* newstmt, bool extractBasicBlock)
{
  return StatementListInsertChild(this, p_statements, target, newstmt, true, extractBasicBlock, true);
}

SOURCE_ADA_PROTECTED_BODY_STATEMENT_END
