//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This file was generated with ROSE's "rosebud" tool by reading node definitions written in a
// C++-like language and emitting this ROSETTA input.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE MANUALLY!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <featureTests.h>
#if defined(ROSE_ENABLE_BINARY_ANALYSIS)
#include "ROSETTA_macros.h"
#include "grammar.h"
#include "AstNodeClass.h"

//#undef DOCUMENTATION -- commented out so IDEs can't figure it out
#ifdef DOCUMENTATION
DOCUMENTATION_should_never_be_defined;
#endif

#ifdef DOCUMENTATION
#define DECLARE_LEAF_CLASS(CLASS_WITHOUT_Sg) /*void*/
#define DECLARE_LEAF_CLASS2(CLASS_WITHOUT_Sg, TAG) /*void*/
#else
#define DECLARE_LEAF_CLASS(CLASS_WITHOUT_Sg) \
    NEW_TERMINAL_MACRO(CLASS_WITHOUT_Sg, #CLASS_WITHOUT_Sg, #CLASS_WITHOUT_Sg "Tag"); \
    CLASS_WITHOUT_Sg.setCppCondition("!defined(DOCUMENTATION)");\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfConstructor(false);\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfDestructor(false)
#define DECLARE_LEAF_CLASS2(CLASS_WITHOUT_Sg, TAG) \
    NEW_TERMINAL_MACRO(CLASS_WITHOUT_Sg, #CLASS_WITHOUT_Sg, #TAG); \
    CLASS_WITHOUT_Sg.setCppCondition("!defined(DOCUMENTATION)");\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfConstructor(false);\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfDestructor(false)
#endif

#ifdef DOCUMENTATION
#define DECLARE_HEADERS(CLASS_WITHOUT_Sg) /*void*/
#else
#define DECLARE_HEADERS(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.setPredeclarationString("Sg" #CLASS_WITHOUT_Sg "_HEADERS", \
                          ROSE_AUTOMAKE_ABSOLUTE_PATH_TOP_SRCDIR + "/src/ROSETTA/src/binaryInstruction.C")
#endif

#ifdef DOCUMENTATION
#define DECLARE_OTHERS(CLASS_WITHOUT_Sg) /*void*/
#else
#define DECLARE_OTHERS(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.setFunctionPrototype("Sg" #CLASS_WITHOUT_Sg "_OTHERS", \
                          ROSE_AUTOMAKE_ABSOLUTE_PATH_TOP_SRCDIR + "/src/ROSETTA/src/binaryInstruction.C")
#endif

#ifdef DOCUMENTATION
#define IS_SERIALIZABLE() /*void*/
#else
#define IS_SERIALIZABLE(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.isBoostSerializable(true)
#endif


// Since ROSETTA builds classes from the leaves up to the base, and C++ builds classes from the
// base down to the leaves, we need to make sure that doxygen sees the base classes before the derived classes. So
// just list all the non-leaf classes here.
#ifdef DOCUMENTATION
class SgAsmBinaryExpression;
class SgAsmCilDataStream;
class SgAsmCilMetadata;
class SgAsmCilNode;
class SgAsmConstantExpression;
class SgAsmDwarfConstruct;
class SgAsmDwarfInformation;
class SgAsmElfSection;
class SgAsmExecutableFileFormat;
class SgAsmExpression;
class SgAsmGenericHeader;
class SgAsmGenericSection;
class SgAsmGenericString;
class SgAsmGenericStrtab;
class SgAsmGenericSymbol;
class SgAsmInstruction;
class SgAsmJvmAttribute;
class SgAsmJvmNode;
class SgAsmNode;
class SgAsmPESection;
class SgAsmRegisterReferenceExpression;
class SgAsmScalarType;
class SgAsmStatement;
class SgAsmSynthesizedDeclaration;
class SgAsmType;
class SgAsmUnaryExpression;
class SgAsmValueExpression;
class SgNode;
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
void Grammar::setUpBinaryInstructions() {
#endif // !DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmX86Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmX86Instruction);
IS_SERIALIZABLE(AsmX86Instruction);

#ifndef DOCUMENTATION
AsmX86Instruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmX86Instruction);
#if defined(SgAsmX86Instruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/BasicTypes.h>
#include <Rose/BinaryAnalysis/InstructionEnumsX86.h>
#endif // SgAsmX86Instruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one Intel x86 machine instruction. */
class SgAsmX86Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionKind", "kind", "= Rose::BinaryAnalysis::x86_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "baseSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "operandSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "addressSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "bool", "lockPrefix", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86RepeatPrefix", "repeatPrefix", "= Rose::BinaryAnalysis::x86_repeat_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86BranchPrediction", "branchPrediction", "= Rose::BinaryAnalysis::x86_branch_prediction_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86SegmentRegister", "segmentOverride", "= Rose::BinaryAnalysis::x86_segreg_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmX86Instruction);
#if defined(SgAsmX86Instruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmX86Instruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmX86Instruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        s & BOOST_SERIALIZATION_NVP(p_baseSize);
        s & BOOST_SERIALIZATION_NVP(p_operandSize);
        s & BOOST_SERIALIZATION_NVP(p_addressSize);
        s & BOOST_SERIALIZATION_NVP(p_lockPrefix);
        s & BOOST_SERIALIZATION_NVP(p_repeatPrefix);
        s & BOOST_SERIALIZATION_NVP(p_branchPrediction);
        s & BOOST_SERIALIZATION_NVP(p_segmentOverride);
        debugSerializationEnd("SgAsmX86Instruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::X86InstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::X86InstructionKind const&);
    /** @} */

public:
    /** Property: An enum constant describing the base size of an x86 instruction. 
     * 
     * @{ */
    Rose::BinaryAnalysis::X86InstructionSize const& get_baseSize() const;
    void set_baseSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */

public:
    /** Property: An enum describing the x86 instruction operand size. 
     * 
     * @{ */
    Rose::BinaryAnalysis::X86InstructionSize const& get_operandSize() const;
    void set_operandSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */

public:
    /** Property: An enum describing the x86 address size. 
     * 
     * @{ */
    Rose::BinaryAnalysis::X86InstructionSize const& get_addressSize() const;
    void set_addressSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */

public:
    /** Property: Whether the x86 lock prefix was present.
     *
     *  Returns true if this instruction had the x86 lock prefix byte; false otherwise. 
     *  
     *  @{ */
    bool const& get_lockPrefix() const;
    void set_lockPrefix(bool const&);
    /** @} */

public:
    /** Property: An enum constant describing whether the instruction is repeated. 
     * 
     * @{ */
    Rose::BinaryAnalysis::X86RepeatPrefix const& get_repeatPrefix() const;
    void set_repeatPrefix(Rose::BinaryAnalysis::X86RepeatPrefix const&);
    /** @} */

public:
    /** Property: An enum constant describing branch prediction. 
     * 
     * @{ */
    Rose::BinaryAnalysis::X86BranchPrediction const& get_branchPrediction() const;
    void set_branchPrediction(Rose::BinaryAnalysis::X86BranchPrediction const&);
    /** @} */

public:
    /** Property: The segment override register.
     *
     *  Returns an enum describing the segment register override. Note that this is not a register descriptor, but an enum
     *  constant. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::X86SegmentRegister const& get_segmentOverride() const;
    void set_segmentOverride(Rose::BinaryAnalysis::X86SegmentRegister const&);
    /** @} */
public:
    /** Converts a size to an instruction size enum.
     *
     *  Given a size in bits, which must be 16, 32, or 64, return the corresponding enum constant. */
    static Rose::BinaryAnalysis::X86InstructionSize instructionSizeForWidth(size_t);

    /** Converts a size enum constant to a size.
     *
     *  Given a size enum constant, return the number of bits that enum represents. */
    static size_t widthForInstructionSize(Rose::BinaryAnalysis::X86InstructionSize);

    /** Return the register dictionary for an x86 architecture.
     *
     *  Given an instruction size enum constant return the register dictionary that describes the x86 architecture with
     *  the specified word size.  See also, @ref registersForWidth. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForInstructionSize(Rose::BinaryAnalysis::X86InstructionSize);

    /** Return the register dictionary for an x86 architecture.
     *
     *  Given an instruction size of 16, 32, or 64 return the register dictionary that describes the x86 architecture with
     *  the specified word size.  See also, @ref registersForInstructionSize. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForWidth(size_t);

    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmX86Instruction();

public:
    /** Default constructor. */
    SgAsmX86Instruction();

public:
    /** Constructor. */
    SgAsmX86Instruction(rose_addr_t const& address,
                        uint8_t const& architectureId,
                        Rose::BinaryAnalysis::X86InstructionKind const& kind,
                        Rose::BinaryAnalysis::X86InstructionSize const& baseSize,
                        Rose::BinaryAnalysis::X86InstructionSize const& operandSize,
                        Rose::BinaryAnalysis::X86InstructionSize const& addressSize);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmX86Instruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmVoidType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmVoidType);
IS_SERIALIZABLE(AsmVoidType);

#ifndef DOCUMENTATION
AsmVoidType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** A type that doesn't represent any data. */
class SgAsmVoidType: public SgAsmType {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmVoidType);
#if defined(SgAsmVoidType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmVoidType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmVoidType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmType);
        debugSerializationEnd("SgAsmVoidType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    static SgAsmVoidType* instance();

    virtual std::string toString() const override;
    virtual size_t get_nBits() const override;
public:
    /** Destructor. */
    virtual ~SgAsmVoidType();

public:
    /** Default constructor. */
    SgAsmVoidType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmVoidType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmVectorType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmVectorType);
IS_SERIALIZABLE(AsmVectorType);

#ifndef DOCUMENTATION
AsmVectorType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for vector types. */
class SgAsmVectorType: public SgAsmType {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmVectorType.setDataPrototype(
        "size_t", "nElmts", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmVectorType.setDataPrototype(
        "SgAsmType*", "elmtType", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmVectorType);
#if defined(SgAsmVectorType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmVectorType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmVectorType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmType);
        s & BOOST_SERIALIZATION_NVP(p_nElmts);
        s & BOOST_SERIALIZATION_NVP(p_elmtType);
        debugSerializationEnd("SgAsmVectorType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Number of elements in vector. 
     * 
     * @{ */
    /** @} */

public:
    /** Property: Type of each vector element. 
     * 
     * @{ */
    /** @} */
public:
    /** Construct a new vector type. */
    SgAsmVectorType(size_t nElmts, SgAsmType *elmtType);

    /** Property: Number of elements in vector. */
    size_t get_nElmts() const;

    /** Property: Type of each vector element. */
    SgAsmType* get_elmtType() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
    virtual size_t get_nBits() const override;
public:
    /** Destructor. */
    virtual ~SgAsmVectorType();

public:
    /** Default constructor. */
    SgAsmVectorType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmVectorType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUserInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUserInstruction);
IS_SERIALIZABLE(AsmUserInstruction);

#ifndef DOCUMENTATION
AsmUserInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Instructions defined at runtime.
 *
 *  This class describes instructions whose form is not known until runtime. Most architectures have their own instruction class
 *  derived from @ref SgAsmInstruction, but for architectures intended to be defined outside the ROSE library, we need some way
 *  to represent their decoded machine instructions. This class serves that purpose. */
class SgAsmUserInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmUserInstruction.setDataPrototype(
        "unsigned", "kind", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmUserInstruction);
#if defined(SgAsmUserInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUserInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUserInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        debugSerializationEnd("SgAsmUserInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  The instruction kind distinguishes between different kinds of instructions within a single architecture. 
     *  
     *  @{ */
    unsigned const& get_kind() const;
    void set_kind(unsigned const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmUserInstruction();

public:
    /** Default constructor. */
    SgAsmUserInstruction();

public:
    /** Constructor. */
    SgAsmUserInstruction(rose_addr_t const& address,
                         uint8_t const& architectureId,
                         unsigned const& kind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUserInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryUnsignedExtend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnaryUnsignedExtend);
IS_SERIALIZABLE(AsmUnaryUnsignedExtend);

#ifndef DOCUMENTATION
AsmUnaryUnsignedExtend.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression representing unsigned extending.
 *
 *  The size of the result is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
class SgAsmUnaryUnsignedExtend: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryUnsignedExtend);
#if defined(SgAsmUnaryUnsignedExtend_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryUnsignedExtend -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryUnsignedExtend");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnaryUnsignedExtend");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnaryUnsignedExtend();

public:
    /** Default constructor. */
    SgAsmUnaryUnsignedExtend();

public:
    /** Constructor. */
    explicit SgAsmUnaryUnsignedExtend(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryUnsignedExtend_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryTruncate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnaryTruncate);
IS_SERIALIZABLE(AsmUnaryTruncate);

#ifndef DOCUMENTATION
AsmUnaryTruncate.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression representing truncation.
 *
 *  The amount of truncation is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
class SgAsmUnaryTruncate: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryTruncate);
#if defined(SgAsmUnaryTruncate_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryTruncate -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryTruncate");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnaryTruncate");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnaryTruncate();

public:
    /** Default constructor. */
    SgAsmUnaryTruncate();

public:
    /** Constructor. */
    explicit SgAsmUnaryTruncate(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryTruncate_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnarySignedExtend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnarySignedExtend);
IS_SERIALIZABLE(AsmUnarySignedExtend);

#ifndef DOCUMENTATION
AsmUnarySignedExtend.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression representing sign extending.
 *
 *  The size of the result is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
class SgAsmUnarySignedExtend: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnarySignedExtend);
#if defined(SgAsmUnarySignedExtend_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnarySignedExtend -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnarySignedExtend");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnarySignedExtend");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnarySignedExtend();

public:
    /** Default constructor. */
    SgAsmUnarySignedExtend();

public:
    /** Constructor. */
    explicit SgAsmUnarySignedExtend(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnarySignedExtend_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryRrx           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnaryRrx);
IS_SERIALIZABLE(AsmUnaryRrx);

#ifndef DOCUMENTATION
AsmUnaryRrx.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmUnaryRrx);
#if defined(SgAsmUnaryRrx_HEADERS) || defined(DOCUMENTATION)
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmUnaryRrx_HEADERS

#ifdef DOCUMENTATION
class SgAsmUnaryRrx: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryRrx);
#if defined(SgAsmUnaryRrx_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryRrx -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryRrx");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnaryRrx");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnaryRrx();

public:
    /** Default constructor. */
    SgAsmUnaryRrx();

public:
    /** Constructor. */
    explicit SgAsmUnaryRrx(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryRrx_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryPlus           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnaryPlus);
IS_SERIALIZABLE(AsmUnaryPlus);

#ifndef DOCUMENTATION
AsmUnaryPlus.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression representing a (no-op) unary plus operation. */
class SgAsmUnaryPlus: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryPlus);
#if defined(SgAsmUnaryPlus_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryPlus -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryPlus");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnaryPlus");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnaryPlus();

public:
    /** Default constructor. */
    SgAsmUnaryPlus();

public:
    /** Constructor. */
    explicit SgAsmUnaryPlus(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryPlus_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryMinus           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmUnaryMinus);
IS_SERIALIZABLE(AsmUnaryMinus);

#ifndef DOCUMENTATION
AsmUnaryMinus.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression represting negation. */
class SgAsmUnaryMinus: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryMinus);
#if defined(SgAsmUnaryMinus_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryMinus -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryMinus");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
        debugSerializationEnd("SgAsmUnaryMinus");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmUnaryMinus();

public:
    /** Default constructor. */
    SgAsmUnaryMinus();

public:
    /** Constructor. */
    explicit SgAsmUnaryMinus(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryMinus_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmUnaryExpression = nonTerminalConstructor(
    "AsmUnaryExpression",
    *this,
    "AsmUnaryExpression",
    "AsmUnaryExpressionTag",
    SubclassListBuilder()
        | AsmUnaryMinus
        | AsmUnaryPlus
        | AsmUnaryRrx
        | AsmUnarySignedExtend
        | AsmUnaryTruncate
        | AsmUnaryUnsignedExtend
    , false);
assert(AsmUnaryExpression.associatedGrammar != nullptr);
AsmUnaryExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmUnaryExpression.isBoostSerializable(true);
AsmUnaryExpression.setAutomaticGenerationOfConstructor(false);
AsmUnaryExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmUnaryExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for unary expressions. */
class SgAsmUnaryExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmUnaryExpression.setDataPrototype(
        "SgAsmExpression*", "operand", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmUnaryExpression);
#if defined(SgAsmUnaryExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmUnaryExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmUnaryExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_operand);
        debugSerializationEnd("SgAsmUnaryExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Operand for a unary expression. 
     * 
     * @{ */
    SgAsmExpression* const& get_operand() const;
    void set_operand(SgAsmExpression* const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmUnaryExpression();

protected:
    /** Default constructor. */
    SgAsmUnaryExpression();

protected:
    /** Constructor. */
    explicit SgAsmUnaryExpression(SgAsmExpression* const& operand);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedFieldDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmSynthesizedFieldDeclaration);
IS_SERIALIZABLE(AsmSynthesizedFieldDeclaration);

#ifndef DOCUMENTATION
AsmSynthesizedFieldDeclaration.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmSynthesizedFieldDeclaration);
#if defined(SgAsmSynthesizedFieldDeclaration_HEADERS) || defined(DOCUMENTATION)
// FIXME[Robb P Matzke 2017-02-13]: what is this?
#endif // SgAsmSynthesizedFieldDeclaration_HEADERS

#ifdef DOCUMENTATION
class SgAsmSynthesizedFieldDeclaration: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmSynthesizedFieldDeclaration.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmSynthesizedFieldDeclaration.setDataPrototype(
        "uint64_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmSynthesizedFieldDeclaration);
#if defined(SgAsmSynthesizedFieldDeclaration_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmSynthesizedFieldDeclaration -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmSynthesizedFieldDeclaration");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        debugSerializationEnd("SgAsmSynthesizedFieldDeclaration");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Name. 
     * 
     * @{ */
    std::string const& get_name() const;
    void set_name(std::string const&);
    /** @} */
    // FIXME[Robb P Matzke 2017-02-13]: Is this bytes, bits, or what?
    // Not clear if we want to store the offset explicitly
public:
    /** Property: Offset. 
     * 
     * @{ */
    uint64_t const& get_offset() const;
    void set_offset(uint64_t const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedFieldDeclaration();

public:
    /** Default constructor. */
    SgAsmSynthesizedFieldDeclaration();

public:
    /** Constructor. */
    explicit SgAsmSynthesizedFieldDeclaration(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedFieldDeclaration_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedDataStructureDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmSynthesizedDataStructureDeclaration);
IS_SERIALIZABLE(AsmSynthesizedDataStructureDeclaration);

#ifndef DOCUMENTATION
AsmSynthesizedDataStructureDeclaration.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmSynthesizedDataStructureDeclaration);
#if defined(SgAsmSynthesizedDataStructureDeclaration_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmSynthesizedDataStructureDeclaration_HEADERS

#ifdef DOCUMENTATION
/** Declaration-like nodes that encapsulate multiple instructions.
 *
 *  Binary ASTs have two sides: the container side that corresponds to the ELF/PE/etc. file formats, and the interpretation
 *  side that corresponds to instructions and data from multiple sources (specimen + dynamic libraries) organized into
 *  multiple SgAsmInterpretation where each interpretation makes a coherent binary entity such as the DOS part of a PE
 *  executable.  The declaration-like nodes that follow appear on the interpretation side of the AST.  We may add other
 *  declaration nodes to the container side of the AST at a later time.
 *
 *  These interpretation-side declaration-like nodes are used by the projects/BinaryDataStructureRecognition even if they
 *  aren't used internally by ROSE. */
class SgAsmSynthesizedDataStructureDeclaration: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmSynthesizedDataStructureDeclaration);
#if defined(SgAsmSynthesizedDataStructureDeclaration_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmSynthesizedDataStructureDeclaration -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmSynthesizedDataStructureDeclaration");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
        debugSerializationEnd("SgAsmSynthesizedDataStructureDeclaration");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
protected:
      SgAsmSynthesizedDeclarationPtrList p_declarationList;

public:
    /** Appends another declaration. */
    void appendDeclaration(SgAsmSynthesizedDeclaration *declaration) {
        p_declarationList.push_back(declaration);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void append_declaration(SgAsmSynthesizedDeclaration*) ROSE_DEPRECATED("use appendDeclaration");
public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedDataStructureDeclaration();

public:
    /** Default constructor. */
    SgAsmSynthesizedDataStructureDeclaration();

public:
    /** Constructor. */
    explicit SgAsmSynthesizedDataStructureDeclaration(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedDataStructureDeclaration_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStringStorage           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmStringStorage);
IS_SERIALIZABLE(AsmStringStorage);

#ifndef DOCUMENTATION
AsmStringStorage.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Strings stored in an ELF or PE container. */
class SgAsmStringStorage: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStringStorage.setDataPrototype(
        "SgAsmGenericStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStringStorage.setDataPrototype(
        "std::string", "string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStringStorage.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmStringStorage);
#if defined(SgAsmStringStorage_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmStringStorage -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmStringStorage");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_strtab);
        s & BOOST_SERIALIZATION_NVP(p_string);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        debugSerializationEnd("SgAsmStringStorage");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: String table holding the string. 
     * 
     * @{ */
    SgAsmGenericStrtab* const& get_strtab() const;
    void set_strtab(SgAsmGenericStrtab* const&);
    /** @} */

public:
    /** Property: String value. 
     * 
     * @{ */
    std::string const& get_string() const;
    void set_string(std::string const&);
    /** @} */

public:
    /** Property: Location of string in storage table. 
     * 
     * @{ */
    rose_addr_t const& get_offset() const;
    void set_offset(rose_addr_t const&);
    /** @} */
public:
    SgAsmStringStorage(SgAsmGenericStrtab *strtab, const std::string &string, rose_addr_t offset);

    void dump(FILE *s, const char *prefix, ssize_t idx) const;

    /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are
     * used to control string allocation in ELF string tables and must only be modified by allocators in closely related
     * classes.  For instance, to change the value of the string one should call SgAsmGenericString::set_string()
     * instead. */

 private:
      friend class SgAsmStoredString;                     /*allowed to set private data members*/
      friend class SgAsmStoredStrtab;                     /*allowed to set private data members*/
public:
    /** Destructor. */
    virtual ~SgAsmStringStorage();

public:
    /** Default constructor. */
    SgAsmStringStorage();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStringStorage_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStoredString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmStoredString);
IS_SERIALIZABLE(AsmStoredString);

#ifndef DOCUMENTATION
AsmStoredString.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Strings stored in an ELF or PE container. */
class SgAsmStoredString: public SgAsmGenericString {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStoredString.setDataPrototype(
        "SgAsmStringStorage*", "storage", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmStoredString);
#if defined(SgAsmStoredString_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmStoredString -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmStoredString");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericString);
        s & BOOST_SERIALIZATION_NVP(p_storage);
        debugSerializationEnd("SgAsmStoredString");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Storage area for this string. 
     * 
     * @{ */
    SgAsmStringStorage* const& get_storage() const;
    void set_storage(SgAsmStringStorage* const&);
    /** @} */
public:
    /** Construct a string existing in a string table. */
    SgAsmStoredString(SgAsmGenericStrtab*, rose_addr_t offset);

    /** Construct a new string in a string table. */
    SgAsmStoredString(SgAsmGenericStrtab*, const std::string&);

    /** Construct a string that shares storage with another. */
    explicit SgAsmStoredString(class SgAsmStringStorage*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Returns the string table that holds this string.
     *
     *  Returns the table even if the string value isn't currently allocated in the table. */
    SgAsmGenericStrtab *get_strtab();

    /** Returns the std::string associated with the SgAsmStoredString. */
    virtual std::string get_string(bool escape=false) const override;

    /** Give the string a new value.
     *
     *  This also deallocates the previous value. */
    virtual void set_string(const std::string&) override;

    /** Give the string a new value.
     *
     *  The string is given a new value by specifying the offset of a string that already exists in the string table. */
    virtual void set_string(rose_addr_t) override;

    /** Returns the offset into the string table where the string is allocated.
     *
     *  If the string is not allocated then this call triggers an allocation. */
    virtual rose_addr_t get_offset() const override;
public:
    /** Destructor. */
    virtual ~SgAsmStoredString();

public:
    /** Default constructor. */
    SgAsmStoredString();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStoredString_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStaticData           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmStaticData);
IS_SERIALIZABLE(AsmStaticData);

#ifndef DOCUMENTATION
AsmStaticData.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmStaticData);
#if defined(SgAsmStaticData_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmStaticData_HEADERS

#ifdef DOCUMENTATION
/** Represents static data in an executable.
 *
 *  For now, we don't associate any type with the data because ROSE's data type infrastructure (source or binary) is not
 *  capable of representing the information we need: multiple interpretations of overlapping parts of memory (i.e., two or
 *  more types for the same bytes); arbitrary offsets and padding in structured types; size-specific integers and
 *  floating-point types; regions of unknown type; ease of improving type information by filling in more details as the
 *  type is discovered; etc. */
class SgAsmStaticData: public SgAsmStatement {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStaticData.setDataPrototype(
        "SgUnsignedCharList", "rawBytes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmStaticData);
#if defined(SgAsmStaticData_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmStaticData -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmStaticData");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
        s & BOOST_SERIALIZATION_NVP(p_rawBytes);
        debugSerializationEnd("SgAsmStaticData");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Raw bytes.
     *
     *  These are the raw memory bytes of static data that appear in the binary specimen. Type information is painted onto
     *  these bytes. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_rawBytes() const;
    void set_rawBytes(SgUnsignedCharList const&);
    /** @} */
public:
    /** Property: Size of static data in bytes.
     *
     *  This returns the number of raw data bytes rather than the size of any data type painted onto those bytes. */
    size_t get_size() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    const SgUnsignedCharList& get_raw_bytes() const ROSE_DEPRECATED("use get_rawBytes");
    void set_raw_bytes(const SgUnsignedCharList&) ROSE_DEPRECATED("use set_rawBytes");
public:
    /** Destructor. */
    virtual ~SgAsmStaticData();

public:
    /** Default constructor. */
    SgAsmStaticData();

public:
    /** Constructor. */
    explicit SgAsmStaticData(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStaticData_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStackExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmStackExpression);
IS_SERIALIZABLE(AsmStackExpression);

#ifndef DOCUMENTATION
AsmStackExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for references to a machine register. */
class SgAsmStackExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStackExpression.setDataPrototype(
        "int", "stackPosition", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmStackExpression);
#if defined(SgAsmStackExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmStackExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmStackExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_stackPosition);
        debugSerializationEnd("SgAsmStackExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Position of element referenced on the stack.
     *
     *  This is a value that references the values on the stack (zero is top of stack, positive numbers are the depth into the
     *  stack). 
     *  
     *  @{ */
    int const& get_stackPosition() const;
    void set_stackPosition(int const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    int get_stack_position() const ROSE_DEPRECATED("use get_stackPosition");
    void set_stack_position(int)  ROSE_DEPRECATED("use set_stackPosition");
public:
    /** Destructor. */
    virtual ~SgAsmStackExpression();

public:
    /** Default constructor. */
    SgAsmStackExpression();

public:
    /** Constructor. */
    explicit SgAsmStackExpression(int const& stackPosition);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStackExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRiscOperation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmRiscOperation);
IS_SERIALIZABLE(AsmRiscOperation);

#ifndef DOCUMENTATION
AsmRiscOperation.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmRiscOperation);
#if defined(SgAsmRiscOperation_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmRiscOperation_IMPL
#include <SgAsmExprListExp.h>
#endif
#endif // SgAsmRiscOperation_HEADERS

#ifdef DOCUMENTATION
/** Static representation of instruction semantics.
 *
 *  Instruction semantics are not added to the AST by default since this would make it very, very large.  Instead, ROSE has
 *  a non-traditional approach: instead of ROSE having C++ code to generate a data-centric representation of semantics (a
 *  tree like data structure similar to a syntax tree) and then users writing analyses on that data structure, ROSE's C++
 *  code can be hooked into directly by users via C++ class derivation. If a user really wants a data-centric view they can
 *  either have ROSE create @ref SgAsmRiscOperation nodes in the AST, or they can hook into ROSE's instruction semantics
 *  API and build whatever kind of data-centric representation that suites their need. */
class SgAsmRiscOperation: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRiscOperation.setDataPrototype(
        "SgAsmRiscOperation::RiscOperator", "riscOperator", "= OP_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRiscOperation.setDataPrototype(
        "SgAsmExprListExp*", "operands", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmRiscOperation);
#if defined(SgAsmRiscOperation_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmRiscOperation -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmRiscOperation");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_riscOperator);
        s & BOOST_SERIALIZATION_NVP(p_operands);
        debugSerializationEnd("SgAsmRiscOperation");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** One enum per RISC operator.
     *
     * The names are the same as the RISC operator.  Note that some of these operators aren't normally part of the base
     * set. For instance, "subtract" and comparison operations are usually implemented in terms of more basic operations
     * like add_, invert, and equalToZero. */
    enum RiscOperator {
        OP_NONE,
        OP_bottom,
        OP_undefined,
        OP_unspecified,
        OP_filterCallTarget,
        OP_filterReturnTarget,
        OP_filterIndirectJumpTarget,
        OP_hlt,
        OP_cpuid,
        OP_rdtsc,
        OP_and_,
        OP_or_,
        OP_xor_,
        OP_invert,
        OP_extract,
        OP_concat,
        OP_leastSignificantSetBit,
        OP_mostSignificantSetBit,
        OP_rotateLeft,
        OP_rotateRight,
        OP_shiftLeft,
        OP_shiftRight,
        OP_shiftRightArithmetic,
        OP_equalToZero,
        OP_ite,
        OP_isEqual,
        OP_isNotEqual,
        OP_isUnsignedLessThan,
        OP_isUnsignedLessThanOrEqual,
        OP_isUnsignedGreaterThan,
        OP_isUnsignedGreaterThanOrEqual,
        OP_isSignedLessThan,
        OP_isSignedLessThanOrEqual,
        OP_isSignedGreaterThan,
        OP_isSignedGreaterThanOrEqual,
        OP_unsignedExtend,
        OP_signExtend,
        OP_add,                                     /**< Two args + optional carry bit. */
        OP_addCarries,                              /**< Carries from a 3-arg add operation. */
        OP_subtract,
        OP_negate,
        OP_signedDivide,
        OP_signedModulo,
        OP_signedMultiply,
        OP_unsignedDivide,
        OP_unsignedModulo,
        OP_unsignedMultiply,
        OP_interrupt,
        OP_readRegister,
        OP_peekRegister,
        OP_writeRegister,
        OP_readMemory,                              /**< Three or four args depending on whether segment reg is present. */
        OP_peekMemory,
        OP_writeMemory,                             /**< Three or four args depending on whether segment reg is present. */
        OP_N_OPERATORS                              /**< Number of operators in this enum. */ // MUST BE LAST!
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    // Note that the qualification for the type is necessary only for ROSETTA. Remove it when ROSETTA finally goes away.
public:
    /** Property: Low-level semantic operation.
     *
     *  This property is an enum constant that represents an operation in @ref
     *  Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics::RiscOperators "RiscOperators". 
     *  
     *  @{ */
    SgAsmRiscOperation::RiscOperator const& get_riscOperator() const;
    void set_riscOperator(SgAsmRiscOperation::RiscOperator const&);
    /** @} */

public:
    /** Property: Operands for the low-level operation.
     *
     *  These are the operands used by the low-level operation. The actual list is stored in a separate @ref SgAsmExprListExp AST
     *  node instead of directly in this node due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmExprListExp* const& get_operands() const;
    void set_operands(SgAsmExprListExp* const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmRiscOperation();

public:
    /** Default constructor. */
    SgAsmRiscOperation();

public:
    /** Constructor. */
    explicit SgAsmRiscOperation(SgAsmRiscOperation::RiscOperator const& riscOperator);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRiscOperation_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRegisterNames           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmRegisterNames);
IS_SERIALIZABLE(AsmRegisterNames);

#ifndef DOCUMENTATION
AsmRegisterNames.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmRegisterNames);
#if defined(SgAsmRegisterNames_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmRegisterNames_HEADERS

#ifdef DOCUMENTATION
/** An ordered list of registers. */
class SgAsmRegisterNames: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRegisterNames.setDataPrototype(
        "SgAsmRegisterReferenceExpressionPtrList", "registers", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRegisterNames.setDataPrototype(
        "unsigned", "mask", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmRegisterNames);
#if defined(SgAsmRegisterNames_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmRegisterNames -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmRegisterNames");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_registers);
        s & BOOST_SERIALIZATION_NVP(p_mask);
        debugSerializationEnd("SgAsmRegisterNames");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of registers.
     *
     *  These are the actual registers contained in this node.  Registers are stored in this node instead of directly in a
     *  @ref SgAsmRegisterNames node because of limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmRegisterReferenceExpressionPtrList const& get_registers() const;
    SgAsmRegisterReferenceExpressionPtrList& get_registers();
    void set_registers(SgAsmRegisterReferenceExpressionPtrList const&);
    /** @} */

public:
    /** Property: Bit mask.
     *
     *  This is an optional bit mask representing the registers. It's used by the m68k disassembler and represents the mask
     *  that appeared in the encoded instruction. 
     *  
     *  @{ */
    unsigned const& get_mask() const;
    void set_mask(unsigned const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmRegisterNames();

public:
    /** Default constructor. */
    SgAsmRegisterNames();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRegisterNames_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPowerpcInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPowerpcInstruction);
IS_SERIALIZABLE(AsmPowerpcInstruction);

#ifndef DOCUMENTATION
AsmPowerpcInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPowerpcInstruction);
#if defined(SgAsmPowerpcInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/InstructionEnumsPowerpc.h>
#endif // SgAsmPowerpcInstruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one PowerPC machine instruction. */
class SgAsmPowerpcInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPowerpcInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::PowerpcInstructionKind", "kind", "= Rose::BinaryAnalysis::powerpc_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPowerpcInstruction);
#if defined(SgAsmPowerpcInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPowerpcInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPowerpcInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        debugSerializationEnd("SgAsmPowerpcInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the PowerPC instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::PowerpcInstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::PowerpcInstructionKind const&);
    /** @} */
public:
    /** Description of conditional branch BO constant.
     *
     *  Given a BO constant from a PowerPC conditional branch instruction, convert it to a description of the condition
     *  that causes the branch to be taken. "BO" is the term used in the PowerPC documentation to denote the first argument
     *  of the conditional instruction; it is a 5-bit integer constant. */
    std::string conditionalBranchDescription() const;

    /** Return the register dictionary for a PowerPC architecture.
     *
     *  Given an instruction size of 32 or 64 return the register dictionary that describes the PowerPC architecture with
     *  the specified word size. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForWidth(size_t);

    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmPowerpcInstruction();

public:
    /** Default constructor. */
    SgAsmPowerpcInstruction();

public:
    /** Constructor. */
    SgAsmPowerpcInstruction(rose_addr_t const& address,
                            uint8_t const& architectureId,
                            Rose::BinaryAnalysis::PowerpcInstructionKind const& kind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPowerpcInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPointerType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPointerType);
IS_SERIALIZABLE(AsmPointerType);

#ifndef DOCUMENTATION
AsmPointerType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Pointer type. */
class SgAsmPointerType: public SgAsmScalarType {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPointerType.setDataPrototype(
        "SgAsmType *", "subtype", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPointerType);
#if defined(SgAsmPointerType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPointerType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPointerType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmScalarType);
        s & BOOST_SERIALIZATION_NVP(p_subtype);
        debugSerializationEnd("SgAsmPointerType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmType * const& get_subtype() const;
    void set_subtype(SgAsmType * const&);
public:
    /** Construct new pointer type. */
    SgAsmPointerType(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits, SgAsmType *subtype);

    /** Make instance wrapped around a subtype. */
    static SgAsmPointerType* instance(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits, SgAsmType *subtype);

    virtual void check() const override;
    virtual std::string toString() const override;
public:
    /** Destructor. */
    virtual ~SgAsmPointerType();

public:
    /** Default constructor. */
    SgAsmPointerType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPointerType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEStringSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEStringSection);
IS_SERIALIZABLE(AsmPEStringSection);

#ifndef DOCUMENTATION
AsmPEStringSection.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** String section. */
class SgAsmPEStringSection: public SgAsmPESection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEStringSection.setDataPrototype(
        "SgAsmCoffStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEStringSection);
#if defined(SgAsmPEStringSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEStringSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEStringSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
        s & BOOST_SERIALIZATION_NVP(p_strtab);
        debugSerializationEnd("SgAsmPEStringSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: String table.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmCoffStrtab* const& get_strtab() const;
    void set_strtab(SgAsmCoffStrtab* const&);
    /** @} */
public:
    SgAsmPEStringSection(SgAsmPEFileHeader*);
    virtual SgAsmPEStringSection* parse() override;
    virtual bool reallocate() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    virtual void set_size(rose_addr_t newsize) override;
    virtual void unparse(std::ostream&) const override;
public:
    /** Destructor. */
    virtual ~SgAsmPEStringSection();

public:
    /** Default constructor. */
    SgAsmPEStringSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEStringSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPESectionTable);
IS_SERIALIZABLE(AsmPESectionTable);

#ifndef DOCUMENTATION
AsmPESectionTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Section table. */
class SgAsmPESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmPESectionTable);
#if defined(SgAsmPESectionTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPESectionTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPESectionTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        debugSerializationEnd("SgAsmPESectionTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    explicit SgAsmPESectionTable(SgAsmPEFileHeader*);
    virtual SgAsmPESectionTable* parse() override;

    /** Attaches a previously unattached PE Section to the PE Section Table.
     *
     *  This method complements SgAsmPESection::init_from_section_table. This method initializes the section table from the
     *  section while init_from_section_table() initializes the section from the section table. */
    void addSection(SgAsmPESection *section);
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void add_section(SgAsmPESection*) ROSE_DEPRECATED("use addSection");
public:
    /** Destructor. */
    virtual ~SgAsmPESectionTable();

public:
    /** Default constructor. */
    SgAsmPESectionTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESectionTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPESectionTableEntry);
IS_SERIALIZABLE(AsmPESectionTableEntry);

#ifndef DOCUMENTATION
AsmPESectionTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Section table entry. */
class SgAsmPESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "virtual_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physical_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physical_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "coff_line_nums", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "n_relocs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "n_coff_line_nums", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPESectionTableEntry);
#if defined(SgAsmPESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPESectionTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPESectionTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_virtual_size);
        s & BOOST_SERIALIZATION_NVP(p_rva);
        s & BOOST_SERIALIZATION_NVP(p_physical_size);
        s & BOOST_SERIALIZATION_NVP(p_physical_offset);
        s & BOOST_SERIALIZATION_NVP(p_coff_line_nums);
        s & BOOST_SERIALIZATION_NVP(p_n_relocs);
        s & BOOST_SERIALIZATION_NVP(p_n_coff_line_nums);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        debugSerializationEnd("SgAsmPESectionTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
    struct PESectionTableEntry_disk {
        char     name[8];          /* NUL-padded */
        uint32_t virtual_size;     /* virtual memory size, >= physical_size and difference is zero filled */
        uint32_t rva;              /* relative virt addr wrt Image Base; multiple of section_align; dense space */
        uint32_t physical_size;    /* bytes of initialized data on disk; multiple of file_align & <= virtual_size*/
        uint32_t physical_offset;  /* location of initialized data on disk; multiple of file_align */
        uint32_t coff_line_nums;   /* file offset of COFF line number info or zero */
        uint32_t n_relocs;         /* number of relocation entries; should be zero for executables */
        uint32_t n_coff_line_nums; /* number of COFF line number entries */
        uint32_t flags;            /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc.*/
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* These come from the windows PE documentation and
     * http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
    enum PESectionFlags {
        OF_CODE             = 0x00000020,   /* section contains code */
        OF_IDATA            = 0x00000040,   /* initialized data */
        OF_UDATA            = 0x00000080,   /* uninitialized data */
        OF_INFO             = 0x00000200,   /* comments or some other type of info */
        OF_REMOVE           = 0x00000800,   /* section will not become part of image */
        OF_COMDAT           = 0x00001000,   /* section contains comdat */
        OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for
                                             * this section */
        OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
        OF_ALIGN_1          = 0x00100000,   /* no alignment */
        OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
        OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
        OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
        OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
        OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
        OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
        OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
        OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
        OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
        OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
        OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
        OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
        OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
        OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
        OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
        OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
        OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
        OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
        OF_SHARED           = 0x10000000,   /* section is shared */
        OF_EXECUTABLE       = 0x20000000,   /* execute permission */
        OF_READABLE         = 0x40000000,   /* read permission */
        OF_WRITABLE         = 0x80000000    /* write permission */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Name.
     *
     *  See PE specification. 
     *  
     *  @{ */
    std::string const& get_name() const;
    void set_name(std::string const&);
    /** @} */

public:
    /** Property: Virtual size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_virtual_size() const;
    void set_virtual_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_rva() const;
    void set_rva(rose_addr_t const&);
    /** @} */

public:
    /** Property: Physical size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_physical_size() const;
    void set_physical_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Physical offset.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_physical_offset() const;
    void set_physical_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: COFF line numbers.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_coff_line_nums() const;
    void set_coff_line_nums(unsigned const&);
    /** @} */

public:
    /** Property: Number of relocations.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_n_relocs() const;
    void set_n_relocs(unsigned const&);
    /** @} */

public:
    /** Property: Number of COFF line numbers.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_n_coff_line_nums() const;
    void set_n_coff_line_nums(unsigned const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);

    /** Update this section table entry with newer information from the section */
    void updateFromSection(SgAsmPESection *section);
    void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*) const;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void update_from_section(SgAsmPESection*) ROSE_DEPRECATED("use updateFromSection");
public:
    /** Destructor. */
    virtual ~SgAsmPESectionTableEntry();

public:
    /** Default constructor. */
    SgAsmPESectionTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESectionTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPERVASizePairList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPERVASizePairList);
IS_SERIALIZABLE(AsmPERVASizePairList);

#ifndef DOCUMENTATION
AsmPERVASizePairList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPERVASizePairList);
#if defined(SgAsmPERVASizePairList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmPERVASizePairList_HEADERS

#ifdef DOCUMENTATION
/** List of SgAsmPERVASizePair AST nodes.
 *
 *  The only reason this AST node exists rather than storing the list directly in the nodes that need it is due to ROSETTA
 *  limitations. */
class SgAsmPERVASizePairList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPERVASizePairList.setDataPrototype(
        "SgAsmPERVASizePairPtrList", "pairs", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPERVASizePairList);
#if defined(SgAsmPERVASizePairList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPERVASizePairList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPERVASizePairList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_pairs);
        debugSerializationEnd("SgAsmPERVASizePairList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to other nodes. 
     * 
     * @{ */
    SgAsmPERVASizePairPtrList const& get_pairs() const;
    SgAsmPERVASizePairPtrList& get_pairs();
    void set_pairs(SgAsmPERVASizePairPtrList const&);
    /** @} */
public:
    explicit SgAsmPERVASizePairList(SgAsmPEFileHeader *parent);
public:
    /** Destructor. */
    virtual ~SgAsmPERVASizePairList();

public:
    /** Default constructor. */
    SgAsmPERVASizePairList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPERVASizePairList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPERVASizePair           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPERVASizePair);
IS_SERIALIZABLE(AsmPERVASizePair);

#ifndef DOCUMENTATION
AsmPERVASizePair.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPERVASizePair);
#if defined(SgAsmPERVASizePair_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#endif // SgAsmPERVASizePair_HEADERS

#ifdef DOCUMENTATION
/** RVA/size pair. */
class SgAsmPERVASizePair: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPERVASizePair.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "e_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPERVASizePair.setDataPrototype(
        "rose_addr_t", "e_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPERVASizePair.setDataPrototype(
        "SgAsmGenericSection*", "section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPERVASizePair);
#if defined(SgAsmPERVASizePair_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPERVASizePair -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPERVASizePair");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_e_rva);
        s & BOOST_SERIALIZATION_NVP(p_e_size);
        s & BOOST_SERIALIZATION_NVP(p_section);
        debugSerializationEnd("SgAsmPERVASizePair");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** File format for an RVA/Size pair.
     *
     *  Such pairs are considered to be part of the PE file header.  All fields are little endian. */
    struct RVASizePair_disk {
        uint32_t    e_rva;
        uint32_t    e_size;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_e_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_e_rva();
    void set_e_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_e_size() const;
    void set_e_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Section.
     *
     *  See PE specification. 
     *  
     *  @{ */
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, const SgAsmPERVASizePair::RVASizePair_disk*);
    SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, rose_addr_t rva, rose_addr_t size);

    /** Sets or removes the section associated with an RVA/size pair.
     *
     *  Setting or removing the section also updates the RVA and size according to the preferred mapping address and mapped
     *  size of the section. */
    void set_section(SgAsmGenericSection *section);

    /** Returns the section associated with an RVA/size pair.
     *
     *  This is the same as the ROSETTA-generated accessor, but we need a custom version of set_section(). */
    SgAsmGenericSection *get_section() const;

    void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const;
public:
    /** Destructor. */
    virtual ~SgAsmPERVASizePair();

public:
    /** Default constructor. */
    SgAsmPERVASizePair();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPERVASizePair_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEImportSection);
IS_SERIALIZABLE(AsmPEImportSection);

#ifndef DOCUMENTATION
AsmPEImportSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEImportSection);
#if defined(SgAsmPEImportSection_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>

#ifdef ROSE_SgAsmPEImportSection_IMPL
#include <SgAsmPEImportDirectoryList.h>
#endif
#endif // SgAsmPEImportSection_HEADERS

#ifdef DOCUMENTATION
/** Portable Executable Import Section.
 *
 *  Constructs an SgAsmPEImportSection that represents either a PE ".idata" section as defined by the PE Section Table, or
 *  a PE Import Table as described by the RVA/Size pairs at the end of the NT Optional Header. The ".idata" section and PE
 *  Import Table both have the same format (only important fields shown):
 *
 *  @par Import Section
 *  An Import Section consists of a list of Import Directory Entries ("Directories"), one per dynamically linked library,
 *  followed by an all-zero Directory entry that marks the end of the list.  ROSE does not explicitly store the terminating
 *  entry, and wherever "Directories" appears in the following description it does not include this null directory.
 *
 *  @par Import Directory
 *  Each directory points to (by relative virtual address (RVA)) both an Import Lookup Table (ILT) and Import Address Table
 *  (IAT).
 *
 *  @par Import Lookup Table (and Import Address Table)
 *  The Import Lookup Table (ILT) and Import Address Table (IAT) have identical structure.  ROSE represents them as a list
 *  of SgAsmPEImportItem in the Import Directory.  The ILT and IAT are parallel arrays of 32- or 64-bit (PE32 or PE32+)
 *  entries terminated with an all-zero entry.  The terminating entry is not stored explicitly by ROSE.  The entries are
 *  identical for both ILTs and IATs.
 *
 *  @par Import Lookup Table Entry (and Import Address Table Entry)
 *  Entries for ILTs and IATs are structurally identical.  They are 32- or 64-bit vectors.  The most significant bit
 *  (31/63) indicates whether the remaining bits are an Ordinal (when set) or Hint/Name address (when clear).  Ordinals are
 *  represented by the low-order 16 bits and Hint/Name addresses are stored in the low-order 31 bits.  All other bits must
 *  be zero according to the PE specification.  Hint/Name addresses are relative virtual addresses of entries in the
 *  (implicit) Hint/Name Table. When a function is bound by the dynamic linkter, its IAT Entry within process memory is
 *  overwritten with the virtual address of the bound function.
 *
 *  @par Hint/Name Table
 *  Some Import Lookup Table (and Import Address Table) entries contain a Hint/Name Table Entry RVA.  The Hint/Name Table
 *  Entries collectively form the Hint/Name Table, but there is no requirement that the entries appear in any particular
 *  order or even that they appear contiguously in memory.  In other words, the Hint/Name Table is a conceptual object
 *  rather than a true table in the PE file.
 *
 *
 * @verbatim
    +------------ Import Section -------------+                         (SgAsmPEImportSection)
    |                                         |
    |                                         |
    |  +------- Import Directory #0 ------+   |                         (SgAsmPEImportDirectory)
    |  |   1. Import Lookup Table RVA     |   |
    |  |   2. Date/time stamp             |   |
    |  |   3. Forwarder chain index       |   |
    |  |   4. Name RVA                    |   |
    |  |   5. Import Address Table RVA    |   |
    |  +----------------------------------+   |
    |                                         |
    |                                         |
    |  +------- Import Directory #1 ------+   |
    |  |   1. Import Lookup Table RVA     |--------+
    |  |   2. Date/time stamp             |   |    |
    |  |   3. Forwarder chain index       |   |    |
    |  |   4. Name RVA                    |   |    |
    |  |   5. Import Address Table RVA    |------- | -------+
    |  +----------------------------------+   |    |        |
    |                                         |    |        |
    |         . . .                           |    |        |
    |                                         |    |        |
    |  +------- Import Directory #N ------+   |    |        |
    |  |                                  |   |    |        |
    |  |   Terminating directory is       |   |    |        |
    |  |   zero filled.                   |   |    |        |
    |  |                                  |   |    |        |
    |  |                                  |   |    |        |
    |  +----------------------------------+   |    |        |
    |                                         |    |        |
    +-----------------------------------------+    |        |           (Entries of the ILT and IAT are combined into
                                                   |        |            SgAsmPEImportItem objects.)
                                                   |        |
                                                   |        |
    +----------- Import Lookup Table ---------+ <--+        +-->  +----------- Import Address Table --------+
    | #0  32/64-bit vector                    |                   | #0  32/64-bit vector or VA when bound   |
    |                                         |   These arrays    |                                         |
    | #1  32/64-bit vector                    |   are parallel    | #1  32/64-bit vector or VA when bound   |
    |                      \                  |                   |                                         |
    |     ...               \when used as     |                   |     ...                                 |
    |                        \a Hint/Name     |                   |                                         |
    | #N  32/64-bit zero      \RVA            |                   | #N  32/64-bit zero                      |
    +--------------------------\--------------+                   +-----------------------------------------+
                                \
                                 \
                                  |
    + - - - - -  Hint/Name Table  | - - - - - +           The Hint/Name Table doesn't actually
                                  v                       exist explicitly--there is no pointer
    |  +------ Hint/Name ----------------+    |           to the beginning of the table and no
       |  1. 2-byte index ENPT           |                requirement that the entries be in any
    |  |  2. NUL-terminated name         |    |           particular order, or even contiguous.
       |  3. Optional extran NUL         |
    |  +---------------------------------+    |           "ENPT" means Export Name Pointer Table,
                                                          which is a table in the linked-to
    |          . . .                          |           shared library.

    |  +------ Hint/Name ----------------+    |
       |  1. 2-byte index ENPT           |                              (SgAsmPEImportHNTEntry)
    |  |  2. NUL-terminated name         |    |
       |  3. Optional extran NUL         |
    |  +---------------------------------+    |

    + - - - - - - - - - - - - - - - - - - - - +
@endverbatim
 *
 * When parsing an Import Directory, ROSE assumes that the IAT contains ordinals and/or hint/name addresses rather than
 * bound addresses.  ROSE checks that the IAT entries are compatible with the ILT entries there were already parsed and if
 * an inconsistency is detected then a warning is issued and ROSE assumes that the IAT entry is a bound value instead.
 * Passing true as the @p assume_bound argument for the parser will cause ROSE to not issue such warnings and immediately
 * assume that all IAT entries are bound addresses.  One can therefore find the conflicting entries by looking for
 * SgAsmImportItem objects that are created with a non-zero bound address.
 *
 * The IAT is often required to be allocated at a fixed address, often the beginning of the ".rdata" section.  Increasing
 * the size of the IAT by adding more items to the import list(s) can be problematic because ROSE is unable to safely write
 * beyond the end of the original IAT.  We require the user to manually allocate space for the new IAT and tell the
 * SgAsmPEImportDirectory object the location and size of the allocated space before unparsing.  On a related note, due to
 * ROSE allocators being section-local, reallocation of an Import Section does not cause reallocation of ILTs, Hint/Name
 * pairs, or DLL names that have addresses outside the Import Section.  If these items' sizes increase, the items will be
 * truncated when written back to disk.  The reallocation happens automatically for all import-related objects that are
 * either bound to the import section or have a null RVA, so one method of getting things reallocated is to traverse the
 * AST and null their RVAs:
 *
 * @code
 *  struct Traversal: public AstSimpleTraversal {
 *      void visit(SgNode *node) {
 *          SgAsmPEImportDirectory *idir = isSgAsmPEImportDirectory(node);
 *          SgAsmPEImportItem *import = isSgAsmPEImportItem(node);
 *          static const Rose::BinaryAnalysis::RelativeVirtualAddress nil(0);
 *
 *          if (idir) {
 *              idir->set_dll_name_rva(nil);
 *              idir->set_ilt_rva(nil);
 *              idir->set_iat_rva(nil);
 *          }
 *
 *          if (import)
 *              idir->set_hintname_rva(nil);
 *     }
 *  };
 * @endcode
 *
 * @sa
 *      SgAsmPEImportDirectory
 *      SgAsmPEImportItem
 */
class SgAsmPEImportSection: public SgAsmPESection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportSection.setDataPrototype(
        "SgAsmPEImportDirectoryList*", "importDirectories", "= createAndParent<SgAsmPEImportDirectoryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEImportSection);
#if defined(SgAsmPEImportSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEImportSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEImportSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
        s & BOOST_SERIALIZATION_NVP(p_importDirectories);
        debugSerializationEnd("SgAsmPEImportSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of import directories.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPEImportDirectoryList* const& get_importDirectories() const;
    void set_importDirectories(SgAsmPEImportDirectoryList* const&);
    /** @} */
public:
    explicit SgAsmPEImportSection(SgAsmPEFileHeader*);
    virtual SgAsmPEImportSection *parse() override;
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Add an import directory to the end of the import directory list. */
    void addImportDirectory(SgAsmPEImportDirectory*);

    /** Remove an import directory from the import directory list. Does not delete it. */
    void removeImportDirectory(SgAsmPEImportDirectory*);
    static bool showImportMessage();
    static void importMessageReset();

    /** Reallocate space for all Import Address Table.
     *
     *  This method traverses the AST beginning at this PE Import Section and assigns addresses and sizes to all Import
     *  Address Tables (IATs).  The first IAT is given the @p start_at RVA and its size is reset to what ever size is
     *  needed to store the entire table.  Each subsequent IAT is given the next available address and it's size is also
     *  updated.  The result is that all the IATs under this Import Section are given addresses and sizes that make them
     *  contiguous in memory. This method returns the total number of bytes required for all the IATs. */
    size_t reallocateIats(Rose::BinaryAnalysis::RelativeVirtualAddress start_at);

private:
    static size_t mesg_nprinted; //counter for import_mesg()

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPEImportDirectoryList* get_import_directories() const ROSE_DEPRECATED("use get_importDirectories");
    void set_import_directories(SgAsmPEImportDirectoryList*) ROSE_DEPRECATED("use set_importDirectories");
    void add_import_directory(SgAsmPEImportDirectory*) ROSE_DEPRECATED("use addImportDirectory");
    void remove_import_directory(SgAsmPEImportDirectory*) ROSE_DEPRECATED("use removeImportDirectory");
    static bool show_import_mesg() ROSE_DEPRECATED("use showImportMessage");
    static void import_mesg_reset() ROSE_DEPRECATED("use importMessageReset");
    size_t reallocate_iats(Rose::BinaryAnalysis::RelativeVirtualAddress) ROSE_DEPRECATED("use reallocateIats");
public:
    /** Destructor. */
    virtual ~SgAsmPEImportSection();

public:
    /** Default constructor. */
    SgAsmPEImportSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportItemList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEImportItemList);
IS_SERIALIZABLE(AsmPEImportItemList);

#ifndef DOCUMENTATION
AsmPEImportItemList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEImportItemList);
#if defined(SgAsmPEImportItemList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmPEImportItemList_HEADERS

#ifdef DOCUMENTATION
/** A list of imported items.
 *
 *  The only purpose of this node is to hold a list of pointers to other nodes. This list cannot be contained directly in the nodes
 *  that need it due to ROSETTA limitations. */
class SgAsmPEImportItemList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItemList.setDataPrototype(
        "SgAsmPEImportItemPtrList", "vector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEImportItemList);
#if defined(SgAsmPEImportItemList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEImportItemList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEImportItemList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_vector);
        debugSerializationEnd("SgAsmPEImportItemList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to other nodes. 
     * 
     * @{ */
    SgAsmPEImportItemPtrList const& get_vector() const;
    SgAsmPEImportItemPtrList& get_vector();
    void set_vector(SgAsmPEImportItemPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmPEImportItemList();

public:
    /** Default constructor. */
    SgAsmPEImportItemList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportItemList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportItem           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEImportItem);
IS_SERIALIZABLE(AsmPEImportItem);

#ifndef DOCUMENTATION
AsmPEImportItem.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEImportItem);
#if defined(SgAsmPEImportItem_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>

#ifdef ROSE_SgAsmPEImportItem_IMPL
#include <SgAsmBasicString.h>
#endif
#endif // SgAsmPEImportItem_HEADERS

#ifdef DOCUMENTATION
/** A single imported object.
 *
 *  Each of these nodes is created from a combination of the PE Import Lookup Table and the PE Import Address Table, pointers to
 *  which are stored in the Import Directory (@ref SgAsmPEImportDirectory). This node represents a single import object described by
 *  data structures referenced by a PE Import Directory.  Such a node represents data from two, possibly three, distinct data
 *  structures in the PE file: (1) An entry in the Import Lookup Table, (2) an entry in the Import Address Table, and (3) an
 *  optional Hint/Name pair in the (implicit) Hint/Name Table. */
class SgAsmPEImportItem: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "bool", "by_ordinal", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "unsigned", "ordinal", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "unsigned", "hint", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "hintname_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "size_t", "hintname_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "bound_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportItem.setDataPrototype(
        "bool", "iat_written", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEImportItem);
#if defined(SgAsmPEImportItem_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEImportItem -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEImportItem");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_by_ordinal);
        s & BOOST_SERIALIZATION_NVP(p_ordinal);
        s & BOOST_SERIALIZATION_NVP(p_hint);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_hintname_rva);
        s & BOOST_SERIALIZATION_NVP(p_hintname_nalloc);
        s & BOOST_SERIALIZATION_NVP(p_bound_rva);
        s & BOOST_SERIALIZATION_NVP(p_iat_written);
        debugSerializationEnd("SgAsmPEImportItem");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Whether ordinal number is stored.
     *
     *  See PE specification. 
     *  
     *  @{ */
    bool const& get_by_ordinal() const;
    void set_by_ordinal(bool const&);
    /** @} */

public:
    /** Property: Ordinal number
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_ordinal() const;
    void set_ordinal(unsigned const&);
    /** @} */

public:
    /** Property: Export name table hint if not ordinal.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_hint() const;
    void set_hint(unsigned const&);
    /** @} */

public:
    /** Property: Name if not by ordinal.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString* const&);
    /** @} */

public:
    /** Property: RVA of hint/name pair.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_hintname_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_hintname_rva();
    void set_hintname_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: File bytes allocated for hint/name pair.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_hintname_nalloc() const;
    void set_hintname_nalloc(size_t const&);
    /** @} */

public:
    /** Property: Bound RVA from IAT if not a copy of ILT.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_bound_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_bound_rva();
    void set_bound_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Whether the resolved address has been written to the memory map.
     *
     *  See PE specification. 
     *  
     *  @{ */
    bool const& get_iat_written() const;
    void set_iat_written(bool const&);
    /** @} */
public:
    explicit SgAsmPEImportItem(SgAsmPEImportItemList *parent);
    explicit SgAsmPEImportItem(SgAsmPEImportDirectory*);
    SgAsmPEImportItem(SgAsmPEImportDirectory*, const std::string &name, unsigned hint=0);
    SgAsmPEImportItem(SgAsmPEImportDirectory*, const unsigned ordinal);

    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Bytes needed to store hint/name pair.
     *
     *  A hint/name pair consists of a two-byte, little endian, unsigned hint and a NUL-terminated ASCII string.  An
     *  optional zero byte padding appears after the string's NUL terminator if necessary to make the total size of the
     *  hint/name pair a multiple of two. */
    size_t hintNameRequiredSize() const;

    /** Virtual address of an IAT entry.
     *
     *  Returns the virtual address of the IAT slot for this import item.  This import item must be linked into the AST in
     *  order for this method to succeed. */
    rose_addr_t get_iatEntryVa() const;

private:
    void initFromParent(SgAsmPEImportItemList *parent);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    size_t hintname_required_size() const ROSE_DEPRECATED("use hintNameRequiredSize");
    rose_addr_t get_iat_entry_va() const ROSE_DEPRECATED("use get_iatEntryVa");
public:
    /** Destructor. */
    virtual ~SgAsmPEImportItem();

public:
    /** Default constructor. */
    SgAsmPEImportItem();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportItem_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportDirectoryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEImportDirectoryList);
IS_SERIALIZABLE(AsmPEImportDirectoryList);

#ifndef DOCUMENTATION
AsmPEImportDirectoryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEImportDirectoryList);
#if defined(SgAsmPEImportDirectoryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmPEImportDirectoryList_HEADERS

#ifdef DOCUMENTATION
/** A list of PE Import Directories.
 *
 *  The only purpose of this class is to store a list of node pointers which cannot be stored in the nodes that need it due to
 *  ROSETTA limitations. */
class SgAsmPEImportDirectoryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectoryList.setDataPrototype(
        "SgAsmPEImportDirectoryPtrList", "vector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEImportDirectoryList);
#if defined(SgAsmPEImportDirectoryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEImportDirectoryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEImportDirectoryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_vector);
        debugSerializationEnd("SgAsmPEImportDirectoryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of nodes.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPEImportDirectoryPtrList const& get_vector() const;
    SgAsmPEImportDirectoryPtrList& get_vector();
    void set_vector(SgAsmPEImportDirectoryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmPEImportDirectoryList();

public:
    /** Default constructor. */
    SgAsmPEImportDirectoryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportDirectoryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportDirectory           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEImportDirectory);
IS_SERIALIZABLE(AsmPEImportDirectory);

#ifndef DOCUMENTATION
AsmPEImportDirectory.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEImportDirectory);
#if defined(SgAsmPEImportDirectory_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <sageContainer.h>

#ifdef ROSE_SgAsmPEImportDirectory_IMPL
#include <SgAsmGenericString.h>
#include <SgAsmPEImportItemList.h>
#endif
#endif // SgAsmPEImportDirectory_HEADERS

#ifdef DOCUMENTATION
/** One import directory per library.
 *
 *  The import directory points to the Import Lookup Table and Import Address Table. ROSE no longer represents the ILT and IAT with
 *  separate IR nodes. */
class SgAsmPEImportDirectory: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "SgAsmGenericString*", "dllName", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "dllNameRva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "dll_name_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "time_t", "time", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "unsigned", "forwarder_chain", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "ilt_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "ilt_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "iat_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "iat_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEImportDirectory.setDataPrototype(
        "SgAsmPEImportItemList*", "imports", "= createAndParent<SgAsmPEImportItemList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEImportDirectory);
#if defined(SgAsmPEImportDirectory_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEImportDirectory -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEImportDirectory");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_dllName);
        s & BOOST_SERIALIZATION_NVP(p_dllNameRva);
        s & BOOST_SERIALIZATION_NVP(p_dll_name_nalloc);
        s & BOOST_SERIALIZATION_NVP(p_time);
        s & BOOST_SERIALIZATION_NVP(p_forwarder_chain);
        s & BOOST_SERIALIZATION_NVP(p_ilt_rva);
        s & BOOST_SERIALIZATION_NVP(p_ilt_nalloc);
        s & BOOST_SERIALIZATION_NVP(p_iat_rva);
        s & BOOST_SERIALIZATION_NVP(p_iat_nalloc);
        s & BOOST_SERIALIZATION_NVP(p_imports);
        debugSerializationEnd("SgAsmPEImportDirectory");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct PEImportDirectory_disk {
        uint32_t ilt_rva;               /* 0x00 Import Lookup Table RVA */
        uint32_t time;                  /* 0x04 Zero until the image is bound, then time stamp of the DLL */
        uint32_t forwarder_chain;       /* 0x08 Index of the first forwarder chain */
        uint32_t dll_name_rva;          /* 0x0c address of NUL-terminated DLL name */
        uint32_t iat_rva;               /* 0x10 Import Address Table (Thunk Table) RVA */
    }                                       /* 0x14 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Name of library from which to import.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmGenericString* const& get_dllName() const;
    void set_dllName(SgAsmGenericString* const&);
    /** @} */

public:
    /** Property: Address of the import library name.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_dllNameRva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_dllNameRva();
    void set_dllNameRva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Bytes allocated in the file for the name.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_dll_name_nalloc() const;
    void set_dll_name_nalloc(size_t const&);
    /** @} */

public:
    /** Property: Time.
     *
     *  See PE specification. 
     *  
     *  @{ */
    time_t const& get_time() const;
    void set_time(time_t const&);
    /** @} */

public:
    /** Property: Forwarder chain.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_forwarder_chain() const;
    void set_forwarder_chain(unsigned const&);
    /** @} */

public:
    /** Property: Starting address of the ILT.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_ilt_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_ilt_rva();
    void set_ilt_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Bytes allocated in the file for the ILT.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_ilt_nalloc() const;
    void set_ilt_nalloc(size_t const&);
    /** @} */

public:
    /** Property: IAT RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_iat_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_iat_rva();
    void set_iat_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Bytes allocated in the file for the IAT.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_iat_nalloc() const;
    void set_iat_nalloc(size_t const&);
    /** @} */

public:
    /** Property: List of imports.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPEImportItemList* const& get_imports() const;
    void set_imports(SgAsmPEImportItemList* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEImportDirectory(SgAsmPEImportSection *isec, const std::string &dll_name="");

    /** Parse an import directory.
     *
     *  The import directory is parsed from the specified virtual address via the PE header's loader map. Return value is
     *  this directory entry on success, or the null pointer if the entry is all zero (which marks the end of the directory
     *  list). The @p isLastEntry is true if the caller thinks this should be an all-zero entry. */
    SgAsmPEImportDirectory *parse(rose_addr_t va, bool isLastEntry);

    /** Allocates space for this import directory's name, import lookup table, and import address table.
     *
     *  The items are allocated beginning at the specified relative virtual address. Items are reallocated if they are not
     *  allocated or if they are allocated in the same section to which start_rva points (the import section).  They are
     *  not reallocated if they already exist in some other section. The return value is the number of bytes allocated in
     *  the import section.  Upon return, this directory's address data members are initialized with possibly new
     *  values. */
    size_t reallocate(Rose::BinaryAnalysis::RelativeVirtualAddress starting_rva);

    /** Encode an import directory entry back into disk format */
    void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*) const;
    virtual void unparse(std::ostream&, const SgAsmPEImportSection*, size_t idx) const;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Number of bytes required for the table.
     *
     *  Returns the number of bytes required for the entire IAT or ILT (including the zero terminator) as it is currently
     *  defined in the Import Directory.  The returned size does not include space required to store any Hint/Name pairs,
     *  which are outside the ILT/IAT but pointed to by the ILT/IAT. */
    size_t iatRequiredSize() const;

    /** Find an import item in an import directory.
     *
     *  Returns the index of the specified import item in this directory, or -1 if the import item is not a child of this
     *  directory.  The hint index is checked first. */
    int findImportItem(const SgAsmPEImportItem *item, int hint=0) const;

    /** Obtains the virtual address of the Hint/Name Table.
     *
     *  The Hint/Name Table is an implicit table--the PE file format specification talks about such a table, but it is not
     *  actually defined anywhere in the PE file.  Instead, various Import Lookup Table and Import Address Table entries
     *  might point to individual Hint/Name pairs, which collectively form an implicit Hint/Name Table.  There is no
     *  requirement that the Hint/Name pairs are contiguous in the address space, and indeed they often are not.
     *  Therefore, the only way to describe the location of the Hint/Name Table is by a list of addresses.
     *
     *  This function will scan this Import Directory's import items, observe which items make references to Hint/Name
     *  pairs that have known addresses, and add those areas of virtual memory to the specified extent map.  This function
     *  returns the number of ILT entries that reference a Hint/Name pair. */
    size_t hintNameTableExtent(Rose::BinaryAnalysis::AddressIntervalSet &extent/*in,out*/) const;

private:
    void parse_ilt_iat(const Rose::BinaryAnalysis::RelativeVirtualAddress &table_start, bool assume_bound);
    void unparse_ilt_iat(std::ostream&,const Rose::BinaryAnalysis::RelativeVirtualAddress &table_start, bool assume_bound,
                         size_t nalloc) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmGenericString* get_dll_name() const ROSE_DEPRECATED("use get_dllName");
    void set_dll_name(SgAsmGenericString*) ROSE_DEPRECATED("use set_dllName");
    const Rose::BinaryAnalysis::RelativeVirtualAddress& get_dll_name_rva() const ROSE_DEPRECATED("use get_dllNameRva");
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_dll_name_rva() ROSE_DEPRECATED("use get_dllNameRva");
    void set_dll_name_rva(const Rose::BinaryAnalysis::RelativeVirtualAddress&) ROSE_DEPRECATED("use set_dllNameRva");
    size_t iat_required_size() const ROSE_DEPRECATED("use iatRequiredSize");
    int find_import_item(const SgAsmPEImportItem*, int=0) const ROSE_DEPRECATED("use findImportItem");
    size_t hintname_table_extent(Rose::BinaryAnalysis::AddressIntervalSet&) const ROSE_DEPRECATED("use hintNameTableExtent");
public:
    /** Destructor. */
    virtual ~SgAsmPEImportDirectory();

public:
    /** Default constructor. */
    SgAsmPEImportDirectory();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportDirectory_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEFileHeader);
IS_SERIALIZABLE(AsmPEFileHeader);

#ifndef DOCUMENTATION
AsmPEFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEFileHeader);
#if defined(SgAsmPEFileHeader_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>

#ifdef ROSE_SgAsmPEFileHeader_IMPL
#include <SgAsmCoffSymbolTable.h>
#include <SgAsmPERVASizePairList.h>
#include <SgAsmPESectionTable.h>
#endif
#endif // SgAsmPEFileHeader_HEADERS

#ifdef DOCUMENTATION
/** Windows PE file header.
 *
 *  Most of the properties come directly from the PE specification and their documentation is not repeated here. */
class SgAsmPEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_cpu_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_nsections", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_time", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "rose_addr_t", "e_coff_symtab", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nt_hdr_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_coff_nsyms", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_opt_magic", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_lmajor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_lminor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_code_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_data_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_bss_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "e_code_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "e_data_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_section_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_file_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_os_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_os_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_user_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_user_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsys_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsys_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_reserved9", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_image_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_header_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_file_checksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsystem", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_dll_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_stack_reserve_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_stack_commit_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_heap_reserve_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_heap_commit_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_loader_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_num_rvasize_pairs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "SgAsmPERVASizePairList*", "rvaSizePairs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "SgAsmPESectionTable*", "sectionTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEFileHeader.setDataPrototype(
        "SgAsmCoffSymbolTable*", "coffSymbolTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEFileHeader);
#if defined(SgAsmPEFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_e_cpu_type);
        s & BOOST_SERIALIZATION_NVP(p_e_nsections);
        s & BOOST_SERIALIZATION_NVP(p_e_time);
        s & BOOST_SERIALIZATION_NVP(p_e_coff_symtab);
        s & BOOST_SERIALIZATION_NVP(p_e_nt_hdr_size);
        s & BOOST_SERIALIZATION_NVP(p_e_coff_nsyms);
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
        s & BOOST_SERIALIZATION_NVP(p_e_opt_magic);
        s & BOOST_SERIALIZATION_NVP(p_e_lmajor);
        s & BOOST_SERIALIZATION_NVP(p_e_lminor);
        s & BOOST_SERIALIZATION_NVP(p_e_code_size);
        s & BOOST_SERIALIZATION_NVP(p_e_data_size);
        s & BOOST_SERIALIZATION_NVP(p_e_bss_size);
        s & BOOST_SERIALIZATION_NVP(p_e_code_rva);
        s & BOOST_SERIALIZATION_NVP(p_e_data_rva);
        s & BOOST_SERIALIZATION_NVP(p_e_section_align);
        s & BOOST_SERIALIZATION_NVP(p_e_file_align);
        s & BOOST_SERIALIZATION_NVP(p_e_os_major);
        s & BOOST_SERIALIZATION_NVP(p_e_os_minor);
        s & BOOST_SERIALIZATION_NVP(p_e_user_major);
        s & BOOST_SERIALIZATION_NVP(p_e_user_minor);
        s & BOOST_SERIALIZATION_NVP(p_e_subsys_major);
        s & BOOST_SERIALIZATION_NVP(p_e_subsys_minor);
        s & BOOST_SERIALIZATION_NVP(p_e_reserved9);
        s & BOOST_SERIALIZATION_NVP(p_e_image_size);
        s & BOOST_SERIALIZATION_NVP(p_e_header_size);
        s & BOOST_SERIALIZATION_NVP(p_e_file_checksum);
        s & BOOST_SERIALIZATION_NVP(p_e_subsystem);
        s & BOOST_SERIALIZATION_NVP(p_e_dll_flags);
        s & BOOST_SERIALIZATION_NVP(p_e_stack_reserve_size);
        s & BOOST_SERIALIZATION_NVP(p_e_stack_commit_size);
        s & BOOST_SERIALIZATION_NVP(p_e_heap_reserve_size);
        s & BOOST_SERIALIZATION_NVP(p_e_heap_commit_size);
        s & BOOST_SERIALIZATION_NVP(p_e_loader_flags);
        s & BOOST_SERIALIZATION_NVP(p_e_num_rvasize_pairs);
        s & BOOST_SERIALIZATION_NVP(p_rvaSizePairs);
        s & BOOST_SERIALIZATION_NVP(p_sectionTable);
        s & BOOST_SERIALIZATION_NVP(p_coffSymbolTable);
        debugSerializationEnd("SgAsmPEFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a PE File Header. All fields are little endian. */
    struct PEFileHeader_disk {
        unsigned char e_magic[4];       /* 0x00 magic number "PE\0\0" */
        uint16_t    e_cpu_type;         /* 0x04 e.g., 0x014c = Intel 386 */
        uint16_t    e_nsections;        /* 0x06 number of sections defined in the Section Table */
        uint32_t    e_time;             /* 0x08 time and date file was created or modified by the linker */
        uint32_t    e_coff_symtab;      /* 0x0c offset to COFF symbol table */
        uint32_t    e_coff_nsyms;       /* 0x10 number of symbols in COFF symbol table */
        uint16_t    e_nt_hdr_size;      /* 0x14 num remaining bytes in the header following the 'flags' field */
        uint16_t    e_flags;            /* 0x16 Bit flags: exe file, program/library image, fixed address, etc. */
    }                                       /* 0x18 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct PE32OptHeader_disk {
        uint16_t    e_opt_magic;        /* 0x18 magic number */
        uint16_t    e_lmajor;           /* 0x1a linker version */
        uint16_t    e_lminor;           /* 0x1c */
        uint16_t    e_code_size;        /* 0x1e Size of .text or sum of all code sections */
        uint32_t    e_data_size;        /* 0x20 Sum size of initialized data */
        uint32_t    e_bss_size;         /* 0x24 Sum size of uninitialized data */
        uint32_t    e_entrypoint_rva;   /* 0x28 RVA="relative virtual address"; relative to 'image_base', below */
        uint32_t    e_code_rva;         /* 0x2c Addr relative to image base for code section when memory mapped */
        uint32_t    e_data_rva;         /* 0x30 Address relative to image base for data section */
        uint32_t    e_image_base;       /* 0x34 Virt base of image (first byte of file, DOS header). 64k aligned */
        uint32_t    e_section_align;    /* 0x38 Alignment of sections in memory. Power of two 512<=x<=256M */
        uint32_t    e_file_align;       /* 0x3c Alignment factor (in bytes) for image pages */
        uint16_t    e_os_major;         /* 0x40 OS version number required to run this image */
        uint16_t    e_os_minor;         /* 0x42 */
        uint16_t    e_user_major;       /* 0x44 User-specified for differentiating between image revs */
        uint16_t    e_user_minor;       /* 0x46 */
        uint16_t    e_subsys_major;     /* 0x48 Subsystem version number */
        uint16_t    e_subsys_minor;     /* 0x4a */
        uint32_t    e_reserved9;        /* 0x4c */
        uint32_t    e_image_size;       /* 0x50 Virtual size of the image inc. all headers; section_align */
        uint32_t    e_header_size;      /* 0x54 Total header size (DOS Header + PE Header + Section table */
        uint32_t    e_file_checksum;    /* 0x58 Checksum for entire file; Set to zero by the linker */
        uint16_t    e_subsystem;        /* 0x5c Native, WindowsGUI, WindowsCharacter, OS/2 Character, etc. */
        uint16_t    e_dll_flags;        /* 0x5e Bit flags for library init/terminate per process or thread */
        uint32_t    e_stack_reserve_size;/*0x60 Virtual mem reserved for stack; non-committed pages are guards */
        uint32_t    e_stack_commit_size;/* 0x64 Size of valid stack; other pages are guards; <=stack_reserve_size*/
        uint32_t    e_heap_reserve_size;/* 0x68 Size (bytes) of local heap to reserve */
        uint32_t    e_heap_commit_size; /* 0x6c Size (bytes) of valid local heap */
        uint32_t    e_loader_flags;     /* 0x70 Reserved, must be zero */
        uint32_t    e_num_rvasize_pairs;/* 0x74 Num RVASizePair entries that follow this member; part of header */
    }                                       /* 0x78 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct PE64OptHeader_disk {
        uint16_t    e_opt_magic;        /* 0x18 */
        uint16_t    e_lmajor;           /* 0x1a */
        uint16_t    e_lminor;           /* 0x1c */
        uint16_t    e_code_size;        /* 0x1e */
        uint32_t    e_data_size;        /* 0x20 */
        uint32_t    e_bss_size;         /* 0x24 */
        uint32_t    e_entrypoint_rva;   /* 0x28 */
        uint32_t    e_code_rva;         /* 0x2c */
        // uint32_t  e_data_rva;             /* Not present in PE32+ */
        uint64_t    e_image_base;       /* 0x30 */
        uint32_t    e_section_align;    /* 0x38 */
        uint32_t    e_file_align;       /* 0x3c */
        uint16_t    e_os_major;         /* 0x40 */
        uint16_t    e_os_minor;         /* 0x42 */
        uint16_t    e_user_major;       /* 0x44 */
        uint16_t    e_user_minor;       /* 0x46 */
        uint16_t    e_subsys_major;     /* 0x48 */
        uint16_t    e_subsys_minor;     /* 0x4a */
        uint32_t    e_reserved9;        /* 0x4c */
        uint32_t    e_image_size;       /* 0x50 */
        uint32_t    e_header_size;      /* 0x54 */
        uint32_t    e_file_checksum;    /* 0x58 */
        uint16_t    e_subsystem;        /* 0x5c */
        uint16_t    e_dll_flags;        /* 0x5e */
        uint64_t    e_stack_reserve_size;/*0x60 */
        uint64_t    e_stack_commit_size;/* 0x68 */
        uint64_t    e_heap_reserve_size;/* 0x70 */
        uint64_t    e_heap_commit_size; /* 0x78 */
        uint32_t    e_loader_flags;     /* 0x80 */
        uint32_t    e_num_rvasize_pairs;/* 0x84 */
    }                                       /* 0x88 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
        ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* Bit flags for the PE header 'flags' member */
    enum HeaderFlags {
        HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
        HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: link errors or incrementally linked */
        HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
        HF_LIBRARY          = 0x2000,       /* Library image */
        HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
    };

    /* Values for the PE header 'subsystem' member */
    enum Subsystem {
        HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
        HF_NATIVE           = 0x0001,       /* Native */
        HF_WINGUI           = 0x0002,       /* Windows GUI */
        HF_WINCHAR          = 0x0003,       /* Windows character */
        HF_OS2CHAR          = 0x0005,       /* OS/2 character */
        HF_POSIX            = 0x0007        /* POSIX character */
    };

    /* Bit flags for the PE header 'dll_flags' member */
    enum DLLFlags {
        DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
        DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
        DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
        DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
        DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
    };

    /** Reason for each rva/size pair in the PE header. */
    enum PairPurpose {              // Values are important
        PAIR_EXPORTS            = 0,
        PAIR_IMPORTS            = 1,
        PAIR_RESOURCES          = 2,
        PAIR_EXCEPTIONS         = 3,
        PAIR_CERTIFICATES       = 4,
        PAIR_BASERELOCS         = 5,
        PAIR_DEBUG              = 6,
        PAIR_ARCHITECTURE       = 7,
        PAIR_GLOBALPTR          = 8,
        PAIR_TLS                = 9,    // Thread local storage
        PAIR_LOADCONFIG         = 10,
        PAIR_BOUNDIMPORT        = 11,
        PAIR_IAT                = 12,   // Import address table
        PAIR_DELAYIMPORT        = 13,   // Delay import descriptor
        PAIR_CLRRUNTIME         = 14,   // CLR(?) runtime header
        PAIR_RESERVED15         = 15    // Reserved (always zero according to specification)
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: CPU type.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_cpu_type() const;
    void set_e_cpu_type(unsigned const&);
    /** @} */

public:
    /** Property: Number of sections.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_nsections() const;
    void set_e_nsections(unsigned const&);
    /** @} */

public:
    /** Property: Time.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_time() const;
    void set_e_time(unsigned const&);
    /** @} */

public:
    /** Property: COFF symbol table.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_e_coff_symtab() const;
    void set_e_coff_symtab(rose_addr_t const&);
    /** @} */

public:
    /** Property: Size of NT header.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_e_nt_hdr_size() const;
    void set_e_nt_hdr_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Number of COFF symbols.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_coff_nsyms() const;
    void set_e_coff_nsyms(unsigned const&);
    /** @} */

public:
    /** Property: Flags
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_flags() const;
    void set_e_flags(unsigned const&);
    /** @} */

public:
    /** Property: Magic.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_opt_magic() const;
    void set_e_opt_magic(unsigned const&);
    /** @} */

public:
    /** Property: lmajor.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_lmajor() const;
    void set_e_lmajor(unsigned const&);
    /** @} */

public:
    /** Property: lminor.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_lminor() const;
    void set_e_lminor(unsigned const&);
    /** @} */

public:
    /** Property: Code size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_code_size() const;
    void set_e_code_size(unsigned const&);
    /** @} */

public:
    /** Property: Data size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_data_size() const;
    void set_e_data_size(unsigned const&);
    /** @} */

public:
    /** Property: BSS size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_bss_size() const;
    void set_e_bss_size(unsigned const&);
    /** @} */

public:
    /** Property: Code RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_e_code_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_e_code_rva();
    void set_e_code_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Data RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_e_data_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_e_data_rva();
    void set_e_data_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Section alignment.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_section_align() const;
    void set_e_section_align(unsigned const&);
    /** @} */

public:
    /** Property: File alignment.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_file_align() const;
    void set_e_file_align(unsigned const&);
    /** @} */

public:
    /** Property: OS major number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_os_major() const;
    void set_e_os_major(unsigned const&);
    /** @} */

public:
    /** Property: OS minor number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_os_minor() const;
    void set_e_os_minor(unsigned const&);
    /** @} */

public:
    /** Property: User major number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_user_major() const;
    void set_e_user_major(unsigned const&);
    /** @} */

public:
    /** Property: User minor number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_user_minor() const;
    void set_e_user_minor(unsigned const&);
    /** @} */

public:
    /** Property: Subsystem major number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_subsys_major() const;
    void set_e_subsys_major(unsigned const&);
    /** @} */

public:
    /** Property: Subsystem minor number.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_subsys_minor() const;
    void set_e_subsys_minor(unsigned const&);
    /** @} */

public:
    /** Property: Reserved area #9.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_reserved9() const;
    void set_e_reserved9(unsigned const&);
    /** @} */

public:
    /** Property: Image size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_image_size() const;
    void set_e_image_size(unsigned const&);
    /** @} */

public:
    /** Property: Header size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_header_size() const;
    void set_e_header_size(unsigned const&);
    /** @} */

public:
    /** Property: File checksum.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_file_checksum() const;
    void set_e_file_checksum(unsigned const&);
    /** @} */

public:
    /** Property: Subsystem.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_subsystem() const;
    void set_e_subsystem(unsigned const&);
    /** @} */

public:
    /** Property: DLL flags.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_dll_flags() const;
    void set_e_dll_flags(unsigned const&);
    /** @} */

public:
    /** Property: Stack reserve size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_stack_reserve_size() const;
    void set_e_stack_reserve_size(unsigned const&);
    /** @} */

public:
    /** Property: Stack commit size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_stack_commit_size() const;
    void set_e_stack_commit_size(unsigned const&);
    /** @} */

public:
    /** Property: Heap reserve size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_heap_reserve_size() const;
    void set_e_heap_reserve_size(unsigned const&);
    /** @} */

public:
    /** Property: Heap commit size.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_heap_commit_size() const;
    void set_e_heap_commit_size(unsigned const&);
    /** @} */

public:
    /** Property: Loader flags.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_loader_flags() const;
    void set_e_loader_flags(unsigned const&);
    /** @} */

public:
    /** Property: Number of RVA/size pairs.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_num_rvasize_pairs() const;
    void set_e_num_rvasize_pairs(unsigned const&);
    /** @} */

public:
    /** Property: RVA/size pairs.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPERVASizePairList* const& get_rvaSizePairs() const;
    void set_rvaSizePairs(SgAsmPERVASizePairList* const&);
    /** @} */

public:
    /** Property: Section table.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPESectionTable* const& get_sectionTable() const;
    void set_sectionTable(SgAsmPESectionTable* const&);
    /** @} */

public:
    /** Property: COFF symbol table.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmCoffSymbolTable* const& get_coffSymbolTable() const;
    void set_coffSymbolTable(SgAsmCoffSymbolTable* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEFileHeader(SgAsmGenericFile*);

    virtual const char* formatName() const override;

    /** Return true if the file looks like it might be a PE file according to the magic number.
     *
     *  The file must contain what appears to be a DOS File Header at address zero, and what appears to be a PE File Header
     *  at a file offset specified in part of the DOS File Header (actually, in the bytes that follow the DOS File
     *  Header). */
    static bool isPe(SgAsmGenericFile*);

    /** Convert an RVA/Size Pair index number into a section name.
     *
     *  The enum value passed as the first argument is looked up in an internal table and its full, static name from the PE
     *  documentation is returned. Additionally, if @p short_name is non-null then it points to a static abbreviated name. For
     *  example, if the first argument is @c PAIR_EXPORTS from the @ref SgAsmPEFileHeader::PairPurpose enum, then this function
     *  returns "Export Table" as the full name, and "Exports" as the abbreviated name. */
    std::string rvaSizePairName(PairPurpose, const char **short_name);

    /** Define an RVA/Size pair in the PE file header. */
    void set_rvaSizePair(PairPurpose, SgAsmPESection*);

    /** Update all the RVA/Size pair info from the section to which it points. */
    void updateRvaSizePairs();

    void addRvaSizePairs();

    virtual SgAsmPEFileHeader *parse() override;
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    void createTableSections();

    /* Loader memory maps */
    Rose::BinaryAnalysis::MemoryMap::Ptr get_loaderMap() const;
    void set_loaderMap(const Rose::BinaryAnalysis::MemoryMap::Ptr&);

private:
    void *encode(SgAsmPEFileHeader::PEFileHeader_disk*) const;
    void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*) const;
    void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*) const;
    Rose::BinaryAnalysis::MemoryMap::Ptr p_loader_map;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPERVASizePairList* get_rvasize_pairs() const ROSE_DEPRECATED("use get_rvaSizePairs");
    void set_rvasize_pairs(SgAsmPERVASizePairList*) ROSE_DEPRECATED("use set_rvaSizePairs");
    SgAsmPESectionTable* get_section_table() const ROSE_DEPRECATED("use get_sectionTable");
    void set_section_table(SgAsmPESectionTable*) ROSE_DEPRECATED("use set_sectionTable");
    SgAsmCoffSymbolTable* get_coff_symtab() const ROSE_DEPRECATED("use get_coffSymbolTable");
    void set_coff_symtab(SgAsmCoffSymbolTable*) ROSE_DEPRECATED("use set_coffSymbolTable");
    virtual const char *format_name() const override ROSE_DEPRECATED("use formatName");
    static bool is_PE (SgAsmGenericFile*) ROSE_DEPRECATED("use isPe");
    std::string rvasize_pair_name(PairPurpose, const char**) ROSE_DEPRECATED("use rvaSizePairName");
    void set_rvasize_pair(PairPurpose, SgAsmPESection*) ROSE_DEPRECATED("use set_rvaSizePair");
    void update_rvasize_pairs() ROSE_DEPRECATED("use updateRvaSizePairs");
    void add_rvasize_pairs() ROSE_DEPRECATED("use addRvaSizePairs");
    void create_table_sections() ROSE_DEPRECATED("use createTableSections");
    Rose::BinaryAnalysis::MemoryMap::Ptr get_loader_map() const ROSE_DEPRECATED("use get_loaderMap");
    void set_loader_map(const Rose::BinaryAnalysis::MemoryMap::Ptr&) ROSE_DEPRECATED("use set_loaderMap");
public:
    /** Destructor. */
    virtual ~SgAsmPEFileHeader();

public:
    /** Default constructor. */
    SgAsmPEFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEExportSection);
IS_SERIALIZABLE(AsmPEExportSection);

#ifndef DOCUMENTATION
AsmPEExportSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEExportSection);
#if defined(SgAsmPEExportSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmPEExportSection_IMPL
#include <SgAsmPEExportDirectory.h>
#include <SgAsmPEExportEntryList.h>
#endif
#endif // SgAsmPEExportSection_HEADERS

#ifdef DOCUMENTATION
/** Export file section. */
class SgAsmPEExportSection: public SgAsmPESection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportSection.setDataPrototype(
        "SgAsmPEExportDirectory*", "exportDirectory", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportSection.setDataPrototype(
        "SgAsmPEExportEntryList*", "exports", "= createAndParent<SgAsmPEExportEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEExportSection);
#if defined(SgAsmPEExportSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEExportSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEExportSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
        s & BOOST_SERIALIZATION_NVP(p_exportDirectory);
        s & BOOST_SERIALIZATION_NVP(p_exports);
        debugSerializationEnd("SgAsmPEExportSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Export directory.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPEExportDirectory* const& get_exportDirectory() const;
    void set_exportDirectory(SgAsmPEExportDirectory* const&);
    /** @} */

public:
    /** Property: List of export entries.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPEExportEntryList* const& get_exports() const;
    void set_exports(SgAsmPEExportEntryList* const&);
    /** @} */
public:
    /** The PE Export Address Table is an array of expaddr_n 4-byte RVAs.
     *
     *  If the address is not in the export section (as defined by the address and length that are indicated in the NT Optional
     *  Header) then the RVA is an actual address in code or data. Otherwise its a Forwarder RVA that names a symbol in another
     *  DLL. */
    typedef uint32_t ExportAddress_disk;

    /** The PE Export Name Pointer Table is an array of nameptr_n 4-byte RVAs pointing into the Export Name Table. The pointers are
     *  ordered lexically to allow binary searches.  An export name is defined only if the export name pointer table contains a
     *  pointer to it. */
    typedef uint32_t ExportNamePtr_disk;

    /** The PE Export Ordinal Table is an array of nameptr_n (yes) 2-byte indices into the Export Address Table biased by
     *  ord_base. In other words, the ord_base must be subtracted from the ordinals to obtain true indices into the Export Address
     *  Table. */
    typedef uint16_t ExportOrdinal_disk;

    SgAsmPEExportSection(SgAsmPEFileHeader*);
    virtual SgAsmPEExportSection *parse() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    void addEntry(SgAsmPEExportEntry*);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPEExportDirectory* get_export_dir() const ROSE_DEPRECATED("use get_exportDirectory");
    void set_export_dir(SgAsmPEExportDirectory*) ROSE_DEPRECATED("use set_exportDirectory");
    void add_entry(SgAsmPEExportEntry*) ROSE_DEPRECATED("use addEntry");
public:
    /** Destructor. */
    virtual ~SgAsmPEExportSection();

public:
    /** Default constructor. */
    SgAsmPEExportSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmPESection = nonTerminalConstructor(
    "AsmPESection",
    *this,
    "AsmPESection",
    "AsmPESectionTag",
    SubclassListBuilder()
        | AsmPEExportSection
        | AsmPEImportSection
        | AsmPEStringSection
    , true);
assert(AsmPESection.associatedGrammar != nullptr);
AsmPESection.setCppCondition("!defined(DOCUMENTATION)");
AsmPESection.isBoostSerializable(true);
AsmPESection.setAutomaticGenerationOfConstructor(false);
AsmPESection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmPESection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPESection);
#if defined(SgAsmPESection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmPESection_IMPL
#include <SgAsmPESectionTableEntry.h>
#endif
#endif // SgAsmPESection_HEADERS

#ifdef DOCUMENTATION
/** Base class for PE sections. */
class SgAsmPESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPESection.setDataPrototype(
        "SgAsmPESectionTableEntry*", "section_entry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPESection);
#if defined(SgAsmPESection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPESection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPESection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_section_entry);
        debugSerializationEnd("SgAsmPESection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Section table entry.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmPESectionTableEntry* const& get_section_entry() const;
    void set_section_entry(SgAsmPESectionTableEntry* const&);
    /** @} */
public:
    explicit SgAsmPESection(SgAsmPEFileHeader*);

    /** Initializes the section from data parsed from the PE Section Table.
     *
     *  This includes the section offset, size, memory mapping, alignments, permissions, etc. This function complements
     *  SgAsmPESectionTable::add_section(): this function initializes this section from the section table while
     *  add_section() initializes the section table from the section. */
    SgAsmPESection *initFromSectionTable(SgAsmPESectionTableEntry *entry, int id);
    virtual bool reallocate() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPESection *init_from_section_table(SgAsmPESectionTableEntry*, int) ROSE_DEPRECATED("use initFromSectionTable");
public:
    /** Destructor. */
    virtual ~SgAsmPESection();

public:
    /** Default constructor. */
    SgAsmPESection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEExportEntryList);
IS_SERIALIZABLE(AsmPEExportEntryList);

#ifndef DOCUMENTATION
AsmPEExportEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEExportEntryList);
#if defined(SgAsmPEExportEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmPEExportEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of pointers to other AST nodes.
 *
 *  The only purpose of this node is to hold a list of pointers to other nodes. We cannot store the list directly in the nodes that
 *  need it due to ROSETTA limitations. */
class SgAsmPEExportEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportEntryList.setDataPrototype(
        "SgAsmPEExportEntryPtrList", "exports", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEExportEntryList);
#if defined(SgAsmPEExportEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEExportEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEExportEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_exports);
        debugSerializationEnd("SgAsmPEExportEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to nodes. 
     * 
     * @{ */
    SgAsmPEExportEntryPtrList const& get_exports() const;
    SgAsmPEExportEntryPtrList& get_exports();
    void set_exports(SgAsmPEExportEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmPEExportEntryList();

public:
    /** Default constructor. */
    SgAsmPEExportEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEExportEntry);
IS_SERIALIZABLE(AsmPEExportEntry);

#ifndef DOCUMENTATION
AsmPEExportEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEExportEntry);
#if defined(SgAsmPEExportEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <Sawyer/Result.h>
#endif // SgAsmPEExportEntry_HEADERS

#ifdef DOCUMENTATION
/** Export entry. */
class SgAsmPEExportEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportEntry.setDataPrototype(
        "unsigned", "ordinal", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportEntry.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "exportRva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportEntry.setDataPrototype(
        "SgAsmGenericString*", "forwarder", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEExportEntry);
#if defined(SgAsmPEExportEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEExportEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEExportEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_ordinal);
        s & BOOST_SERIALIZATION_NVP(p_exportRva);
        s & BOOST_SERIALIZATION_NVP(p_forwarder);
        debugSerializationEnd("SgAsmPEExportEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Name.
     *
     *  See PE specification.
     *
     * @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString*);
    /** @} */
public:
   /** Property: Ordinal.
     *
     *  Unbiased ordinal. This is the index into the Export Address Table. See PE specification. 
     *  
     *  @{ */
    unsigned const& get_ordinal() const;
    void set_ordinal(unsigned const&);
    /** @} */

public:
    /** Property: Export RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_exportRva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_exportRva();
    void set_exportRva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Forwarder.
     *
     *  See PE specification.
     *
     *  @{ */
    SgAsmGenericString* const& get_forwarder() const;
    void set_forwarder(SgAsmGenericString*);
    /** @} */

public:
    SgAsmPEExportEntry(SgAsmGenericString *name, unsigned ordinal, Rose::BinaryAnalysis::RelativeVirtualAddress export_rva,
                       SgAsmGenericString *forwarder);
    void dump(FILE *f,const char *prefix,ssize_t idx) const;
    /* Accessors. Override ROSETTA because we adjust parents. */

    /** Property: Biased ordinal.
     *
     *  This is the biased ordinal, which is the unbiased ordinal plus the ordinal base from the export directory.
     *  This is a read-only value calculated by following the parent pointer to the SgAsmPEExportSection node and
     *  then down to its SgAsmPEExportDirectory. If any links are missing then an error is returned. */
    Sawyer::Result<unsigned /*ordinal*/, std::string /*reason*/> biasedOrdinal() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    const Rose::BinaryAnalysis::RelativeVirtualAddress& get_export_rva() const ROSE_DEPRECATED("use get_exportRva");
    void set_export_rva(const Rose::BinaryAnalysis::RelativeVirtualAddress&) ROSE_DEPRECATED("use set_exportRva");
public:
    /** Destructor. */
    virtual ~SgAsmPEExportEntry();

public:
    /** Default constructor. */
    SgAsmPEExportEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportDirectory           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmPEExportDirectory);
IS_SERIALIZABLE(AsmPEExportDirectory);

#ifndef DOCUMENTATION
AsmPEExportDirectory.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmPEExportDirectory);
#if defined(SgAsmPEExportDirectory_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>

#ifdef ROSE_SgAsmPEExportDirectory_IMPL
#include <SgAsmGenericString.h>
#endif
#endif // SgAsmPEExportDirectory_HEADERS

#ifdef DOCUMENTATION
/** Export directory. */
class SgAsmPEExportDirectory: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "time_t", "timestamp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "vmajor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "vminor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "name_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "ord_base", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "size_t", "expaddr_n", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "size_t", "nameptr_n", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "expaddr_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "nameptr_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "ordinals_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmPEExportDirectory.setDataPrototype(
        "SgAsmGenericString*", "name", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmPEExportDirectory);
#if defined(SgAsmPEExportDirectory_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmPEExportDirectory -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmPEExportDirectory");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_res1);
        s & BOOST_SERIALIZATION_NVP(p_timestamp);
        s & BOOST_SERIALIZATION_NVP(p_vmajor);
        s & BOOST_SERIALIZATION_NVP(p_vminor);
        s & BOOST_SERIALIZATION_NVP(p_name_rva);
        s & BOOST_SERIALIZATION_NVP(p_ord_base);
        s & BOOST_SERIALIZATION_NVP(p_expaddr_n);
        s & BOOST_SERIALIZATION_NVP(p_nameptr_n);
        s & BOOST_SERIALIZATION_NVP(p_expaddr_rva);
        s & BOOST_SERIALIZATION_NVP(p_nameptr_rva);
        s & BOOST_SERIALIZATION_NVP(p_ordinals_rva);
        s & BOOST_SERIALIZATION_NVP(p_name);
        debugSerializationEnd("SgAsmPEExportDirectory");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* An Export Section begins with the Export Directory */
    struct PEExportDirectory_disk {
        uint32_t res1;         /* 0x00 Reserved, must be zero */
        uint32_t timestamp;    /* 0x04 Time that export data was created */
        uint16_t vmajor;       /* 0x08 Major version number (user defined) */
        uint16_t vminor;       /* 0x0a Minor version number (user defined) */
        uint32_t name_rva;     /* 0x0c Location of name of DLL */
        uint32_t ord_base;     /* 0x10 Starting ordinal for exports in this image (usually 1) */
        uint32_t expaddr_n;    /* 0x14 Number of entries in the export address table */
        uint32_t nameptr_n;    /* 0x18 Number of entries in the name pointer table and ordinal table */
        uint32_t expaddr_rva;  /* 0x1c Location of Export Address Table */
        uint32_t nameptr_rva;  /* 0x20 Location of Export Name Pointer Table */
        uint32_t ordinals_rva; /* 0x24 Location of Ordinal Table */
    }                               /* 0x28 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Reserved aread #1.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_res1() const;
    void set_res1(unsigned const&);
    /** @} */

public:
    /** Property: Time stamp.
     *
     *  See PE specification. 
     *  
     *  @{ */
    time_t const& get_timestamp() const;
    void set_timestamp(time_t const&);
    /** @} */

public:
    /** Property: VMajor.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_vmajor() const;
    void set_vmajor(unsigned const&);
    /** @} */

public:
    /** Property: VMinor.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_vminor() const;
    void set_vminor(unsigned const&);
    /** @} */

public:
    /** Property: RVA for name.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_name_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_name_rva();
    void set_name_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Ordinal base.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_ord_base() const;
    void set_ord_base(unsigned const&);
    /** @} */

public:
    /** Property: Expaddr_n.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_expaddr_n() const;
    void set_expaddr_n(size_t const&);
    /** @} */

public:
    /** Property: Nameptr_n.
     *
     *  See PE specification. 
     *  
     *  @{ */
    size_t const& get_nameptr_n() const;
    void set_nameptr_n(size_t const&);
    /** @} */

public:
    /** Property: Expaddr RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_expaddr_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_expaddr_rva();
    void set_expaddr_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Name pointer RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_nameptr_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_nameptr_rva();
    void set_nameptr_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Ordinals RVA.
     *
     *  See PE specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_ordinals_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_ordinals_rva();
    void set_ordinals_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  See PE specification. 
     *  
     *  @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEExportDirectory(SgAsmPEExportSection*);
    void dump(FILE *f, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmPEExportDirectory();

public:
    /** Default constructor. */
    SgAsmPEExportDirectory();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportDirectory_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmOperandList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmOperandList);
IS_SERIALIZABLE(AsmOperandList);

#ifndef DOCUMENTATION
AsmOperandList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmOperandList);
#if defined(SgAsmOperandList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmOperandList_HEADERS

#ifdef DOCUMENTATION
/** List of operands for an instruction. */
class SgAsmOperandList: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmOperandList.setDataPrototype(
        "SgAsmExpressionPtrList", "operands", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmOperandList);
#if defined(SgAsmOperandList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmOperandList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmOperandList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_operands);
        debugSerializationEnd("SgAsmOperandList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Ordered list of instruction operands.
     *
     *  The operand list is its own Sage node type (rather than operands being stored directly in the instruction node)
     *  because of limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmExpressionPtrList const& get_operands() const;
    SgAsmExpressionPtrList& get_operands();
    void set_operands(SgAsmExpressionPtrList const&);
    /** @} */
public:
    /** Append another operand expression to this node. */
    void appendOperand(SgAsmExpression* operand);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void append_operand(SgAsmExpression*) ROSE_DEPRECATED("use appendOperand");
public:
    /** Destructor. */
    virtual ~SgAsmOperandList();

public:
    /** Default constructor. */
    SgAsmOperandList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmOperandList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNullInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNullInstruction);
IS_SERIALIZABLE(AsmNullInstruction);

#ifndef DOCUMENTATION
AsmNullInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNullInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmNullInstruction);
#if defined(SgAsmNullInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNullInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNullInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        debugSerializationEnd("SgAsmNullInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    // there's only one kind of null instruction
    enum Kind { null_unknown };

public: // overrides
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmNullInstruction();

public:
    /** Default constructor. */
    SgAsmNullInstruction();

public:
    /** Constructor. */
    SgAsmNullInstruction(rose_addr_t const& address,
                         uint8_t const& architectureId);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNullInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEStringTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNEStringTable);
IS_SERIALIZABLE(AsmNEStringTable);

#ifndef DOCUMENTATION
AsmNEStringTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNEStringTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmNEStringTable);
#if defined(SgAsmNEStringTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNEStringTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNEStringTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        debugSerializationEnd("SgAsmNEStringTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    std::string get_string(rose_addr_t offset);
public:
    /** Destructor. */
    virtual ~SgAsmNEStringTable();

public:
    /** Default constructor. */
    SgAsmNEStringTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEStringTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNESectionTable);
IS_SERIALIZABLE(AsmNESectionTable);

#ifndef DOCUMENTATION
AsmNESectionTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTable.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTable.setDataPrototype(
        "unsigned", "sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTable.setDataPrototype(
        "rose_addr_t", "physicalSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTable.setDataPrototype(
        "rose_addr_t", "virtualSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNESectionTable);
#if defined(SgAsmNESectionTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNESectionTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNESectionTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_sector);
        s & BOOST_SERIALIZATION_NVP(p_physicalSize);
        s & BOOST_SERIALIZATION_NVP(p_virtualSize);
        debugSerializationEnd("SgAsmNESectionTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);

public:
    unsigned const& get_sector() const;
    void set_sector(unsigned const&);

public:
    rose_addr_t const& get_physicalSize() const;
    void set_physicalSize(rose_addr_t const&);

public:
    rose_addr_t const& get_virtualSize() const;
    void set_virtualSize(rose_addr_t const&);
public:
    explicit SgAsmNESectionTable(SgAsmNEFileHeader*);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    rose_addr_t get_physical_size() const ROSE_DEPRECATED("use get_physicalSize");
    void set_physical_size(rose_addr_t) ROSE_DEPRECATED("use set_physicalSize");
    rose_addr_t get_virtual_size() const ROSE_DEPRECATED("use get_virtualSize");
    void set_virtual_size(rose_addr_t) ROSE_DEPRECATED("use set_virtualSize");
public:
    /** Destructor. */
    virtual ~SgAsmNESectionTable();

public:
    /** Default constructor. */
    SgAsmNESectionTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESectionTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNESectionTableEntry);
IS_SERIALIZABLE(AsmNESectionTableEntry);

#ifndef DOCUMENTATION
AsmNESectionTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTableEntry.setDataPrototype(
        "unsigned", "sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physicalSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESectionTableEntry.setDataPrototype(
        "rose_addr_t", "virtualSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNESectionTableEntry);
#if defined(SgAsmNESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNESectionTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNESectionTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_sector);
        s & BOOST_SERIALIZATION_NVP(p_physicalSize);
        s & BOOST_SERIALIZATION_NVP(p_virtualSize);
        debugSerializationEnd("SgAsmNESectionTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. All fields are little endian. */
    struct NESectionTableEntry_disk {
        uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
        uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
        uint16_t    flags;                  /* 0x04 Segment bit flags */
        uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
    }                                     /* 0x08 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    enum NESectionFlags {
        SF_RESERVED         = 0x0e08,       /* these bits are reserved */

        SF_TYPE_MASK        = 0x0007,       /* segment-type field */
        SF_CODE             = 0x0000,       /* code-segment type */
        SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
        SF_ALLOC            = 0x0002,       /* loader allocates memory */
        SF_LOAD             = 0x0004,       /* load the segment */

        SF_MOVABLE          = 0x0010,       /* segment is not fixed */
        SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
        SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
        SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
        SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
        SF_DISCARDABLE      = 0x1000,       /* discardable */
        SF_DISCARD          = 0xf000        /* discard priority */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);

public:
    unsigned const& get_sector() const;
    void set_sector(unsigned const&);

public:
    rose_addr_t const& get_physicalSize() const;
    void set_physicalSize(rose_addr_t const&);

public:
    rose_addr_t const& get_virtualSize() const;
    void set_virtualSize(rose_addr_t const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
    void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
    void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    rose_addr_t get_physical_size() const ROSE_DEPRECATED("use get_physicalSize");
    void set_physical_size(rose_addr_t) ROSE_DEPRECATED("use set_physicalSize");
    rose_addr_t get_virtual_size() const ROSE_DEPRECATED("use get_virtualSize");
    void set_virtual_size(rose_addr_t) ROSE_DEPRECATED("use set_virtualSize");
public:
    /** Destructor. */
    virtual ~SgAsmNESectionTableEntry();

public:
    /** Default constructor. */
    SgAsmNESectionTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESectionTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNESection);
IS_SERIALIZABLE(AsmNESection);

#ifndef DOCUMENTATION
AsmNESection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmNESection);
#if defined(SgAsmNESection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmNESection_IMPL
#include <SgAsmNESectionTableEntry.h>
#include <SgAsmNERelocTable.h>
#endif
#endif // SgAsmNESection_HEADERS

#ifdef DOCUMENTATION
class SgAsmNESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESection.setDataPrototype(
        "SgAsmNESectionTableEntry*", "sectionTableEntry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNESection.setDataPrototype(
        "SgAsmNERelocTable*", "relocationTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNESection);
#if defined(SgAsmNESection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNESection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNESection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_sectionTableEntry);
        s & BOOST_SERIALIZATION_NVP(p_relocationTable);
        debugSerializationEnd("SgAsmNESection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmNESectionTableEntry* const& get_sectionTableEntry() const;
    void set_sectionTableEntry(SgAsmNESectionTableEntry* const&);

public:
    SgAsmNERelocTable* const& get_relocationTable() const;
    void set_relocationTable(SgAsmNERelocTable* const&);
public:
    explicit SgAsmNESection(SgAsmNEFileHeader *fhdr);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNESectionTableEntry* get_st_entry() const ROSE_DEPRECATED("use get_sectionTableEntry");
    void set_st_entry(SgAsmNESectionTableEntry*) ROSE_DEPRECATED("use set_sectionTableEntry");
    SgAsmNERelocTable* get_reloc_table() const ROSE_DEPRECATED("use get_relocationTable");
    void set_reloc_table(SgAsmNERelocTable*) ROSE_DEPRECATED("use set_relocationTable");
public:
    /** Destructor. */
    virtual ~SgAsmNESection();

public:
    /** Default constructor. */
    SgAsmNESection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNERelocTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNERelocTable);
IS_SERIALIZABLE(AsmNERelocTable);

#ifndef DOCUMENTATION
AsmNERelocTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNERelocTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocTable.setDataPrototype(
        "SgAsmNERelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNERelocTable);
#if defined(SgAsmNERelocTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNERelocTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNERelocTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmNERelocTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmNERelocEntryPtrList const& get_entries() const;
    SgAsmNERelocEntryPtrList& get_entries();
    void set_entries(SgAsmNERelocEntryPtrList const&);
public:
    explicit SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, SgAsmNESection *section);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmNERelocTable();

public:
    /** Default constructor. */
    SgAsmNERelocTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNERelocTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNERelocEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNERelocEntry);
IS_SERIALIZABLE(AsmNERelocEntry);

#ifndef DOCUMENTATION
AsmNERelocEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNERelocEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocSrcType", "src_type", "= SgAsmNERelocEntry::RF_SRCTYPE_8OFF",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocModifiers", "modifier", "= SgAsmNERelocEntry::RF_MODIFIER_SINGLE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocTgtType", "tgt_type", "= SgAsmNERelocEntry::RF_TGTTYPE_IREF",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocFlags", "flags", "= SgAsmNERelocEntry::RF_ADDITIVE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "rose_addr_t", "src_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iref_type", "iref", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iord_type", "iord", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iname_type", "iname", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::osfixup_type", "osfixup", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNERelocEntry);
#if defined(SgAsmNERelocEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNERelocEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNERelocEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_src_type);
        s & BOOST_SERIALIZATION_NVP(p_modifier);
        s & BOOST_SERIALIZATION_NVP(p_tgt_type);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_src_offset);
        s & BOOST_SERIALIZATION_NVP(p_iref);
        s & BOOST_SERIALIZATION_NVP(p_iord);
        s & BOOST_SERIALIZATION_NVP(p_iname);
        s & BOOST_SERIALIZATION_NVP(p_osfixup);
        debugSerializationEnd("SgAsmNERelocEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
     * than defining it here as a struct. */
    enum NERelocSrcType {
        RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
        RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
        RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
        RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
        RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
        RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
        RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
        RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
        RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
    };

    enum NERelocTgtType {
        RF_TGTTYPE_IREF     = 0,            /* Internal reference */
        RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
        RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
        RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */
    };

    enum NERelocModifiers {
        RF_MODIFIER_SINGLE  = 1,
        RF_MODIFIER_MULTI   = 3
    };

    enum NERelocFlags {
        RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
        RF_RESERVED         = 0x02,         /* reserved bits */
        RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
        RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
        RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
        RF_8ORDINAL         = 0x20          /* Ordinal is 8-bits rather than 16 */
    };

    // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support
    // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, rose_addr_t; and then use
    // member functions to access the data in the base class.
    struct iref_type { /*tgt_type==0x00: internal reference*/
        unsigned    sect_idx;       /* section index (1-origin) */
        unsigned    res1;           /* reserved */
        rose_addr_t tgt_offset;

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(sect_idx);
            s & BOOST_SERIALIZATION_NVP(res1);
            s & BOOST_SERIALIZATION_NVP(tgt_offset);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

        iref_type();
    };

    struct iord_type { /*tgt_type==0x01: imported ordinal*/
        unsigned    modref;         /* 1-based index into import module table */
        unsigned    ordinal;
        rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(modref);
            s & BOOST_SERIALIZATION_NVP(ordinal);
            s & BOOST_SERIALIZATION_NVP(addend);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

        iord_type();
    };

    struct iname_type { /*tgt_type==0x02: imported name*/
        unsigned    modref;         /* 1-based index into import module table */
        unsigned    nm_off;         /* offset into import procedure names */
        rose_addr_t      addend;    /* value to add (only present for flags & RF_2EXTRA) */

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(modref);
            s & BOOST_SERIALIZATION_NVP(nm_off);
            s & BOOST_SERIALIZATION_NVP(addend);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

        iname_type();
    };

    struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
        unsigned    type;
        unsigned    res3;

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(type);
            s & BOOST_SERIALIZATION_NVP(res3);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

        osfixup_type();
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    SgAsmNERelocEntry::NERelocSrcType const& get_src_type() const;
    void set_src_type(SgAsmNERelocEntry::NERelocSrcType const&);

public:
    SgAsmNERelocEntry::NERelocModifiers const& get_modifier() const;
    void set_modifier(SgAsmNERelocEntry::NERelocModifiers const&);

public:
    SgAsmNERelocEntry::NERelocTgtType const& get_tgt_type() const;
    void set_tgt_type(SgAsmNERelocEntry::NERelocTgtType const&);

public:
    SgAsmNERelocEntry::NERelocFlags const& get_flags() const;
    void set_flags(SgAsmNERelocEntry::NERelocFlags const&);

public:
    rose_addr_t const& get_src_offset() const;
    void set_src_offset(rose_addr_t const&);

public:
    SgAsmNERelocEntry::iref_type const& get_iref() const;
    void set_iref(SgAsmNERelocEntry::iref_type const&);

public:
    SgAsmNERelocEntry::iord_type const& get_iord() const;
    void set_iord(SgAsmNERelocEntry::iord_type const&);

public:
    SgAsmNERelocEntry::iname_type const& get_iname() const;
    void set_iname(SgAsmNERelocEntry::iname_type const&);

public:
    SgAsmNERelocEntry::osfixup_type const& get_osfixup() const;
    void set_osfixup(SgAsmNERelocEntry::osfixup_type const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size);
    rose_addr_t unparse(std::ostream&, const SgAsmGenericSection*, rose_addr_t spos) const;
    void dump(FILE*, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmNERelocEntry();

public:
    /** Default constructor. */
    SgAsmNERelocEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNERelocEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNENameTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNENameTable);
IS_SERIALIZABLE(AsmNENameTable);

#ifndef DOCUMENTATION
AsmNENameTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNENameTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNENameTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNENameTable.setDataPrototype(
        "SgUnsignedList", "ordinals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNENameTable);
#if defined(SgAsmNENameTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNENameTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNENameTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_names);
        s & BOOST_SERIALIZATION_NVP(p_ordinals);
        debugSerializationEnd("SgAsmNENameTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgStringList const& get_names() const;
    void set_names(SgStringList const&);

public:
    SgUnsignedList const& get_ordinals() const;
    void set_ordinals(SgUnsignedList const&);
public:
    SgAsmNENameTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    std::vector<std::string> get_namesByOrdinal(unsigned ordinal);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    std::vector<std::string> get_names_by_ordinal(unsigned) ROSE_DEPRECATED("use get_namesByOrdinal");
public:
    /** Destructor. */
    virtual ~SgAsmNENameTable();

public:
    /** Default constructor. */
    SgAsmNENameTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNENameTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEModuleTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNEModuleTable);
IS_SERIALIZABLE(AsmNEModuleTable);

#ifndef DOCUMENTATION
AsmNEModuleTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmNEModuleTable);
#if defined(SgAsmNEModuleTable_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmNEModuleTable_IMPL
#include <SgAsmNEStringTable.h>
#endif
#endif // SgAsmNEModuleTable_HEADERS

#ifdef DOCUMENTATION
class SgAsmNEModuleTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEModuleTable.setDataPrototype(
        "SgAsmNEStringTable*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEModuleTable.setDataPrototype(
        "SgAddressList", "nameOffsets", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEModuleTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNEModuleTable);
#if defined(SgAsmNEModuleTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNEModuleTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNEModuleTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_strtab);
        s & BOOST_SERIALIZATION_NVP(p_nameOffsets);
        s & BOOST_SERIALIZATION_NVP(p_names);
        debugSerializationEnd("SgAsmNEModuleTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmNEStringTable* const& get_strtab() const;
    void set_strtab(SgAsmNEStringTable* const&);

public:
    SgAddressList const& get_nameOffsets() const;
    void set_nameOffsets(SgAddressList const&);

public:
    SgStringList const& get_names() const;
    void set_names(SgStringList const&);
public:
    SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, SgAsmNEStringTable *strtab, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    const SgAddressList& get_name_offsets() const ROSE_DEPRECATED("use get_nameOffsets");
    void set_name_offsets(const SgAddressList&) ROSE_DEPRECATED("use set_nameOffsets");
public:
    /** Destructor. */
    virtual ~SgAsmNEModuleTable();

public:
    /** Default constructor. */
    SgAsmNEModuleTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEModuleTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNEFileHeader);
IS_SERIALIZABLE(AsmNEFileHeader);

#ifndef DOCUMENTATION
AsmNEFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmNEFileHeader);
#if defined(SgAsmNEFileHeader_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/Address.h>

#ifdef ROSE_SgAsmNEFileHeader_IMPL
#include <SgAsmDOSExtendedHeader.h>
#include <SgAsmNEEntryTable.h>
#include <SgAsmNEModuleTable.h>
#include <SgAsmNENameTable.h>
#include <SgAsmNESectionTable.h>
#endif
#endif // SgAsmNEFileHeader_HEADERS

#ifdef DOCUMENTATION
class SgAsmNEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_linker_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_linker_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_checksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_flags1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_autodata_sn", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_bss_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_stack_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_csip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_sssp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nsections", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nmodrefs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nnonresnames", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nmovable_entries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_sector_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nresources", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_exetype", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_flags2", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_winvers", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_sectab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_rsrctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_resnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_modreftab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_importnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nonresnametab_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fastload_sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fastload_nsectors", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmDOSExtendedHeader*", "dos2Header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNESectionTable*", "sectionTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNENameTable*", "residentNameTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNENameTable*", "nonresidentNameTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNEModuleTable*", "moduleTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNEEntryTable*", "entryTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNEFileHeader);
#if defined(SgAsmNEFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNEFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNEFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_e_linker_major);
        s & BOOST_SERIALIZATION_NVP(p_e_linker_minor);
        s & BOOST_SERIALIZATION_NVP(p_e_checksum);
        s & BOOST_SERIALIZATION_NVP(p_e_flags1);
        s & BOOST_SERIALIZATION_NVP(p_e_autodata_sn);
        s & BOOST_SERIALIZATION_NVP(p_e_bss_size);
        s & BOOST_SERIALIZATION_NVP(p_e_stack_size);
        s & BOOST_SERIALIZATION_NVP(p_e_csip);
        s & BOOST_SERIALIZATION_NVP(p_e_sssp);
        s & BOOST_SERIALIZATION_NVP(p_e_nsections);
        s & BOOST_SERIALIZATION_NVP(p_e_nmodrefs);
        s & BOOST_SERIALIZATION_NVP(p_e_nnonresnames);
        s & BOOST_SERIALIZATION_NVP(p_e_nmovable_entries);
        s & BOOST_SERIALIZATION_NVP(p_e_sector_align);
        s & BOOST_SERIALIZATION_NVP(p_e_nresources);
        s & BOOST_SERIALIZATION_NVP(p_e_exetype);
        s & BOOST_SERIALIZATION_NVP(p_e_flags2);
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
        s & BOOST_SERIALIZATION_NVP(p_e_winvers);
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_size);
        s & BOOST_SERIALIZATION_NVP(p_e_sectab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_resnametab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_modreftab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_importnametab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_offset);
        s & BOOST_SERIALIZATION_NVP(p_e_fastload_sector);
        s & BOOST_SERIALIZATION_NVP(p_e_fastload_nsectors);
        s & BOOST_SERIALIZATION_NVP(p_dos2Header);
        s & BOOST_SERIALIZATION_NVP(p_sectionTable);
        s & BOOST_SERIALIZATION_NVP(p_residentNameTable);
        s & BOOST_SERIALIZATION_NVP(p_nonresidentNameTable);
        s & BOOST_SERIALIZATION_NVP(p_moduleTable);
        s & BOOST_SERIALIZATION_NVP(p_entryTable);
        debugSerializationEnd("SgAsmNEFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of an NE File Header. All fields are little endian.
     *
     * NOTES
     *
     * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
     *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
     *         of the stack. */
    struct NEFileHeader_disk {
         unsigned char e_magic[2];           /* 0x00 magic number "NE" */
         unsigned char e_linker_major;       /* 0x02 linker major version number */
         unsigned char e_linker_minor;       /* 0x03 linker minor version number */
         uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
         uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
         uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
         uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
         uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
         uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
         uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
         uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
         uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
         uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
         uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
         uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
         uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
         uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
         uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
         uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
         uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
         uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
         uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
         uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
         uint16_t    e_nresources;           /* 0x34 number of resource entries */
         unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
         unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
         uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
         uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
         uint16_t    e_res1;                 /* 0x3c reserved */
         uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
       }                                     /* 0x40 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* Bit flags for the NE header 'e_flags' member.
     *
     * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
     * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
     * value in AX is a status indicator (non-zero for success, zero for failure). */
    enum HeaderFlags1 {
         HF1_RESERVED         = 0x57f4,      /* Reserved bits */
         HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
         HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
         HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
         HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
         HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
         HF1_LIBRARY          = 0x8000       /* Module is a library */
       };

    /* Bit flags for the NE header 'e_flags2' member. */
    enum HeaderFlags2 {
         HF2_RESERVED         = 0xf1,        /* Reserved bits */
         HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
         HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
         HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
       };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    unsigned const& get_e_linker_major() const;
    void set_e_linker_major(unsigned const&);

public:
    unsigned const& get_e_linker_minor() const;
    void set_e_linker_minor(unsigned const&);

public:
    unsigned const& get_e_checksum() const;
    void set_e_checksum(unsigned const&);

public:
    unsigned const& get_e_flags1() const;
    void set_e_flags1(unsigned const&);

public:
    unsigned const& get_e_autodata_sn() const;
    void set_e_autodata_sn(unsigned const&);

public:
    unsigned const& get_e_bss_size() const;
    void set_e_bss_size(unsigned const&);

public:
    unsigned const& get_e_stack_size() const;
    void set_e_stack_size(unsigned const&);

public:
    unsigned const& get_e_csip() const;
    void set_e_csip(unsigned const&);

public:
    unsigned const& get_e_sssp() const;
    void set_e_sssp(unsigned const&);

public:
    unsigned const& get_e_nsections() const;
    void set_e_nsections(unsigned const&);

public:
    unsigned const& get_e_nmodrefs() const;
    void set_e_nmodrefs(unsigned const&);

public:
    unsigned const& get_e_nnonresnames() const;
    void set_e_nnonresnames(unsigned const&);

public:
    unsigned const& get_e_nmovable_entries() const;
    void set_e_nmovable_entries(unsigned const&);

public:
    unsigned const& get_e_sector_align() const;
    void set_e_sector_align(unsigned const&);

public:
    unsigned const& get_e_nresources() const;
    void set_e_nresources(unsigned const&);

public:
    unsigned const& get_e_exetype() const;
    void set_e_exetype(unsigned const&);

public:
    unsigned const& get_e_flags2() const;
    void set_e_flags2(unsigned const&);

public:
    unsigned const& get_e_res1() const;
    void set_e_res1(unsigned const&);

public:
    unsigned const& get_e_winvers() const;
    void set_e_winvers(unsigned const&);

public:
    rose_addr_t const& get_e_entrytab_rfo() const;
    void set_e_entrytab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_entrytab_size() const;
    void set_e_entrytab_size(rose_addr_t const&);

public:
    rose_addr_t const& get_e_sectab_rfo() const;
    void set_e_sectab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_rsrctab_rfo() const;
    void set_e_rsrctab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_resnametab_rfo() const;
    void set_e_resnametab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_modreftab_rfo() const;
    void set_e_modreftab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_importnametab_rfo() const;
    void set_e_importnametab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_nonresnametab_offset() const;
    void set_e_nonresnametab_offset(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fastload_sector() const;
    void set_e_fastload_sector(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fastload_nsectors() const;
    void set_e_fastload_nsectors(rose_addr_t const&);

public:
    SgAsmDOSExtendedHeader* const& get_dos2Header() const;
    void set_dos2Header(SgAsmDOSExtendedHeader* const&);

public:
    SgAsmNESectionTable* const& get_sectionTable() const;
    void set_sectionTable(SgAsmNESectionTable* const&);

public:
    SgAsmNENameTable* const& get_residentNameTable() const;
    void set_residentNameTable(SgAsmNENameTable* const&);

public:
    SgAsmNENameTable* const& get_nonresidentNameTable() const;
    void set_nonresidentNameTable(SgAsmNENameTable* const&);

public:
    SgAsmNEModuleTable* const& get_moduleTable() const;
    void set_moduleTable(SgAsmNEModuleTable* const&);

public:
    SgAsmNEEntryTable* const& get_entryTable() const;
    void set_entryTable(SgAsmNEEntryTable* const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNEFileHeader(SgAsmGenericFile *f, rose_addr_t offset);

    static bool isNe (SgAsmGenericFile*);
    static SgAsmNEFileHeader *parse(SgAsmDOSFileHeader*);
    virtual void unparse(std::ostream&) const override;
    virtual const char *formatName() const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

private:
    void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmDOSExtendedHeader* get_dos2_header() const ROSE_DEPRECATED("use get_dos2Header");
    void set_dos2_header(SgAsmDOSExtendedHeader*) ROSE_DEPRECATED("use set_dos2Header");
    SgAsmNESectionTable* get_section_table() const ROSE_DEPRECATED("use get_sectionTable");
    void set_section_table(SgAsmNESectionTable*) ROSE_DEPRECATED("use set_sectionTable");
    SgAsmNENameTable* get_resname_table() const ROSE_DEPRECATED("use get_residentNameTable");
    void set_resname_table(SgAsmNENameTable*) ROSE_DEPRECATED("use set_residentNameTable");
    SgAsmNENameTable* get_nonresname_table() const ROSE_DEPRECATED("use get_nonresidentNameTable");
    void set_nonresname_table(SgAsmNENameTable*) ROSE_DEPRECATED("use set_nonresidentNameTable");
    SgAsmNEModuleTable* get_module_table() const ROSE_DEPRECATED("use get_moduleTable");
    void set_module_table(SgAsmNEModuleTable*) ROSE_DEPRECATED("use set_moduleTable");
    SgAsmNEEntryTable* get_entry_table() const ROSE_DEPRECATED("use get_entryTable");
    void set_entry_table(SgAsmNEEntryTable*) ROSE_DEPRECATED("use set_entryTable");
    static bool is_NE (SgAsmGenericFile*) ROSE_DEPRECATED("use isNe");
    virtual const char *format_name() const override ROSE_DEPRECATED("use formatName");
public:
    /** Destructor. */
    virtual ~SgAsmNEFileHeader();

public:
    /** Default constructor. */
    SgAsmNEFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEEntryTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNEEntryTable);
IS_SERIALIZABLE(AsmNEEntryTable);

#ifndef DOCUMENTATION
AsmNEEntryTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNEEntryTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryTable.setDataPrototype(
        "SgSizeTList", "bundle_sizes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryTable.setDataPrototype(
        "SgAsmNEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNEEntryTable);
#if defined(SgAsmNEEntryTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNEEntryTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNEEntryTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_bundle_sizes);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmNEEntryTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgSizeTList const& get_bundle_sizes() const;
    void set_bundle_sizes(SgSizeTList const&);

public:
    SgAsmNEEntryPointPtrList const& get_entries() const;
    SgAsmNEEntryPointPtrList& get_entries();
    void set_entries(SgAsmNEEntryPointPtrList const&);
public:
    SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    void populate_entries();
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmNEEntryTable();

public:
    /** Default constructor. */
    SgAsmNEEntryTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEEntryTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmNEEntryPoint);
IS_SERIALIZABLE(AsmNEEntryPoint);

#ifndef DOCUMENTATION
AsmNEEntryPoint.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmNEEntryPoint: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryPoint.setDataPrototype(
        "SgAsmNEEntryPoint::NEEntryFlags", "flags", "= SgAsmNEEntryPoint::EF_ZERO",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "int3f", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "sectionIndex", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "sectionOffset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmNEEntryPoint);
#if defined(SgAsmNEEntryPoint_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNEEntryPoint -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNEEntryPoint");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_int3f);
        s & BOOST_SERIALIZATION_NVP(p_sectionIndex);
        s & BOOST_SERIALIZATION_NVP(p_sectionOffset);
        debugSerializationEnd("SgAsmNEEntryPoint");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum NEEntryFlags {
        EF_ZERO             = 0x00,                     /* No flags set */
        EF_RESERVED         = 0xfc,                     /* Reserved bits */
        EF_EXPORTED         = 0x01,                     /* Exported */
        EF_GLOBAL           = 0x02                      /* Uses a global (shared) data section */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    SgAsmNEEntryPoint::NEEntryFlags const& get_flags() const;
    void set_flags(SgAsmNEEntryPoint::NEEntryFlags const&);

public:
    unsigned const& get_int3f() const;
    void set_int3f(unsigned const&);

public:
    unsigned const& get_sectionIndex() const;
    void set_sectionIndex(unsigned const&);

public:
    unsigned const& get_sectionOffset() const;
    void set_sectionOffset(unsigned const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);
    void dump(FILE*, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    unsigned get_section_idx() const ROSE_DEPRECATED("use get_sectionIndex");
    void set_section_idx(unsigned) ROSE_DEPRECATED("use set_sectionIndex");
    unsigned get_section_offset() const ROSE_DEPRECATED("use get_sectionOffset");
    void set_section_offset(unsigned) ROSE_DEPRECATED("use set_sectionOffset");
public:
    /** Destructor. */
    virtual ~SgAsmNEEntryPoint();

public:
    /** Default constructor. */
    SgAsmNEEntryPoint();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEEntryPoint_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmMipsInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmMipsInstruction);
IS_SERIALIZABLE(AsmMipsInstruction);

#ifndef DOCUMENTATION
AsmMipsInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmMipsInstruction);
#if defined(SgAsmMipsInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/InstructionEnumsMips.h>
#endif // SgAsmMipsInstruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one MIPS machine instruction. */
class SgAsmMipsInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmMipsInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::MipsInstructionKind", "kind", "= Rose::BinaryAnalysis::mips_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmMipsInstruction);
#if defined(SgAsmMipsInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmMipsInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmMipsInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        debugSerializationEnd("SgAsmMipsInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the MIPS instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::MipsInstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::MipsInstructionKind const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmMipsInstruction();

public:
    /** Default constructor. */
    SgAsmMipsInstruction();

public:
    /** Constructor. */
    SgAsmMipsInstruction(rose_addr_t const& address,
                         uint8_t const& architectureId,
                         Rose::BinaryAnalysis::MipsInstructionKind const& kind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmMipsInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmMemoryReferenceExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmMemoryReferenceExpression);
IS_SERIALIZABLE(AsmMemoryReferenceExpression);

#ifndef DOCUMENTATION
AsmMemoryReferenceExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Reference to memory locations. */
class SgAsmMemoryReferenceExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmMemoryReferenceExpression.setDataPrototype(
        "SgAsmExpression*", "address", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmMemoryReferenceExpression.setDataPrototype(
        "SgAsmExpression*", "segment", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmMemoryReferenceExpression);
#if defined(SgAsmMemoryReferenceExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmMemoryReferenceExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmMemoryReferenceExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_address);
        s & BOOST_SERIALIZATION_NVP(p_segment);
        debugSerializationEnd("SgAsmMemoryReferenceExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Memory address expression.
     *
     *  This property stores the address of the memory reference.  If the reference is for multiple bytes of memory, then
     *  only one address is stored and the instruction semantics determine which address it is. Usually multi-byte
     *  references store the lowest address. 
     *  
     *  @{ */
    SgAsmExpression* const& get_address() const;
    void set_address(SgAsmExpression* const&);
    /** @} */

public:
    /** Property: Optional memory segment register.
     *
     *  If a segment register is specified then the actual memory address is formed by adding the stored memory address to
     *  the current value of the segment register.  The x86 architecture is the only ROSE architecture that uses segment
     *  registers, and most of the time they are initialized to zero by the instruction semantics. 
     *  
     *  @{ */
    SgAsmExpression* const& get_segment() const;
    void set_segment(SgAsmExpression* const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmMemoryReferenceExpression();

public:
    /** Default constructor. */
    SgAsmMemoryReferenceExpression();

public:
    /** Constructor. */
    SgAsmMemoryReferenceExpression(SgAsmExpression* const& address,
                                   SgAsmExpression* const& segment);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmMemoryReferenceExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmM68kInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmM68kInstruction);
IS_SERIALIZABLE(AsmM68kInstruction);

#ifndef DOCUMENTATION
AsmM68kInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmM68kInstruction);
#if defined(SgAsmM68kInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/InstructionEnumsM68k.h>
#endif // SgAsmM68kInstruction_HEADERS

#ifdef DOCUMENTATION
class SgAsmM68kInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmM68kInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::M68kInstructionKind", "kind", "= Rose::BinaryAnalysis::m68k_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmM68kInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::M68kDataFormat", "dataFormat", "= Rose::BinaryAnalysis::m68k_fmt_unknown",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmM68kInstruction);
#if defined(SgAsmM68kInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmM68kInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmM68kInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        s & BOOST_SERIALIZATION_NVP(p_dataFormat);
        debugSerializationEnd("SgAsmM68kInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the Motorola m68k instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::M68kInstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::M68kInstructionKind const&);
    /** @} */

public:
    /** Property: Data format. 
     * 
     * @{ */
    Rose::BinaryAnalysis::M68kDataFormat const& get_dataFormat() const;
    void set_dataFormat(Rose::BinaryAnalysis::M68kDataFormat const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmM68kInstruction();

public:
    /** Default constructor. */
    SgAsmM68kInstruction();

public:
    /** Constructor. */
    SgAsmM68kInstruction(rose_addr_t const& address,
                         uint8_t const& architectureId,
                         Rose::BinaryAnalysis::M68kInstructionKind const& kind,
                         Rose::BinaryAnalysis::M68kDataFormat const& dataFormat);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmM68kInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLESectionTable);
IS_SERIALIZABLE(AsmLESectionTable);

#ifndef DOCUMENTATION
AsmLESectionTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmLESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmLESectionTable);
#if defined(SgAsmLESectionTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLESectionTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLESectionTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        debugSerializationEnd("SgAsmLESectionTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmLESectionTable();

public:
    /** Default constructor. */
    SgAsmLESectionTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESectionTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLESectionTableEntry);
IS_SERIALIZABLE(AsmLESectionTableEntry);

#ifndef DOCUMENTATION
AsmLESectionTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmLESectionTableEntry);
#if defined(SgAsmLESectionTableEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmLESectionTableEntry_HEADERS

#ifdef DOCUMENTATION
class SgAsmLESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "pageMapIndex", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "pageMapNEntries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "rose_addr_t", "mappedSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESectionTableEntry.setDataPrototype(
        "rose_addr_t", "baseAddr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLESectionTableEntry);
#if defined(SgAsmLESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLESectionTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLESectionTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_pageMapIndex);
        s & BOOST_SERIALIZATION_NVP(p_pageMapNEntries);
        s & BOOST_SERIALIZATION_NVP(p_res1);
        s & BOOST_SERIALIZATION_NVP(p_mappedSize);
        s & BOOST_SERIALIZATION_NVP(p_baseAddr);
        debugSerializationEnd("SgAsmLESectionTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
    struct LESectionTableEntry_disk {
        uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
        uint32_t    base_addr;              /* 0x04 relocation base address */
        uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
        uint32_t    pagemap_index;          /* 0x0c */
        uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
        uint32_t    res1;                   /* 0x14 reserved */
    }                                     /* 0x18 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
     *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
     *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
     *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
     *             stream.) */
    enum LESectionFlags {
        SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */

        SF_READABLE         = 0x00000001,   /**< Read permission granted when mapped */
        SF_WRITABLE         = 0x00000002,   /**< Write permission granted when mapped */
        SF_EXECUTABLE       = 0x00000004,   /**< Execute permission granted when mapped */

        SF_RESOURCE         = 0x00000008,   /**< Section contains resource objects */
        SF_DISCARDABLE      = 0x00000010,   /**< Discardable section */
        SF_SHARED           = 0x00000020,   /**< Section is shared */
        SF_PRELOAD_PAGES    = 0x00000040,   /**< Section has preload pages */
        SF_INVALID_PAGES    = 0x00000080,   /**< Section has invalid pages */

        SF_TYPE_MASK        = 0x00000300,        /*NO_STRINGIFY*/
        SF_TYPE_NORMAL      = 0x00000000,
        SF_TYPE_ZERO        = 0x00000100,   /**< Section has zero-filled pages */
        SF_TYPE_RESIDENT    = 0x00000200,   /**< Section is resident (valid for VDDs and PDDs only) */
        SF_TYPE_RESCONT     = 0x00000300,   /**< Section is resident and contiguous */

        SF_RES_LONG_LOCK    = 0x00000400,   /**< Section is resident and "long-lockable" (VDDs and PDDs only) */
        SF_1616_ALIAS       = 0x00001000,   /**< 16:16 alias required (80x86 specific) */
        SF_BIG_BIT          = 0x00002000,   /**< Big/default bit setting (80x86 specific); see note above */
        SF_CODE_CONFORM     = 0x00004000,   /**< Section is conforming for code (80x86 specific) */
        SF_IO_PRIV          = 0x00008000    /**< Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);

public:
    unsigned const& get_pageMapIndex() const;
    void set_pageMapIndex(unsigned const&);

public:
    unsigned const& get_pageMapNEntries() const;
    void set_pageMapNEntries(unsigned const&);

public:
    unsigned const& get_res1() const;
    void set_res1(unsigned const&);

public:
    rose_addr_t const& get_mappedSize() const;
    void set_mappedSize(rose_addr_t const&);

public:
    rose_addr_t const& get_baseAddr() const;
    void set_baseAddr(rose_addr_t const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLESectionTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                             const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    unsigned get_pagemap_index() const ROSE_DEPRECATED("use get pageMapIndex");
    void set_pagemap_index(unsigned) ROSE_DEPRECATED("use set_pageMapIndex");
    unsigned get_pagemap_nentries() const ROSE_DEPRECATED("use get_pageMapNEntries");
    void set_pagemap_nentries(unsigned) ROSE_DEPRECATED("use set_pageMapNEntries");
    rose_addr_t get_mapped_size() const ROSE_DEPRECATED("use get_mappedSize");
    void set_mapped_size(rose_addr_t) ROSE_DEPRECATED("use set_mappedSize");
    rose_addr_t get_base_addr() const ROSE_DEPRECATED("use get_baseAddr");
    void set_base_addr(rose_addr_t) ROSE_DEPRECATED("use set_baseAddr");
public:
    /** Destructor. */
    virtual ~SgAsmLESectionTableEntry();

public:
    /** Default constructor. */
    SgAsmLESectionTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESectionTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLESection);
IS_SERIALIZABLE(AsmLESection);

#ifndef DOCUMENTATION
AsmLESection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmLESection);
#if defined(SgAsmLESection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmLESection_IMPL
#include <SgAsmLESectionTableEntry.h>
#endif
#endif // SgAsmLESection_HEADERS

#ifdef DOCUMENTATION
class SgAsmLESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLESection.setDataPrototype(
        "SgAsmLESectionTableEntry*", "sectionTableEntry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLESection);
#if defined(SgAsmLESection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLESection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLESection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_sectionTableEntry);
        debugSerializationEnd("SgAsmLESection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmLESectionTableEntry* const& get_sectionTableEntry() const;
    void set_sectionTableEntry(SgAsmLESectionTableEntry* const&);
public:
    explicit SgAsmLESection(SgAsmLEFileHeader*);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLESectionTableEntry* get_st_entry() const ROSE_DEPRECATED("use get_sectionTableEntry");
    void set_st_entry(SgAsmLESectionTableEntry*) ROSE_DEPRECATED("use set_sectionTableEntry");
public:
    /** Destructor. */
    virtual ~SgAsmLESection();

public:
    /** Default constructor. */
    SgAsmLESection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLERelocTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLERelocTable);
IS_SERIALIZABLE(AsmLERelocTable);

#ifndef DOCUMENTATION
AsmLERelocTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmLERelocTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLERelocTable.setDataPrototype(
        "SgAsmLERelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLERelocTable);
#if defined(SgAsmLERelocTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLERelocTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLERelocTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmLERelocTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmLERelocEntryPtrList const& get_entries() const;
    SgAsmLERelocEntryPtrList& get_entries();
    void set_entries(SgAsmLERelocEntryPtrList const&);
public:
    SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmLERelocTable();

public:
    /** Default constructor. */
    SgAsmLERelocTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLERelocTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEPageTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLEPageTable);
IS_SERIALIZABLE(AsmLEPageTable);

#ifndef DOCUMENTATION
AsmLEPageTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmLEPageTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEPageTable.setDataPrototype(
        "SgAsmLEPageTableEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLEPageTable);
#if defined(SgAsmLEPageTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLEPageTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLEPageTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmLEPageTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmLEPageTableEntryPtrList const& get_entries() const;
    SgAsmLEPageTableEntryPtrList& get_entries();
    void set_entries(SgAsmLEPageTableEntryPtrList const&);
public:
    SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    SgAsmLEPageTableEntry *get_page(size_t idx);
public:
    /** Destructor. */
    virtual ~SgAsmLEPageTable();

public:
    /** Default constructor. */
    SgAsmLEPageTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEPageTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEPageTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLEPageTableEntry);
IS_SERIALIZABLE(AsmLEPageTableEntry);

#ifndef DOCUMENTATION
AsmLEPageTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmLEPageTableEntry);
#if defined(SgAsmLEPageTableEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmLEPageTableEntry_HEADERS

#ifdef DOCUMENTATION
class SgAsmLEPageTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEPageTableEntry.setDataPrototype(
        "unsigned", "pageno", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEPageTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLEPageTableEntry);
#if defined(SgAsmLEPageTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLEPageTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLEPageTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_pageno);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        debugSerializationEnd("SgAsmLEPageTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
     * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while still
     * allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
     * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they are
     * both indexed by the logical page number). */

#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format for a page table entry */
    struct LEPageTableEntry_disk {
        uint16_t            pageno_hi;
        unsigned char       pageno_lo;
        unsigned char       flags;
    }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    unsigned const& get_pageno() const;
    void set_pageno(unsigned const&);

public:
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEPageTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                          const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);
    void dump(FILE*, const char *prefix, ssize_t idx) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;
public:
    /** Destructor. */
    virtual ~SgAsmLEPageTableEntry();

public:
    /** Default constructor. */
    SgAsmLEPageTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEPageTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLENameTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLENameTable);
IS_SERIALIZABLE(AsmLENameTable);

#ifndef DOCUMENTATION
AsmLENameTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmLENameTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLENameTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLENameTable.setDataPrototype(
        "SgUnsignedList", "ordinals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLENameTable);
#if defined(SgAsmLENameTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLENameTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLENameTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_names);
        s & BOOST_SERIALIZATION_NVP(p_ordinals);
        debugSerializationEnd("SgAsmLENameTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgStringList const& get_names() const;
    void set_names(SgStringList const&);

public:
    SgUnsignedList const& get_ordinals() const;
    void set_ordinals(SgUnsignedList const&);
public:
    /* This table contains a module name followed by the list of exported function names. Each name is associated with an "ordinal"
     * which serves as an index into the Entry Table. The ordinal for the first string (module name) is meaningless and should be
     * zero. In the non-resident name table the first entry is a module description and the functions are not always resident in
     * system memory (they are discardable). */
    SgAsmLENameTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmLENameTable();

public:
    /** Default constructor. */
    SgAsmLENameTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLENameTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLEFileHeader);
IS_SERIALIZABLE(AsmLEFileHeader);

#ifndef DOCUMENTATION
AsmLEFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmLEFileHeader);
#if defined(SgAsmLEFileHeader_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>

#ifdef ROSE_SgAsmLEFileHeader_IMPL
#include <SgAsmDOSExtendedHeader.h>
#include <SgAsmLEEntryTable.h>
#include <SgAsmLENameTable.h>
#include <SgAsmLEPageTable.h>
#include <SgAsmLERelocTable.h>
#include <SgAsmLESectionTable.h>
#endif
#endif // SgAsmLEFileHeader_HEADERS

#ifdef DOCUMENTATION
class SgAsmLEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_byte_order", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_word_order", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_format_level", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_cpu_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_os_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_module_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_eip_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_esp_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_last_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_page_offset_shift", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_fixup_sect_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_loader_sect_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_secttab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_rsrctab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_fmtdirtab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_import_modtab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_preload_npages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_nonresnametab_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_nonresnametab_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_auto_ds_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_debug_info_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_num_instance_preload", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_num_instance_demand", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_heap_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_npages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_eip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_esp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_sect_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_loader_sect_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_secttab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_pagetab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_iterpages_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_rsrctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_resnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fmtdirtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_pagetab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_rectab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_import_modtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_import_proctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_ppcksumtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_data_pages_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nonresnametab_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_debug_info_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmDOSExtendedHeader*", "dos2Header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLESectionTable*", "sectionTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLEPageTable*", "pageTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLENameTable*", "residentNameTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLENameTable*", "nonresidentNameTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLEEntryTable*", "entryTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLERelocTable*", "relocationTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLEFileHeader);
#if defined(SgAsmLEFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLEFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLEFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_e_byte_order);
        s & BOOST_SERIALIZATION_NVP(p_e_word_order);
        s & BOOST_SERIALIZATION_NVP(p_e_format_level);
        s & BOOST_SERIALIZATION_NVP(p_e_cpu_type);
        s & BOOST_SERIALIZATION_NVP(p_e_os_type);
        s & BOOST_SERIALIZATION_NVP(p_e_module_version);
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
        s & BOOST_SERIALIZATION_NVP(p_e_eip_section);
        s & BOOST_SERIALIZATION_NVP(p_e_esp_section);
        s & BOOST_SERIALIZATION_NVP(p_e_last_page_size);
        s & BOOST_SERIALIZATION_NVP(p_e_page_offset_shift);
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_sect_cksum);
        s & BOOST_SERIALIZATION_NVP(p_e_loader_sect_cksum);
        s & BOOST_SERIALIZATION_NVP(p_e_secttab_nentries);
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_nentries);
        s & BOOST_SERIALIZATION_NVP(p_e_fmtdirtab_nentries);
        s & BOOST_SERIALIZATION_NVP(p_e_import_modtab_nentries);
        s & BOOST_SERIALIZATION_NVP(p_e_preload_npages);
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_size);
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_cksum);
        s & BOOST_SERIALIZATION_NVP(p_e_auto_ds_section);
        s & BOOST_SERIALIZATION_NVP(p_e_debug_info_size);
        s & BOOST_SERIALIZATION_NVP(p_e_num_instance_preload);
        s & BOOST_SERIALIZATION_NVP(p_e_num_instance_demand);
        s & BOOST_SERIALIZATION_NVP(p_e_heap_size);
        s & BOOST_SERIALIZATION_NVP(p_e_npages);
        s & BOOST_SERIALIZATION_NVP(p_e_eip);
        s & BOOST_SERIALIZATION_NVP(p_e_esp);
        s & BOOST_SERIALIZATION_NVP(p_e_page_size);
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_sect_size);
        s & BOOST_SERIALIZATION_NVP(p_e_loader_sect_size);
        s & BOOST_SERIALIZATION_NVP(p_e_secttab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_pagetab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_iterpages_offset);
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_resnametab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_fmtdirtab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_pagetab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_rectab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_import_modtab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_import_proctab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_ppcksumtab_rfo);
        s & BOOST_SERIALIZATION_NVP(p_e_data_pages_offset);
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_offset);
        s & BOOST_SERIALIZATION_NVP(p_e_debug_info_rfo);
        s & BOOST_SERIALIZATION_NVP(p_dos2Header);
        s & BOOST_SERIALIZATION_NVP(p_sectionTable);
        s & BOOST_SERIALIZATION_NVP(p_pageTable);
        s & BOOST_SERIALIZATION_NVP(p_residentNameTable);
        s & BOOST_SERIALIZATION_NVP(p_nonresidentNameTable);
        s & BOOST_SERIALIZATION_NVP(p_entryTable);
        s & BOOST_SERIALIZATION_NVP(p_relocationTable);
        debugSerializationEnd("SgAsmLEFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
    struct LEFileHeader_disk {
        unsigned char e_magic[2];           /* 0x00 magic number "LX" */
        unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
        unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
        uint32_t    e_format_level;         /* 0x04 LX file format version number */
        uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
        uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
        uint32_t    e_module_version;       /* 0x0c user-specified module version number */
        uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
        uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
        uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
        uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
        uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
        uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
        uint32_t    e_page_size;            /* 0x28 page size in bytes */
        uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
        uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
        uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
        uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
        uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
        uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
        uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
        uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
        uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
        uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
        uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
        uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
        uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
        uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
        uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
        uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
        uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
        uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
        uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
        uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
        uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
        uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
        uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
        uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
        uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
        uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
        uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
        uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
        uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
        uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
        uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
        uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
    }                                       /* 0xac */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    enum LEFileHeaderFlags {
        HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
        HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
        HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
        HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
        HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
        HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
        HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
        HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
        HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */

        HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
        HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
        HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
        HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
        HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
        HF_MODTYPE_VDEV     = 0x00028000    /* Virtual device driver module */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    unsigned const& get_e_byte_order() const;
    void set_e_byte_order(unsigned const&);

public:
    unsigned const& get_e_word_order() const;
    void set_e_word_order(unsigned const&);

public:
    unsigned const& get_e_format_level() const;
    void set_e_format_level(unsigned const&);

public:
    unsigned const& get_e_cpu_type() const;
    void set_e_cpu_type(unsigned const&);

public:
    unsigned const& get_e_os_type() const;
    void set_e_os_type(unsigned const&);

public:
    unsigned const& get_e_module_version() const;
    void set_e_module_version(unsigned const&);

public:
    unsigned const& get_e_flags() const;
    void set_e_flags(unsigned const&);

public:
    unsigned const& get_e_eip_section() const;
    void set_e_eip_section(unsigned const&);

public:
    unsigned const& get_e_esp_section() const;
    void set_e_esp_section(unsigned const&);

public:
    unsigned const& get_e_last_page_size() const;
    void set_e_last_page_size(unsigned const&);

public:
    unsigned const& get_e_page_offset_shift() const;
    void set_e_page_offset_shift(unsigned const&);

public:
    unsigned const& get_e_fixup_sect_cksum() const;
    void set_e_fixup_sect_cksum(unsigned const&);

public:
    unsigned const& get_e_loader_sect_cksum() const;
    void set_e_loader_sect_cksum(unsigned const&);

public:
    unsigned const& get_e_secttab_nentries() const;
    void set_e_secttab_nentries(unsigned const&);

public:
    unsigned const& get_e_rsrctab_nentries() const;
    void set_e_rsrctab_nentries(unsigned const&);

public:
    unsigned const& get_e_fmtdirtab_nentries() const;
    void set_e_fmtdirtab_nentries(unsigned const&);

public:
    unsigned const& get_e_import_modtab_nentries() const;
    void set_e_import_modtab_nentries(unsigned const&);

public:
    unsigned const& get_e_preload_npages() const;
    void set_e_preload_npages(unsigned const&);

public:
    unsigned const& get_e_nonresnametab_size() const;
    void set_e_nonresnametab_size(unsigned const&);

public:
    unsigned const& get_e_nonresnametab_cksum() const;
    void set_e_nonresnametab_cksum(unsigned const&);

public:
    unsigned const& get_e_auto_ds_section() const;
    void set_e_auto_ds_section(unsigned const&);

public:
    unsigned const& get_e_debug_info_size() const;
    void set_e_debug_info_size(unsigned const&);

public:
    unsigned const& get_e_num_instance_preload() const;
    void set_e_num_instance_preload(unsigned const&);

public:
    unsigned const& get_e_num_instance_demand() const;
    void set_e_num_instance_demand(unsigned const&);

public:
    unsigned const& get_e_heap_size() const;
    void set_e_heap_size(unsigned const&);

public:
    rose_addr_t const& get_e_npages() const;
    void set_e_npages(rose_addr_t const&);

public:
    rose_addr_t const& get_e_eip() const;
    void set_e_eip(rose_addr_t const&);

public:
    rose_addr_t const& get_e_esp() const;
    void set_e_esp(rose_addr_t const&);

public:
    rose_addr_t const& get_e_page_size() const;
    void set_e_page_size(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fixup_sect_size() const;
    void set_e_fixup_sect_size(rose_addr_t const&);

public:
    rose_addr_t const& get_e_loader_sect_size() const;
    void set_e_loader_sect_size(rose_addr_t const&);

public:
    rose_addr_t const& get_e_secttab_rfo() const;
    void set_e_secttab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_pagetab_rfo() const;
    void set_e_pagetab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_iterpages_offset() const;
    void set_e_iterpages_offset(rose_addr_t const&);

public:
    rose_addr_t const& get_e_rsrctab_rfo() const;
    void set_e_rsrctab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_resnametab_rfo() const;
    void set_e_resnametab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_entrytab_rfo() const;
    void set_e_entrytab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fmtdirtab_rfo() const;
    void set_e_fmtdirtab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fixup_pagetab_rfo() const;
    void set_e_fixup_pagetab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_fixup_rectab_rfo() const;
    void set_e_fixup_rectab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_import_modtab_rfo() const;
    void set_e_import_modtab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_import_proctab_rfo() const;
    void set_e_import_proctab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_ppcksumtab_rfo() const;
    void set_e_ppcksumtab_rfo(rose_addr_t const&);

public:
    rose_addr_t const& get_e_data_pages_offset() const;
    void set_e_data_pages_offset(rose_addr_t const&);

public:
    rose_addr_t const& get_e_nonresnametab_offset() const;
    void set_e_nonresnametab_offset(rose_addr_t const&);

public:
    rose_addr_t const& get_e_debug_info_rfo() const;
    void set_e_debug_info_rfo(rose_addr_t const&);

public:
    SgAsmDOSExtendedHeader* const& get_dos2Header() const;
    void set_dos2Header(SgAsmDOSExtendedHeader* const&);

public:
    SgAsmLESectionTable* const& get_sectionTable() const;
    void set_sectionTable(SgAsmLESectionTable* const&);

public:
    SgAsmLEPageTable* const& get_pageTable() const;
    void set_pageTable(SgAsmLEPageTable* const&);

public:
    SgAsmLENameTable* const& get_residentNameTable() const;
    void set_residentNameTable(SgAsmLENameTable* const&);

public:
    SgAsmLENameTable* const& get_nonresidentNameTable() const;
    void set_nonresidentNameTable(SgAsmLENameTable* const&);

public:
    SgAsmLEEntryTable* const& get_entryTable() const;
    void set_entryTable(SgAsmLEEntryTable* const&);

public:
    SgAsmLERelocTable* const& get_relocationTable() const;
    void set_relocationTable(SgAsmLERelocTable* const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEFileHeader(SgAsmGenericFile *f, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    // Overloaded base class virtual function
    const char *formatName() const override;

    static bool isLe (SgAsmGenericFile*);
    static SgAsmLEFileHeader *parse(SgAsmDOSFileHeader*);

private:
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmDOSExtendedHeader* get_dos2_header() const ROSE_DEPRECATED("use get_dos2Header");
    void set_dos2_header(SgAsmDOSExtendedHeader*) ROSE_DEPRECATED("use set_dos2Header");
    SgAsmLESectionTable* get_section_table() const ROSE_DEPRECATED("use get_sectionTable");
    void set_section_table(SgAsmLESectionTable*) ROSE_DEPRECATED("use set_sectionTable");
    SgAsmLEPageTable* get_page_table() const ROSE_DEPRECATED("use get_pageTable");
    void set_page_table(SgAsmLEPageTable*) ROSE_DEPRECATED("use set_pageTable");
    SgAsmLENameTable* get_resname_table() const ROSE_DEPRECATED("use get_residentNameTable");
    void set_resname_table(SgAsmLENameTable*) ROSE_DEPRECATED("use set_residentNameTable");
    SgAsmLENameTable* get_nonresname_table() const ROSE_DEPRECATED("use get_nonresidentNameTable");
    void set_nonresname_table(SgAsmLENameTable*) ROSE_DEPRECATED("use set_nonresidentNameTable");
    SgAsmLEEntryTable* get_entry_table() const ROSE_DEPRECATED("use get_entryTable");
    void set_entry_table(SgAsmLEEntryTable*) ROSE_DEPRECATED("use set_entryTable");
    SgAsmLERelocTable* get_reloc_table() const ROSE_DEPRECATED("use get_relocationTable");
    void set_reloc_table(SgAsmLERelocTable*) ROSE_DEPRECATED("use set_relocationTable");
    const char *format_name() const override ROSE_DEPRECATED("use formatName");
    static bool is_LE (SgAsmGenericFile*) ROSE_DEPRECATED("use isLe");
public:
    /** Destructor. */
    virtual ~SgAsmLEFileHeader();

public:
    /** Default constructor. */
    SgAsmLEFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEEntryTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLEEntryTable);
IS_SERIALIZABLE(AsmLEEntryTable);

#ifndef DOCUMENTATION
AsmLEEntryTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmLEEntryTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryTable.setDataPrototype(
        "SgSizeTList", "bundle_sizes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryTable.setDataPrototype(
        "SgAsmLEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLEEntryTable);
#if defined(SgAsmLEEntryTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLEEntryTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLEEntryTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_bundle_sizes);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmLEEntryTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgSizeTList const& get_bundle_sizes() const;
    void set_bundle_sizes(SgSizeTList const&);

public:
    SgAsmLEEntryPointPtrList const& get_entries() const;
    SgAsmLEEntryPointPtrList& get_entries();
    void set_entries(SgAsmLEEntryPointPtrList const&);
public:
    SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmLEEntryTable();

public:
    /** Default constructor. */
    SgAsmLEEntryTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEEntryTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmLEEntryPoint);
IS_SERIALIZABLE(AsmLEEntryPoint);

#ifndef DOCUMENTATION
AsmLEEntryPoint.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmLEEntryPoint);
#if defined(SgAsmLEEntryPoint_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <sageContainer.h>
#endif // SgAsmLEEntryPoint_HEADERS

#ifdef DOCUMENTATION
class SgAsmLEEntryPoint: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "SgAsmLEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "objnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "entry_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmLEEntryPoint.setDataPrototype(
        "rose_addr_t", "entry_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmLEEntryPoint);
#if defined(SgAsmLEEntryPoint_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmLEEntryPoint -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmLEEntryPoint");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_objnum);
        s & BOOST_SERIALIZATION_NVP(p_entry_type);
        s & BOOST_SERIALIZATION_NVP(p_res1);
        s & BOOST_SERIALIZATION_NVP(p_entry_offset);
        debugSerializationEnd("SgAsmLEEntryPoint");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
     * next entry point description follows immediately after the flag. */
    struct LEEntryPoint_disk {
        uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
        uint16_t    objnum;         /* 0x01 Object number */
        uint8_t     entry_type;     /* 0x03 Flags for entry type */
        uint32_t    entry_offset;   /* 0x04 Offset of entry point */
        uint16_t    res1;           /* 0x08 Reserved */
    }                               /* 0x0a */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    SgAsmLEEntryPointPtrList const& get_entries() const;
    SgAsmLEEntryPointPtrList& get_entries();
    void set_entries(SgAsmLEEntryPointPtrList const&);

public:
    unsigned const& get_flags() const;
    void set_flags(unsigned const&);

public:
    unsigned const& get_objnum() const;
    void set_objnum(unsigned const&);

public:
    unsigned const& get_entry_type() const;
    void set_entry_type(unsigned const&);

public:
    unsigned const& get_res1() const;
    void set_res1(unsigned const&);

public:
    rose_addr_t const& get_entry_offset() const;
    void set_entry_offset(rose_addr_t const&);
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEEntryPoint(Rose::BinaryAnalysis::ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
    SgAsmLEEntryPoint(Rose::BinaryAnalysis::ByteOrder::Endianness sex, unsigned flags);
    rose_addr_t unparse(std::ostream&, Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmGenericSection*,
                        rose_addr_t spos) const;
    void dump(FILE*, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmLEEntryPoint();

public:
    /** Default constructor. */
    SgAsmLEEntryPoint();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEEntryPoint_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmStackMapVerificationType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmStackMapVerificationType);
IS_SERIALIZABLE(AsmJvmStackMapVerificationType);

#ifndef DOCUMENTATION
AsmJvmStackMapVerificationType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents an entry in a stack map table.
 *
 */
class SgAsmJvmStackMapVerificationType: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapVerificationType.setDataPrototype(
        "uint8_t", "tag", "= 9",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapVerificationType.setDataPrototype(
        "uint16_t", "cpool_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapVerificationType.setDataPrototype(
        "uint16_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmStackMapVerificationType);
#if defined(SgAsmJvmStackMapVerificationType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmStackMapVerificationType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmStackMapVerificationType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_tag);
        s & BOOST_SERIALIZATION_NVP(p_cpool_index);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        debugSerializationEnd("SgAsmJvmStackMapVerificationType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    /** StackMapVerificationType tags.
     *
     * These tags indicate which item of the verification_type_info union is in use.
     */
    enum verification_type_tag {
        ITEM_Top = 0,
        ITEM_Integer = 1,
        ITEM_Float = 2,
        ITEM_Double = 3,
        ITEM_Long = 4,
        ITEM_Null = 5,
        ITEM_UninitializedThis = 6,
        ITEM_Object = 7,
        ITEM_Uninitialized = 8
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types (for documentation purposes only)
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef DOCUMENTATION
    /** The following discriminated union is documented below and provides information about
     *    the SgAsmJvmStackMapVerificationType entry (see 4.7.4 in JVM specification).
     */
    union verification_type_info {
        Top_variable_info;
        Integer_variable_info;
        Float_variable_info;
        Long_variable_info;
        Double_variable_info;
        Null_variable_info;
        UninitializedThis_variable_info;
        Object_variable_info;
        Uninitialized_variable_info;
    };

    /** 4.7.4 */
    struct Top_variable_info {
        uint8_t tag;
    };
    struct Integer_variable_info {
        uint8_t tag;
    };
    struct Float_variable_info {
        uint8_t tag;
    };
    struct Long_variable_info {
        uint8_t tag;
    };
    struct Double_variable_info {
        uint8_t tag;
    };
    struct Null_variable_info {
        uint8_t tag;
    };
    struct UnitializedThis_variable_info {
        uint8_t tag;
    };
    struct Object_variable_info {
        uint8_t tag;
        uint16_t cpool_index;
    };
    struct Unitialized_variable_info {
        uint8_t tag;
        uint16_t offset;
    };
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: tag
     *
     *  Enum constant describing variable type. 
     *  
     *  @{ */
    uint8_t const& get_tag() const;
    void set_tag(uint8_t const&);
    /** @} */
 /* Not a legal entry */
public:
    /** Property: cpool_index
     *
     *  See the JVM specification. 
     *  
     *  @{ */
    uint16_t const& get_cpool_index() const;
    void set_cpool_index(uint16_t const&);
    /** @} */

public:
    /** Property: offset
     *
     *  See the JVM specification. 
     *  
     *  @{ */
    uint16_t const& get_offset() const;
    void set_offset(uint16_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /**
     * Initialize the object before parsing. This is the preferred constructor
     * as it sets the parent. */
    explicit SgAsmJvmStackMapVerificationType(SgAsmJvmStackMapFrame* frame);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmStackMapVerificationType* parse(SgAsmJvmConstantPool* pool);

    /** Write stack map table to a binary file */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmStackMapVerificationType();

public:
    /** Default constructor. */
    SgAsmJvmStackMapVerificationType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmStackMapVerificationType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmStackMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmStackMapTable);
IS_SERIALIZABLE(AsmJvmStackMapTable);

#ifndef DOCUMENTATION
AsmJvmStackMapTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmStackMapTable);
#if defined(SgAsmJvmStackMapTable_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmStackMapTable_HEADERS

#ifdef DOCUMENTATION
/** The StackMapTable attribute is a variable-length attribute in the attributes table
 *  of a Code attribute (see section 4.7.3). A StackMapTable attribute is used during the
 *  process of verification by type checking (4.10.1).
 */
class SgAsmJvmStackMapTable: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapTable.setDataPrototype(
        "SgAsmJvmStackMapFramePtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmStackMapTable);
#if defined(SgAsmJvmStackMapTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmStackMapTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmStackMapTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmJvmStackMapTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: List of stack map table entries/frames. 
     * 
     * @{ */
    SgAsmJvmStackMapFramePtrList const& get_entries() const;
    SgAsmJvmStackMapFramePtrList& get_entries();
    void set_entries(SgAsmJvmStackMapFramePtrList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /**
     * Initialize the object before parsing. This is the preferred constructor
     * as it sets the parent. */
    explicit SgAsmJvmStackMapTable(SgAsmJvmAttributeTable* table);

    /** Initialize the object by parsing content from the class file. */
    virtual SgAsmJvmStackMapTable* parse(SgAsmJvmConstantPool* pool) override;

    /** Write stack map table to a binary file */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmStackMapTable();

public:
    /** Default constructor. */
    SgAsmJvmStackMapTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmStackMapTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmStackMapFrame           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmStackMapFrame);
IS_SERIALIZABLE(AsmJvmStackMapFrame);

#ifndef DOCUMENTATION
AsmJvmStackMapFrame.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmStackMapFrame);
#if defined(SgAsmJvmStackMapFrame_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmStackMapFrame_HEADERS

#ifdef DOCUMENTATION
/** Represents a frame in a stack map table.
 *
 */
class SgAsmJvmStackMapFrame: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapFrame.setDataPrototype(
        "SgAsmJvmStackMapVerificationTypePtrList", "stack", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapFrame.setDataPrototype(
        "SgAsmJvmStackMapVerificationTypePtrList", "locals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapFrame.setDataPrototype(
        "uint8_t", "frame_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmStackMapFrame.setDataPrototype(
        "uint16_t", "offset_delta", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmStackMapFrame);
#if defined(SgAsmJvmStackMapFrame_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmStackMapFrame -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmStackMapFrame");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_stack);
        s & BOOST_SERIALIZATION_NVP(p_locals);
        s & BOOST_SERIALIZATION_NVP(p_frame_type);
        s & BOOST_SERIALIZATION_NVP(p_offset_delta);
        debugSerializationEnd("SgAsmJvmStackMapFrame");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
public:
public:
    /** Property: List of verification_type_info stack variables. 
     * 
     * @{ */
    SgAsmJvmStackMapVerificationTypePtrList const& get_stack() const;
    SgAsmJvmStackMapVerificationTypePtrList& get_stack();
    void set_stack(SgAsmJvmStackMapVerificationTypePtrList const&);
    /** @} */

public:
    /** Property: List of verification_type_info local variables. 
     * 
     * @{ */
    SgAsmJvmStackMapVerificationTypePtrList const& get_locals() const;
    SgAsmJvmStackMapVerificationTypePtrList& get_locals();
    void set_locals(SgAsmJvmStackMapVerificationTypePtrList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types (for documentation purposes only)
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef DOCUMENTATION
    /** The following discriminated union is documented below and indicates which
     *    item of the union is in use.
     */
    union stack_map_frame {
        same_frame;
        same_locals_1_stack_item_frame;
        same_locals_1_stack_item_frame_extended;
        chop_frame;
        same_frame_extended;
        append_frame;
        full_frame;
    };

    struct same_frame {
        uint8_t frame_type; /* 0-63 */
    };
    struct same_locals_1_stack_item_frame {
        uint8_t frame_type; /* 64-127 */
        verification_type_info stack;
    };
    struct same_locals_1_stack_item_extended {
        uint8_t frame_type; /* 247 */
        uint16_t offset_delta;
        verification_type_info stack;
    };
    struct chop_frame {
        uint8_t frame_type; /* 248-250 */
        uint16_t offset_delta;
    };
    struct same_frame_extended {
        uint8_t frame_type; /* 251 */
        uint16_t offset_delta;
    };
    struct append_frame {
        uint8_t frame_type; /* 252-254 */
        uint16_t offset_delta;
        verification_type_info stack;
    };
    struct full_frame {
        uint8_t frame_type; /* 252-254 */
        uint16_t offset_delta;
        uint16_t number_of_locals;
        verification_type_info stack[number_of_locals];
        uint16_t number_of_stack_items;
        verification_type_info stack[number_of_stack_items];
    };
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
public:
    /** Property: frame_type
     *
     *  See the JVM specification. 
     *  
     *  @{ */
    uint8_t const& get_frame_type() const;
    void set_frame_type(uint8_t const&);
    /** @} */

public:
    /** Property: offset_delta
     *
     *  See the JVM specification. 
     *  
     *  @{ */
    uint16_t const& get_offset_delta() const;
    void set_offset_delta(uint16_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /**
     * Initialize the object before parsing. This is the preferred constructor
     * as it sets the parent. */
    explicit SgAsmJvmStackMapFrame(SgAsmJvmStackMapTable* table);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmStackMapFrame* parse(SgAsmJvmConstantPool* pool);

    /** Write the stack map table frame to a binary file */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmStackMapFrame();

public:
    /** Default constructor. */
    SgAsmJvmStackMapFrame();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmStackMapFrame_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmSourceFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmSourceFile);
IS_SERIALIZABLE(AsmJvmSourceFile);

#ifndef DOCUMENTATION
AsmJvmSourceFile.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM SourceFile attribute.
 *
 *  A SourceFile attribute stores an index to the name of the class file, see section 4.7.10 of the JVM specification. */
class SgAsmJvmSourceFile: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmSourceFile.setDataPrototype(
        "uint16_t", "sourcefile_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmSourceFile);
#if defined(SgAsmJvmSourceFile_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmSourceFile -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmSourceFile");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_sourcefile_index);
        debugSerializationEnd("SgAsmJvmSourceFile");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: sourcefile_index
     *
     *  The value of the sourcefile_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_sourcefile_index() const;
    void set_sourcefile_index(uint16_t const&);
    /** @} */
public:
    /**
     * Initialize the object before parsing. This is the preferred constructor
     * as it sets the parent. */
    explicit SgAsmJvmSourceFile(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Write source file to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmSourceFile();

public:
    /** Default constructor. */
    SgAsmJvmSourceFile();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmSourceFile_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmSignature           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmSignature);
IS_SERIALIZABLE(AsmJvmSignature);

#ifndef DOCUMENTATION
AsmJvmSignature.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM Signature attribute.
 *
 *  A Signature attribute stores a signature for a class, interface, constructor, method, field, or record component, see section
 *  4.7.9 of the JVM specification. */
class SgAsmJvmSignature: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmSignature.setDataPrototype(
        "uint16_t", "signature_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmSignature);
#if defined(SgAsmJvmSignature_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmSignature -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmSignature");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_signature_index);
        debugSerializationEnd("SgAsmJvmSignature");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: signature_index
     *
     *  The value of the signature_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_signature_index() const;
    void set_signature_index(uint16_t const&);
    /** @} */
public:
    /** Initialize the attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmSignature(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Write signature to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmSignature();

public:
    /** Default constructor. */
    SgAsmJvmSignature();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmSignature_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmNestMembers           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmNestMembers);
IS_SERIALIZABLE(AsmJvmNestMembers);

#ifndef DOCUMENTATION
AsmJvmNestMembers.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmNestMembers);
#if defined(SgAsmJvmNestMembers_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmNestMembers_HEADERS

#ifdef DOCUMENTATION
/** JVM NestMembers attribute.
 *
 *  The NestMembers attribute records the classes and interfaces that are authorized to claim
 *  membership in the nest hosted by the current class or interface, see section 4.7.29 of the
 *  JVM specification. */
class SgAsmJvmNestMembers: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmNestMembers.setDataPrototype(
        "SgUnsigned16List", "classes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmNestMembers);
#if defined(SgAsmJvmNestMembers_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmNestMembers -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmNestMembers");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_classes);
        debugSerializationEnd("SgAsmJvmNestMembers");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: classes
     *
     *  Each value in the classes array must be a valid index into the constant_pool table.
     *  The constant_pool entry at that index must be a CONSTANT_Class_info structure
     *  representing a class or interface which is a member of the nest hosted by the current
     *  class or interface (see section 4.4.1 of the JVM specification). 
     *  
     *  @{ */
    SgUnsigned16List const& get_classes() const;
    void set_classes(SgUnsigned16List const&);
    /** @} */
public:
    /** Initialize the attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmNestMembers(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmNestMembers* parse(SgAsmJvmConstantPool* pool) override;

    /** Write object to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmNestMembers();

public:
    /** Default constructor. */
    SgAsmJvmNestMembers();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmNestMembers_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmNestHost           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmNestHost);
IS_SERIALIZABLE(AsmJvmNestHost);

#ifndef DOCUMENTATION
AsmJvmNestHost.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM NestHost attribute.
 *
 *  The NestHost attribute records the nest host of the nest to which the current class or
 *  interface claims to belong, see section 4.7.28 of the JVM specification. */
class SgAsmJvmNestHost: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmNestHost.setDataPrototype(
        "uint16_t", "host_class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmNestHost);
#if defined(SgAsmJvmNestHost_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmNestHost -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmNestHost");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_host_class_index);
        debugSerializationEnd("SgAsmJvmNestHost");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: classes
     *
     *  The value in the host_class_index item must be a valid index into the constant_pool table.
     *  The constant_pool entry at that index must be a CONSTANT_Class_info structure
     *  representing a class or interface which is the nest host for the current class or
     *  interface (see section 4.4.1 of the JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_host_class_index() const;
    void set_host_class_index(uint16_t const&);
    /** @} */
public:
    /** Initialize the attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmNestHost(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmNestHost* parse(SgAsmJvmConstantPool* pool) override;

    /** Write object to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmNestHost();

public:
    /** Default constructor. */
    SgAsmJvmNestHost();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmNestHost_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmModuleMainClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmModuleMainClass);
IS_SERIALIZABLE(AsmJvmModuleMainClass);

#ifndef DOCUMENTATION
AsmJvmModuleMainClass.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM ModuleMainClass attribute.
 *
 *  A ModuleMainClass attribute stores a signature for a class, interface, constructor, method, field, or record component, see
 *  section 4.7.27 of the JVM specification. */
class SgAsmJvmModuleMainClass: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmModuleMainClass.setDataPrototype(
        "uint16_t", "main_class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmModuleMainClass);
#if defined(SgAsmJvmModuleMainClass_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmModuleMainClass -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmModuleMainClass");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_main_class_index);
        debugSerializationEnd("SgAsmJvmModuleMainClass");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: main_class_index
     *
     *  The value of the main_class_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_main_class_index() const;
    void set_main_class_index(uint16_t const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmModuleMainClass(SgAsmJvmExceptionTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Write module main class to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmModuleMainClass();

public:
    /** Default constructor. */
    SgAsmJvmModuleMainClass();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmModuleMainClass_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethodTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmMethodTable);
IS_SERIALIZABLE(AsmJvmMethodTable);

#ifndef DOCUMENTATION
AsmJvmMethodTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents a JVM method_info table/array.
 *
 *  The JVM Constant Pool is itself a section.  The entries of the table are stored with the section they describe rather than
 *  storing them all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers
 *  that are their original indices in the JVM Section Table. */
class SgAsmJvmMethodTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethodTable.setDataPrototype(
        "SgAsmJvmMethodPtrList", "methods", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmMethodTable);
#if defined(SgAsmJvmMethodTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmMethodTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmMethodTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_methods);
        debugSerializationEnd("SgAsmJvmMethodTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to methods. 
     * 
     * @{ */
    SgAsmJvmMethodPtrList const& get_methods() const;
    SgAsmJvmMethodPtrList& get_methods();
    void set_methods(SgAsmJvmMethodPtrList const&);
    /** @} */
public:
    /** Initialize the method table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethodTable(SgAsmJvmFileHeader*);

    /** Parses a JVM method table.
     *
     *  Parses a JVM method table and constructs and parses all methods reachable from the method table section. Returns a pointer
     *  to this object. */
    virtual SgAsmJvmMethodTable* parse() override;

    /** Write method table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethodTable();

public:
    /** Default constructor. */
    SgAsmJvmMethodTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethodTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethodParameters           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmMethodParameters);
IS_SERIALIZABLE(AsmJvmMethodParameters);

#ifndef DOCUMENTATION
AsmJvmMethodParameters.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmMethodParameters);
#if defined(SgAsmJvmMethodParameters_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmMethodParameters_HEADERS

#ifdef DOCUMENTATION
/** JVM MethodParameters attribute.
 *
 *  The MethodParameters attribute is a variable-length attribute in the attributes table of a method_info structure (4.6).
 *  A MethodParameters attribute records information about the formal parameters of a method, such as their names.
 *  See section 4.7.24 of the JVM specification. */
class SgAsmJvmMethodParameters: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethodParameters.setDataPrototype(
        "SgAsmJvmMethodParametersEntryPtrList", "parameters", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmMethodParameters);
#if defined(SgAsmJvmMethodParameters_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmMethodParameters -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmMethodParameters");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_parameters);
        debugSerializationEnd("SgAsmJvmMethodParameters");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: parameters
     *
     *  List of pointers to method parameter entries (see the JVM specification 4.7.24). 
     *  
     *  @{ */
    SgAsmJvmMethodParametersEntryPtrList const& get_parameters() const;
    SgAsmJvmMethodParametersEntryPtrList& get_parameters();
    void set_parameters(SgAsmJvmMethodParametersEntryPtrList const&);
    /** @} */
public:
    /** Initialize the MethodParameters attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethodParameters(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmMethodParameters* parse(SgAsmJvmConstantPool* pool) override;

    /** Write the line number table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethodParameters();

public:
    /** Default constructor. */
    SgAsmJvmMethodParameters();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethodParameters_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethodParametersEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmMethodParametersEntry);
IS_SERIALIZABLE(AsmJvmMethodParametersEntry);

#ifndef DOCUMENTATION
AsmJvmMethodParametersEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM MethodParametersEntry.
 *
 *  Each method parameter is described by a parameters entry anonymous structure.
 *  See the JVM specification, section 4.7.24. */
class SgAsmJvmMethodParametersEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethodParametersEntry.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethodParametersEntry.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmMethodParametersEntry);
#if defined(SgAsmJvmMethodParametersEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmMethodParametersEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmMethodParametersEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
        debugSerializationEnd("SgAsmJvmMethodParametersEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: name_index
     *
     *  The value of the name_index item must either be zero or a valid index into the constant_pool table
     *  (see JVM specification). 
     *  (
     *  (@{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: access_flags
     *
     *  The value of the access_flags item represents information about the formal parameter (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_access_flags() const;
    void set_access_flags(uint16_t const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethodParametersEntry(SgAsmJvmMethodParameters*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmMethodParametersEntry* parse(SgAsmJvmConstantPool*);

    /** Write line number entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethodParametersEntry();

public:
    /** Default constructor. */
    SgAsmJvmMethodParametersEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethodParametersEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmMethod);
IS_SERIALIZABLE(AsmJvmMethod);

#ifndef DOCUMENTATION
AsmJvmMethod.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmMethod);
#if defined(SgAsmJvmMethod_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmJvmMethod_IMPL
#include <SgAsmInstructionList.h>
#include <SgAsmJvmAttributeTable.h>
#endif
#endif // SgAsmJvmMethod_HEADERS

#ifdef DOCUMENTATION
/** JVM Method.
 *
 *  A method describes an instance of an initialization method (2.9.1) and the class or interface initialization method (2.9.2), see
 *  section 4.6 of the JVM specification. */
class SgAsmJvmMethod: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethod.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmMethod.setDataPrototype(
        "SgAsmInstructionList*", "instruction_list", "= createAndParent<SgAsmInstructionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmMethod);
#if defined(SgAsmJvmMethod_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmMethod -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmMethod");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
        s & BOOST_SERIALIZATION_NVP(p_instruction_list);
        debugSerializationEnd("SgAsmJvmMethod");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: access_flags
     *
     *  The value of the access_flags item is a mask of flags used to denote access permission to and properties of this method (see
     *  JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_access_flags() const;
    void set_access_flags(uint16_t const&);
    /** @} */

public:
    /** Property: name_index
     *
     *  The value of the name_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: descriptor_index
     *
     *  The value of the descriptor_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_descriptor_index() const;
    void set_descriptor_index(uint16_t const&);
    /** @} */

public:
    /** Property: Table of attributes. 
     * 
     * @{ */
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */

public:
    /** Property: Instruction list.
     *
     *  Pointer to list of instructions (@ref SgAsmInstruction) belonging to this method. 
     *  
     *  @{ */
    SgAsmInstructionList* const& get_instruction_list() const;
    void set_instruction_list(SgAsmInstructionList* const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethod(SgAsmJvmMethodTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmMethod* parse(SgAsmJvmConstantPool*);

    /** Write method to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethod();

public:
    /** Default constructor. */
    SgAsmJvmMethod();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethod_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLocalVariableTypeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLocalVariableTypeTable);
IS_SERIALIZABLE(AsmJvmLocalVariableTypeTable);

#ifndef DOCUMENTATION
AsmJvmLocalVariableTypeTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmLocalVariableTypeTable);
#if defined(SgAsmJvmLocalVariableTypeTable_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmLocalVariableTypeTable_HEADERS

#ifdef DOCUMENTATION
/** JVM LocalVariableTypeTable attribute.
 *
 *  The LocalVariableTypeTable attribute is an optional variable-length attribute in the attributes table of a Code
 *  attribute (4.7.3). It may be used by debuggers to determine the value of a given local variable during the
 *  execution of a method. See section 4.7.14 of the JVM specification. */
class SgAsmJvmLocalVariableTypeTable: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeTable.setDataPrototype(
        "SgAsmJvmLocalVariableTypeEntryPtrList", "local_variable_type_table", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLocalVariableTypeTable);
#if defined(SgAsmJvmLocalVariableTypeTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLocalVariableTypeTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLocalVariableTypeTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_local_variable_type_table);
        debugSerializationEnd("SgAsmJvmLocalVariableTypeTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: local_variable_table
     *
     *  List of pointers to local_variable_type_table entries (see the JVM specification 4.7.14). 
     *  
     *  @{ */
    SgAsmJvmLocalVariableTypeEntryPtrList const& get_local_variable_type_table() const;
    SgAsmJvmLocalVariableTypeEntryPtrList& get_local_variable_type_table();
    void set_local_variable_type_table(SgAsmJvmLocalVariableTypeEntryPtrList const&);
    /** @} */
public:
    /** Initialize the LocalVariableTypeTable attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLocalVariableTypeTable(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmLocalVariableTypeTable* parse(SgAsmJvmConstantPool* pool) override;

    /** Write the local variable table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLocalVariableTypeTable();

public:
    /** Default constructor. */
    SgAsmJvmLocalVariableTypeTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLocalVariableTypeTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLocalVariableTypeEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLocalVariableTypeEntry);
IS_SERIALIZABLE(AsmJvmLocalVariableTypeEntry);

#ifndef DOCUMENTATION
AsmJvmLocalVariableTypeEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM LocalVariableTypeEntry.
 *
 *  Each local_variable is described by a local_variable_table anonymous structure.  See the JVM specification, section 4.7.14. */
class SgAsmJvmLocalVariableTypeEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeEntry.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeEntry.setDataPrototype(
        "uint16_t", "length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeEntry.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeEntry.setDataPrototype(
        "uint16_t", "signature_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTypeEntry.setDataPrototype(
        "uint16_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLocalVariableTypeEntry);
#if defined(SgAsmJvmLocalVariableTypeEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLocalVariableTypeEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLocalVariableTypeEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
        s & BOOST_SERIALIZATION_NVP(p_length);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_signature_index);
        s & BOOST_SERIALIZATION_NVP(p_index);
        debugSerializationEnd("SgAsmJvmLocalVariableTypeEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: start_pc
     *
     *  The value of the start_pc item must be a valid index into the code array of this Code attribute and must be
     *  the index of the opcode of an instruction (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_start_pc() const;
    void set_start_pc(uint16_t const&);
    /** @} */

public:
    /** Property: length
     *
     *  The value of the start_pc + length item must either be a valid index into the code array of this Code attribute
     *  and be the index of the opcode of an instruction, or it must be the first index beyond the end of that code
     *  array (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_length() const;
    void set_length(uint16_t const&);
    /** @} */

public:
    /** Property: name_index
     *
     *  The value of the name_index item must be a valid index into the constant_pool table. The constant_pool entry
     *  at that index must contain a CONSTANT_Utf8_info structure representing a valid unqualified name denoting
     *  a local variable (see JVM specification, 4.2.2). 
     *  
     *  @{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: signature_index
     *
     *  The value of the signature_index item must be a valid index into the constant_pool table. The constant_pool entry
     *  at that index must contain a CONSTANT_Utf8_info structure representing a field signature which encodes
     *  the type of a variable in the source program (see JVM specification, 4.7.9.1). 
     *  
     *  @{ */
    uint16_t const& get_signature_index() const;
    void set_signature_index(uint16_t const&);
    /** @} */

public:
    /** Property: index
     *
     *  The value of the index item must be a valid index into the local variable array of the current frame. The
     *  given local variable is at index in the local variable array of the current frame (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_index() const;
    void set_index(uint16_t const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLocalVariableTypeEntry(SgAsmJvmLocalVariableTypeTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmLocalVariableTypeEntry* parse(SgAsmJvmConstantPool*);

    /** Write the local variable entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLocalVariableTypeEntry();

public:
    /** Default constructor. */
    SgAsmJvmLocalVariableTypeEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLocalVariableTypeEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLocalVariableTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLocalVariableTable);
IS_SERIALIZABLE(AsmJvmLocalVariableTable);

#ifndef DOCUMENTATION
AsmJvmLocalVariableTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmLocalVariableTable);
#if defined(SgAsmJvmLocalVariableTable_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmLocalVariableTable_HEADERS

#ifdef DOCUMENTATION
/** JVM LocalVariableTable attribute.
 *
 *  The LocalVariableTable attribute is an optional variable-length attribute in the attributes table of a Code
 *  attribute (4.7.3). It may be used by debuggers to determine the value of a given local variable during the
 *  execution of a method. See section 4.7.13 of the JVM specification. */
class SgAsmJvmLocalVariableTable: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableTable.setDataPrototype(
        "SgAsmJvmLocalVariableEntryPtrList", "local_variable_table", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLocalVariableTable);
#if defined(SgAsmJvmLocalVariableTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLocalVariableTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLocalVariableTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_local_variable_table);
        debugSerializationEnd("SgAsmJvmLocalVariableTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: local_variable_table
     *
     *  List of pointers to local_variable_table entries (see the JVM specification 4.7.13). 
     *  
     *  @{ */
    SgAsmJvmLocalVariableEntryPtrList const& get_local_variable_table() const;
    SgAsmJvmLocalVariableEntryPtrList& get_local_variable_table();
    void set_local_variable_table(SgAsmJvmLocalVariableEntryPtrList const&);
    /** @} */
public:
    /** Initialize the LocalVariableTable attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLocalVariableTable(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmLocalVariableTable* parse(SgAsmJvmConstantPool* pool) override;

    /** Write the local variable table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLocalVariableTable();

public:
    /** Default constructor. */
    SgAsmJvmLocalVariableTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLocalVariableTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLocalVariableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLocalVariableEntry);
IS_SERIALIZABLE(AsmJvmLocalVariableEntry);

#ifndef DOCUMENTATION
AsmJvmLocalVariableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM LocalVariableEntry.
 *
 *  Each local_variable is described by a local_variable_table anonymous structure.  See the JVM specification, section 4.7.13. */
class SgAsmJvmLocalVariableEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableEntry.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableEntry.setDataPrototype(
        "uint16_t", "length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableEntry.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableEntry.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLocalVariableEntry.setDataPrototype(
        "uint16_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLocalVariableEntry);
#if defined(SgAsmJvmLocalVariableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLocalVariableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLocalVariableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
        s & BOOST_SERIALIZATION_NVP(p_length);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
        s & BOOST_SERIALIZATION_NVP(p_index);
        debugSerializationEnd("SgAsmJvmLocalVariableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: start_pc
     *
     *  The value of the start_pc item must be a valid index into the code array of this Code attribute and must be
     *  the index of the opcode of an instruction (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_start_pc() const;
    void set_start_pc(uint16_t const&);
    /** @} */

public:
    /** Property: length
     *
     *  The value of the start_pc + length item must either be a valid index into the code array of this Code attribute
     *  and be the index of the opcode of an instruction, or it must be the first index beyond the end of that code
     *  array (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_length() const;
    void set_length(uint16_t const&);
    /** @} */

public:
    /** Property: name_index
     *
     *  The value of the name_index item must be a valid index into the constant_pool table. The constant_pool entry
     *  at that index must contain a CONSTANT_Utf8_info structure representing a valid unqualified name denoting
     *  a local variable (see JVM specification, 4.2.2). 
     *  
     *  @{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: descriptor_index
     *
     *  The value of the descriptor_index item must be a valid index into the constant_pool table. The constant_pool entry
     *  at that index must contain a CONSTANT_Utf8_info structure representing a field descriptor which encodes
     *  the type of a variable in the source program (see JVM specification, 4.3.2). 
     *  
     *  @{ */
    uint16_t const& get_descriptor_index() const;
    void set_descriptor_index(uint16_t const&);
    /** @} */

public:
    /** Property: index
     *
     *  The value of the index item must be a valid index into the local variable array of the current frame. The
     *  given local variable is at index in the local variable array of the current frame (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_index() const;
    void set_index(uint16_t const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLocalVariableEntry(SgAsmJvmLocalVariableTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmLocalVariableEntry* parse(SgAsmJvmConstantPool*);

    /** Write the local variable entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLocalVariableEntry();

public:
    /** Default constructor. */
    SgAsmJvmLocalVariableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLocalVariableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLineNumberTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLineNumberTable);
IS_SERIALIZABLE(AsmJvmLineNumberTable);

#ifndef DOCUMENTATION
AsmJvmLineNumberTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmLineNumberTable);
#if defined(SgAsmJvmLineNumberTable_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmLineNumberTable_HEADERS

#ifdef DOCUMENTATION
/** JVM LineNumberTable attribute.
 *
 *  The LineNumberTable attribute is an optional variable-length attribute in the attributes table of a Code attribute (4.7.3). It
 *  may be used by debuggers to determine which part of the code array corresponds to a given line number in the original source
 *  file.  See section 4.7.12 of the JVM specification. */
class SgAsmJvmLineNumberTable: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLineNumberTable.setDataPrototype(
        "SgAsmJvmLineNumberEntryPtrList", "line_number_table", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLineNumberTable);
#if defined(SgAsmJvmLineNumberTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLineNumberTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLineNumberTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_line_number_table);
        debugSerializationEnd("SgAsmJvmLineNumberTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: line_number_table
     *
     *  List of pointers to line_number_table entries (see the JVM specification 4.7.12). 
     *  
     *  @{ */
    SgAsmJvmLineNumberEntryPtrList const& get_line_number_table() const;
    SgAsmJvmLineNumberEntryPtrList& get_line_number_table();
    void set_line_number_table(SgAsmJvmLineNumberEntryPtrList const&);
    /** @} */
public:
    /** Initialize the LineNumberTable attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLineNumberTable(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmLineNumberTable* parse(SgAsmJvmConstantPool* pool) override;

    /** Write the line number table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLineNumberTable();

public:
    /** Default constructor. */
    SgAsmJvmLineNumberTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLineNumberTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLineNumberEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmLineNumberEntry);
IS_SERIALIZABLE(AsmJvmLineNumberEntry);

#ifndef DOCUMENTATION
AsmJvmLineNumberEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM LineNumberEntry.
 *
 *  Each line_number is described by a line_number_table anonymous structure.  See the JVM specification, section 4.7.12. */
class SgAsmJvmLineNumberEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLineNumberEntry.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmLineNumberEntry.setDataPrototype(
        "uint16_t", "line_number", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmLineNumberEntry);
#if defined(SgAsmJvmLineNumberEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmLineNumberEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmLineNumberEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
        s & BOOST_SERIALIZATION_NVP(p_line_number);
        debugSerializationEnd("SgAsmJvmLineNumberEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: start_pc
     *
     *  The value of the start_pc item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_start_pc() const;
    void set_start_pc(uint16_t const&);
    /** @} */

public:
    /** Property: line_number
     *
     *  The value of the line_number entry must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_line_number() const;
    void set_line_number(uint16_t const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLineNumberEntry(SgAsmJvmLineNumberTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmLineNumberEntry* parse(SgAsmJvmConstantPool*);

    /** Write line number entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmLineNumberEntry();

public:
    /** Default constructor. */
    SgAsmJvmLineNumberEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLineNumberEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmInstruction);
IS_SERIALIZABLE(AsmJvmInstruction);

#ifndef DOCUMENTATION
AsmJvmInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmInstruction);
#if defined(SgAsmJvmInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/InstructionEnumsJvm.h>
#endif // SgAsmJvmInstruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one JVS machine instruction. */
class SgAsmJvmInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::JvmInstructionKind", "kind", "= Rose::BinaryAnalysis::JvmInstructionKind::unknown",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmInstruction);
#if defined(SgAsmJvmInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        debugSerializationEnd("SgAsmJvmInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the JVM instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::JvmInstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::JvmInstructionKind const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmInstruction();

public:
    /** Default constructor. */
    SgAsmJvmInstruction();

public:
    /** Constructor. */
    SgAsmJvmInstruction(rose_addr_t const& address,
                        uint8_t const& architectureId,
                        Rose::BinaryAnalysis::JvmInstructionKind const& kind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInnerClasses           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmInnerClasses);
IS_SERIALIZABLE(AsmJvmInnerClasses);

#ifndef DOCUMENTATION
AsmJvmInnerClasses.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmInnerClasses);
#if defined(SgAsmJvmInnerClasses_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmInnerClasses_HEADERS

#ifdef DOCUMENTATION
/** Represents a JVM InnerClasses attribute.
 *
 *  The InnerClasses attribute is a variable-length attribute in the attributes table of a ClassFile structure. See section 4.7.6 of
 *  the JVM specification.
 */
class SgAsmJvmInnerClasses: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInnerClasses.setDataPrototype(
        "SgAsmJvmInnerClassesEntryPtrList", "classes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmInnerClasses);
#if defined(SgAsmJvmInnerClasses_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmInnerClasses -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmInnerClasses");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_classes);
        debugSerializationEnd("SgAsmJvmInnerClasses");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to InnerClasses attribute entry. 
     * 
     * @{ */
    SgAsmJvmInnerClassesEntryPtrList const& get_classes() const;
    SgAsmJvmInnerClassesEntryPtrList& get_classes();
    void set_classes(SgAsmJvmInnerClassesEntryPtrList const&);
    /** @} */
public:
    /** Initialize the InnerClasses attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmInnerClasses(SgAsmJvmAttributeTable* table);

    /** Parses a JVM InnerClasses attribute.
     *
     * Parses a JVM InnerClasses attribute and constructs and parses all classes
     * entries reachable from the table. Returns a pointer to this object. */
    SgAsmJvmInnerClasses* parse(SgAsmJvmConstantPool*) override;

    /** Write the InnerClasses attribute to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmInnerClasses();

public:
    /** Default constructor. */
    SgAsmJvmInnerClasses();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInnerClasses_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInnerClassesEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmInnerClassesEntry);
IS_SERIALIZABLE(AsmJvmInnerClassesEntry);

#ifndef DOCUMENTATION
AsmJvmInnerClassesEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** A JVM InnerClasses attribute array entry.
 *
 *  See the JVM specification (section 4.7.6) for more information.
 */
class SgAsmJvmInnerClassesEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_class_info_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "outer_class_info_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_class_access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmInnerClassesEntry);
#if defined(SgAsmJvmInnerClassesEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmInnerClassesEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmInnerClassesEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_inner_class_info_index);
        s & BOOST_SERIALIZATION_NVP(p_outer_class_info_index);
        s & BOOST_SERIALIZATION_NVP(p_inner_name_index);
        s & BOOST_SERIALIZATION_NVP(p_inner_class_access_flags);
        debugSerializationEnd("SgAsmJvmInnerClassesEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: inner_class_info_index.
     *
     *  The value of the inner_class_info_index must be a valid index into the constant_pool table (see the JVM specification
     *  section 4.7.6). 
     *  
     *  @{ */
    uint16_t const& get_inner_class_info_index() const;
    void set_inner_class_info_index(uint16_t const&);
    /** @} */

public:
    /** Property: outer_class_info_index
     *
     *  The value of the outer_class_info_index must be a valid index into the constant_pool table (see the JVM specification
     *  section 4.7.6). 
     *  
     *  @{ */
    uint16_t const& get_outer_class_info_index() const;
    void set_outer_class_info_index(uint16_t const&);
    /** @} */

public:
    /** Property: inner_name_index
     *
     *  The value of the inner_name_index must be a valid index into the constant_pool table (see the JVM specification section
     *  4.7.6). 
     *  
     *  @{ */
    uint16_t const& get_inner_name_index() const;
    void set_inner_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: inner_class_access_flags
     *
     *  The value of the inner_class_access_flags item is a mask of flags used to denote access permissions to and properties of
     *  class or interface C as declared in the source code from which this class file was compiled (see the JVM specification
     *  section 4.7.6). 
     *  
     *  @{ */
    uint16_t const& get_inner_class_access_flags() const;
    void set_inner_class_access_flags(uint16_t const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmInnerClassesEntry(SgAsmJvmInnerClasses*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmInnerClassesEntry* parse(SgAsmJvmConstantPool*);

    /** Write inner classes entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmInnerClassesEntry();

public:
    /** Default constructor. */
    SgAsmJvmInnerClassesEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInnerClassesEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmFileHeader);
IS_SERIALIZABLE(AsmJvmFileHeader);

#ifndef DOCUMENTATION
AsmJvmFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents the file header of an JVM binary container.
 *
 *  The file header contains information that the Java Virtual Machine (JVM) uses to find the various parts within the
 *  container. Most of the object properties are defined in the official JVM specification and their documentation is not
 *  replicated here.
 */
class SgAsmJvmFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "minor_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "major_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "this_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "super_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmConstantPool*", "constant_pool", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "std::list<uint16_t>", "interfaces", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmFieldTable*", "field_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmMethodTable*", "method_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmFileHeader);
#if defined(SgAsmJvmFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_minor_version);
        s & BOOST_SERIALIZATION_NVP(p_major_version);
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
        s & BOOST_SERIALIZATION_NVP(p_this_class);
        s & BOOST_SERIALIZATION_NVP(p_super_class);
        s & BOOST_SERIALIZATION_NVP(p_constant_pool);
        s & BOOST_SERIALIZATION_NVP(p_interfaces);
        s & BOOST_SERIALIZATION_NVP(p_field_table);
        s & BOOST_SERIALIZATION_NVP(p_method_table);
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
        debugSerializationEnd("SgAsmJvmFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Minor version.
     *
     *  Minor version number of this class file. 
     *  
     *  @{ */
    uint16_t const& get_minor_version() const;
    void set_minor_version(uint16_t const&);
    /** @} */

public:
    /** Property: Major version.
     *
     *  Major version number of this class file. 
     *  
     *  @{ */
    uint16_t const& get_major_version() const;
    void set_major_version(uint16_t const&);
    /** @} */

public:
    /** Property: Access flags.
     *
     *  Mask of flags used to denote access permissions and properties of this class or interface. 
     *  
     *  @{ */
    uint16_t const& get_access_flags() const;
    void set_access_flags(uint16_t const&);
    /** @} */

public:
    /** Property: This class index.
     *
     *  Index into constant pool table for this class or interface. 
     *  
     *  @{ */
    uint16_t const& get_this_class() const;
    void set_this_class(uint16_t const&);
    /** @} */

public:
    /** Property: Super class.
     *
     *  Index into constant pool table for direct super class of this class or interface. 
     *  
     *  @{ */
    uint16_t const& get_super_class() const;
    void set_super_class(uint16_t const&);
    /** @} */

public:
    /** Property: Constant pool.
     *
     *  Points to the AST node that represents the JVM constant pool. The constant pool is a table of structures
     *  (see 4.4) representing various string constants, class and interface names, field names, and other constants
     *  that are referred to within the ClassFile structure and its substructures. The format of each constant-pool
     *  table entry is indicated by its first "tag" byte. 
     *  
     *  @{ */
    SgAsmJvmConstantPool* const& get_constant_pool() const;
    void set_constant_pool(SgAsmJvmConstantPool* const&);
    /** @} */

public:
    /** Property: Interfaces.
     *
     *  Each value in the interfaces array must be a valid index into the constant_pool table. The constant_pool entry
     *  at each value is a CONSTANT_Class_info structure representing an interface that is a direct superinterface
     *  of this class or interface type. 
     *  
     *  @{ */
    std::list<uint16_t> const& get_interfaces() const;
    std::list<uint16_t>& get_interfaces();
    void set_interfaces(std::list<uint16_t> const&);
    /** @} */

public:
    /** Property: Field table.
     *
     *  Points to the AST node that represents the JVM field table. The constant pool is a table of structures
     *  (see 4.4) representing various string constants, class and interface names, field names, and other constants
     *  that are referred to within the ClassFile structure and its substructures. The format of each constant-pool
     *  table entry is indicated by its first "tag" byte. 
     *  
     *  @{ */
    SgAsmJvmFieldTable* const& get_field_table() const;
    void set_field_table(SgAsmJvmFieldTable* const&);
    /** @} */

public:
    /** Property: Method table.
     *
     *  Points to the AST node that represents the JVM method table. The constant pool is a table of structures
     *  (see 4.4) representing various string constants, class and interface names, field names, and other constants
     *  that are referred to within the ClassFile structure and its substructures. The format of each constant-pool
     *  table entry is indicated by its first "tag" byte. 
     *  
     *  @{ */
    SgAsmJvmMethodTable* const& get_method_table() const;
    void set_method_table(SgAsmJvmMethodTable* const&);
    /** @} */

public:
    /** Property: Attribute table.
     *
     *  Points to the AST node that represents the JVM attribute table. The constant pool is a table of structures
     *  (see 4.4) representing various string constants, class and interface names, field names, and other constants
     *  that are referred to within the ClassFile structure and its substructures. The format of each constant-pool
     *  table entry is indicated by its first "tag" byte. 
     *  
     *  @{ */
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
public:
    /** Construct a new JVM File Header with default values; ready to be initialized via parse(). */
    explicit SgAsmJvmFileHeader(SgAsmGenericFile *);

    /** Parse header from file.
     *
     *  Initialize this header with information parsed from the file and construct and parse everything that's reachable
     *  from the header. Since the size of the ELF File Header is determined by the contents of the ELF File Header as
     *  stored in the file, the size of the ELF File Header will be adjusted upward if necessary. */
    virtual SgAsmJvmFileHeader* parse() override;

    /** Write the section to a binary file */
    virtual void unparse(std::ostream&) const override;

    /** Returns true if a cursory look at the file indicates that it could be a JVM class file. */
    static bool is_JVM(SgAsmGenericFile*);

protected:
    // Some extra clean-up actions on destruction
    virtual void destructorHelper() override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmFileHeader();

public:
    /** Default constructor. */
    SgAsmJvmFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmFieldTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmFieldTable);
IS_SERIALIZABLE(AsmJvmFieldTable);

#ifndef DOCUMENTATION
AsmJvmFieldTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents a JVM field_info table/array.
 *
 *  The JVM fields table is a section.  The entries of the table are stored with the section they describe rather than storing them
 *  all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers that are
 *  their original indices in the JVM Section Table. */
class SgAsmJvmFieldTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmFieldTable.setDataPrototype(
        "SgAsmJvmFieldPtrList", "fields", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmFieldTable);
#if defined(SgAsmJvmFieldTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmFieldTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmFieldTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_fields);
        debugSerializationEnd("SgAsmJvmFieldTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to fields. 
     * 
     * @{ */
    SgAsmJvmFieldPtrList const& get_fields() const;
    SgAsmJvmFieldPtrList& get_fields();
    void set_fields(SgAsmJvmFieldPtrList const&);
    /** @} */
public:
    /** Initialize the field table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmFieldTable(SgAsmJvmFileHeader*);

    /** Parses a JVM field table.
     *
     *  Parses a JVM field table and constructs and parses all fields reachable from the table. Returns a pointer to this object. */
    virtual SgAsmJvmFieldTable* parse() override;

    /** Write field table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmFieldTable();

public:
    /** Default constructor. */
    SgAsmJvmFieldTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmFieldTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmField           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmField);
IS_SERIALIZABLE(AsmJvmField);

#ifndef DOCUMENTATION
AsmJvmField.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmField);
#if defined(SgAsmJvmField_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmJvmField_IMPL
#include <SgAsmJvmAttributeTable.h>
#endif
#endif // SgAsmJvmField_HEADERS

#ifdef DOCUMENTATION
/** JVM Field.
 *
 *  Each field is described by a field_info structure. */
class SgAsmJvmField: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmField.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmField.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmField.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmField.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmField);
#if defined(SgAsmJvmField_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmField -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmField");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
        debugSerializationEnd("SgAsmJvmField");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: access_flags
     *
     *  The value of the access_flags item is a mask of flags used to denote access permission to and properties of this method (see
     *  JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_access_flags() const;
    void set_access_flags(uint16_t const&);
    /** @} */

public:
    /** Property: name_index
     *
     *  The value of the name_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: descriptor_index
     *
     *  The value of the descriptor_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_descriptor_index() const;
    void set_descriptor_index(uint16_t const&);
    /** @} */

public:
    /** Property: Table of attributes. 
     * 
     * @{ */
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmField(SgAsmJvmFieldTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmField* parse(SgAsmJvmConstantPool* pool);

    /** Write field to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmField();

public:
    /** Default constructor. */
    SgAsmJvmField();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmField_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmExceptionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmExceptionTable);
IS_SERIALIZABLE(AsmJvmExceptionTable);

#ifndef DOCUMENTATION
AsmJvmExceptionTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmExceptionTable);
#if defined(SgAsmJvmExceptionTable_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmExceptionTable_HEADERS

#ifdef DOCUMENTATION
/** Represents a JVM exception_info table/array.
 *
 *  The JVM exceptions table is an SgAsmJvmNode containing SgAsmJvmExceptionHandler entries.
 *  Each entry in the table describes one exception handler in the code array. */
class SgAsmJvmExceptionTable: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptionTable.setDataPrototype(
        "SgAsmJvmExceptionHandlerPtrList", "handlers", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmExceptionTable);
#if defined(SgAsmJvmExceptionTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmExceptionTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmExceptionTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_handlers);
        debugSerializationEnd("SgAsmJvmExceptionTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to exceptions. 
     * 
     * @{ */
    SgAsmJvmExceptionHandlerPtrList const& get_handlers() const;
    SgAsmJvmExceptionHandlerPtrList& get_handlers();
    void set_handlers(SgAsmJvmExceptionHandlerPtrList const&);
    /** @} */
public:
    /** Initialize the exception table before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmExceptionTable(SgAsmJvmCodeAttribute*);

    /** Parses a JVM exception table.
     *
     *  Parses a JVM exception table and constructs and parses all exceptions reachable from the table.  Returns a pointer to this
     *  object. */
    SgAsmJvmExceptionTable* parse(SgAsmJvmConstantPool*);

    /** Write exception table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmExceptionTable();

public:
    /** Default constructor. */
    SgAsmJvmExceptionTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmExceptionTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmExceptions           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmExceptions);
IS_SERIALIZABLE(AsmJvmExceptions);

#ifndef DOCUMENTATION
AsmJvmExceptions.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmExceptions);
#if defined(SgAsmJvmExceptions_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmExceptions_HEADERS

#ifdef DOCUMENTATION
/** JVM Exceptions attribute.
 *
 *  The Exceptions attribute is a variable-length attribute in the attributes table of a method_info
 *  struction (see section 4.6 of the JVM specification). The Exceptions attribute indicates which
 *  checked exceptions a method may throw. */
class SgAsmJvmExceptions: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptions.setDataPrototype(
        "SgUnsigned16List", "exception_index_table", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmExceptions);
#if defined(SgAsmJvmExceptions_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmExceptions -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmExceptions");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_exception_index_table);
        debugSerializationEnd("SgAsmJvmExceptions");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: exception_index_table
     *
     *  Each value in the exception_index_table array must be a valid index into the constant_pool
     *  table. The constant_pool entry at that index must be the CONSTANT_Utf8_info structure
     *  representing the string "Exceptions" (see section 4.4.7 of the JVM specification). 
     *  
     *  @{ */
    SgUnsigned16List const& get_exception_index_table() const;
    void set_exception_index_table(SgUnsigned16List const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmExceptions(SgAsmJvmAttributeTable* table);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmExceptions* parse(SgAsmJvmConstantPool*) override;

    /** Write the Exceptions attribute to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmExceptions();

public:
    /** Default constructor. */
    SgAsmJvmExceptions();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmExceptions_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmExceptionHandler           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmExceptionHandler);
IS_SERIALIZABLE(AsmJvmExceptionHandler);

#ifndef DOCUMENTATION
AsmJvmExceptionHandler.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM ExceptionHandler.
 *
 *  Each exception handler is described by an anonymous structure defined in Code_attribute, section 4.7.3 of the JVM specification. */
class SgAsmJvmExceptionHandler: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptionHandler.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptionHandler.setDataPrototype(
        "uint16_t", "end_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptionHandler.setDataPrototype(
        "uint16_t", "handler_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmExceptionHandler.setDataPrototype(
        "uint16_t", "catch_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmExceptionHandler);
#if defined(SgAsmJvmExceptionHandler_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmExceptionHandler -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmExceptionHandler");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
        s & BOOST_SERIALIZATION_NVP(p_end_pc);
        s & BOOST_SERIALIZATION_NVP(p_handler_pc);
        s & BOOST_SERIALIZATION_NVP(p_catch_type);
        debugSerializationEnd("SgAsmJvmExceptionHandler");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: start_pc
     *
     *  The value of the start_pc item must be a valid index into the constant_pool table (see JVM specification).  Present in an
     *  exception table of a Code_attribute (see section 4.7.3 of the JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_start_pc() const;
    void set_start_pc(uint16_t const&);
    /** @} */

public:
    /** Property: end_pc
     *
     *  The value of the end_pc item must be a valid index into the constant_pool table (see JVM specification).  Present in an
     *  exception table of a Code_attribute (see section 4.7.3 of the JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_end_pc() const;
    void set_end_pc(uint16_t const&);
    /** @} */

public:
    /** Property: handler_pc
     *
     *  The value of the handler_pc item must be a valid index into the constant_pool table (see JVM specification).  Present in an
     *  exception table of a Code_attribute (see section 4.7.3 of the JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_handler_pc() const;
    void set_handler_pc(uint16_t const&);
    /** @} */

public:
    /** Property: catch_type
     *
     *  The value of the catch_type item must be a valid index into the constant_pool table (see JVM specification).  Present in an
     *  exception table of a Code_attribute (see section 4.7.3 of the JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_catch_type() const;
    void set_catch_type(uint16_t const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmExceptionHandler(SgAsmJvmExceptionTable* table);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmExceptionHandler* parse(SgAsmJvmConstantPool*);

    /** Write the object to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmExceptionHandler();

public:
    /** Default constructor. */
    SgAsmJvmExceptionHandler();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmExceptionHandler_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmEnclosingMethod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmEnclosingMethod);
IS_SERIALIZABLE(AsmJvmEnclosingMethod);

#ifndef DOCUMENTATION
AsmJvmEnclosingMethod.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM EnclosingMethod attribute.
 *
 *  The EnclosingMethod attribute is a fixed-length attribute in the attributes table of a ClassFile structure (4.1).
 *  A class must have an EnclosingMethod attribute if and only if it represents a local class or an anonymous class,
 *  see section 4.7.7 of the JVM specification. */
class SgAsmJvmEnclosingMethod: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmEnclosingMethod.setDataPrototype(
        "uint16_t", "class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmEnclosingMethod.setDataPrototype(
        "uint16_t", "method_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmEnclosingMethod);
#if defined(SgAsmJvmEnclosingMethod_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmEnclosingMethod -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmEnclosingMethod");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_class_index);
        s & BOOST_SERIALIZATION_NVP(p_method_index);
        debugSerializationEnd("SgAsmJvmEnclosingMethod");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: class_index
     *
     *  The value of the class_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_class_index() const;
    void set_class_index(uint16_t const&);
    /** @} */

public:
    /** Property: method_index
     *
     *  The value of the method_index item either must be zero or a valid index into the constant_pool table
     *  (see JVM specification). 
     *  (
     *  (@{ */
    uint16_t const& get_method_index() const;
    void set_method_index(uint16_t const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmEnclosingMethod(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmEnclosingMethod* parse(SgAsmJvmConstantPool* pool) override;

    /** Write enclosing method to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmEnclosingMethod();

public:
    /** Default constructor. */
    SgAsmJvmEnclosingMethod();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmEnclosingMethod_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantValue           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmConstantValue);
IS_SERIALIZABLE(AsmJvmConstantValue);

#ifndef DOCUMENTATION
AsmJvmConstantValue.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM ConstantValue attribute.
 *
 *  A ConstantValue attribute represents the value of a constant expression, see section 4.7.2 of the JVM specification.
 */
class SgAsmJvmConstantValue: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantValue.setDataPrototype(
        "uint16_t", "constantvalue_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmConstantValue);
#if defined(SgAsmJvmConstantValue_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmConstantValue -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmConstantValue");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_constantvalue_index);
        debugSerializationEnd("SgAsmJvmConstantValue");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: constantvalue_index
     *
     *  The value of the constantvalue_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_constantvalue_index() const;
    void set_constantvalue_index(uint16_t const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmConstantValue(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Write constant value to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantValue();

public:
    /** Default constructor. */
    SgAsmJvmConstantValue();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantValue_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantPool           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmConstantPool);
IS_SERIALIZABLE(AsmJvmConstantPool);

#ifndef DOCUMENTATION
AsmJvmConstantPool.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents an JVM constant pool.
 *
 *  The JVM Constant Pool is itself a section.  The entries of the table are stored with the section they describe rather
 *  than storing them all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have
 *  unique ID numbers that are their original indices in the JVM Section Table. */
class SgAsmJvmConstantPool: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPool.setDataPrototype(
        "SgAsmJvmConstantPoolEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmConstantPool);
#if defined(SgAsmJvmConstantPool_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmConstantPool -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmConstantPool");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmJvmConstantPool");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of constant pool entries. 
     * 
     * @{ */
    SgAsmJvmConstantPoolEntryPtrList const& get_entries() const;
    SgAsmJvmConstantPoolEntryPtrList& get_entries();
    void set_entries(SgAsmJvmConstantPoolEntryPtrList const&);
    /** @} */
public:
    /** Non-parsing constructor. */
    explicit SgAsmJvmConstantPool(SgAsmJvmFileHeader*);

    /** Parses a JVM Constant Pool.
     *
     *  Parses a JVM constant pool and constructs and parses all sections reachable from the table. The section is
     *  extended as necessary based on the number of entries and the size of each entry. Returns a pointer to this
     *  object. */
    virtual SgAsmJvmConstantPool* parse() override;

    /** Returns constant pool entry at given index.
     *
     *  Index starts at one.
     * @{ */
    SgAsmJvmConstantPoolEntry* get_entry(size_t index) const;
    /** @} */

    /** Return a string at the given index.
     *
     *  Throws an error if the index is invalid or if the constant pool entry
     *  at the index is not a CONSTANT_Utf8_info.
     */
    std::string get_utf8_string(size_t index) const;

    /** Write constant pool to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

protected:
    // Some extra clean-up actions on destruction
    virtual void destructorHelper() override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantPool();

public:
    /** Default constructor. */
    SgAsmJvmConstantPool();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantPool_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantPoolEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmConstantPoolEntry);
IS_SERIALIZABLE(AsmJvmConstantPoolEntry);

#ifndef DOCUMENTATION
AsmJvmConstantPoolEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents an entry in a JVM constant pool.
 *
 *  Constant pool entries are referenced by index starting at 1.
 */
class SgAsmJvmConstantPoolEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "SgAsmJvmConstantPoolEntry::Kind", "tag", "= SgAsmJvmConstantPoolEntry::EMPTY",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "hi_bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "low_bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "bootstrap_method_attr_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "name_and_type_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "reference_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint8_t", "reference_kind", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "string_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmConstantPoolEntry.setDataPrototype(
        "char*", "utf8_bytes", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmConstantPoolEntry);
#if defined(SgAsmJvmConstantPoolEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmConstantPoolEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmConstantPoolEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_tag);
        s & BOOST_SERIALIZATION_NVP(p_bytes);
        s & BOOST_SERIALIZATION_NVP(p_hi_bytes);
        s & BOOST_SERIALIZATION_NVP(p_low_bytes);
        s & BOOST_SERIALIZATION_NVP(p_bootstrap_method_attr_index);
        s & BOOST_SERIALIZATION_NVP(p_class_index);
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
        s & BOOST_SERIALIZATION_NVP(p_name_index);
        s & BOOST_SERIALIZATION_NVP(p_name_and_type_index);
        s & BOOST_SERIALIZATION_NVP(p_reference_index);
        s & BOOST_SERIALIZATION_NVP(p_reference_kind);
        s & BOOST_SERIALIZATION_NVP(p_string_index);
        s & BOOST_SERIALIZATION_NVP(p_length);
        debugSerializationEnd("SgAsmJvmConstantPoolEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constant pool tags.
     *
     * These tags indicate the kind of constant denoted by the pool entry.
     */
    enum Kind {
        EMPTY = 0,
        CONSTANT_Utf8 = 1,
        CONSTANT_Integer = 3,
        CONSTANT_Float = 4,
        CONSTANT_Long = 5,
        CONSTANT_Double = 6,
        CONSTANT_Class = 7,
        CONSTANT_String = 8,
        CONSTANT_Fieldref = 9,
        CONSTANT_Methodref = 10,
        CONSTANT_InterfaceMethodref = 11,
        CONSTANT_NameAndType = 12,
        CONSTANT_MethodHandle = 15,
        CONSTANT_MethodType = 16,
        CONSTANT_Dynamic = 17,
        CONSTANT_InvokeDynamic = 18,
        CONSTANT_Module = 19,
        CONSTANT_Package = 20
    };

#ifdef DOCUMENTATION
    /** These following structs are documented below to indicate which fields are active for each tag
     *    of an SgAsmJvmConstantPoolEntry instance. Other fields may not be accessed.
     */
#endif
    /** 4.4.1 CONSTANT_Class_info table entry. All fields are big endian. */
    struct CONSTANT_Class_info {
        uint8_t tag;
        uint16_t name_index;
    };

    /** 4.4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info table
               entries. All fields are big endian. */
    struct CONSTANT_Fieldref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_Methodref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_InterfaceMethodref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };

    /** 4.4.3 CONSTANT_String_info table entry. All fields are big endian. */
    struct CONSTANT_String_info {
        uint8_t tag;
        uint16_t string_index;
    };

    /** 4.4.4 CONSTANT_Integer_info table entry. All fields are big endian. */
    struct CONSTANT_Integer_info {
        uint8_t tag;
        uint32_t bytes;
    };
    struct CONSTANT_Float_info {
        uint8_t tag;
        uint32_t bytes;
    };
    struct CONSTANT_Long_info {
        uint8_t tag;
        uint32_t hi_bytes;
        uint32_t low_bytes;
    };
    struct CONSTANT_Double_info {
        uint8_t tag;
        uint32_t hi_bytes;
        uint32_t low_bytes;
    };

    /** 4.4.6 CONSTANT_NameAndType_info table entry. All fields are big endian. */
    struct CONSTANT_NameAndType_info {
        uint8_t tag;
        uint16_t name_index;
        uint16_t descriptor_index;
    };

    /** 4.4.7 CONSTANT_Utf8_info table entry. All fields are big endian. */
    struct CONSTANT_Utf8_info {
        uint8_t tag;
        uint16_t length;
        uint8_t* bytes;
    };

    /** 4.4.8 CONSTANT_MethodHandle_info table entry. All fields are big endian. */
    struct CONSTANT_MethodHandle_info {
        uint8_t tag;
        uint8_t reference_kind;
        uint16_t reference_index;
    };

    /** 4.4.9 CONSTANT_MethodType_info table entry. All fields are big endian. */
    struct CONSTANT_MethodType_info {
        uint8_t tag;
        uint16_t descriptor_index;
    };

    /** 4.4.10 CONSTANT_Dynamic_info table entry. All fields are big endian. */
    struct CONSTANT_Dynamic_info {
        uint8_t tag;
        uint16_t bootstrap_method_attr_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_InvokeDynamic_info {
        uint8_t tag;
        uint16_t bootstrap_method_attr_index;
        uint16_t name_and_type_index;
    };

    /** 4.4.11 CONSTANT_Module_info table entry. All fields are big endian. */
    struct CONSTANT_Module_info {
        uint8_t tag;
        uint16_t name_index;
    };

    /** 4.4.12 CONSTANT_Package_info table entry. All fields are big endian. */
    struct CONSTANT_Package_info {
        uint8_t tag;
        uint16_t name_index;
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: tag
     *
     *  Enum constant describing the kind of this entry in the pool. 
     *  
     *  @{ */
    SgAsmJvmConstantPoolEntry::Kind const& get_tag() const;
    void set_tag(SgAsmJvmConstantPoolEntry::Kind const&);
    /** @} */

public:
    /** Property: bytes
     *
     *  The bytes item of the CONSTANT_Integer_info structure represents the value of the int constant.  The bytes item of the
     *  CONSTANT_Float_info structure represents the value of the float constant in IEEE 754 binary32 floating-point format. 
     *  
     *  @{ */
    uint32_t const& get_bytes() const;
    void set_bytes(uint32_t const&);
    /** @} */

public:
    /** Properties: hi_bytes
     *
     *  The unsigned high_bytes and low_bytes items of the CONSTANT_Long_info structure together represent the value of the long
     *  constant.  The unsigned high_bytes and low_bytes items of the CONSTANT_Double_info structure together represent the the
     *  double value in IEEE 754 binary64 floating-point format. 
     *  
     *  @{ */
    uint32_t const& get_hi_bytes() const;
    void set_hi_bytes(uint32_t const&);
    /** @} */

public:
    /** Properties: low_bytes
     *
     *  The unsigned high_bytes and low_bytes items of the CONSTANT_Long_info structure together represent the value of the long
     *  constant.  The unsigned high_bytes and low_bytes items of the CONSTANT_Double_info structure together represent the the
     *  double value in IEEE 754 binary64 floating-point format. 
     *  
     *  @{ */
    uint32_t const& get_low_bytes() const;
    void set_low_bytes(uint32_t const&);
    /** @} */

public:
    /** Property: bootstrap_method_attr_index
     *
     *  The bootstrap_method_attr_index item is an index into the bootstrap_methods array of the bootstrap method table of this
     *  class file.  Present in CONSTANT_Dynamic_info and CONSTANT_Dynamic_info structs. 
     *  
     *  @{ */
    uint16_t const& get_bootstrap_method_attr_index() const;
    void set_bootstrap_method_attr_index(uint16_t const&);
    /** @} */

public:
    /** Property: class_index
     *
     *  The value of the class_index item must be a valid index into the constant_pool table (see JVM specification).  Present in
     *  CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_class_index() const;
    void set_class_index(uint16_t const&);
    /** @} */

public:
    /** Property: descriptor_index
     *
     *  The value of the descriptor_index item must be a valid index into the constant_pool table (see JVM specification).  Present
     *  in CONSTANT_NameAndType_info and CONSTANT_MethodHandle_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_descriptor_index() const;
    void set_descriptor_index(uint16_t const&);
    /** @} */

public:
    /** Property: name_index
     *
     *  The value of the name_index item must be a valid index into the constant_pool table (see JVM specification).  Present in
     *  CONSTANT_Class_info, CONSTANT_NameAndType_info, CONSTANT_Module_info, and CONSTANT_Package_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_name_index() const;
    void set_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: name_and_type_index
     *
     *  The value of the name_and_type_index item must be a valid index into the constant_pool table (see JVM specification).
     *  Present in CONSTANT_Fieldref_info, CONSTANT_Methodref_info, CONSTANT_InterfaceMethodref_info, CONSTANT_Dynamic_info, and
     *  CONSTANT_InvokeDynamic_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_name_and_type_index() const;
    void set_name_and_type_index(uint16_t const&);
    /** @} */

public:
    /** Property: reference_index
     *
     *  The value of the reference_index item must be a valid index into the constant_pool table (see JVM specification).  Present
     *  in CONSTANT_MethodHandle_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_reference_index() const;
    void set_reference_index(uint16_t const&);
    /** @} */

public:
    /** Property: reference_kind
     *
     *  The value of the reference_kind item must be in the range 1 to 9. The value denotes the kind of a CONSTANT_MethodHandle_info
     *  table entry. 
     *  
     *  @{ */
    uint8_t const& get_reference_kind() const;
    void set_reference_kind(uint8_t const&);
    /** @} */

public:
    /** Property: string_index
     *
     *  The value of the string_index item must be a valid index into the constant_pool table (see JVM specification).  Present in
     *  CONSTANT_String_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_string_index() const;
    void set_string_index(uint16_t const&);
    /** @} */

public:
    /** Property: length
     *
     *  The value of the length item gives the number of bytes in the bytes array (not the length of the resulting string).  Present
     *  in CONSTANT_Utf8_info table entries. 
     *  
     *  @{ */
    uint16_t const& get_length() const;
    void set_length(uint16_t const&);
    /** @} */
    // [Robb Matzke 2023-03-22]: I (and the serialization) have no idea what this points to, and therefore it cannot be
    // serialized. E.g., how many 'chars' should be serialized? Is the length stored in the `length` property? If so, `utf8_bytes`
    // should probably be an std::vector instead, which is a serializable thing. Furthermore, the data member cannot be 'const'
    // because that prevents it from being initialized by some de-serialization mechanisms (e.g., boost::serialize creates a default
    // constructed object and then fills it in).
public:
    /** Property: utf8_bytes (bytes in CONSTANT_Utf8_info structure).
     *
     *  The bytes array contains the bytes of the string. Present in CONSTANT_Utf8_info table entries. 
     *  
     *  @{ */
    char* const& get_utf8_bytes() const;
    void set_utf8_bytes(char* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor creating an object ready to be initialized via parse(). */
    explicit SgAsmJvmConstantPoolEntry(SgAsmJvmConstantPoolEntry::Kind tag);

    /** Initialize a constant pool entry by parsing the file.
     *
     * @{ */
    SgAsmJvmConstantPoolEntry* parse(SgAsmJvmConstantPool* pool);
    /** @} */

    /** Write constant pool entry to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Convert constant pool entry kind to a string */
    static std::string to_string(SgAsmJvmConstantPoolEntry::Kind);
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantPoolEntry();

public:
    /** Default constructor. */
    SgAsmJvmConstantPoolEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantPoolEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmCodeAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmCodeAttribute);
IS_SERIALIZABLE(AsmJvmCodeAttribute);

#ifndef DOCUMENTATION
AsmJvmCodeAttribute.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM Code attribute.
 *
 *  A Code attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance
 *  initialization method and a class or interface initialization method, see section 4.7.3 of the JVM specification.
 */
class SgAsmJvmCodeAttribute: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "uint16_t", "max_stack", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "uint16_t", "max_locals", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "uint32_t", "code_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "const char*", "code", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "SgAsmJvmExceptionTable*", "exception_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmCodeAttribute.setDataPrototype(
        "rose_addr_t", "code_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmCodeAttribute);
#if defined(SgAsmJvmCodeAttribute_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmCodeAttribute -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmCodeAttribute");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_max_stack);
        s & BOOST_SERIALIZATION_NVP(p_max_locals);
        s & BOOST_SERIALIZATION_NVP(p_code_length);
        s & BOOST_SERIALIZATION_NVP(p_exception_table);
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
        s & BOOST_SERIALIZATION_NVP(p_code_offset);
        debugSerializationEnd("SgAsmJvmCodeAttribute");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: max_stack
     *
     *  The value of the max_stack item gives the maximum depth of the operand stack of this method at any point during execution of
     *  the method. 
     *  
     *  @{ */
    uint16_t const& get_max_stack() const;
    void set_max_stack(uint16_t const&);
    /** @} */

public:
    /** Property: max_locals
     *
     *  The value of the max_locals item gives the number of local variables in the local variable array allocated upon invocation
     *  of this method. 
     *  
     *  @{ */
    uint16_t const& get_max_locals() const;
    void set_max_locals(uint16_t const&);
    /** @} */

public:
    /** Property: code_length
     *
     *  The value of the code_length item gives the number of local variables in the local variable array allocated upon invocation
     *  of this method. 
     *  
     *  @{ */
    uint32_t const& get_code_length() const;
    void set_code_length(uint32_t const&);
    /** @} */
    // FIXME[Robb Matzke 2023-03-20]: is the lack of serialization a bug?
public:
    /** Property: code
     *
     *  The code array gives the actual bytes of Java Virtual Machine code that implement the method. 
     *  
     *  @{ */
    const char* const& get_code() const;
    void set_code(const char* const&);
    /** @} */

public:
    /** Property: Exception table.
     *
     *  Points to the AST node that represents the exception table for this code attribute. 
     *  
     *  @{ */
    SgAsmJvmExceptionTable* const& get_exception_table() const;
    void set_exception_table(SgAsmJvmExceptionTable* const&);
    /** @} */

public:
    /** Property: Attribute table.
     *
     *  Points to the AST node that represents the attribute table for this code attribute. 
     *  
     *  @{ */
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */

public:
    /** Property: Code offset.
     *
     *  Offset in bytes from the start of the file for the byte-code array of the method.  A convenience property @a not in the JVM
     *  specification. 
     *  
     *  @{ */
    rose_addr_t const& get_code_offset() const;
    void set_code_offset(rose_addr_t const&);
    /** @} */
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmCodeAttribute(SgAsmJvmAttributeTable* table);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Write code attribute to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmCodeAttribute();

public:
    /** Default constructor. */
    SgAsmJvmCodeAttribute();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmCodeAttribute_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmClass);
IS_SERIALIZABLE(AsmJvmClass);

#ifndef DOCUMENTATION
AsmJvmClass.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** JVM Class.
 *
 *  Each class is described by a CONSTANT_Class_info structure.  See the JVM specification section 4.4.1. */
class SgAsmJvmClass: public SgAsmJvmNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmJvmClass);
#if defined(SgAsmJvmClass_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmClass -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmClass");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        debugSerializationEnd("SgAsmJvmClass");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmJvmClass();

public:
    /** Default constructor. */
    SgAsmJvmClass();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmClass_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmBootstrapMethods           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmBootstrapMethods);
IS_SERIALIZABLE(AsmJvmBootstrapMethods);

#ifndef DOCUMENTATION
AsmJvmBootstrapMethods.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmBootstrapMethods);
#if defined(SgAsmJvmBootstrapMethods_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmBootstrapMethods_HEADERS

#ifdef DOCUMENTATION
/** The BootstrapMethods attribute is a variable-length attribute in the attributes table of a ClassFile
 *  structure (Section 4.1). The BootstrapMethods attribute records bootstrap methods used to produce
 *  dynamically-computed constants and dynamically-computed call sites (Section 4.4.10).
 */
class SgAsmJvmBootstrapMethods: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmBootstrapMethods.setDataPrototype(
        "SgAsmJvmBootstrapMethodPtrList", "bootstrap_methods", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmBootstrapMethods);
#if defined(SgAsmJvmBootstrapMethods_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmBootstrapMethods -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmBootstrapMethods");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
        s & BOOST_SERIALIZATION_NVP(p_bootstrap_methods);
        debugSerializationEnd("SgAsmJvmBootstrapMethods");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: List of bootstrap method entries. 
     * 
     * @{ */
    SgAsmJvmBootstrapMethodPtrList const& get_bootstrap_methods() const;
    SgAsmJvmBootstrapMethodPtrList& get_bootstrap_methods();
    void set_bootstrap_methods(SgAsmJvmBootstrapMethodPtrList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Initialize the bootstrap methods object before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmBootstrapMethods(SgAsmJvmAttributeTable*);

    /** Initialize the object by parsing content from the class file. */
    virtual SgAsmJvmBootstrapMethods* parse(SgAsmJvmConstantPool* pool) override;

    /** Write the BootstrapMethods attribute to a binary file */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmBootstrapMethods();

public:
    /** Default constructor. */
    SgAsmJvmBootstrapMethods();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmBootstrapMethods_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmBootstrapMethod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmBootstrapMethod);
IS_SERIALIZABLE(AsmJvmBootstrapMethod);

#ifndef DOCUMENTATION
AsmJvmBootstrapMethod.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmJvmBootstrapMethod);
#if defined(SgAsmJvmBootstrapMethod_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmJvmBootstrapMethod_HEADERS

#ifdef DOCUMENTATION
/** JVM BootstrapMethod.
 *
 *  Each bootstrap_method entry contains an index to a CONSTANT_MethodHandle_info structure which specifies
 *  a bootstrap method, and a sequence (perhaps empty) of indexes to static arguments for the bootstrap method.
 */
class SgAsmJvmBootstrapMethod: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmBootstrapMethod.setDataPrototype(
        "uint16_t", "bootstrap_method_ref", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmBootstrapMethod.setDataPrototype(
        "SgUnsigned16List", "bootstrap_arguments", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmBootstrapMethod);
#if defined(SgAsmJvmBootstrapMethod_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmBootstrapMethod -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmBootstrapMethod");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_bootstrap_method_ref);
        s & BOOST_SERIALIZATION_NVP(p_bootstrap_arguments);
        debugSerializationEnd("SgAsmJvmBootstrapMethod");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: bootstrap_method_ref.
     *
     *  The value of the bootstrap_method_ref item must be a valid index into the constant_pool table.
     *  The constant_pool entry at that index must be a CONSTANT_MethodHandle_info structure (Section 4.4.8).
     *  
     *  @{ */
    uint16_t const& get_bootstrap_method_ref() const;
    void set_bootstrap_method_ref(uint16_t const&);
    /** @} */

public:
    /** Property: bootstrap_arguments.
     *
     *  Each entry in the bootstrap_arguments list must be a valid index into the constant_pool table.
     *  The constant_pool entry at that index must be loadable (Section 4.4).
     *  
     *  @{ */
    SgUnsigned16List const& get_bootstrap_arguments() const;
    void set_bootstrap_arguments(SgUnsigned16List const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing as it sets its parent. */
    explicit SgAsmJvmBootstrapMethod(SgAsmJvmBootstrapMethods*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmBootstrapMethod* parse(SgAsmJvmConstantPool*);

    /** Write object to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmBootstrapMethod();

public:
    /** Default constructor. */
    SgAsmJvmBootstrapMethod();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmBootstrapMethod_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmAttributeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmJvmAttributeTable);
IS_SERIALIZABLE(AsmJvmAttributeTable);

#ifndef DOCUMENTATION
AsmJvmAttributeTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents a JVM attribute_info table/array.
 *
 *  A JVM attribute table is a section.  The entries of the table are stored with the section they describe rather than storing them
 *  all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers that are
 *  their original indices in the JVM Section Table. */
class SgAsmJvmAttributeTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmAttributeTable.setDataPrototype(
        "SgAsmJvmAttributePtrList", "attributes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmAttributeTable);
#if defined(SgAsmJvmAttributeTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmAttributeTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmAttributeTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_attributes);
        debugSerializationEnd("SgAsmJvmAttributeTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to attributes. 
     * 
     * @{ */
    SgAsmJvmAttributePtrList const& get_attributes() const;
    SgAsmJvmAttributePtrList& get_attributes();
    void set_attributes(SgAsmJvmAttributePtrList const&);
    /** @} */
public:
    /** Initialize the attribute table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmAttributeTable(SgAsmJvmFileHeader*, SgAsmNode*);

    /** Parses a JVM attribute table.
     *
     *  Parses a JVM attribute table and constructs and parses all attributes reachable from the table section. Returns a pointer to
     *  this object. */
    using SgAsmGenericSection::parse; // Removes warning messages on some compilers
                                      // ("hidden virtual overloaded function")
    SgAsmJvmAttributeTable* parse(SgAsmJvmConstantPool*);

    /** Write attribute table to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmAttributeTable();

public:
    /** Default constructor. */
    SgAsmJvmAttributeTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmAttributeTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmJvmAttribute = nonTerminalConstructor(
    "AsmJvmAttribute",
    *this,
    "AsmJvmAttribute",
    "AsmJvmAttributeTag",
    SubclassListBuilder()
        | AsmJvmBootstrapMethods
        | AsmJvmCodeAttribute
        | AsmJvmConstantValue
        | AsmJvmEnclosingMethod
        | AsmJvmExceptions
        | AsmJvmInnerClasses
        | AsmJvmLineNumberTable
        | AsmJvmLocalVariableTable
        | AsmJvmLocalVariableTypeTable
        | AsmJvmMethodParameters
        | AsmJvmModuleMainClass
        | AsmJvmNestHost
        | AsmJvmNestMembers
        | AsmJvmSignature
        | AsmJvmSourceFile
        | AsmJvmStackMapTable
    , false);
assert(AsmJvmAttribute.associatedGrammar != nullptr);
AsmJvmAttribute.setCppCondition("!defined(DOCUMENTATION)");
AsmJvmAttribute.isBoostSerializable(true);
AsmJvmAttribute.setAutomaticGenerationOfConstructor(false);
AsmJvmAttribute.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmJvmAttribute.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for a JVM attribute. */
class SgAsmJvmAttribute: public SgAsmJvmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmAttribute.setDataPrototype(
        "uint16_t", "attribute_name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmJvmAttribute.setDataPrototype(
        "uint32_t", "attribute_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmJvmAttribute);
#if defined(SgAsmJvmAttribute_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmAttribute -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmAttribute");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
        s & BOOST_SERIALIZATION_NVP(p_attribute_name_index);
        s & BOOST_SERIALIZATION_NVP(p_attribute_length);
        debugSerializationEnd("SgAsmJvmAttribute");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: attribute_name_index
     *
     *  The value of the attribute_name_index item must be a valid index into the constant_pool table (see JVM specification). 
     *  
     *  @{ */
    uint16_t const& get_attribute_name_index() const;
    void set_attribute_name_index(uint16_t const&);
    /** @} */

public:
    /** Property: attribute_length
     *
     *  The value of the attribute_length item indicates the length of the attribute, not including the attribute_name_index nor
     *  attribute_length. 
     *  
     *  @{ */
    uint32_t const& get_attribute_length() const;
    void set_attribute_length(uint32_t const&);
    /** @} */
public:
    /** Factory method returning a derived class instance. */
    static SgAsmJvmAttribute* instance(SgAsmJvmConstantPool* pool, SgAsmJvmAttributeTable* parent);

    /** Initialize an attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool);

    /** Write attribute to a binary file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmJvmAttribute();

protected:
    /** Default constructor. */
    SgAsmJvmAttribute();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmAttribute_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmJvmNode = nonTerminalConstructor(
    "AsmJvmNode",
    *this,
    "AsmJvmNode",
    "AsmJvmNodeTag",
    SubclassListBuilder()
        | AsmJvmAttribute
        | AsmJvmBootstrapMethod
        | AsmJvmClass
        | AsmJvmConstantPoolEntry
        | AsmJvmExceptionHandler
        | AsmJvmExceptionTable
        | AsmJvmField
        | AsmJvmInnerClassesEntry
        | AsmJvmLineNumberEntry
        | AsmJvmLocalVariableEntry
        | AsmJvmLocalVariableTypeEntry
        | AsmJvmMethod
        | AsmJvmMethodParametersEntry
        | AsmJvmStackMapFrame
        | AsmJvmStackMapVerificationType
    , false);
assert(AsmJvmNode.associatedGrammar != nullptr);
AsmJvmNode.setCppCondition("!defined(DOCUMENTATION)");
AsmJvmNode.isBoostSerializable(true);
AsmJvmNode.setAutomaticGenerationOfConstructor(false);
AsmJvmNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmJvmNode.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for JVM branch of binary analysis IR nodes. */
class SgAsmJvmNode: public SgAsmNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmJvmNode);
#if defined(SgAsmJvmNode_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmJvmNode -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmJvmNode");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        debugSerializationEnd("SgAsmJvmNode");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Write node to a binary file. */
    virtual void unparse(std::ostream&) const;

    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmJvmNode();

protected:
    /** Default constructor. */
    SgAsmJvmNode();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmNode_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInterpretationList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmInterpretationList);
IS_SERIALIZABLE(AsmInterpretationList);

#ifndef DOCUMENTATION
AsmInterpretationList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmInterpretationList);
#if defined(SgAsmInterpretationList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmInterpretationList_HEADERS

#ifdef DOCUMENTATION
class SgAsmInterpretationList: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInterpretationList.setDataPrototype(
        "SgAsmInterpretationPtrList", "interpretations", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmInterpretationList);
#if defined(SgAsmInterpretationList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmInterpretationList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmInterpretationList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_interpretations);
        debugSerializationEnd("SgAsmInterpretationList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Interpretation list.
     *
     *  The actual list of pointers to interpretations. The only reason this list is in its own node instead of being
     *  contained directly in the node that needs it is because of limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmInterpretationPtrList const& get_interpretations() const;
    SgAsmInterpretationPtrList& get_interpretations();
    void set_interpretations(SgAsmInterpretationPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmInterpretationList();

public:
    /** Default constructor. */
    SgAsmInterpretationList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInterpretationList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInterpretation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmInterpretation);
IS_SERIALIZABLE(AsmInterpretation);

#ifndef DOCUMENTATION
AsmInterpretation.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmInterpretation);
#if defined(SgAsmInterpretation_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/BasicTypes.h>
#include <Rose/BinaryAnalysis/InstructionMap.h>
#include <Rose/BinaryAnalysis/MemoryMap.h>

#ifdef ROSE_SgAsmInterpretation_IMPL
#include <SgAsmBlock.h>
#include <SgAsmGenericHeaderList.h>
#endif
#endif // SgAsmInterpretation_HEADERS

#ifdef DOCUMENTATION
/** Represents an interpretation of a binary container.
 *
 *  An interpretation is a collection of the parts of a binary specimen that represent a coherent program, library, core
 *  dump, etc. For instance, a Windows PE executable has a DOS interpretation and a Windows interpretation--really two
 *  executables in the one container. All the DOS-related stuff will be under one SgAsmInterpretation AST and all the
 *  Windows-related stuff will be under another SgAsmInterpretation AST. */
class SgAsmInterpretation: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInterpretation.setDataPrototype(
        "SgAsmGenericHeaderList*", "headers", "= createAndParent<SgAsmGenericHeaderList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInterpretation.setDataPrototype(
        "SgAsmBlock*", "globalBlock", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInterpretation.setDataPrototype(
        "bool", "coverageComputed", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInterpretation.setDataPrototype(
        "double", "percentageCoverage", "= NAN",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmInterpretation);
#if defined(SgAsmInterpretation_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmInterpretation -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmInterpretation");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_headers);
        s & BOOST_SERIALIZATION_NVP(p_globalBlock);
        s & BOOST_SERIALIZATION_NVP(p_map);
        s & BOOST_SERIALIZATION_NVP(instruction_map);
        s & BOOST_SERIALIZATION_NVP(p_coverageComputed);
        s & BOOST_SERIALIZATION_NVP(p_percentageCoverage);
        debugSerializationEnd("SgAsmInterpretation");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: File headers.
     *
     *  List of pointers to the file headers that compose this interpretation.
     *
     *  These headers are not considered to be children of this interpretation in the AST--they are reached from other
     *  traversal paths. 
     *  
     *  @{ */
    SgAsmGenericHeaderList* const& get_headers() const;
    void set_headers(SgAsmGenericHeaderList* const&);
    /** @} */

public:
    /** Property: Global block.
     *
     *  The global block is the top of the AST for this interpretation's functions, basic blocks, and instructions. 
     *  
     *  @{ */
    SgAsmBlock* const& get_globalBlock() const;
    void set_globalBlock(SgAsmBlock* const&);
    /** @} */
    // ROSETTA doesn't understand this type, but we want this treated like a property whose data member name is "p_map"
    // and which has automatically generator accessors and mutators named "get_map" and "set_map" and is serialized.
private:
    Rose::BinaryAnalysis::MemoryMap::Ptr p_map;

public:
    /** Property: Memory map.
     *
     *  This is the memory map representing the entire interpretation. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::MemoryMap::Ptr const& get_map() const;
    void set_map(Rose::BinaryAnalysis::MemoryMap::Ptr const&);
    /** @} */
    // ROSETTA doesn't understand this type, but we want it serialized. Therfore, we'll define it as a property, but we'll
    // supply our own accessor and no mutator.
private:
    mutable Rose::BinaryAnalysis::InstructionMap instruction_map;

public:
    /** Property: Cached map of instructions by address.
     *
     *  Returns the @ref InstructionMap associated with an interpretation. The instruction map is recomputed if the
     *  currently cached map is empty or if the @p recompute argument is true. Otherwise this just returns the existing
     *  map. No attempt is made to make sure that the map is up-to-date with respect to the current state of the AST.
     *
     *  @{ */
 // cached instruction map

    Rose::BinaryAnalysis::InstructionMap& get_instructionMap(bool recompute = false);
    void set_instructionMap(const Rose::BinaryAnalysis::InstructionMap&);
    /** @} */
public:
    /** Property: code coverage percent.
     *
     *  True iff percentageCoverage has been computed.
     *
     *  Results of a code coverage analysis. 
     *  
     *  @{ */
    bool const& get_coverageComputed() const;
    void set_coverageComputed(bool const&);
    /** @} */

public:
    /** Property: code coverage percent.
     *
     *  The percentage of an interpretation where each section is marked as executable and identified for
     *  disassembly into instructions. 
     *  
     *  @{ */
    double const& get_percentageCoverage() const;
    void set_percentageCoverage(double const&);
    /** @} */
public:
    /** Returns a list of all files referenced by an interpretation.
     *
     *  It does this by looking at the file headers referenced by the interpretation, following their parent pointers up to an
     *  SgAsmGenericFile node, and returning a vector of those nodes with duplicate files removed. */
    SgAsmGenericFilePtrList get_files() const;

    /** Populate a map of instructions indexed by their virtual addresses.
     *
     *  This function traverses the AST rooted at the @ref globalBlock and inserts each encountered instruction into the provided
     *  @ref Rose::BinaryAnalysis::InstructionMap based on its starting virtual address. */
    void insertInstructions(Rose::BinaryAnalysis::InstructionMap&/*in,out*/);

    /** Erase instructions from a map.
     *
     *  This function traverses the AST rooted at the @ref globalBlock and erases each encountered instruction from the provided
     *  @ref Rose::BinaryAnalysis::InstructionMap based on its starting virtual address. */
    void eraseInstructions(Rose::BinaryAnalysis::InstructionMap&/*in,out*/);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmBlock* get_global_block() const ROSE_DEPRECATED("use get_globalBlock");
    void set_global_block(SgAsmBlock*) ROSE_DEPRECATED("use set_globalBlock");
    Rose::BinaryAnalysis::InstructionMap& get_instruction_map(bool=false) ROSE_DEPRECATED("use get_instructionMap");
    void set_instruction_map(const Rose::BinaryAnalysis::InstructionMap&) ROSE_DEPRECATED("use set_instructionMap");
    void insert_instructions(Rose::BinaryAnalysis::InstructionMap&) ROSE_DEPRECATED("use insertInstructions");
    void erase_instructions(Rose::BinaryAnalysis::InstructionMap&) ROSE_DEPRECATED("use eraseInstructions");
public:
    /** Destructor. */
    virtual ~SgAsmInterpretation();

public:
    /** Default constructor. */
    SgAsmInterpretation();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInterpretation_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIntegerValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmIntegerValueExpression);
IS_SERIALIZABLE(AsmIntegerValueExpression);

#ifndef DOCUMENTATION
AsmIntegerValueExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/**  Base class for integer values.
 *
 *  An integer value consists of an offset from an optional base node.  The base node must be some kind of object with a
 *  virtual address, such as an instruction, symbol, segment, etc.  If no base node is associated with the
 *  SgAsmIntegerValueExpression (the default situation), then a zero base address is used.
 *
 *  When a (new) base object is associated with an SgAsmIntegerValueExpression via the makeRelativeTo() method, the value
 *  of the expression does not change.  However, the value does change when the address of the associated base node
 *  changes.  For instance, one way to represent a function call to "main" is to have a CALL instruction whose operand is
 *  an SgAsmIntegerValueExpression that has a base which is either the entry instruction of "main" or the symbol for
 *  "main".  That way, if the address of "main" changes then the target address in the CALL instruction also changes.
 *
 *  The base class stores the bits that are interpretted as the signed offset. The offset is accessed with
 *  get_relativeValue() and set_relativeValue() methods. The class also defines get_absoluteValue() and
 *  set_aabsoluteValue() methods that operate on the absolute value (which isn't actually stored anywhere). */
class SgAsmIntegerValueExpression: public SgAsmConstantExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIntegerValueExpression.setDataPrototype(
        "SgNode*", "baseNode", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmIntegerValueExpression);
#if defined(SgAsmIntegerValueExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmIntegerValueExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmIntegerValueExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmConstantExpression);
        s & BOOST_SERIALIZATION_NVP(p_baseNode);
        debugSerializationEnd("SgAsmIntegerValueExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Base node associated with an integer.
     *
     * When setting this property, the base node is changed without updating this object's relative value, thus this
     * object's absolute value changes.  The value returned by get_absoluteValue() will probably differ from what it would
     * have returned before calling set_baseNode().  If this is not the behavior that's needed, see the makeRelativeTo()
     * method.
     *
     * The base node is not considered to be a child of this node in the AST. 
     * 
     * @{ */
    SgNode* const& get_baseNode() const;
    void set_baseNode(SgNode* const&);
    /** @} */
public:
    /** Construct a new value of specified type.
     *
     *  Creates a new AST node having value @p n of type @p type. See also, the constructor that takes a bit vector as the
     *  first argument, which is useful when the value is non-integral or is too large to fit in a @c uint64_t. */
    SgAsmIntegerValueExpression(uint64_t n, SgAsmType *type);

    /** Construct a new value of specified type.
     *
     *  Creates a new AST node having value @p bv of type @p type.  See also, the constructor that takes a @c uint64_t as
     *  the first argument which might be simpler to call in situations where the value is an integral type not more than
     *  64 bits. */
    SgAsmIntegerValueExpression(const Sawyer::Container::BitVector &bv, SgAsmType *type);

    /** Returns the base address of an addressable IR node. */
    static uint64_t virtualAddress(SgNode*);

    /** Returns a label for the value.
     *
     *  The label consists of the base object name (if available) or address, followed by a plus sign or minus sign,
     *  followed by the offset from that object.  The empty string is returned if this integer value expression has no base
     *  object (i.e., it's absolute).
     *
     *  If the base object has no name and the integer value points directly at the object (offset=0) then one of two
     *  things happen: if @p quiet is true, the empty string is returned, otherwise the label is the name of the node type
     *  enclosed in an extra set of angle brackets.  This is useful to indicate that a value is relative rather than
     *  absolute.  For instance, the instruction listing "call 0x004126bb" is ambiguous as to whether 0x004126bb points to
     *  a known, unnamed function, a non-entry instruction within a function, or some memory location we didn't
     *  disassemble.  But when labeled with @p quiet being false, the output will be:
     *
     *  @code
     *  call 0x004126bb<main>; points to a function with a name
     *  call 0x004126bb<<Func>>; points to a function without a name
     *  call 0x004126bb<<Insn>>; points to an instruction that's not a function entry point
     *  call 0x004126bb; points to something that's not been disassembled
     *  @endcode */
    std::string get_label(bool quiet=false) const;

    /** Return the number of significant bits in the value. */
    size_t get_significantBits() const;

    /** Makes the value of this integer relative to some other addressable node.
     *
     *  The absolute value of this expression is unchanged by this operation. The @p baseNode must be a type of IR node
     *  that has a virtual address, such as another instruction.  If @p baseNode is the null pointer, then the
     *  "relativeness" of this constant is removed (i.e., it will be relative to zero). */
    void makeRelativeTo(SgNode *baseNode);

    /** Returns the base address.
     *
     *  The base address is the virtual address of the associated IR node, or zero if no IR node is associated with this
     *  integer value. */
    uint64_t get_baseAddress() const;

    /** Returns the current absolute value zero filled to 64 bits.
     *
     *  The absolute value is the 64-bit sum of the 64-bit address of the base node (or zero if no base node is associated
     *  with this object) and the 64-bit offset. However, this function returns only the specified number of low-order bits
     *  zero extended to the 64-bit return type.  If @p nbits is zero, then get_significantBits() is called. */
    uint64_t get_absoluteValue(size_t nbits=0) const;

    /** Set absolute value.
     *
     *  Changes the absolute value of this integer expression without changing the base node. */
    void set_absoluteValue(uint64_t);

    /** Returns the current absolute value (base+offset) as a signed value. */
    int64_t get_signedValue() const;

    /** Get relative value.
     *
     *  Interprets the bit vector as a signed value, sign extends it to 64-bits if necessary, and returns it. */
    int64_t get_relativeValue() const;

    /** Set relative value without changing the base value.
     *
     *  The relative value is interpretted as a signed value of the specified
     *  width (defaulting to 64-bits). */
    void set_relativeValue(int64_t v, size_t nbits=64);

    uint64_t get_value() const { return get_absoluteValue(); }
public:
    /** Destructor. */
    virtual ~SgAsmIntegerValueExpression();

public:
    /** Default constructor. */
    SgAsmIntegerValueExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIntegerValueExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIntegerType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmIntegerType);
IS_SERIALIZABLE(AsmIntegerType);

#ifndef DOCUMENTATION
AsmIntegerType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmIntegerType);
#if defined(SgAsmIntegerType_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmIntegerType_HEADERS

#ifdef DOCUMENTATION
/** Integer types. */
class SgAsmIntegerType: public SgAsmScalarType {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIntegerType.setDataPrototype(
        "bool", "isSigned", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmIntegerType);
#if defined(SgAsmIntegerType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmIntegerType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmIntegerType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmScalarType);
        s & BOOST_SERIALIZATION_NVP(p_isSigned);
        debugSerializationEnd("SgAsmIntegerType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: whether the integral type is signed or unsigned.
     *
     *  Returns true if this is a signed type, otherwise false.
     *
     * @{ */
    bool get_isSigned() const;
    /** @} */

public:
    /** Constructor with specified member values.
     *
     *  Constructs a new integer type and initializes its properties according to the arguments. */
    SgAsmIntegerType(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits, bool isSigned);

    /** Make an instance for an unsigned type. */
    static SgAsmIntegerType* instanceUnsigned(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits);

    /** Make an instance for a signed type. */
    static SgAsmIntegerType* instanceSigned(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits);

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
public:
    /** Destructor. */
    virtual ~SgAsmIntegerType();

public:
    /** Default constructor. */
    SgAsmIntegerType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIntegerType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInstructionList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmInstructionList);
IS_SERIALIZABLE(AsmInstructionList);

#ifndef DOCUMENTATION
AsmInstructionList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmInstructionList);
#if defined(SgAsmInstructionList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmInstructionList_HEADERS

#ifdef DOCUMENTATION
/** List of SgAsmInstruction nodes. */
class SgAsmInstructionList: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstructionList.setDataPrototype(
        "SgAsmInstructionPtrList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmInstructionList);
#if defined(SgAsmInstructionList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmInstructionList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmInstructionList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_instructions);
        debugSerializationEnd("SgAsmInstructionList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of @ref SgAsmInstruction entries.
     *
     *  The @ref SgAsmInstruction nodes in this list have not been broken
     *  into separate instruction blocks.  Therefore, the list may contain
     *  branching instructions that do not terminate the list. 
     *  
     *  @{ */
    SgAsmInstructionPtrList const& get_instructions() const;
    SgAsmInstructionPtrList& get_instructions();
    void set_instructions(SgAsmInstructionPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmInstructionList();

public:
    /** Default constructor. */
    SgAsmInstructionList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInstructionList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIndirectRegisterExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmIndirectRegisterExpression);
IS_SERIALIZABLE(AsmIndirectRegisterExpression);

#ifndef DOCUMENTATION
AsmIndirectRegisterExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Registers accessed indirectly.
 *
 *  An indirect register is a register whose descriptor is computed dynamically.  The dynamic descriptor is computed by reading
 *  "offset" register to obtain an integral value and adding it to the integral "index" modulo the specified "modulus" to obtain an
 *  integer @em i. (These are all properties of this node.)  Then, the final register descriptor is calculated by adding @em i times
 *  "stride" to the base register @ref SgAsmRegisterReferenceExpression::descriptor. The @em i times "stride" multiplies each member
 *  of "stride" by @em i, and addition of two register descriptors is defined as the pair-wise addition of their elements.
 *
 *  An example of an indirect register is x86 ST(1) which has base register "st", stride={0,1,0,0}, offset register "fpstatus_top",
 *  index is 1, and modulus is 8. Thus, the dynamically-computed register is:
 *
 *  @code
 *   i = (read("fpstatus_top") + index) % modulo;
 *   result = descriptor("st") + {0,1,0,0} * i;
 *  @endcode */
class SgAsmIndirectRegisterExpression: public SgAsmRegisterReferenceExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIndirectRegisterExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "stride", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIndirectRegisterExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIndirectRegisterExpression.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmIndirectRegisterExpression.setDataPrototype(
        "size_t", "modulus", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmIndirectRegisterExpression);
#if defined(SgAsmIndirectRegisterExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmIndirectRegisterExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmIndirectRegisterExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmRegisterReferenceExpression);
        s & BOOST_SERIALIZATION_NVP(p_stride);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        s & BOOST_SERIALIZATION_NVP(p_index);
        s & BOOST_SERIALIZATION_NVP(p_modulus);
        debugSerializationEnd("SgAsmIndirectRegisterExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
   /** Property: Register descriptor stride.
     *
     *  This is the "stride" referred to in the documentation for this class.  This is not an actual register. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RegisterDescriptor const& get_stride() const;
    void set_stride(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */

public:
    /** Property: Register descriptor offset.
     *
     *  This is the "offset" referred to in the documentation for this class. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RegisterDescriptor const& get_offset() const;
    void set_offset(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */

public:
    /** Property: Register descriptor index.
     *
     *  This is the "index" referred to in the documentation for this class. 
     *  
     *  @{ */
    size_t const& get_index() const;
    void set_index(size_t const&);
    /** @} */

public:
    /** Property: Register descriptor modulus.
     *
     *  This is the "modulus" referred to in the documentation for this class. 
     *  
     *  @{ */
    size_t const& get_modulus() const;
    void set_modulus(size_t const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmIndirectRegisterExpression();

public:
    /** Default constructor. */
    SgAsmIndirectRegisterExpression();

public:
    /** Constructor. */
    SgAsmIndirectRegisterExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor,
                                    Rose::BinaryAnalysis::RegisterDescriptor const& stride,
                                    Rose::BinaryAnalysis::RegisterDescriptor const& offset,
                                    size_t const& index,
                                    size_t const& modulus);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIndirectRegisterExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericSymbolList);
IS_SERIALIZABLE(AsmGenericSymbolList);

#ifndef DOCUMENTATION
AsmGenericSymbolList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericSymbolList);
#if defined(SgAsmGenericSymbolList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmGenericSymbolList_HEADERS

#ifdef DOCUMENTATION
/** Node to hold a list of symbol node pointers.
 *
 *  The only reason this node exists is because a ROSETTA limitation prevents us from storing the list directly in the nodes that
 *  need it. */
class SgAsmGenericSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbolList.setDataPrototype(
        "SgAsmGenericSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericSymbolList);
#if defined(SgAsmGenericSymbolList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericSymbolList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericSymbolList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmGenericSymbolList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of symbol nodes. 
     * 
     * @{ */
    SgAsmGenericSymbolPtrList const& get_symbols() const;
    SgAsmGenericSymbolPtrList& get_symbols();
    void set_symbols(SgAsmGenericSymbolPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmGenericSymbolList();

public:
    /** Default constructor. */
    SgAsmGenericSymbolList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSymbolList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSectionList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericSectionList);
IS_SERIALIZABLE(AsmGenericSectionList);

#ifndef DOCUMENTATION
AsmGenericSectionList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericSectionList);
#if defined(SgAsmGenericSectionList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmGenericSectionList_HEADERS

#ifdef DOCUMENTATION
/** List of pointers to file sections.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being stored directly in the
 *  nodes that need it. */
class SgAsmGenericSectionList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSectionList.setDataPrototype(
        "SgAsmGenericSectionPtrList", "sections", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericSectionList);
#if defined(SgAsmGenericSectionList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericSectionList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericSectionList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_sections);
        debugSerializationEnd("SgAsmGenericSectionList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of section pointers. 
     * 
     * @{ */
    SgAsmGenericSectionPtrList const& get_sections() const;
    SgAsmGenericSectionPtrList& get_sections();
    void set_sections(SgAsmGenericSectionPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmGenericSectionList();

public:
    /** Default constructor. */
    SgAsmGenericSectionList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSectionList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericHeaderList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericHeaderList);
IS_SERIALIZABLE(AsmGenericHeaderList);

#ifndef DOCUMENTATION
AsmGenericHeaderList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericHeaderList);
#if defined(SgAsmGenericHeaderList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmGenericHeaderList_HEADERS

#ifdef DOCUMENTATION
/** List of generic file headers.
 *
 *  The only purpose of this AST node is to hold a list of pointers which cannot be contained directly in other nodes
 *  because of ROSETTA limitations. */
class SgAsmGenericHeaderList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeaderList.setDataPrototype(
        "SgAsmGenericHeaderPtrList", "headers", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericHeaderList);
#if defined(SgAsmGenericHeaderList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericHeaderList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericHeaderList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_headers);
        debugSerializationEnd("SgAsmGenericHeaderList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of file header nodes. 
     * 
     * @{ */
    SgAsmGenericHeaderPtrList const& get_headers() const;
    SgAsmGenericHeaderPtrList& get_headers();
    void set_headers(SgAsmGenericHeaderPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmGenericHeaderList();

public:
    /** Default constructor. */
    SgAsmGenericHeaderList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericHeaderList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFormat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericFormat);
IS_SERIALIZABLE(AsmGenericFormat);

#ifndef DOCUMENTATION
AsmGenericFormat.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericFormat);
#if defined(SgAsmGenericFormat_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmGenericFormat_HEADERS

#ifdef DOCUMENTATION
/** Basic information about an executable container. */
class SgAsmGenericFormat: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecFamily", "family", "= SgAsmGenericFormat::FAMILY_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecPurpose", "purpose", "= SgAsmGenericFormat::PURPOSE_EXECUTABLE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "Rose::BinaryAnalysis::ByteOrder::Endianness", "sex", "= Rose::BinaryAnalysis::ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "unsigned", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "bool", "isCurrentVersion", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecABI", "abi", "= SgAsmGenericFormat::ABI_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "unsigned", "abiVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFormat.setDataPrototype(
        "size_t", "wordSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericFormat);
#if defined(SgAsmGenericFormat_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericFormat -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericFormat");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_family);
        s & BOOST_SERIALIZATION_NVP(p_purpose);
        s & BOOST_SERIALIZATION_NVP(p_sex);
        s & BOOST_SERIALIZATION_NVP(p_version);
        s & BOOST_SERIALIZATION_NVP(p_isCurrentVersion);
        s & BOOST_SERIALIZATION_NVP(p_abi);
        s & BOOST_SERIALIZATION_NVP(p_abiVersion);
        s & BOOST_SERIALIZATION_NVP(p_wordSize);
        debugSerializationEnd("SgAsmGenericFormat");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Family. 
     * 
     * @{ */
    SgAsmGenericFormat::ExecFamily const& get_family() const;
    void set_family(SgAsmGenericFormat::ExecFamily const&);
    /** @} */

public:
    /** Property: Purpose. 
     * 
     * @{ */
    SgAsmGenericFormat::ExecPurpose const& get_purpose() const;
    void set_purpose(SgAsmGenericFormat::ExecPurpose const&);
    /** @} */

public:
    /** Property: Byte order. 
     * 
     * @{ */
    Rose::BinaryAnalysis::ByteOrder::Endianness const& get_sex() const;
    void set_sex(Rose::BinaryAnalysis::ByteOrder::Endianness const&);
    /** @} */

public:
    /** Property: File format version number. 
     * 
     * @{ */
    unsigned const& get_version() const;
    void set_version(unsigned const&);
    /** @} */

public:
    /** Property: Whether version is considered current.
     *
     *  True if the @ref version property is considered to be the current, supported version for this file
     *  format. 
     *  
     *  @{ */
    bool const& get_isCurrentVersion() const;
    void set_isCurrentVersion(bool const&);
    /** @} */

public:
    /** Property: Application binary interface. 
     * 
     * @{ */
    SgAsmGenericFormat::ExecABI const& get_abi() const;
    void set_abi(SgAsmGenericFormat::ExecABI const&);
    /** @} */

public:
    /** Property: Application binary interface version. 
     * 
     * @{ */
    unsigned const& get_abiVersion() const;
    void set_abiVersion(unsigned const&);
    /** @} */

public:
    /** Property: Natural word size in bytes. 
     * 
     * @{ */
    size_t const& get_wordSize() const;
    void set_wordSize(size_t const&);
    /** @} */
public:
    /** Print some debugging info. */
    void dump(FILE*, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool get_is_current_version() const ROSE_DEPRECATED("use get_isCurrentVersion");
    void set_is_current_version(bool) ROSE_DEPRECATED("use set_isCurrentVersion");
    unsigned get_abi_version() const ROSE_DEPRECATED("use get_abiVersion");
    void set_abi_version(unsigned) ROSE_DEPRECATED("use set_abiVersion");
    size_t get_word_size() const ROSE_DEPRECATED("use get_wordSize");
    void set_word_size(size_t) ROSE_DEPRECATED("use set_wordSize");
public:
    /** Destructor. */
    virtual ~SgAsmGenericFormat();

public:
    /** Default constructor. */
    SgAsmGenericFormat();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFormat_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFileList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericFileList);
IS_SERIALIZABLE(AsmGenericFileList);

#ifndef DOCUMENTATION
AsmGenericFileList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericFileList);
#if defined(SgAsmGenericFileList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmGenericFileList_HEADERS

#ifdef DOCUMENTATION
/** List of AST file node pointers.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being contained directly in the nodes
 *  that need it. */
class SgAsmGenericFileList: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFileList.setDataPrototype(
        "SgAsmGenericFilePtrList", "files", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericFileList);
#if defined(SgAsmGenericFileList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericFileList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericFileList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_files);
        debugSerializationEnd("SgAsmGenericFileList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of AST node pointers. 
     * 
     * @{ */
    SgAsmGenericFilePtrList const& get_files() const;
    SgAsmGenericFilePtrList& get_files();
    void set_files(SgAsmGenericFilePtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmGenericFileList();

public:
    /** Default constructor. */
    SgAsmGenericFileList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFileList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericFile);
IS_SERIALIZABLE(AsmGenericFile);

#ifndef DOCUMENTATION
AsmGenericFile.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericFile);
#if defined(SgAsmGenericFile_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/MemoryMap.h>
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>

#include "DataConversion.h"
#include "StatSerializer.h"                         // non-intrusive serialization of struct stat

#ifdef ROSE_SgAsmGenericFile_IMPL
#include <SgAsmDwarfCompilationUnitList.h>
#include <SgAsmGenericSectionList.h>
#include <SgAsmGenericHeaderList.h>
#endif
#endif // SgAsmGenericFile_HEADERS

#ifdef DOCUMENTATION
/** Base class for binary files. */
class SgAsmGenericFile: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "SgAsmDwarfCompilationUnitList*", "dwarfInfo", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "int", "fd", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "struct stat", "sb", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "SgFileContentList", "data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "SgAsmGenericHeaderList*", "headers", "= createAndParent<SgAsmGenericHeaderList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "SgAsmGenericSectionList*", "holes", "= createAndParent<SgAsmGenericSectionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "bool", "truncateZeros", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "bool", "trackingReferences", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "Rose::BinaryAnalysis::AddressIntervalSet", "referencedExtents", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericFile.setDataPrototype(
        "bool", "neuter", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericFile);
#if defined(SgAsmGenericFile_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericFile -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericFile");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_dwarfInfo);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_sb);
        s & BOOST_SERIALIZATION_NVP(p_data);
        s & BOOST_SERIALIZATION_NVP(p_headers);
        s & BOOST_SERIALIZATION_NVP(p_holes);
        s & BOOST_SERIALIZATION_NVP(p_truncateZeros);
        s & BOOST_SERIALIZATION_NVP(p_trackingReferences);
        s & BOOST_SERIALIZATION_NVP(p_referencedExtents);
        s & BOOST_SERIALIZATION_NVP(p_neuter);
        debugSerializationEnd("SgAsmGenericFile");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Section modification functions for @ref shiftExtend. */
    enum AddressSpace {
        ADDRSP_MEMORY = 0x0001,
        ADDRSP_FILE   = 0x0002,
        ADDRSP_ALL    = 0x0003
    };

    /** Elasticity argument for @ref shiftExtend. */
    enum Elasticity {
        ELASTIC_NONE  = 0,                          /**< Nothing is elastic; other parts of space are shifted. */
        ELASTIC_UNREF = 1,                          /**< Unreferenced address space is elastic. */
        ELASTIC_HOLE  = 2                           /**< Unreferenced and "hole" sections are elastic. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: DWARF debugging hiearchy. 
     * 
     * @{ */
    SgAsmDwarfCompilationUnitList* const& get_dwarfInfo() const;
    void set_dwarfInfo(SgAsmDwarfCompilationUnitList* const&);
    /** @} */

public:
    /** Property: Name of file. 
     * 
     * @{ */
    std::string const& get_name() const;
    void set_name(std::string const&);
    /** @} */

public:
    /** Property: Read-only file descriptor.
     *
     *  Negative represents lack of valid file descriptor. 
     *  
     *  @{ */
    int const& get_fd() const;
    void set_fd(int const&);
    /** @} */

public:
    struct stat const& get_sb() const;

public:
    /** Property: Contents of the file. 
     * 
     * @{ */
    SgFileContentList const& get_data() const;
    void set_data(SgFileContentList const&);
    /** @} */

public:
    /** Property: List of all headers in file.
     *
     *  This is stored as a pointer to another node that contains the list due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmGenericHeaderList* const& get_headers() const;
    void set_headers(SgAsmGenericHeaderList* const&);
    /** @} */

public:
    /** Property: Addresses unreferenced during parsing.
     *
     *  This is a pointer to a node that contains a list of pointers to the holes. It is done this way rather than storing
     *  the list directly, because of limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmGenericSectionList* const& get_holes() const;
    void set_holes(SgAsmGenericSectionList* const&);
    /** @} */

public:
    /** Property: Whether to truncate zeros on writes. 
     * 
     * @{ */
    bool const& get_truncateZeros() const;
    void set_truncateZeros(bool const&);
    /** @} */

public:
    /** Property: Whether to track referenced areas during parsing. 
     * 
     * @{ */
    bool const& get_trackingReferences() const;
    void set_trackingReferences(bool const&);
    /** @} */

public:
    /** Property: Addresses referenced during parsing. 
     * 
     * @{ */
    Rose::BinaryAnalysis::AddressIntervalSet const& get_referencedExtents() const;
    void set_referencedExtents(Rose::BinaryAnalysis::AddressIntervalSet const&);
    /** @} */

public:
    /** Property: If set, refuse to unparse file. 
     * 
     * @{ */
    bool const& get_neuter() const;
    void set_neuter(bool const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    mutable Rose::BinaryAnalysis::AddressIntervalSet *p_unreferenced_cache = nullptr;
    DataConverter *p_data_converter = nullptr;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Loads file contents into memory. */
    SgAsmGenericFile* parse(std::string file_name);

    void reallocate();

    /** Mirror image of parsing an executable file.
     *
     *  The result (unless the AST has been modified) should be identical to the original file.  If the file's neuter
     *  property is true, then rather than creating a binary file, the output will contain a note indicating that the
     *  neuter property is set.  This is intended to prevent ASTs that represent malicious binaries from accidently being
     *  used to create the binary. */
    void unparse(std::ostream&) const;

    /** Extend the output file by writing the last byte if it hasn't been written yet. */
    void extendToEof(std::ostream&) const;

    /** Print basic info about the sections of a file. */
    void dump(FILE*) const;

    /** Print text file containing all known information about a binary file.
     *
     *  If in_cwd is set, then the file is created in the current working directory rather than the directory containing
     *  the binary file (the default is to create the file in the current working directory).  If @p ext is non-null then
     *  these characters are added to the end of the binary file name. The default null pointer causes the string ".dump"
     *  to be appended to the file name. */
    void dumpAll(bool in_cwd=true, const char *ext=NULL);

    /** Print text file containing all known information about a binary file. */
    void dumpAll(const std::string& dumpname);

    /** Returns the parts of the file that have never been referenced. */
    const Rose::BinaryAnalysis::AddressIntervalSet& get_unreferencedExtents() const;

    /** Marks part of a file as having been referenced if tracking references. */
    void markReferencedExtent(rose_addr_t start_rva, rose_addr_t size);

    /** Property: Data converter.
     *
     *  Function to encode/decode data as it's transferred to/from disk.  The default is to do no transformation.
     *
     * @{ */
    DataConverter* get_dataConverter() const;
    void set_dataConverter(DataConverter*);
    /** @} */

    /** Returns current size of file based on section with highest ending address. */
    rose_addr_t get_currentSize() const;

    /** Returns original size of file, based on file system. */
    rose_addr_t get_originalSize() const;

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data from the file beginning at the specified byte offset (measured from the beginning
     *  of the file), placing the result in @p dst_buf, and returning the number of bytes read. If the number of bytes read
     *  is less than @p size then one of two things happen: if @p strict is true then an @ref
     *  SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise @p dst_buf is zero padded so that exactly @p
     *  size bytes are always initialized. */
    size_t readContent(rose_addr_t offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data starting at the specified (absolute) virtual address. The @p map specifies how virtual
     *  addresses are mapped to file offsets.  As bytes are read, if we encounter a virtual address that is not mapped we stop
     *  reading and do one of two things: if @p strict is set then a @ref Rose::BinaryAnalysis::MemoryMap::NotMapped exception is
     *  thrown; otherwise the rest of the @p dst_buf is zero filled and the number of bytes read (not filled) is returned. */
    size_t readContent(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, void *dst_buf,
                       rose_addr_t size, bool strict=true);

    /** Reads a string from a file.
     *
     *  Returns the string stored at the specified (absolute) virtual address. The returned string contains the bytes beginning at
     *  the starting virtual address and continuing until we reach a NUL byte or an address which is not mapped. If we reach an
     *  address which is not mapped then one of two things happen: if @p strict is set then a @ref
     *  Rose::BinaryAnalysis::MemoryMap::NotMapped exception is thrown; otherwise the string is simply terminated. The returned
     *  string does not include the NUL byte. */
    std::string readContentString(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, bool strict=true);

    /** Reads a string from a file.
     *
     *  Returns the NUL-terminated string stored at the specified relative virtual address. The returned string contains
     *  the bytes beginning at the specified starting file offset and continuing until we reach a NUL byte or an invalid
     *  file offset. If we reach an invalid file offset one of two things happen: if @p strict is set (the default) then an
     *  @ref SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise the string is simply terminated. The
     *  returned string does not include the NUL byte. */
    std::string readContentString(rose_addr_t abs_offset, bool strict=true);

    /** Property: Entire file contents. */
    const SgFileContentList& content() { return p_data; }

    /** Returns a vector that points to part of the file.
     *
     *  Returns a vector that points to part of the file content without actually ever reading or otherwise referencing the
     *  file content until the vector elements are referenced. If the desired extent falls entirely or partially outside
     *  the range of data known to the file then throw an @ref SgAsmExecutableFileFormat::ShortRead exception. This
     *  function never updates reference tracking lists for the file. */
    SgFileContentList content(rose_addr_t offset, rose_addr_t size);

    /** Returns list of all sections in the file that are memory mapped, including headers and holes. */
    SgAsmGenericSectionPtrList get_mappedSections() const;

    /** Returns list of all sections in the file (including headers, holes, etc). */
    SgAsmGenericSectionPtrList get_sections(bool include_holes=true) const;

    /** Returns sections having specified ID across all headers, including headers and holes. */
    SgAsmGenericSectionPtrList get_sectionsById(int id) const;

    /** Returns all sections having specified name across all headers, including headers and holes. */
    SgAsmGenericSectionPtrList get_sectionsByName(std::string, char sep='\0') const;

    /** Find sections by their offset.
     *
     *  Returns all sections that contain all of the specified portion of the file across all headers, including headers
     *  and holes. */
    SgAsmGenericSectionPtrList get_sectionsByOffset(rose_addr_t offset, rose_addr_t size) const;

    /** Find sections by address.
     *
     *  Returns all sections that are mapped to include the specified relative virtual address across all headers,
     *  including headers and holes. This uses the preferred mapping of the section rather than the actual mapping. */
    SgAsmGenericSectionPtrList get_sectionsByRva(rose_addr_t rva) const;

    /** Find sections by address.
     *
     *  Returns all sections that are mapped to include the specified virtual address across all headers, including headers
     *  and holes. This uses the preferred mapping rather than the actual mapping. */
    SgAsmGenericSectionPtrList get_sectionsByVa(rose_addr_t va) const;

    /** Find section with specified ID.
     *
     *  Returns the pointer to section with the specified ID across all headers only if there's exactly one match. Headers
     *  and holes are included in the results. */
    SgAsmGenericSection *get_sectionById(int id, size_t *nfound=0) const;

    /** Find section by name.
     *
     *  Returns pointer to the section with the specified name, or NULL if there isn't exactly one match. Any characters in
     *  the name after the first occurrence of SEP are ignored (default is NUL). For instance, if sep=='$' then the
     *  following names are all equivalent: .idata, .idata$, and .idata$1 */
    SgAsmGenericSection *get_sectionByName(const std::string&, char sep=0, size_t *nfound=0) const;

    /** Find section by file offset.
     *
     *  Returns single section that contains all of the specified portion of the file across all headers, including headers
     *  and holes. */
    SgAsmGenericSection *get_sectionByOffset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Returns single section that is mapped to include the specified relative virtual file address across all headers,
     *  including headers and holes. */
    SgAsmGenericSection *get_sectionByRva(rose_addr_t rva, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Returns single section that is mapped to include the specified virtual address across all headers. See also
     *  @ref get_bestSectionByVa. */
    SgAsmGenericSection *get_sectionByVa(rose_addr_t va, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Similar to @ref get_sectionByVa except when more than one section contains the specified virtual address this
     *  choose the "best" one. All candidates must map the virtual address to the same file address or else we fail (return
     *  null and number of candidates). See @ref bestSectionByVa for definition of "best". */
    SgAsmGenericSection *get_bestSectionByVa(rose_addr_t va, size_t *nfound=0) const;

    /** Definition for "best".
     *
     *  This is the definition of "best" as used by @ref get_bestSectionByVa and @ref
     *  SgAsmGenericHeader::get_bestSectionByVa.  The specified list of sections is scanned and the best one
     *  containing the specified virtual address is returned.  The operation is equivalent to the successive elimination of
     *  bad sections: first eliminate all sections that do not contain the virtual address.  If more than one remains,
     *  eliminate all but the smallest.  If two or more are tied in size and at least one has a name, eliminate those that
     *  don't have names.  If more than one section remains, return the section that is earliest in the specified list of
     *  sections.  Return the null pointer if no section contains the specified virtual address, or if any two sections
     *  that contain the virtual address map it to different parts of the underlying binary file. */
    static SgAsmGenericSection *bestSectionByVa(const SgAsmGenericSectionPtrList &sections, rose_addr_t va);

    /** Moves and enlarges a section.
     *
     *  Shifts (to a higher offset) and/or enlarges the specified section, S, taking all other sections into account. The
     *  positions of sections are based on their preferred virtual mappings rather than the actual mapping.
     *
     *  The neighborhood(S) is S itself and the set of all sections that overlap or are adjacent to the neighborhood of S,
     *  recursively.
     *
     *  The address space can be partitioned into three categories:
     *  @li Section: part of an address space that is referenced by an SgAsmGenericSection other than a "hole" section.
     *  @li Hole:    part of an address space that is referenced only by a "hole" section.
     *  @li Unref:   part of an address space that is not used by any section, including any "hole" section.
     *
     *  The last two categories define parts of the address space that can be optionally elastic--they expand or contract
     *  to take up slack or provide space for neighboring sections. This is controlled by the "elasticity" argument.
     *
     *  Note that when elasticity is ELASTIC_HOLE we simply ignore the "hole" sections, effectively removing their
     *  addresses from the range of addresses under consideration. This avoids complications that arise when a "hole"
     *  overlaps with a real section (due to someone changing offsets in an incompatible manner), but causes the hole
     *  offset and size to remain fixed.  (FIXME RPM 2008-10-20)
     *
     *  When section S is shifted by 'Sa' bytes and/or enlarged by 'Sn' bytes, other sections are affected as follows:
     *  @li Cat L:  Not affected
     *  @li Cat R: Shifted by Sa+Sn if they are in neighborhood(S). Otherwise the amount of shifting depends on the size of
     *      the hole right of neighborhood(S).
     *  @li Cat C:  Shifted Sa and enlarged Sn.
     *  @li Cat O:  If starting address are the same: Shifted Sa. If starting address not equal: Englarged Sa+Sn
     *  @li Cat I:  Shifted Sa, not enlarged
     *  @li Cat B:  Not shifted, but enlarged Sn
     *  @li Cat E:  Shifted Sa and enlarged Sn
     *
     *  Generally speaking, the AddressSpace argument should be SgAsmGenericFile::ADDRSP_ALL in order to adjust both file
     *  and memory offsets and sizes in a consistent manner.
     *
     *  To change the address and/or size of S without regard to other sections in the same file, use set_offset() and
     *  set_size() (for file address space) or set_mapped_preferred_rva() and set_mapped_size() (for memory address
     *  space).
     *
     * @{ */
    void shiftExtend(SgAsmGenericSection*, rose_addr_t sa, rose_addr_t sn, AddressSpace, Elasticity);
    void shiftExtend(SgAsmGenericSection *s, rose_addr_t sa, rose_addr_t sn);
    /** @} */

    /** File offset of next section.
     *
     *  Given a file address, return the file offset of the following section.  If there is no following section then
     *  return an address of -1 (when signed) */
    rose_addr_t get_nextSectionOffset(rose_addr_t offset);

    /** Adds a new hole to the file.
     *
     *  This is called implicitly by the hole constructor. */
    void addHole(SgAsmGenericSection*);

    /** Removes a hole from the list of holes in a file. */
    void removeHole(SgAsmGenericSection*);

    /** Find holes in file and create sections to fill them.
     *
     *  Synthesizes "hole" sections to describe the parts of the file that are not yet referenced by other sections.  Note
     *  that holes are used to represent parts of the original file data, before sections were modified by walking the AST
     *  (at this time it is not possible to create a hole outside the original file content). */
    void fillHoles();

    /** Deletes "hole" sections.
     *
     *  Undoes what @ref fillHoles did. */
    void unfillHoles();

    /** Adds a new header to the file.
     *
     *  This is called implicitly by the header constructor */
    void addHeader(SgAsmGenericHeader*);

    /** Removes a header from the header list in a file. */
    void removeHeader(SgAsmGenericHeader*);

    /** Returns the header for the specified format. */
    SgAsmGenericHeader *get_header(SgAsmExecutableFileFormat::ExecFamily);

    /** Return a string describing the file format.
     *
     *  This uses the last header so that files like PE, NE, LE, LX, etc. which also have a DOS header report the format of
     *  the second (PE, etc.) header rather than the DOS header. */
    const char *formatName() const;

protected:
    // Some extra clean-up actions on destruction
    virtual void destructorHelper() override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmDwarfCompilationUnitList* get_dwarf_info() const ROSE_DEPRECATED("use get_dwarfInfo");
    void set_dwarf_info(SgAsmDwarfCompilationUnitList*) ROSE_DEPRECATED("use set_dwarfInfo");
    bool get_truncate_zeros() const ROSE_DEPRECATED("use get_truncateZeros");
    void set_truncate_zeros(bool) ROSE_DEPRECATED("use set_truncateZeros");
    bool get_tracking_references() const ROSE_DEPRECATED("use get_trackingReferences");
    void set_tracking_references(bool) ROSE_DEPRECATED("use set_trackingReferences");
    const Rose::BinaryAnalysis::AddressIntervalSet& get_referenced_extents() const ROSE_DEPRECATED("use get_referencedExtents");
    void set_referenced_extents(const Rose::BinaryAnalysis::AddressIntervalSet&) ROSE_DEPRECATED("use set_referencedExtents");
    void extend_to_eof(std::ostream&) const ROSE_DEPRECATED("use extendToEof");
    void dump_all(bool in_cwd=true, const char *ext=NULL) ROSE_DEPRECATED("use dumpAll");
    void dump_all(const std::string& dumpname) ROSE_DEPRECATED("use dumpAll");
    const Rose::BinaryAnalysis::AddressIntervalSet& get_unreferenced_extents() const ROSE_DEPRECATED("use get_unreferencedExtents");
    void mark_referenced_extent(rose_addr_t, rose_addr_t) ROSE_DEPRECATED("use markReferencedExtent");
    DataConverter* get_data_converter() const ROSE_DEPRECATED("use get_dataConverter");
    void set_data_converter(DataConverter*) ROSE_DEPRECATED("use set_dataConverter");
    rose_addr_t get_current_size() const ROSE_DEPRECATED("use get_currentSize");
    rose_addr_t get_orig_size() const ROSE_DEPRECATED("use get_originalSize");
    size_t read_content(rose_addr_t, void*, rose_addr_t, bool=true) ROSE_DEPRECATED("use readContent");
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t, void*, rose_addr_t, bool=true)
        ROSE_DEPRECATED("use readContent");
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t, bool=true)
        ROSE_DEPRECATED("use readContentString");
    std::string read_content_str(rose_addr_t, bool=true) ROSE_DEPRECATED("use readContentString");
    SgAsmGenericSectionPtrList get_mapped_sections() const ROSE_DEPRECATED("use get_mappedSections");
    SgAsmGenericSectionPtrList get_sections_by_id(int id) const ROSE_DEPRECATED("use get_sectionById");
    SgAsmGenericSectionPtrList get_sections_by_name(std::string, char='\0') const ROSE_DEPRECATED("use get_sectionsByName");
    SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t, rose_addr_t) const ROSE_DEPRECATED("use get_sectionsByOffset");
    SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t) const ROSE_DEPRECATED("use get_sectionsByRva");
    SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t) const ROSE_DEPRECATED("use get_sectionsByVa");
    SgAsmGenericSection *get_section_by_id(int, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionById");
    SgAsmGenericSection *get_section_by_name(const std::string&, char=0, size_t* = nullptr) const
        ROSE_DEPRECATED("use get_sectionByName");
    SgAsmGenericSection *get_section_by_offset(rose_addr_t, rose_addr_t, size_t* = nullptr) const
        ROSE_DEPRECATED("use get_sectionByOffset");
    SgAsmGenericSection *get_section_by_rva(rose_addr_t, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionByRva");
    SgAsmGenericSection *get_section_by_va(rose_addr_t, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionByVa");
    SgAsmGenericSection *get_best_section_by_va(rose_addr_t, size_t* = nullptr) const ROSE_DEPRECATED("use get_bestSectionByVa");
    static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList&, rose_addr_t)
        ROSE_DEPRECATED("use bestSectionByVa");
    void shift_extend(SgAsmGenericSection*, rose_addr_t, rose_addr_t, AddressSpace, Elasticity) ROSE_DEPRECATED("use shiftExtend");
    void shift_extend(SgAsmGenericSection*, rose_addr_t, rose_addr_t) ROSE_DEPRECATED("use shiftExtend");
    rose_addr_t get_next_section_offset(rose_addr_t) ROSE_DEPRECATED("use get_nextSectionOffset");
    void add_hole(SgAsmGenericSection*) ROSE_DEPRECATED("use addHole");
    void remove_hole(SgAsmGenericSection*) ROSE_DEPRECATED("use remoeHole");
    void fill_holes() ROSE_DEPRECATED("use fillHoles");
    void unfill_holes() ROSE_DEPRECATED("use unfillHoles");
    void add_header(SgAsmGenericHeader*) ROSE_DEPRECATED("use addHeader");
    void remove_header(SgAsmGenericHeader*) ROSE_DEPRECATED("use removeHeader");
    const char *format_name() const ROSE_DEPRECATED("use formatName");
public:
    /** Destructor. */
    virtual ~SgAsmGenericFile();

public:
    /** Default constructor. */
    SgAsmGenericFile();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFile_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericDLLList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericDLLList);
IS_SERIALIZABLE(AsmGenericDLLList);

#ifndef DOCUMENTATION
AsmGenericDLLList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericDLLList);
#if defined(SgAsmGenericDLLList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmGenericDLLList_HEADERS

#ifdef DOCUMENTATION
/** List of pointers to other nodes.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being included directly in the nodes
 *  that need the list. */
class SgAsmGenericDLLList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericDLLList.setDataPrototype(
        "SgAsmGenericDLLPtrList", "dlls", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericDLLList);
#if defined(SgAsmGenericDLLList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericDLLList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericDLLList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_dlls);
        debugSerializationEnd("SgAsmGenericDLLList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of AST node pointers. 
     * 
     * @{ */
    SgAsmGenericDLLPtrList const& get_dlls() const;
    SgAsmGenericDLLPtrList& get_dlls();
    void set_dlls(SgAsmGenericDLLPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmGenericDLLList();

public:
    /** Default constructor. */
    SgAsmGenericDLLList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericDLLList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericDLL           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmGenericDLL);
IS_SERIALIZABLE(AsmGenericDLL);

#ifndef DOCUMENTATION
AsmGenericDLL.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericDLL);
#if defined(SgAsmGenericDLL_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>

#ifdef ROSE_SgAsmGenericDLL_IMPL
#include <SgAsmBasicString.h>
#endif
#endif // SgAsmGenericDLL_HEADERS

#ifdef DOCUMENTATION
/** Base class for dynamically linked library information. */
class SgAsmGenericDLL: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericDLL.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericDLL.setDataPrototype(
        "SgStringList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericDLL);
#if defined(SgAsmGenericDLL_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericDLL -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericDLL");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmGenericDLL");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Name.
     *
     * @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString *s);
    /** @} */
public:
    /** Property: Symbols. 
     * 
     * @{ */
    SgStringList const& get_symbols() const;
    void set_symbols(SgStringList const&);
    /** @} */
public:
    /** Constructor that initializes the name. */
    explicit SgAsmGenericDLL(SgAsmGenericString *s);

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Add a needed symbol to the import list for this DLL. */
    void addSymbol(const std::string&);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void add_symbol(const std::string&) ROSE_DEPRECATED("use addSymbol");
public:
    /** Destructor. */
    virtual ~SgAsmGenericDLL();

public:
    /** Default constructor. */
    SgAsmGenericDLL();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericDLL_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFunction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmFunction);
IS_SERIALIZABLE(AsmFunction);

#ifndef DOCUMENTATION
AsmFunction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmFunction);
#if defined(SgAsmFunction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>
#include <sageContainer.h>

#ifdef ROSE_SgAsmFunction_IMPL
#include <SgAsmInstruction.h>
#endif
#endif // SgAsmFunction_HEADERS

#ifdef DOCUMENTATION
/** Represents a synthesized function.
 *
 *  A function is a collection of blocks holding instructions (basic blocks) or static data.  Instructions might have
 *  references to addresses or data which are described by symbols (not to be confused with the binary's symbol table) in
 *  the function's symbol table (@ref symbolTable property).  Functions do not explicitly exist in a binary, but are
 *  synthesized by ROSE as part of the disassembly and partitioning steps. The individual instructions and/or individual
 *  static data areas need not cover a contiguous region of the address space.  Some synthesized functions will likely not
 *  be a "function" or "produceure" in the strict sense of those words due to such factors as compiler optimizations,
 *  hand-coded routines, exception handling, non-local branching, shortcomings of ROSE's partitioning solvers, etc. In any
 *  case, each function will have one primary entry address.  Although the AST requires that every function have its own
 *  basic block children, which have their own instructions (definition of "tree" data structures), logically two functions
 *  might share basic blocks, although this is uncommon.
 *
 *  Warning: Although currently basic blocks are direct children of function nodes in the AST, this may change in a future
 *  version of ROSE as new node types are introduced to describe scopes and control structures. */
class SgAsmFunction: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "unsigned", "reason", "= SgAsmFunction::FUNC_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "std::string", "reasonComment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "SgAsmFunction::function_kind_enum", "functionKind", "= SgAsmFunction::e_unknown",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "SgAsmFunction::MayReturn", "mayReturn", "= SgAsmFunction::RET_UNKNOWN",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "std::string", "nameMd5", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "SgAsmStatementPtrList", "statementList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "SgAsmStatementPtrList", "dest", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "rose_addr_t", "entryVa", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "SgSymbolTable*", "symbolTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "size_t", "cachedVertex", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "int64_t", "stackDelta", "= SgAsmInstruction::INVALID_STACK_DELTA",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFunction.setDataPrototype(
        "std::string", "callingConvention", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmFunction);
#if defined(SgAsmFunction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmFunction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmFunction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_reason);
        s & BOOST_SERIALIZATION_NVP(p_reasonComment);
        s & BOOST_SERIALIZATION_NVP(p_functionKind);
        s & BOOST_SERIALIZATION_NVP(p_mayReturn);
        s & BOOST_SERIALIZATION_NVP(p_nameMd5);
        s & BOOST_SERIALIZATION_NVP(p_statementList);
        s & BOOST_SERIALIZATION_NVP(p_dest);
        s & BOOST_SERIALIZATION_NVP(p_entryVa);
        s & BOOST_SERIALIZATION_NVP(p_cachedVertex);
        s & BOOST_SERIALIZATION_NVP(p_stackDelta);
        s & BOOST_SERIALIZATION_NVP(p_callingConvention);
        debugSerializationEnd("SgAsmFunction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Whether a function returns. */
    enum MayReturn {
            RET_UNKNOWN,                    /**< It is unknown whether this function ever returns or not. */
            RET_NEVER,                      /**< This function is known to never return. */
            RET_SOMETIMES,                  /**< This function may return or not, depending on how it is called. */
            RET_ALWAYS                      /**< This function returns each time it is called. */
    };

    /** Reasons why an instruction might be considered the beginning of a function. These bit flags are also used by
     *  the instruction partitioner (Partitioner class) to determine what heuristics are used when partitioning
     *  instructions into functions. */
    enum FunctionReason {
            // NOTE: If you add more here, then fix Partitioner::parse_switches()
            //       Also fix SgAsmFunction::reason_key()
            FUNC_NONE        = 0x00000000,  /**< Used for initialization; not a bit flag. */
            FUNC_THUNK_TARGET= 0x00004000,  /**< Function is the target of a thunk. */
            FUNC_EXCEPTION_HANDLER
                             = 0x00008000,  /**< Function for handling an exception. */
            FUNC_ENTRY_POINT = 0x00010000,  /**< An entry point specified in the file header. */
            FUNC_CALL_TARGET = 0x00020000,  /**< Target of a function call instruction sequence in the CFG. When used as
                                             *   a partitioning heuristic, the partitioner will create new functions when
                                             *   it discovers a call-like sequence while traversing the CFG. */
            FUNC_CALL_INSN   = 0x00040000,  /**< Target of call, possibly not in the CFG (see Partitioner::mark_call_insns).
                                             *   When used as a partitioning heuristic, the partitioner will search all
                                             *   available instructions for instances of call-like instructions and define
                                             *   a function for each target. The function entry points added in this way
                                             *   become initial nodes of the CFG which is used by some of
                                             *   the other function discovery methods, including FUNC_CALL_TARGET. */
            FUNC_EH_FRAME    = 0x00080000,  /**< Address mentioned in the ELF .eh_frame section. */
            FUNC_SYMBOL      = 0x00100000,  /**< Address of a function symbol in a symbol table. */
            FUNC_PATTERN     = 0x00200000,  /**< Appears to be a function based on pattern of instructions. When used as
                                             *   a partitioning heuristic, the partitioner will search through all available
                                             *   instructions and create function entry points. The function entry points are
                                             *   added to the CFG which is used by some of the other function discovery
                                             *   methods. */
            FUNC_GRAPH       = 0x00400000,  /**< Implied by inter-basicblock branching. When used as a partitioning
                                             *   heuristic, the partitioner creates a new function when it discovers, by
                                             *   CFG traversal, that two different functions branch to a common basic block.
                                             *   The block in common becomes a new function under this rule. */
            FUNC_USERDEF     = 0x00800000,  /**< User-defined algorithm. See Partitioner::addFunctionDetector(). */
            FUNC_PADDING     = 0x01000000,  /**< Created to represent NOP padding between other functions. When used as a
                                             *   partitioning heuristic, the partitioner searches for padding after all
                                             *   CFG-based analysis has completed.  Padding can consist of either NOP
                                             *   instructions or zero bytes. The former requires that instructions at the
                                             *   interfunction addresses have been disassembled. */
            FUNC_DISCONT     = 0x02000000,  /**< Blocks of function are not contiguous in memory. This is not a partitioner
                                             *   heuristic, but rather only an indication of whether the function's basic
                                             *   blocks occupy contiguous memory locations. */
            FUNC_INSNHEAD    = 0x04000000,  /**< Initial instructions not in any other function. (UNUSED?) */
            FUNC_IMPORT      = 0x08000000,  /**< Functions dynamically linked. For ELF containers, these are the entries
                                             *   in the procedure lookup table (PLT). When used as a partitioning heuristic,
                                             *   the partitioner will scan the PLT and define a function for each entry. */
            FUNC_LEFTOVERS   = 0x10000000,  /**< Generated function to hold blocks that are otherwise not part of
                                             *   any function.  If this bit is turned off then the instruction
                                             *   Partitioner will delete instructions that it couldn't assign to
                                             *   a function. */
            FUNC_INTRABLOCK  = 0x20000000,  /**< Function contains basic blocks that were inserted by searching the
                                             *   address space between the blocks discovered by analyzing the control flow.
                                             *   Blocks added by this algorithm do not take control flow into account, and
                                             *   therefore, the global control flow graph (CFG) may have edges into the
                                             *   middle of such blocks, or such blocks may have edges into the middle of
                                             *   other blocks, including inter-function edges.  Also, blocks added by this
                                             *   method might not represent true instructions, but rather data that was
                                             *   disassembled as instructions. */
            FUNC_THUNK       = 0x40000000,  /**< Function is a thunk.  Thunks are small pieces of code whose only purpose
                                             *   is to branch to another function.  Depending on how the disassembler and
                                             *   partitioner are run, a thunk can exist either as its own function or the
                                             *   thunk's instructions will be subsumed by the called function.  The
                                             *   partitioner only sets this flag for functions that are created due to
                                             *   the thunk recognition pass; other functions that don't have this bit set
                                             *   might also be thunks, and functions that have this bit set might not
                                             *   be a thunk.  The Partitioner::is_thunk() method will return true for
                                             *   functions whose content looks like a thunk. */
            FUNC_EXPORT      = 0x80000000,  /**< Exported function. These are the functions that appear in a PE export
                                             *   table. */
            FUNC_DEFAULT     = 0xefff80ff,  /**< Default value for Partitioner class. */

            /*========= Miscellaneous Reasons ===========================================================================
             * The first half of the range (1-127, inclusive) is used for algorithms defined by ROSE.  The second half is
             * availalble for users to use as they see fit. */
            FUNC_MISCMASK    = 0x000000ff,  /**< Miscellaneous.  These are all the other special purpose function detectors
                                             *   that are implemented in the Partitioner. Each one is identified by an
                                             *   eight-bit integer stored in the low order bits.  Only one such reason can
                                             *   be stored at a time.  These are not used to control which partitioning
                                             *   heuristics to use, but rather to indicate which one (of possibly many)
                                             *   that detected the function. */
            FUNC_INTERPADFUNC = 1,          /**< Detected by Partitioner::FindInterPadFunctions, which looks for unassigned
                                             *   space between two inter-function padding blocks and makes the first such
                                             *   address the beginning of one of these functions. */
            FUNC_PESCRAMBLER_DISPATCH = 2, /**<  Dispatcher function for code generated by pescrambler. */
            FUNC_CONFIGURED = 3,           /**<  Function is defined in a configuration file. */
            FUNC_CMDLINE = 4,              /**<  Function mentioned on the command-line. */
            FUNC_SCAN_RO_DATA = 5,         /**<  Address was found in read-only data area by scanning the data. */
            FUNC_INSN_RO_DATA = 6,         /**<  Address was found in read-only data referenced by an existing
                                            *    instruction. */
    };

    /** Constants for the "function_kind" property. */
    enum function_kind_enum {
        e_unknown  = 0,
        e_standard = 1,
        e_library  = 2,
        e_imported = 3,
        e_thunk     = 4,
        e_last
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Name.
     *
     *  The optional string name of a function. 
     *  
     *  @{ */
    std::string const& get_name() const;
    void set_name(std::string const&);
    /** @} */

public:
    /** Property: Reason that function exists.
     *
     *  This is a bit vector of enum constants that describe why this function was created. See @ref
     *  SgAsmFunction::FunctionReason for details. 
     *  
     *  @{ */
    unsigned const& get_reason() const;
    void set_reason(unsigned const&);
    /** @} */

public:
    /** Property: Additional function existance reason comment.
     *
     *  This reason comment gets filled in automatically by certain function analyses. It's a free-form string that
     *  contains additional information about why this function exists and is used in conjunction with the @ref reason
     *  property. 
     *  
     *  @{ */
    std::string const& get_reasonComment() const;
    void set_reasonComment(std::string const&);
    /** @} */

public:
    /** Property: Kind of function.
     *
     *  This enum constant describes the kind of function. See @ref SgAsmFunction::function_kind_enum for details. 
     *  
     *  @{ */
    SgAsmFunction::function_kind_enum const& get_functionKind() const;
    void set_functionKind(SgAsmFunction::function_kind_enum const&);
    /** @} */

public:
    /** Property: Whether a function could return to its caller. 
     * 
     * @{ */
    SgAsmFunction::MayReturn const& get_mayReturn() const;
    void set_mayReturn(SgAsmFunction::MayReturn const&);
    /** @} */

public:
    /** Property: Hash of the function.
     *
     *  This is unused by ROSE, but can be set by users to identify a function by hash string. 
     *  
     *  @{ */
    std::string const& get_nameMd5() const;
    void set_nameMd5(std::string const&);
    /** @} */

public:
    /** Property: Statements that make up a function.
     *
     *  The "statements" of a function are things like instructions, static data blocks, etc. 
     *  
     *  @{ */
    SgAsmStatementPtrList const& get_statementList() const;
    SgAsmStatementPtrList& get_statementList();
    void set_statementList(SgAsmStatementPtrList const&);
    /** @} */
    // FIXME[Robb P Matzke 2017-02-13]: unused?
public:
    SgAsmStatementPtrList const& get_dest() const;
    void set_dest(SgAsmStatementPtrList const&);

public:
    /** Property: Primary entry address.
     *
     *  Every function has one primary entry address that uniquely identifies the function in the AST. This is the starting
     *  address of the function's entry instruction.  The abbreviation "va" means "virtual address". 
     *  
     *  @{ */
    rose_addr_t const& get_entryVa() const;
    void set_entryVa(rose_addr_t const&);
    /** @} */

public:
    /** Property: Symbol table.
     *
     *  A ROSE symbol table associated with this function. This is not the same as the symbol table that appears in the
     *  binary specimen, such as ELF or PE symbol tables. 
     *  
     *  @{ */
    SgSymbolTable* const& get_symbolTable() const;
    void set_symbolTable(SgSymbolTable* const&);
    /** @} */
    // FIXME[Robb P Matzke 2017-02-13]: what is this?
public:
    size_t const& get_cachedVertex() const;
    void set_cachedVertex(size_t const&);

public:
    /** Property: Net effect of function on the stack pointer.
     *
     *  Net effect that this function has on the machine's stack pointer register.  For most x86 Linux ELF specimens the
     *  net effect is to pop the return address from the stack, thus +4 for 32-bit specimens and +8 for 64-bit specimens.
     *
     *  If the stack delta analysis has not run or could not determine a constant stack delta, then the special value @c
     *  SgAsmInstruction::INVALID_STACK_DELTA is used. 
     *  
     *  @{ */
    int64_t const& get_stackDelta() const;
    void set_stackDelta(int64_t const&);
    /** @} */

public:
    /** Property: Primary calling convention.
     *
     *  This is the name of the primary calling convention for this function. When the semantics of the function match
     *  multiple calling convention definitions, this property holds the "best" one for some definition of "best". It is
     *  also possible for the semantics to not match any calling convention definition in which case this property is
     *  empty. It is also empty if the calling convention analysis was not performed. 
     *  
     *  @{ */
    std::string const& get_callingConvention() const;
    void set_callingConvention(std::string const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Adds statement to end of statement list. */
    void appendStatement(SgAsmStatement*);

    /** Erases statement from statement list.
     *
     *  If the specified statement is found in the list of statements then it is erased without being deleted. */
    void removeStatement(SgAsmStatement* statement);

    /** Function entry basic block.
     *
     *  Returns the basic block that represents the function primary entry point. Returns null for a function
     *  that contains no instructions. */
    SgAsmBlock* get_entryBlock() const;

    /** Multi-line description of function reason keys from unparser.
     *
     *  Returns a string that describes what the one-letter function reasons mean in the unparser output. */
    static std::string reasonKey(const std::string &prefix = "");

    /** Returns a very short string describing the reason mask. */
    std::string reasonString(bool pad) const;

    /** Class method that converts a reason bit vector to a human-friendly string.
     *
     *  The second argument is the bit vector of SgAsmFunction::FunctionReason bits. */
    static std::string reasonString(bool pad, unsigned reason);

    /** Selection functor for SgAsmFunction::get_extent(). */
    class NodeSelector {
    public:
            virtual ~NodeSelector() {}
            virtual bool operator()(SgNode*) = 0;
    };

    /** Returns information about the function addresses.
     *
     *  Every non-empty function has a minimum (inclusive) and maximum (exclusive) address which are returned by reference,
     *  but not all functions own all the bytes within that range of addresses. Therefore, the exact bytes are returned by
     *  adding them to the optional ExtentMap argument.  This function returns the number of nodes (instructions and static
     *  data items) in the function.  If the function contains no nodes then @p extents is not modified and the low and
     *  high addresses are both set to zero.
     *
     *  If an @p selector functor is provided, then only nodes for which it returns true are considered part of the
     *  function.  This can be used for such things as filtering out data blocks that are marked as padding.  For example:
     *
     *  @code
     *  class NotPadding: public SgAsmFunction::NodeSelector {
     *  public:
     *      virtual bool operator()(SgNode *node) {
     *          SgAsmStaticData *data = isSgAsmStaticData(node);
     *          SgAsmBlock *block = SageInterface::getEnclosingNode<SgAsmBlock>(data);
     *          return !data || !block || block->get_reason()!=SgAsmBlock::BLK_PADDING;
     *      }
     *  } notPadding;
     *
     *  Rose::BinaryAnalysis::AddressIntervalSet extents;
     *  function->get_extent(&extents, NULL, NULL, &notPadding);
     *  @endcode
     *
     *  Here's another example that calculates the extent of only the padding data, based on the negation of the filter in
     *  the previous example:
     *
     *  @code
     *  class OnlyPadding: public NotPadding {
     *  public:
     *      virtual bool operator()(SgNode *node) {
     *          return !NotPadding::operator()(node);
     *      }
     *  } onlyPadding;
     *
     *  Rose::BinaryAnalysis::AddressIntervalSet extents;
     *  function->get_extent(&extents, NULL, NULL, &onlyPadding);
     *  @endcode */
    size_t get_extent(Rose::BinaryAnalysis::AddressIntervalSet *emap=NULL, rose_addr_t *lo_addr=NULL, rose_addr_t *hi_addr=NULL,
                      NodeSelector *selector=NULL);

    /** Computes the SHA1 message digest for the bytes of a function.
     *
     *  Returns true if the SHA1 is available, false if the message digest cannot be computed because the prerequisite
     *  gcrypt functions are not available. The optional @p selector argument can be used to limit the digest to only
     *  certain nodes of the function; by default, all instructions and static data are accumulated. */
    bool get_sha1(uint8_t digest[20]/*out*/, NodeSelector *selector=NULL);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    function_kind_enum get_function_kind() const ROSE_DEPRECATED("use get_functionKind");
    void set_function_kind(function_kind_enum) ROSE_DEPRECATED("use set_functionKind");
    MayReturn get_may_return() const ROSE_DEPRECATED("use get_mayReturn");
    void set_may_return(MayReturn) ROSE_DEPRECATED("use set_mayReturn");
    const std::string& get_name_md5() const ROSE_DEPRECATED("use get_nameMd5");
    void set_name_md5(const std::string&) ROSE_DEPRECATED("use set_nameMd5");
    rose_addr_t get_entry_va() const ROSE_DEPRECATED("use get_entryVa");
    void set_entry_va(rose_addr_t) ROSE_DEPRECATED("use set_entryVa");
    SgSymbolTable* get_symbol_table() const ROSE_DEPRECATED("use get_symbolTable");
    void set_symbol_table(SgSymbolTable*) ROSE_DEPRECATED("use set_symbolTable");
    size_t get_cached_vertex() const ROSE_DEPRECATED("use get_cachedVertex");
    void set_cached_vertex(size_t) ROSE_DEPRECATED("use set_cachedVertex");
    void append_statement(SgAsmStatement*) ROSE_DEPRECATED("use appendStatement");
    void remove_statement(SgAsmStatement* statement) ROSE_DEPRECATED("use removeStatement");
    SgAsmBlock* get_entry_block() const ROSE_DEPRECATED("use get_entryBlock");
    static std::string reason_key(const std::string &prefix="") ROSE_DEPRECATED("use reasonKey");
    std::string reason_str(bool) const ROSE_DEPRECATED("use reasonString");
    static std::string reason_str(bool, unsigned) ROSE_DEPRECATED("use reasonString");
public:
    /** Destructor. */
    virtual ~SgAsmFunction();

public:
    /** Default constructor. */
    SgAsmFunction();

public:
    /** Constructor. */
    SgAsmFunction(rose_addr_t const& address,
                  std::string const& name,
                  unsigned const& reason,
                  SgAsmFunction::function_kind_enum const& functionKind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFunction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmSynthesizedDeclaration = nonTerminalConstructor(
    "AsmSynthesizedDeclaration",
    *this,
    "AsmSynthesizedDeclaration",
    "AsmSynthesizedDeclarationTag",
    SubclassListBuilder()
        | AsmFunction
        | AsmSynthesizedDataStructureDeclaration
        | AsmSynthesizedFieldDeclaration
    , false);
assert(AsmSynthesizedDeclaration.associatedGrammar != nullptr);
AsmSynthesizedDeclaration.setCppCondition("!defined(DOCUMENTATION)");
AsmSynthesizedDeclaration.isBoostSerializable(true);
AsmSynthesizedDeclaration.setAutomaticGenerationOfConstructor(false);
AsmSynthesizedDeclaration.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmSynthesizedDeclaration.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for synthesized declarations.
 *
 *  A synthesized declaration is one created by ROSE which does not appear in the binary specimen. At one point we
 *  considered adding "synthesized" to all such intities, but later decided against it since most declarations are missing
 *  from binary specimens are are synthesized by ROSE, and would therefore lead to a lot of extra letters in many class
 *  names. */
class SgAsmSynthesizedDeclaration: public SgAsmStatement {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmSynthesizedDeclaration);
#if defined(SgAsmSynthesizedDeclaration_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmSynthesizedDeclaration -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmSynthesizedDeclaration");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
        debugSerializationEnd("SgAsmSynthesizedDeclaration");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedDeclaration();

protected:
    /** Default constructor. */
    SgAsmSynthesizedDeclaration();

protected:
    /** Constructor. */
    explicit SgAsmSynthesizedDeclaration(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedDeclaration_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFloatValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmFloatValueExpression);
IS_SERIALIZABLE(AsmFloatValueExpression);

#ifndef DOCUMENTATION
AsmFloatValueExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Floating-point value.
 *
 *  The bits are stored in the super-class (SgAsmConstantExpression) and interpretted as various kinds of floating-point
 *  values. */
class SgAsmFloatValueExpression: public SgAsmConstantExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmFloatValueExpression);
#if defined(SgAsmFloatValueExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmFloatValueExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmFloatValueExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmConstantExpression);
        s & BOOST_SERIALIZATION_NVP(p_nativeValue);
        s & BOOST_SERIALIZATION_NVP(p_nativeValueIsValid);
        debugSerializationEnd("SgAsmFloatValueExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    // This node stores its primary representation of the value in the p_bitVector of a parent class.  However, since we
    // often access the value as a native "double", and since converting to/from a bit vector is costly, we want to cache
    // the native double value whenever we compute it.  ROSETTA does not need to be aware of the cached value since it can
    // be recomputed from the bit vector, and in fact, ROSETTA can't handle cache data members because it doesn't
    // understand "mutable".
    //
    // However, Rosebud handles this just fine.
private:
    mutable double p_nativeValue;

public:

private:
    mutable bool p_nativeValueIsValid;

public:
public:
    /** Construct specified floating-point value.
     *
     *  Creates a new floating-point constant AST node having the specified native value and type. See also, the
     *  constructor that takes a bit vector as its first argument, which is useful in cases where the native representation
     *  of a floating point value does not match the target machine's representation.
     *
     *  On the other hand, the default constructor creates a new floating-point value of unspecified type initialized to positive
     *  zero.  We recommend using a constructor that takes a @ref SgAsmType argument instead. */
    SgAsmFloatValueExpression(double nativeValue, SgAsmType*);

    /** Construct specified floating-point value.
     *
     *  Creates a new floating-point constant AST node having the specified value and type.  See also, the constructor that
     *  takes a @c double argument for those cases when the native representation matches the target machine's
     *  representation. */
    SgAsmFloatValueExpression(const Sawyer::Container::BitVector&, SgAsmType*);

    /** Set AST node value to specified native value. */
    void set_nativeValue(double);

    /** Get value in native format. */
    double get_nativeValue() const;

    /** Update bit vector from native representation.
     *
     *  Resets the bit vector using the cached native representation.  The bit vector is considered to be the canonical
     *  value of this AST node. */
    void updateBitVector();

    /** Update cached native value from bit vector.
     *
     *  Resets the cached native value from the bit vector. The bit vector is considered to be the canonical value of this
     *  AST node, and the native format value is a cached representation that can be used in arithmetic. */
    void updateNativeValue() const;
public:
    /** Destructor. */
    virtual ~SgAsmFloatValueExpression();

public:
    /** Default constructor. */
    SgAsmFloatValueExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFloatValueExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFloatType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmFloatType);
IS_SERIALIZABLE(AsmFloatType);

#ifndef DOCUMENTATION
AsmFloatType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmFloatType);
#if defined(SgAsmFloatType_HEADERS) || defined(DOCUMENTATION)
#include <Sawyer/BitVector.h>
#include <Rose/BitFlags.h>
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmFloatType_HEADERS

#ifdef DOCUMENTATION
/** Floating point types. */
class SgAsmFloatType: public SgAsmScalarType {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "size_t", "significandOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "size_t", "significandNBits", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "size_t", "signBitOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "size_t", "exponentOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "size_t", "exponentNBits", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "uint64_t", "exponentBias", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmFloatType.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmFloatType);
#if defined(SgAsmFloatType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmFloatType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmFloatType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmScalarType);
        s & BOOST_SERIALIZATION_NVP(p_significandOffset);
        s & BOOST_SERIALIZATION_NVP(p_significandNBits);
        s & BOOST_SERIALIZATION_NVP(p_signBitOffset);
        s & BOOST_SERIALIZATION_NVP(p_exponentOffset);
        s & BOOST_SERIALIZATION_NVP(p_exponentNBits);
        s & BOOST_SERIALIZATION_NVP(p_exponentBias);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        debugSerializationEnd("SgAsmFloatType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Individual bit flags for this floating-point type. */
    enum Flag {
        GRADUAL_UNDERFLOW           = 0x00000001,   /**< De-normalized signifand when exponent field is clear. */
        IMPLICIT_BIT_CONVENTION     = 0x00000002    /**< Use IEEE 754 implicit bit convention for signicand. */
    };

    /** Collective bit flags for this floating-point type. */
    typedef Rose::BitFlags<Flag> Flags;

    /** Range of bits used for various purposes within the values of this type. */
    typedef Sawyer::Container::BitVector::BitRange BitRange;

public:
public:

public:

public:

public:

public:

public:

public:
public:
    /** Construct a new floating-point type. */
    SgAsmFloatType(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits,
                   const BitRange &significandBits, const BitRange exponentBits, size_t signBit,
                   uint64_t exponentBias, Flags flags);

    /** Construct an IEEE 754 floating point type of the specified width.
     *
     * @{ */
    static SgAsmFloatType* instanceIeee32(Rose::BinaryAnalysis::ByteOrder::Endianness);
    static SgAsmFloatType* instanceIeee64(Rose::BinaryAnalysis::ByteOrder::Endianness);
    /** @} */

    /** Property: Offset to significand least significant bit. */
    BitRange significandBits() const;

    /** Property: Number of bits in the exponent. */
    BitRange exponentBits() const;

    /** Property: Offset to significand sign bit. */
    size_t signBit() const;

    /** Property: Zero-point of exponent. */
    uint64_t exponentBias() const;

    /** Property: Bit vector of all boolean properties. */
    Flags flags() const;

    /** Default IEEE 754 flags.
     *
     *  These flags are the most common types and include the implicit bit convention for the significand and the
     *  gradual underflow capability. */
    static Flags ieeeFlags();

    /** Property: Whether type has gradual underflow.
     *
     *  If the type supports gradual underflow, then when the exponent field's bits are all clear then the integer part (a
     *  single bit implied or explicit depending on @ref implicitBitConvention) of the significand is zero instead of
     *  one. */
    bool gradualUnderflow() const;

    /** Property: Whether the type follows the IEEE 754 significand implicit bit convention.
     *
     *  If true, then the leading set bit of the significand is not stored but rather an implied. If the exponent field
     *  contains any non-zero bits then the integer part of the significand is one, otherwise when the exponent field
     *  is all clear the integer part is zero. */
    bool implicitBitConvention() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
public:
    /** Destructor. */
    virtual ~SgAsmFloatType();

public:
    /** Default constructor. */
    SgAsmFloatType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFloatType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmScalarType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmScalarType = nonTerminalConstructor(
    "AsmScalarType",
    *this,
    "AsmScalarType",
    "AsmScalarTypeTag",
    SubclassListBuilder()
        | AsmFloatType
        | AsmIntegerType
        | AsmPointerType
    , false);
assert(AsmScalarType.associatedGrammar != nullptr);
AsmScalarType.setCppCondition("!defined(DOCUMENTATION)");
AsmScalarType.isBoostSerializable(true);
AsmScalarType.setAutomaticGenerationOfConstructor(false);
AsmScalarType.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmScalarType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmScalarType);
#if defined(SgAsmScalarType_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmScalarType_HEADERS

#ifdef DOCUMENTATION
/** Base class for scalar types. */
class SgAsmScalarType: public SgAsmType {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmScalarType.setDataPrototype(
        "Rose::BinaryAnalysis::ByteOrder::Endianness", "minorOrder", "= Rose::BinaryAnalysis::ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmScalarType.setDataPrototype(
        "Rose::BinaryAnalysis::ByteOrder::Endianness", "majorOrder", "= Rose::BinaryAnalysis::ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmScalarType.setDataPrototype(
        "size_t", "majorNBytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmScalarType.setDataPrototype(
        "size_t", "nBits", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmScalarType);
#if defined(SgAsmScalarType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmScalarType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmScalarType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmType);
        s & BOOST_SERIALIZATION_NVP(p_minorOrder);
        s & BOOST_SERIALIZATION_NVP(p_majorOrder);
        s & BOOST_SERIALIZATION_NVP(p_majorNBytes);
        s & BOOST_SERIALIZATION_NVP(p_nBits);
        debugSerializationEnd("SgAsmScalarType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:

public:
    /** Property: Major byte order for mixed-order types. 
     * 
     * @{ */
    /** @} */

public:
    /** Property: Stride of major byte order for mixed order types. 
     * 
     * @{ */
    /** @} */

public:
    /** Property: Number of bits. 
     * 
     * @{ */
    /** @} */
protected:
    /** Construct a new scalar type.
     *
     *  Since scalar types are base classes, one normally does not construct just a scalar type but rather one of the base
     *  classes. */
    SgAsmScalarType(Rose::BinaryAnalysis::ByteOrder::Endianness, size_t nBits);

public:
    /** Property: Number of bits. */
    virtual size_t get_nBits() const override;

    /** Property: Minor byte order. This is the usual notion of byte order. */
    Rose::BinaryAnalysis::ByteOrder::Endianness get_minorOrder() const;

    /** Property: Major byte order for mixed-order types. */
    Rose::BinaryAnalysis::ByteOrder::Endianness get_majorOrder() const;

    /** Property: Stride of major byte order for mixed order types. */
    size_t get_majorNBytes() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
public:
    /** Destructor. */
    virtual ~SgAsmScalarType();

protected:
    /** Default constructor. */
    SgAsmScalarType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmScalarType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmType = nonTerminalConstructor(
    "AsmType",
    *this,
    "AsmType",
    "AsmTypeTag",
    SubclassListBuilder()
        | AsmScalarType
        | AsmVectorType
        | AsmVoidType
    , false);
assert(AsmType.associatedGrammar != nullptr);
AsmType.setCppCondition("!defined(DOCUMENTATION)");
AsmType.isBoostSerializable(true);
AsmType.setAutomaticGenerationOfConstructor(false);
AsmType.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for binary types. */
class SgAsmType: public SgAsmNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmType);
#if defined(SgAsmType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        debugSerializationEnd("SgAsmType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    static Sawyer::Container::Map<std::string, SgAsmType*> p_typeRegistry;

public:
    /** Validate properties collectively.
     *
     *  This method collectively validates the properties of a type since validation is not always possible or convenient
     *  when the user modifies an individual property.  For instance, when changing the bit fields in a floating-point
     *  type, it would be very inconvenient to the user if those properties individually validated there settings because
     *  it would require the user to shuffle fields around in such a way that they never overlap. This way, the overlap
     *  validation can occur after the user is all done moving the fields. */
    virtual void check() const;

    /** Convert a type to a string.
     *
     *  The output is intended mostly for debugging since it contains more details than what would be typically useful. For
     *  instance, instead of the word "double", this will probably print all the details about where the various
     *  floating-point fields are located, how the exponent field works, etc. */
    virtual std::string toString() const {
        abort();                                    // ROSETTA limitation: intended pure virtual
        return NULL;                                // Windows limitation: return value required [Too, 2014-08-11]
    }

    /** Width of type in bits. */
    virtual size_t get_nBits() const {
        abort();                                    // ROSETTA limitation: intended pure virtual
        return (size_t)-1;                          // Windows limitation: return value required [Too, 2014-08-11]
    }

    /** Width of type in bytes. */
    virtual size_t get_nBytes() const;

    /** Registers a type with the type system.
     *
     *  This method registers the specified type by its @ref toString value so it can be found later.  If a type by the
     *  same name is already registered then the specified one is deleted.  The return value is the type that is ultimately
     *  in the registry (either one that existed their previously or the specified type). */
    template<class Type>                                    // Type is a subclass of SgAsmType
    static Type* registerOrDelete(Type *toInsert) {
        ASSERT_not_null(toInsert);
        std::string key = toInsert->toString();
        Type *retval = dynamic_cast<Type*>(p_typeRegistry.insertMaybe(key, toInsert));
        ASSERT_not_null(retval);
        if (retval!=toInsert)
            delete toInsert;
        return retval;
    }
public:
    /** Destructor. */
    virtual ~SgAsmType();

protected:
    /** Default constructor. */
    SgAsmType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExprListExp           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmExprListExp);
IS_SERIALIZABLE(AsmExprListExp);

#ifndef DOCUMENTATION
AsmExprListExp.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmExprListExp);
#if defined(SgAsmExprListExp_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmExprListExp_HEADERS

#ifdef DOCUMENTATION
/** List of expression nodes. */
class SgAsmExprListExp: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmExprListExp.setDataPrototype(
        "SgAsmExpressionPtrList", "expressions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmExprListExp);
#if defined(SgAsmExprListExp_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmExprListExp -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmExprListExp");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_expressions);
        debugSerializationEnd("SgAsmExprListExp");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Pointers to expressions.
     *
     *  List of expression nodes are stored in their own @ref SgAsmExprListExp node instead of in parent AST nodes due to
     *  limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmExpressionPtrList const& get_expressions() const;
    SgAsmExpressionPtrList& get_expressions();
    void set_expressions(SgAsmExpressionPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmExprListExp();

public:
    /** Default constructor. */
    SgAsmExprListExp();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExprListExp_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverSection);
IS_SERIALIZABLE(AsmElfSymverSection);

#ifndef DOCUMENTATION
AsmElfSymverSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverSection);
#if defined(SgAsmElfSymverSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfSymverSection_IMPL
#include <SgAsmElfSymverEntryList.h>
#endif
#endif // SgAsmElfSymverSection_HEADERS

#ifdef DOCUMENTATION
/** The ELF symbol version table.
 *
 *  Often named ".gnu.version section", this section points to an @ref SgAsmElfSymverEntryList containing a list of
 *  SgAsmElfSymverEntry objects. */
class SgAsmElfSymverSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverSection.setDataPrototype(
        "SgAsmElfSymverEntryList*", "entries", "= createAndParent<SgAsmElfSymverEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverSection);
#if defined(SgAsmElfSymverSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of table entries.
     *
     *  The list of entries in this section. The only reason the list is stored in a separate AST node instead of being
     *  stored here directly is due to ROSETTA limitations. 
     *  
     *  @{ */
    SgAsmElfSymverEntryList* const& get_entries() const;
    void set_entries(SgAsmElfSymverEntryList* const&);
    /** @} */
public:
    /** Construct section and link it into the AST. */
    explicit SgAsmElfSymverSection(SgAsmElfFileHeader*);

    /** Initializes section by parsing the file. */
    virtual SgAsmElfSymverSection* parse() override;

    using SgAsmElfSection::calculateSizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write symver table sections back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    using SgAsmElfSection::calculate_sizes;
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverSection();

public:
    /** Default constructor. */
    SgAsmElfSymverSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverNeededSection);
IS_SERIALIZABLE(AsmElfSymverNeededSection);

#ifndef DOCUMENTATION
AsmElfSymverNeededSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverNeededSection);
#if defined(SgAsmElfSymverNeededSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfSymverNeededSection_IMPL
#include <SgAsmElfSymverNeededEntryList.h>
#endif
#endif // SgAsmElfSymverNeededSection_HEADERS

#ifdef DOCUMENTATION
/** GNU symbol version requirements table.
 *
 *  This section is usually named ".gnu.version_r".  The format of this table is similar to the GNU Symbol Version
 *  Definitions Table, namey that the table object (@ref SgAsmElfSymverNeededSection) points to a list of entries (@ref
 *  SgAsmElfSymverNeededEntry), which of which point to a list of auxilliary information (@ref SgAsmElfSymverNeededAux). */
class SgAsmElfSymverNeededSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededSection.setDataPrototype(
        "SgAsmElfSymverNeededEntryList*", "entries", "= createAndParent<SgAsmElfSymverNeededEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverNeededSection);
#if defined(SgAsmElfSymverNeededSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverNeededSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverNeededSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverNeededSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries.
     *
     *  This property points to an AST node whose only purpose is to hold the list of entries. The only reason the entries
     *  are not contained directly in this node where they're needed is due to ROSETTA limitations. 
     *  
     *  @{ */
    SgAsmElfSymverNeededEntryList* const& get_entries() const;
    void set_entries(SgAsmElfSymverNeededEntryList* const&);
    /** @} */
public:
    /** Constructor that links objec into AST.
     *
     *  This constructor adds this entry to the specified GNU Symbol Version Requirements Table. */
    SgAsmElfSymverNeededSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Parse a GNU Symbol Version Requirements Table.
     *
     *  The layout of this table is very similar to the layout of the GNU Symbol Version Definition Table and users should
     *  refer to @ref SgAsmElfSymverDefinedSection::parse for details.  Different data structures are used between the
     *  Definition and Requirements tables:
     *
     *  @li @ref SgAsmElfSymverNeededSection corresponds to SgAsmElfSymverDefinedSection.
     *  @li @ref SgAsmElfSymverNeededEntry corresponds to SgAsmElfSymverDefinedEntry.
     *  @li @ref SgAsmElfSymverNeededAux corresponds to SgAsmElfSymverDefinedAux. */
    virtual SgAsmElfSymverNeededSection* parse() override;

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write SymverNeeded section back to disk.
     *
     *  For more information about encoding, see @ref SgAsmElfSymverNeededSection::parse. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededSection();

public:
    /** Default constructor. */
    SgAsmElfSymverNeededSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverNeededEntryList);
IS_SERIALIZABLE(AsmElfSymverNeededEntryList);

#ifndef DOCUMENTATION
AsmElfSymverNeededEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverNeededEntryList);
#if defined(SgAsmElfSymverNeededEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymverNeededEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of symbol version needed entries.
 *
 *  The only reason this node type exists is to hold the list of pointers. The list cannot be contained in the nodes that
 *  actually need it due to limitations of ROSETTA. */
class SgAsmElfSymverNeededEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededEntryList.setDataPrototype(
        "SgAsmElfSymverNeededEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverNeededEntryList);
#if defined(SgAsmElfSymverNeededEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverNeededEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverNeededEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverNeededEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries. 
     * 
     * @{ */
    SgAsmElfSymverNeededEntryPtrList const& get_entries() const;
    SgAsmElfSymverNeededEntryPtrList& get_entries();
    void set_entries(SgAsmElfSymverNeededEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededEntryList();

public:
    /** Default constructor. */
    SgAsmElfSymverNeededEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverNeededEntry);
IS_SERIALIZABLE(AsmElfSymverNeededEntry);

#ifndef DOCUMENTATION
AsmElfSymverNeededEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverNeededEntry);
#if defined(SgAsmElfSymverNeededEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>

#ifdef ROSE_SgAsmElfSymverNeededEntry_IMPL
#include <SgAsmElfSymverNeededAuxList.h>
#include <SgAsmGenericString.h>
#endif
#endif // SgAsmElfSymverNeededEntry_HEADERS

#ifdef DOCUMENTATION
/** One entry of the ELF symbol version needed table. */
class SgAsmElfSymverNeededEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededEntry.setDataPrototype(
        "size_t", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededEntry.setDataPrototype(
        "SgAsmGenericString*", "fileName", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededEntry.setDataPrototype(
        "SgAsmElfSymverNeededAuxList*", "entries", "= createAndParent<SgAsmElfSymverNeededAuxList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverNeededEntry);
#if defined(SgAsmElfSymverNeededEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverNeededEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverNeededEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_version);
        s & BOOST_SERIALIZATION_NVP(p_fileName);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverNeededEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. Same for 32bit and 64bit. */
    struct ElfSymverNeededEntry_disk {
        uint16_t      vn_version;                   /**< version of this struct: This field shall be set to 1 */
        uint16_t      vn_cnt;                       /**< Number of vernaux entries @see SgAsmElfSymverNeededAux */
        uint32_t      vn_file;                      /**< Offset (in bytes) to strings table to file string */
        uint32_t      vn_aux;                       /**< Offset (in bytes) to start of array of vernaux entries */
        uint32_t      vn_next;                      /**< Offset (in bytes) to next verneed entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Version.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    size_t const& get_version() const;
    void set_version(size_t const&);
    /** @} */

public:
    /** Property: File name. 
     * 
     * @{ */
    SgAsmGenericString* const& get_fileName() const;
    void set_fileName(SgAsmGenericString* const&);
    /** @} */

public:
    /** Property: List of entries.
     *
     *  This is a pointer to an AST node whose only purpose is to hold the list. The reason the list cannot be contained
     *  directly in this node where it's needed is due to ROSETTA limitations. 
     *  
     *  @{ */
    SgAsmElfSymverNeededAuxList* const& get_entries() const;
    void set_entries(SgAsmElfSymverNeededAuxList* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that links object into the AST. */
    explicit SgAsmElfSymverNeededEntry(SgAsmElfSymverNeededSection*);

    /** Initialize object by parsing file. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*);

    /** Encode object to disk representation. */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*) const;

    /** Print debugging information. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmGenericString* get_file_name() const ROSE_DEPRECATED("use get_fileName");
    void set_file_name(SgAsmGenericString*) ROSE_DEPRECATED("use set_fileName");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededEntry();

public:
    /** Default constructor. */
    SgAsmElfSymverNeededEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededAuxList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverNeededAuxList);
IS_SERIALIZABLE(AsmElfSymverNeededAuxList);

#ifndef DOCUMENTATION
AsmElfSymverNeededAuxList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverNeededAuxList);
#if defined(SgAsmElfSymverNeededAuxList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymverNeededAuxList_HEADERS

#ifdef DOCUMENTATION
/** Hods a list of symbol version aux entries.
 *
 *  The only purpose of this node is to work around a limitation of ROSETTA that prevents this list from being contained
 *  directly in the class that needs it. */
class SgAsmElfSymverNeededAuxList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededAuxList.setDataPrototype(
        "SgAsmElfSymverNeededAuxPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverNeededAuxList);
#if defined(SgAsmElfSymverNeededAuxList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverNeededAuxList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverNeededAuxList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverNeededAuxList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries. 
     * 
     * @{ */
    SgAsmElfSymverNeededAuxPtrList const& get_entries() const;
    SgAsmElfSymverNeededAuxPtrList& get_entries();
    void set_entries(SgAsmElfSymverNeededAuxPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededAuxList();

public:
    /** Default constructor. */
    SgAsmElfSymverNeededAuxList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededAuxList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededAux           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverNeededAux);
IS_SERIALIZABLE(AsmElfSymverNeededAux);

#ifndef DOCUMENTATION
AsmElfSymverNeededAux.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverNeededAux);
#if defined(SgAsmElfSymverNeededAux_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>

#ifdef ROSE_SgAsmElfSymverNeededAux_IMPL
#include <SgAsmGenericString.h>
#endif
#endif // SgAsmElfSymverNeededAux_HEADERS

#ifdef DOCUMENTATION
/** Auxiliary info for needed symbol version. */
class SgAsmElfSymverNeededAux: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededAux.setDataPrototype(
        "uint32_t", "hash", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededAux.setDataPrototype(
        "int", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededAux.setDataPrototype(
        "size_t", "other", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverNeededAux.setDataPrototype(
        "SgAsmGenericString*", "name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverNeededAux);
#if defined(SgAsmElfSymverNeededAux_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverNeededAux -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverNeededAux");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_hash);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_other);
        s & BOOST_SERIALIZATION_NVP(p_name);
        debugSerializationEnd("SgAsmElfSymverNeededAux");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. Same for 32bit and 64bit. */
    struct ElfSymverNeededAux_disk {
        uint32_t      vna_hash;                     /**< Hash of version name */
        uint16_t      vna_flags;                    /**< Version information flag bitmask */
        uint16_t      vna_other;                    /**< Version index of this entry (bit 15 is special) */
        uint32_t      vna_name;                     /**< Offset (in bytes) to strings table to name string */
        uint32_t      vna_next;                     /**< Offset (in bytes) to next vernaux entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Hash.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    uint32_t const& get_hash() const;
    void set_hash(uint32_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    int const& get_flags() const;
    void set_flags(int const&);
    /** @} */

public:
    /** Property: Other.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    size_t const& get_other() const;
    void set_other(size_t const&);
    /** @} */

public:
    /** Property: Name. 
     * 
     * @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into AST.
     *
     *  This constructor adds this auxiliary information object to the specified entry of the specified GNU Symbol Version
     *  Requirements Table. */
    SgAsmElfSymverNeededAux(SgAsmElfSymverNeededEntry *entry, SgAsmElfSymverNeededSection *symver);

    /** Initialize this auxiliary record by parsing data from the file. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*);

    /** Encode this auxiliary record into a format that can be written to a file. */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*) const;

    /** Print debugging information.
     *
     *  Prints debugging information about this auxiliary record of an entry of the GNU Symbol Version Requirements
     *  Table. Note that this method is not normally called since @ref SgAsmElfSymverNeededEntry::dump prints the auxiliary
     *  information explicitly for a more compact listing. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededAux();

public:
    /** Default constructor. */
    SgAsmElfSymverNeededAux();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededAux_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverEntryList);
IS_SERIALIZABLE(AsmElfSymverEntryList);

#ifndef DOCUMENTATION
AsmElfSymverEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverEntryList);
#if defined(SgAsmElfSymverEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymverEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of entries from a symbol version table.
 *
 *  The only reason this node exists instead of storing the entries directly in the parent node that needs them is due to
 *  ROSETTA limitations. */
class SgAsmElfSymverEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverEntryList.setDataPrototype(
        "SgAsmElfSymverEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverEntryList);
#if defined(SgAsmElfSymverEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of symbol version table entries. 
     * 
     * @{ */
    SgAsmElfSymverEntryPtrList const& get_entries() const;
    SgAsmElfSymverEntryPtrList& get_entries();
    void set_entries(SgAsmElfSymverEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymverEntryList();

public:
    /** Default constructor. */
    SgAsmElfSymverEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverEntry);
IS_SERIALIZABLE(AsmElfSymverEntry);

#ifndef DOCUMENTATION
AsmElfSymverEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Entry in an ELF symbol version table. */
class SgAsmElfSymverEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverEntry.setDataPrototype(
        "size_t", "value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverEntry);
#if defined(SgAsmElfSymverEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_value);
        debugSerializationEnd("SgAsmElfSymverEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Value.
     *
     *  Numeric value of this symbol. 
     *  
     *  @{ */
    size_t const& get_value() const;
    void set_value(size_t const&);
    /** @} */
public:
    /** Constructor that links new entry into the AST. */
    explicit SgAsmElfSymverEntry(SgAsmElfSymverSection*);

    /** Prints some debugging info. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverEntry();

public:
    /** Default constructor. */
    SgAsmElfSymverEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverDefinedSection);
IS_SERIALIZABLE(AsmElfSymverDefinedSection);

#ifndef DOCUMENTATION
AsmElfSymverDefinedSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverDefinedSection);
#if defined(SgAsmElfSymverDefinedSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfSymverDefinedSection_IMPL
#include <SgAsmElfSymverDefinedEntryList.h>
#endif
#endif // SgAsmElfSymverDefinedSection_HEADERS

#ifdef DOCUMENTATION
/** The GNU symbol version definitions.
 *
 *  This section is usually named ".gnu.version_d".  The @ref SgAsmElfSymverDefinedSection points to a list of entries (@ref
 *  SgAsmElfSymverDefinedEntry), which in turn point to a list of auxilliary members (@ref SgAsmElfSymverDefinedAux). See @ref
 *  SgAsmElfSymverDefinedSection::parse for a good description of the disk format. */
class SgAsmElfSymverDefinedSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedSection.setDataPrototype(
        "SgAsmElfSymverDefinedEntryList*", "entries", "= createAndParent<SgAsmElfSymverDefinedEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverDefinedSection);
#if defined(SgAsmElfSymverDefinedSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverDefinedSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverDefinedSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverDefinedSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries.
     *
     *  This is a pointer to an AST node which contains the list. The reason the list isn't stored here directly is due to
     *  limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfSymverDefinedEntryList* const& get_entries() const;
    void set_entries(SgAsmElfSymverDefinedEntryList* const&);
    /** @} */
public:
    /** Constructor linking object into AST. */
    SgAsmElfSymverDefinedSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initializes this ELF SymverDefined Section by parsing a file.
     *
     *  The structure is nominally the following (where n is from DT_VERDEFNUM - 1 in .dynamic)
     *
     *  @code
     *   [0]ElfSymverDefinedEntry_disk
     *        vd_next------------------------------------+
     *        vd_aux ---------------------------------+  |
     *        vd_cnt                                  |  |
     *      [0]       ElfSymverDefinedAux_disk <------+  |
     *                  vda_next -----------------+      |
     *      [1]       ElfSymverDefinedAux_disk <--+      |
     *         ...                                       |
     *      [vd_cnt-1]ElfSymverDefinedAux_disk           |
     *                  vda_next = 0 <== null term       |
     *   [1]ElfSymverDefinedEntry_disk <-----------------+
     *      ...
     *   [n]ElfSymverDefinedEntry_disk
     *        vd_next = 0
     *        vd_aux
     *        vd_cnt
     *      [0]       ElfSymverDefinedAux_disk
     *      [1]       ElfSymverDefinedAux_disk
     *         ...
     *      [vd_cnt-1]ElfSymverDefinedAux_disk
     *  @endcode
     *
     *  However, the spec doesn't specify any actual relationship to the layout of anything...so it could just as easily
     *  be:
     *
     *  @code
     *    [0]ElfSymverDefinedEntry_disk ---+---+
     *    [1]ElfSymverDefinedEntry_disk <--+   |
     *    ...                                  |
     *    [n]ElfSymverDefinedEntry_disk -------|---+
     *                                         |   |
     *    [0]ElfSymverDefinedAux_disk   <------+   |
     *    ...                                      |
     *    [x]ElfSymverDefinedAux_disk   <----------+
     *    [.]ElfSymverDefinedAux_disk
     *  @endcode
     *
     *  There is also nothing in particular that says Aux entries need to be next to each other.  So, the code handles the
     *  most rigidly compliant case, which is to use only the offsets and make no assumptions about layouts.
     *
     *  Also note the number of entries is specified in two ways -- via null termination on the "linked list", as well as
     *  the number from the .dynamic section [DT_VERDEFNUM].  For now, we'll support the null terminator, restricted by
     *  ensuring we don't exceed the size of the section (to keep from running away on a bad file).
     *
     *  We have a similar problem with the number of Aux's per Entry (vd_cnt versus vda_aux=0). However, in this case, we
     *  respect the min of the two (i.e. we assume cnt is right, but if vda_aux is zero earlier than expected, we stop).
     *  This is necessary because the spec allows two or more entries to point into (possibly different places) of a shared
     *  aux array.  This parser creates a new @ref SgAsmElfSymverDefinedAux object every time an element of the aux array
     *  is read from disk, ensuring that each @ref SgAsmElfSymverDefinedEntry points to its own copies.
     *
     *  All offsets are relative to the start of the struct they were specified in. I.e.,
     *
     *  @code
     *    Entry* entry=(0x0100);
     *    Aux* firstAux=(0x100 + entry->vd_aux)
     *    Aux* secondAux=(0x100 + entry->vd_aux + firstAux->vda_next)
     *
     *    Entry* secondEntry=(0x0100 + entry->vd_next);
     *  @endcode
     *
     *  Because of this rather complex structure, the section itself (@ref SgAsmElfSymverDefinedSection) manages all of the
     *  data related to structure (vd_next,vd_aux,vd_cnt, vda_next) -- the subclasses can simply ignore all of that.  The
     *  section also takes care of creating both *Entries and *Auxes and tying them together correctly. */
    virtual SgAsmElfSymverDefinedSection* parse() override;

    using SgAsmElfSection::calculateSizes;
    /** Return sizes for various parts of the table. See doc for SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write SymverDefined section back to disk.
     *
     *  For more information about encoding, see @ref parse. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    using SgAsmElfSection::calculate_sizes;
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedSection();

public:
    /** Default constructor. */
    SgAsmElfSymverDefinedSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverDefinedEntryList);
IS_SERIALIZABLE(AsmElfSymverDefinedEntryList);

#ifndef DOCUMENTATION
AsmElfSymverDefinedEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverDefinedEntryList);
#if defined(SgAsmElfSymverDefinedEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymverDefinedEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of entries for the ELF symbol version definition table.
 *
 *  The only reason we have a dedicated AST node type for this information instead of storing it directly in the nodes that
 *  need it is due to limitations of ROSETTA. */
class SgAsmElfSymverDefinedEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntryList.setDataPrototype(
        "SgAsmElfSymverDefinedEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverDefinedEntryList);
#if defined(SgAsmElfSymverDefinedEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverDefinedEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverDefinedEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverDefinedEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of table entries. 
     * 
     * @{ */
    SgAsmElfSymverDefinedEntryPtrList const& get_entries() const;
    SgAsmElfSymverDefinedEntryPtrList& get_entries();
    void set_entries(SgAsmElfSymverDefinedEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedEntryList();

public:
    /** Default constructor. */
    SgAsmElfSymverDefinedEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverDefinedEntry);
IS_SERIALIZABLE(AsmElfSymverDefinedEntry);

#ifndef DOCUMENTATION
AsmElfSymverDefinedEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverDefinedEntry);
#if defined(SgAsmElfSymverDefinedEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>

#ifdef ROSE_SgAsmElfSymverDefinedEntry_IMPL
#include <SgAsmElfSymverDefinedAuxList.h>
#endif
#endif // SgAsmElfSymverDefinedEntry_HEADERS

#ifdef DOCUMENTATION
/** One entry from an ELF symbol version definition table. */
class SgAsmElfSymverDefinedEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntry.setDataPrototype(
        "size_t", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntry.setDataPrototype(
        "int", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntry.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntry.setDataPrototype(
        "uint32_t", "hash", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedEntry.setDataPrototype(
        "SgAsmElfSymverDefinedAuxList*", "entries", "= createAndParent<SgAsmElfSymverDefinedAuxList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverDefinedEntry);
#if defined(SgAsmElfSymverDefinedEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverDefinedEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverDefinedEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_version);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_index);
        s & BOOST_SERIALIZATION_NVP(p_hash);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverDefinedEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** Disk format. 32- and 64-bit formats are both the same. */
    struct ElfSymverDefinedEntry_disk {
        uint16_t      vd_version;                   /**< version of this struct: This field shall be set to 1 */
        uint16_t      vd_flags;                     /**< Version information flag bitmask */
        uint16_t      vd_ndx;                       /**< Version index of this entry */
        uint16_t      vd_cnt;                       /**< Number of verdaux entries @see SgAsmElfSymverDefinedAux */
        uint32_t      vd_hash;                      /**< Hash of version name */
        uint32_t      vd_aux;                       /**< Offset (in bytes) to start of array of verdaux entries */
        uint32_t      vd_next;                      /**< Offset (in bytes) to next verdef entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Version.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    size_t const& get_version() const;
    void set_version(size_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    int const& get_flags() const;
    void set_flags(int const&);
    /** @} */

public:
    /** Property: Index.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    size_t const& get_index() const;
    void set_index(size_t const&);
    /** @} */

public:
    /** Property: Hash.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    uint32_t const& get_hash() const;
    void set_hash(uint32_t const&);
    /** @} */

public:
    /** Property: Entries.
     *
     *  List of auxilliary entries for this version definition.  Rather than storing the list here directly, we point to a
     *  node whose only purpose is to hold the list. This is due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfSymverDefinedAuxList* const& get_entries() const;
    void set_entries(SgAsmElfSymverDefinedAuxList* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking ojbec into the AST. */
    explicit SgAsmElfSymverDefinedEntry(SgAsmElfSymverDefinedSection *symver_defined);

    /** Initialize by parsing information from the file. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*);

    /** Convert to the disk format. */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*) const;

    /** Print some debugging info. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedEntry();

public:
    /** Default constructor. */
    SgAsmElfSymverDefinedEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedAuxList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverDefinedAuxList);
IS_SERIALIZABLE(AsmElfSymverDefinedAuxList);

#ifndef DOCUMENTATION
AsmElfSymverDefinedAuxList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverDefinedAuxList);
#if defined(SgAsmElfSymverDefinedAuxList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymverDefinedAuxList_HEADERS

#ifdef DOCUMENTATION
/** List of symbol version aux entries.
 *
 *  The only purpose of this node is to hold the list of pointers, which can't be contained in the classes that need the
 *  list due to limitations of ROSETTA. */
class SgAsmElfSymverDefinedAuxList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedAuxList.setDataPrototype(
        "SgAsmElfSymverDefinedAuxPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverDefinedAuxList);
#if defined(SgAsmElfSymverDefinedAuxList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverDefinedAuxList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverDefinedAuxList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSymverDefinedAuxList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries. 
     * 
     * @{ */
    SgAsmElfSymverDefinedAuxPtrList const& get_entries() const;
    SgAsmElfSymverDefinedAuxPtrList& get_entries();
    void set_entries(SgAsmElfSymverDefinedAuxPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedAuxList();

public:
    /** Default constructor. */
    SgAsmElfSymverDefinedAuxList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedAuxList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedAux           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymverDefinedAux);
IS_SERIALIZABLE(AsmElfSymverDefinedAux);

#ifndef DOCUMENTATION
AsmElfSymverDefinedAux.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymverDefinedAux);
#if defined(SgAsmElfSymverDefinedAux_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>

#ifdef ROSE_SgAsmElfSymverDefinedAux_IMPL
#include <SgAsmGenericString.h>
#endif
#endif // SgAsmElfSymverDefinedAux_HEADERS

#ifdef DOCUMENTATION
/** Auxiliary data for an ELF Symbol Version. */
class SgAsmElfSymverDefinedAux: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymverDefinedAux.setDataPrototype(
        "SgAsmGenericString*", "name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymverDefinedAux);
#if defined(SgAsmElfSymverDefinedAux_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymverDefinedAux -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymverDefinedAux");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_name);
        debugSerializationEnd("SgAsmElfSymverDefinedAux");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. The format is the same for 32bit and 64bit. */
    struct ElfSymverDefinedAux_disk {
        uint32_t      vda_name;                     /**< Offset (in bytes) to strings table to name string */
        uint32_t      vda_next;                     /**< Offset (in bytes) to next verdaux entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Name. 
     * 
     * @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into AST.
     *
     *  This constructor links this new Aux into the specified Entry of the specified Symbol Version Definition Table. */
    explicit SgAsmElfSymverDefinedAux(SgAsmElfSymverDefinedEntry *symver_def_entry, SgAsmElfSymverDefinedSection *symver_def_sec);

    /** Initialize this object with data parsed from a file. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*);

    /** Convert this object into the disk format record to be written back to the Symbol Version Definition Table. */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*) const;

    /** Print debugging information.
     *
     *  Shows information about the specified auxiliary data for an entry in the Symbol Version Definition Table. Note that
     *  in order to have a more compact output, @ref SgAsmElfSymverDefinedEntry::dump prints the @ref
     *  SgAsmElfSymverDefinedAux objects explicitly rather than calling this method. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedAux();

public:
    /** Default constructor. */
    SgAsmElfSymverDefinedAux();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedAux_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbolSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymbolSection);
IS_SERIALIZABLE(AsmElfSymbolSection);

#ifndef DOCUMENTATION
AsmElfSymbolSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymbolSection);
#if defined(SgAsmElfSymbolSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfSymbolSection_IMPL
#include <SgAsmElfSymbolList.h>
#endif
#endif // SgAsmElfSymbolSection_HEADERS

#ifdef DOCUMENTATION
/** ELF file section containing symbols. */
class SgAsmElfSymbolSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbolSection.setDataPrototype(
        "bool", "isDynamic", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbolSection.setDataPrototype(
        "SgAsmElfSymbolList*", "symbols", "= createAndParent<SgAsmElfSymbolList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymbolSection);
#if defined(SgAsmElfSymbolSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymbolSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymbolSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_isDynamic);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmElfSymbolSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Whether this section represents dynamic linking symbols. 
     * 
     * @{ */
    bool const& get_isDynamic() const;
    void set_isDynamic(bool const&);
    /** @} */

public:
    /** Property: Symbols.
     *
     *  List of symbols contained in this symbol table.  The actual list is stored in a separate AST instead of being stored
     *  directly in this node due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfSymbolList* const& get_symbols() const;
    void set_symbols(SgAsmElfSymbolList* const&);
    /** @} */
public:
    /** Non-parsing constructor */
    SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initialize by parsing a file. */
    virtual SgAsmElfSymbolSection* parse() override;

    /** Update section pointers for locally-bound symbols.
     *
     *  Now that the section table has been read and all non-synthesized sections have been created, we can update
     *  pointers to other things.
     *
     *  The st_shndx is the index (ID) of the section to which the symbol is bound. Special values are:
     *
     *  @li 0x0000: no section (section table entry zero should be all zeros anyway)
     *  @li 0xff00-0xffff: reserved values, not an index
     *  @li 0xff00-0xff1f: processor specific values
     *  @li 0xfff1: symbol has absolute value not affected by relocation
     *  @li 0xfff2: symbol is fortran common or unallocated C extern */
    virtual void finishParsing() override;

    /** Given a symbol, return its index in this symbol table. */
    size_t indexOf(SgAsmElfSymbol*);

    using SgAsmElfSection::calculateSizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Called prior to unparsing.
     *
     *  Updates symbol entries with name offsets. */
    virtual bool reallocate() override;

    /** Write symbol table sections back to disk. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool get_is_dynamic() const ROSE_DEPRECATED("use get_isDynamic");
    void set_is_dynamic(bool) ROSE_DEPRECATED("use set_isDynamic");
    virtual void finish_parsing() override ROSE_DEPRECATED("use finishParsing");
    size_t index_of(SgAsmElfSymbol*) ROSE_DEPRECATED("use indexOf");
    using SgAsmElfSection::calculate_sizes;
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymbolSection();

public:
    /** Default constructor. */
    SgAsmElfSymbolSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbolSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymbolList);
IS_SERIALIZABLE(AsmElfSymbolList);

#ifndef DOCUMENTATION
AsmElfSymbolList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymbolList);
#if defined(SgAsmElfSymbolList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSymbolList_HEADERS

#ifdef DOCUMENTATION
class SgAsmElfSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbolList.setDataPrototype(
        "SgAsmElfSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymbolList);
#if defined(SgAsmElfSymbolList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymbolList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymbolList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmElfSymbolList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Symbol list.
     *
     *  This points to an AST node that contains the actual symbol list. The reason that the list is not held directly in
     *  the nodes that need it is due to ROSETTA limitations. 
     *  
     *  @{ */
    SgAsmElfSymbolPtrList const& get_symbols() const;
    SgAsmElfSymbolPtrList& get_symbols();
    void set_symbols(SgAsmElfSymbolPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSymbolList();

public:
    /** Default constructor. */
    SgAsmElfSymbolList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbolList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSymbol);
IS_SERIALIZABLE(AsmElfSymbol);

#ifndef DOCUMENTATION
AsmElfSymbol.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSymbol);
#if defined(SgAsmElfSymbol_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <sageContainer.h>
#endif // SgAsmElfSymbol_HEADERS

#ifdef DOCUMENTATION
/** Represents a single ELF symbol.
 *
 *  Most of the properties of this node correspond directly with properties defined by the ELF specification. Their
 *  documentation is not replicated here -- refer to the specification. */
class SgAsmElfSymbol: public SgAsmGenericSymbol {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbol.setDataPrototype(
        "unsigned char", "st_info", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbol.setDataPrototype(
        "unsigned char", "st_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbol.setDataPrototype(
        "unsigned", "st_shndx", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbol.setDataPrototype(
        "rose_addr_t", "st_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSymbol.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSymbol);
#if defined(SgAsmElfSymbol_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSymbol -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSymbol");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSymbol);
        s & BOOST_SERIALIZATION_NVP(p_st_info);
        s & BOOST_SERIALIZATION_NVP(p_st_res1);
        s & BOOST_SERIALIZATION_NVP(p_st_shndx);
        s & BOOST_SERIALIZATION_NVP(p_st_size);
        s & BOOST_SERIALIZATION_NVP(p_extra);
        debugSerializationEnd("SgAsmElfSymbol");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum ElfSymBinding {
        STB_LOCAL=0,
        STB_GLOBAL=1,
        STB_WEAK=2
    };

    enum ElfSymType {
        STT_NOTYPE      = 0,                    /**< Unspecified type */
        STT_OBJECT      = 1,                    /**< Data object */
        STT_FUNC        = 2,                    /**< Code object */
        STT_SECTION     = 3,                    /**< Associated with a section */
        STT_FILE        = 4,                    /**< Name of a file */
        STT_COMMON      = 5,                    /**< Common data object */
        STT_TLS         = 6,                    /**< Thread-local data object */
        STT_IFUNC       = 10                    /**< Indirect function. Function call w/out args results in reloc value. */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** 32-bit format of an ELF symbol. */
    struct Elf32SymbolEntry_disk {
        uint32_t      st_name;                      /**< Name offset into string table */
        uint32_t      st_value;                     /**< Value: absolute value, address, etc. depending on sym type */
        uint32_t      st_size;                      /**< Symbol size in bytes */
        unsigned char st_info;                      /**< Type and binding attributes */
        unsigned char st_res1;                      /**< Reserved; always zero */
        uint16_t      st_shndx;                     /**< Section index or special meaning */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SymbolEntry_disk {
        uint32_t      st_name;
        unsigned char st_info;
        unsigned char st_res1;
        uint16_t      st_shndx;
        uint64_t      st_value;
        uint64_t      st_size;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Info.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned char const& get_st_info() const;
    void set_st_info(unsigned char const&);
    /** @} */

public:
    /** Property: Reserved byte.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned char const& get_st_res1() const;
    void set_st_res1(unsigned char const&);
    /** @} */

public:
    /** Property: shndx.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned const& get_st_shndx() const;
    void set_st_shndx(unsigned const&);
    /** @} */

public:
    /** Property: size.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    rose_addr_t const& get_st_size() const;
    void set_st_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Extra data.
     *
     *  Bytes that are not part of the symbol but which appear in the table as reserved or padding. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_extra() const;
    SgUnsignedCharList& get_extra();
    void set_extra(SgUnsignedCharList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that adds the symbol to a symbol table. */
    explicit SgAsmElfSymbol(SgAsmElfSymbolSection*);

    /** Initialize symbol by parsing a symbol table entry.
     *
     *  An ELF String Section must be supplied in order to get the symbol name. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymbol::Elf32SymbolEntry_disk*);

    /** Initialize symbol by parsing a symbol table entry.
     *
     *  An ELF String Section must be supplied in order to get the symbol name. */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfSymbol::Elf64SymbolEntry_disk*);

    /** Encode a symbol into disk format.
     *
     * @{ */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymbol::Elf32SymbolEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSymbol::Elf64SymbolEntry_disk*) const;
    /** @} */

    /** Print some debugging info.
     *
     *  The 'section' is an optional section pointer for the st_shndx member.
     *
     * @{ */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const override;
    void dump(FILE*, const char *prefix, ssize_t idx, SgAsmGenericSection*) const;
    /** @} */

    /** Returns binding as an enum constant. */
    SgAsmElfSymbol::ElfSymBinding get_elfBinding() const;

    /** Returns type as an enum constant. */
    SgAsmElfSymbol::ElfSymType get_elfType() const;

    /** Converts enum constant to string. */
    static std::string toString(SgAsmElfSymbol::ElfSymBinding);

    /** Converts enum constant to string. */
    static std::string toString(SgAsmElfSymbol::ElfSymType);

private:
    void parse_common();                            // initialization common to all parse() methods

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmElfSymbol::ElfSymBinding get_elf_binding() const ROSE_DEPRECATED("use get_elfBinding");
    SgAsmElfSymbol::ElfSymType get_elf_type() const ROSE_DEPRECATED("use get_elfType");
    static std::string to_string(SgAsmElfSymbol::ElfSymBinding) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmElfSymbol::ElfSymType) ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmElfSymbol();

public:
    /** Default constructor. */
    SgAsmElfSymbol();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbol_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfStrtab);
IS_SERIALIZABLE(AsmElfStrtab);

#ifndef DOCUMENTATION
AsmElfStrtab.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** ELF string table. */
class SgAsmElfStrtab: public SgAsmGenericStrtab {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmElfStrtab);
#if defined(SgAsmElfStrtab_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfStrtab -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfStrtab");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericStrtab);
        debugSerializationEnd("SgAsmElfStrtab");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Non-parsing constructor.
     *
     *  The table is created to be at least one byte long and having a NUL character as the first byte. */
    explicit SgAsmElfStrtab(class SgAsmElfSection *containing_section);

    /** Free StringStorage objects associated with this string table.
     *
     *  It may not be safe to blow them away yet since other objects may still have @ref SgAsmStoredString objects pointing to
     *  these storage objects. So instead, we will mark all this strtab's storage objects as no longer being associated
     *  with a string table. This allows the @ref SgAsmStoredString objects to still function properly and their
     *  destructors will free their storage. */
    void destructorHelper() override;

    /** Parses the string table.
     *
     *  All that actually happens at this point is we look to see if the table begins with an empty string. */
    virtual SgAsmElfStrtab *parse() override;

    /** Write string table back to disk.
     *
     *  Free space is zeroed out; holes are left as they are. */
    virtual void unparse(std::ostream&) const;

    /** Creates the storage item for the string at the specified offset.
     *
     *  If @p shared is true then attempt to re-use a previous storage object, otherwise always create a new one. Each
     *  storage object is considered a separate string, therefore when two strings share the same storage object, changing
     *  one string changes the other. */
    virtual SgAsmStringStorage *createStorage(rose_addr_t offset, bool shared) override;

    /** Returns the number of bytes required to store the string in the string table.
     *
     *  This is the length of the string plus one for the NUL terminator. */
    virtual rose_addr_t get_storageSize(const SgAsmStringStorage*) override;

    /** Find offset for a string.
     *
     *  Tries to find a suitable offset for a string such that it overlaps with some other string already allocated. If the
     *  new string is the same as the end of some other string (new="main", existing="domain") then we just use an offset
     *  into that string since the space is already allocated for the existing string. If the new string ends with an
     *  existing string (new="domain", existing="main") and there's enough free space before the existing string (two bytes
     *  in this case) then we allocate some of that free space and use a suitable offset. In any case, upon return
     *  <code>storege->get_offset()</code> will return the allocated offset if successful, or
     *  @ref SgAsmGenericString::unallocated if we couldn't find an overlap. */
    virtual void allocateOverlap(SgAsmStringStorage*) override;

    /** Similar to create_storage() but uses a storage object that's already been allocated. */
    virtual void rebind(SgAsmStringStorage*, rose_addr_t) override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    virtual SgAsmStringStorage *create_storage(rose_addr_t, bool) override ROSE_DEPRECATED("use createStorage");
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) override ROSE_DEPRECATED("use get_storageSize");
    virtual void allocate_overlap(SgAsmStringStorage*) override ROSE_DEPRECATED("use allocateOverlap");
public:
    /** Destructor. */
    virtual ~SgAsmElfStrtab();

public:
    /** Default constructor. */
    SgAsmElfStrtab();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfStrtab_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfStringSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfStringSection);
IS_SERIALIZABLE(AsmElfStringSection);

#ifndef DOCUMENTATION
AsmElfStringSection.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** ELF string table section.
 *
 *  A file section that holds string literals such as symbol names. */
class SgAsmElfStringSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfStringSection.setDataPrototype(
        "SgAsmElfStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfStringSection);
#if defined(SgAsmElfStringSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfStringSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfStringSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_strtab);
        debugSerializationEnd("SgAsmElfStringSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: String table.
     *
     *  Pointer to the actual string table for this section. 
     *  
     *  @{ */
    SgAsmElfStrtab* const& get_strtab() const;
    void set_strtab(SgAsmElfStrtab* const&);
    /** @} */
public:
    /** Constructor that links new object into AST. */
    explicit SgAsmElfStringSection(SgAsmElfFileHeader*);

    /** Initialize object by parsing binary specimen. */
    virtual SgAsmElfStringSection *parse() override;

    /** Dump debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Adjust size of table.
     *
     * Augments superclass to make sure free list and such are adjusted properly. Any time the ELF String Section size is
     * changed we adjust the free list in the ELF String Table contained in this section. */
    virtual void set_size(rose_addr_t newsize) override;

    /** Reallocate space for the string section if necessary.
     *
     *  Note that reallocation is lazy here -- we don't shrink the section, we only enlarge it (if you want the section to
     *  shrink then call SgAsmGenericStrtab::reallocate(bool) with a true value rather than calling this
     *  function. SgAsmElfStringSection::reallocate is called in response to unparsing a file and gives the string table a
     *  chance to extend its container section if it needs to allocate more space for strings. */
    virtual bool reallocate() override;

    /** Unparse an ElfStringSection by unparsing the ElfStrtab */
    virtual void unparse(std::ostream&) const override;
public:
    /** Destructor. */
    virtual ~SgAsmElfStringSection();

public:
    /** Default constructor. */
    SgAsmElfStringSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfStringSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSegmentTable);
IS_SERIALIZABLE(AsmElfSegmentTable);

#ifndef DOCUMENTATION
AsmElfSegmentTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents an ELF segment table.
 *
 * The ELF Segment Table is an ELF Section that has entries describing the various segments of the ELF file.  Each segment
 * is also an SgAsmElfSection and the entries of the ELF Segment Table are associated with the SgAsmElfSection they
 * describe.  The ELF Segment Table can be reconstructed by traversing the AST and finding the SgAsmElfSegmentTableEntry
 * nodes. */
class SgAsmElfSegmentTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmElfSegmentTable);
#if defined(SgAsmElfSegmentTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSegmentTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSegmentTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        debugSerializationEnd("SgAsmElfSegmentTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Constuct segment table linked into the AST. */
    explicit SgAsmElfSegmentTable(SgAsmElfFileHeader*);

    /** Parses an ELF Segment (Program Header) Table.
     *
     *  Parses an ELF segment table and constructs and parses all segments reachable from the table. The section is
     *  extended as necessary based on the number of entries and teh size of each entry. */
    virtual SgAsmElfSegmentTable *parse() override;

    /** Attaches new segments to the segment table.
     *
     *  Attaches a previously unattached ELF Segment (@ref SgAsmElfSection) to the ELF Segment Table (@ref
     *  SgAsmElfSegmentTable). This method complements @ref SgAsmElfSection::initFromSegmentTable. This method
     *  initializes the segment table from the segment while init_from_segment_table initializes the segment from the
     *  segment table.
     *
     *  ELF Segments are represented by @ref SgAsmElfSection objects since ELF Segments and ELF Sections overlap very much in their
     *  features and thus should share an interface. An @ref SgAsmElfSection can appear in the ELF Section Table and/or the ELF
     *  Segment Table and you can determine where it was located with its @ref SgAsmElfSection::sectionEntry and @ref
     *  SgAsmElfSection::segmentEntry properties.
     *
     *  Returns the new segment table entry linked into the AST. */
    SgAsmElfSegmentTableEntry *addSection(SgAsmElfSection*);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. */
    rose_addr_t calculateSizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    virtual bool reallocate() override;

    /** Write the segment table to disk. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmElfSegmentTableEntry *add_section(SgAsmElfSection*) ROSE_DEPRECATED("use addSection");
    rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTable();

public:
    /** Default constructor. */
    SgAsmElfSegmentTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTableEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSegmentTableEntryList);
IS_SERIALIZABLE(AsmElfSegmentTableEntryList);

#ifndef DOCUMENTATION
AsmElfSegmentTableEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSegmentTableEntryList);
#if defined(SgAsmElfSegmentTableEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfSegmentTableEntryList_HEADERS

#ifdef DOCUMENTATION
class SgAsmElfSegmentTableEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntryList.setDataPrototype(
        "SgAsmElfSegmentTableEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSegmentTableEntryList);
#if defined(SgAsmElfSegmentTableEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSegmentTableEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSegmentTableEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfSegmentTableEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Segment table entries.
     *
     *  List of entries in this segment table.  The reason we have a whole AST node dedicated to holding this list rather
     *  than just storing the list directly in the nodes that need it is due to limitations with ROSETTA. 
     *  
     *  @{ */
    SgAsmElfSegmentTableEntryPtrList const& get_entries() const;
    SgAsmElfSegmentTableEntryPtrList& get_entries();
    void set_entries(SgAsmElfSegmentTableEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTableEntryList();

public:
    /** Default constructor. */
    SgAsmElfSegmentTableEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTableEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSegmentTableEntry);
IS_SERIALIZABLE(AsmElfSegmentTableEntry);

#ifndef DOCUMENTATION
AsmElfSegmentTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSegmentTableEntry);
#if defined(SgAsmElfSegmentTableEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <sageContainer.h>
#endif // SgAsmElfSegmentTableEntry_HEADERS

#ifdef DOCUMENTATION
/** Represents one entry of a segment table. */
class SgAsmElfSegmentTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgAsmElfSegmentTableEntry::SegmentType", "type", "= SgAsmElfSegmentTableEntry::PT_LOAD",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgAsmElfSegmentTableEntry::SegmentFlags", "flags", "= SgAsmElfSegmentTableEntry::PF_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "vaddr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "paddr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "filesz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "memsz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSegmentTableEntry);
#if defined(SgAsmElfSegmentTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSegmentTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSegmentTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_index);
        s & BOOST_SERIALIZATION_NVP(p_type);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        s & BOOST_SERIALIZATION_NVP(p_vaddr);
        s & BOOST_SERIALIZATION_NVP(p_paddr);
        s & BOOST_SERIALIZATION_NVP(p_filesz);
        s & BOOST_SERIALIZATION_NVP(p_memsz);
        s & BOOST_SERIALIZATION_NVP(p_align);
        s & BOOST_SERIALIZATION_NVP(p_extra);
        debugSerializationEnd("SgAsmElfSegmentTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Segment types (host order). All other values are reserved. */
    enum SegmentType {
        PT_NULL         = 0,                        /**< Ignored entry. Other values of entry are undefined. */
        PT_LOAD         = 1,                        /**< Loadable by mapping file contents into memory. */
        PT_DYNAMIC      = 2,                        /**< Dynamic linking information. */
        PT_INTERP       = 3,                        /**< Segment contains NUL-terminated path name of interpreter. */
        PT_NOTE         = 4,                        /**< Auxiliary information. */
        PT_SHLIB        = 5,                        /**< Reserved w/unspecified semantics. Such a file is nonconforming. */
        PT_PHDR         = 6,                        /**< Segment contains the segment table itself (program header array) */
        PT_TLS          = 7,                        /**< Thread local storage. */

        // OS- and Processor-specific ranges
        PT_LOOS         = 0x60000000,               /**< Values reserved for OS-specific semantics */
        PT_HIOS         = 0x6fffffff,
        PT_LOPROC       = 0x70000000,               /**< Values reserved for processor-specific semantics */
        PT_HIPROC       = 0x7fffffff,

        // OS-specific values for GNU/Linux
        PT_GNU_EH_FRAME = 0x6474e550,               /**< GCC .eh_frame_hdr segment */
        PT_GNU_STACK    = 0x6474e551,               /**< Indicates stack executability */
        PT_GNU_RELRO    = 0x6474e552,               /**< Read-only after relocation */
        PT_PAX_FLAGS    = 0x65041580,               /**< Indicates PaX flag markings */

        // OS-specific values for Sun
        PT_SUNWBSS      = 0x6ffffffa,               /**< Sun Specific segment */
        PT_SUNWSTACK    = 0x6ffffffb                /**< Stack segment */
    };

    /** Segment bit flags */
    enum SegmentFlags {
        PF_NONE         = 0,                        /**< Initial value in c'tor */
        PF_RESERVED     = 0x000ffff8,               /**< Reserved bits */
        PF_XPERM        = 0x00000001,               /**< Execute permission */
        PF_WPERM        = 0x00000002,               /**< Write permission */
        PF_RPERM        = 0x00000004,               /**< Read permission */
        PF_OS_MASK      = 0x0ff00000,               /**< os-specific bits */
        PF_PROC_MASK    = 0xf0000000                /**< Processor-specific bits */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** File format of an ELF Segment header.
     *
     * Byte order of members depends on e_ident value in file header. This code comes directly from "Executable and
     * Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool Interface Standards (TIS) and not from any
     * header file. The 64-bit structure is gleaned from the Linux elf(5) man page. Segment table entries (a.k.a., ELF
     * program headers) either describe process segments or give supplementary info which does not contribute to the
     * process image. */
    struct Elf32SegmentTableEntry_disk {
        uint32_t        p_type;                  /**< 0x00 kind of segment */
        uint32_t        p_offset;                /**< 0x04 file offset */
        uint32_t        p_vaddr;                 /**< 0x08 desired mapped address of segment */
        uint32_t        p_paddr;                 /**< 0x0c physical address where supported (unused by System V) */
        uint32_t        p_filesz;                /**< 0x20 bytes in file (may be zero or other value smaller than p_memsz) */
        uint32_t        p_memsz;                 /**< 0x24 number of bytes when mapped (may be zero) */
        uint32_t        p_flags;                 /**< 0x28 */
        uint32_t        p_align;                 /**< 0x2c alignment for file and memory (0,1=>none); power of two */
    }                                            /* 0x30 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SegmentTableEntry_disk {
        uint32_t        p_type;         /* 0x00 */
        uint32_t        p_flags;        /* 0x04 */
        uint64_t        p_offset;       /* 0x08 */
        uint64_t        p_vaddr;        /* 0x10 */
        uint64_t        p_paddr;        /* 0x18 */
        uint64_t        p_filesz;       /* 0x20 */
        uint64_t        p_memsz;        /* 0x28 */
        uint64_t        p_align;        /* 0x30 */
    }                                       /* 0x38 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Index into table.
     *
     *  This is the index of this entry within the ELF segment table. 
     *  
     *  @{ */
    size_t const& get_index() const;
    void set_index(size_t const&);
    /** @} */

public:
    /** Property: Segment type. 
     * 
     * @{ */
    SgAsmElfSegmentTableEntry::SegmentType const& get_type() const;
    void set_type(SgAsmElfSegmentTableEntry::SegmentType const&);
    /** @} */

public:
    /** Property: Segment flags. 
     * 
     * @{ */
    SgAsmElfSegmentTableEntry::SegmentFlags const& get_flags() const;
    void set_flags(SgAsmElfSegmentTableEntry::SegmentFlags const&);
    /** @} */

public:
    /** Property: Offset of segment in the file.
     *
     *  This is the starting byte offset of the segment within the file. 
     *  
     *  @{ */
    rose_addr_t const& get_offset() const;
    void set_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: Virtual address.
     *
     *  This is the virtual address for the start of the segment as stored in the segment table. This is only a hint to the
     *  loader, which may map the segment to some other virtual address. 
     *  
     *  @{ */
    rose_addr_t const& get_vaddr() const;
    void set_vaddr(rose_addr_t const&);
    /** @} */

public:
    /** Property: ELF paddr field.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_paddr() const;
    void set_paddr(rose_addr_t const&);
    /** @} */

public:
    /** Property: Size of segment in file.
     *
     *  Size of the segment in bytes as it is stored in the file. 
     *  
     *  @{ */
    rose_addr_t const& get_filesz() const;
    void set_filesz(rose_addr_t const&);
    /** @} */

public:
    /** Property:  Size of segment in memory.
     *
     *  Size of the segment in bytes after it is loaded into virtual memory. 
     *  
     *  @{ */
    rose_addr_t const& get_memsz() const;
    void set_memsz(rose_addr_t const&);
    /** @} */

public:
    /** Property: Alignment.
     *
     *  Alignment in memory in bytes. Zero means the same thing as one, namely no alignment. 
     *  
     *  @{ */
    rose_addr_t const& get_align() const;
    void set_align(rose_addr_t const&);
    /** @} */

public:
    /** Property: Extra bytes.
     *
     *  These are bytes from the table entry that are not assigned any specific purpose by the ELF specification. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_extra() const;
    SgUnsignedCharList& get_extra();
    void set_extra(SgUnsignedCharList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Construct node from 32-bit file data. */
    SgAsmElfSegmentTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                              const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);

    /** Construct node from 64-bit file data. */
    SgAsmElfSegmentTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                              const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);

    /** Converts segment table entry back into disk structure.
     *
     * @{ */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*) const;
    /** @} */

    /** Update this segment table entry with newer information from the section */
    void updateFromSection(SgAsmElfSection*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Convert segment type to string. */
    static std::string toString(SgAsmElfSegmentTableEntry::SegmentType);

    /** Convert segment flags to string. */
    static std::string toString(SgAsmElfSegmentTableEntry::SegmentFlags);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void update_from_section(SgAsmElfSection*) ROSE_DEPRECATED("use updateFromSection");
    static std::string to_string(SgAsmElfSegmentTableEntry::SegmentType) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmElfSegmentTableEntry::SegmentFlags) ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTableEntry();

public:
    /** Default constructor. */
    SgAsmElfSegmentTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSectionTable);
IS_SERIALIZABLE(AsmElfSectionTable);

#ifndef DOCUMENTATION
AsmElfSectionTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents an ELF section table.
 *
 *  The ELF Section Table is itself a section.  The entries of the table are stored with the section they describe rather
 *  than storing them all in the SgAsmSectionTable node.  We can reconstruct the ELF Section Table since sections have
 *  unique ID numbers that are their original indices in the ELF Section Table. */
class SgAsmElfSectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmElfSectionTable);
#if defined(SgAsmElfSectionTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSectionTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSectionTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        debugSerializationEnd("SgAsmElfSectionTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Constructor creates section table within the AST. */
    explicit SgAsmElfSectionTable(SgAsmElfFileHeader*);

    /** Parses an ELF Section Table.
     *
     *  Parses an ELF section table and constructs and parses all sections reachable from the table. The section is
     *  extended as necessary based on the number of entries and the size of each entry. Returns a pointer to this
     *  object. */
    virtual SgAsmElfSectionTable *parse() override;

    /** Attaches a previously unattached ELF Section to the section table.
     *
     *  If @p section is an ELF String Section (SgAsmElfStringSection) that contains an ELF String Table
     *  (SgAsmElfStringTable) and the ELF Section Table has no associated string table then the @p section will be used as
     *  the string table to hold the section names.
     *
     *  This method complements SgAsmElfSection::init_from_section_table. This method initializes the section table from
     *  the section while init_from_section_table() initializes the section from the section table.
     *
     *  Returns the new section table entry linked into the AST. */
    SgAsmElfSectionTableEntry *addSection(SgAsmElfSection*);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. */
    rose_addr_t calculateSizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    virtual bool reallocate() override;

    /** Write the section table section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmElfSectionTableEntry *add_section(SgAsmElfSection*) ROSE_DEPRECATED("use addSection");
    rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfSectionTable();

public:
    /** Default constructor. */
    SgAsmElfSectionTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSectionTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfSectionTableEntry);
IS_SERIALIZABLE(AsmElfSectionTableEntry);

#ifndef DOCUMENTATION
AsmElfSectionTableEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSectionTableEntry);
#if defined(SgAsmElfSectionTableEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <sageContainer.h>
#endif // SgAsmElfSectionTableEntry_HEADERS

#ifdef DOCUMENTATION
/** Represents one entry in an ELF section table. */
class SgAsmElfSectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned", "sh_name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "SgAsmElfSectionTableEntry::SectionType", "sh_type", "= SHT_PROGBITS",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned long", "sh_link", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned long", "sh_info", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "uint64_t", "sh_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_addr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_addralign", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_entsize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSectionTableEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSectionTableEntry);
#if defined(SgAsmElfSectionTableEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSectionTableEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSectionTableEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_sh_name);
        s & BOOST_SERIALIZATION_NVP(p_sh_type);
        s & BOOST_SERIALIZATION_NVP(p_sh_link);
        s & BOOST_SERIALIZATION_NVP(p_sh_info);
        s & BOOST_SERIALIZATION_NVP(p_sh_flags);
        s & BOOST_SERIALIZATION_NVP(p_sh_addr);
        s & BOOST_SERIALIZATION_NVP(p_sh_offset);
        s & BOOST_SERIALIZATION_NVP(p_sh_size);
        s & BOOST_SERIALIZATION_NVP(p_sh_addralign);
        s & BOOST_SERIALIZATION_NVP(p_sh_entsize);
        s & BOOST_SERIALIZATION_NVP(p_extra);
        debugSerializationEnd("SgAsmElfSectionTableEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Section types (host order). All other values are reserved. */
    enum SectionType {
        SHT_NULL        = 0,                  /**< Section header is inactive */
        SHT_PROGBITS    = 1,                  /**< Info defined by the program; format and meaning determined by prog */
        SHT_SYMTAB      = 2,                  /**< Complete symbol table */
        SHT_STRTAB      = 3,                  /**< String table */
        SHT_RELA        = 4,                  /**< Relocation entries with explicit addends (e.g., Elf32_Rela types) */
        SHT_HASH        = 5,                  /**< Symbol hash table (used by dynamic linking) */
        SHT_DYNAMIC     = 6,                  /**< Information for dynamic linking */
        SHT_NOTE        = 7,                  /**< Information that marks the file in some way */
        SHT_NOBITS      = 8,                  /**< Like SHT_PROGBITS but occupies no file space */
        SHT_REL         = 9,                  /**< Relocation entries without explicit addends (e.g., Elf32_Rel types) */
        SHT_SHLIB       = 10,                 /**< Reserved, unspecified semantics; Present only in non-conforming files */
        SHT_DYNSYM      = 11,                 /**< Minimal set of dynamic linking symbols */

        SHT_LOOS        = 0x60000000,         /**< OS specific semantics */
        SHT_GNU_verdef  = 0x6ffffffd,         /**< Symbol Version Definitions [gnu extension] .gnu.version_d */
        SHT_GNU_verneed = 0x6ffffffe,         /**< Symbol Version Requirements [gnu extension] .gnu.version_r */
        SHT_GNU_versym  = 0x6fffffff,         /**< Symbol Version Table [gnu extension] .gnu.version */
        SHT_HIOS        = 0x6fffffff,         /**< End OS specific semantics */       /*NO_STRINGIFY*/

        SHT_LOPROC      = 0x70000000,         /* Processor specific semantics */
        SHT_HIPROC      = 0x7fffffff,
        SHT_LOUSER      = 0x80000000,         /* Application specific semantics */
        SHT_HIUSER      = 0xffffffff
    };

    /** Section Flags (host order).  All other values are reserved. */
    enum SectionFlags {
        SHF_NULL=                  0,        /**< Invalid section flag (added for rose) */
        SHF_WRITE=           (1 << 0),       /**< Writable */
        SHF_ALLOC=           (1 << 1),       /**< Occupies memory during execution */
        SHF_EXECINSTR=       (1 << 2),       /**< Executable */
        SHF_MERGE=           (1 << 4),       /**< Might be merged */
        SHF_STRINGS=         (1 << 5),       /**< Contains nul-terminated strings */
        SHF_INFO_LINK=       (1 << 6),       /**< 'sh_info' contains SHT index */
        SHF_LINK_ORDER=      (1 << 7),       /**< Preserve order after combining */
        SHF_OS_NONCONFORMING=(1 << 8),       /**< Non-standard OS specific handling required */
        SHF_GROUP=           (1 << 9),       /**< Section is member of a group.  */
        SHF_TLS=             (1 << 10),      /**< Section hold thread-local data.  */
        SHF_MASKOS=          0x0ff00000,     /**< OS-specific.  */
        SHF_MASKPROC=        0xf0000000      /**< Processor-specific */
    };

    /** File format of an ELF Section header.
     *
     *  Byte order of members depends on e_ident value in file header. This code
     * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
     * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5) man
     * page. */
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct Elf32SectionTableEntry_disk {
        uint32_t        sh_name;             /* 0x00 Section name; index into section header string table */
        uint32_t        sh_type;             /* 0x04 Section contents and semantics (see SectionType enum) */
        uint32_t        sh_flags;            /* 0x08 Bit flags */
        uint32_t        sh_addr;             /* 0x0c Desired mapped address */
        uint32_t        sh_offset;           /* 0x10 Section location in file unless sh_type==SHT_NOBITS */
        uint32_t        sh_size;             /* 0x14 Section size in bytes */
        uint32_t        sh_link;             /* 0x18 Section ID of another section; meaning depends on section type */
        uint32_t        sh_info;             /* 0x1c Extra info depending on section type */
        uint32_t        sh_addralign;        /* 0x20 Mapped alignment (0 and 1=>byte aligned); sh_addr must be aligned*/
        uint32_t        sh_entsize;          /* 0x24 If non-zero, size in bytes of each array member in the section */
    }                                        /* 0x28 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SectionTableEntry_disk {
        uint32_t        sh_name;             /* 0x00 see Elf32SectionTableEntry_disk */
        uint32_t        sh_type;             /* 0x04 */
        uint64_t        sh_flags;            /* 0x08 */
        uint64_t        sh_addr;             /* 0x10 */
        uint64_t        sh_offset;           /* 0x18 */
        uint64_t        sh_size;             /* 0x20 */
        uint32_t        sh_link;             /* 0x28 */
        uint32_t        sh_info;             /* 0x2c */
        uint64_t        sh_addralign;        /* 0x30 */
        uint64_t        sh_entsize;          /* 0x38 */
    }                                        /* 0x40 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: sh_name.
     *
     *  The sh_name property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    unsigned const& get_sh_name() const;
    void set_sh_name(unsigned const&);
    /** @} */

public:
    /** Property: sh_type.
     *
     *  The sh_type property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    SgAsmElfSectionTableEntry::SectionType const& get_sh_type() const;
    void set_sh_type(SgAsmElfSectionTableEntry::SectionType const&);
    /** @} */

public:
    /** Property: sh_link.
     *
     *  The sh_link property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    unsigned long const& get_sh_link() const;
    void set_sh_link(unsigned long const&);
    /** @} */

public:
    /** Property: sh_info.
     *
     *  The sh_info property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    unsigned long const& get_sh_info() const;
    void set_sh_info(unsigned long const&);
    /** @} */

public:
    /** Property: sh_flags.
     *
     *  The sh_flags property of an ELF section table.  See official ELF specification. 
     *  
     *  @{ */
    uint64_t const& get_sh_flags() const;
    void set_sh_flags(uint64_t const&);
    /** @} */

public:
    /** Property: sh_addr.
     *
     *  The sh_addr property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_sh_addr() const;
    void set_sh_addr(rose_addr_t const&);
    /** @} */

public:
    /** Property: sh_offset.
     *
     *  The sh_offset property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_sh_offset() const;
    void set_sh_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: sh_size.
     *
     *  The sh_size property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_sh_size() const;
    void set_sh_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: sh_addralign.
     *
     *  The sh_addralign property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_sh_addralign() const;
    void set_sh_addralign(rose_addr_t const&);
    /** @} */

public:
    /** Property: sh_entsize.
     *
     *  The sh_entsize property of an ELF section table. See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_sh_entsize() const;
    void set_sh_entsize(rose_addr_t const&);
    /** @} */

public:
    /** Property: Extra bytes not officially part of the table entry.
     *
     *  These are the extra bytes that aren't assigned any meaning by the specification. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_extra() const;
    SgUnsignedCharList& get_extra();
    void set_extra(SgUnsignedCharList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Converts 32-bit disk representation to host representation. */
    SgAsmElfSectionTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                              const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);

    /** Converts 64-bit disk representation to host representation. */
    SgAsmElfSectionTableEntry(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                              const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);

    /** Encode a section table entry into the disk structure.
     *
     * @{ */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                 SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness sex,
                 SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk) const;
    /** @} */

    /** Update this section table entry with newer information from the section. */
    void updateFromSection(SgAsmElfSection*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    // Use Rose::stringify... function instead.
    static std::string toString(SgAsmElfSectionTableEntry::SectionType);
    static std::string toString(SgAsmElfSectionTableEntry::SectionFlags);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    void update_from_section(SgAsmElfSection*) ROSE_DEPRECATED("use updateFromSection");
    static std::string to_string(SgAsmElfSectionTableEntry::SectionType) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmElfSectionTableEntry::SectionFlags) ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmElfSectionTableEntry();

public:
    /** Default constructor. */
    SgAsmElfSectionTableEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSectionTableEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfRelocSection);
IS_SERIALIZABLE(AsmElfRelocSection);

#ifndef DOCUMENTATION
AsmElfRelocSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfRelocSection);
#if defined(SgAsmElfRelocSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfRelocSection_IMPL
#include <SgAsmElfRelocEntryList.h>
#endif
#endif // SgAsmElfRelocSection_HEADERS

#ifdef DOCUMENTATION
/** Represents an ELF relocation section. */
class SgAsmElfRelocSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocSection.setDataPrototype(
        "bool", "usesAddend", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocSection.setDataPrototype(
        "SgAsmElfSection*", "targetSection", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocSection.setDataPrototype(
        "SgAsmElfRelocEntryList*", "entries", "= createAndParent<SgAsmElfRelocEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfRelocSection);
#if defined(SgAsmElfRelocSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfRelocSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfRelocSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_usesAddend);
        s & BOOST_SERIALIZATION_NVP(p_targetSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfRelocSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Whether entries in this section use the addend format. 
     * 
     * @{ */
    bool const& get_usesAddend() const;
    void set_usesAddend(bool const&);
    /** @} */

public:
    /** Property: Section targeted by these relocations. 
     * 
     * @{ */
    SgAsmElfSection* const& get_targetSection() const;
    void set_targetSection(SgAsmElfSection* const&);
    /** @} */

public:
    /** Property: List of entries.
     *
     *  This is an AST node whose only purpose is to hold the list. It's done this way due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfRelocEntryList* const& get_entries() const;
    void set_entries(SgAsmElfRelocEntryList* const&);
    /** @} */
public:
    SgAsmElfRelocSection(SgAsmElfFileHeader *fhdr, SgAsmElfSymbolSection *symsec,SgAsmElfSection* targetsec);

    using SgAsmElfSection::calculateSizes;
    /** Parse an existing ELF Rela Section */
    virtual SgAsmElfRelocSection *parse() override;

    /** Return sizes for various parts of the table. See doc for SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    virtual bool reallocate() override;

    /** Write section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool get_uses_addend() const ROSE_DEPRECATED("use get_usesAddend");
    void set_uses_addend(bool) ROSE_DEPRECATED("use set_usesAddend");
    SgAsmElfSection* get_target_section() const ROSE_DEPRECATED("use get_targetSection");
    void set_target_section(SgAsmElfSection*) ROSE_DEPRECATED("use set_targetSection");
    using SgAsmElfSection::calculate_sizes;
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfRelocSection();

public:
    /** Default constructor. */
    SgAsmElfRelocSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfRelocEntryList);
IS_SERIALIZABLE(AsmElfRelocEntryList);

#ifndef DOCUMENTATION
AsmElfRelocEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfRelocEntryList);
#if defined(SgAsmElfRelocEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfRelocEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of ELF relocation entries.
 *
 *  The only purpose of this node is to hold a list of the actual relocation entry nodes since ROSETTA limitations prevent
 *  that list from being contained in the nodes where it's needed. */
class SgAsmElfRelocEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntryList.setDataPrototype(
        "SgAsmElfRelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfRelocEntryList);
#if defined(SgAsmElfRelocEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfRelocEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfRelocEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfRelocEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of relocation entries. 
     * 
     * @{ */
    SgAsmElfRelocEntryPtrList const& get_entries() const;
    SgAsmElfRelocEntryPtrList& get_entries();
    void set_entries(SgAsmElfRelocEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfRelocEntryList();

public:
    /** Default constructor. */
    SgAsmElfRelocEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfRelocEntry);
IS_SERIALIZABLE(AsmElfRelocEntry);

#ifndef DOCUMENTATION
AsmElfRelocEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfRelocEntry);
#if defined(SgAsmElfRelocEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <sageContainer.h>
#endif // SgAsmElfRelocEntry_HEADERS

#ifdef DOCUMENTATION
/** One entry of an ELF relocation table. */
class SgAsmElfRelocEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntry.setDataPrototype(
        "rose_addr_t", "r_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntry.setDataPrototype(
        "rose_addr_t", "r_addend", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntry.setDataPrototype(
        "unsigned long", "sym", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntry.setDataPrototype(
        "SgAsmElfRelocEntry::RelocType", "type", "= R_386_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfRelocEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfRelocEntry);
#if defined(SgAsmElfRelocEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfRelocEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfRelocEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_r_offset);
        s & BOOST_SERIALIZATION_NVP(p_r_addend);
        s & BOOST_SERIALIZATION_NVP(p_sym);
        s & BOOST_SERIALIZATION_NVP(p_type);
        s & BOOST_SERIALIZATION_NVP(p_extra);
        debugSerializationEnd("SgAsmElfRelocEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Relocation Type. In host order.  All other values are reserved. */
    enum RelocType{
        // Intel 80386 specific definitions.
        R_386_NONE         =0,  /**< No reloc */
        R_386_32           =1,  /**< Direct 32 bit  */
        R_386_PC32         =2,  /**< PC relative 32 bit */
        R_386_GOT32        =3,  /**< 32 bit GOT entry */
        R_386_PLT32        =4,  /**< 32 bit PLT address */
        R_386_COPY         =5,  /**< Copy symbol at runtime */
        R_386_GLOB_DAT     =6,  /**< Create GOT entry */
        R_386_JMP_SLOT     =7,  /**< Create PLT entry */
        R_386_RELATIVE     =8,  /**< Adjust by program base */
        R_386_GOTOFF       =9,  /**< 32 bit offset to GOT */
        R_386_GOTPC        =10, /**< 32 bit PC relative offset to GOT */
        R_386_32PLT        =11,
        R_386_TLS_TPOFF    =14, /**< Offset in static TLS block */
        R_386_TLS_IE       =15, /**< Address of GOT entry for static TLS block offset */
        R_386_TLS_GOTIE    =16, /**< GOT entry for static TLS block offset */
        R_386_TLS_LE       =17, /**< Offset relative to static TLS block */
        R_386_TLS_GD       =18, /**< Direct 32 bit for GNU version of general dynamic thread local data */
        R_386_TLS_LDM      =19, /**< Direct 32 bit for GNU version of local dynamic thread local data in LE code */
        R_386_16           =20,
        R_386_PC16         =21,
        R_386_8            =22,
        R_386_PC8          =23,
        R_386_TLS_GD_32    =24, /**< Direct 32 bit for general dynamic thread local data */
        R_386_TLS_GD_PUSH  =25, /**< Tag for pushl in GD TLS code */
        R_386_TLS_GD_CALL  =26, /**< Relocation for call to __tls_get_addr() */
        R_386_TLS_GD_POP   =27, /**< Tag for popl in GD TLS code */
        R_386_TLS_LDM_32   =28, /**< Direct 32 bit for local dynamic thread local data in LE code */
        R_386_TLS_LDM_PUSH =29, /**< Tag for pushl in LDM TLS code */
        R_386_TLS_LDM_CALL =30, /**< Relocation for call to __tls_get_addr() in LDM code */
        R_386_TLS_LDM_POP  =31, /**< Tag for popl in LDM TLS code */
        R_386_TLS_LDO_32   =32, /**< Offset relative to TLS block */
        R_386_TLS_IE_32    =33, /**< GOT entry for negated static TLS block offset */
        R_386_TLS_LE_32    =34, /**< Negated offset relative to static TLS block */
        R_386_TLS_DTPMOD32 =35, /**< ID of module containing symbol */
        R_386_TLS_DTPOFF32 =36, /**< Offset in TLS block */
        R_386_TLS_TPOFF32  =37, /**< Negated offset in static TLS block */

        // First Entry for X86-64
        R_X86_64_NONE     =100, /**<  No reloc */
        R_X86_64_64       =101, /**<  Direct 64 bit  */
        R_X86_64_PC32     =102, /**<  PC relative 32 bit signed */
        R_X86_64_GOT32    =103, /**<  32 bit GOT entry */
        R_X86_64_PLT32    =104, /**<  32 bit PLT address */
        R_X86_64_COPY     =105, /**<  Copy symbol at runtime */
        R_X86_64_GLOB_DAT =106, /**<  Create GOT entry */
        R_X86_64_JUMP_SLOT=107, /**<  Create PLT entry */
        R_X86_64_RELATIVE =108, /**<  Adjust by program base */
        R_X86_64_GOTPCREL =109, /**<  32 bit signed PC relative offset to GOT */
        R_X86_64_32       =110, /**<  Direct 32 bit zero extended */
        R_X86_64_32S      =111, /**<  Direct 32 bit sign extended */
        R_X86_64_16       =112, /**<  Direct 16 bit zero extended */
        R_X86_64_PC16     =113, /**<  16 bit sign extended pc relative */
        R_X86_64_8        =114, /**<  Direct 8 bit sign extended  */
        R_X86_64_PC8      =115, /**<  8 bit sign extended pc relative */
        R_X86_64_DTPMOD64 =116, /**<  ID of module containing symbol */
        R_X86_64_DTPOFF64 =117, /**<  Offset in module's TLS block */
        R_X86_64_TPOFF64  =118, /**<  Offset in initial TLS block */
        R_X86_64_TLSGD    =119, /**<  32 bit signed PC relative offset to two GOT entries for GD symbol */
        R_X86_64_TLSLD    =120, /**<  32 bit signed PC relative offset to two GOT entries for LD symbol */
        R_X86_64_DTPOFF32 =121, /**<  Offset in TLS block */
        R_X86_64_GOTTPOFF =122, /**<  32 bit signed PC relative offset to GOT entry for IE symbol */
        R_X86_64_TPOFF32  =123  /**<  Offset in initial TLS block */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    struct Elf32RelaEntry_disk {
        uint32_t        r_offset;
        uint32_t        r_info;
        uint32_t        r_addend;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64RelaEntry_disk {
        uint64_t        r_offset;
        uint64_t        r_info;
        uint64_t        r_addend;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf32RelEntry_disk {
        uint32_t        r_offset;
        uint32_t        r_info;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64RelEntry_disk {
        uint64_t        r_offset;
        uint64_t        r_info;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Offset.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    rose_addr_t const& get_r_offset() const;
    void set_r_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: Addend.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    rose_addr_t const& get_r_addend() const;
    void set_r_addend(rose_addr_t const&);
    /** @} */

public:
    /** Property: Sym.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_sym() const;
    void set_sym(unsigned long const&);
    /** @} */

public:
    /** Property: Type.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    SgAsmElfRelocEntry::RelocType const& get_type() const;
    void set_type(SgAsmElfRelocEntry::RelocType const&);
    /** @} */

public:
    /** Property: Value of padding bytes. 
     * 
     * @{ */
    SgUnsignedCharList const& get_extra() const;
    SgUnsignedCharList& get_extra();
    void set_extra(SgUnsignedCharList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that adds the new entry to the relocation table. */
    SgAsmElfRelocEntry(SgAsmElfRelocSection*);

    /** Initialize object by parsing from file.
     *
     * @{ */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf32RelaEntry_disk *disk);
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf64RelaEntry_disk *disk);
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf32RelEntry_disk *disk);
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf64RelEntry_disk *disk);
    /** @} */

    /** Convert object to on-disk format.
     *
     * @{ */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfRelocEntry::Elf32RelaEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfRelocEntry::Elf64RelaEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfRelocEntry::Elf32RelEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfRelocEntry::Elf64RelEntry_disk*) const;
    /** @} */

    /** Print debugging information.
     *
     * @{ */
    void dump(FILE *f, const char *prefix, ssize_t idx, SgAsmElfSymbolSection *symtab) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {
        dump(f, prefix, idx, NULL);
    }
    /** @} */

    /** Convert relocation to string for debugging. */
    std::string toString() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    std::string reloc_name() const ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmElfRelocEntry();

public:
    /** Default constructor. */
    SgAsmElfRelocEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfNoteSection);
IS_SERIALIZABLE(AsmElfNoteSection);

#ifndef DOCUMENTATION
AsmElfNoteSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfNoteSection);
#if defined(SgAsmElfNoteSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfNoteSection_IMPL
#include <SgAsmElfNoteEntryList.h>
#endif
#endif // SgAsmElfNoteSection_HEADERS

#ifdef DOCUMENTATION
class SgAsmElfNoteSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfNoteSection.setDataPrototype(
        "SgAsmElfNoteEntryList*", "entries", "= createAndParent<SgAsmElfNoteEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfNoteSection);
#if defined(SgAsmElfNoteSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfNoteSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfNoteSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfNoteSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of note entries.
     *
     *  This property points to an AST node that contains the list rather than being a list directly because of limitations
     *  of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfNoteEntryList* const& get_entries() const;
    void set_entries(SgAsmElfNoteEntryList* const&);
    /** @} */
public:
    /** Non-parsing constructor */
    explicit SgAsmElfNoteSection(SgAsmElfFileHeader*);

    virtual SgAsmElfNoteSection *parse() override;

    virtual bool reallocate() override;

    /** Write data to note section */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmElfNoteSection();

public:
    /** Default constructor. */
    SgAsmElfNoteSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfNoteEntryList);
IS_SERIALIZABLE(AsmElfNoteEntryList);

#ifndef DOCUMENTATION
AsmElfNoteEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfNoteEntryList);
#if defined(SgAsmElfNoteEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfNoteEntryList_HEADERS

#ifdef DOCUMENTATION
/** Node to hold list of ELF note entries.
 *
 *  This node's only purpose is to hold the list of pointers to note entries, which must be done like this because of
 *  limitations of ROSETTA. */
class SgAsmElfNoteEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfNoteEntryList.setDataPrototype(
        "SgAsmElfNoteEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfNoteEntryList);
#if defined(SgAsmElfNoteEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfNoteEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfNoteEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfNoteEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of ELF not entries. 
     * 
     * @{ */
    SgAsmElfNoteEntryPtrList const& get_entries() const;
    SgAsmElfNoteEntryPtrList& get_entries();
    void set_entries(SgAsmElfNoteEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfNoteEntryList();

public:
    /** Default constructor. */
    SgAsmElfNoteEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfNoteEntry);
IS_SERIALIZABLE(AsmElfNoteEntry);

#ifndef DOCUMENTATION
AsmElfNoteEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfNoteEntry);
#if defined(SgAsmElfNoteEntry_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>

#ifdef ROSE_SgAsmElfNoteEntry_IMPL
#include <SgAsmBasicString.h>
#endif
#endif // SgAsmElfNoteEntry_HEADERS

#ifdef DOCUMENTATION
/** One entry of an ELF notes table. */
class SgAsmElfNoteEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfNoteEntry.setDataPrototype(
        "unsigned", "type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfNoteEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfNoteEntry.setDataPrototype(
        "SgUnsignedCharList", "payload", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfNoteEntry);
#if defined(SgAsmElfNoteEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfNoteEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfNoteEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_type);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_payload);
        debugSerializationEnd("SgAsmElfNoteEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Type of note.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    unsigned const& get_type() const;
    void set_type(unsigned const&);
    /** @} */

public:
    /** Property: Note name.
     *
     *  A string note name stored in an ELF string table in the binary specimen. Changing the name of a note also changes
     *  the contents of the string table. 
     *  
     *  @{ */
    /** @} */

public:
    /** Property: Note payload.
     *
     *  This is the data associated with the note. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_payload() const;
    SgUnsignedCharList& get_payload();
    void set_payload(SgUnsignedCharList const&);
    /** @} */
public:
    /** Constructor adds the new note to the list of notes for the note section. */
    SgAsmElfNoteEntry(SgAsmElfNoteSection*);

    /** Property: Note name.
     *
     *  A string note name stored in an ELF string table in the binary specimen. Changing the name of a note also changes
     *  the contents of the string table.
     *
     * @{ */
    SgAsmGenericString *get_name() const;
    void set_name(SgAsmGenericString *name);
    /** @} */

    /** Initialize a note by parsing it from the specified location in the note section.
     *
     *  Return value is the offset to the beginning of the next note. */
    rose_addr_t parse(rose_addr_t starting_offset);

    /** Write a note at the specified offset to the section containing the note.
     *
     *  Returns the offset for the first byte past the end of the note. */
    rose_addr_t unparse(std::ostream &f, rose_addr_t starting_offset);

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Property: Note payload.
     *
     *  This is the data associated with the note. */
    void set_payload(const void*, size_t nbytes);

    /** Returns the number of bytes needed to store this note. */
    rose_addr_t calculateSize() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    rose_addr_t calculate_size() const ROSE_DEPRECATED("use calculateSize");
public:
    /** Destructor. */
    virtual ~SgAsmElfNoteEntry();

public:
    /** Default constructor. */
    SgAsmElfNoteEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfFileHeader);
IS_SERIALIZABLE(AsmElfFileHeader);

#ifndef DOCUMENTATION
AsmElfFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfFileHeader);
#if defined(SgAsmElfFileHeader_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmElfFileHeader_HEADERS

#ifdef DOCUMENTATION
/** Represents the file header of an ELF binary container.
 *
 *  The file header contains information that the operating system uses to find the various parts within the
 *  container. Most of the object properties are defined in the official ELF specification and their documentation is not
 *  replicated here.
 *
 *  ROSE does not require or use an ELF support library or headers and is thus able to parse ELF files on systems where ELF
 *  is not normally employed. */
class SgAsmElfFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_file_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_data_encoding", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_file_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "SgUnsignedCharList", "e_ident_padding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_machine", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_ehsize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "phextrasz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_phnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "shextrasz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_shnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_shstrndx", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "SgAsmElfSectionTable*", "sectionTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfFileHeader.setDataPrototype(
        "SgAsmElfSegmentTable*", "segmentTable", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfFileHeader);
#if defined(SgAsmElfFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_e_ident_file_class);
        s & BOOST_SERIALIZATION_NVP(p_e_ident_data_encoding);
        s & BOOST_SERIALIZATION_NVP(p_e_ident_file_version);
        s & BOOST_SERIALIZATION_NVP(p_e_ident_padding);
        s & BOOST_SERIALIZATION_NVP(p_e_type);
        s & BOOST_SERIALIZATION_NVP(p_e_machine);
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
        s & BOOST_SERIALIZATION_NVP(p_e_ehsize);
        s & BOOST_SERIALIZATION_NVP(p_phextrasz);
        s & BOOST_SERIALIZATION_NVP(p_e_phnum);
        s & BOOST_SERIALIZATION_NVP(p_shextrasz);
        s & BOOST_SERIALIZATION_NVP(p_e_shnum);
        s & BOOST_SERIALIZATION_NVP(p_e_shstrndx);
        s & BOOST_SERIALIZATION_NVP(p_sectionTable);
        s & BOOST_SERIALIZATION_NVP(p_segmentTable);
        debugSerializationEnd("SgAsmElfFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Enum for the @ref e_type property. */
    enum ObjectType {
        ET_NONE         = 0                         /**< No file type */
        ,ET_REL          = 1                        /**< Relocatable file */
        ,ET_EXEC         = 2                        /**< Executable file */
        ,ET_DYN          = 3                        /**< Shared object file */
        ,ET_CORE         = 4                        /**< Core file */

        ,ET_LOOS         = 0xfe00                   /**< OS-specific range start */
        ,ET_HIOS         = 0xfeff                   /**< OS-specific range end */
        ,ET_LOPROC       = 0xff00                   /**< Processor-specific range start */
        ,ET_HIPROC       = 0xffff                   /**< Processor-specific range end */
    };

    // Some structures are used to represent certain things whose layout is very precise in binary files, thus we need to
    // make sure the compiler doesn't insert alignment padding between the struct members.  ROSE can be compiled on an
    // architecture that has different alignment constraints than the architecture that these structs describe. GNU
    // compilers have long used the attribute mechanism. Microsoft compilers on the other hand use pragmas. GCC versions
    // 4.0 and earlier do not recognize the Microsoft pragmas and issue compiler errors when one is encountered.
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** File format of an ELF header.
     *
     *  Byte order of members depends on e_ident value. This code comes directly from "System V Application Binary
     *  Interface, Edition 4.1" and the FreeBSD elf(5) man page, and the "Executable and Linkable Format (ELF) Portable
     *  Formats Specifications, Version 1.2" and not from any header file. */
    struct Elf32FileHeader_disk {
        unsigned char       e_ident_magic[4];       /**< 0x7f, 'E', 'L', 'F' */
        unsigned char       e_ident_file_class;     /**< 1=>32-bit; 2=>64-bit; other is error */
        unsigned char       e_ident_data_encoding;  /**< 1=>LSB; 2=>MSB; other is error */
        unsigned char       e_ident_file_version;   /**< Format version number (same as e_version); must be 1 */
        unsigned char       e_ident_padding[9];     /**< Padding to byte 16; must be zero */
        uint16_t            e_type;                 /**< Object file type: relocatable, executable, lib, core */
        uint16_t            e_machine;              /**< Required architecture for an individual file */
        uint32_t            e_version;              /**< Object file version, currently zero or one */
        uint32_t            e_entry;                /**< Entry virtual address or zero if none */
        uint32_t            e_phoff;                /**< File offset of program header table or zero if none */
        uint32_t            e_shoff;                /**< File offset of section header table or zero if none */
        uint32_t            e_flags;                /**< Processor-specific flags (EF_* constants in docs) */
        uint16_t            e_ehsize;               /**< Size of ELF header in bytes */
        uint16_t            e_phentsize;            /**< Size of each entry in the program header table */
        uint16_t            e_phnum;                /**< Number of program headers, or PN_XNUM, or zero */
        uint16_t            e_shentsize;            /**< Size of each entry in the section header table */
        uint16_t            e_shnum;                /**< Number of section headers, or zero for extended entries */
        uint16_t            e_shstrndx;             /**< Index of name section, or SHN_UNDEF, or SHN_XINDEX */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64FileHeader_disk {
        unsigned char       e_ident_magic[4];
        unsigned char       e_ident_file_class;
        unsigned char       e_ident_data_encoding;
        unsigned char       e_ident_file_version;
        unsigned char       e_ident_padding[9];
        uint16_t            e_type;
        uint16_t            e_machine;
        uint32_t            e_version;
        uint64_t            e_entry;
        uint64_t            e_phoff;
        uint64_t            e_shoff;
        uint32_t            e_flags;
        uint16_t            e_ehsize;
        uint16_t            e_phentsize;
        uint16_t            e_phnum;
        uint16_t            e_shentsize;
        uint16_t            e_shnum;
        uint16_t            e_shstrndx;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: File class.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned char const& get_e_ident_file_class() const;
    void set_e_ident_file_class(unsigned char const&);
    /** @} */

public:
    /** Property: Data encoding.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned char const& get_e_ident_data_encoding() const;
    void set_e_ident_data_encoding(unsigned char const&);
    /** @} */

public:
    /** Property: File version.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned char const& get_e_ident_file_version() const;
    void set_e_ident_file_version(unsigned char const&);
    /** @} */

public:
    /** Property: Padding.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_e_ident_padding() const;
    void set_e_ident_padding(SgUnsignedCharList const&);
    /** @} */

public:
    /** Property: Type.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_type() const;
    void set_e_type(unsigned long const&);
    /** @} */

public:
    /** Property: Machine.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_machine() const;
    void set_e_machine(unsigned long const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_flags() const;
    void set_e_flags(unsigned long const&);
    /** @} */

public:
    /** Property: ehsize.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_ehsize() const;
    void set_e_ehsize(unsigned long const&);
    /** @} */

public:
    /** Property: phextrasz.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_phextrasz() const;
    void set_phextrasz(unsigned long const&);
    /** @} */

public:
    /** Property: phnum.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_phnum() const;
    void set_e_phnum(unsigned long const&);
    /** @} */

public:
    /** Property: shextrasz.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_shextrasz() const;
    void set_shextrasz(unsigned long const&);
    /** @} */

public:
    /** Property: shnum.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_shnum() const;
    void set_e_shnum(unsigned long const&);
    /** @} */

public:
    /** Property: shstrndx.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    unsigned long const& get_e_shstrndx() const;
    void set_e_shstrndx(unsigned long const&);
    /** @} */

public:
    /** Property: Section table.
     *
     *  Points to the AST node that represents the ELF section table that describes each section of the file. ELF sections
     *  are generally those parts of the file that are of interest to linkers, debuggers, etc. but not needed by the
     *  program loader. 
     *  
     *  @{ */
    SgAsmElfSectionTable* const& get_sectionTable() const;
    void set_sectionTable(SgAsmElfSectionTable* const&);
    /** @} */

public:
    /** Property: Segment table.
     *
     *  Points to the AST node that represents the ELF segment table that describes each segment of the file. Segments
     *  describe how parts of the file are mapped into virtual memory by the loader. 
     *  
     *  @{ */
    SgAsmElfSegmentTable* const& get_segmentTable() const;
    void set_segmentTable(SgAsmElfSegmentTable* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Construct a new ELF File Header with default values.
     *
     *  The new section is placed at file offset zero and the size is initially one byte (calling @ref parse will extend it
     *  as necessary). Setting the initial size of non-parsed sections to a positive value works better when adding
     *  sections to the end-of-file since the sections will all have different starting offsets and therefore @ref
     *  SgAsmGenericFile::shiftExtend will know what order the sections should be in when they are eventually resized. */
    explicit SgAsmElfFileHeader(SgAsmGenericFile*);

    /** Maximum page size according to the ABI.
     *
     *  This is used by the loader when calculating the program base address. Since parts of the file are mapped into the
     *  process address space those parts must be aligned (both in the file and in memory) on the largest possible page
     *  boundary so that any smaller page boundary will also work correctly. */
    uint64_t maximumPageSize();

    /** Convert ELF "machine" identifier to generic instruction set architecture value. */
    static SgAsmExecutableFileFormat::InsSetArchitecture machineToIsa(unsigned machine);

    /** Convert architecture value to an ELF "machine" value. */
    unsigned isaToMachine(SgAsmExecutableFileFormat::InsSetArchitecture isa) const;

    /** Parse header from file.
     *
     *  Initialize this header with information parsed from the file and construct and parse everything that's reachable
     *  from the header. Since the size of the ELF File Header is determined by the contents of the ELF File Header as
     *  stored in the file, the size of the ELF File Header will be adjusted upward if necessary. */
    virtual SgAsmElfFileHeader *parse() override;

    virtual bool reallocate() override;

    /** Write ELF contents back to a file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Return true if the file looks like it might be an ELF file according to the magic number. */
    static bool isElf(SgAsmGenericFile*);

    /** Get the list of sections defined in the ELF Section Table */
    SgAsmGenericSectionPtrList get_sectionTableSections();

    /** Get the list of sections defined in the ELF Segment Table */
    SgAsmGenericSectionPtrList get_segmentTableSections();

    // Overrides documented in base class
    virtual const char *formatName() const override;

private:
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfFileHeader::Elf32FileHeader_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfFileHeader::Elf64FileHeader_disk*) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmElfSectionTable* get_section_table() const ROSE_DEPRECATED("use get_sectionTable");
    void set_section_table(SgAsmElfSectionTable*) ROSE_DEPRECATED("use set_sectionTable");
    SgAsmElfSegmentTable* get_segment_table() const ROSE_DEPRECATED("use get_segmentTable");
    void set_segment_table(SgAsmElfSegmentTable*) ROSE_DEPRECATED("use set_segmentTable");
    uint64_t max_page_size() ROSE_DEPRECATED("use maximumPageSize");
    static SgAsmExecutableFileFormat::InsSetArchitecture machine_to_isa(unsigned) ROSE_DEPRECATED("use machineToIsa");
    unsigned isa_to_machine(SgAsmExecutableFileFormat::InsSetArchitecture) const ROSE_DEPRECATED("use isaToMachine");
    static bool is_ELF(SgAsmGenericFile*) ROSE_DEPRECATED("use isElf");
    SgAsmGenericSectionPtrList get_sectab_sections() ROSE_DEPRECATED("use get_sectionTableSections");
    SgAsmGenericSectionPtrList get_segtab_sections() ROSE_DEPRECATED("use get_segmentTableSections");
    virtual const char *format_name() const override ROSE_DEPRECATED("use formatName");
public:
    /** Destructor. */
    virtual ~SgAsmElfFileHeader();

public:
    /** Default constructor. */
    SgAsmElfFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfEHFrameSection);
IS_SERIALIZABLE(AsmElfEHFrameSection);

#ifndef DOCUMENTATION
AsmElfEHFrameSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfEHFrameSection);
#if defined(SgAsmElfEHFrameSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfEHFrameSection_IMPL
#include <SgAsmElfEHFrameEntryCIList.h>
#endif
#endif // SgAsmElfEHFrameSection_HEADERS

#ifdef DOCUMENTATION
/** Represents an ELF EH frame section. */
class SgAsmElfEHFrameSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameSection.setDataPrototype(
        "SgAsmElfEHFrameEntryCIList*", "ci_entries", "= createAndParent<SgAsmElfEHFrameEntryCIList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfEHFrameSection);
#if defined(SgAsmElfEHFrameSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfEHFrameSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfEHFrameSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_ci_entries);
        debugSerializationEnd("SgAsmElfEHFrameSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: CI entries.
     *
     *  See official ELF specification.  This property points to an AST node containing the list rather than the direct
     *  list due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfEHFrameEntryCIList* const& get_ci_entries() const;
    void set_ci_entries(SgAsmElfEHFrameEntryCIList* const&);
    /** @} */
public:
    /** Non-parsing constructor. */
    explicit SgAsmElfEHFrameSection(SgAsmElfFileHeader*);

    /** Initialize by parsing a file. */
    virtual SgAsmElfEHFrameSection *parse() override;

    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculateSizes. Since EH Frame Sections are run-length encoded, we
     *  need to actually unparse the section in order to determine its size. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    /** Write data to .eh_frame section */
    virtual void unparse(std::ostream&) const override;

    /** Unparses the section into the optional output stream and returns the number of bytes written.
     *
     *  If there is no output stream we still go through the actions but don't write anything. This is the only way to
     *  determine the amount of memory required to store the section since the section is run-length encoded. */
    rose_addr_t unparse(std::ostream*) const;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameSection();

public:
    /** Default constructor. */
    SgAsmElfEHFrameSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryFDList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfEHFrameEntryFDList);
IS_SERIALIZABLE(AsmElfEHFrameEntryFDList);

#ifndef DOCUMENTATION
AsmElfEHFrameEntryFDList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfEHFrameEntryFDList);
#if defined(SgAsmElfEHFrameEntryFDList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfEHFrameEntryFDList_HEADERS

#ifdef DOCUMENTATION
/** List of ELF error handling frame descriptor entries.
 *
 *  The only purpose of this node is to hold the list of pointers to FD entries, and is necesssary due to limitations of
 *  ROSETTA. */
class SgAsmElfEHFrameEntryFDList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryFDList.setDataPrototype(
        "SgAsmElfEHFrameEntryFDPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfEHFrameEntryFDList);
#if defined(SgAsmElfEHFrameEntryFDList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfEHFrameEntryFDList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfEHFrameEntryFDList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfEHFrameEntryFDList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to error handling frame descriptor entries. 
     * 
     * @{ */
    SgAsmElfEHFrameEntryFDPtrList const& get_entries() const;
    SgAsmElfEHFrameEntryFDPtrList& get_entries();
    void set_entries(SgAsmElfEHFrameEntryFDPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryFDList();

public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryFDList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryFDList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryFD           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfEHFrameEntryFD);
IS_SERIALIZABLE(AsmElfEHFrameEntryFD);

#ifndef DOCUMENTATION
AsmElfEHFrameEntryFD.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfEHFrameEntryFD);
#if defined(SgAsmElfEHFrameEntryFD_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <sageContainer.h>
#endif // SgAsmElfEHFrameEntryFD_HEADERS

#ifdef DOCUMENTATION
/** ELF error handling frame entry frame description entry. */
class SgAsmElfEHFrameEntryFD: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryFD.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "begin_rva", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryFD.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryFD.setDataPrototype(
        "SgUnsignedCharList", "augmentation_data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryFD.setDataPrototype(
        "SgUnsignedCharList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfEHFrameEntryFD);
#if defined(SgAsmElfEHFrameEntryFD_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfEHFrameEntryFD -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfEHFrameEntryFD");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_begin_rva);
        s & BOOST_SERIALIZATION_NVP(p_size);
        s & BOOST_SERIALIZATION_NVP(p_augmentation_data);
        s & BOOST_SERIALIZATION_NVP(p_instructions);
        debugSerializationEnd("SgAsmElfEHFrameEntryFD");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Beginning relative virtual address.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_begin_rva() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_begin_rva();
    void set_begin_rva(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Size in bytes.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_size() const;
    void set_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Augmentation data.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_augmentation_data() const;
    SgUnsignedCharList& get_augmentation_data();
    void set_augmentation_data(SgUnsignedCharList const&);
    /** @} */

public:
    /** Property: Instructions.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_instructions() const;
    SgUnsignedCharList& get_instructions();
    void set_instructions(SgUnsignedCharList const&);
    /** @} */
public:
    /** Non-parsing constructor */
    explicit SgAsmElfEHFrameEntryFD(SgAsmElfEHFrameEntryCI*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Unparse to string.
     *
     *  Unparses the frame description entry (FDE) into a string but do not include the leading length field(s) or the CIE
     *  back pointer. */
    std::string unparse(const SgAsmElfEHFrameSection*, SgAsmElfEHFrameEntryCI*) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryFD();

public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryFD();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryFD_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryCIList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfEHFrameEntryCIList);
IS_SERIALIZABLE(AsmElfEHFrameEntryCIList);

#ifndef DOCUMENTATION
AsmElfEHFrameEntryCIList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfEHFrameEntryCIList);
#if defined(SgAsmElfEHFrameEntryCIList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfEHFrameEntryCIList_HEADERS

#ifdef DOCUMENTATION
/** List of ELF EH frame CI entries.
 *
 *  See official ELF specification. The only reason this node exists is because of ROSETTA limitations which prevent the
 *  list from being stored directly in the class that needs it. */
class SgAsmElfEHFrameEntryCIList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCIList.setDataPrototype(
        "SgAsmElfEHFrameEntryCIPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfEHFrameEntryCIList);
#if defined(SgAsmElfEHFrameEntryCIList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfEHFrameEntryCIList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfEHFrameEntryCIList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfEHFrameEntryCIList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of pointers to ELF EH frame CI entries. 
     * 
     * @{ */
    SgAsmElfEHFrameEntryCIPtrList const& get_entries() const;
    SgAsmElfEHFrameEntryCIPtrList& get_entries();
    void set_entries(SgAsmElfEHFrameEntryCIPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryCIList();

public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryCIList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryCIList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryCI           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfEHFrameEntryCI);
IS_SERIALIZABLE(AsmElfEHFrameEntryCI);

#ifndef DOCUMENTATION
AsmElfEHFrameEntryCI.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfEHFrameEntryCI);
#if defined(SgAsmElfEHFrameEntryCI_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>

#ifdef ROSE_SgAsmElfEHFrameEntryCI_IMPL
#include <SgAsmElfEHFrameEntryFDList.h>
#endif
#endif // SgAsmElfEHFrameEntryCI_HEADERS

#ifdef DOCUMENTATION
/** ELF error handling frame entry, common information entry.
 *
 *  Most of the properties of this class are documented in the official ELF specification. */
class SgAsmElfEHFrameEntryCI: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "std::string", "augmentation_string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "eh_data", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "code_alignment_factor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int64_t", "data_alignment_factor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "augmentation_data_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "lsda_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "prh_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "unsigned", "prh_arg", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "rose_addr_t", "prh_addr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "addr_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "bool", "sig_frame", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "SgUnsignedCharList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfEHFrameEntryCI.setDataPrototype(
        "SgAsmElfEHFrameEntryFDList*", "fd_entries", "= createAndParent<SgAsmElfEHFrameEntryFDList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfEHFrameEntryCI);
#if defined(SgAsmElfEHFrameEntryCI_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfEHFrameEntryCI -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfEHFrameEntryCI");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_version);
        s & BOOST_SERIALIZATION_NVP(p_augmentation_string);
        s & BOOST_SERIALIZATION_NVP(p_eh_data);
        s & BOOST_SERIALIZATION_NVP(p_code_alignment_factor);
        s & BOOST_SERIALIZATION_NVP(p_data_alignment_factor);
        s & BOOST_SERIALIZATION_NVP(p_augmentation_data_length);
        s & BOOST_SERIALIZATION_NVP(p_lsda_encoding);
        s & BOOST_SERIALIZATION_NVP(p_prh_encoding);
        s & BOOST_SERIALIZATION_NVP(p_prh_arg);
        s & BOOST_SERIALIZATION_NVP(p_prh_addr);
        s & BOOST_SERIALIZATION_NVP(p_addr_encoding);
        s & BOOST_SERIALIZATION_NVP(p_sig_frame);
        s & BOOST_SERIALIZATION_NVP(p_instructions);
        s & BOOST_SERIALIZATION_NVP(p_fd_entries);
        debugSerializationEnd("SgAsmElfEHFrameEntryCI");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Version number.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    int const& get_version() const;
    void set_version(int const&);
    /** @} */

public:
    /** Property: Augmentation string.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    std::string const& get_augmentation_string() const;
    void set_augmentation_string(std::string const&);
    /** @} */

public:
    /** Property: Data value.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    uint64_t const& get_eh_data() const;
    void set_eh_data(uint64_t const&);
    /** @} */

public:
    /** Property: Code alignment factor.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    uint64_t const& get_code_alignment_factor() const;
    void set_code_alignment_factor(uint64_t const&);
    /** @} */

public:
    /** Property: Data alignment factor.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    int64_t const& get_data_alignment_factor() const;
    void set_data_alignment_factor(int64_t const&);
    /** @} */

public:
    /** Property: Augmentation data length.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    uint64_t const& get_augmentation_data_length() const;
    void set_augmentation_data_length(uint64_t const&);
    /** @} */

public:
    /** Property: LSDA encoding.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    int const& get_lsda_encoding() const;
    void set_lsda_encoding(int const&);
    /** @} */

public:
    /** Property: PRH encoding.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    int const& get_prh_encoding() const;
    void set_prh_encoding(int const&);
    /** @} */

public:
    /** Property: PRH argument.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    unsigned const& get_prh_arg() const;
    void set_prh_arg(unsigned const&);
    /** @} */

public:
    /** Property: PRH address.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    rose_addr_t const& get_prh_addr() const;
    void set_prh_addr(rose_addr_t const&);
    /** @} */

public:
    /** Property: Address encoding.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    int const& get_addr_encoding() const;
    void set_addr_encoding(int const&);
    /** @} */

public:
    /** Property: Signal frame.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    bool const& get_sig_frame() const;
    void set_sig_frame(bool const&);
    /** @} */

public:
    /** Property: Instructions.
     *
     *  See official ELF specification. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_instructions() const;
    SgUnsignedCharList& get_instructions();
    void set_instructions(SgUnsignedCharList const&);
    /** @} */

public:
    /** Property: FD entries.
     *
     *  See official ELF specification. This points to an AST node that holds the list of pointers to the actual entry
     *  nodes due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfEHFrameEntryFDList* const& get_fd_entries() const;
    void set_fd_entries(SgAsmElfEHFrameEntryFDList* const&);
    /** @} */
public:
    /** Non-parsing constructor */
    explicit SgAsmElfEHFrameEntryCI(SgAsmElfEHFrameSection *ehframe);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Unparse an entry.
     *
     *  Unparse one Common Information Entry (CIE) without unparsing the Frame Description Entries (FDE) to which it
     *  points. The initial length fields are not included in the result string. */
    std::string unparse(const SgAsmElfEHFrameSection*) const;
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryCI();

public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryCI();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryCI_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfDynamicSection);
IS_SERIALIZABLE(AsmElfDynamicSection);

#ifndef DOCUMENTATION
AsmElfDynamicSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfDynamicSection);
#if defined(SgAsmElfDynamicSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfDynamicSection_IMPL
#include <SgAsmElfDynamicEntryList.h>
#endif
#endif // SgAsmElfDynamicSection_HEADERS

#ifdef DOCUMENTATION
/** ELF section containing dynamic linking information. */
class SgAsmElfDynamicSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicSection.setDataPrototype(
        "SgAsmElfDynamicEntryList*", "entries", "= createAndParent<SgAsmElfDynamicEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfDynamicSection);
#if defined(SgAsmElfDynamicSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfDynamicSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfDynamicSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfDynamicSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries.
     *
     *  This points to a node whose only purpose is to hold the list. The list cannot be contained directly here where it's
     *  needed due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmElfDynamicEntryList* const& get_entries() const;
    void set_entries(SgAsmElfDynamicEntryList* const&);
    /** @} */
public:
    /** Constructor that links object into the AST. */
    SgAsmElfDynamicSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initialize object by parsing file. */
    virtual SgAsmElfDynamicSection* parse() override;

    /** Finish initializing the section entries. */
    virtual void finishParsing() override;

    using SgAsmElfSection::calculateSizes;
    /** Return sizes for various parts of the table. See documentation for @ref SgAsmElfSection::calculateSizes. */
    virtual rose_addr_t calculateSizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    virtual bool reallocate() override;

    /** Write the dynamic section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    virtual void finish_parsing() override ROSE_DEPRECATED("use finishParsing") ROSE_DEPRECATED("use finishParsing");
    using SgAsmElfSection::calculate_sizes;
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const override ROSE_DEPRECATED("use calculateSizes");
public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicSection();

public:
    /** Default constructor. */
    SgAsmElfDynamicSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmElfSection = nonTerminalConstructor(
    "AsmElfSection",
    *this,
    "AsmElfSection",
    "AsmElfSectionTag",
    SubclassListBuilder()
        | AsmElfDynamicSection
        | AsmElfEHFrameSection
        | AsmElfNoteSection
        | AsmElfRelocSection
        | AsmElfStringSection
        | AsmElfSymbolSection
        | AsmElfSymverDefinedSection
        | AsmElfSymverNeededSection
        | AsmElfSymverSection
    , true);
assert(AsmElfSection.associatedGrammar != nullptr);
AsmElfSection.setCppCondition("!defined(DOCUMENTATION)");
AsmElfSection.isBoostSerializable(true);
AsmElfSection.setAutomaticGenerationOfConstructor(false);
AsmElfSection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmElfSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfSection);
#if defined(SgAsmElfSection_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmElfSection_IMPL
#include <SgAsmElfSectionTableEntry.h>
#include <SgAsmElfSegmentTableEntry.h>
#endif
#endif // SgAsmElfSection_HEADERS

#ifdef DOCUMENTATION
/** Base class for ELF file sections. */
class SgAsmElfSection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSection.setDataPrototype(
        "SgAsmElfSection*", "linkedSection", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSection.setDataPrototype(
        "SgAsmElfSectionTableEntry*", "sectionEntry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfSection.setDataPrototype(
        "SgAsmElfSegmentTableEntry*", "segmentEntry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfSection);
#if defined(SgAsmElfSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_linkedSection);
        s & BOOST_SERIALIZATION_NVP(p_sectionEntry);
        s & BOOST_SERIALIZATION_NVP(p_segmentEntry);
        debugSerializationEnd("SgAsmElfSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Linked section.
     *
     *  Points to an optional related section. See official ELF specification.
     *
     * @{ */
    SgAsmElfSection* const& get_linkedSection() const;
    virtual void set_linkedSection(SgAsmElfSection*);
    /** @} */
public:
    /** Property: The section table entry corresponding to this section. 
     * 
     * @{ */
    SgAsmElfSectionTableEntry* const& get_sectionEntry() const;
    void set_sectionEntry(SgAsmElfSectionTableEntry* const&);
    /** @} */

public:
    /** Property: The segment table entry corresponding to this section. 
     * 
     * @{ */
    SgAsmElfSegmentTableEntry* const& get_segmentEntry() const;
    void set_segmentEntry(SgAsmElfSegmentTableEntry* const&);
    /** @} */
public:
    /** Constructor for sections not yet in a table.
     *
     *  This constructs a section that is in neither the ELF Section Table nor the ELF Segment Table yet, but eventually
     *  will be. */
    explicit SgAsmElfSection(SgAsmGenericHeader*);

    /** Initializes the section from data parsed from the ELF Section Table.
     *
     *  This includes the section name, offset, size, memory mapping, and alignments. The @p id is the index into the section
     *  table. This function complements @ref SgAsmElfSectionTable::addSection in that this function initializes this section from
     *  the section table while @ref SgAsmElfSectionTable::addSection initializes the section table from the section. */
    SgAsmElfSection *initFromSectionTable(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int id);

    /** Initializes the section from data parse from the ELF Segment Table.
     *
     *  This is similar to @ref initFromSectionTable but for segments instead of sections. */
    SgAsmElfSection *initFromSegmentTable(SgAsmElfSegmentTableEntry*, bool mmapOnly=false);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. Return values are:
     *
     *  @li @p entsize is the size of each entry, sum of required and optional parts. This comes from the sh_entsize member
     *  of this section's ELF Section Table Entry, adjusted upward to be large enough to hold the required part of each
     *  entry (see "required").
     *
     *  @li @p required is the size of the required (leading) part of each entry. The size of the required part is based
     *  on the ELF word size.
     *
     *  @li @p optional is the size of the optional (trailing) part of each entry. If the section has been parsed then
     *  the optional size will be calculated from the entry with the largest "extra" (aka, optional) data. Otherwise this
     *  is calculated as the difference between the @p entsize" and the @p required" sizes.
     *
     *  @li entcount is the total number of entries in this section. If the section has been parsed then this is the
     *  actual number of parsed entries, otherwise its the section size divided by the @p entsize.
     *
     *  Return value is the total size needed for the section. In all cases, it is the product of @p entsize and @p
     *  entcount. */
    rose_addr_t calculateSizes(size_t r32size, size_t r64size, const std::vector<size_t> &optsizes,
                               size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    virtual void finishParsing();

    /** Base implementation for calculating sizes.
     *
     *  Most subclasses will override this virtual function in order to return more useful values. This implementation
     *  returns the following values:
     *
     *  @li @p entsize is size stored in the ELF Section Table's sh_entsize member, or size of entire section if not a
     *  table.
     *
     *  @li @p required is the same as @p entsize.
     *
     *  @li @p optional is zero.
     *
     *  @li @p entcount is the number of entries, each of size entsize, that can fit in the section.
     *
     *  The return size is the product of @p entsize and @p entcount, which, if this section is a table (nonzero
     *  sh_entsize), could be smaller than the total size of the section. */
    virtual rose_addr_t calculateSizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    virtual bool reallocate() override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Make this section's name to be stored in the specified string table. */
    void allocateNameToStorage(SgAsmElfStringSection*);

    /** Obtain ELF header.
     *
     *  This is just a convenience function so we don't need to constantly cast the return value from the @ref header property. */
    SgAsmElfFileHeader *get_elfHeader() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmElfSection* get_linked_section() const ROSE_DEPRECATED("use get_linkedSection");
    virtual void set_linked_section(SgAsmElfSection*) ROSE_DEPRECATED("use set_linkSection");
    SgAsmElfSectionTableEntry* get_section_entry() const ROSE_DEPRECATED("use get_sectionEntry");
    void set_section_entry(SgAsmElfSectionTableEntry*) ROSE_DEPRECATED("use set_sectionEntry");
    SgAsmElfSegmentTableEntry* get_segment_entry() const ROSE_DEPRECATED("use get_segmentEntry");
    void set_segment_entry(SgAsmElfSegmentTableEntry*) ROSE_DEPRECATED("use set_segmentEntry");
    SgAsmElfSection *init_from_section_table(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int)
        ROSE_DEPRECATED("use initFromSectionTable");
    SgAsmElfSection *init_from_segment_table(SgAsmElfSegmentTableEntry*, bool mmap_only=false)
        ROSE_DEPRECATED("use initFromSegmentTable");
    rose_addr_t calculate_sizes(size_t, size_t, const std::vector<size_t>&, size_t*, size_t*, size_t*, size_t*) const
        ROSE_DEPRECATED("use calculateSizes");
    virtual void finish_parsing() ROSE_DEPRECATED("use finishParsing");
    virtual rose_addr_t calculate_sizes(size_t*, size_t*, size_t*, size_t*) const ROSE_DEPRECATED("use calculateSizes");
    void allocate_name_to_storage(SgAsmElfStringSection*) ROSE_DEPRECATED("use allocateNameToStorage");
    SgAsmElfFileHeader *get_elf_header() const ROSE_DEPRECATED("use get_elfHeader");
public:
    /** Destructor. */
    virtual ~SgAsmElfSection();

public:
    /** Default constructor. */
    SgAsmElfSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfDynamicEntryList);
IS_SERIALIZABLE(AsmElfDynamicEntryList);

#ifndef DOCUMENTATION
AsmElfDynamicEntryList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfDynamicEntryList);
#if defined(SgAsmElfDynamicEntryList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmElfDynamicEntryList_HEADERS

#ifdef DOCUMENTATION
/** List of dynamic linking section entries.
 *
 *  The only purpose of this node is to hold a list which, due to ROSETTA limitations, cannot be contained in the objects
 *  that actually need it. */
class SgAsmElfDynamicEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicEntryList.setDataPrototype(
        "SgAsmElfDynamicEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfDynamicEntryList);
#if defined(SgAsmElfDynamicEntryList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfDynamicEntryList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfDynamicEntryList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_entries);
        debugSerializationEnd("SgAsmElfDynamicEntryList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of entries. 
     * 
     * @{ */
    SgAsmElfDynamicEntryPtrList const& get_entries() const;
    SgAsmElfDynamicEntryPtrList& get_entries();
    void set_entries(SgAsmElfDynamicEntryPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicEntryList();

public:
    /** Default constructor. */
    SgAsmElfDynamicEntryList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicEntryList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmElfDynamicEntry);
IS_SERIALIZABLE(AsmElfDynamicEntry);

#ifndef DOCUMENTATION
AsmElfDynamicEntry.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmElfDynamicEntry);
#if defined(SgAsmElfDynamicEntry_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <sageContainer.h>
#endif // SgAsmElfDynamicEntry_HEADERS

#ifdef DOCUMENTATION
/** One entry from the dynamic linking table. */
class SgAsmElfDynamicEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicEntry.setDataPrototype(
        "SgAsmElfDynamicEntry::EntryType", "d_tag", "= SgAsmElfDynamicEntry::DT_NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicEntry.setDataPrototype(
        "Rose::BinaryAnalysis::RelativeVirtualAddress", "d_val", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmElfDynamicEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmElfDynamicEntry);
#if defined(SgAsmElfDynamicEntry_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmElfDynamicEntry -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmElfDynamicEntry");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_d_tag);
        s & BOOST_SERIALIZATION_NVP(p_d_val);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_extra);
        debugSerializationEnd("SgAsmElfDynamicEntry");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum EntryType {                /* Type    Executable SharedObj Purpose */
        DT_NULL     = 0,        /* ignored mandatory  mandatory Marks end of dynamic array */
        DT_NEEDED   = 1,        /* value   optional   optional  Name of needed library */
        DT_PLTRELSZ = 2,        /* value   optional   optional  Size of reloc entries associated with PLT */
        DT_PLTGOT   = 3,        /* pointer optional   optional  PLT and/or GOT */
        DT_HASH     = 4,        /* pointer mandatory  mandatory Symbol hash table */
        DT_STRTAB   = 5,        /* pointer mandatory  mandatory String table for symbols, lib names, etc. */
        DT_SYMTAB   = 6,        /* pointer mandatory  mandatory Symbol table */
        DT_RELA     = 7,        /* pointer mandatory  optional  Relocation table */
        DT_RELASZ   = 8,        /* value   mandatory  optional  Size of RELA relocation table */
        DT_RELAENT  = 9,        /* value   mandatory  optional  Size of each RELA table entry */
        DT_STRSZ    = 10,       /* value   mandatory  mandatory Size of string table */
        DT_SYMENT   = 11,       /* value   mandatory  mandatory Size of symbol table entry */
        DT_INIT     = 12,       /* pointer optional   optional  Initialization function */
        DT_FINI     = 13,       /* pointer optional   optional  Termination function */
        DT_SONAME   = 14,       /* value   ignored    optional  Name of shared object */
        DT_RPATH    = 15,       /* value   optional   ignored   NUL-term library search path */
        DT_SYMBOLIC = 16,       /* ignored ignored    optional  Bool determines dynamic linker symbol resolution */
        DT_REL      = 17,       /* pointer mandatory  optional  Relocation table */
        DT_RELSZ    = 18,       /* value   mandatory  optional  Size of REL relocation table */
        DT_RELENT   = 19,       /* value   mandatory  optional  Size of each REL table entry */
        DT_PLTREL   = 20,       /* value   optional   optional  Reloc type for PLT; value is DT_RELA or DT_REL */
        DT_DEBUG    = 21,       /* pointer optional   ignored   Contents are not specified at ABI level */
        DT_TEXTREL  = 22,       /* ignored optional   optional  presence => relocs to nonwritable segments OK */
        DT_JMPREL   = 23,       /* pointer optional   optional  Addr of relocation entries for PLT */
        DT_BIND_NOW = 24,       /* ignored optional   optional  Shall dynlinker do relocs before xfering control?*/
        DT_INIT_ARRAY = 25,     /* pointer optional   ?         Array with addresses of init fct */
        DT_FINI_ARRAY = 26,     /* pointer optional   ?         Array with address of fini fct */
        DT_INIT_ARRAYSZ = 27,   /* value   optional   ?         Size in bytes of DT_INIT_ARRAY */
        DT_FINI_ARRAYSZ = 28,   /* value   optional   ?         Size in bytes of DT_FINI_ARRAY */
        DT_RUNPATH  = 29,       /* ?       optional   ?         Library search path (how diff from DT_RPATH?) */
        DT_FLAGS    = 30,       /* value   optional   ?         Bit flags */
        DT_PREINIT_ARRAY = 32,  /* pointer optional   ?         Array with addrs of preinit fct (aka DT_ENCODING)*/
        DT_PREINIT_ARRAYSZ = 33,/* value   optional   ?         size in bytes of DT_PREINIT_ARRAY */
        DT_NUM      = 34,       /* ?       ?          ?         "number used"? */

        DT_GNU_PRELINKED =0x6ffffdf5,/*value ?          ?         Prelinking time stamp */
        DT_GNU_CONFLICTSZ=0x6ffffdf6,/*value ?          ?         Size of conflict section */
        DT_GNU_LIBLISTSZ=0x6ffffdf7,/*value  ?          ?         Size of library list */
        DT_CHECKSUM = 0x6ffffdf8, /* value   ?          ?         ? */
        DT_PLTPADSZ = 0x6ffffdf9, /* value   ?          ?         ? */
        DT_MOVEENT  = 0x6ffffdfa, /* value   ?          ?         ? */
        DT_MOVESZ   = 0x6ffffdfb, /* value   ?          ?         ? */
        DT_FEATURE_1= 0x6ffffdfc, /* value   ?          ?         Feature selection (DTF_*) */
        DT_POSFLAG_1= 0x6ffffdfd, /* value   ?          ?         Flag for DT_* entries affecting next entry */
        DT_SYMINSZ  = 0x6ffffdfe, /* value   ?          ?         Size of syminfo table in bytes */
        DT_SYMINENT = 0x6ffffdff, /* value   ?          ?         Size of each syminfo table entry */

        DT_GNU_HASH = 0x6ffffef5, /* pointer ?          ?         GNU-style hash table */
        DT_TLSDESC_PLT=0x6ffffef6,/* pointer ?          ?         ? */
        DT_TLSDESC_GOT=0x6ffffef7,/* pointer ?          ?         ? */
        DT_GNU_CONFLICT=0x6ffffef8,/*pointer ?          ?         Start of conflict section */
        DT_GNU_LIBLIST=0x6ffffef9,/* pointer ?          ?         Library list */
        DT_CONFIG   = 0x6ffffefa, /* pointer ?          ?         Configuration information */
        DT_DEPAUDIT = 0x6ffffefb, /* pointer ?          ?         Dependency auditing */
        DT_AUDIT    = 0x6ffffefc, /* pointer ?          ?         Object auditing */
        DT_PLTPAD   = 0x6ffffefd, /* pointer ?          ?         PLT padding */
        DT_MOVETAB  = 0x6ffffefe, /* pointer ?          ?         Move table */
        DT_SYMINFO  = 0x6ffffeff, /* pointer ?          ?         Syminfo table */

        DT_VERSYM   = 0x6ffffff0, /* pointer ?          ?         ? */
        DT_RELACOUNT= 0x6ffffff9, /* value   ?          ?         ? */
        DT_RELCOUNT = 0x6ffffffa, /* value   ?          ?         ? */
        DT_FLAGS_1  = 0x6ffffffb, /* value   ?          ?         Sun state flags */
        DT_VERDEF   = 0x6ffffffc, /* pointer ?          ?         Sun version definition table */
        DT_VERDEFNUM= 0x6ffffffd, /* value   ?          ?         Sun number of version definitions */
        DT_VERNEED  = 0x6ffffffe, /* pointer ?          ?         Sun needed versions table */
        DT_VERNEEDNUM=0x6fffffff, /* value   ?          ?         Sun number of needed versions */

        DT_AUXILIARY= 0x7ffffffd, /* pointer ?          ?         Sun shared obj to load before self */
        DT_FILTER   = 0x7fffffff  /* pointer ?          ?         Shared object ot get values from */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. */
    struct Elf32DynamicEntry_disk {
        uint32_t            d_tag;                  /**< Entry type, one of the DT_* constants */
        uint32_t            d_val;                  /**< Tag's value */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64DynamicEntry_disk {
        uint64_t            d_tag;                  /**< Entry type, one of the DT_* constants */
        uint64_t            d_val;                  /**< Tag's value */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Tag.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    SgAsmElfDynamicEntry::EntryType const& get_d_tag() const;
    void set_d_tag(SgAsmElfDynamicEntry::EntryType const&);
    /** @} */

public:
    /** Property: Value.
     *
     *  See ELF specification for details. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::RelativeVirtualAddress const& get_d_val() const;
    Rose::BinaryAnalysis::RelativeVirtualAddress& get_d_val();
    void set_d_val(Rose::BinaryAnalysis::RelativeVirtualAddress const&);
    /** @} */

public:
    /** Property: Name.
     *
     * @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString*);
    /** @} */
public:
    /** Property: Padding byte values. 
     * 
     * @{ */
    SgUnsignedCharList const& get_extra() const;
    SgUnsignedCharList& get_extra();
    void set_extra(SgUnsignedCharList const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that links the object into the AST. */
    explicit SgAsmElfDynamicEntry(SgAsmElfDynamicSection *dynsec);

    /** Initialize object by parsing the file.
     *
     * @{ */
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*);
    void parse(Rose::BinaryAnalysis::ByteOrder::Endianness, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*);
    /** @} */

    /** Convert object to disk representation.
     *
     * @{ */
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*) const;
    void *encode(Rose::BinaryAnalysis::ByteOrder::Endianness, SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*) const;
    /** @} */

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Convert Dynamic Entry Tag to a string */
    static std::string toString(SgAsmElfDynamicEntry::EntryType);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    static std::string to_string(SgAsmElfDynamicEntry::EntryType) ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicEntry();

public:
    /** Default constructor. */
    SgAsmElfDynamicEntry();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicEntry_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfWithStmt           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfWithStmt);
IS_SERIALIZABLE(AsmDwarfWithStmt);

#ifndef DOCUMENTATION
AsmDwarfWithStmt.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfWithStmt: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfWithStmt);
#if defined(SgAsmDwarfWithStmt_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfWithStmt -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfWithStmt");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfWithStmt");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfWithStmt();

public:
    /** Default constructor. */
    SgAsmDwarfWithStmt();

public:
    /** Constructor. */
    SgAsmDwarfWithStmt(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfWithStmt_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVolatileType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfVolatileType);
IS_SERIALIZABLE(AsmDwarfVolatileType);

#ifndef DOCUMENTATION
AsmDwarfVolatileType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfVolatileType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfVolatileType);
#if defined(SgAsmDwarfVolatileType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfVolatileType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfVolatileType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfVolatileType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfVolatileType();

public:
    /** Default constructor. */
    SgAsmDwarfVolatileType();

public:
    /** Constructor. */
    SgAsmDwarfVolatileType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVolatileType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariantPart           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfVariantPart);
IS_SERIALIZABLE(AsmDwarfVariantPart);

#ifndef DOCUMENTATION
AsmDwarfVariantPart.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfVariantPart: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfVariantPart);
#if defined(SgAsmDwarfVariantPart_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfVariantPart -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfVariantPart");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfVariantPart");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariantPart();

public:
    /** Default constructor. */
    SgAsmDwarfVariantPart();

public:
    /** Constructor. */
    SgAsmDwarfVariantPart(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariantPart_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfVariant);
IS_SERIALIZABLE(AsmDwarfVariant);

#ifndef DOCUMENTATION
AsmDwarfVariant.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfVariant: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfVariant);
#if defined(SgAsmDwarfVariant_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfVariant -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfVariant");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfVariant");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariant();

public:
    /** Default constructor. */
    SgAsmDwarfVariant();

public:
    /** Constructor. */
    SgAsmDwarfVariant(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariant_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfVariable);
IS_SERIALIZABLE(AsmDwarfVariable);

#ifndef DOCUMENTATION
AsmDwarfVariable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfVariable: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfVariable);
#if defined(SgAsmDwarfVariable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfVariable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfVariable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfVariable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariable();

public:
    /** Default constructor. */
    SgAsmDwarfVariable();

public:
    /** Constructor. */
    SgAsmDwarfVariable(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcStrictType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUpcStrictType);
IS_SERIALIZABLE(AsmDwarfUpcStrictType);

#ifndef DOCUMENTATION
AsmDwarfUpcStrictType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUpcStrictType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUpcStrictType);
#if defined(SgAsmDwarfUpcStrictType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUpcStrictType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUpcStrictType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUpcStrictType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcStrictType();

public:
    /** Default constructor. */
    SgAsmDwarfUpcStrictType();

public:
    /** Constructor. */
    SgAsmDwarfUpcStrictType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcStrictType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcSharedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUpcSharedType);
IS_SERIALIZABLE(AsmDwarfUpcSharedType);

#ifndef DOCUMENTATION
AsmDwarfUpcSharedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUpcSharedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUpcSharedType);
#if defined(SgAsmDwarfUpcSharedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUpcSharedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUpcSharedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUpcSharedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcSharedType();

public:
    /** Default constructor. */
    SgAsmDwarfUpcSharedType();

public:
    /** Constructor. */
    SgAsmDwarfUpcSharedType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcSharedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcRelaxedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUpcRelaxedType);
IS_SERIALIZABLE(AsmDwarfUpcRelaxedType);

#ifndef DOCUMENTATION
AsmDwarfUpcRelaxedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUpcRelaxedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUpcRelaxedType);
#if defined(SgAsmDwarfUpcRelaxedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUpcRelaxedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUpcRelaxedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUpcRelaxedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcRelaxedType();

public:
    /** Default constructor. */
    SgAsmDwarfUpcRelaxedType();

public:
    /** Constructor. */
    SgAsmDwarfUpcRelaxedType(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcRelaxedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnspecifiedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUnspecifiedType);
IS_SERIALIZABLE(AsmDwarfUnspecifiedType);

#ifndef DOCUMENTATION
AsmDwarfUnspecifiedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUnspecifiedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUnspecifiedType);
#if defined(SgAsmDwarfUnspecifiedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUnspecifiedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUnspecifiedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUnspecifiedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnspecifiedType();

public:
    /** Default constructor. */
    SgAsmDwarfUnspecifiedType();

public:
    /** Constructor. */
    SgAsmDwarfUnspecifiedType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnspecifiedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnspecifiedParameters           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUnspecifiedParameters);
IS_SERIALIZABLE(AsmDwarfUnspecifiedParameters);

#ifndef DOCUMENTATION
AsmDwarfUnspecifiedParameters.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUnspecifiedParameters: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUnspecifiedParameters);
#if defined(SgAsmDwarfUnspecifiedParameters_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUnspecifiedParameters -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUnspecifiedParameters");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUnspecifiedParameters");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnspecifiedParameters();

public:
    /** Default constructor. */
    SgAsmDwarfUnspecifiedParameters();

public:
    /** Constructor. */
    SgAsmDwarfUnspecifiedParameters(int const& nesting_level,
                                    uint64_t const& offset,
                                    uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnspecifiedParameters_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnknownConstruct           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUnknownConstruct);
IS_SERIALIZABLE(AsmDwarfUnknownConstruct);

#ifndef DOCUMENTATION
AsmDwarfUnknownConstruct.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfUnknownConstruct: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUnknownConstruct);
#if defined(SgAsmDwarfUnknownConstruct_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUnknownConstruct -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUnknownConstruct");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfUnknownConstruct");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnknownConstruct();

public:
    /** Default constructor. */
    SgAsmDwarfUnknownConstruct();

public:
    /** Constructor. */
    SgAsmDwarfUnknownConstruct(int const& nesting_level,
                               uint64_t const& offset,
                               uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnknownConstruct_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnionType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfUnionType);
IS_SERIALIZABLE(AsmDwarfUnionType);

#ifndef DOCUMENTATION
AsmDwarfUnionType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfUnionType);
#if defined(SgAsmDwarfUnionType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfUnionType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfUnionType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfUnionType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfUnionType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfUnionType);
#if defined(SgAsmDwarfUnionType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfUnionType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfUnionType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfUnionType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnionType();

public:
    /** Default constructor. */
    SgAsmDwarfUnionType();

public:
    /** Constructor. */
    SgAsmDwarfUnionType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnionType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTypedef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfTypedef);
IS_SERIALIZABLE(AsmDwarfTypedef);

#ifndef DOCUMENTATION
AsmDwarfTypedef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfTypedef: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfTypedef);
#if defined(SgAsmDwarfTypedef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfTypedef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfTypedef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfTypedef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfTypedef();

public:
    /** Default constructor. */
    SgAsmDwarfTypedef();

public:
    /** Constructor. */
    SgAsmDwarfTypedef(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTypedef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTryBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfTryBlock);
IS_SERIALIZABLE(AsmDwarfTryBlock);

#ifndef DOCUMENTATION
AsmDwarfTryBlock.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfTryBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfTryBlock);
#if defined(SgAsmDwarfTryBlock_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfTryBlock -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfTryBlock");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfTryBlock");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfTryBlock();

public:
    /** Default constructor. */
    SgAsmDwarfTryBlock();

public:
    /** Constructor. */
    SgAsmDwarfTryBlock(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTryBlock_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfThrownType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfThrownType);
IS_SERIALIZABLE(AsmDwarfThrownType);

#ifndef DOCUMENTATION
AsmDwarfThrownType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfThrownType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfThrownType);
#if defined(SgAsmDwarfThrownType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfThrownType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfThrownType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfThrownType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfThrownType();

public:
    /** Default constructor. */
    SgAsmDwarfThrownType();

public:
    /** Constructor. */
    SgAsmDwarfThrownType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfThrownType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTemplateValueParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfTemplateValueParameter);
IS_SERIALIZABLE(AsmDwarfTemplateValueParameter);

#ifndef DOCUMENTATION
AsmDwarfTemplateValueParameter.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfTemplateValueParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfTemplateValueParameter);
#if defined(SgAsmDwarfTemplateValueParameter_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfTemplateValueParameter -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfTemplateValueParameter");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfTemplateValueParameter");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfTemplateValueParameter();

public:
    /** Default constructor. */
    SgAsmDwarfTemplateValueParameter();

public:
    /** Constructor. */
    SgAsmDwarfTemplateValueParameter(int const& nesting_level,
                                     uint64_t const& offset,
                                     uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTemplateValueParameter_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTemplateTypeParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfTemplateTypeParameter);
IS_SERIALIZABLE(AsmDwarfTemplateTypeParameter);

#ifndef DOCUMENTATION
AsmDwarfTemplateTypeParameter.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfTemplateTypeParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfTemplateTypeParameter);
#if defined(SgAsmDwarfTemplateTypeParameter_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfTemplateTypeParameter -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfTemplateTypeParameter");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfTemplateTypeParameter");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfTemplateTypeParameter();

public:
    /** Default constructor. */
    SgAsmDwarfTemplateTypeParameter();

public:
    /** Constructor. */
    SgAsmDwarfTemplateTypeParameter(int const& nesting_level,
                                    uint64_t const& offset,
                                    uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTemplateTypeParameter_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubroutineType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfSubroutineType);
IS_SERIALIZABLE(AsmDwarfSubroutineType);

#ifndef DOCUMENTATION
AsmDwarfSubroutineType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfSubroutineType);
#if defined(SgAsmDwarfSubroutineType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfSubroutineType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfSubroutineType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfSubroutineType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfSubroutineType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfSubroutineType);
#if defined(SgAsmDwarfSubroutineType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfSubroutineType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfSubroutineType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfSubroutineType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubroutineType();

public:
    /** Default constructor. */
    SgAsmDwarfSubroutineType();

public:
    /** Constructor. */
    SgAsmDwarfSubroutineType(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubroutineType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubrangeType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfSubrangeType);
IS_SERIALIZABLE(AsmDwarfSubrangeType);

#ifndef DOCUMENTATION
AsmDwarfSubrangeType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfSubrangeType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfSubrangeType);
#if defined(SgAsmDwarfSubrangeType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfSubrangeType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfSubrangeType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfSubrangeType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubrangeType();

public:
    /** Default constructor. */
    SgAsmDwarfSubrangeType();

public:
    /** Constructor. */
    SgAsmDwarfSubrangeType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubrangeType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubprogram           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfSubprogram);
IS_SERIALIZABLE(AsmDwarfSubprogram);

#ifndef DOCUMENTATION
AsmDwarfSubprogram.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfSubprogram);
#if defined(SgAsmDwarfSubprogram_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfSubprogram_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfSubprogram_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfSubprogram: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfSubprogram.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfSubprogram);
#if defined(SgAsmDwarfSubprogram_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfSubprogram -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfSubprogram");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfSubprogram");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubprogram();

public:
    /** Default constructor. */
    SgAsmDwarfSubprogram();

public:
    /** Constructor. */
    SgAsmDwarfSubprogram(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubprogram_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfStructureType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfStructureType);
IS_SERIALIZABLE(AsmDwarfStructureType);

#ifndef DOCUMENTATION
AsmDwarfStructureType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfStructureType);
#if defined(SgAsmDwarfStructureType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfStructureType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfStructureType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfStructureType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfStructureType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfStructureType);
#if defined(SgAsmDwarfStructureType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfStructureType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfStructureType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfStructureType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfStructureType();

public:
    /** Default constructor. */
    SgAsmDwarfStructureType();

public:
    /** Constructor. */
    SgAsmDwarfStructureType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfStructureType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfStringType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfStringType);
IS_SERIALIZABLE(AsmDwarfStringType);

#ifndef DOCUMENTATION
AsmDwarfStringType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfStringType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfStringType);
#if defined(SgAsmDwarfStringType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfStringType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfStringType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfStringType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfStringType();

public:
    /** Default constructor. */
    SgAsmDwarfStringType();

public:
    /** Constructor. */
    SgAsmDwarfStringType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfStringType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSharedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfSharedType);
IS_SERIALIZABLE(AsmDwarfSharedType);

#ifndef DOCUMENTATION
AsmDwarfSharedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfSharedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfSharedType);
#if defined(SgAsmDwarfSharedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfSharedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfSharedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfSharedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfSharedType();

public:
    /** Default constructor. */
    SgAsmDwarfSharedType();

public:
    /** Constructor. */
    SgAsmDwarfSharedType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSharedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSetType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfSetType);
IS_SERIALIZABLE(AsmDwarfSetType);

#ifndef DOCUMENTATION
AsmDwarfSetType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfSetType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfSetType);
#if defined(SgAsmDwarfSetType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfSetType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfSetType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfSetType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfSetType();

public:
    /** Default constructor. */
    SgAsmDwarfSetType();

public:
    /** Constructor. */
    SgAsmDwarfSetType(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSetType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfRestrictType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfRestrictType);
IS_SERIALIZABLE(AsmDwarfRestrictType);

#ifndef DOCUMENTATION
AsmDwarfRestrictType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfRestrictType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfRestrictType);
#if defined(SgAsmDwarfRestrictType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfRestrictType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfRestrictType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfRestrictType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfRestrictType();

public:
    /** Default constructor. */
    SgAsmDwarfRestrictType();

public:
    /** Constructor. */
    SgAsmDwarfRestrictType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfRestrictType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfReferenceType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfReferenceType);
IS_SERIALIZABLE(AsmDwarfReferenceType);

#ifndef DOCUMENTATION
AsmDwarfReferenceType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfReferenceType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfReferenceType);
#if defined(SgAsmDwarfReferenceType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfReferenceType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfReferenceType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfReferenceType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfReferenceType();

public:
    /** Default constructor. */
    SgAsmDwarfReferenceType();

public:
    /** Constructor. */
    SgAsmDwarfReferenceType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfReferenceType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPtrToMemberType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfPtrToMemberType);
IS_SERIALIZABLE(AsmDwarfPtrToMemberType);

#ifndef DOCUMENTATION
AsmDwarfPtrToMemberType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfPtrToMemberType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfPtrToMemberType);
#if defined(SgAsmDwarfPtrToMemberType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfPtrToMemberType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfPtrToMemberType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfPtrToMemberType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfPtrToMemberType();

public:
    /** Default constructor. */
    SgAsmDwarfPtrToMemberType();

public:
    /** Constructor. */
    SgAsmDwarfPtrToMemberType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPtrToMemberType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPointerType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfPointerType);
IS_SERIALIZABLE(AsmDwarfPointerType);

#ifndef DOCUMENTATION
AsmDwarfPointerType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfPointerType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfPointerType);
#if defined(SgAsmDwarfPointerType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfPointerType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfPointerType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfPointerType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfPointerType();

public:
    /** Default constructor. */
    SgAsmDwarfPointerType();

public:
    /** Constructor. */
    SgAsmDwarfPointerType(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPointerType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPartialUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfPartialUnit);
IS_SERIALIZABLE(AsmDwarfPartialUnit);

#ifndef DOCUMENTATION
AsmDwarfPartialUnit.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfPartialUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfPartialUnit);
#if defined(SgAsmDwarfPartialUnit_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfPartialUnit -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfPartialUnit");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfPartialUnit");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfPartialUnit();

public:
    /** Default constructor. */
    SgAsmDwarfPartialUnit();

public:
    /** Constructor. */
    SgAsmDwarfPartialUnit(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPartialUnit_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPackedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfPackedType);
IS_SERIALIZABLE(AsmDwarfPackedType);

#ifndef DOCUMENTATION
AsmDwarfPackedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfPackedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfPackedType);
#if defined(SgAsmDwarfPackedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfPackedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfPackedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfPackedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfPackedType();

public:
    /** Default constructor. */
    SgAsmDwarfPackedType();

public:
    /** Constructor. */
    SgAsmDwarfPackedType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPackedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamespace           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfNamespace);
IS_SERIALIZABLE(AsmDwarfNamespace);

#ifndef DOCUMENTATION
AsmDwarfNamespace.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfNamespace);
#if defined(SgAsmDwarfNamespace_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfNamespace_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfNamespace_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfNamespace: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfNamespace.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfNamespace);
#if defined(SgAsmDwarfNamespace_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfNamespace -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfNamespace");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfNamespace");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamespace();

public:
    /** Default constructor. */
    SgAsmDwarfNamespace();

public:
    /** Constructor. */
    SgAsmDwarfNamespace(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamespace_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamelistItem           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfNamelistItem);
IS_SERIALIZABLE(AsmDwarfNamelistItem);

#ifndef DOCUMENTATION
AsmDwarfNamelistItem.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfNamelistItem: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfNamelistItem);
#if defined(SgAsmDwarfNamelistItem_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfNamelistItem -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfNamelistItem");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfNamelistItem");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamelistItem();

public:
    /** Default constructor. */
    SgAsmDwarfNamelistItem();

public:
    /** Constructor. */
    SgAsmDwarfNamelistItem(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamelistItem_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamelist           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfNamelist);
IS_SERIALIZABLE(AsmDwarfNamelist);

#ifndef DOCUMENTATION
AsmDwarfNamelist.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfNamelist: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfNamelist);
#if defined(SgAsmDwarfNamelist_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfNamelist -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfNamelist");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfNamelist");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamelist();

public:
    /** Default constructor. */
    SgAsmDwarfNamelist();

public:
    /** Constructor. */
    SgAsmDwarfNamelist(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamelist_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMutableType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfMutableType);
IS_SERIALIZABLE(AsmDwarfMutableType);

#ifndef DOCUMENTATION
AsmDwarfMutableType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfMutableType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfMutableType);
#if defined(SgAsmDwarfMutableType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfMutableType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfMutableType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfMutableType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfMutableType();

public:
    /** Default constructor. */
    SgAsmDwarfMutableType();

public:
    /** Constructor. */
    SgAsmDwarfMutableType(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMutableType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfModule);
IS_SERIALIZABLE(AsmDwarfModule);

#ifndef DOCUMENTATION
AsmDwarfModule.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfModule: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfModule);
#if defined(SgAsmDwarfModule_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfModule -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfModule");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfModule");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfModule();

public:
    /** Default constructor. */
    SgAsmDwarfModule();

public:
    /** Constructor. */
    SgAsmDwarfModule(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfModule_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMember           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfMember);
IS_SERIALIZABLE(AsmDwarfMember);

#ifndef DOCUMENTATION
AsmDwarfMember.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfMember: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfMember);
#if defined(SgAsmDwarfMember_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfMember -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfMember");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfMember");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfMember();

public:
    /** Default constructor. */
    SgAsmDwarfMember();

public:
    /** Constructor. */
    SgAsmDwarfMember(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMember_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMacroList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfMacroList);
IS_SERIALIZABLE(AsmDwarfMacroList);

#ifndef DOCUMENTATION
AsmDwarfMacroList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfMacroList);
#if defined(SgAsmDwarfMacroList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmDwarfMacroList_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfMacroList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfMacroList.setDataPrototype(
        "SgAsmDwarfMacroPtrList", "macro_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfMacroList);
#if defined(SgAsmDwarfMacroList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfMacroList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfMacroList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_macro_list);
        debugSerializationEnd("SgAsmDwarfMacroList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfMacroPtrList const& get_macro_list() const;
    void set_macro_list(SgAsmDwarfMacroPtrList const&);

public:
    /** Destructor. */
    virtual ~SgAsmDwarfMacroList();

public:
    /** Default constructor. */
    SgAsmDwarfMacroList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMacroList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMacro           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfMacro);
IS_SERIALIZABLE(AsmDwarfMacro);

#ifndef DOCUMENTATION
AsmDwarfMacro.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfMacro: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfMacro.setDataPrototype(
        "std::string", "macro_string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfMacro);
#if defined(SgAsmDwarfMacro_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfMacro -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfMacro");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_macro_string);
        debugSerializationEnd("SgAsmDwarfMacro");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    std::string const& get_macro_string() const;
    void set_macro_string(std::string const&);

public:
    /** Destructor. */
    virtual ~SgAsmDwarfMacro();

public:
    /** Default constructor. */
    SgAsmDwarfMacro();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMacro_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLineList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfLineList);
IS_SERIALIZABLE(AsmDwarfLineList);

#ifndef DOCUMENTATION
AsmDwarfLineList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfLineList);
#if defined(SgAsmDwarfLineList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmDwarfLineList_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfLineList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLineList.setDataPrototype(
        "SgAsmDwarfLinePtrList", "line_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfLineList);
#if defined(SgAsmDwarfLineList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfLineList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfLineList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_line_list);
        debugSerializationEnd("SgAsmDwarfLineList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfLinePtrList const& get_line_list() const;
    SgAsmDwarfLinePtrList& get_line_list();
    void set_line_list(SgAsmDwarfLinePtrList const&);
#if 0
    // I [DQ] am having trouble making these proper data members so just use function to return them, so that they are
    // computed dynamically.
    AsmDwarfLineList.setDataPrototype("SgInstructionAddressSourcePositionMapPtrList", "instructionToSourceMap", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
    AsmDwarfLineList.setDataPrototype("SgSourcePositionInstructionAddressMapPtrList", "sourceToInstructionMap", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

public:
    // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
    //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
    static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

    //! Output information about instruction address <--> source position
    void display( const std::string & label );

    static std::pair<uint64_t,uint64_t> instructionRange();
    static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

    static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
    static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLineList();

public:
    /** Default constructor. */
    SgAsmDwarfLineList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLineList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLine           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfLine);
IS_SERIALIZABLE(AsmDwarfLine);

#ifndef DOCUMENTATION
AsmDwarfLine.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfLine: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLine.setDataPrototype(
        "uint64_t", "address", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLine.setDataPrototype(
        "int", "file_id", "= -2",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLine.setDataPrototype(
        "int", "line", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLine.setDataPrototype(
        "int", "column", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfLine);
#if defined(SgAsmDwarfLine_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfLine -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfLine");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_address);
        s & BOOST_SERIALIZATION_NVP(p_file_id);
        s & BOOST_SERIALIZATION_NVP(p_line);
        s & BOOST_SERIALIZATION_NVP(p_column);
        debugSerializationEnd("SgAsmDwarfLine");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    uint64_t const& get_address() const;
    void set_address(uint64_t const&);
    // FIXME[Robb Matzke 2024-03-14]: Sg_File_Info::NULL_FILE_ID == -2, but since Sg_File_Info's definition is in the
    // huge Cxx_Grammar.h file we don't want to include it here.
public:
    int const& get_file_id() const;
    void set_file_id(int const&);

public:
    int const& get_line() const;
    void set_line(int const&);

public:
    int const& get_column() const;
    void set_column(int const&);

public:
    /** Destructor. */
    virtual ~SgAsmDwarfLine();

public:
    /** Default constructor. */
    SgAsmDwarfLine();

public:
    /** Constructor. */
    SgAsmDwarfLine(uint64_t const& address,
                   int const& file_id,
                   int const& line,
                   int const& column);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLine_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLexicalBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfLexicalBlock);
IS_SERIALIZABLE(AsmDwarfLexicalBlock);

#ifndef DOCUMENTATION
AsmDwarfLexicalBlock.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfLexicalBlock);
#if defined(SgAsmDwarfLexicalBlock_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfLexicalBlock_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfLexicalBlock_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfLexicalBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfLexicalBlock.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfLexicalBlock);
#if defined(SgAsmDwarfLexicalBlock_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfLexicalBlock -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfLexicalBlock");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfLexicalBlock");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLexicalBlock();

public:
    /** Default constructor. */
    SgAsmDwarfLexicalBlock();

public:
    /** Constructor. */
    SgAsmDwarfLexicalBlock(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLexicalBlock_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLabel           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfLabel);
IS_SERIALIZABLE(AsmDwarfLabel);

#ifndef DOCUMENTATION
AsmDwarfLabel.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfLabel: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfLabel);
#if defined(SgAsmDwarfLabel_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfLabel -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfLabel");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfLabel");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfLabel();

public:
    /** Default constructor. */
    SgAsmDwarfLabel();

public:
    /** Constructor. */
    SgAsmDwarfLabel(int const& nesting_level,
                    uint64_t const& offset,
                    uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLabel_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInterfaceType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfInterfaceType);
IS_SERIALIZABLE(AsmDwarfInterfaceType);

#ifndef DOCUMENTATION
AsmDwarfInterfaceType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfInterfaceType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfInterfaceType);
#if defined(SgAsmDwarfInterfaceType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfInterfaceType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfInterfaceType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfInterfaceType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfInterfaceType();

public:
    /** Default constructor. */
    SgAsmDwarfInterfaceType();

public:
    /** Constructor. */
    SgAsmDwarfInterfaceType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInterfaceType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInlinedSubroutine           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfInlinedSubroutine);
IS_SERIALIZABLE(AsmDwarfInlinedSubroutine);

#ifndef DOCUMENTATION
AsmDwarfInlinedSubroutine.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfInlinedSubroutine);
#if defined(SgAsmDwarfInlinedSubroutine_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfInlinedSubroutine_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfInlinedSubroutine_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfInlinedSubroutine: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfInlinedSubroutine.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfInlinedSubroutine);
#if defined(SgAsmDwarfInlinedSubroutine_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfInlinedSubroutine -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfInlinedSubroutine");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfInlinedSubroutine");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfInlinedSubroutine();

public:
    /** Default constructor. */
    SgAsmDwarfInlinedSubroutine();

public:
    /** Constructor. */
    SgAsmDwarfInlinedSubroutine(int const& nesting_level,
                                uint64_t const& offset,
                                uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInlinedSubroutine_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInheritance           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfInheritance);
IS_SERIALIZABLE(AsmDwarfInheritance);

#ifndef DOCUMENTATION
AsmDwarfInheritance.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfInheritance: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfInheritance);
#if defined(SgAsmDwarfInheritance_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfInheritance -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfInheritance");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfInheritance");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfInheritance();

public:
    /** Default constructor. */
    SgAsmDwarfInheritance();

public:
    /** Constructor. */
    SgAsmDwarfInheritance(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInheritance_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfImportedUnit);
IS_SERIALIZABLE(AsmDwarfImportedUnit);

#ifndef DOCUMENTATION
AsmDwarfImportedUnit.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfImportedUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfImportedUnit);
#if defined(SgAsmDwarfImportedUnit_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfImportedUnit -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfImportedUnit");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfImportedUnit");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedUnit();

public:
    /** Default constructor. */
    SgAsmDwarfImportedUnit();

public:
    /** Constructor. */
    SgAsmDwarfImportedUnit(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedUnit_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfImportedModule);
IS_SERIALIZABLE(AsmDwarfImportedModule);

#ifndef DOCUMENTATION
AsmDwarfImportedModule.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfImportedModule: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfImportedModule);
#if defined(SgAsmDwarfImportedModule_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfImportedModule -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfImportedModule");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfImportedModule");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedModule();

public:
    /** Default constructor. */
    SgAsmDwarfImportedModule();

public:
    /** Constructor. */
    SgAsmDwarfImportedModule(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedModule_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfImportedDeclaration);
IS_SERIALIZABLE(AsmDwarfImportedDeclaration);

#ifndef DOCUMENTATION
AsmDwarfImportedDeclaration.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfImportedDeclaration: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfImportedDeclaration);
#if defined(SgAsmDwarfImportedDeclaration_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfImportedDeclaration -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfImportedDeclaration");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfImportedDeclaration");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedDeclaration();

public:
    /** Default constructor. */
    SgAsmDwarfImportedDeclaration();

public:
    /** Constructor. */
    SgAsmDwarfImportedDeclaration(int const& nesting_level,
                                  uint64_t const& offset,
                                  uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedDeclaration_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFunctionTemplate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfFunctionTemplate);
IS_SERIALIZABLE(AsmDwarfFunctionTemplate);

#ifndef DOCUMENTATION
AsmDwarfFunctionTemplate.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfFunctionTemplate: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfFunctionTemplate);
#if defined(SgAsmDwarfFunctionTemplate_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfFunctionTemplate -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfFunctionTemplate");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfFunctionTemplate");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfFunctionTemplate();

public:
    /** Default constructor. */
    SgAsmDwarfFunctionTemplate();

public:
    /** Constructor. */
    SgAsmDwarfFunctionTemplate(int const& nesting_level,
                               uint64_t const& offset,
                               uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFunctionTemplate_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFriend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfFriend);
IS_SERIALIZABLE(AsmDwarfFriend);

#ifndef DOCUMENTATION
AsmDwarfFriend.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfFriend: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfFriend);
#if defined(SgAsmDwarfFriend_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfFriend -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfFriend");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfFriend");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfFriend();

public:
    /** Default constructor. */
    SgAsmDwarfFriend();

public:
    /** Constructor. */
    SgAsmDwarfFriend(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFriend_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFormatLabel           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfFormatLabel);
IS_SERIALIZABLE(AsmDwarfFormatLabel);

#ifndef DOCUMENTATION
AsmDwarfFormatLabel.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfFormatLabel: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfFormatLabel);
#if defined(SgAsmDwarfFormatLabel_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfFormatLabel -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfFormatLabel");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfFormatLabel");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfFormatLabel();

public:
    /** Default constructor. */
    SgAsmDwarfFormatLabel();

public:
    /** Constructor. */
    SgAsmDwarfFormatLabel(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFormatLabel_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFormalParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfFormalParameter);
IS_SERIALIZABLE(AsmDwarfFormalParameter);

#ifndef DOCUMENTATION
AsmDwarfFormalParameter.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfFormalParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfFormalParameter);
#if defined(SgAsmDwarfFormalParameter_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfFormalParameter -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfFormalParameter");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfFormalParameter");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfFormalParameter();

public:
    /** Default constructor. */
    SgAsmDwarfFormalParameter();

public:
    /** Constructor. */
    SgAsmDwarfFormalParameter(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFormalParameter_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFileType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfFileType);
IS_SERIALIZABLE(AsmDwarfFileType);

#ifndef DOCUMENTATION
AsmDwarfFileType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfFileType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfFileType);
#if defined(SgAsmDwarfFileType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfFileType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfFileType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfFileType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfFileType();

public:
    /** Default constructor. */
    SgAsmDwarfFileType();

public:
    /** Constructor. */
    SgAsmDwarfFileType(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFileType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEnumerator           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfEnumerator);
IS_SERIALIZABLE(AsmDwarfEnumerator);

#ifndef DOCUMENTATION
AsmDwarfEnumerator.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfEnumerator: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfEnumerator);
#if defined(SgAsmDwarfEnumerator_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfEnumerator -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfEnumerator");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfEnumerator");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfEnumerator();

public:
    /** Default constructor. */
    SgAsmDwarfEnumerator();

public:
    /** Constructor. */
    SgAsmDwarfEnumerator(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEnumerator_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEnumerationType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfEnumerationType);
IS_SERIALIZABLE(AsmDwarfEnumerationType);

#ifndef DOCUMENTATION
AsmDwarfEnumerationType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfEnumerationType);
#if defined(SgAsmDwarfEnumerationType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfEnumerationType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfEnumerationType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfEnumerationType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfEnumerationType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfEnumerationType);
#if defined(SgAsmDwarfEnumerationType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfEnumerationType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfEnumerationType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfEnumerationType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfEnumerationType();

public:
    /** Default constructor. */
    SgAsmDwarfEnumerationType();

public:
    /** Constructor. */
    SgAsmDwarfEnumerationType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEnumerationType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfEntryPoint);
IS_SERIALIZABLE(AsmDwarfEntryPoint);

#ifndef DOCUMENTATION
AsmDwarfEntryPoint.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfEntryPoint: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfEntryPoint);
#if defined(SgAsmDwarfEntryPoint_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfEntryPoint -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfEntryPoint");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfEntryPoint");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfEntryPoint();

public:
    /** Default constructor. */
    SgAsmDwarfEntryPoint();

public:
    /** Constructor. */
    SgAsmDwarfEntryPoint(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEntryPoint_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfDwarfProcedure           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfDwarfProcedure);
IS_SERIALIZABLE(AsmDwarfDwarfProcedure);

#ifndef DOCUMENTATION
AsmDwarfDwarfProcedure.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfDwarfProcedure: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfDwarfProcedure);
#if defined(SgAsmDwarfDwarfProcedure_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfDwarfProcedure -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfDwarfProcedure");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfDwarfProcedure");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfDwarfProcedure();

public:
    /** Default constructor. */
    SgAsmDwarfDwarfProcedure();

public:
    /** Constructor. */
    SgAsmDwarfDwarfProcedure(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfDwarfProcedure_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfConstType);
IS_SERIALIZABLE(AsmDwarfConstType);

#ifndef DOCUMENTATION
AsmDwarfConstType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfConstType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfConstType);
#if defined(SgAsmDwarfConstType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfConstType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfConstType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfConstType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstType();

public:
    /** Default constructor. */
    SgAsmDwarfConstType();

public:
    /** Constructor. */
    SgAsmDwarfConstType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstructList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfConstructList);
IS_SERIALIZABLE(AsmDwarfConstructList);

#ifndef DOCUMENTATION
AsmDwarfConstructList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfConstructList);
#if defined(SgAsmDwarfConstructList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmDwarfConstructList_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfConstructList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstructList.setDataPrototype(
        "SgAsmDwarfConstructPtrList", "list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfConstructList);
#if defined(SgAsmDwarfConstructList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfConstructList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfConstructList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_list);
        debugSerializationEnd("SgAsmDwarfConstructList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructPtrList const& get_list() const;
    SgAsmDwarfConstructPtrList& get_list();
    void set_list(SgAsmDwarfConstructPtrList const&);

public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstructList();

public:
    /** Default constructor. */
    SgAsmDwarfConstructList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstructList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfConstant);
IS_SERIALIZABLE(AsmDwarfConstant);

#ifndef DOCUMENTATION
AsmDwarfConstant.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfConstant: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfConstant);
#if defined(SgAsmDwarfConstant_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfConstant -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfConstant");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfConstant");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstant();

public:
    /** Default constructor. */
    SgAsmDwarfConstant();

public:
    /** Constructor. */
    SgAsmDwarfConstant(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstant_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCondition           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCondition);
IS_SERIALIZABLE(AsmDwarfCondition);

#ifndef DOCUMENTATION
AsmDwarfCondition.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfCondition: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCondition);
#if defined(SgAsmDwarfCondition_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCondition -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCondition");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfCondition");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfCondition();

public:
    /** Default constructor. */
    SgAsmDwarfCondition();

public:
    /** Constructor. */
    SgAsmDwarfCondition(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCondition_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCompilationUnitList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCompilationUnitList);
IS_SERIALIZABLE(AsmDwarfCompilationUnitList);

#ifndef DOCUMENTATION
AsmDwarfCompilationUnitList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfCompilationUnitList);
#if defined(SgAsmDwarfCompilationUnitList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmDwarfCompilationUnitList_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfCompilationUnitList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnitList.setDataPrototype(
        "SgAsmDwarfCompilationUnitPtrList", "cu_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCompilationUnitList);
#if defined(SgAsmDwarfCompilationUnitList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCompilationUnitList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCompilationUnitList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_cu_list);
        debugSerializationEnd("SgAsmDwarfCompilationUnitList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfCompilationUnitPtrList const& get_cu_list() const;
    SgAsmDwarfCompilationUnitPtrList& get_cu_list();
    void set_cu_list(SgAsmDwarfCompilationUnitPtrList const&);

public:
    /** Destructor. */
    virtual ~SgAsmDwarfCompilationUnitList();

public:
    /** Default constructor. */
    SgAsmDwarfCompilationUnitList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCompilationUnitList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCompilationUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCompilationUnit);
IS_SERIALIZABLE(AsmDwarfCompilationUnit);

#ifndef DOCUMENTATION
AsmDwarfCompilationUnit.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfCompilationUnit);
#if defined(SgAsmDwarfCompilationUnit_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfCompilationUnit_IMPL
#include <SgAsmDwarfConstructList.h>
#include <SgAsmDwarfLineList.h>
#include <SgAsmDwarfMacroList.h>
#endif
#endif // SgAsmDwarfCompilationUnit_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfCompilationUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "std::string", "producer", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "std::string", "language", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "low_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "hi_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "int", "version_stamp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "abbrev_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "address_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "offset_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfLineList*", "line_info", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfConstructList*", "language_constructs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfMacroList*", "macro_info", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCompilationUnit);
#if defined(SgAsmDwarfCompilationUnit_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCompilationUnit -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCompilationUnit");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_producer);
        s & BOOST_SERIALIZATION_NVP(p_language);
        s & BOOST_SERIALIZATION_NVP(p_low_pc);
        s & BOOST_SERIALIZATION_NVP(p_hi_pc);
        s & BOOST_SERIALIZATION_NVP(p_version_stamp);
        s & BOOST_SERIALIZATION_NVP(p_abbrev_offset);
        s & BOOST_SERIALIZATION_NVP(p_address_size);
        s & BOOST_SERIALIZATION_NVP(p_offset_length);
        s & BOOST_SERIALIZATION_NVP(p_line_info);
        s & BOOST_SERIALIZATION_NVP(p_language_constructs);
        s & BOOST_SERIALIZATION_NVP(p_macro_info);
        debugSerializationEnd("SgAsmDwarfCompilationUnit");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    std::string const& get_producer() const;
    void set_producer(std::string const&);

public:
    std::string const& get_language() const;
    void set_language(std::string const&);

public:
    uint64_t const& get_low_pc() const;
    void set_low_pc(uint64_t const&);

public:
    uint64_t const& get_hi_pc() const;
    void set_hi_pc(uint64_t const&);

public:
    int const& get_version_stamp() const;
    void set_version_stamp(int const&);

public:
    uint64_t const& get_abbrev_offset() const;
    void set_abbrev_offset(uint64_t const&);

public:
    uint64_t const& get_address_size() const;
    void set_address_size(uint64_t const&);

public:
    uint64_t const& get_offset_length() const;
    void set_offset_length(uint64_t const&);

public:
    SgAsmDwarfLineList* const& get_line_info() const;
    void set_line_info(SgAsmDwarfLineList* const&);

public:
    SgAsmDwarfConstructList* const& get_language_constructs() const;
    void set_language_constructs(SgAsmDwarfConstructList* const&);

public:
    SgAsmDwarfMacroList* const& get_macro_info() const;
    void set_macro_info(SgAsmDwarfMacroList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCompilationUnit();

public:
    /** Default constructor. */
    SgAsmDwarfCompilationUnit();

public:
    /** Constructor. */
    SgAsmDwarfCompilationUnit(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCompilationUnit_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCommonInclusion           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCommonInclusion);
IS_SERIALIZABLE(AsmDwarfCommonInclusion);

#ifndef DOCUMENTATION
AsmDwarfCommonInclusion.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfCommonInclusion: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCommonInclusion);
#if defined(SgAsmDwarfCommonInclusion_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCommonInclusion -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCommonInclusion");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfCommonInclusion");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfCommonInclusion();

public:
    /** Default constructor. */
    SgAsmDwarfCommonInclusion();

public:
    /** Constructor. */
    SgAsmDwarfCommonInclusion(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCommonInclusion_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCommonBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCommonBlock);
IS_SERIALIZABLE(AsmDwarfCommonBlock);

#ifndef DOCUMENTATION
AsmDwarfCommonBlock.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfCommonBlock);
#if defined(SgAsmDwarfCommonBlock_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfCommonBlock_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfCommonBlock_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfCommonBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfCommonBlock.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCommonBlock);
#if defined(SgAsmDwarfCommonBlock_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCommonBlock -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCommonBlock");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfCommonBlock");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCommonBlock();

public:
    /** Default constructor. */
    SgAsmDwarfCommonBlock();

public:
    /** Constructor. */
    SgAsmDwarfCommonBlock(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCommonBlock_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfClassType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfClassType);
IS_SERIALIZABLE(AsmDwarfClassType);

#ifndef DOCUMENTATION
AsmDwarfClassType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfClassType);
#if defined(SgAsmDwarfClassType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfClassType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfClassType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfClassType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfClassType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfClassType);
#if defined(SgAsmDwarfClassType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfClassType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfClassType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfClassType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfClassType();

public:
    /** Default constructor. */
    SgAsmDwarfClassType();

public:
    /** Constructor. */
    SgAsmDwarfClassType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfClassType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfClassTemplate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfClassTemplate);
IS_SERIALIZABLE(AsmDwarfClassTemplate);

#ifndef DOCUMENTATION
AsmDwarfClassTemplate.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfClassTemplate: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfClassTemplate);
#if defined(SgAsmDwarfClassTemplate_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfClassTemplate -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfClassTemplate");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfClassTemplate");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfClassTemplate();

public:
    /** Default constructor. */
    SgAsmDwarfClassTemplate();

public:
    /** Constructor. */
    SgAsmDwarfClassTemplate(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfClassTemplate_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCatchBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfCatchBlock);
IS_SERIALIZABLE(AsmDwarfCatchBlock);

#ifndef DOCUMENTATION
AsmDwarfCatchBlock.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfCatchBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfCatchBlock);
#if defined(SgAsmDwarfCatchBlock_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfCatchBlock -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfCatchBlock");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfCatchBlock");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfCatchBlock();

public:
    /** Default constructor. */
    SgAsmDwarfCatchBlock();

public:
    /** Constructor. */
    SgAsmDwarfCatchBlock(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCatchBlock_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfBaseType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfBaseType);
IS_SERIALIZABLE(AsmDwarfBaseType);

#ifndef DOCUMENTATION
AsmDwarfBaseType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfBaseType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfBaseType);
#if defined(SgAsmDwarfBaseType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfBaseType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfBaseType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfBaseType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfBaseType();

public:
    /** Default constructor. */
    SgAsmDwarfBaseType();

public:
    /** Constructor. */
    SgAsmDwarfBaseType(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfBaseType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfArrayType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfArrayType);
IS_SERIALIZABLE(AsmDwarfArrayType);

#ifndef DOCUMENTATION
AsmDwarfArrayType.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmDwarfArrayType);
#if defined(SgAsmDwarfArrayType_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmDwarfArrayType_IMPL
#include <SgAsmDwarfConstructList.h>
#endif
#endif // SgAsmDwarfArrayType_HEADERS

#ifdef DOCUMENTATION
class SgAsmDwarfArrayType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfArrayType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfArrayType);
#if defined(SgAsmDwarfArrayType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfArrayType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfArrayType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        s & BOOST_SERIALIZATION_NVP(p_body);
        debugSerializationEnd("SgAsmDwarfArrayType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmDwarfConstructList* const& get_body() const;
    void set_body(SgAsmDwarfConstructList* const&);
public:
    SgAsmDwarfConstructList* get_children() override;
public:
    /** Destructor. */
    virtual ~SgAsmDwarfArrayType();

public:
    /** Default constructor. */
    SgAsmDwarfArrayType();

public:
    /** Constructor. */
    SgAsmDwarfArrayType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfArrayType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfAccessDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDwarfAccessDeclaration);
IS_SERIALIZABLE(AsmDwarfAccessDeclaration);

#ifndef DOCUMENTATION
AsmDwarfAccessDeclaration.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfAccessDeclaration: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfAccessDeclaration);
#if defined(SgAsmDwarfAccessDeclaration_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfAccessDeclaration -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfAccessDeclaration");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
        debugSerializationEnd("SgAsmDwarfAccessDeclaration");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfAccessDeclaration();

public:
    /** Default constructor. */
    SgAsmDwarfAccessDeclaration();

public:
    /** Constructor. */
    SgAsmDwarfAccessDeclaration(int const& nesting_level,
                                uint64_t const& offset,
                                uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfAccessDeclaration_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstruct           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmDwarfConstruct = nonTerminalConstructor(
    "AsmDwarfConstruct",
    *this,
    "AsmDwarfConstruct",
    "AsmDwarfConstructTag",
    SubclassListBuilder()
        | AsmDwarfAccessDeclaration
        | AsmDwarfArrayType
        | AsmDwarfBaseType
        | AsmDwarfCatchBlock
        | AsmDwarfClassTemplate
        | AsmDwarfClassType
        | AsmDwarfCommonBlock
        | AsmDwarfCommonInclusion
        | AsmDwarfCompilationUnit
        | AsmDwarfCondition
        | AsmDwarfConstant
        | AsmDwarfConstType
        | AsmDwarfDwarfProcedure
        | AsmDwarfEntryPoint
        | AsmDwarfEnumerationType
        | AsmDwarfEnumerator
        | AsmDwarfFileType
        | AsmDwarfFormalParameter
        | AsmDwarfFormatLabel
        | AsmDwarfFriend
        | AsmDwarfFunctionTemplate
        | AsmDwarfImportedDeclaration
        | AsmDwarfImportedModule
        | AsmDwarfImportedUnit
        | AsmDwarfInheritance
        | AsmDwarfInlinedSubroutine
        | AsmDwarfInterfaceType
        | AsmDwarfLabel
        | AsmDwarfLexicalBlock
        | AsmDwarfMember
        | AsmDwarfModule
        | AsmDwarfMutableType
        | AsmDwarfNamelist
        | AsmDwarfNamelistItem
        | AsmDwarfNamespace
        | AsmDwarfPackedType
        | AsmDwarfPartialUnit
        | AsmDwarfPointerType
        | AsmDwarfPtrToMemberType
        | AsmDwarfReferenceType
        | AsmDwarfRestrictType
        | AsmDwarfSetType
        | AsmDwarfSharedType
        | AsmDwarfStringType
        | AsmDwarfStructureType
        | AsmDwarfSubprogram
        | AsmDwarfSubrangeType
        | AsmDwarfSubroutineType
        | AsmDwarfTemplateTypeParameter
        | AsmDwarfTemplateValueParameter
        | AsmDwarfThrownType
        | AsmDwarfTryBlock
        | AsmDwarfTypedef
        | AsmDwarfUnionType
        | AsmDwarfUnknownConstruct
        | AsmDwarfUnspecifiedParameters
        | AsmDwarfUnspecifiedType
        | AsmDwarfUpcRelaxedType
        | AsmDwarfUpcSharedType
        | AsmDwarfUpcStrictType
        | AsmDwarfVariable
        | AsmDwarfVariant
        | AsmDwarfVariantPart
        | AsmDwarfVolatileType
        | AsmDwarfWithStmt
    , false);
assert(AsmDwarfConstruct.associatedGrammar != nullptr);
AsmDwarfConstruct.setCppCondition("!defined(DOCUMENTATION)");
AsmDwarfConstruct.isBoostSerializable(true);
AsmDwarfConstruct.setAutomaticGenerationOfConstructor(false);
AsmDwarfConstruct.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmDwarfConstruct.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfConstruct: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstruct.setDataPrototype(
        "int", "nesting_level", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstruct.setDataPrototype(
        "uint64_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstruct.setDataPrototype(
        "uint64_t", "overall_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstruct.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDwarfConstruct.setDataPrototype(
        "SgAsmDwarfLine*", "source_position", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfConstruct);
#if defined(SgAsmDwarfConstruct_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfConstruct -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfConstruct");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
        s & BOOST_SERIALIZATION_NVP(p_nesting_level);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        s & BOOST_SERIALIZATION_NVP(p_overall_offset);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_source_position);
        debugSerializationEnd("SgAsmDwarfConstruct");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    // For now we will store the nesting level (just to support debugging), then it will be removed.
public:
    int const& get_nesting_level() const;
    void set_nesting_level(int const&);

public:
    uint64_t const& get_offset() const;
    void set_offset(uint64_t const&);

public:
    uint64_t const& get_overall_offset() const;
    void set_overall_offset(uint64_t const&);
    // A lot of constructs have a name so put the name into the base class
public:
    std::string const& get_name() const;
    void set_name(std::string const&);
    // This is a data member that can be filled in via a separate analysis (we would have to read the line information before
    // hand).
public:
    SgAsmDwarfLine* const& get_source_position() const;
    void set_source_position(SgAsmDwarfLine* const&);
    // [Robb Matzke 2023-03-22]: SgNode already has an attributeMechanism
    // [[using Rosebud: rosetta]]
    // AstAttributeMechanism* attributeMechanism = nullptr;

public:
    /** Factory pattern to build IR nodes based on the tag. */
    static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

    virtual SgAsmDwarfConstructList* get_children();
public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstruct();

protected:
    /** Default constructor. */
    SgAsmDwarfConstruct();

protected:
    /** Constructor. */
    SgAsmDwarfConstruct(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstruct_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInformation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmDwarfInformation = nonTerminalConstructor(
    "AsmDwarfInformation",
    *this,
    "AsmDwarfInformation",
    "AsmDwarfInformationTag",
    SubclassListBuilder()
        | AsmDwarfCompilationUnitList
        | AsmDwarfConstruct
        | AsmDwarfConstructList
        | AsmDwarfLine
        | AsmDwarfLineList
        | AsmDwarfMacro
        | AsmDwarfMacroList
    , false);
assert(AsmDwarfInformation.associatedGrammar != nullptr);
AsmDwarfInformation.setCppCondition("!defined(DOCUMENTATION)");
AsmDwarfInformation.isBoostSerializable(true);
AsmDwarfInformation.setAutomaticGenerationOfConstructor(false);
AsmDwarfInformation.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmDwarfInformation.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
class SgAsmDwarfInformation: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDwarfInformation);
#if defined(SgAsmDwarfInformation_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDwarfInformation -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDwarfInformation");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        debugSerializationEnd("SgAsmDwarfInformation");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDwarfInformation();

protected:
    /** Default constructor. */
    SgAsmDwarfInformation();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInformation_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDOSFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDOSFileHeader);
IS_SERIALIZABLE(AsmDOSFileHeader);

#ifndef DOCUMENTATION
AsmDOSFileHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Represents the file header for DOS executables.
 *
 *  Many of the properties for this node come directly from the DOS specification and have similar names to that documentation. Such
 *  properties are not documented in ROSE. */
class SgAsmDOSFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_last_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_total_pages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_nrelocs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_header_paragraphs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_minalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_maxalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_ss", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_sp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_ip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_cs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_overlay", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "rose_addr_t", "e_relocs_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "SgAsmGenericSection*", "relocs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSFileHeader.setDataPrototype(
        "SgAsmGenericSection*", "rm_section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDOSFileHeader);
#if defined(SgAsmDOSFileHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDOSFileHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDOSFileHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
        s & BOOST_SERIALIZATION_NVP(p_e_last_page_size);
        s & BOOST_SERIALIZATION_NVP(p_e_total_pages);
        s & BOOST_SERIALIZATION_NVP(p_e_nrelocs);
        s & BOOST_SERIALIZATION_NVP(p_e_header_paragraphs);
        s & BOOST_SERIALIZATION_NVP(p_e_minalloc);
        s & BOOST_SERIALIZATION_NVP(p_e_maxalloc);
        s & BOOST_SERIALIZATION_NVP(p_e_ss);
        s & BOOST_SERIALIZATION_NVP(p_e_sp);
        s & BOOST_SERIALIZATION_NVP(p_e_cksum);
        s & BOOST_SERIALIZATION_NVP(p_e_ip);
        s & BOOST_SERIALIZATION_NVP(p_e_cs);
        s & BOOST_SERIALIZATION_NVP(p_e_overlay);
        s & BOOST_SERIALIZATION_NVP(p_e_relocs_offset);
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
        s & BOOST_SERIALIZATION_NVP(p_relocs);
        s & BOOST_SERIALIZATION_NVP(p_rm_section);
        debugSerializationEnd("SgAsmDOSFileHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** On-disk format of DOS file header. */
    struct DOSFileHeader_disk {
        unsigned char e_magic[2];                /**< 0x00 "MZ" */
        uint16_t      e_last_page_size;          /**< 0x02 bytes used on last page of file (1 page == 512 bytes);
                                                  *        zero implies if last page is full. */ //
        uint16_t      e_total_pages;             /**< 0x04 number of pages (inc. last possibly partial page) in file. */
        uint16_t      e_nrelocs;                 /**< 0x06 number of relocation entries stored after this header. */
        uint16_t      e_header_paragraphs;       /**< 0x08 header size in paragraphs (16-byte blocks) inc. relocations. */
        uint16_t      e_minalloc;                /**< 0x0a number of extra paragraphs needed, similar to BSS in Unix. */
        uint16_t      e_maxalloc;                /**< 0x0c max paragraphs to allocate for BSS. */
        uint16_t      e_ss;                      /**< 0x0e initial value of SS register relative to program load segment. */
        uint16_t      e_sp;                      /**< 0x10 initial value for SP register. */
        uint16_t      e_cksum;                   /**< 0x12 checksum; 16-bit sum of all words in file should be zero
                                                  *        (usually not filled in). */
        uint16_t      e_ip;                      /**< 0x14 initial value for IP register. */
        uint16_t      e_cs;                      /**< 0x16 initial value for CS register relative to program load segment. */
        uint16_t      e_relocs_offset;           /**< 0x18 file address of relocation table. */
        uint16_t      e_overlay;                 /**< 0x1a overlay number (zero indicates main program). */
        uint32_t      e_res1;                    /**< 0x1c unknown purpose. */
    }                                            /* 0x20 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct DOSRelocEntry_disk {
        uint16_t      offset;                       /* 0x00 */
        uint16_t      segment;                      /* 0x02 */
    }                                               /* 0x04 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Last page size.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_last_page_size() const;
    void set_e_last_page_size(uint16_t const&);
    /** @} */

public:
    /** Property: Total number of pages.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_total_pages() const;
    void set_e_total_pages(uint16_t const&);
    /** @} */

public:
    /** Property: Number of relocations.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_nrelocs() const;
    void set_e_nrelocs(uint16_t const&);
    /** @} */

public:
    /** Property: Number of header paragraphs.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_header_paragraphs() const;
    void set_e_header_paragraphs(uint16_t const&);
    /** @} */

public:
    /** Property: Min alloc.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_minalloc() const;
    void set_e_minalloc(uint16_t const&);
    /** @} */

public:
    /** Property: Max alloc.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_maxalloc() const;
    void set_e_maxalloc(uint16_t const&);
    /** @} */

public:
    /** Property: SS.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_ss() const;
    void set_e_ss(uint16_t const&);
    /** @} */

public:
    /** Property: SP.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_sp() const;
    void set_e_sp(uint16_t const&);
    /** @} */

public:
    /** Property: Checksum.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_cksum() const;
    void set_e_cksum(uint16_t const&);
    /** @} */

public:
    /** Property: IP.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_ip() const;
    void set_e_ip(uint16_t const&);
    /** @} */

public:
    /** Property: CS.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_cs() const;
    void set_e_cs(uint16_t const&);
    /** @} */

public:
    /** Property: Overlay.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    uint16_t const& get_e_overlay() const;
    void set_e_overlay(uint16_t const&);
    /** @} */

public:
    /** Property: Relocs offset.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    rose_addr_t const& get_e_relocs_offset() const;
    void set_e_relocs_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: Reserved field 1.
     *
     *  See DOS specification. 
     *  
     *  @{ */
    unsigned const& get_e_res1() const;
    void set_e_res1(unsigned const&);
    /** @} */

public:
    /** Property: Section containing relocation information. 
     * 
     * @{ */
    SgAsmGenericSection* const& get_relocs() const;
    void set_relocs(SgAsmGenericSection* const&);
    /** @} */

public:
    /** Property: Real mode section. 
     * 
     * @{ */
    SgAsmGenericSection* const& get_rm_section() const;
    void set_rm_section(SgAsmGenericSection* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmDOSFileHeader(SgAsmGenericFile*);
    virtual SgAsmDOSFileHeader *parse() override {return parse(true);}
    SgAsmDOSFileHeader *parse(bool define_rm_section);
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    virtual const char *formatName() const override;

    /** Parses the DOS real-mode text+data section and adds it to the AST.
     *
     *  If max_offset is non-zero then use that as the maximum offset of the real-mode section. If the DOS header indicates a zero
     *  sized section then return NULL. If the section exists or is zero size due to the max_offset then return the section. See
     *  also, update_from_rm_section(). */
    SgAsmGenericSection *parseRealModeSection(rose_addr_t max_offset=0);

    /** Update DOS header with data from real-mode section.
     *
     *  The DOS real-mode data+text section is assumed to appear immediately after the DOS Extended Header, which appears
     *  immediately after the DOS File Header, which appears at the beginning of the file. These assumptions are not checked until
     *  SgAsmDOSFileHeader::unparse() is called. See also, @ref parseRealModeSection. */
    void updateFromRealModeSection();

    /** Returns true if a cursory look at the file indicates that it could be a DOS executable file. */
    static bool isDos(SgAsmGenericFile*);

private:
    void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    virtual const char* format_name() const override ROSE_DEPRECATED("use formatName");
    SgAsmGenericSection* parse_rm_section(rose_addr_t max_offset = 0) ROSE_DEPRECATED("use parseRealModeSection");
    void update_from_rm_section() ROSE_DEPRECATED("use updateFromRealModeSection");
    static bool is_DOS(SgAsmGenericFile*) ROSE_DEPRECATED("use isDos");
public:
    /** Destructor. */
    virtual ~SgAsmDOSFileHeader();

public:
    /** Default constructor. */
    SgAsmDOSFileHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDOSFileHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmGenericHeader = nonTerminalConstructor(
    "AsmGenericHeader",
    *this,
    "AsmGenericHeader",
    "AsmGenericHeaderTag",
    SubclassListBuilder()
        | AsmDOSFileHeader
        | AsmElfFileHeader
        | AsmJvmFileHeader
        | AsmLEFileHeader
        | AsmNEFileHeader
        | AsmPEFileHeader
    , true);
assert(AsmGenericHeader.associatedGrammar != nullptr);
AsmGenericHeader.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericHeader.isBoostSerializable(true);
AsmGenericHeader.setAutomaticGenerationOfConstructor(false);
AsmGenericHeader.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmGenericHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericHeader);
#if defined(SgAsmGenericHeader_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <sageContainer.h>
#include <SgAsmGenericFormat.h>

#ifdef ROSE_SgAsmGenericHeader_IMPL
#include <SgAsmGenericDLLList.h>
#include <SgAsmGenericSectionList.h>
#endif

class SgAsmGenericDLL;
class SgAsmGenericDLLList;
#endif // SgAsmGenericHeader_HEADERS

#ifdef DOCUMENTATION
/** Base class for container file headers. */
class SgAsmGenericHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericFormat*", "executableFormat", "= createAndParent<SgAsmGenericFormat>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgCharList", "magic", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericFormat::InsSetArchitecture", "isa", "= SgAsmGenericFormat::ISA_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "rose_addr_t", "baseVa", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgRVAList", "entryRvas", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericDLLList*", "dlls", "= createAndParent<SgAsmGenericDLLList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericSectionList*", "sections", "= createAndParent<SgAsmGenericSectionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericHeader);
#if defined(SgAsmGenericHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_executableFormat);
        s & BOOST_SERIALIZATION_NVP(p_magic);
        s & BOOST_SERIALIZATION_NVP(p_isa);
        s & BOOST_SERIALIZATION_NVP(p_baseVa);
        s & BOOST_SERIALIZATION_NVP(p_entryRvas);
        s & BOOST_SERIALIZATION_NVP(p_dlls);
        s & BOOST_SERIALIZATION_NVP(p_sections);
        debugSerializationEnd("SgAsmGenericHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: General info about the executable format. 
     * 
     * @{ */
    SgAsmGenericFormat* const& get_executableFormat() const;
    void set_executableFormat(SgAsmGenericFormat* const&);
    /** @} */

public:
    /** Property: Optional magic number in file byte order. 
     * 
     * @{ */
    SgCharList const& get_magic() const;
    SgCharList& get_magic();
    void set_magic(SgCharList const&);
    /** @} */

public:
    /** Property: Machine for which this header and its sections, etc. was compiled. 
     * 
     * @{ */
    SgAsmGenericFormat::InsSetArchitecture const& get_isa() const;
    void set_isa(SgAsmGenericFormat::InsSetArchitecture const&);
    /** @} */

public:
    /** Property: Base virtual address used by all relative virtual addresses. 
     * 
     * @{ */
    rose_addr_t const& get_baseVa() const;
    void set_baseVa(rose_addr_t const&);
    /** @} */

public:
    /** Property: Code entry point wrt base virtual address. 
     * 
     * @{ */
    SgRVAList const& get_entryRvas() const;
    SgRVAList& get_entryRvas();
    void set_entryRvas(SgRVAList const&);
    /** @} */

public:
    /** Property: List of dynamically linked libraries. 
     * 
     * @{ */
    SgAsmGenericDLLList* const& get_dlls() const;
    void set_dlls(SgAsmGenericDLLList* const&);
    /** @} */

public:
    /** Property: List of file sections. 
     * 
     * @{ */
    SgAsmGenericSectionList* const& get_sections() const;
    void set_sections(SgAsmGenericSectionList* const&);
    /** @} */
public:
    /** Constructor.
     *
     *  Headers (@ref SgAsmGenericHeader and derived classes) set the file/header relationship--a bidirectional link
     *  between this new header and the single file that contains this new header. This new header points to its file and
     *  the file contains a list that points to this new header. The header-to-file half of the link is deleted by the
     *  default destructor by virtue of being a simple pointer, but we also need to delete the other half of the link in
     *  the destructors. */
    explicit SgAsmGenericHeader(SgAsmGenericFile*);

    virtual bool reallocate() override;

    /** Unparse headers and all they point to */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Returns the name of the file format. */
    virtual const char *formatName() const;

    /** Add a new DLL to the header DLL list */
    void addDll(SgAsmGenericDLL *dll);

    /** Vector of dynamically loaded libraries. */
    std::vector<SgAsmGenericDLL*>& get_dlls();

    /** Returns the RVA of the first entry point.
     *
     *  The return value is relative to the header's base virtual address. If there are no entry points defined then
     *  returns a zero RVA. */
    rose_addr_t get_entryRva() const;

    /** Append an RVA to the list of entry points. */
    void addEntryRva(const Rose::BinaryAnalysis::RelativeVirtualAddress&);

    /* Convenience functions */
    Rose::BinaryAnalysis::ByteOrder::Endianness get_sex() const;
    size_t get_wordSize() const;

    /** Adds a new section to the header.
     *
     *  This is called implicitly by the section constructor. */
    void addSection(SgAsmGenericSection*);

    /** Removes a secton from the header's section list. */
    void removeSection(SgAsmGenericSection*);

    /** Returns the list of sections that are memory mapped */
    SgAsmGenericSectionPtrList get_mappedSections() const;

    /** Returns sections in this header that have the specified ID. */
    SgAsmGenericSectionPtrList get_sectionsById(int id) const;

    /** Returns sections in this header that have the specified name.
     *
     *  If @p sep is a non-null string then ignore any part of name at and after @p sep. */
    SgAsmGenericSectionPtrList get_sectionsByName(std::string, char sep=0) const;

    /** Returns sectons in this header that contain all of the specified portion of the file. */
    SgAsmGenericSectionPtrList get_sectionsByOffset(rose_addr_t offset, rose_addr_t size) const;

    /** Returns sections that have a preferred mapping that includes the specified relative virtual address. */
    SgAsmGenericSectionPtrList get_sectionsByRva(rose_addr_t rva) const;

    /** Returns sections having a preferred or actual mapping that includes the specified virtual address.
     *
     *  If @p use_preferred is set, then the condition is evaluated by looking at the section's preferred mapping,
     *  otherwise the actual mapping is used.  If an actual mapping is used, the specified virtual address must be part of
     *  the actual mapped section, not merely in the memory region that was also mapped to satisfy alignment
     *  constraints. */
    SgAsmGenericSectionPtrList get_sectionsByVa(rose_addr_t va, bool use_preferred) const;

    /** Returns single section in this header that has the specified ID. */
    SgAsmGenericSection *get_sectionById(int id, size_t *nfound=0) const;

    /** Returns single section in this header that has the specified name. */
    SgAsmGenericSection *get_sectionByName(const std::string&, char sep=0, size_t *nfound=0) const;

    /** Returns single section in this header that contains all of the specified portion of the file. */
    SgAsmGenericSection *get_sectionByOffset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;

    /** Returns the single section having a preferred mapping that includes the specified relative virtual address.
     *
     *  If there are no sections or multiple sections satisfying this condition then a null pointer is returned. */
    SgAsmGenericSection *get_sectionByRva(rose_addr_t rva, size_t *nfound=0) const;

    /** Returns the section having a preferred or actual mapping that includes the specified virtual address.
     *
     *  If @p use_preferred is set, then the condition is evaluated by looking at the section's preferred mapping,
     *  otherwise the actual mapping is used. If an actual mapping is used, the specified virtual address must be part of
     *  the actual mapped section, not merely in the memory region that was also mapped to satisfy alignment constraints.
     *  If there are no sections or multiple sections satisfying this condition then a null pointer is returned. */
    SgAsmGenericSection *get_sectionByVa(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;

    /** Like SgAsmGenericFile::get_best_section_by_va() except considers only sections defined in this header. */
    SgAsmGenericSection *get_bestSectionByVa(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmGenericFormat* get_exec_format() const ROSE_DEPRECATED("use get_executableFormat");
    void set_exec_format(SgAsmGenericFormat*) ROSE_DEPRECATED("use set_executableFormat");
    rose_addr_t get_base_va() const ROSE_DEPRECATED("use get_baseVa");
    void set_base_va(rose_addr_t) ROSE_DEPRECATED("use set_baseVa");
    SgRVAList& get_entry_rvas() ROSE_DEPRECATED("use get_entryRvas");
    const SgRVAList& get_entry_rvas() const ROSE_DEPRECATED("use get_entryRvas");
    void set_entry_rvas(const SgRVAList&) ROSE_DEPRECATED("use set_entryRvas");
    virtual const char *format_name() const ROSE_DEPRECATED("use formatName");
    void add_dll(SgAsmGenericDLL*) ROSE_DEPRECATED("use addDll");
    rose_addr_t get_entry_rva() const ROSE_DEPRECATED("use get_entryRva");
    void add_entry_rva(const Rose::BinaryAnalysis::RelativeVirtualAddress&) ROSE_DEPRECATED("use addEntryRva");
    size_t get_word_size() const ROSE_DEPRECATED("use get_wordSize");
    void add_section(SgAsmGenericSection*) ROSE_DEPRECATED("use addSection");
    void remove_section(SgAsmGenericSection*) ROSE_DEPRECATED("use removeSection");
    SgAsmGenericSectionPtrList get_mapped_sections() const ROSE_DEPRECATED("use get_mappedSections");
    SgAsmGenericSectionPtrList get_sections_by_id(int) const ROSE_DEPRECATED("use get_sectionsById");
    SgAsmGenericSectionPtrList get_sections_by_name(std::string, char=0) const ROSE_DEPRECATED("use get_sectionsByName");
    SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t, rose_addr_t) const ROSE_DEPRECATED("use get_sectionsByOffset");
    SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t) const ROSE_DEPRECATED("use get_sectionsByRva");
    SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t, bool) const ROSE_DEPRECATED("use get_sectionsByVa");
    SgAsmGenericSection *get_section_by_id(int, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionById");
    SgAsmGenericSection *get_section_by_name(const std::string&, char=0, size_t* = nullptr) const
        ROSE_DEPRECATED("use get_sectionByName");
    SgAsmGenericSection *get_section_by_offset(rose_addr_t, rose_addr_t, size_t* = nullptr) const
        ROSE_DEPRECATED("use get_sectionByOffset");
    SgAsmGenericSection *get_section_by_rva(rose_addr_t, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionByRva");
    SgAsmGenericSection *get_section_by_va(rose_addr_t, bool, size_t* = nullptr) const ROSE_DEPRECATED("use get_sectionByVa");
    SgAsmGenericSection *get_best_section_by_va(rose_addr_t, bool, size_t* = nullptr) const ROSE_DEPRECATED("use get_bestSectionByVa");
public:
    /** Destructor. */
    virtual ~SgAsmGenericHeader();

public:
    /** Default constructor. */
    SgAsmGenericHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDOSExtendedHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDOSExtendedHeader);
IS_SERIALIZABLE(AsmDOSExtendedHeader);

#ifndef DOCUMENTATION
AsmDOSExtendedHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** DOS exteded header.
 *
 *  Most of the properties correspond to those defined in the PE/DOS specifications and that documentation is not repeated here. */
class SgAsmDOSExtendedHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_oemid", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_oeminfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res2", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res3", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res4", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res5", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res6", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmDOSExtendedHeader.setDataPrototype(
        "rose_addr_t", "e_lfanew", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmDOSExtendedHeader);
#if defined(SgAsmDOSExtendedHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDOSExtendedHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDOSExtendedHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
        s & BOOST_SERIALIZATION_NVP(p_e_oemid);
        s & BOOST_SERIALIZATION_NVP(p_e_oeminfo);
        s & BOOST_SERIALIZATION_NVP(p_e_res2);
        s & BOOST_SERIALIZATION_NVP(p_e_res3);
        s & BOOST_SERIALIZATION_NVP(p_e_res4);
        s & BOOST_SERIALIZATION_NVP(p_e_res5);
        s & BOOST_SERIALIZATION_NVP(p_e_res6);
        s & BOOST_SERIALIZATION_NVP(p_e_lfanew);
        debugSerializationEnd("SgAsmDOSExtendedHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct DOSExtendedHeader_disk {
        uint32_t      e_res1;     /* 0x00 reserved */
        uint16_t      e_oemid;    /* 0x04 OEM Identifier */
        uint16_t      e_oeminfo;  /* 0x06 other OEM information; oemid specific */
        uint32_t      e_res2;     /* 0x08 reserved */
        uint32_t      e_res3;     /* 0x0c reserved */
        uint32_t      e_res4;     /* 0x10 reserved */
        uint32_t      e_res5;     /* 0x14 reserved */
        uint32_t      e_res6;     /* 0x18 reserved */
        uint32_t      e_lfanew;   /* 0x1c file offset of new exe (PE) header */
    }                                 /* 0x20 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Rerserved area 1.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res1() const;
    void set_e_res1(unsigned const&);
    /** @} */

public:
    /** Property: OEM ID.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_oemid() const;
    void set_e_oemid(unsigned const&);
    /** @} */

public:
    /** Property: OEM info.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_oeminfo() const;
    void set_e_oeminfo(unsigned const&);
    /** @} */

public:
    /** Property: Rerserved area 2.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res2() const;
    void set_e_res2(unsigned const&);
    /** @} */

public:
    /** Property: Rerserved area 3.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res3() const;
    void set_e_res3(unsigned const&);
    /** @} */

public:
    /** Property: Rerserved area 4.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res4() const;
    void set_e_res4(unsigned const&);
    /** @} */

public:
    /** Property: Rerserved area 5.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res5() const;
    void set_e_res5(unsigned const&);
    /** @} */

public:
    /** Property: Rerserved area 6.
     *
     *  See PE specification. 
     *  
     *  @{ */
    unsigned const& get_e_res6() const;
    void set_e_res6(unsigned const&);
    /** @} */

public:
    /** Property: lfanew.
     *
     *  See PE specification. 
     *  
     *  @{ */
    rose_addr_t const& get_e_lfanew() const;
    void set_e_lfanew(rose_addr_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmDOSExtendedHeader(SgAsmDOSFileHeader*);
    virtual SgAsmDOSExtendedHeader *parse() override;
    void *encode(SgAsmDOSExtendedHeader::DOSExtendedHeader_disk*) const;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmDOSExtendedHeader();

public:
    /** Default constructor. */
    SgAsmDOSExtendedHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDOSExtendedHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDirectRegisterExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmDirectRegisterExpression);
IS_SERIALIZABLE(AsmDirectRegisterExpression);

#ifndef DOCUMENTATION
AsmDirectRegisterExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression representing a machine register. */
class SgAsmDirectRegisterExpression: public SgAsmRegisterReferenceExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmDirectRegisterExpression);
#if defined(SgAsmDirectRegisterExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmDirectRegisterExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmDirectRegisterExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmRegisterReferenceExpression);
        debugSerializationEnd("SgAsmDirectRegisterExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmDirectRegisterExpression();

public:
    /** Default constructor. */
    SgAsmDirectRegisterExpression();

public:
    /** Constructor. */
    explicit SgAsmDirectRegisterExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDirectRegisterExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRegisterReferenceExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmRegisterReferenceExpression = nonTerminalConstructor(
    "AsmRegisterReferenceExpression",
    *this,
    "AsmRegisterReferenceExpression",
    "AsmRegisterReferenceExpressionTag",
    SubclassListBuilder()
        | AsmDirectRegisterExpression
        | AsmIndirectRegisterExpression
    , false);
assert(AsmRegisterReferenceExpression.associatedGrammar != nullptr);
AsmRegisterReferenceExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmRegisterReferenceExpression.isBoostSerializable(true);
AsmRegisterReferenceExpression.setAutomaticGenerationOfConstructor(false);
AsmRegisterReferenceExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmRegisterReferenceExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for references to a machine register. */
class SgAsmRegisterReferenceExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRegisterReferenceExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "descriptor", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmRegisterReferenceExpression.setDataPrototype(
        "int", "adjustment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmRegisterReferenceExpression);
#if defined(SgAsmRegisterReferenceExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmRegisterReferenceExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmRegisterReferenceExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_descriptor);
        s & BOOST_SERIALIZATION_NVP(p_adjustment);
        debugSerializationEnd("SgAsmRegisterReferenceExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Descriptor for accessed register. 
     * 
     * @{ */
    Rose::BinaryAnalysis::RegisterDescriptor const& get_descriptor() const;
    void set_descriptor(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */

public:
    /** Property: Post-increment or pre-decrement amount.
     *
     *  This is a value that's added or subtracted from a register each time the containing instruction is executed. 
     *  
     *  @{ */
    int const& get_adjustment() const;
    void set_adjustment(int const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmRegisterReferenceExpression();

protected:
    /** Default constructor. */
    SgAsmRegisterReferenceExpression();

protected:
    /** Constructor. */
    explicit SgAsmRegisterReferenceExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRegisterReferenceExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmControlFlagsExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmControlFlagsExpression);
IS_SERIALIZABLE(AsmControlFlagsExpression);

#ifndef DOCUMENTATION
AsmControlFlagsExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmControlFlagsExpression);
#if defined(SgAsmControlFlagsExpression_HEADERS) || defined(DOCUMENTATION)
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmControlFlagsExpression_HEADERS

#ifdef DOCUMENTATION
class SgAsmControlFlagsExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmControlFlagsExpression.setDataPrototype(
        "unsigned long", "bitFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmControlFlagsExpression);
#if defined(SgAsmControlFlagsExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmControlFlagsExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmControlFlagsExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_bitFlags);
        debugSerializationEnd("SgAsmControlFlagsExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    unsigned long const& get_bitFlags() const;
    void set_bitFlags(unsigned long const&);
    // [Robb Matzke 2023-11-06] deprecated 2023-11
    unsigned long get_bit_flags() const ROSE_DEPRECATED("use get_bitFlags");
    void set_bit_flags(unsigned long) ROSE_DEPRECATED("use set_bitFlags");
public:
    /** Destructor. */
    virtual ~SgAsmControlFlagsExpression();

public:
    /** Default constructor. */
    SgAsmControlFlagsExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmControlFlagsExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmConstantExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmConstantExpression = nonTerminalConstructor(
    "AsmConstantExpression",
    *this,
    "AsmConstantExpression",
    "AsmConstantExpressionTag",
    SubclassListBuilder()
        | AsmFloatValueExpression
        | AsmIntegerValueExpression
    , false);
assert(AsmConstantExpression.associatedGrammar != nullptr);
AsmConstantExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmConstantExpression.isBoostSerializable(true);
AsmConstantExpression.setAutomaticGenerationOfConstructor(false);
AsmConstantExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmConstantExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmConstantExpression);
#if defined(SgAsmConstantExpression_HEADERS) || defined(DOCUMENTATION)
#include <Sawyer/BitVector.h>
#endif // SgAsmConstantExpression_HEADERS

#ifdef DOCUMENTATION
/** Base class for constants.
 *
 *  Represents integer values, floating-point values, etc. This class holds the actual bits for the constant value.
 *  Subclasses provide the intepretation of those bits. */
class SgAsmConstantExpression: public SgAsmValueExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmConstantExpression.setDataPrototype(
        "Sawyer::Container::BitVector", "bitVector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmConstantExpression);
#if defined(SgAsmConstantExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmConstantExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmConstantExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmValueExpression);
        s & BOOST_SERIALIZATION_NVP(p_bitVector);
        debugSerializationEnd("SgAsmConstantExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Bits for constant.
     *
     *  This is the canonical value of an AST node; subclasses may cache native representations of this value. 
     *  
     *  @{ */
    Sawyer::Container::BitVector const& get_bitVector() const;
    Sawyer::Container::BitVector& get_bitVector();
    void set_bitVector(Sawyer::Container::BitVector const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmConstantExpression();

protected:
    /** Default constructor. */
    SgAsmConstantExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmConstantExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmValueExpression = nonTerminalConstructor(
    "AsmValueExpression",
    *this,
    "AsmValueExpression",
    "AsmValueExpressionTag",
    SubclassListBuilder()
        | AsmConstantExpression
    , false);
assert(AsmValueExpression.associatedGrammar != nullptr);
AsmValueExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmValueExpression.isBoostSerializable(true);
AsmValueExpression.setAutomaticGenerationOfConstructor(false);
AsmValueExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmValueExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for values.
 *
 *  Assembly instruction (@ref SgAsmInstruction) operands are represented by @ref SgAsmExpression nodes in the AST. If the
 *  expression has a numeric value then an @ref SgAsmValueExpression is used.  Values of various types (integers and
 *  floating-point values of various sizes) are represented by subclasses of @ref SgAsmValueExpression.  Values that are
 *  addresses or references to data will have symbols in a function symbol table.  All other values are assumed to be
 *  literals and will not have associated symbols. */
class SgAsmValueExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmValueExpression.setDataPrototype(
        "SgAsmValueExpression*", "unfoldedExpression", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmValueExpression.setDataPrototype(
        "unsigned short", "bitOffset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmValueExpression.setDataPrototype(
        "unsigned short", "bitSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmValueExpression.setDataPrototype(
        "SgSymbol*", "symbol", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmValueExpression);
#if defined(SgAsmValueExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmValueExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmValueExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_unfoldedExpression);
        s & BOOST_SERIALIZATION_NVP(p_bitOffset);
        s & BOOST_SERIALIZATION_NVP(p_bitSize);
        debugSerializationEnd("SgAsmValueExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Alternate expression without constant folding.
     *
     *  This is an optional expression that's equivalent to this expression but without constant folding.
     *
     *  Note: All of the ROSE disassemblers always set this to null regardless of whether they do any constant folding. 
     *  
     *  @{ */
    SgAsmValueExpression* const& get_unfoldedExpression() const;
    void set_unfoldedExpression(SgAsmValueExpression* const&);
    /** @} */

public:
    /** Property: Where this expression is encoded within the instruction.
     *
     *  This is the bit offset into the instruction's raw bytes where this expression is encoded. If it is not supported by
     *  the architectures, it will be set to zero and the "bit_size" property will also be zero.  Bits are numbered so that
     *  bits zero through seven are in the first byte, bits eight through 15 are in the second byte, etc. Within a byte,
     *  bits are numbered so that lower indexes are less significant bits. 
     *  
     *  @{ */
    unsigned short const& get_bitOffset() const;
    void set_bitOffset(unsigned short const&);
    /** @} */

public:
    /** Property: Where this expression is encoded within the instruction.
     *
     *  This is the size in bits of the encoding for this expression within the instruction.  If it is not supported by
     *  the architecture, it will be set to zero. 
     *  
     *  @{ */
    unsigned short const& get_bitSize() const;
    void set_bitSize(unsigned short const&);
    /** @} */

public:
    /** Property: Symbol corresponding to this expression.
     *
     *  If a symbol refers to this expression then it is linked by this property, otherwise null.  The symbol is not
     *  considered to be a child of this node in the AST. 
     *  
     *  @{ */
    SgSymbol* const& get_symbol() const;
    void set_symbol(SgSymbol* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmValueExpression* get_unfolded_expression_tree() const ROSE_DEPRECATED("use get_unfoldedExpression");
    void set_unfolded_expression_tree(SgAsmValueExpression*) ROSE_DEPRECATED("use set_unfoldedExpression");
    unsigned short get_bit_offset() const ROSE_DEPRECATED("use get_bitOffset");
    void set_bit_offset(unsigned short) ROSE_DEPRECATED("use set_bitOffset");
    unsigned short get_bit_size() const ROSE_DEPRECATED("use get_bitSize");
    void set_bit_size(unsigned short) ROSE_DEPRECATED("use set_bitSize");
public:
    /** Destructor. */
    virtual ~SgAsmValueExpression();

protected:
    /** Default constructor. */
    SgAsmValueExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmValueExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCommonSubExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCommonSubExpression);
IS_SERIALIZABLE(AsmCommonSubExpression);

#ifndef DOCUMENTATION
AsmCommonSubExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCommonSubExpression);
#if defined(SgAsmCommonSubExpression_HEADERS) || defined(DOCUMENTATION)
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmCommonSubExpression_HEADERS

#ifdef DOCUMENTATION
class SgAsmCommonSubExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCommonSubExpression.setDataPrototype(
        "SgAsmExpression*", "subexpression", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCommonSubExpression);
#if defined(SgAsmCommonSubExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCommonSubExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCommonSubExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_subexpression);
        debugSerializationEnd("SgAsmCommonSubExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    SgAsmExpression* const& get_subexpression() const;
    void set_subexpression(SgAsmExpression* const&);

public:
    /** Destructor. */
    virtual ~SgAsmCommonSubExpression();

public:
    /** Default constructor. */
    SgAsmCommonSubExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCommonSubExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbolTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCoffSymbolTable);
IS_SERIALIZABLE(AsmCoffSymbolTable);

#ifndef DOCUMENTATION
AsmCoffSymbolTable.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCoffSymbolTable);
#if defined(SgAsmCoffSymbolTable_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmCoffSymbolTable_IMPL
#include <SgAsmCoffSymbolList.h>
#endif
#endif // SgAsmCoffSymbolTable_HEADERS

#ifdef DOCUMENTATION
/** COFF symbol table.
 *
 *  This is a symbol table used by Microsoft PE format. */
class SgAsmCoffSymbolTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbolTable.setDataPrototype(
        "SgAsmGenericSection*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbolTable.setDataPrototype(
        "SgAsmCoffSymbolList*", "symbols", "= createAndParent<SgAsmCoffSymbolList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCoffSymbolTable);
#if defined(SgAsmCoffSymbolTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCoffSymbolTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCoffSymbolTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_strtab);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmCoffSymbolTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: String table.
     *
     *  Table that holds the strings for the symbol names. 
     *  
     *  @{ */
    SgAsmGenericSection* const& get_strtab() const;
    void set_strtab(SgAsmGenericSection* const&);
    /** @} */

public:
    /** Property: List of symbols. 
     * 
     * @{ */
    SgAsmCoffSymbolList* const& get_symbols() const;
    void set_symbols(SgAsmCoffSymbolList* const&);
    /** @} */
public:
    explicit SgAsmCoffSymbolTable(SgAsmPEFileHeader*);
    size_t get_nslots() const;
    virtual SgAsmCoffSymbolTable *parse() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbolTable();

public:
    /** Default constructor. */
    SgAsmCoffSymbolTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbolTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCoffSymbolList);
IS_SERIALIZABLE(AsmCoffSymbolList);

#ifndef DOCUMENTATION
AsmCoffSymbolList.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCoffSymbolList);
#if defined(SgAsmCoffSymbolList_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmCoffSymbolList_HEADERS

#ifdef DOCUMENTATION
/** List of COFF symbols. */
class SgAsmCoffSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbolList.setDataPrototype(
        "SgAsmCoffSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCoffSymbolList);
#if defined(SgAsmCoffSymbolList_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCoffSymbolList -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCoffSymbolList");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_symbols);
        debugSerializationEnd("SgAsmCoffSymbolList");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: List of symbol pointers. 
     * 
     * @{ */
    SgAsmCoffSymbolPtrList const& get_symbols() const;
    SgAsmCoffSymbolPtrList& get_symbols();
    void set_symbols(SgAsmCoffSymbolPtrList const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbolList();

public:
    /** Default constructor. */
    SgAsmCoffSymbolList();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbolList_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCoffSymbol);
IS_SERIALIZABLE(AsmCoffSymbol);

#ifndef DOCUMENTATION
AsmCoffSymbol.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCoffSymbol);
#if defined(SgAsmCoffSymbol_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>
#endif // SgAsmCoffSymbol_HEADERS

#ifdef DOCUMENTATION
/** COFF symbol. */
class SgAsmCoffSymbol: public SgAsmGenericSymbol {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "std::string", "st_name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "rose_addr_t", "st_name_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "int", "st_section_num", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_storage_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_num_aux_entries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCoffSymbol.setDataPrototype(
        "SgUnsignedCharList", "auxiliaryData", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCoffSymbol);
#if defined(SgAsmCoffSymbol_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCoffSymbol -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCoffSymbol");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSymbol);
        s & BOOST_SERIALIZATION_NVP(p_st_name);
        s & BOOST_SERIALIZATION_NVP(p_st_name_offset);
        s & BOOST_SERIALIZATION_NVP(p_st_section_num);
        s & BOOST_SERIALIZATION_NVP(p_st_type);
        s & BOOST_SERIALIZATION_NVP(p_st_storage_class);
        s & BOOST_SERIALIZATION_NVP(p_st_num_aux_entries);
        s & BOOST_SERIALIZATION_NVP(p_auxiliaryData);
        debugSerializationEnd("SgAsmCoffSymbol");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct COFFSymbol_disk {
        union {
            char            st_name[8];
            struct {
                uint32_t    st_zero;
                uint32_t    st_offset;
            };
        };
        uint32_t            st_value;
        int16_t             st_section_num;
        uint16_t            st_type;
        unsigned char       st_storage_class;
        unsigned char       st_num_aux_entries;
    }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties and data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Symbol name. 
     * 
     * @{ */
    std::string const& get_st_name() const;
    void set_st_name(std::string const&);
    /** @} */

public:
    /** Property: Symbol name offset. 
     * 
     * @{ */
    rose_addr_t const& get_st_name_offset() const;
    void set_st_name_offset(rose_addr_t const&);
    /** @} */

public:
    /** Property: Section number. 
     * 
     * @{ */
    int const& get_st_section_num() const;
    void set_st_section_num(int const&);
    /** @} */

public:
    /** Property: Symbol type constant. 
     * 
     * @{ */
    unsigned const& get_st_type() const;
    void set_st_type(unsigned const&);
    /** @} */

public:
    /** Property: Symbol storage class. 
     * 
     * @{ */
    unsigned const& get_st_storage_class() const;
    void set_st_storage_class(unsigned const&);
    /** @} */

public:
    /** Property: Number of auxilliary entries. 
     * 
     * @{ */
    unsigned const& get_st_num_aux_entries() const;
    void set_st_num_aux_entries(unsigned const&);
    /** @} */

public:
    /** Property: Auxilliary data. 
     * 
     * @{ */
    SgUnsignedCharList const& get_auxiliaryData() const;
    SgUnsignedCharList& get_auxiliaryData();
    void set_auxiliaryData(SgUnsignedCharList const&);
    /** @} */
public:
    static const unsigned int COFFSymbol_disk_size = 18;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
    void *encode(SgAsmCoffSymbol::COFFSymbol_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    const SgUnsignedCharList& get_aux_data() const ROSE_DEPRECATED("use get_auxiliaryData");
    void set_aux_data(const SgUnsignedCharList&) ROSE_DEPRECATED("use set_auxiliaryData");
public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbol();

public:
    /** Default constructor. */
    SgAsmCoffSymbol();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbol_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmGenericSymbol = nonTerminalConstructor(
    "AsmGenericSymbol",
    *this,
    "AsmGenericSymbol",
    "AsmGenericSymbolTag",
    SubclassListBuilder()
        | AsmCoffSymbol
        | AsmElfSymbol
    , false);
assert(AsmGenericSymbol.associatedGrammar != nullptr);
AsmGenericSymbol.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericSymbol.isBoostSerializable(true);
AsmGenericSymbol.setAutomaticGenerationOfConstructor(false);
AsmGenericSymbol.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmGenericSymbol.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericSymbol);
#if defined(SgAsmGenericSymbol_HEADERS) || defined(DOCUMENTATION)
/* Base class for symbol tables. */
#endif // SgAsmGenericSymbol_HEADERS

#ifdef DOCUMENTATION
class SgAsmGenericSymbol: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolDefState", "definitionState", "= SgAsmGenericSymbol::SYM_UNDEFINED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolBinding", "binding", "= SgAsmGenericSymbol::SYM_NO_BINDING",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolType", "type", "= SgAsmGenericSymbol::SYM_NO_TYPE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "rose_addr_t", "value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSection*", "bound", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericSymbol);
#if defined(SgAsmGenericSymbol_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericSymbol -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericSymbol");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_definitionState);
        s & BOOST_SERIALIZATION_NVP(p_binding);
        s & BOOST_SERIALIZATION_NVP(p_type);
        s & BOOST_SERIALIZATION_NVP(p_value);
        s & BOOST_SERIALIZATION_NVP(p_size);
        s & BOOST_SERIALIZATION_NVP(p_bound);
        s & BOOST_SERIALIZATION_NVP(p_name);
        debugSerializationEnd("SgAsmGenericSymbol");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Symbol definition state. */
    enum SymbolDefState {
        SYM_UNDEFINED,          /**< Symbol has not been defined yet. */
        SYM_TENTATIVE,          /**< Does not have size/value yet. E.g., uninitialized C or Fortran common blks. */
        SYM_DEFINED             /**< Created and assigned storage. */
    };

    /** Symbol type. */
    enum SymbolType {
        SYM_NO_TYPE,            /**< No type or type is unknown. */
        SYM_DATA,               /**< Normal variable definitions. */
        SYM_FUNC,               /**< Function or other code. */
        SYM_SECTION,            /**< Section of a file. */
        SYM_FILE,               /**< Name of a file. */
        SYM_ARRAY,              /**< Array of some other type. */
        SYM_TLS,                /**< Thread-local storage. */
        SYM_REGISTER,           /**< CPU register value. See Sparc. */
        SYM_COMMON,             /**< Common block. */
        SYM_IFUNC               /**< Indirection function. */
    };

    /** Symbol binding. */
    enum SymbolBinding {
        SYM_NO_BINDING,         /**< Unknown binding. */
        SYM_LOCAL,              /**< Local binding. */
        SYM_GLOBAL,             /**< Global binding. */
        SYM_WEAK                /**< Weak binding. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Definition state. 
     * 
     * @{ */
    SgAsmGenericSymbol::SymbolDefState const& get_definitionState() const;
    void set_definitionState(SgAsmGenericSymbol::SymbolDefState const&);
    /** @} */

public:
    /** Property: Symbol binding. 
     * 
     * @{ */
    SgAsmGenericSymbol::SymbolBinding const& get_binding() const;
    void set_binding(SgAsmGenericSymbol::SymbolBinding const&);
    /** @} */

public:
    /** Property: Symbol type. 
     * 
     * @{ */
    SgAsmGenericSymbol::SymbolType const& get_type() const;
    void set_type(SgAsmGenericSymbol::SymbolType const&);
    /** @} */

public:
    /** Property: Symbol value. 
     * 
     * @{ */
    rose_addr_t const& get_value() const;
    void set_value(rose_addr_t const&);
    /** @} */

public:
    /** Property: Symbol size in bytes. 
     * 
     * @{ */
    rose_addr_t const& get_size() const;
    void set_size(rose_addr_t const&);
    /** @} */

public:
    /** Property: Associated file section. 
     * 
     * @{ */
    SgAsmGenericSection* const& get_bound() const;
    void set_bound(SgAsmGenericSection* const&);
    /** @} */

public:
    /** Property: Name.
     *
     * @{ */
    SgAsmGenericString* get_name() const;
    void set_name(SgAsmGenericString*);
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SymbolDefState get_def_state() const ROSE_DEPRECATED("use get_definitionState");
    void set_def_state(SymbolDefState) ROSE_DEPRECATED("use set_definitionState");
public:
    /** Destructor. */
    virtual ~SgAsmGenericSymbol();

protected:
    /** Default constructor. */
    SgAsmGenericSymbol();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSymbol_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCoffStrtab);
IS_SERIALIZABLE(AsmCoffStrtab);

#ifndef DOCUMENTATION
AsmCoffStrtab.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** COFF symbol string table. */
class SgAsmCoffStrtab: public SgAsmGenericStrtab {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmCoffStrtab);
#if defined(SgAsmCoffStrtab_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCoffStrtab -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCoffStrtab");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericStrtab);
        debugSerializationEnd("SgAsmCoffStrtab");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    explicit SgAsmCoffStrtab(class SgAsmPESection *containing_section);
    void destructorHelper() override;
    virtual void unparse(std::ostream&) const;
    virtual SgAsmStringStorage *createStorage(rose_addr_t offset, bool shared) override;
    virtual rose_addr_t get_storageSize(const SgAsmStringStorage*) override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    virtual SgAsmStringStorage *create_storage(rose_addr_t, bool) override ROSE_DEPRECATED("use createStorage");
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) override ROSE_DEPRECATED("use get_storageSize");
public:
    /** Destructor. */
    virtual ~SgAsmCoffStrtab();

public:
    /** Default constructor. */
    SgAsmCoffStrtab();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffStrtab_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmGenericStrtab = nonTerminalConstructor(
    "AsmGenericStrtab",
    *this,
    "AsmGenericStrtab",
    "AsmGenericStrtabTag",
    SubclassListBuilder()
        | AsmCoffStrtab
        | AsmElfStrtab
    , false);
assert(AsmGenericStrtab.associatedGrammar != nullptr);
AsmGenericStrtab.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericStrtab.isBoostSerializable(true);
AsmGenericStrtab.setAutomaticGenerationOfConstructor(false);
AsmGenericStrtab.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmGenericStrtab.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericStrtab);
#if defined(SgAsmGenericStrtab_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>
#endif // SgAsmGenericStrtab_HEADERS

#ifdef DOCUMENTATION
/** Base class for string tables. */
class SgAsmGenericStrtab: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericStrtab.setDataPrototype(
        "SgAsmGenericSection*", "container", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericStrtab.setDataPrototype(
        "SgAsmGenericStrtab::referenced_t", "storageList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericStrtab.setDataPrototype(
        "Rose::BinaryAnalysis::AddressIntervalSet", "freeList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericStrtab.setDataPrototype(
        "SgAsmStringStorage*", "dontFree", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericStrtab.setDataPrototype(
        "size_t", "numberFreed", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericStrtab);
#if defined(SgAsmGenericStrtab_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericStrtab -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericStrtab");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_container);
        s & BOOST_SERIALIZATION_NVP(p_storageList);
        s & BOOST_SERIALIZATION_NVP(p_freeList);
        s & BOOST_SERIALIZATION_NVP(p_dontFree);
        s & BOOST_SERIALIZATION_NVP(p_numberFreed);
        debugSerializationEnd("SgAsmGenericStrtab");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    typedef std::vector<class SgAsmStringStorage*> referenced_t;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Section storing this string table. 
     * 
     * @{ */
    SgAsmGenericSection* const& get_container() const;
    void set_container(SgAsmGenericSection* const&);
    /** @} */

public:
    /** Property: String storage list. 
     * 
     * @{ */
    SgAsmGenericStrtab::referenced_t const& get_storageList() const;
    void set_storageList(SgAsmGenericStrtab::referenced_t const&);
    /** @} */

public:
    /** Property: Free space list.
     *
     *  This list stores space which is available for new strings.
     *
     *  @{ */
    Rose::BinaryAnalysis::AddressIntervalSet const& get_freeList() const;
    Rose::BinaryAnalysis::AddressIntervalSet& get_freeList();
    /** @} */
public:
    /** Property: Space that should never be freed. 
     * 
     * @{ */
    SgAsmStringStorage* const& get_dontFree() const;
    void set_dontFree(SgAsmStringStorage* const&);
    /** @} */

public:
    /** Property: Number of strings freed thus far. 
     * 
     * @{ */
    size_t const& get_numberFreed() const;
    void set_numberFreed(size_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructs table inside file section. */
    explicit SgAsmGenericStrtab(SgAsmGenericSection *container);

    /** Parse a string table. */
    virtual SgAsmGenericStrtab* parse() {return this;}

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Constructs an SgAsmStoredString from an offset into this string table. */
    SgAsmStoredString *createString(rose_addr_t offset, bool shared);

    /** Free area of this string table that corresponds to the string currently stored.
     *
     *  Use this in preference to the offset/size version of free() when possible. */
    void free(SgAsmStringStorage*);

    /** Add a range of bytes to the free list after subtracting areas that are referenced by other strings.
     *
     *  For instance, an ELF string table can have "main" and "domain" sharing storage. If we free the "domain" string then
     *  only "do" should be added to the free list. */
    void free(rose_addr_t offset, rose_addr_t size); /*mark part of table as free*/

    /** Free all strings so they will be reallocated later.
     *
     *  This is more efficient than calling @ref free for each storage object. If @p blow_away_holes is true then any areas
     *  that are unreferenced in the string table will be marked as referenced and added to the free list. */
    void freeAllStrings(bool blow_away_holes=false);

    virtual void allocateOverlap(SgAsmStringStorage*);

    /** Allocates storage for strings that have been modified but not allocated.
     *
     *  First try to fit unallocated strings into free space. Any that are left will cause the string table to be
     *  extended. Returns true if the reallocation would potentially affect some other section. If @p shrink is true then
     *  release address space that's no longer needed at the end of the table. */
    bool reallocate(bool shrink);

    //These should be pure virtual but ROSETTA apparently doesn't support that (RPM 2008-10-03)
    virtual SgAsmStringStorage *createStorage(rose_addr_t /*offset*/, bool /*shared*/);
    virtual rose_addr_t get_storageSize(const SgAsmStringStorage*);
    virtual void rebind(SgAsmStringStorage*, rose_addr_t);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    const referenced_t& get_storage_list() const ROSE_DEPRECATED("use get_storageList");
    void set_storage_list(const referenced_t&) ROSE_DEPRECATED("use set_storageList");
    const Rose::BinaryAnalysis::AddressIntervalSet& get_freelist() const ROSE_DEPRECATED("use get_freeList");
    Rose::BinaryAnalysis::AddressIntervalSet& get_freelist() ROSE_DEPRECATED("use set_freeList");
    SgAsmStringStorage* get_dont_free() const ROSE_DEPRECATED("use get_dontFree");
    void set_dont_free(SgAsmStringStorage*) ROSE_DEPRECATED("use set_dontFree");
    size_t get_num_freed() const ROSE_DEPRECATED("use get_numberFreed");
    void set_num_freed(size_t) ROSE_DEPRECATED("use set_numberFreed");
    SgAsmStoredString *create_string(rose_addr_t, bool) ROSE_DEPRECATED("use createString");
    void free_all_strings(bool=false) ROSE_DEPRECATED("use freeAllStrings");
    virtual void allocate_overlap(SgAsmStringStorage*) ROSE_DEPRECATED("use allocateOverlap");
    virtual SgAsmStringStorage *create_storage(rose_addr_t, bool) ROSE_DEPRECATED("use createStorage");
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) ROSE_DEPRECATED("use get_storageSize");
public:
    /** Destructor. */
    virtual ~SgAsmGenericStrtab();

protected:
    /** Default constructor. */
    SgAsmGenericStrtab();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericStrtab_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCliHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCliHeader);
IS_SERIALIZABLE(AsmCliHeader);

#ifndef DOCUMENTATION
AsmCliHeader.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCliHeader);
#if defined(SgAsmCliHeader_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmCliHeader_IMPL
#include <SgAsmCilMetadataRoot.h>
#endif
#endif // SgAsmCliHeader_HEADERS

#ifdef DOCUMENTATION
/** CIL Managed Code section.
 *
 *  "CLI" means "common language infrastructure; "CIL" is "common intermediate language". */
class SgAsmCliHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint32_t", "cb", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint16_t", "majorRuntimeVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint16_t", "minorRuntimeVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "metaData", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint32_t", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint32_t", "entryPointToken", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "resources", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "strongNameSignature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "codeManagerTable", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "vTableFixups", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "exportAddressTableJumps", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "uint64_t", "managedNativeHeader", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCliHeader.setDataPrototype(
        "SgAsmCilMetadataRoot*", "metadataRoot", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCliHeader);
#if defined(SgAsmCliHeader_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCliHeader -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCliHeader");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
        s & BOOST_SERIALIZATION_NVP(p_cb);
        s & BOOST_SERIALIZATION_NVP(p_majorRuntimeVersion);
        s & BOOST_SERIALIZATION_NVP(p_minorRuntimeVersion);
        s & BOOST_SERIALIZATION_NVP(p_metaData);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_entryPointToken);
        s & BOOST_SERIALIZATION_NVP(p_resources);
        s & BOOST_SERIALIZATION_NVP(p_strongNameSignature);
        s & BOOST_SERIALIZATION_NVP(p_codeManagerTable);
        s & BOOST_SERIALIZATION_NVP(p_vTableFixups);
        s & BOOST_SERIALIZATION_NVP(p_exportAddressTableJumps);
        s & BOOST_SERIALIZATION_NVP(p_managedNativeHeader);
        debugSerializationEnd("SgAsmCliHeader");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Cb
     *
     *  Size of the header in bytes 
     *  
     *  @{ */
    uint32_t const& get_cb() const;
    void set_cb(uint32_t const&);
    /** @} */

public:
    /** Property: MajorRuntimeVersion
     *
     *  The minimum version of the runtime required to run this program, currently 2. 
     *  
     *  @{ */
    uint16_t const& get_majorRuntimeVersion() const;
    void set_majorRuntimeVersion(uint16_t const&);
    /** @} */

public:
    /** Property: MinorRuntimeVersion
     *
     *  The minor portion of the version, currently 0. 
     *  
     *  @{ */
    uint16_t const& get_minorRuntimeVersion() const;
    void set_minorRuntimeVersion(uint16_t const&);
    /** @} */

public:
    /** Property: MetaData
     *
     *  RVA and size of implementation-specific resources (II.24). 
     *  
     *  @{ */
    uint64_t const& get_metaData() const;
    void set_metaData(uint64_t const&);
    /** @} */

public:
    /** Property: Flags
     *
     *  Flags describing this runtime image (II.25.3.3.1). 
     *  
     *  @{ */
    uint32_t const& get_flags() const;
    void set_flags(uint32_t const&);
    /** @} */

public:
    /** Property: EntryPointToken
     *
     *  Token for the MethodDef or File of the entry point for the image. 
     *  
     *  @{ */
    uint32_t const& get_entryPointToken() const;
    void set_entryPointToken(uint32_t const&);
    /** @} */

public:
    /** Property: Resources
     *
     *  RVA and size of implementation-specific resources. 
     *  
     *  @{ */
    uint64_t const& get_resources() const;
    void set_resources(uint64_t const&);
    /** @} */

public:
    /** Property: StrongNameSignature
     *
     *  RVA of the hash data for this PE file used by the CLI loader for binding and versioning. 
     *  
     *  @{ */
    uint64_t const& get_strongNameSignature() const;
    void set_strongNameSignature(uint64_t const&);
    /** @} */

public:
    /** Property: CodeManagerTable
     *
     *  Always 0 (II.24.1) 
     *  
     *  @{ */
    uint64_t const& get_codeManagerTable() const;
    void set_codeManagerTable(uint64_t const&);
    /** @} */

public:
    /** Property: VTableFixups
     *
     *  RVA of an array of locations in the file that contain an array of function pointers (e.g., vtable slots). 
     *  
     *  @{ */
    uint64_t const& get_vTableFixups() const;
    void set_vTableFixups(uint64_t const&);
    /** @} */

public:
    /** Property: ExportAddressTableJumps
     *
     *  Always 0 (II.24.1) 
     *  
     *  @{ */
    uint64_t const& get_exportAddressTableJumps() const;
    void set_exportAddressTableJumps(uint64_t const&);
    /** @} */

public:
    /** Property: ManagedNativeHeader
     *
     *  Always 0 (II.24.1) 
     *  
     *  @{ */
    uint64_t const& get_managedNativeHeader() const;
    void set_managedNativeHeader(uint64_t const&);
    /** @} */
    // FIXME[Robb Matzke 2023-03-20]: is the lack of serialization a bug?
public:
    /** Property: pointer to the root of the CIL Metadata. 
     * 
     * @{ */
    SgAsmCilMetadataRoot* const& get_metadataRoot() const;
    void set_metadataRoot(SgAsmCilMetadataRoot* const&);
    /** @} */
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmCliHeader(SgAsmPEFileHeader*);

    /** Initialize the object by parsing content from the PE file. */
    virtual SgAsmCliHeader* parse() override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmCliHeader();

public:
    /** Default constructor. */
    SgAsmCliHeader();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCliHeader_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmGenericSection = nonTerminalConstructor(
    "AsmGenericSection",
    *this,
    "AsmGenericSection",
    "AsmGenericSectionTag",
    SubclassListBuilder()
        | AsmCliHeader
        | AsmCoffSymbolTable
        | AsmDOSExtendedHeader
        | AsmElfSection
        | AsmElfSectionTable
        | AsmElfSegmentTable
        | AsmGenericHeader
        | AsmJvmAttributeTable
        | AsmJvmConstantPool
        | AsmJvmFieldTable
        | AsmJvmMethodTable
        | AsmLEEntryTable
        | AsmLENameTable
        | AsmLEPageTable
        | AsmLERelocTable
        | AsmLESection
        | AsmLESectionTable
        | AsmNEEntryTable
        | AsmNEModuleTable
        | AsmNENameTable
        | AsmNERelocTable
        | AsmNESection
        | AsmNESectionTable
        | AsmNEStringTable
        | AsmPESection
        | AsmPESectionTable
    , true);
assert(AsmGenericSection.associatedGrammar != nullptr);
AsmGenericSection.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericSection.isBoostSerializable(true);
AsmGenericSection.setAutomaticGenerationOfConstructor(false);
AsmGenericSection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmGenericSection.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmGenericSection);
#if defined(SgAsmGenericSection_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/AddressIntervalSet.h>
#include <Rose/BinaryAnalysis/MemoryMap.h>
#include <Rose/BinaryAnalysis/RelativeVirtualAddress.h>
#include <sageContainer.h>

#ifdef ROSE_SgAsmGenericSection_IMPL
#include <SgAsmBasicString.h>
#endif
#endif // SgAsmGenericSection_HEADERS

#ifdef DOCUMENTATION
/** Contiguous region of a file.
 *
 *  This class represents any contiguous region of a file that serves a particular purpose. Not only are ELF and PE Sections
 *  represented by @ref SgAsmGenericSection, but also such things as file headers, segment and section tables, etc. */
class SgAsmGenericSection: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericFile*", "file", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericHeader*", "header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "fileAlignment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "SgFileContentList", "data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericSection::SectionPurpose", "purpose", "= SgAsmGenericSection::SP_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "bool", "synthesized", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "int", "id", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "std::string", "shortName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mappedPreferredRva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mappedSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mappedAlignment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "bool", "mappedReadPermission", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "bool", "mappedWritePermission", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "bool", "mappedExecutePermission", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "bool", "containsCode", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mappedActualVa", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmGenericSection);
#if defined(SgAsmGenericSection_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericSection -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericSection");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        s & BOOST_SERIALIZATION_NVP(p_file);
        s & BOOST_SERIALIZATION_NVP(p_header);
        s & BOOST_SERIALIZATION_NVP(p_size);
        s & BOOST_SERIALIZATION_NVP(p_offset);
        s & BOOST_SERIALIZATION_NVP(p_fileAlignment);
        s & BOOST_SERIALIZATION_NVP(p_data);
        s & BOOST_SERIALIZATION_NVP(p_purpose);
        s & BOOST_SERIALIZATION_NVP(p_synthesized);
        s & BOOST_SERIALIZATION_NVP(p_id);
        s & BOOST_SERIALIZATION_NVP(p_name);
        s & BOOST_SERIALIZATION_NVP(p_shortName);
        s & BOOST_SERIALIZATION_NVP(p_mappedPreferredRva);
        s & BOOST_SERIALIZATION_NVP(p_mappedSize);
        s & BOOST_SERIALIZATION_NVP(p_mappedAlignment);
        s & BOOST_SERIALIZATION_NVP(p_mappedReadPermission);
        s & BOOST_SERIALIZATION_NVP(p_mappedWritePermission);
        s & BOOST_SERIALIZATION_NVP(p_mappedExecutePermission);
        s & BOOST_SERIALIZATION_NVP(p_containsCode);
        s & BOOST_SERIALIZATION_NVP(p_mappedActualVa);
        debugSerializationEnd("SgAsmGenericSection");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Reason for section's existence.
     *
     *  This is a union of all the section purposes from the various supported file formats.  However, at this time we're
     *  only interested in a few kinds of sections and therefore most will fall into the SP_OTHER category. */
    enum SectionPurpose {
        SP_UNSPECIFIED,                 /**< File format did not specify a reason and none could be determined. */
        SP_PROGRAM,                     /**< Program-supplied data, code, etc. */
        SP_HEADER,                      /**< Section contains a header for the executable file format. */
        SP_SYMTAB,                      /**< Symbol table. */
        SP_OTHER                        /**< File-specified purpose other than any given in this enum. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: File to which this section belongs. 
     * 
     * @{ */
    SgAsmGenericFile* const& get_file() const;
    void set_file(SgAsmGenericFile* const&);
    /** @} */

public:
    /** Property: File header that owns this section. 
     * 
     * @{ */
    SgAsmGenericHeader* const& get_header() const;
    void set_header(SgAsmGenericHeader* const&);
    /** @} */

public:
    /** Property: Size of section in file in bytes.
     *
     *  This is the current file size of the section in bytes as it exists in the file.. The original size of the
     *  section (available when @ref parse is called for the function, but possibly updated while parsing) is available
     *  through the size of the original @ref data property.
     *
     *  When ths size is set, some types of sections may do additional work. That additional work must not adjust the size
     *  of other sections or the mapping of any section (use @ref SgAsmGenericFile::shiftExtend to do that).
     *
     *  @{ */
    rose_addr_t get_size() const;
    virtual void set_size(rose_addr_t);
    /** @} */
public:
    /** Property: Offset to start of section in file.
     *
     *  This property holds the current file offset in bytes of this section. When setting the property, some types of
     *  sections may need to do perform additional work. That additional work must not adjust the offset of other sections,
     *  or the mapping of any section.
     *
     *  @{ */
 // Starting file offset of the section

    rose_addr_t get_offset() const;
    virtual void set_offset(rose_addr_t);
    /** @} */
public:
    /** Property: Required file alignment.
     *
     *  Zero and one both imply byte alignment. 
     *  
     *  @{ */
    rose_addr_t const& get_fileAlignment() const;
    void set_fileAlignment(rose_addr_t const&);
    /** @} */

public:
    /** Property: Original content of just this section.
     *
     *  Points into file's content. 
     *  
     *  @{ */
    SgFileContentList const& get_data() const;
    void set_data(SgFileContentList const&);
    /** @} */

public:
    /** Property: General contents of the section. 
     * 
     * @{ */
    SgAsmGenericSection::SectionPurpose const& get_purpose() const;
    void set_purpose(SgAsmGenericSection::SectionPurpose const&);
    /** @} */

public:
    /** Property: Whether section really exists.
     *
     *  If true, then this section was created by the format reader and not actually present in the file. 
     *  
     *  @{ */
    bool const& get_synthesized() const;
    void set_synthesized(bool const&);
    /** @} */

public:
    /** Property: Non-unique section ID or negative.
     *
     *  ELF files have unique id numbers. 
     *  
     *  @{ */
    int const& get_id() const;
    void set_id(int const&);
    /** @} */

public:
    /** Property: Non-unique name of section.
     *
     *  The name may be the empty string. If you just want to change the name of a section use the existing name node and
     *  change its string value.  Assigning a new @ref SgAsmGenericString to the section also changes the parent of the
     *  specified string node.
     *
     *  @{ */
    SgAsmGenericString* const& get_name() const;
    void set_name(SgAsmGenericString *s);
    /** @} */
public:
    /** Property: Abbreviated name.
     *
     *  Some sections have long names like "Import Address Table" that are cumbersome when they appear in assembly
     *  listings.  Therefore, each section may also have a short name.  Reading this property returns the short name
     *  if it's non-empty, otherwise the full name.
     *
     *  @{ */
    void set_shortName(std::string const&);
    std::string get_shortName() const;
    /** @} */
public:
    /** Property: Relative virtual address where section prefers to be mapped.
     *
     *  This is the relative virtual address where the section @em prefers to be mapped. The RVA where the section will
     *  ultimately be mapped by the loader might be different due to file and/or memory alignment constraints and conflicts
     *  with other sections.
     *
     *  The virtual address is relative to the base address stored in the file header.
     *
     *  @{ */
    rose_addr_t const& get_mappedPreferredRva() const;
    virtual void set_mappedPreferredRva(rose_addr_t);
    /** @} */
public:
    /** Property: Mapped size.
     *
     *  Size of section in bytes when it's mapped into virtual memory.
     *
     *  @{ */
    rose_addr_t const& get_mappedSize() const;
    virtual void set_mappedSize(rose_addr_t);
    /** @} */
public:
    /** Property: Alignment in virtual memory. 
     * 
     * @{ */
    rose_addr_t const& get_mappedAlignment() const;
    void set_mappedAlignment(rose_addr_t const&);
    /** @} */

public:
    /** Property: Whether mapped with read permission. 
     * 
     * @{ */
    bool const& get_mappedReadPermission() const;
    void set_mappedReadPermission(bool const&);
    /** @} */

public:
    /** Property: Whether mapped with write permission. 
     * 
     * @{ */
    bool const& get_mappedWritePermission() const;
    void set_mappedWritePermission(bool const&);
    /** @} */

public:
    /** Property: Whether mapped with execute permission. 
     * 
     * @{ */
    bool const& get_mappedExecutePermission() const;
    void set_mappedExecutePermission(bool const&);
    /** @} */

public:
    /** Property: Whether a section is known to contain code.
     *
     *  If a section is known to contain code then this data member is set.  Part of the process of parsing a binary file
     *  is to look at the symbol tables and if any function symbol points into a section then the entire section is marked
     *  as containing code.  This is necessary because ELF Object Files (*.o files) contain one ELF Section per function,
     *  none of which have a memory mapping specification.  By marking those sections as containing code, the LoaderELFObj
     *  class, knows that the section should be mapped to virtual memory for disassembly. 
     *  
     *  @{ */
    bool const& get_containsCode() const;
    void set_containsCode(bool const&);
    /** @} */

public:
    /** Property: Virtual address where ROSE maps this section.
     *
     *  The actual mapping is sometimes different than the preferred mapping indicated in the section table due to file and/or
     *  memory alignment constraints or conflicts with other sections.  The only place values are assigned to this data member is in
     *  the @ref Rose::BinaryAnalysis::BinaryLoader class and subclasses thereof.
     *
     *  The address corresponds to the latest call into the @ref Rose::BinaryAnalysis::BinaryLoader classes.  Depending on the
     *  loader employed, it's possible for a section to be mapped, this @c mapped_actual_va value to be set, and then some other
     *  section to be mapped over the top of all or part of the first section. In that case, the @c mapped_actual_va of the first
     *  section is not reset to zero.  The return value is not conditional upon @ref isMapped since that predicate applies only to
     *  preferred mapping attributes. 
     *  
     *  @{ */
    rose_addr_t const& get_mappedActualVa() const;
    void set_mappedActualVa(rose_addr_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
protected: // Allows local_data_pool to be initialized by subclasses. Note, destruction is problematic, freeing non-allocated ptr.
           // Set breakpoint in malloc_error_break to debug [Rasmussen, 2024.03.02]
    /* This is an optional local, writable pool for the p_data member. Normally a section will point into the pool
     * for its SgAsmGenericFile which is memory-mapped (read-only) from the actual file being parsed. The default
     * unparsing action is to write the original data back to the file. By allowing a section to allocate its own
     * pool for `data` we create a very easy way to get data into the unparsed file (the alternative is to derive
     * a new class and override the unparse() method). */
    unsigned char *local_data_pool;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into ASt.
     *
     *  Section constructors set the optional section header relationship--a bidirectional link between this new section
     *  and its optional, single header.  This new section points to its header and the header contains a list that points
     *  to this new section.  The section-to-header part of the link is deleted by the default destructor by virtue of
     *  being a simple pointer, but we also need to delete the other half of the link in the destructors. */
    SgAsmGenericSection(SgAsmGenericFile*, SgAsmGenericHeader*);

    /** Prints info about offsets into known sections. */
    static void dumpContainingSections(FILE*, const std::string &prefix, Rose::BinaryAnalysis::RelativeVirtualAddress,
                                       const SgAsmGenericSectionPtrList&);

    /** Saves a reference to the original file data for a section based on the section's current offset and size.
     *
     *  Once this happens, changing the offset or size of the file will not affect the original data. The original data can
     *  be extended, however, by calling @ref extend, which is typically done during parsing. */
    void grabContent();

    /** Parse contents of the section.
     *
     *  This is normally reimplemented in subclasses. */
    virtual SgAsmGenericSection* parse();

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Called prior to unparse to make things consistent. */
    virtual bool reallocate() { return false; }

    /** Write a section back to the file.
     *
     *  This is the generic version that simply writes the content. Subclasses should override this. */
    virtual void unparse(std::ostream&) const;

    /** Write just the specified regions back to the file */
    void unparse(std::ostream&, const ExtentMap&) const;

    /** Write holes (unreferenced areas) back to the file */
    void unparseHoles(std::ostream&) const;

    /** Predicate determining whether this section is also a top-level file header.
     *
     *  Returns true (the associated @ref SgAsmGenericHeader pointer) if this section is a top-level file header, false
     *  (NULL) otherwise. */
    SgAsmGenericHeader *isFileHeader();

    /** File offset for end of section. */
    rose_addr_t get_endOffset() const;

    /** Extend a section by some number of bytes during the construction and/or parsing phase.
     *
     *  This is function is considered to be part of the parsing and construction of a section--it changes the part of the file
     *  that's considered the "original size" of the section. To adjust the size of a section after the executable file is parsed,
     *  see @ref SgAsmGenericFile::shiftExtend.  Sections are allowed to extend beyond the end of the file and the original data
     *  (the @ref data property) is extended only up to the end of the file. */
    void extend(rose_addr_t nbytes);

    /** Write data to a file section.
     *
     *  Writes data to the specified file at the specified offset (first two arguments). The remaining arguments specify the
     *  data to be written.
     *
     *  Returns the section-relative byte offset for the first byte beyond what would have been written if all bytes of the buffer
     *  were written.
     *
     *  The buffer is allowed to extend past the end of the section as long as the part that extends beyond is all zeros. The zeros
     *  will not be written to the output file.  Furthermore, any trailing zeros that extend beyond the end of the file will not be
     *  written (end-of-file is determined by @ref SgAsmGenericFile::get_originalSize).
     *
     * @{ */
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, size_t bufsize, const void *buf) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const std::string &str) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, char c) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const SgFileContentList &buf) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const SgUnsignedCharList &buf) const;
    /** @} */

    /** Write an unsigned little-endian 128-bit value.
     *
     *  Encode an unsigned value as LEB128 and return the next offset. */
    rose_addr_t writeUleb128(unsigned char*, rose_addr_t offset, uint64_t) const;

    /** Write a signed little-endian 128-bit value.
     *
     *  Encode an signed value as LEB128 and return the next offset. */
    rose_addr_t writeSleb128(unsigned char*, rose_addr_t offset, int64_t) const;

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data beginning at byte @p start_offset from the beginning of the file, placing the
     *  results in @p dst_buf and returning the number of bytes read. The return value could be smaller than @p size if the
     *  end-of-file is reached. If the return value is smaller than @p size then one of two things happen: if @p strict is
     *  set (the default) then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise the @p dst_buf
     *  will be padded with zero bytes so that exactly @p size bytes of @p dst_buf are always initialized. */
    size_t readContent(rose_addr_t abs_offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data beginning at byte @p start (absolute or relative virtual address) in the mapped address
     *  space and placing the results in @p dst_buf and returning the number of bytes read. The return value could be smaller than
     *  @p size if the reading encounters virtual addresses that are not mapped.  When an unmapped virtual address is encountered
     *  the reading stops (even if subsequent virtual addresses are defined) and one of two things happen: if @p strict is set (the
     *  default) then an @ref Rose::BinaryAnalysis::MemoryMap::NotMapped exception is thrown, otherwise the @p dst_buf is padded
     *  with zeros so that all @p size bytes are initialized. The @p map is used to map virtual addresses to file offsets; if @p map
     *  is NULL then the map defined in the underlying file is used.
     *
     * @{ */
    size_t readContent(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t start,  void *dst_buf,
                       rose_addr_t size, bool strict=true);
    size_t readContent(const Rose::BinaryAnalysis::MemoryMap::Ptr&, const Rose::BinaryAnalysis::RelativeVirtualAddress &start,
                       void *dst_buf, rose_addr_t size, bool strict=true);
    /** @} */

    /** Reads data from a file.
     *
     *  This behaves the same as @ref readContent except the starting offset is relative to the beginning of this section.  Reading
     *  past the end of the section is not allowed and treated as a short read, and one of two things happen: if @p strict is set
     *  (the default) then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown, otherwise the result is zero padded so
     *  as to contain exactly @p size bytes. */
    size_t readContentLocal(rose_addr_t rel_offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads a string from the file.
     *
     *  The string begins at the specified virtual address and continues until the first NUL byte or until we reach an address that
     *  is not mapped. However, if @p strict is set (the default) and we reach an unmapped address then an @ref
     *  Rose::BinaryAnalysis::MemoryMap::NotMapped exception is thrown. The @p map defines the mapping from virtual addresses to
     *  file offsets; if @p map is NULL then the map defined in the underlying file is used. */
    std::string readContentString(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, bool strict=true);

    /** Reads a string from the file.
     *
     *  The string begins at the specified absolute or header-relative file offset and continues until the first NUL byte
     *  or end of file is reached. However, if @p strict is set (the default) and we reach the end-of-file then an @ref
     *  SgAsmExecutableFileFormat::ShortRead exception is thrown.
     *
     * @{ */
    std::string readContentString(rose_addr_t abs_offset, bool strict=true);
    std::string readContentString(const Rose::BinaryAnalysis::MemoryMap::Ptr &map, Rose::BinaryAnalysis::RelativeVirtualAddress rva,
                                  bool strict=true);
    /** @} */

    /** Reads a string from the file.
     *
     *  The string begins at the specified file offset relative to the start of this section and continues until the first
     *  NUL byte or the end of section is reached. However, if @p strict is set (the default) and we reach the
     *  end-of-section then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown. */
    std::string readContentLocalString(rose_addr_t rel_offset, bool strict=true);

    /** Reads content of a section and returns it as a container.
     *
     *  The returned container will always have exactly @p size byte.  If @p size bytes are not available in this section
     *  at the specified offset then the container will be zero padded. This method always behaves as a non-strict read. */
    SgUnsignedCharList readContentLocalUcl(rose_addr_t rel_offset, rose_addr_t size);

    /** Read a signed little-endian 128-bit value.
     *
     *  Extract a signed LEB128 value and adjust @p rel_offset according to how many bytes it occupied. If @p strict is set
     *  (the default) and the end of the section is reached then throw an @ref SgAsmExecutableFileFormat::ShortRead
     *  exception. Upon return, the @p rel_offset will be adjusted to point to the first byte after the LEB128 value. */
    int64_t readContentLocalSleb128(rose_addr_t *rel_offset, bool strict=true);

    /** Read an unsigned little-endian 128-bit value.
     *
     *  Extract an unsigned LEB128 value and adjust @p rel_offset according to how many bytes it occupied.  If @p strict is
     *  set (the default) and the end of the section is reached then throw an @ref SgAsmExecutableFileFormat::ShortRead
     *  exception. Upon return, the @p rel_offset will be adjusted to point to the first byte after the LEB128 value. */
    uint64_t readContentLocalUleb128(rose_addr_t *rel_offset, bool strict=true);

    /** Obtain a local, writable pool to hold content.
     *
     *  Sections typically point into the memory mapped, read-only file stored in the SgAsmGenericFile parent initialized by calling
     *  @ref grabContent (or indirectly by calling @ref parse).  This is also the same data which is, by default, written back out
     *  to the new file during @ref unparse.  Programs modify section content by either overriding the @ref unparse method or by
     *  modifying the @ref data property. But in order to modify @ref data we have to make sure that it's pointing to a read/write
     *  memory pool. This function replaces the read-only memory pool with a new one containing @p nbytes bytes of zeros. */
    unsigned char *writableContent(size_t nbytes);

    /** Returns a list of parts of a single section that have been referenced.
     *
     *  The offsets are relative to the start of the section. The tracking actually happens at the entire file level (see the @ref
     *  SgAsmGenericFile::referencedExtents property) and this function returns that same information but limits the results to this
     *  section, and returns section offsets rather than file offsets. */
    Rose::BinaryAnalysis::AddressIntervalSet get_referencedExtents() const;

    /** Returns a list of parts of a single section that have not been referenced.
     *
     *  The offsets are relative to the start of the section. The tracking actually happens at the entire file level (see @ref
     *  SgAsmGenericFile::get_unreferencedExtents) and this function returns that same information but limits the results to this
     *  section, and returns section offsets rather than file offsets. */
    Rose::BinaryAnalysis::AddressIntervalSet get_unreferencedExtents() const;

    /** Whether section desires to be mapped to memory.
     *
     *  This predicate is true iff this section has a non-zero mapped address and size. */
    bool isMapped() const;

    /** Causes section to not be mapped to memory.
     *
     *  This method sets the mapped address and size to zero. */
    void clearMapped();

    /** Base virtual address for a section.
     *
     *  Returns  zero if the section is not associated with a header.  This is just a convenience method to get the base
     *  virtual address of the file header that owns this section. */
    rose_addr_t get_baseVa() const;

    /** Virtual address where section prefers to be mapped.
     *
     *  Returns (non-relative) virtual address if mapped, zero otherwise. See also, the @ref mappedPreferredRva property. */
    rose_addr_t get_mappedPreferredVa() const;

    /** File offset for specified virtual address.
     *
     *  Returns the file offset associated with the virtual address of a mapped section. The @ref Rose::BinaryAnalysis::MemoryMap
     *  class is a better interface to this same information. */
    rose_addr_t get_vaOffset(rose_addr_t va) const;

    /** File offset for specified relative virtual address.
     *
     *  Returns the file offset associated with the relative virtual address of a mapped section.  The @ref
     *  Rose::BinaryAnalysis::MemoryMap class is a better interface to this same information. */
    rose_addr_t get_rvaOffset(rose_addr_t rva) const;

    /** Returns the file extent for the section.
     *
     *  The extent end points are determined by calling @ref get_offset and @ref get_size. */
    Extent get_fileExtent() const;

    /** Returns the memory extent for a mapped section.
     *
     *  If the section is not mapped then offset and size will be zero. The return value is computed from the @ref
     *  mappedPreferredRva and @ref mappedSize properties. */
    Extent get_mappedPreferredExtent() const;

    /** Increase file offset and mapping address to satisfy alignment constraints.
     *
     *  This is typically done when initializing a new section. The constructor places the new section at the end of the file before
     *  it knows what the alignment constraints will be. The user should then set the alignment constraints (see @ref fileAlignment
     *  and @ref mappedAlignment properties) and call this method.  This method must be called before any additional sections are
     *  appended to the file.
     *
     *  The file offset and memory mapping address are adjusted independently.
     *
     *  On the other hand, if additional sections are in the way, they must first be moved out of the way with the
     *  @ref SgAsmGenericFile::shiftExtend method.
     *
     *  Returns true if the file offset and/or mapping address changed as a result of this call. */
    bool align();

protected:
    virtual void destructorHelper() override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    rose_addr_t get_file_alignment() const ROSE_DEPRECATED("use get_fileAlignment");
    void set_file_alignment(rose_addr_t) ROSE_DEPRECATED("use set_fileAlignment");
    std::string get_short_name() const ROSE_DEPRECATED("use get_shortName");
    void set_short_name(const std::string&) ROSE_DEPRECATED("use set_shortName");
    rose_addr_t get_mapped_preferred_rva() const ROSE_DEPRECATED("use get_mappedPreferredRva");
    void set_mapped_preferred_rva(rose_addr_t) ROSE_DEPRECATED("use set_mappedPreferredRva");
    rose_addr_t get_mapped_size() const ROSE_DEPRECATED("use get_mappedSize");
    void set_mapped_size(rose_addr_t) ROSE_DEPRECATED("use set_mappedSize");
    rose_addr_t get_mapped_alignment() const ROSE_DEPRECATED("use get_mappedAlignment");
    void set_mapped_alignment(rose_addr_t) ROSE_DEPRECATED("use set_mappedAlignment");
    bool get_mapped_rperm() const ROSE_DEPRECATED("use get_mappedReadPermission");
    void set_mapped_rperm(bool) ROSE_DEPRECATED("use set_mappedReadPermission");
    bool get_mapped_wperm() const ROSE_DEPRECATED("use get_mappedWritePermission");
    void set_mapped_wperm(bool) ROSE_DEPRECATED("use set_mappedWritePermission");
    bool get_mapped_xperm() const ROSE_DEPRECATED("use get_mappedExecutePermission");
    void set_mapped_xperm(bool) ROSE_DEPRECATED("use set_mappedExecutePermission");
    bool get_contains_code() const ROSE_DEPRECATED("use get_containsCode");
    void set_contains_code(bool) ROSE_DEPRECATED("use set_containsCode");
    rose_addr_t get_mapped_actual_va() const ROSE_DEPRECATED("use get_mappedActualVa");
    void set_mapped_actual_va(rose_addr_t) ROSE_DEPRECATED("use set_mappedActualVa");
    static void dump_containing_sections(FILE*, const std::string&, Rose::BinaryAnalysis::RelativeVirtualAddress,
                                         const SgAsmGenericSectionPtrList&)
        ROSE_DEPRECATED("use dumpContainingSections");
    void grab_content() ROSE_DEPRECATED("use grabContent");
    void unparse_holes(std::ostream&) const ROSE_DEPRECATED("use unparseHoles");
    SgAsmGenericHeader *is_file_header() ROSE_DEPRECATED("use isFileHeader");
    rose_addr_t get_end_offset() const ROSE_DEPRECATED("use get_endOffset");
    rose_addr_t write_uleb128(unsigned char*, rose_addr_t, uint64_t) const ROSE_DEPRECATED("use writeUleb128");
    rose_addr_t write_sleb128(unsigned char*, rose_addr_t, int64_t) const ROSE_DEPRECATED("use writeSleb128");
    size_t read_content(rose_addr_t, void*, rose_addr_t, bool=true) ROSE_DEPRECATED("use readContent");
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t,  void*, rose_addr_t, bool=true)
        ROSE_DEPRECATED("use readContent");
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, const Rose::BinaryAnalysis::RelativeVirtualAddress&, void*,
                        rose_addr_t, bool=true)
        ROSE_DEPRECATED("use readContent");
    size_t read_content_local(rose_addr_t, void*, rose_addr_t, bool=true) ROSE_DEPRECATED("use readContentLocal");
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t, bool=true)
        ROSE_DEPRECATED("use readContentString");
    std::string read_content_str(rose_addr_t, bool=true) ROSE_DEPRECATED("use readContentString");
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr&, Rose::BinaryAnalysis::RelativeVirtualAddress,
                                 bool=true)
        ROSE_DEPRECATED("use readContentString");
    std::string read_content_local_str(rose_addr_t, bool=true) ROSE_DEPRECATED("use readContentLocalString");
    SgUnsignedCharList read_content_local_ucl(rose_addr_t, rose_addr_t) ROSE_DEPRECATED("use readContentLocalUcl");
    int64_t read_content_local_sleb128(rose_addr_t*, bool=true) ROSE_DEPRECATED("use readContentLocalSleb128");
    uint64_t read_content_local_uleb128(rose_addr_t*, bool=true) ROSE_DEPRECATED("use readContentLocalUleb128");
    unsigned char *writable_content(size_t) ROSE_DEPRECATED("use writableContent");
    Rose::BinaryAnalysis::AddressIntervalSet get_referenced_extents() const ROSE_DEPRECATED("use get_referencedExtents");
    Rose::BinaryAnalysis::AddressIntervalSet get_unreferenced_extents() const ROSE_DEPRECATED("use get_unreferencedExtents");
    bool is_mapped() const ROSE_DEPRECATED("use isMapped");
    void clear_mapped() ROSE_DEPRECATED("use clearMapped");
    rose_addr_t get_base_va() const ROSE_DEPRECATED("use get_baseVa");
    rose_addr_t get_mapped_preferred_va() const ROSE_DEPRECATED("use get_mappedPreferredVa");
    rose_addr_t get_va_offset(rose_addr_t) const ROSE_DEPRECATED("use get_vaOffset");
    rose_addr_t get_rva_offset(rose_addr_t) const ROSE_DEPRECATED("use get_rvaOffset");
    Extent get_file_extent() const ROSE_DEPRECATED("use get_fileExtent");
    Extent get_mapped_preferred_extent() const ROSE_DEPRECATED("use get_mappedPreferredExtent");
public:
    /** Destructor. */
    virtual ~SgAsmGenericSection();

public:
    /** Default constructor. */
    SgAsmGenericSection();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSection_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilUint8Heap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilUint8Heap);
IS_SERIALIZABLE(AsmCilUint8Heap);

#ifndef DOCUMENTATION
AsmCilUint8Heap.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for CIL branch of binary analysis IR nodes. */
class SgAsmCilUint8Heap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilUint8Heap.setDataPrototype(
        "std::vector<uint8_t>", "Stream", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilUint8Heap);
#if defined(SgAsmCilUint8Heap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilUint8Heap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilUint8Heap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
        s & BOOST_SERIALIZATION_NVP(p_Stream);
        debugSerializationEnd("SgAsmCilUint8Heap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<uint8_t> const& get_Stream() const;
    std::vector<uint8_t>& get_Stream();
public:
    void parse(const std::vector<uint8_t>& buf, size_t startOfMetaData) override;
    void unparse(std::vector<uint8_t>& buf, size_t startOfMetaData) const override;
    void dump(std::ostream& os) const override;
public:
    /** Destructor. */
    virtual ~SgAsmCilUint8Heap();

public:
    /** Default constructor. */
    SgAsmCilUint8Heap();

public:
    /** Constructor. */
    SgAsmCilUint8Heap(uint32_t const& Offset,
                      uint32_t const& Size,
                      std::string const& Name,
                      uint32_t const& NamePadding);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilUint8Heap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilUint32Heap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilUint32Heap);
IS_SERIALIZABLE(AsmCilUint32Heap);

#ifndef DOCUMENTATION
AsmCilUint32Heap.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for CIL branch of binary analysis IR nodes. */
class SgAsmCilUint32Heap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilUint32Heap.setDataPrototype(
        "std::vector<uint32_t>", "Stream", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilUint32Heap);
#if defined(SgAsmCilUint32Heap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilUint32Heap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilUint32Heap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
        s & BOOST_SERIALIZATION_NVP(p_Stream);
        debugSerializationEnd("SgAsmCilUint32Heap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<uint32_t> const& get_Stream() const;
    std::vector<uint32_t>& get_Stream();
public:
    void parse(const std::vector<uint8_t>& buf, size_t startOfMetaData) override;
    void unparse(std::vector<uint8_t>& buf, size_t startOfMetaData) const override;
    void dump(std::ostream& os) const override;
public:
    /** Destructor. */
    virtual ~SgAsmCilUint32Heap();

public:
    /** Default constructor. */
    SgAsmCilUint32Heap();

public:
    /** Constructor. */
    SgAsmCilUint32Heap(uint32_t const& Offset,
                       uint32_t const& Size,
                       std::string const& Name,
                       uint32_t const& NamePadding);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilUint32Heap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeSpecTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeSpecTable);
IS_SERIALIZABLE(AsmCilTypeSpecTable);

#ifndef DOCUMENTATION
AsmCilTypeSpecTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeSpec tables. */
class SgAsmCilTypeSpecTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeSpecTable.setDataPrototype(
        "std::vector<SgAsmCilTypeSpec*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeSpecTable);
#if defined(SgAsmCilTypeSpecTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeSpecTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeSpecTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilTypeSpecTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilTypeSpec*> const& get_elements() const;
    std::vector<SgAsmCilTypeSpec*>& get_elements();
public:
    using CilMetadataType = SgAsmCilTypeSpec;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeSpecTable();

public:
    /** Default constructor. */
    SgAsmCilTypeSpecTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeSpecTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeSpec           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeSpec);
IS_SERIALIZABLE(AsmCilTypeSpec);

#ifndef DOCUMENTATION
AsmCilTypeSpec.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeSpec node (II.22.39). */
class SgAsmCilTypeSpec: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeSpec.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeSpec);
#if defined(SgAsmCilTypeSpec_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeSpec -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeSpec");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        debugSerializationEnd("SgAsmCilTypeSpec");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Signature.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Signature_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeSpec();

public:
    /** Default constructor. */
    SgAsmCilTypeSpec();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeSpec_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeRefTable);
IS_SERIALIZABLE(AsmCilTypeRefTable);

#ifndef DOCUMENTATION
AsmCilTypeRefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeRef tables. */
class SgAsmCilTypeRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeRefTable.setDataPrototype(
        "std::vector<SgAsmCilTypeRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeRefTable);
#if defined(SgAsmCilTypeRefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeRefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeRefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilTypeRefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilTypeRef*> const& get_elements() const;
    std::vector<SgAsmCilTypeRef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilTypeRef;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeRefTable();

public:
    /** Default constructor. */
    SgAsmCilTypeRefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeRefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeRef);
IS_SERIALIZABLE(AsmCilTypeRef);

#ifndef DOCUMENTATION
AsmCilTypeRef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeRef node (II.22.38). */
class SgAsmCilTypeRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeRef.setDataPrototype(
        "uint16_t", "ResolutionScope", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeRef.setDataPrototype(
        "uint32_t", "TypeName", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeRef.setDataPrototype(
        "uint32_t", "TypeNamespace", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeRef);
#if defined(SgAsmCilTypeRef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeRef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeRef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_ResolutionScope);
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
        debugSerializationEnd("SgAsmCilTypeRef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: ResolutionScope.
     *
     *  An index into a Module, ModuleRef, AssemblyRef or TypeRef table, or null. 
     *  
     *  @{ */
    uint16_t const& get_ResolutionScope() const;
    void set_ResolutionScope(uint16_t const&);
    /** @} */

public:
    /** Property: TypeName.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeName() const;
    void set_TypeName(uint32_t const&);
    /** @} */

public:
    /** Property: TypeNamespace.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeNamespace() const;
    void set_TypeNamespace(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_ResolutionScope_object() const;
    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeRef();

public:
    /** Default constructor. */
    SgAsmCilTypeRef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeRef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeDefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeDefTable);
IS_SERIALIZABLE(AsmCilTypeDefTable);

#ifndef DOCUMENTATION
AsmCilTypeDefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeDef tables. */
class SgAsmCilTypeDefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDefTable.setDataPrototype(
        "std::vector<SgAsmCilTypeDef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeDefTable);
#if defined(SgAsmCilTypeDefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeDefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeDefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilTypeDefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilTypeDef*> const& get_elements() const;
    std::vector<SgAsmCilTypeDef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilTypeDef;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeDefTable();

public:
    /** Default constructor. */
    SgAsmCilTypeDefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeDefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeDef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilTypeDef);
IS_SERIALIZABLE(AsmCilTypeDef);

#ifndef DOCUMENTATION
AsmCilTypeDef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL TypeDef node (II.22.37). */
class SgAsmCilTypeDef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "TypeName", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "TypeNamespace", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "Extends", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "FieldList", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "MethodList", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilTypeDef);
#if defined(SgAsmCilTypeDef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilTypeDef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilTypeDef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
        s & BOOST_SERIALIZATION_NVP(p_Extends);
        s & BOOST_SERIALIZATION_NVP(p_FieldList);
        s & BOOST_SERIALIZATION_NVP(p_MethodList);
        debugSerializationEnd("SgAsmCilTypeDef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Flags.
     *
     *  A 4-byte bitmask of type TypeAttributes. 
     *  
     *  @{ */
    uint32_t const& get_Flags() const;
    void set_Flags(uint32_t const&);
    /** @} */

public:
    /** Property: TypeName.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeName() const;
    void set_TypeName(uint32_t const&);
    /** @} */

public:
    /** Property: TypeNamespace.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeNamespace() const;
    void set_TypeNamespace(uint32_t const&);
    /** @} */

public:
    /** Property: Extends.
     *
     *  An index into the TypeDef, TypeRef, or TypeSpec table. 
     *  
     *  @{ */
    uint32_t const& get_Extends() const;
    void set_Extends(uint32_t const&);
    /** @} */

public:
    /** Property: FieldList.
     *
     *  An index into the Field table. 
     *  
     *  @{ */
    uint32_t const& get_FieldList() const;
    void set_FieldList(uint32_t const&);
    /** @} */

public:
    /** Property: MethodList.
     *
     *  An index into the MethodDef table. 
     *  
     *  @{ */
    uint32_t const& get_MethodList() const;
    void set_MethodList(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
    const SgAsmCilMetadata* get_Extends_object() const;
    const SgAsmCilMetadata* get_FieldList_object() const;
    const SgAsmCilMetadata* get_MethodList_object() const;
    const SgAsmCilMetadata* get_MethodList_object(const SgAsmCilMethodDef*) const;
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeDef();

public:
    /** Default constructor. */
    SgAsmCilTypeDef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeDef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilStandAloneSigTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilStandAloneSigTable);
IS_SERIALIZABLE(AsmCilStandAloneSigTable);

#ifndef DOCUMENTATION
AsmCilStandAloneSigTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL StandAloneSig tables. */
class SgAsmCilStandAloneSigTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilStandAloneSigTable.setDataPrototype(
        "std::vector<SgAsmCilStandAloneSig*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilStandAloneSigTable);
#if defined(SgAsmCilStandAloneSigTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilStandAloneSigTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilStandAloneSigTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilStandAloneSigTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilStandAloneSig*> const& get_elements() const;
    std::vector<SgAsmCilStandAloneSig*>& get_elements();
public:
    using CilMetadataType = SgAsmCilStandAloneSig;
public:
    /** Destructor. */
    virtual ~SgAsmCilStandAloneSigTable();

public:
    /** Default constructor. */
    SgAsmCilStandAloneSigTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilStandAloneSigTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilStandAloneSig           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilStandAloneSig);
IS_SERIALIZABLE(AsmCilStandAloneSig);

#ifndef DOCUMENTATION
AsmCilStandAloneSig.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL StandAloneSig node (II.22.36). */
class SgAsmCilStandAloneSig: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilStandAloneSig.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilStandAloneSig);
#if defined(SgAsmCilStandAloneSig_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilStandAloneSig -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilStandAloneSig");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        debugSerializationEnd("SgAsmCilStandAloneSig");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Signature.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Signature_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilStandAloneSig();

public:
    /** Default constructor. */
    SgAsmCilStandAloneSig();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilStandAloneSig_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilPropertyTable);
IS_SERIALIZABLE(AsmCilPropertyTable);

#ifndef DOCUMENTATION
AsmCilPropertyTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Property tables. */
class SgAsmCilPropertyTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilPropertyTable.setDataPrototype(
        "std::vector<SgAsmCilProperty*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilPropertyTable);
#if defined(SgAsmCilPropertyTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilPropertyTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilPropertyTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilPropertyTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilProperty*> const& get_elements() const;
    std::vector<SgAsmCilProperty*>& get_elements();
public:
    using CilMetadataType = SgAsmCilProperty;
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyTable();

public:
    /** Default constructor. */
    SgAsmCilPropertyTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilPropertyMapTable);
IS_SERIALIZABLE(AsmCilPropertyMapTable);

#ifndef DOCUMENTATION
AsmCilPropertyMapTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL PropertyMap tables. */
class SgAsmCilPropertyMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilPropertyMapTable.setDataPrototype(
        "std::vector<SgAsmCilPropertyMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilPropertyMapTable);
#if defined(SgAsmCilPropertyMapTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilPropertyMapTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilPropertyMapTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilPropertyMapTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilPropertyMap*> const& get_elements() const;
    std::vector<SgAsmCilPropertyMap*>& get_elements();
public:
    using CilMetadataType = SgAsmCilPropertyMap;
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyMapTable();

public:
    /** Default constructor. */
    SgAsmCilPropertyMapTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyMapTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilPropertyMap);
IS_SERIALIZABLE(AsmCilPropertyMap);

#ifndef DOCUMENTATION
AsmCilPropertyMap.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL PropertyMap node (II.22.35). */
class SgAsmCilPropertyMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilPropertyMap.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilPropertyMap.setDataPrototype(
        "uint32_t", "PropertyList", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilPropertyMap);
#if defined(SgAsmCilPropertyMap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilPropertyMap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilPropertyMap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_PropertyList);
        debugSerializationEnd("SgAsmCilPropertyMap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Parent.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: PropertyList.
     *
     *  An index into the Property table. 
     *  
     *  @{ */
    uint32_t const& get_PropertyList() const;
    void set_PropertyList(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_PropertyList_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyMap();

public:
    /** Default constructor. */
    SgAsmCilPropertyMap();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyMap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilProperty           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilProperty);
IS_SERIALIZABLE(AsmCilProperty);

#ifndef DOCUMENTATION
AsmCilProperty.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Property node (II.22.34). */
class SgAsmCilProperty: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilProperty.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilProperty.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilProperty.setDataPrototype(
        "uint32_t", "Type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilProperty);
#if defined(SgAsmCilProperty_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilProperty -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilProperty");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Type);
        debugSerializationEnd("SgAsmCilProperty");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Flags.
     *
     *  A 2-byte bitmask of type PropertyAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Type.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Type() const;
    void set_Type(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Type_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilProperty();

public:
    /** Default constructor. */
    SgAsmCilProperty();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilProperty_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilParamTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilParamTable);
IS_SERIALIZABLE(AsmCilParamTable);

#ifndef DOCUMENTATION
AsmCilParamTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Param tables. */
class SgAsmCilParamTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilParamTable.setDataPrototype(
        "std::vector<SgAsmCilParam*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilParamTable);
#if defined(SgAsmCilParamTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilParamTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilParamTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilParamTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilParam*> const& get_elements() const;
    std::vector<SgAsmCilParam*>& get_elements();
public:
    using CilMetadataType = SgAsmCilParam;
public:
    /** Destructor. */
    virtual ~SgAsmCilParamTable();

public:
    /** Default constructor. */
    SgAsmCilParamTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilParamTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilParam           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilParam);
IS_SERIALIZABLE(AsmCilParam);

#ifndef DOCUMENTATION
AsmCilParam.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Param node (II.22.33). */
class SgAsmCilParam: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilParam.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilParam.setDataPrototype(
        "uint16_t", "Sequence", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilParam.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilParam);
#if defined(SgAsmCilParam_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilParam -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilParam");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Sequence);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        debugSerializationEnd("SgAsmCilParam");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Flags.
     *
     *  A 2-byte bitmask of type ParamAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Sequence.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_Sequence() const;
    void set_Sequence(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilParam();

public:
    /** Default constructor. */
    SgAsmCilParam();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilParam_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNestedClassTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilNestedClassTable);
IS_SERIALIZABLE(AsmCilNestedClassTable);

#ifndef DOCUMENTATION
AsmCilNestedClassTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL NestedClass tables. */
class SgAsmCilNestedClassTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilNestedClassTable.setDataPrototype(
        "std::vector<SgAsmCilNestedClass*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilNestedClassTable);
#if defined(SgAsmCilNestedClassTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilNestedClassTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilNestedClassTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilNestedClassTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilNestedClass*> const& get_elements() const;
    std::vector<SgAsmCilNestedClass*>& get_elements();
public:
    using CilMetadataType = SgAsmCilNestedClass;
public:
    /** Destructor. */
    virtual ~SgAsmCilNestedClassTable();

public:
    /** Default constructor. */
    SgAsmCilNestedClassTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNestedClassTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNestedClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilNestedClass);
IS_SERIALIZABLE(AsmCilNestedClass);

#ifndef DOCUMENTATION
AsmCilNestedClass.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL NestedClass node (II.22.32). */
class SgAsmCilNestedClass: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilNestedClass.setDataPrototype(
        "uint32_t", "NestedClass", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilNestedClass.setDataPrototype(
        "uint32_t", "EnclosingClass", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilNestedClass);
#if defined(SgAsmCilNestedClass_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilNestedClass -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilNestedClass");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_NestedClass);
        s & BOOST_SERIALIZATION_NVP(p_EnclosingClass);
        debugSerializationEnd("SgAsmCilNestedClass");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: NestedClass.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_NestedClass() const;
    void set_NestedClass(uint32_t const&);
    /** @} */

public:
    /** Property: EnclosingClass.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_EnclosingClass() const;
    void set_EnclosingClass(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_NestedClass_object() const;
    const SgAsmCilMetadata* get_EnclosingClass_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilNestedClass();

public:
    /** Default constructor. */
    SgAsmCilNestedClass();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNestedClass_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilModuleTable);
IS_SERIALIZABLE(AsmCilModuleTable);

#ifndef DOCUMENTATION
AsmCilModuleTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Module tables. */
class SgAsmCilModuleTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModuleTable.setDataPrototype(
        "std::vector<SgAsmCilModule*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilModuleTable);
#if defined(SgAsmCilModuleTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilModuleTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilModuleTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilModuleTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilModule*> const& get_elements() const;
    std::vector<SgAsmCilModule*>& get_elements();
public:
    using CilMetadataType = SgAsmCilModule;
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleTable();

public:
    /** Default constructor. */
    SgAsmCilModuleTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilModuleRefTable);
IS_SERIALIZABLE(AsmCilModuleRefTable);

#ifndef DOCUMENTATION
AsmCilModuleRefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ModuleRef tables. */
class SgAsmCilModuleRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModuleRefTable.setDataPrototype(
        "std::vector<SgAsmCilModuleRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilModuleRefTable);
#if defined(SgAsmCilModuleRefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilModuleRefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilModuleRefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilModuleRefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilModuleRef*> const& get_elements() const;
    std::vector<SgAsmCilModuleRef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilModuleRef;
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleRefTable();

public:
    /** Default constructor. */
    SgAsmCilModuleRefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleRefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilModuleRef);
IS_SERIALIZABLE(AsmCilModuleRef);

#ifndef DOCUMENTATION
AsmCilModuleRef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ModuleRef node (II.22.31). */
class SgAsmCilModuleRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModuleRef.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilModuleRef);
#if defined(SgAsmCilModuleRef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilModuleRef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilModuleRef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        debugSerializationEnd("SgAsmCilModuleRef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleRef();

public:
    /** Default constructor. */
    SgAsmCilModuleRef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleRef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilModule);
IS_SERIALIZABLE(AsmCilModule);

#ifndef DOCUMENTATION
AsmCilModule.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Module node (II.22.30). */
class SgAsmCilModule: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModule.setDataPrototype(
        "uint16_t", "Generation", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModule.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModule.setDataPrototype(
        "uint32_t", "Mvid", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModule.setDataPrototype(
        "uint32_t", "Encld", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilModule.setDataPrototype(
        "uint32_t", "EncBaseId", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilModule);
#if defined(SgAsmCilModule_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilModule -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilModule");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Generation);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Mvid);
        s & BOOST_SERIALIZATION_NVP(p_Encld);
        s & BOOST_SERIALIZATION_NVP(p_EncBaseId);
        debugSerializationEnd("SgAsmCilModule");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Generation.
     *
     *  A 2-byte value, reserved, shall be zero. 
     *  
     *  @{ */
    uint16_t const& get_Generation() const;
    void set_Generation(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Mvid.
     *
     *  An index into the Guid heap. 
     *  
     *  @{ */
    uint32_t const& get_Mvid() const;
    void set_Mvid(uint32_t const&);
    /** @} */

public:
    /** Property: Encld.
     *
     *  An index into the Guid heap. 
     *  
     *  @{ */
    uint32_t const& get_Encld() const;
    void set_Encld(uint32_t const&);
    /** @} */

public:
    /** Property: EncBaseId.
     *
     *  An index into the Guid heap. 
     *  
     *  @{ */
    uint32_t const& get_EncBaseId() const;
    void set_EncBaseId(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const std::uint32_t* get_Mvid_guid() const;
    const std::uint32_t* get_Encld_guid() const;
    const std::uint32_t* get_EncBaseId_guid() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilModule();

public:
    /** Default constructor. */
    SgAsmCilModule();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModule_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSpecTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodSpecTable);
IS_SERIALIZABLE(AsmCilMethodSpecTable);

#ifndef DOCUMENTATION
AsmCilMethodSpecTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodSpec tables. */
class SgAsmCilMethodSpecTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSpecTable.setDataPrototype(
        "std::vector<SgAsmCilMethodSpec*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodSpecTable);
#if defined(SgAsmCilMethodSpecTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodSpecTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodSpecTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilMethodSpecTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilMethodSpec*> const& get_elements() const;
    std::vector<SgAsmCilMethodSpec*>& get_elements();
public:
    using CilMetadataType = SgAsmCilMethodSpec;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSpecTable();

public:
    /** Default constructor. */
    SgAsmCilMethodSpecTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSpecTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSpec           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodSpec);
IS_SERIALIZABLE(AsmCilMethodSpec);

#ifndef DOCUMENTATION
AsmCilMethodSpec.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodSpec node (II.22.29). */
class SgAsmCilMethodSpec: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSpec.setDataPrototype(
        "uint32_t", "Method", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSpec.setDataPrototype(
        "uint32_t", "Instantiation", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodSpec);
#if defined(SgAsmCilMethodSpec_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodSpec -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodSpec");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Method);
        s & BOOST_SERIALIZATION_NVP(p_Instantiation);
        debugSerializationEnd("SgAsmCilMethodSpec");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Method.
     *
     *  An index into the MethodDef or MemberRef table. 
     *  
     *  @{ */
    uint32_t const& get_Method() const;
    void set_Method(uint32_t const&);
    /** @} */

public:
    /** Property: Instantiation.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Instantiation() const;
    void set_Instantiation(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Method_object() const;
    const std::uint8_t* get_Instantiation_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSpec();

public:
    /** Default constructor. */
    SgAsmCilMethodSpec();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSpec_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSemanticsTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodSemanticsTable);
IS_SERIALIZABLE(AsmCilMethodSemanticsTable);

#ifndef DOCUMENTATION
AsmCilMethodSemanticsTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodSemantics tables. */
class SgAsmCilMethodSemanticsTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSemanticsTable.setDataPrototype(
        "std::vector<SgAsmCilMethodSemantics*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodSemanticsTable);
#if defined(SgAsmCilMethodSemanticsTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodSemanticsTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodSemanticsTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilMethodSemanticsTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilMethodSemantics*> const& get_elements() const;
    std::vector<SgAsmCilMethodSemantics*>& get_elements();
public:
    using CilMetadataType = SgAsmCilMethodSemantics;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSemanticsTable();

public:
    /** Default constructor. */
    SgAsmCilMethodSemanticsTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSemanticsTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSemantics           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodSemantics);
IS_SERIALIZABLE(AsmCilMethodSemantics);

#ifndef DOCUMENTATION
AsmCilMethodSemantics.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodSemantics node (II.22.28). */
class SgAsmCilMethodSemantics: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSemantics.setDataPrototype(
        "uint16_t", "Semantics", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSemantics.setDataPrototype(
        "uint32_t", "Method", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodSemantics.setDataPrototype(
        "uint32_t", "Association", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodSemantics);
#if defined(SgAsmCilMethodSemantics_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodSemantics -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodSemantics");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Semantics);
        s & BOOST_SERIALIZATION_NVP(p_Method);
        s & BOOST_SERIALIZATION_NVP(p_Association);
        debugSerializationEnd("SgAsmCilMethodSemantics");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Semantics.
     *
     *  A 2-byte bitmask of type MethodSemanticsAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Semantics() const;
    void set_Semantics(uint16_t const&);
    /** @} */

public:
    /** Property: Method.
     *
     *  An index into the MethodDef table. 
     *  
     *  @{ */
    uint32_t const& get_Method() const;
    void set_Method(uint32_t const&);
    /** @} */

public:
    /** Property: Association.
     *
     *  An index into the Event or Property table. 
     *  
     *  @{ */
    uint32_t const& get_Association() const;
    void set_Association(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Method_object() const;
    const SgAsmCilMetadata* get_Association_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSemantics();

public:
    /** Default constructor. */
    SgAsmCilMethodSemantics();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSemantics_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodImplTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodImplTable);
IS_SERIALIZABLE(AsmCilMethodImplTable);

#ifndef DOCUMENTATION
AsmCilMethodImplTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodImpl tables. */
class SgAsmCilMethodImplTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodImplTable.setDataPrototype(
        "std::vector<SgAsmCilMethodImpl*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodImplTable);
#if defined(SgAsmCilMethodImplTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodImplTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodImplTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilMethodImplTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilMethodImpl*> const& get_elements() const;
    std::vector<SgAsmCilMethodImpl*>& get_elements();
public:
    using CilMetadataType = SgAsmCilMethodImpl;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodImplTable();

public:
    /** Default constructor. */
    SgAsmCilMethodImplTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodImplTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodImpl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodImpl);
IS_SERIALIZABLE(AsmCilMethodImpl);

#ifndef DOCUMENTATION
AsmCilMethodImpl.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodImpl node (II.22.27). */
class SgAsmCilMethodImpl: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "Class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "MethodBody", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "MethodDeclaration", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodImpl);
#if defined(SgAsmCilMethodImpl_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodImpl -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodImpl");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Class);
        s & BOOST_SERIALIZATION_NVP(p_MethodBody);
        s & BOOST_SERIALIZATION_NVP(p_MethodDeclaration);
        debugSerializationEnd("SgAsmCilMethodImpl");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Class.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_Class() const;
    void set_Class(uint32_t const&);
    /** @} */

public:
    /** Property: MethodBody.
     *
     *  An index into the MethodDef or MemberRef table. 
     *  
     *  @{ */
    uint32_t const& get_MethodBody() const;
    void set_MethodBody(uint32_t const&);
    /** @} */

public:
    /** Property: MethodDeclaration.
     *
     *  An index into the MethodDef or MemberRef table. 
     *  
     *  @{ */
    uint32_t const& get_MethodDeclaration() const;
    void set_MethodDeclaration(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Class_object() const;
    const SgAsmCilMetadata* get_MethodBody_object() const;
    const SgAsmCilMetadata* get_MethodDeclaration_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodImpl();

public:
    /** Default constructor. */
    SgAsmCilMethodImpl();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodImpl_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodDefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodDefTable);
IS_SERIALIZABLE(AsmCilMethodDefTable);

#ifndef DOCUMENTATION
AsmCilMethodDefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodDef tables. */
class SgAsmCilMethodDefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDefTable.setDataPrototype(
        "std::vector<SgAsmCilMethodDef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodDefTable);
#if defined(SgAsmCilMethodDefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodDefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodDefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilMethodDefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilMethodDef*> const& get_elements() const;
    std::vector<SgAsmCilMethodDef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilMethodDef;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodDefTable();

public:
    /** Default constructor. */
    SgAsmCilMethodDefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodDefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodDef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodDef);
IS_SERIALIZABLE(AsmCilMethodDef);

#ifndef DOCUMENTATION
AsmCilMethodDef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MethodDef node (II.22.26). */
class SgAsmCilMethodDef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "RVA", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "ImplFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "ParamList", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "SgAsmBlock*", "body", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "bool", "initLocals", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "stackSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "bool", "hasMoreSections", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "localVarSigTok", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodDef.setDataPrototype(
        "std::vector<SgAsmCilMethodData*>", "methodData", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodDef);
#if defined(SgAsmCilMethodDef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodDef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodDef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_RVA);
        s & BOOST_SERIALIZATION_NVP(p_ImplFlags);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        s & BOOST_SERIALIZATION_NVP(p_ParamList);
        s & BOOST_SERIALIZATION_NVP(p_body);
        s & BOOST_SERIALIZATION_NVP(p_initLocals);
        s & BOOST_SERIALIZATION_NVP(p_stackSize);
        s & BOOST_SERIALIZATION_NVP(p_hasMoreSections);
        s & BOOST_SERIALIZATION_NVP(p_localVarSigTok);
        s & BOOST_SERIALIZATION_NVP(p_methodData);
        debugSerializationEnd("SgAsmCilMethodDef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: RVA.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_RVA() const;
    void set_RVA(uint32_t const&);
    /** @} */

public:
    /** Property: ImplFlags.
     *
     *  A 2-byte bitmask of type MethodImplAttributes. 
     *  
     *  @{ */
    uint32_t const& get_ImplFlags() const;
    void set_ImplFlags(uint32_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  A 2-byte bitmask of type MethodAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Signature.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */

public:
    /** Property: ParamList.
     *
     *  An index into the Param table. 
     *  
     *  @{ */
    uint32_t const& get_ParamList() const;
    void set_ParamList(uint32_t const&);
    /** @} */

public:
    /** Property: body.
     *
     *  A block containing an instruction sequence (either x86 or CIL). 
     *  
     *  @{ */
    SgAsmBlock* const& get_body() const;
    void set_body(SgAsmBlock* const&);
    /** @} */

public:
    /** Property: initLocals.
     *
     *  Returns true if locals are initialized. 
     *  
     *  @{ */
    bool const& get_initLocals() const;
    void set_initLocals(bool const&);
    /** @} */

public:
    /** Property: stackSize.
     *
     *  Returns the max stack size required for this method. 
     *  
     *  @{ */
    uint32_t const& get_stackSize() const;
    void set_stackSize(uint32_t const&);
    /** @} */

public:
    /** Property: hasMoreSections.
     *
     *  Returns true if this method has more sections in addition to the body. 
     *  
     *  @{ */
    bool const& get_hasMoreSections() const;
    void set_hasMoreSections(bool const&);
    /** @} */
    //
    // additional fields
public:
    /** Property: localVarSigTok (II.24.4.3).
     *
     *  localVarSigTok is extracted from fat method headers; 0 when a
     *  tiny header is used. 
     *  
     *  @{ */
    uint32_t const& get_localVarSigTok() const;
    void set_localVarSigTok(uint32_t const&);
    /** @} */

public:
    /** Property: methodData (II.24.4.5).
     *
     *  Collection of data sections (see hasMoreSections) 
     *  
     *  @{ */
    std::vector<SgAsmCilMethodData*> const& get_methodData() const;
    std::vector<SgAsmCilMethodData*>& get_methodData();
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
    const SgAsmCilMetadata* get_ParamList_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodDef();

public:
    /** Default constructor. */
    SgAsmCilMethodDef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodDef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodData           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMethodData);
IS_SERIALIZABLE(AsmCilMethodData);

#ifndef DOCUMENTATION
AsmCilMethodData.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCilMethodData);
#if defined(SgAsmCilMethodData_HEADERS) || defined(DOCUMENTATION)
#include <vector>
#endif // SgAsmCilMethodData_HEADERS

#ifdef DOCUMENTATION
/** Property class representing CIL Extra Sections (II.25.4.5). 
 *  
 * \note parsing/unparsing is handled by the using class (i.e., SgAsmCilMethoDef)
 */
class SgAsmCilMethodData: public SgAsmCilNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodData.setDataPrototype(
        "uint64_t", "kind", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodData.setDataPrototype(
        "std::uint32_t", "dataSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMethodData.setDataPrototype(
        "std::vector<SgAsmCilExceptionData*>", "clauses", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMethodData);
#if defined(SgAsmCilMethodData_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMethodData -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMethodData");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        s & BOOST_SERIALIZATION_NVP(p_dataSize);
        s & BOOST_SERIALIZATION_NVP(p_clauses);
        debugSerializationEnd("SgAsmCilMethodData");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
  enum
  {
    CorILMethod_Sect_EHTable    = 0x01,
    CorILMethod_Sect_OptILTable = 0x02,
    CorILMethod_Sect_FatFormat  = 0x40,
    CorILMethod_Sect_MoreSects  = 0x80,
  };

private:
public:
    uint64_t const& get_kind() const;
    void set_kind(uint64_t const&);

public:
    std::uint32_t const& get_dataSize() const;
    void set_dataSize(std::uint32_t const&);

public:
    std::vector<SgAsmCilExceptionData*> const& get_Clauses() const;
    std::vector<SgAsmCilExceptionData*>& get_Clauses();
public:
  bool isEHTable() const
  {
    return (p_kind & CorILMethod_Sect_EHTable) == CorILMethod_Sect_EHTable;
  }

  bool isOptILTable() const
  {
    const bool res = (p_kind & CorILMethod_Sect_OptILTable) == CorILMethod_Sect_OptILTable;

    ASSERT_require(!res);
    return res;
  }

  bool usesFatFormat() const
  {
    return (p_kind & CorILMethod_Sect_FatFormat) == CorILMethod_Sect_FatFormat;
  }

  bool hasMoreSections() const
  {
    return (p_kind & CorILMethod_Sect_MoreSects) == CorILMethod_Sect_MoreSects;
  }
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodData();

public:
    /** Default constructor. */
    SgAsmCilMethodData();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodData_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadataRoot           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMetadataRoot);
IS_SERIALIZABLE(AsmCilMetadataRoot);

#ifndef DOCUMENTATION
AsmCilMetadataRoot.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL SgAsmCilMetadataRoot. */
class SgAsmCilMetadataRoot: public SgAsmCilNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "MajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "MinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Reserved0", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "std::string", "Version", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "VersionPadding", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "NumberOfStreams", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataRoot.setDataPrototype(
        "std::vector<SgAsmCilDataStream*>", "Streams", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMetadataRoot);
#if defined(SgAsmCilMetadataRoot_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMetadataRoot -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMetadataRoot");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
        s & BOOST_SERIALIZATION_NVP(p_Reserved0);
        s & BOOST_SERIALIZATION_NVP(p_Length);
        s & BOOST_SERIALIZATION_NVP(p_Version);
        s & BOOST_SERIALIZATION_NVP(p_VersionPadding);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_NumberOfStreams);
        s & BOOST_SERIALIZATION_NVP(p_Streams);
        debugSerializationEnd("SgAsmCilMetadataRoot");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Magic signature for physical metadata (always 0x424A5342) 
     * 
     * @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */

public:
    /** Property: Major version number. 
     * 
     * @{ */
    uint16_t const& get_MajorVersion() const;
    void set_MajorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: Minor version number. 
     * 
     * @{ */
    uint16_t const& get_MinorVersion() const;
    void set_MinorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: Reserved space. 
     * 
     * @{ */
    uint32_t const& get_Reserved0() const;
    void set_Reserved0(uint32_t const&);
    /** @} */

public:
    /** Property: Number of bytes allocated to hold version string (including null terminator). 
     * 
     * @{ */
    uint32_t const& get_Length() const;
    void set_Length(uint32_t const&);
    /** @} */

public:
    /** Property: Version string. 
     * 
     * @{ */
    std::string const& get_Version() const;
    void set_Version(std::string const&);
    /** @} */

public:
    /** Property: Padding to next 4-byte boundary. 
     * 
     * @{ */
    uint32_t const& get_VersionPadding() const;
    void set_VersionPadding(uint32_t const&);
    /** @} */

public:
    /** Property: Reserved space. 
     * 
     * @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Reserved space. 
     * 
     * @{ */
    uint16_t const& get_NumberOfStreams() const;
    void set_NumberOfStreams(uint16_t const&);
    /** @} */
    // FIXME[Robb Matzke 2023-03-22]: these were implemented elsewhere, but could be auto generated
public:
    /** Property: Metadata streams. 
     * 
     * @{ */
    std::vector<SgAsmCilDataStream*> const& get_Streams() const;
    std::vector<SgAsmCilDataStream*>& get_Streams();
    /** @} */
    //const std::vector<SgAsmCilDataStream*>& get_Streams() const;
    //std::vector<SgAsmCilDataStream*>& get_Streams();
private:
    /** indices to efficienty access the different heaps
     * @{ */
    mutable int8_t idxStringHeap = -1;
    mutable int8_t idxBlobHeap = -1;
    mutable int8_t idxUsHeap = -1;
    mutable int8_t idxGuidHeap = -1;
    mutable int8_t idxMetadataHeap = -1;
    /** }@ */

public:
    /** 4-byte indicating the start of the metadata root in the .text section.
     */
    static constexpr uint32_t MAGIC_SIGNATURE = 0x424A5342;

    /** Declares the parse function as called from the Cli section header object.
     *  @pre isSgAsmCliHeader(this->get_parent()) != nullptr
     */
    void parse();

    /** Declares the parse function.
     *  @param buf the binary buffer.
     *  @param index the start location of the metadata root object.
     *         buf[index] is the location of the magic number.
     */
    void parse(const std::vector<uint8_t>& buf, size_t index);

    /** Declares the unparse function as called from the Cli section header object. */
    void unparse(std::ostream& f) const;

    /** Unparses the metadata objects into a buffer starting at index @p idx. */
    void unparse(std::vector<uint8_t>&, std::size_t) const;

    /** Prints the object's data in a human readable form to @p os. */
    void dump(std::ostream& os) const;

    /** Accessor function to return a specific heap.
     *
     * @{ */
    SgAsmCilUint8Heap*    get_StringHeap() const;
    SgAsmCilUint8Heap*    get_BlobHeap() const;
    SgAsmCilUint8Heap*    get_UsHeap() const;
    SgAsmCilUint32Heap*   get_GuidHeap() const;
    SgAsmCilMetadataHeap* get_MetadataHeap() const;
    /** }@ */
public:
    /** Destructor. */
    virtual ~SgAsmCilMetadataRoot();

public:
    /** Default constructor. */
    SgAsmCilMetadataRoot();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadataRoot_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadataHeap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMetadataHeap);
IS_SERIALIZABLE(AsmCilMetadataHeap);

#ifndef DOCUMENTATION
AsmCilMetadataHeap.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCilMetadataHeap);
#if defined(SgAsmCilMetadataHeap_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_SgAsmCilMetadataHeap_IMPL
#include <SgAsmCilAssemblyTable.h>
#include <SgAsmCilAssemblyOSTable.h>
#include <SgAsmCilAssemblyProcessorTable.h>
#include <SgAsmCilAssemblyRefTable.h>
#include <SgAsmCilAssemblyRefOSTable.h>
#include <SgAsmCilAssemblyRefProcessorTable.h>
#include <SgAsmCilClassLayoutTable.h>
#include <SgAsmCilConstantTable.h>
#include <SgAsmCilCustomAttributeTable.h>
#include <SgAsmCilDeclSecurityTable.h>
#include <SgAsmCilEventTable.h>
#include <SgAsmCilEventMapTable.h>
#include <SgAsmCilExportedTypeTable.h>
#include <SgAsmCilFieldTable.h>
#include <SgAsmCilFieldLayoutTable.h>
#include <SgAsmCilFieldMarshalTable.h>
#include <SgAsmCilFieldRVATable.h>
#include <SgAsmCilFileTable.h>
#include <SgAsmCilGenericParamTable.h>
#include <SgAsmCilGenericParamConstraintTable.h>
#include <SgAsmCilImplMapTable.h>
#include <SgAsmCilInterfaceImplTable.h>
#include <SgAsmCilManifestResourceTable.h>
#include <SgAsmCilMemberRefTable.h>
#include <SgAsmCilMethodDefTable.h>
#include <SgAsmCilMethodImplTable.h>
#include <SgAsmCilMethodSemanticsTable.h>
#include <SgAsmCilMethodSpecTable.h>
#include <SgAsmCilModuleTable.h>
#include <SgAsmCilModuleRefTable.h>
#include <SgAsmCilNestedClassTable.h>
#include <SgAsmCilParamTable.h>
#include <SgAsmCilPropertyTable.h>
#include <SgAsmCilPropertyMapTable.h>
#include <SgAsmCilStandAloneSigTable.h>
#include <SgAsmCilTypeDefTable.h>
#include <SgAsmCilTypeRefTable.h>
#include <SgAsmCilTypeSpecTable.h>
#endif
#endif // SgAsmCilMetadataHeap_HEADERS

#ifdef DOCUMENTATION
/** CIL SgAsmCilMetadataHeap node. */
class SgAsmCilMetadataHeap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint32_t", "ReservedAlwaysZero", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "MajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "MinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "HeapSizes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "ReservedAlwaysOne", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "Valid", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "Sorted", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "std::vector<uint32_t>", "NumberOfRows", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "DataSizeFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyTable*", "AssemblyTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyOSTable*", "AssemblyOSTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyProcessorTable*", "AssemblyProcessorTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefTable*", "AssemblyRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefOSTable*", "AssemblyRefOSTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefProcessorTable*", "AssemblyRefProcessorTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilClassLayoutTable*", "ClassLayoutTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilConstantTable*", "ConstantTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilCustomAttributeTable*", "CustomAttributeTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilDeclSecurityTable*", "DeclSecurityTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilEventTable*", "EventTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilEventMapTable*", "EventMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilExportedTypeTable*", "ExportedTypeTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldTable*", "FieldTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldLayoutTable*", "FieldLayoutTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldMarshalTable*", "FieldMarshalTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldRVATable*", "FieldRVATable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFileTable*", "FileTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilGenericParamTable*", "GenericParamTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilGenericParamConstraintTable*", "GenericParamConstraintTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilImplMapTable*", "ImplMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilInterfaceImplTable*", "InterfaceImplTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilManifestResourceTable*", "ManifestResourceTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMemberRefTable*", "MemberRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodDefTable*", "MethodDefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodImplTable*", "MethodImplTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodSemanticsTable*", "MethodSemanticsTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodSpecTable*", "MethodSpecTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilModuleTable*", "ModuleTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilModuleRefTable*", "ModuleRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilNestedClassTable*", "NestedClassTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilParamTable*", "ParamTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilPropertyTable*", "PropertyTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilPropertyMapTable*", "PropertyMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilStandAloneSigTable*", "StandAloneSigTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeDefTable*", "TypeDefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeRefTable*", "TypeRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeSpecTable*", "TypeSpecTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMetadataHeap);
#if defined(SgAsmCilMetadataHeap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMetadataHeap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMetadataHeap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
        s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysZero);
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
        s & BOOST_SERIALIZATION_NVP(p_HeapSizes);
        s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysOne);
        s & BOOST_SERIALIZATION_NVP(p_Valid);
        s & BOOST_SERIALIZATION_NVP(p_Sorted);
        s & BOOST_SERIALIZATION_NVP(p_NumberOfRows);
        s & BOOST_SERIALIZATION_NVP(p_DataSizeFlags);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyTable);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyOSTable);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyProcessorTable);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefTable);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefOSTable);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefProcessorTable);
        s & BOOST_SERIALIZATION_NVP(p_ClassLayoutTable);
        s & BOOST_SERIALIZATION_NVP(p_ConstantTable);
        s & BOOST_SERIALIZATION_NVP(p_CustomAttributeTable);
        s & BOOST_SERIALIZATION_NVP(p_DeclSecurityTable);
        s & BOOST_SERIALIZATION_NVP(p_EventTable);
        s & BOOST_SERIALIZATION_NVP(p_EventMapTable);
        s & BOOST_SERIALIZATION_NVP(p_ExportedTypeTable);
        s & BOOST_SERIALIZATION_NVP(p_FieldTable);
        s & BOOST_SERIALIZATION_NVP(p_FieldLayoutTable);
        s & BOOST_SERIALIZATION_NVP(p_FieldMarshalTable);
        s & BOOST_SERIALIZATION_NVP(p_FieldRVATable);
        s & BOOST_SERIALIZATION_NVP(p_FileTable);
        s & BOOST_SERIALIZATION_NVP(p_GenericParamTable);
        s & BOOST_SERIALIZATION_NVP(p_GenericParamConstraintTable);
        s & BOOST_SERIALIZATION_NVP(p_ImplMapTable);
        s & BOOST_SERIALIZATION_NVP(p_InterfaceImplTable);
        s & BOOST_SERIALIZATION_NVP(p_ManifestResourceTable);
        s & BOOST_SERIALIZATION_NVP(p_MemberRefTable);
        s & BOOST_SERIALIZATION_NVP(p_MethodDefTable);
        s & BOOST_SERIALIZATION_NVP(p_MethodImplTable);
        s & BOOST_SERIALIZATION_NVP(p_MethodSemanticsTable);
        s & BOOST_SERIALIZATION_NVP(p_MethodSpecTable);
        s & BOOST_SERIALIZATION_NVP(p_ModuleTable);
        s & BOOST_SERIALIZATION_NVP(p_ModuleRefTable);
        s & BOOST_SERIALIZATION_NVP(p_NestedClassTable);
        s & BOOST_SERIALIZATION_NVP(p_ParamTable);
        s & BOOST_SERIALIZATION_NVP(p_PropertyTable);
        s & BOOST_SERIALIZATION_NVP(p_PropertyMapTable);
        s & BOOST_SERIALIZATION_NVP(p_StandAloneSigTable);
        s & BOOST_SERIALIZATION_NVP(p_TypeDefTable);
        s & BOOST_SERIALIZATION_NVP(p_TypeRefTable);
        s & BOOST_SERIALIZATION_NVP(p_TypeSpecTable);
        debugSerializationEnd("SgAsmCilMetadataHeap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: 4 reserved bytes. 
     * 
     * @{ */
    uint32_t const& get_ReservedAlwaysZero() const;
    void set_ReservedAlwaysZero(uint32_t const&);
    /** @} */

public:
    /** Property: A 1-byte constant. 
     * 
     * @{ */
    uint8_t const& get_MajorVersion() const;
    void set_MajorVersion(uint8_t const&);
    /** @} */

public:
    /** Property: A 1-byte constant. 
     * 
     * @{ */
    uint8_t const& get_MinorVersion() const;
    void set_MinorVersion(uint8_t const&);
    /** @} */

public:
    /** Property: A 1-byte constant indicating the index sizes of streams. 
     * 
     * @{ */
    uint8_t const& get_HeapSizes() const;
    void set_HeapSizes(uint8_t const&);
    /** @} */

public:
    /** Property: A 1-byte constant. 
     * 
     * @{ */
    uint8_t const& get_ReservedAlwaysOne() const;
    void set_ReservedAlwaysOne(uint8_t const&);
    /** @} */

public:
    /** Property: A 4-byte value indicating which metadata tables are present. 
     * 
     * @{ */
    uint64_t const& get_Valid() const;
    void set_Valid(uint64_t const&);
    /** @} */

public:
    /** Property: A 4-byte value. 
     * 
     * @{ */
    uint64_t const& get_Sorted() const;
    void set_Sorted(uint64_t const&);
    /** @} */

public:
    /** Property: A vector indicating how many rows the present tables contain. 
     * 
     * @{ */
    std::vector<uint32_t> const& get_NumberOfRows() const;
    void set_NumberOfRows(std::vector<uint32_t> const&);
    /** @} */

public:
    /** Property: precomputed flags that determine whether a metadata reference is stored as 2 or 4 byte value in the file. 
     * 
     * @{ */
    uint64_t const& get_DataSizeFlags() const;
    void set_DataSizeFlags(uint64_t const&);
    /** @} */

public:
    /** Property: AssemblyTable. 
     * 
     * @{ */
    SgAsmCilAssemblyTable* const& get_AssemblyTable() const;
    void set_AssemblyTable(SgAsmCilAssemblyTable* const&);
    /** @} */

public:
    /** Property: AssemblyOSTable. 
     * 
     * @{ */
    SgAsmCilAssemblyOSTable* const& get_AssemblyOSTable() const;
    void set_AssemblyOSTable(SgAsmCilAssemblyOSTable* const&);
    /** @} */

public:
    /** Property: AssemblyProcessorTable. 
     * 
     * @{ */
    SgAsmCilAssemblyProcessorTable* const& get_AssemblyProcessorTable() const;
    void set_AssemblyProcessorTable(SgAsmCilAssemblyProcessorTable* const&);
    /** @} */

public:
    /** Property: AssemblyRefTable. 
     * 
     * @{ */
    SgAsmCilAssemblyRefTable* const& get_AssemblyRefTable() const;
    void set_AssemblyRefTable(SgAsmCilAssemblyRefTable* const&);
    /** @} */

public:
    /** Property: AssemblyRefOSTable. 
     * 
     * @{ */
    SgAsmCilAssemblyRefOSTable* const& get_AssemblyRefOSTable() const;
    void set_AssemblyRefOSTable(SgAsmCilAssemblyRefOSTable* const&);
    /** @} */

public:
    /** Property: AssemblyRefProcessorTable. 
     * 
     * @{ */
    SgAsmCilAssemblyRefProcessorTable* const& get_AssemblyRefProcessorTable() const;
    void set_AssemblyRefProcessorTable(SgAsmCilAssemblyRefProcessorTable* const&);
    /** @} */

public:
    /** Property: ClassLayoutTable. 
     * 
     * @{ */
    SgAsmCilClassLayoutTable* const& get_ClassLayoutTable() const;
    void set_ClassLayoutTable(SgAsmCilClassLayoutTable* const&);
    /** @} */

public:
    /** Property: ConstantTable. 
     * 
     * @{ */
    SgAsmCilConstantTable* const& get_ConstantTable() const;
    void set_ConstantTable(SgAsmCilConstantTable* const&);
    /** @} */

public:
    /** Property: CustomAttributeTable. 
     * 
     * @{ */
    SgAsmCilCustomAttributeTable* const& get_CustomAttributeTable() const;
    void set_CustomAttributeTable(SgAsmCilCustomAttributeTable* const&);
    /** @} */

public:
    /** Property: DeclSecurityTable. 
     * 
     * @{ */
    SgAsmCilDeclSecurityTable* const& get_DeclSecurityTable() const;
    void set_DeclSecurityTable(SgAsmCilDeclSecurityTable* const&);
    /** @} */

public:
    /** Property: EventTable. 
     * 
     * @{ */
    SgAsmCilEventTable* const& get_EventTable() const;
    void set_EventTable(SgAsmCilEventTable* const&);
    /** @} */

public:
    /** Property: EventMapTable. 
     * 
     * @{ */
    SgAsmCilEventMapTable* const& get_EventMapTable() const;
    void set_EventMapTable(SgAsmCilEventMapTable* const&);
    /** @} */

public:
    /** Property: ExportedTypeTable. 
     * 
     * @{ */
    SgAsmCilExportedTypeTable* const& get_ExportedTypeTable() const;
    void set_ExportedTypeTable(SgAsmCilExportedTypeTable* const&);
    /** @} */

public:
    /** Property: FieldTable. 
     * 
     * @{ */
    SgAsmCilFieldTable* const& get_FieldTable() const;
    void set_FieldTable(SgAsmCilFieldTable* const&);
    /** @} */

public:
    /** Property: FieldLayoutTable. 
     * 
     * @{ */
    SgAsmCilFieldLayoutTable* const& get_FieldLayoutTable() const;
    void set_FieldLayoutTable(SgAsmCilFieldLayoutTable* const&);
    /** @} */

public:
    /** Property: FieldMarshalTable. 
     * 
     * @{ */
    SgAsmCilFieldMarshalTable* const& get_FieldMarshalTable() const;
    void set_FieldMarshalTable(SgAsmCilFieldMarshalTable* const&);
    /** @} */

public:
    /** Property: FieldRVATable. 
     * 
     * @{ */
    SgAsmCilFieldRVATable* const& get_FieldRVATable() const;
    void set_FieldRVATable(SgAsmCilFieldRVATable* const&);
    /** @} */

public:
    /** Property: FileTable. 
     * 
     * @{ */
    SgAsmCilFileTable* const& get_FileTable() const;
    void set_FileTable(SgAsmCilFileTable* const&);
    /** @} */

public:
    /** Property: GenericParamTable. 
     * 
     * @{ */
    SgAsmCilGenericParamTable* const& get_GenericParamTable() const;
    void set_GenericParamTable(SgAsmCilGenericParamTable* const&);
    /** @} */

public:
    /** Property: GenericParamConstraintTable. 
     * 
     * @{ */
    SgAsmCilGenericParamConstraintTable* const& get_GenericParamConstraintTable() const;
    void set_GenericParamConstraintTable(SgAsmCilGenericParamConstraintTable* const&);
    /** @} */

public:
    /** Property: ImplMapTable. 
     * 
     * @{ */
    SgAsmCilImplMapTable* const& get_ImplMapTable() const;
    void set_ImplMapTable(SgAsmCilImplMapTable* const&);
    /** @} */

public:
    /** Property: InterfaceImplTable. 
     * 
     * @{ */
    SgAsmCilInterfaceImplTable* const& get_InterfaceImplTable() const;
    void set_InterfaceImplTable(SgAsmCilInterfaceImplTable* const&);
    /** @} */

public:
    /** Property: ManifestResourceTable. 
     * 
     * @{ */
    SgAsmCilManifestResourceTable* const& get_ManifestResourceTable() const;
    void set_ManifestResourceTable(SgAsmCilManifestResourceTable* const&);
    /** @} */

public:
    /** Property: MemberRefTable. 
     * 
     * @{ */
    SgAsmCilMemberRefTable* const& get_MemberRefTable() const;
    void set_MemberRefTable(SgAsmCilMemberRefTable* const&);
    /** @} */

public:
    /** Property: MethodDefTable. 
     * 
     * @{ */
    SgAsmCilMethodDefTable* const& get_MethodDefTable() const;
    void set_MethodDefTable(SgAsmCilMethodDefTable* const&);
    /** @} */

public:
    /** Property: MethodImplTable. 
     * 
     * @{ */
    SgAsmCilMethodImplTable* const& get_MethodImplTable() const;
    void set_MethodImplTable(SgAsmCilMethodImplTable* const&);
    /** @} */

public:
    /** Property: MethodSemanticsTable. 
     * 
     * @{ */
    SgAsmCilMethodSemanticsTable* const& get_MethodSemanticsTable() const;
    void set_MethodSemanticsTable(SgAsmCilMethodSemanticsTable* const&);
    /** @} */

public:
    /** Property: MethodSpecTable. 
     * 
     * @{ */
    SgAsmCilMethodSpecTable* const& get_MethodSpecTable() const;
    void set_MethodSpecTable(SgAsmCilMethodSpecTable* const&);
    /** @} */

public:
    /** Property: ModuleTable. 
     * 
     * @{ */
    SgAsmCilModuleTable* const& get_ModuleTable() const;
    void set_ModuleTable(SgAsmCilModuleTable* const&);
    /** @} */

public:
    /** Property: ModuleRefTable. 
     * 
     * @{ */
    SgAsmCilModuleRefTable* const& get_ModuleRefTable() const;
    void set_ModuleRefTable(SgAsmCilModuleRefTable* const&);
    /** @} */

public:
    /** Property: NestedClassTable. 
     * 
     * @{ */
    SgAsmCilNestedClassTable* const& get_NestedClassTable() const;
    void set_NestedClassTable(SgAsmCilNestedClassTable* const&);
    /** @} */

public:
    /** Property: ParamTable. 
     * 
     * @{ */
    SgAsmCilParamTable* const& get_ParamTable() const;
    void set_ParamTable(SgAsmCilParamTable* const&);
    /** @} */

public:
    /** Property: PropertyTable. 
     * 
     * @{ */
    SgAsmCilPropertyTable* const& get_PropertyTable() const;
    void set_PropertyTable(SgAsmCilPropertyTable* const&);
    /** @} */

public:
    /** Property: PropertyMapTable. 
     * 
     * @{ */
    SgAsmCilPropertyMapTable* const& get_PropertyMapTable() const;
    void set_PropertyMapTable(SgAsmCilPropertyMapTable* const&);
    /** @} */

public:
    /** Property: StandAloneSigTable. 
     * 
     * @{ */
    SgAsmCilStandAloneSigTable* const& get_StandAloneSigTable() const;
    void set_StandAloneSigTable(SgAsmCilStandAloneSigTable* const&);
    /** @} */

public:
    /** Property: TypeDefTable. 
     * 
     * @{ */
    SgAsmCilTypeDefTable* const& get_TypeDefTable() const;
    void set_TypeDefTable(SgAsmCilTypeDefTable* const&);
    /** @} */

public:
    /** Property: TypeRefTable. 
     * 
     * @{ */
    SgAsmCilTypeRefTable* const& get_TypeRefTable() const;
    void set_TypeRefTable(SgAsmCilTypeRefTable* const&);
    /** @} */

public:
    /** Property: TypeSpecTable. 
     * 
     * @{ */
    SgAsmCilTypeSpecTable* const& get_TypeSpecTable() const;
    void set_TypeSpecTable(SgAsmCilTypeSpecTable* const&);
    /** @} */
public:
    /// reference kinds in the metadata tables
    enum ReferenceKind
    {
      // heaps
      e_ref_string_heap           = 1 << 0,
      e_ref_guid_heap             = 1 << 1,
      e_ref_blob_heap             = 1 << 2,
      // single-table references
      e_ref_assembly_ref          = 1 << 3,
      e_ref_type_def              = 1 << 4,
      e_ref_event                 = 1 << 5,
      e_ref_field                 = 1 << 6,
      e_ref_generic_param         = 1 << 7,
      e_ref_module_ref            = 1 << 8,
      e_ref_method_def            = 1 << 9,
      e_ref_param                 = 1 << 10,
      e_ref_property              = 1 << 11,
      // multi-table references
      e_ref_has_constant          = 1 << 12,
      e_ref_has_custom_attribute  = 1 << 13,
      e_ref_has_decl_security     = 1 << 14,
      e_ref_has_field_marshall    = 1 << 15,
      e_ref_has_semantics         = 1 << 16,
      e_ref_method_def_or_ref     = 1 << 17,
      e_ref_type_def_or_ref       = 1 << 18,
      e_ref_implementation        = 1 << 19,
      e_ref_member_forwarded      = 1 << 20,
      e_ref_member_ref_parent     = 1 << 21,
      e_ref_type_or_method_def    = 1 << 22,
      e_ref_custom_attribute_type = 1 << 23,
      e_ref_resolution_scope      = 1 << 24,
      e_ref_last                  = 1 << 25,
    };

    enum TableKind : std::uint8_t
    {

      e_Assembly = 0x20,
      e_AssemblyOS = 0x22,
      e_AssemblyProcessor = 0x21,
      e_AssemblyRef = 0x23,
      e_AssemblyRefOS = 0x25,
      e_AssemblyRefProcessor = 0x24,
      e_ClassLayout = 0x0F,
      e_Constant = 0x0B,
      e_CustomAttribute = 0x0C,
      e_DeclSecurity = 0x0E,
      e_Event = 0x14,
      e_EventMap = 0x12,
      e_ExportedType = 0x27,
      e_Field = 0x04,
      e_FieldLayout = 0x10,
      e_FieldMarshal = 0x0D,
      e_FieldRVA = 0x1D,
      e_File = 0x26,
      e_GenericParam = 0x2A,
      e_GenericParamConstraint = 0x2C,
      e_ImplMap = 0x1C,
      e_InterfaceImpl = 0x09,
      e_ManifestResource = 0x28,
      e_MemberRef = 0x0A,
      e_MethodDef = 0x06,
      e_MethodImpl = 0x19,
      e_MethodSemantics = 0x18,
      e_MethodSpec = 0x2B,
      e_Module = 0x00,
      e_ModuleRef = 0x1A,
      e_NestedClass = 0x29,
      e_Param = 0x08,
      e_Property = 0x17,
      e_PropertyMap = 0x15,
      e_StandAloneSig = 0x11,
      e_TypeDef = 0x02,
      e_TypeRef = 0x01,
      e_TypeSpec = 0x1B,
      e_Unknown_table_kind = 0xFF
    };

    /** parses the metadata objects from the buffer. */
    void parse(const std::vector<uint8_t>& buf, size_t startOfMetaData) override;

    /** unparses the metadata objects into the buffer */
    void unparse(std::vector<uint8_t>& buf, size_t startOfMetaData) const override;

    /** Prints the object's data in a human readable form. */
    void dump(std::ostream& os) const override;

    /** Look up node by index.
     *
     *  Looks up the node associated with the coded index @p idx in the metadata table associated with @p tblcode. */
    SgAsmCilMetadata* get_MetadataNode(std::uint32_t idx, TableKind tblcode) const;

    /** Look up node by index.
     *
     *  Looks up the node associated with the coded index @p refcode in the metadata tables under the assumption that the value is
     *  of kind @p knd. */
    SgAsmCilMetadata* get_CodedMetadataNode(std::uint32_t refcode, ReferenceKind knd) const;

    /** Look up node by index.
     *
     *  Looks up the node associated with the coded index @p refcode in the metadata tables under the assumption the value is of
     *  kind @p knd. */
    SgAsmCilMetadata* get_MetadataNode(std::uint32_t refcode, ReferenceKind knd) const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMetadataHeap();

public:
    /** Default constructor. */
    SgAsmCilMetadataHeap();

public:
    /** Constructor. */
    SgAsmCilMetadataHeap(uint32_t const& Offset,
                         uint32_t const& Size,
                         std::string const& Name,
                         uint32_t const& NamePadding);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadataHeap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMemberRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMemberRefTable);
IS_SERIALIZABLE(AsmCilMemberRefTable);

#ifndef DOCUMENTATION
AsmCilMemberRefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MemberRef tables. */
class SgAsmCilMemberRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMemberRefTable.setDataPrototype(
        "std::vector<SgAsmCilMemberRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMemberRefTable);
#if defined(SgAsmCilMemberRefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMemberRefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMemberRefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilMemberRefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilMemberRef*> const& get_elements() const;
    std::vector<SgAsmCilMemberRef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilMemberRef;
public:
    /** Destructor. */
    virtual ~SgAsmCilMemberRefTable();

public:
    /** Default constructor. */
    SgAsmCilMemberRefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMemberRefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMemberRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilMemberRef);
IS_SERIALIZABLE(AsmCilMemberRef);

#ifndef DOCUMENTATION
AsmCilMemberRef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL MemberRef node (II.22.25). */
class SgAsmCilMemberRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilMemberRef);
#if defined(SgAsmCilMemberRef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMemberRef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMemberRef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Class);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        debugSerializationEnd("SgAsmCilMemberRef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Class.
     *
     *  An index into the MethodDef, ModuleRef, TypeDef, TypeRef, or TypeSpec tables. 
     *  
     *  @{ */
    uint32_t const& get_Class() const;
    void set_Class(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Signature.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Class_object() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilMemberRef();

public:
    /** Default constructor. */
    SgAsmCilMemberRef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMemberRef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilManifestResourceTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilManifestResourceTable);
IS_SERIALIZABLE(AsmCilManifestResourceTable);

#ifndef DOCUMENTATION
AsmCilManifestResourceTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ManifestResource tables. */
class SgAsmCilManifestResourceTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilManifestResourceTable.setDataPrototype(
        "std::vector<SgAsmCilManifestResource*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilManifestResourceTable);
#if defined(SgAsmCilManifestResourceTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilManifestResourceTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilManifestResourceTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilManifestResourceTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilManifestResource*> const& get_elements() const;
    std::vector<SgAsmCilManifestResource*>& get_elements();
public:
    using CilMetadataType = SgAsmCilManifestResource;
public:
    /** Destructor. */
    virtual ~SgAsmCilManifestResourceTable();

public:
    /** Default constructor. */
    SgAsmCilManifestResourceTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilManifestResourceTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilManifestResource           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilManifestResource);
IS_SERIALIZABLE(AsmCilManifestResource);

#ifndef DOCUMENTATION
AsmCilManifestResource.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ManifestResource node (II.22.24). */
class SgAsmCilManifestResource: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Implementation", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilManifestResource);
#if defined(SgAsmCilManifestResource_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilManifestResource -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilManifestResource");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Offset);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Implementation);
        debugSerializationEnd("SgAsmCilManifestResource");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Offset.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_Offset() const;
    void set_Offset(uint32_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  A 4-byte constant of type ManifestResourceAttributes. 
     *  
     *  @{ */
    uint32_t const& get_Flags() const;
    void set_Flags(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Implementation.
     *
     *  An index into a File table, a AssemblyRef table, or null. 
     *  
     *  @{ */
    uint32_t const& get_Implementation() const;
    void set_Implementation(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const SgAsmCilMetadata* get_Implementation_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilManifestResource();

public:
    /** Default constructor. */
    SgAsmCilManifestResource();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilManifestResource_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInterfaceImplTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilInterfaceImplTable);
IS_SERIALIZABLE(AsmCilInterfaceImplTable);

#ifndef DOCUMENTATION
AsmCilInterfaceImplTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL InterfaceImpl tables. */
class SgAsmCilInterfaceImplTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilInterfaceImplTable.setDataPrototype(
        "std::vector<SgAsmCilInterfaceImpl*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilInterfaceImplTable);
#if defined(SgAsmCilInterfaceImplTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilInterfaceImplTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilInterfaceImplTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilInterfaceImplTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilInterfaceImpl*> const& get_elements() const;
    std::vector<SgAsmCilInterfaceImpl*>& get_elements();
public:
    using CilMetadataType = SgAsmCilInterfaceImpl;
public:
    /** Destructor. */
    virtual ~SgAsmCilInterfaceImplTable();

public:
    /** Default constructor. */
    SgAsmCilInterfaceImplTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInterfaceImplTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInterfaceImpl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilInterfaceImpl);
IS_SERIALIZABLE(AsmCilInterfaceImpl);

#ifndef DOCUMENTATION
AsmCilInterfaceImpl.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL InterfaceImpl node (II.22.23). */
class SgAsmCilInterfaceImpl: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilInterfaceImpl.setDataPrototype(
        "uint32_t", "Class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilInterfaceImpl.setDataPrototype(
        "uint32_t", "Interface", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilInterfaceImpl);
#if defined(SgAsmCilInterfaceImpl_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilInterfaceImpl -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilInterfaceImpl");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Class);
        s & BOOST_SERIALIZATION_NVP(p_Interface);
        debugSerializationEnd("SgAsmCilInterfaceImpl");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Class.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_Class() const;
    void set_Class(uint32_t const&);
    /** @} */

public:
    /** Property: Interface.
     *
     *  An index into the TypeDef, TypeRef, or TypeSpec table. 
     *  
     *  @{ */
    uint32_t const& get_Interface() const;
    void set_Interface(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Class_object() const;
    const SgAsmCilMetadata* get_Interface_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilInterfaceImpl();

public:
    /** Default constructor. */
    SgAsmCilInterfaceImpl();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInterfaceImpl_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilInstruction);
IS_SERIALIZABLE(AsmCilInstruction);

#ifndef DOCUMENTATION
AsmCilInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmCilInstruction);
#if defined(SgAsmCilInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/InstructionEnumsCil.h>
#endif // SgAsmCilInstruction_HEADERS

#ifdef DOCUMENTATION
class SgAsmCilInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::CilInstructionKind", "kind", "= Rose::BinaryAnalysis::Cil_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilInstruction);
#if defined(SgAsmCilInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        debugSerializationEnd("SgAsmCilInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the CIL instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::CilInstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::CilInstructionKind const&);
    /** @} */
public:
    // Overrides are documented in the base classa
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmCilInstruction();

public:
    /** Default constructor. */
    SgAsmCilInstruction();

public:
    /** Constructor. */
    SgAsmCilInstruction(rose_addr_t const& address,
                        uint8_t const& architectureId,
                        Rose::BinaryAnalysis::CilInstructionKind const& kind);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilImplMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilImplMapTable);
IS_SERIALIZABLE(AsmCilImplMapTable);

#ifndef DOCUMENTATION
AsmCilImplMapTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ImplMap tables. */
class SgAsmCilImplMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilImplMapTable.setDataPrototype(
        "std::vector<SgAsmCilImplMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilImplMapTable);
#if defined(SgAsmCilImplMapTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilImplMapTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilImplMapTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilImplMapTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilImplMap*> const& get_elements() const;
    std::vector<SgAsmCilImplMap*>& get_elements();
public:
    using CilMetadataType = SgAsmCilImplMap;
public:
    /** Destructor. */
    virtual ~SgAsmCilImplMapTable();

public:
    /** Default constructor. */
    SgAsmCilImplMapTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilImplMapTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilImplMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilImplMap);
IS_SERIALIZABLE(AsmCilImplMap);

#ifndef DOCUMENTATION
AsmCilImplMap.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ImplMap node (II.22.22). */
class SgAsmCilImplMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilImplMap.setDataPrototype(
        "uint16_t", "MappingFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "MemberForwarded", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "ImportName", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "ImportScope", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilImplMap);
#if defined(SgAsmCilImplMap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilImplMap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilImplMap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_MappingFlags);
        s & BOOST_SERIALIZATION_NVP(p_MemberForwarded);
        s & BOOST_SERIALIZATION_NVP(p_ImportName);
        s & BOOST_SERIALIZATION_NVP(p_ImportScope);
        debugSerializationEnd("SgAsmCilImplMap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: MappingFlags.
     *
     *  A 2-byte bitmask of type PInvokeAttributes. 
     *  
     *  @{ */
    uint16_t const& get_MappingFlags() const;
    void set_MappingFlags(uint16_t const&);
    /** @} */

public:
    /** Property: MemberForwarded.
     *
     *  An index into the Field or MethodDef table. 
     *  
     *  @{ */
    uint32_t const& get_MemberForwarded() const;
    void set_MemberForwarded(uint32_t const&);
    /** @} */

public:
    /** Property: ImportName.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_ImportName() const;
    void set_ImportName(uint32_t const&);
    /** @} */

public:
    /** Property: ImportScope.
     *
     *  An index into the ModuleRef table. 
     *  
     *  @{ */
    uint32_t const& get_ImportScope() const;
    void set_ImportScope(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_MemberForwarded_object() const;
    const std::uint8_t* get_ImportName_string() const;
    const SgAsmCilMetadata* get_ImportScope_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilImplMap();

public:
    /** Default constructor. */
    SgAsmCilImplMap();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilImplMap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilGenericParamTable);
IS_SERIALIZABLE(AsmCilGenericParamTable);

#ifndef DOCUMENTATION
AsmCilGenericParamTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL GenericParam tables. */
class SgAsmCilGenericParamTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParamTable.setDataPrototype(
        "std::vector<SgAsmCilGenericParam*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilGenericParamTable);
#if defined(SgAsmCilGenericParamTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilGenericParamTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilGenericParamTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilGenericParamTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilGenericParam*> const& get_elements() const;
    std::vector<SgAsmCilGenericParam*>& get_elements();
public:
    using CilMetadataType = SgAsmCilGenericParam;
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamTable();

public:
    /** Default constructor. */
    SgAsmCilGenericParamTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParam           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilGenericParam);
IS_SERIALIZABLE(AsmCilGenericParam);

#ifndef DOCUMENTATION
AsmCilGenericParam.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL GenericParam node (II.22.20). */
class SgAsmCilGenericParam: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParam.setDataPrototype(
        "uint16_t", "Number", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParam.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParam.setDataPrototype(
        "uint32_t", "Owner", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParam.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilGenericParam);
#if defined(SgAsmCilGenericParam_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilGenericParam -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilGenericParam");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Number);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Owner);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        debugSerializationEnd("SgAsmCilGenericParam");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Number.
     *
     *  The 2-byte index of the generic parameter. 
     *  
     *  @{ */
    uint16_t const& get_Number() const;
    void set_Number(uint16_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  A 2-byte bitmask of type GenericParamAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Owner.
     *
     *  An index into the TypeDef or MethodDef table. 
     *  
     *  @{ */
    uint32_t const& get_Owner() const;
    void set_Owner(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Owner_object() const;
    const std::uint8_t* get_Name_string() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParam();

public:
    /** Default constructor. */
    SgAsmCilGenericParam();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParam_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamConstraintTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilGenericParamConstraintTable);
IS_SERIALIZABLE(AsmCilGenericParamConstraintTable);

#ifndef DOCUMENTATION
AsmCilGenericParamConstraintTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL GenericParamConstraint tables. */
class SgAsmCilGenericParamConstraintTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParamConstraintTable.setDataPrototype(
        "std::vector<SgAsmCilGenericParamConstraint*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilGenericParamConstraintTable);
#if defined(SgAsmCilGenericParamConstraintTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilGenericParamConstraintTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilGenericParamConstraintTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilGenericParamConstraintTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilGenericParamConstraint*> const& get_elements() const;
    std::vector<SgAsmCilGenericParamConstraint*>& get_elements();
public:
    using CilMetadataType = SgAsmCilGenericParamConstraint;
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamConstraintTable();

public:
    /** Default constructor. */
    SgAsmCilGenericParamConstraintTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamConstraintTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamConstraint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilGenericParamConstraint);
IS_SERIALIZABLE(AsmCilGenericParamConstraint);

#ifndef DOCUMENTATION
AsmCilGenericParamConstraint.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL GenericParamConstraint node (II.22.21). */
class SgAsmCilGenericParamConstraint: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParamConstraint.setDataPrototype(
        "uint32_t", "Owner", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilGenericParamConstraint.setDataPrototype(
        "uint32_t", "Constraint", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilGenericParamConstraint);
#if defined(SgAsmCilGenericParamConstraint_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilGenericParamConstraint -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilGenericParamConstraint");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Owner);
        s & BOOST_SERIALIZATION_NVP(p_Constraint);
        debugSerializationEnd("SgAsmCilGenericParamConstraint");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Owner.
     *
     *  An index into the GenericParam table. 
     *  
     *  @{ */
    uint32_t const& get_Owner() const;
    void set_Owner(uint32_t const&);
    /** @} */

public:
    /** Property: Constraint.
     *
     *  An index into the TypeDef, TypeRef, or TypeSpec table. 
     *  
     *  @{ */
    uint32_t const& get_Constraint() const;
    void set_Constraint(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Owner_object() const;
    const SgAsmCilMetadata* get_Constraint_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamConstraint();

public:
    /** Default constructor. */
    SgAsmCilGenericParamConstraint();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamConstraint_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFileTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFileTable);
IS_SERIALIZABLE(AsmCilFileTable);

#ifndef DOCUMENTATION
AsmCilFileTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL File tables. */
class SgAsmCilFileTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFileTable.setDataPrototype(
        "std::vector<SgAsmCilFile*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFileTable);
#if defined(SgAsmCilFileTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFileTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFileTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilFileTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilFile*> const& get_elements() const;
    std::vector<SgAsmCilFile*>& get_elements();
public:
    using CilMetadataType = SgAsmCilFile;
public:
    /** Destructor. */
    virtual ~SgAsmCilFileTable();

public:
    /** Default constructor. */
    SgAsmCilFileTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFileTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFile);
IS_SERIALIZABLE(AsmCilFile);

#ifndef DOCUMENTATION
AsmCilFile.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL File node (II.22.19). */
class SgAsmCilFile: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFile.setDataPrototype(
        "uint32_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFile.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFile.setDataPrototype(
        "uint32_t", "HashValue", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFile);
#if defined(SgAsmCilFile_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFile -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFile");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_HashValue);
        debugSerializationEnd("SgAsmCilFile");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Flags.
     *
     *  A 4-byte bitmask of type FileAttributes. 
     *  
     *  @{ */
    uint32_t const& get_Flags() const;
    void set_Flags(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: HashValue.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_HashValue() const;
    void set_HashValue(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_HashValue_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilFile();

public:
    /** Default constructor. */
    SgAsmCilFile();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFile_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldTable);
IS_SERIALIZABLE(AsmCilFieldTable);

#ifndef DOCUMENTATION
AsmCilFieldTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Field tables. */
class SgAsmCilFieldTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldTable.setDataPrototype(
        "std::vector<SgAsmCilField*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldTable);
#if defined(SgAsmCilFieldTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilFieldTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilField*> const& get_elements() const;
    std::vector<SgAsmCilField*>& get_elements();
public:
    using CilMetadataType = SgAsmCilField;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldTable();

public:
    /** Default constructor. */
    SgAsmCilFieldTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldRVATable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldRVATable);
IS_SERIALIZABLE(AsmCilFieldRVATable);

#ifndef DOCUMENTATION
AsmCilFieldRVATable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldRVA tables. */
class SgAsmCilFieldRVATable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldRVATable.setDataPrototype(
        "std::vector<SgAsmCilFieldRVA*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldRVATable);
#if defined(SgAsmCilFieldRVATable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldRVATable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldRVATable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilFieldRVATable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilFieldRVA*> const& get_elements() const;
    std::vector<SgAsmCilFieldRVA*>& get_elements();
public:
    using CilMetadataType = SgAsmCilFieldRVA;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldRVATable();

public:
    /** Default constructor. */
    SgAsmCilFieldRVATable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldRVATable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldRVA           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldRVA);
IS_SERIALIZABLE(AsmCilFieldRVA);

#ifndef DOCUMENTATION
AsmCilFieldRVA.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldRVA node (II.22.18). */
class SgAsmCilFieldRVA: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldRVA.setDataPrototype(
        "uint32_t", "RVA", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldRVA.setDataPrototype(
        "uint32_t", "Field", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldRVA);
#if defined(SgAsmCilFieldRVA_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldRVA -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldRVA");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_RVA);
        s & BOOST_SERIALIZATION_NVP(p_Field);
        debugSerializationEnd("SgAsmCilFieldRVA");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: RVA.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_RVA() const;
    void set_RVA(uint32_t const&);
    /** @} */

public:
    /** Property: Field.
     *
     *  An index into Field table. 
     *  
     *  @{ */
    uint32_t const& get_Field() const;
    void set_Field(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Field_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldRVA();

public:
    /** Default constructor. */
    SgAsmCilFieldRVA();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldRVA_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldMarshalTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldMarshalTable);
IS_SERIALIZABLE(AsmCilFieldMarshalTable);

#ifndef DOCUMENTATION
AsmCilFieldMarshalTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldMarshal tables. */
class SgAsmCilFieldMarshalTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldMarshalTable.setDataPrototype(
        "std::vector<SgAsmCilFieldMarshal*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldMarshalTable);
#if defined(SgAsmCilFieldMarshalTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldMarshalTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldMarshalTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilFieldMarshalTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilFieldMarshal*> const& get_elements() const;
    std::vector<SgAsmCilFieldMarshal*>& get_elements();
public:
    using CilMetadataType = SgAsmCilFieldMarshal;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldMarshalTable();

public:
    /** Default constructor. */
    SgAsmCilFieldMarshalTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldMarshalTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldMarshal           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldMarshal);
IS_SERIALIZABLE(AsmCilFieldMarshal);

#ifndef DOCUMENTATION
AsmCilFieldMarshal.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldMarshal node (II.22.17). */
class SgAsmCilFieldMarshal: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldMarshal.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldMarshal.setDataPrototype(
        "uint32_t", "NativeType", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldMarshal);
#if defined(SgAsmCilFieldMarshal_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldMarshal -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldMarshal");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_NativeType);
        debugSerializationEnd("SgAsmCilFieldMarshal");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Parent.
     *
     *  An index into Field or Param table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: NativeType.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_NativeType() const;
    void set_NativeType(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_NativeType_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldMarshal();

public:
    /** Default constructor. */
    SgAsmCilFieldMarshal();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldMarshal_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldLayoutTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldLayoutTable);
IS_SERIALIZABLE(AsmCilFieldLayoutTable);

#ifndef DOCUMENTATION
AsmCilFieldLayoutTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldLayout tables. */
class SgAsmCilFieldLayoutTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldLayoutTable.setDataPrototype(
        "std::vector<SgAsmCilFieldLayout*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldLayoutTable);
#if defined(SgAsmCilFieldLayoutTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldLayoutTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldLayoutTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilFieldLayoutTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilFieldLayout*> const& get_elements() const;
    std::vector<SgAsmCilFieldLayout*>& get_elements();
public:
    using CilMetadataType = SgAsmCilFieldLayout;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldLayoutTable();

public:
    /** Default constructor. */
    SgAsmCilFieldLayoutTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldLayoutTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldLayout           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilFieldLayout);
IS_SERIALIZABLE(AsmCilFieldLayout);

#ifndef DOCUMENTATION
AsmCilFieldLayout.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL FieldLayout node (II.22.16). */
class SgAsmCilFieldLayout: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldLayout.setDataPrototype(
        "uint32_t", "Offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilFieldLayout.setDataPrototype(
        "uint32_t", "Field", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilFieldLayout);
#if defined(SgAsmCilFieldLayout_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilFieldLayout -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilFieldLayout");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Offset);
        s & BOOST_SERIALIZATION_NVP(p_Field);
        debugSerializationEnd("SgAsmCilFieldLayout");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Offset.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_Offset() const;
    void set_Offset(uint32_t const&);
    /** @} */

public:
    /** Property: Field.
     *
     *  An index into the Field table. 
     *  
     *  @{ */
    uint32_t const& get_Field() const;
    void set_Field(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Field_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldLayout();

public:
    /** Default constructor. */
    SgAsmCilFieldLayout();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldLayout_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilField           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilField);
IS_SERIALIZABLE(AsmCilField);

#ifndef DOCUMENTATION
AsmCilField.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Field node (II.22.15). */
class SgAsmCilField: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilField.setDataPrototype(
        "uint16_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilField.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilField.setDataPrototype(
        "uint32_t", "Signature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilField);
#if defined(SgAsmCilField_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilField -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilField");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Signature);
        debugSerializationEnd("SgAsmCilField");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Flags.
     *
     *  A 2-byte bitmask of type FieldAttributes. 
     *  
     *  @{ */
    uint16_t const& get_Flags() const;
    void set_Flags(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Signature.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Signature() const;
    void set_Signature(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilField();

public:
    /** Default constructor. */
    SgAsmCilField();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilField_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilExportedTypeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilExportedTypeTable);
IS_SERIALIZABLE(AsmCilExportedTypeTable);

#ifndef DOCUMENTATION
AsmCilExportedTypeTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ExportedType tables. */
class SgAsmCilExportedTypeTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedTypeTable.setDataPrototype(
        "std::vector<SgAsmCilExportedType*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilExportedTypeTable);
#if defined(SgAsmCilExportedTypeTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilExportedTypeTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilExportedTypeTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilExportedTypeTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilExportedType*> const& get_elements() const;
    std::vector<SgAsmCilExportedType*>& get_elements();
public:
    using CilMetadataType = SgAsmCilExportedType;
public:
    /** Destructor. */
    virtual ~SgAsmCilExportedTypeTable();

public:
    /** Default constructor. */
    SgAsmCilExportedTypeTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilExportedTypeTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilExportedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilExportedType);
IS_SERIALIZABLE(AsmCilExportedType);

#ifndef DOCUMENTATION
AsmCilExportedType.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ExportedType node (II.22.14). */
class SgAsmCilExportedType: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "EventFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeDefIdName", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeName", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeNamespace", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "Implementation", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilExportedType);
#if defined(SgAsmCilExportedType_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilExportedType -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilExportedType");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_EventFlags);
        s & BOOST_SERIALIZATION_NVP(p_TypeDefIdName);
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
        s & BOOST_SERIALIZATION_NVP(p_Implementation);
        debugSerializationEnd("SgAsmCilExportedType");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: EventFlags.
     *
     *  A 4-byte bitmask of type TypeAttribute. 
     *  
     *  @{ */
    uint32_t const& get_EventFlags() const;
    void set_EventFlags(uint32_t const&);
    /** @} */

public:
    /** Property: TypeDefIdName.
     *
     *  A 4-byte index into a TypeDef table of another module in this Assembly. 
     *  
     *  @{ */
    uint32_t const& get_TypeDefIdName() const;
    void set_TypeDefIdName(uint32_t const&);
    /** @} */

public:
    /** Property: TypeName.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeName() const;
    void set_TypeName(uint32_t const&);
    /** @} */

public:
    /** Property: TypeNamespace.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_TypeNamespace() const;
    void set_TypeNamespace(uint32_t const&);
    /** @} */

public:
    /** Property: Implementation.
     *
     *  An index into the File table, ExportedType table, or the AssemblyRef table. 
     *  
     *  @{ */
    uint32_t const& get_Implementation() const;
    void set_Implementation(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
    const SgAsmCilMetadata* get_Implementation_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilExportedType();

public:
    /** Default constructor. */
    SgAsmCilExportedType();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilExportedType_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilExceptionData           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilExceptionData);
IS_SERIALIZABLE(AsmCilExceptionData);

#ifndef DOCUMENTATION
AsmCilExceptionData.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Property class representing CIL Exception clauses (II.25.4.6). 
 *  
 * \note parsing/unparsing is handled by the using class (i.e., SgAsmCilMethoDef)
 */
class SgAsmCilExceptionData: public SgAsmCilNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "tryOffset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "tryLength", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "handlerOffset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "handlerLength", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilExceptionData.setDataPrototype(
        "std::uint32_t", "classTokenOrFilterOffset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilExceptionData);
#if defined(SgAsmCilExceptionData_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilExceptionData -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilExceptionData");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        s & BOOST_SERIALIZATION_NVP(p_flags);
        s & BOOST_SERIALIZATION_NVP(p_tryOffset);
        s & BOOST_SERIALIZATION_NVP(p_tryLength);
        s & BOOST_SERIALIZATION_NVP(p_handlerOffset);
        s & BOOST_SERIALIZATION_NVP(p_handlerLength);
        s & BOOST_SERIALIZATION_NVP(p_classTokenOrFilterOffset);
        debugSerializationEnd("SgAsmCilExceptionData");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
  enum
  {
    COR_ILEXCEPTION_CLAUSE_EXCEPTION = 0x0000,
    COR_ILEXCEPTION_CLAUSE_FILTER    = 0x0001,
    COR_ILEXCEPTION_CLAUSE_FINALLY   = 0x0002,
    COR_ILEXCEPTION_CLAUSE_FAULT     = 0x0004,
    COR_ILEXCEPTION_CLAUSE_MASK      = ( COR_ILEXCEPTION_CLAUSE_EXCEPTION
                                       | COR_ILEXCEPTION_CLAUSE_FILTER
                                       | COR_ILEXCEPTION_CLAUSE_FINALLY
                                       | COR_ILEXCEPTION_CLAUSE_FAULT
                                       ),
  };

private:
public:
    std::uint32_t const& get_flags() const;
    void set_flags(std::uint32_t const&);

public:
    std::uint32_t const& get_tryOffset() const;
    void set_tryOffset(std::uint32_t const&);

public:
    std::uint32_t const& get_tryLength() const;
    void set_tryLength(std::uint32_t const&);

public:
    std::uint32_t const& get_handlerOffset() const;
    void set_handlerOffset(std::uint32_t const&);

public:
    std::uint32_t const& get_handlerLength() const;
    void set_handlerLength(std::uint32_t const&);

public:
    std::uint32_t const& get_classTokenOrFilterOffset() const;
    void set_classTokenOrFilterOffset(std::uint32_t const&);
public:
  /**
   * Convenience functions to query the flags property.
   * \{
   */
  bool isException() const { return (get_flags() & COR_ILEXCEPTION_CLAUSE_MASK) == COR_ILEXCEPTION_CLAUSE_EXCEPTION; }
  bool isFilter()    const { return (get_flags() & COR_ILEXCEPTION_CLAUSE_MASK) == COR_ILEXCEPTION_CLAUSE_FILTER; }
  bool isFinally()   const { return (get_flags() & COR_ILEXCEPTION_CLAUSE_MASK) == COR_ILEXCEPTION_CLAUSE_FINALLY; }
  bool isFault()     const { return (get_flags() & COR_ILEXCEPTION_CLAUSE_MASK) == COR_ILEXCEPTION_CLAUSE_FAULT; }
  /** \} */
public:
    /** Destructor. */
    virtual ~SgAsmCilExceptionData();

public:
    /** Default constructor. */
    SgAsmCilExceptionData();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilExceptionData_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilEventTable);
IS_SERIALIZABLE(AsmCilEventTable);

#ifndef DOCUMENTATION
AsmCilEventTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Event tables. */
class SgAsmCilEventTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEventTable.setDataPrototype(
        "std::vector<SgAsmCilEvent*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilEventTable);
#if defined(SgAsmCilEventTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilEventTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilEventTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilEventTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilEvent*> const& get_elements() const;
    std::vector<SgAsmCilEvent*>& get_elements();
public:
    using CilMetadataType = SgAsmCilEvent;
public:
    /** Destructor. */
    virtual ~SgAsmCilEventTable();

public:
    /** Default constructor. */
    SgAsmCilEventTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilEventMapTable);
IS_SERIALIZABLE(AsmCilEventMapTable);

#ifndef DOCUMENTATION
AsmCilEventMapTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL EventMap tables. */
class SgAsmCilEventMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEventMapTable.setDataPrototype(
        "std::vector<SgAsmCilEventMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilEventMapTable);
#if defined(SgAsmCilEventMapTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilEventMapTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilEventMapTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilEventMapTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilEventMap*> const& get_elements() const;
    std::vector<SgAsmCilEventMap*>& get_elements();
public:
    using CilMetadataType = SgAsmCilEventMap;
public:
    /** Destructor. */
    virtual ~SgAsmCilEventMapTable();

public:
    /** Default constructor. */
    SgAsmCilEventMapTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventMapTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilEventMap);
IS_SERIALIZABLE(AsmCilEventMap);

#ifndef DOCUMENTATION
AsmCilEventMap.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL EventMap node (II.22.12). */
class SgAsmCilEventMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEventMap.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEventMap.setDataPrototype(
        "uint32_t", "EventList", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilEventMap);
#if defined(SgAsmCilEventMap_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilEventMap -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilEventMap");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_EventList);
        debugSerializationEnd("SgAsmCilEventMap");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Parent.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: EventList.
     *
     *  An index into the Event table. 
     *  
     *  @{ */
    uint32_t const& get_EventList() const;
    void set_EventList(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_EventList_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilEventMap();

public:
    /** Default constructor. */
    SgAsmCilEventMap();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventMap_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEvent           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilEvent);
IS_SERIALIZABLE(AsmCilEvent);

#ifndef DOCUMENTATION
AsmCilEvent.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Event node (II.22.13). */
class SgAsmCilEvent: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEvent.setDataPrototype(
        "uint16_t", "EventFlags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEvent.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilEvent.setDataPrototype(
        "uint32_t", "EventType", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilEvent);
#if defined(SgAsmCilEvent_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilEvent -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilEvent");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_EventFlags);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_EventType);
        debugSerializationEnd("SgAsmCilEvent");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: EventFlags.
     *
     *  A 2-byte bitmask of type EventAttribute. 
     *  
     *  @{ */
    uint16_t const& get_EventFlags() const;
    void set_EventFlags(uint16_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: EventType.
     *
     *  An index into a TypeDef, a TypeRef, or TypeSpec table. 
     *  
     *  @{ */
    uint32_t const& get_EventType() const;
    void set_EventType(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_Name_string() const;
    const SgAsmCilMetadata* get_EventType_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilEvent();

public:
    /** Default constructor. */
    SgAsmCilEvent();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEvent_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDeclSecurityTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilDeclSecurityTable);
IS_SERIALIZABLE(AsmCilDeclSecurityTable);

#ifndef DOCUMENTATION
AsmCilDeclSecurityTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL DeclSecurity tables. */
class SgAsmCilDeclSecurityTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDeclSecurityTable.setDataPrototype(
        "std::vector<SgAsmCilDeclSecurity*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilDeclSecurityTable);
#if defined(SgAsmCilDeclSecurityTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilDeclSecurityTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilDeclSecurityTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilDeclSecurityTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilDeclSecurity*> const& get_elements() const;
    std::vector<SgAsmCilDeclSecurity*>& get_elements();
public:
    using CilMetadataType = SgAsmCilDeclSecurity;
public:
    /** Destructor. */
    virtual ~SgAsmCilDeclSecurityTable();

public:
    /** Default constructor. */
    SgAsmCilDeclSecurityTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDeclSecurityTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDeclSecurity           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilDeclSecurity);
IS_SERIALIZABLE(AsmCilDeclSecurity);

#ifndef DOCUMENTATION
AsmCilDeclSecurity.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL DeclSecurity node (II.22.11). */
class SgAsmCilDeclSecurity: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDeclSecurity.setDataPrototype(
        "uint16_t", "Action", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDeclSecurity.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDeclSecurity.setDataPrototype(
        "uint32_t", "PermissionSet", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilDeclSecurity);
#if defined(SgAsmCilDeclSecurity_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilDeclSecurity -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilDeclSecurity");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Action);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_PermissionSet);
        debugSerializationEnd("SgAsmCilDeclSecurity");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Action.
     *
     *  A 2-byte value. 
     *  
     *  @{ */
    uint16_t const& get_Action() const;
    void set_Action(uint16_t const&);
    /** @} */

public:
    /** Property: Parent.
     *
     *  An index into the TypeDef, MethodDef, or Assembly table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: PermissionSet.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_PermissionSet() const;
    void set_PermissionSet(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_PermissionSet_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilDeclSecurity();

public:
    /** Default constructor. */
    SgAsmCilDeclSecurity();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDeclSecurity_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDataStream           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmCilDataStream = nonTerminalConstructor(
    "AsmCilDataStream",
    *this,
    "AsmCilDataStream",
    "AsmCilDataStreamTag",
    SubclassListBuilder()
        | AsmCilMetadataHeap
        | AsmCilUint32Heap
        | AsmCilUint8Heap
    , false);
assert(AsmCilDataStream.associatedGrammar != nullptr);
AsmCilDataStream.setCppCondition("!defined(DOCUMENTATION)");
AsmCilDataStream.isBoostSerializable(true);
AsmCilDataStream.setAutomaticGenerationOfConstructor(false);
AsmCilDataStream.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmCilDataStream.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for CIL branch of binary analysis IR nodes. */
class SgAsmCilDataStream: public SgAsmCilNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "Offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "Size", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDataStream.setDataPrototype(
        "std::string", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "NamePadding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilDataStream);
#if defined(SgAsmCilDataStream_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilDataStream -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilDataStream");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        s & BOOST_SERIALIZATION_NVP(p_Offset);
        s & BOOST_SERIALIZATION_NVP(p_Size);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_NamePadding);
        debugSerializationEnd("SgAsmCilDataStream");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Start offset of the byte stream. 
     * 
     * @{ */
    uint32_t const& get_Offset() const;
    void set_Offset(uint32_t const&);
    /** @} */

public:
    /** Property: Length of the byte stream. 
     * 
     * @{ */
    uint32_t const& get_Size() const;
    void set_Size(uint32_t const&);
    /** @} */

public:
    /** Property: Name of the byte stream. 
     * 
     * @{ */
    std::string const& get_Name() const;
    void set_Name(std::string const&);
    /** @} */

public:
    /** Property: Name of the byte stream. 
     * 
     * @{ */
    uint32_t const& get_NamePadding() const;
    void set_NamePadding(uint32_t const&);
    /** @} */
public:
    /** Define constant strings for the known stream types.
     *
     *  @{ */
    static const std::string ID_STRING_HEAP;
    static const std::string ID_BLOB_HEAP;
    static const std::string ID_US_HEAP;
    static const std::string ID_GUID_HEAP;
    static const std::string ID_METADATA_HEAP;
    /** }@ */

    /** Defines the parse function.
     *
     * @param buf the binary buffer.
     * @param startOfMetaData the location in buf where the metadata root (CIL ECMA II.24.2.1)
     *        is located.
     * @details
     *   buf[startOfMetaData] is the location of the metadata root magic number.
     *   parse will add get_Offset to startOfMetaData to find the first byte of a
     *   stream. */
    virtual void parse(const std::vector<uint8_t>& buf, size_t startOfMetaData); /* FIXME: should be abstract */

    /** Unparses the metadata objects into the buffer */
    virtual void unparse(std::vector<uint8_t>& buf, size_t startOfMetaData) const; /* FIXME: should be abstract */

    /** Prints the object's data in a human readable form. */
    virtual void dump(std::ostream& os) const; /* FIXME: should be abstract */
public:
    /** Destructor. */
    virtual ~SgAsmCilDataStream();

protected:
    /** Default constructor. */
    SgAsmCilDataStream();

protected:
    /** Constructor. */
    SgAsmCilDataStream(uint32_t const& Offset,
                       uint32_t const& Size,
                       std::string const& Name,
                       uint32_t const& NamePadding);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDataStream_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilCustomAttributeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilCustomAttributeTable);
IS_SERIALIZABLE(AsmCilCustomAttributeTable);

#ifndef DOCUMENTATION
AsmCilCustomAttributeTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL CustomAttribute tables. */
class SgAsmCilCustomAttributeTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilCustomAttributeTable.setDataPrototype(
        "std::vector<SgAsmCilCustomAttribute*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilCustomAttributeTable);
#if defined(SgAsmCilCustomAttributeTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilCustomAttributeTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilCustomAttributeTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilCustomAttributeTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilCustomAttribute*> const& get_elements() const;
    std::vector<SgAsmCilCustomAttribute*>& get_elements();
public:
    using CilMetadataType = SgAsmCilCustomAttribute;
public:
    /** Destructor. */
    virtual ~SgAsmCilCustomAttributeTable();

public:
    /** Default constructor. */
    SgAsmCilCustomAttributeTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilCustomAttributeTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilCustomAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilCustomAttribute);
IS_SERIALIZABLE(AsmCilCustomAttribute);

#ifndef DOCUMENTATION
AsmCilCustomAttribute.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL CustomAttribute node (II.22.10). */
class SgAsmCilCustomAttribute: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilCustomAttribute);
#if defined(SgAsmCilCustomAttribute_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilCustomAttribute -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilCustomAttribute");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_Type);
        s & BOOST_SERIALIZATION_NVP(p_Value);
        debugSerializationEnd("SgAsmCilCustomAttribute");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Parent.
     *
     *  An index into a metadata table that has an associated HasCustomAttribute index. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: Type.
     *
     *  An index into the MethodDef or MemberRef table (more precisely, a CustomAttributeType coded index). 
     *  
     *  @{ */
    uint32_t const& get_Type() const;
    void set_Type(uint32_t const&);
    /** @} */

public:
    /** Property: Value.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Value() const;
    void set_Value(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_Type_object() const;
    const std::uint8_t* get_Value_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilCustomAttribute();

public:
    /** Default constructor. */
    SgAsmCilCustomAttribute();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilCustomAttribute_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilConstantTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilConstantTable);
IS_SERIALIZABLE(AsmCilConstantTable);

#ifndef DOCUMENTATION
AsmCilConstantTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Constant tables. */
class SgAsmCilConstantTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilConstantTable.setDataPrototype(
        "std::vector<SgAsmCilConstant*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilConstantTable);
#if defined(SgAsmCilConstantTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilConstantTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilConstantTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilConstantTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilConstant*> const& get_elements() const;
    std::vector<SgAsmCilConstant*>& get_elements();
public:
    using CilMetadataType = SgAsmCilConstant;
public:
    /** Destructor. */
    virtual ~SgAsmCilConstantTable();

public:
    /** Default constructor. */
    SgAsmCilConstantTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilConstantTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilConstant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilConstant);
IS_SERIALIZABLE(AsmCilConstant);

#ifndef DOCUMENTATION
AsmCilConstant.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Constant node (II.22.9). */
class SgAsmCilConstant: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilConstant.setDataPrototype(
        "uint8_t", "Type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilConstant.setDataPrototype(
        "uint8_t", "Padding", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilConstant.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilConstant.setDataPrototype(
        "uint32_t", "Value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilConstant);
#if defined(SgAsmCilConstant_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilConstant -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilConstant");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Type);
        s & BOOST_SERIALIZATION_NVP(p_Padding);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        s & BOOST_SERIALIZATION_NVP(p_Value);
        debugSerializationEnd("SgAsmCilConstant");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Type.
     *
     *  A 1-byte constant. 
     *  
     *  @{ */
    uint8_t const& get_Type() const;
    void set_Type(uint8_t const&);
    /** @} */

public:
    /** Property: Padding.
     *
     *  A 1-byte zero padding. 
     *  
     *  @{ */
    uint8_t const& get_Padding() const;
    void set_Padding(uint8_t const&);
    /** @} */

public:
    /** Property: Parent.
     *
     *  An index into the Param, Field, or Property table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */

public:
    /** Property: Value.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_Value() const;
    void set_Value(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_Value_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilConstant();

public:
    /** Default constructor. */
    SgAsmCilConstant();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilConstant_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilClassLayoutTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilClassLayoutTable);
IS_SERIALIZABLE(AsmCilClassLayoutTable);

#ifndef DOCUMENTATION
AsmCilClassLayoutTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ClassLayout tables. */
class SgAsmCilClassLayoutTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilClassLayoutTable.setDataPrototype(
        "std::vector<SgAsmCilClassLayout*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilClassLayoutTable);
#if defined(SgAsmCilClassLayoutTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilClassLayoutTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilClassLayoutTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilClassLayoutTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilClassLayout*> const& get_elements() const;
    std::vector<SgAsmCilClassLayout*>& get_elements();
public:
    using CilMetadataType = SgAsmCilClassLayout;
public:
    /** Destructor. */
    virtual ~SgAsmCilClassLayoutTable();

public:
    /** Default constructor. */
    SgAsmCilClassLayoutTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilClassLayoutTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilClassLayout           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilClassLayout);
IS_SERIALIZABLE(AsmCilClassLayout);

#ifndef DOCUMENTATION
AsmCilClassLayout.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL ClassLayout node (II.22.8). */
class SgAsmCilClassLayout: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilClassLayout.setDataPrototype(
        "uint16_t", "PackingSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilClassLayout.setDataPrototype(
        "uint32_t", "ClassSize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilClassLayout.setDataPrototype(
        "uint32_t", "Parent", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilClassLayout);
#if defined(SgAsmCilClassLayout_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilClassLayout -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilClassLayout");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_PackingSize);
        s & BOOST_SERIALIZATION_NVP(p_ClassSize);
        s & BOOST_SERIALIZATION_NVP(p_Parent);
        debugSerializationEnd("SgAsmCilClassLayout");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: PackingSize.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_PackingSize() const;
    void set_PackingSize(uint16_t const&);
    /** @} */

public:
    /** Property: ClassSize.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_ClassSize() const;
    void set_ClassSize(uint32_t const&);
    /** @} */

public:
    /** Property: Parent.
     *
     *  An index into the TypeDef table. 
     *  
     *  @{ */
    uint32_t const& get_Parent() const;
    void set_Parent(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_Parent_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilClassLayout();

public:
    /** Default constructor. */
    SgAsmCilClassLayout();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilClassLayout_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyTable);
IS_SERIALIZABLE(AsmCilAssemblyTable);

#ifndef DOCUMENTATION
AsmCilAssemblyTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Assembly tables. */
class SgAsmCilAssemblyTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyTable.setDataPrototype(
        "std::vector<SgAsmCilAssembly*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyTable);
#if defined(SgAsmCilAssemblyTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssembly*> const& get_elements() const;
    std::vector<SgAsmCilAssembly*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssembly;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRefTable);
IS_SERIALIZABLE(AsmCilAssemblyRefTable);

#ifndef DOCUMENTATION
AsmCilAssemblyRefTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRef tables. */
class SgAsmCilAssemblyRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRefTable);
#if defined(SgAsmCilAssemblyRefTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRefTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRefTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyRefTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssemblyRef*> const& get_elements() const;
    std::vector<SgAsmCilAssemblyRef*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssemblyRef;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRefTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefProcessorTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRefProcessorTable);
IS_SERIALIZABLE(AsmCilAssemblyRefProcessorTable);

#ifndef DOCUMENTATION
AsmCilAssemblyRefProcessorTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRefProcessor tables. */
class SgAsmCilAssemblyRefProcessorTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefProcessorTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRefProcessor*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRefProcessorTable);
#if defined(SgAsmCilAssemblyRefProcessorTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRefProcessorTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRefProcessorTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyRefProcessorTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssemblyRefProcessor*> const& get_elements() const;
    std::vector<SgAsmCilAssemblyRefProcessor*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssemblyRefProcessor;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefProcessorTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRefProcessorTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefProcessorTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefProcessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRefProcessor);
IS_SERIALIZABLE(AsmCilAssemblyRefProcessor);

#ifndef DOCUMENTATION
AsmCilAssemblyRefProcessor.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRefProcessor node (II.22.7). */
class SgAsmCilAssemblyRefProcessor: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefProcessor.setDataPrototype(
        "uint32_t", "Processor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefProcessor.setDataPrototype(
        "uint32_t", "AssemblyRef", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRefProcessor);
#if defined(SgAsmCilAssemblyRefProcessor_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRefProcessor -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRefProcessor");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Processor);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRef);
        debugSerializationEnd("SgAsmCilAssemblyRefProcessor");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Processor.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_Processor() const;
    void set_Processor(uint32_t const&);
    /** @} */

public:
    /** Property: AssemblyRef.
     *
     *  An index into the AssemblyRef table. 
     *  
     *  @{ */
    uint32_t const& get_AssemblyRef() const;
    void set_AssemblyRef(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_AssemblyRef_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefProcessor();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRefProcessor();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefProcessor_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefOSTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRefOSTable);
IS_SERIALIZABLE(AsmCilAssemblyRefOSTable);

#ifndef DOCUMENTATION
AsmCilAssemblyRefOSTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRefOS tables. */
class SgAsmCilAssemblyRefOSTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefOSTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRefOS*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRefOSTable);
#if defined(SgAsmCilAssemblyRefOSTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRefOSTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRefOSTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyRefOSTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssemblyRefOS*> const& get_elements() const;
    std::vector<SgAsmCilAssemblyRefOS*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssemblyRefOS;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefOSTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRefOSTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefOSTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefOS           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRefOS);
IS_SERIALIZABLE(AsmCilAssemblyRefOS);

#ifndef DOCUMENTATION
AsmCilAssemblyRefOS.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRefOS node (II.22.6). */
class SgAsmCilAssemblyRefOS: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSPlatformID", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSMajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSMinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "AssemblyRefOS", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRefOS);
#if defined(SgAsmCilAssemblyRefOS_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRefOS -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRefOS");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_OSPlatformID);
        s & BOOST_SERIALIZATION_NVP(p_OSMajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_OSMinorVersion);
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefOS);
        debugSerializationEnd("SgAsmCilAssemblyRefOS");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: OSPlatformID.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSPlatformID() const;
    void set_OSPlatformID(uint32_t const&);
    /** @} */

public:
    /** Property: OSMajorVersion.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSMajorVersion() const;
    void set_OSMajorVersion(uint32_t const&);
    /** @} */

public:
    /** Property: OSMinorVersion.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSMinorVersion() const;
    void set_OSMinorVersion(uint32_t const&);
    /** @} */

public:
    /** Property: AssemblyRefOS.
     *
     *  An index into the AssemblyRef table. 
     *  
     *  @{ */
    uint32_t const& get_AssemblyRefOS() const;
    void set_AssemblyRefOS(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const SgAsmCilMetadata* get_AssemblyRefOS_object() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefOS();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRefOS();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefOS_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyRef);
IS_SERIALIZABLE(AsmCilAssemblyRef);

#ifndef DOCUMENTATION
AsmCilAssemblyRef.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyRef node (II.22.5). */
class SgAsmCilAssemblyRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "MajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "MinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "BuildNumber", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "RevisionNumber", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "PublicKeyOrToken", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Culture", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "HashValue", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyRef);
#if defined(SgAsmCilAssemblyRef_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyRef -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyRef");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
        s & BOOST_SERIALIZATION_NVP(p_BuildNumber);
        s & BOOST_SERIALIZATION_NVP(p_RevisionNumber);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_PublicKeyOrToken);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Culture);
        s & BOOST_SERIALIZATION_NVP(p_HashValue);
        debugSerializationEnd("SgAsmCilAssemblyRef");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: MajorVersion.
     *
     *  Major version number. 
     *  
     *  @{ */
    uint16_t const& get_MajorVersion() const;
    void set_MajorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: MinorVersion.
     *
     *  Minor version number. 
     *  
     *  @{ */
    uint16_t const& get_MinorVersion() const;
    void set_MinorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: BuildNumber.
     *
     *  Build number. 
     *  
     *  @{ */
    uint16_t const& get_BuildNumber() const;
    void set_BuildNumber(uint16_t const&);
    /** @} */

public:
    /** Property: RevisionNumber.
     *
     *  Revision number. 
     *  
     *  @{ */
    uint16_t const& get_RevisionNumber() const;
    void set_RevisionNumber(uint16_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  Shall have only one bit set, the PublicKey bit. 
     *  
     *  @{ */
    uint32_t const& get_Flags() const;
    void set_Flags(uint32_t const&);
    /** @} */

public:
    /** Property: PublicKeyOrToken.
     *
     *  An index into the Blob heap, can be null, or non-null. 
     *  
     *  @{ */
    uint32_t const& get_PublicKeyOrToken() const;
    void set_PublicKeyOrToken(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Culture.
     *
     *  An index into the String heap, null or non-null. 
     *  
     *  @{ */
    uint32_t const& get_Culture() const;
    void set_Culture(uint32_t const&);
    /** @} */

public:
    /** Property: HashValue.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_HashValue() const;
    void set_HashValue(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_PublicKeyOrToken_blob() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Culture_string() const;
    const std::uint8_t* get_HashValue_blob() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRef();

public:
    /** Default constructor. */
    SgAsmCilAssemblyRef();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRef_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyProcessorTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyProcessorTable);
IS_SERIALIZABLE(AsmCilAssemblyProcessorTable);

#ifndef DOCUMENTATION
AsmCilAssemblyProcessorTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyProcessor tables. */
class SgAsmCilAssemblyProcessorTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyProcessorTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyProcessor*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyProcessorTable);
#if defined(SgAsmCilAssemblyProcessorTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyProcessorTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyProcessorTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyProcessorTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssemblyProcessor*> const& get_elements() const;
    std::vector<SgAsmCilAssemblyProcessor*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssemblyProcessor;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyProcessorTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyProcessorTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyProcessorTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyProcessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyProcessor);
IS_SERIALIZABLE(AsmCilAssemblyProcessor);

#ifndef DOCUMENTATION
AsmCilAssemblyProcessor.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyProcessor node (II.22.4). */
class SgAsmCilAssemblyProcessor: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyProcessor.setDataPrototype(
        "uint32_t", "Processor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyProcessor);
#if defined(SgAsmCilAssemblyProcessor_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyProcessor -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyProcessor");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_Processor);
        debugSerializationEnd("SgAsmCilAssemblyProcessor");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: Processor.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_Processor() const;
    void set_Processor(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyProcessor();

public:
    /** Default constructor. */
    SgAsmCilAssemblyProcessor();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyProcessor_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyOSTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyOSTable);
IS_SERIALIZABLE(AsmCilAssemblyOSTable);

#ifndef DOCUMENTATION
AsmCilAssemblyOSTable.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyOS tables. */
class SgAsmCilAssemblyOSTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyOSTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyOS*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyOSTable);
#if defined(SgAsmCilAssemblyOSTable_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyOSTable -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyOSTable");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_elements);
        debugSerializationEnd("SgAsmCilAssemblyOSTable");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    std::vector<SgAsmCilAssemblyOS*> const& get_elements() const;
    std::vector<SgAsmCilAssemblyOS*>& get_elements();
public:
    using CilMetadataType = SgAsmCilAssemblyOS;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyOSTable();

public:
    /** Default constructor. */
    SgAsmCilAssemblyOSTable();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyOSTable_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyOS           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssemblyOS);
IS_SERIALIZABLE(AsmCilAssemblyOS);

#ifndef DOCUMENTATION
AsmCilAssemblyOS.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL AssemblyOS node (II.22.3). */
class SgAsmCilAssemblyOS: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSPlatformID", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSMajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSMinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssemblyOS);
#if defined(SgAsmCilAssemblyOS_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssemblyOS -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssemblyOS");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_OSPlatformID);
        s & BOOST_SERIALIZATION_NVP(p_OSMajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_OSMinorVersion);
        debugSerializationEnd("SgAsmCilAssemblyOS");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: OSPlatformID.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSPlatformID() const;
    void set_OSPlatformID(uint32_t const&);
    /** @} */

public:
    /** Property: OSMajorVersion.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSMajorVersion() const;
    void set_OSMajorVersion(uint32_t const&);
    /** @} */

public:
    /** Property: OSMinorVersion.
     *
     *  A 4-byte constant. 
     *  
     *  @{ */
    uint32_t const& get_OSMinorVersion() const;
    void set_OSMinorVersion(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyOS();

public:
    /** Default constructor. */
    SgAsmCilAssemblyOS();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyOS_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssembly           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmCilAssembly);
IS_SERIALIZABLE(AsmCilAssembly);

#ifndef DOCUMENTATION
AsmCilAssembly.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** CIL Assembly node (II.22.2). */
class SgAsmCilAssembly: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "HashAlgId", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "MajorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "MinorVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "BuildNumber", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "RevisionNumber", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "PublicKey", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Culture", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmCilAssembly);
#if defined(SgAsmCilAssembly_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilAssembly -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilAssembly");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
        s & BOOST_SERIALIZATION_NVP(p_HashAlgId);
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
        s & BOOST_SERIALIZATION_NVP(p_BuildNumber);
        s & BOOST_SERIALIZATION_NVP(p_RevisionNumber);
        s & BOOST_SERIALIZATION_NVP(p_Flags);
        s & BOOST_SERIALIZATION_NVP(p_PublicKey);
        s & BOOST_SERIALIZATION_NVP(p_Name);
        s & BOOST_SERIALIZATION_NVP(p_Culture);
        debugSerializationEnd("SgAsmCilAssembly");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Property: HashAlgId.
     *
     *  A 4-byte constant of type AssemblyHashAlgorithm. 
     *  
     *  @{ */
    uint32_t const& get_HashAlgId() const;
    void set_HashAlgId(uint32_t const&);
    /** @} */

public:
    /** Property: MajorVersion.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_MajorVersion() const;
    void set_MajorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: MinorVersion.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_MinorVersion() const;
    void set_MinorVersion(uint16_t const&);
    /** @} */

public:
    /** Property: BuildNumber.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_BuildNumber() const;
    void set_BuildNumber(uint16_t const&);
    /** @} */

public:
    /** Property: RevisionNumber.
     *
     *  A 2-byte constant. 
     *  
     *  @{ */
    uint16_t const& get_RevisionNumber() const;
    void set_RevisionNumber(uint16_t const&);
    /** @} */

public:
    /** Property: Flags.
     *
     *  A 4-byte bitmask of type AssemblyFlags. 
     *  
     *  @{ */
    uint32_t const& get_Flags() const;
    void set_Flags(uint32_t const&);
    /** @} */

public:
    /** Property: PublicKey.
     *
     *  An index into the Blob heap. 
     *  
     *  @{ */
    uint32_t const& get_PublicKey() const;
    void set_PublicKey(uint32_t const&);
    /** @} */

public:
    /** Property: Name.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Name() const;
    void set_Name(uint32_t const&);
    /** @} */

public:
    /** Property: Culture.
     *
     *  An index into the String heap. 
     *  
     *  @{ */
    uint32_t const& get_Culture() const;
    void set_Culture(uint32_t const&);
    /** @} */
public:
    void parse(const std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
    void unparse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing) const;
    void dump(std::ostream&) const;

    const std::uint8_t* get_PublicKey_blob() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Culture_string() const;
public:
    /** Destructor. */
    virtual ~SgAsmCilAssembly();

public:
    /** Default constructor. */
    SgAsmCilAssembly();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssembly_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadata           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmCilMetadata = nonTerminalConstructor(
    "AsmCilMetadata",
    *this,
    "AsmCilMetadata",
    "AsmCilMetadataTag",
    SubclassListBuilder()
        | AsmCilAssembly
        | AsmCilAssemblyOS
        | AsmCilAssemblyOSTable
        | AsmCilAssemblyProcessor
        | AsmCilAssemblyProcessorTable
        | AsmCilAssemblyRef
        | AsmCilAssemblyRefOS
        | AsmCilAssemblyRefOSTable
        | AsmCilAssemblyRefProcessor
        | AsmCilAssemblyRefProcessorTable
        | AsmCilAssemblyRefTable
        | AsmCilAssemblyTable
        | AsmCilClassLayout
        | AsmCilClassLayoutTable
        | AsmCilConstant
        | AsmCilConstantTable
        | AsmCilCustomAttribute
        | AsmCilCustomAttributeTable
        | AsmCilDeclSecurity
        | AsmCilDeclSecurityTable
        | AsmCilEvent
        | AsmCilEventMap
        | AsmCilEventMapTable
        | AsmCilEventTable
        | AsmCilExportedType
        | AsmCilExportedTypeTable
        | AsmCilField
        | AsmCilFieldLayout
        | AsmCilFieldLayoutTable
        | AsmCilFieldMarshal
        | AsmCilFieldMarshalTable
        | AsmCilFieldRVA
        | AsmCilFieldRVATable
        | AsmCilFieldTable
        | AsmCilFile
        | AsmCilFileTable
        | AsmCilGenericParamConstraint
        | AsmCilGenericParamConstraintTable
        | AsmCilGenericParam
        | AsmCilGenericParamTable
        | AsmCilImplMap
        | AsmCilImplMapTable
        | AsmCilInterfaceImpl
        | AsmCilInterfaceImplTable
        | AsmCilManifestResource
        | AsmCilManifestResourceTable
        | AsmCilMemberRef
        | AsmCilMemberRefTable
        | AsmCilMethodDef
        | AsmCilMethodDefTable
        | AsmCilMethodImpl
        | AsmCilMethodImplTable
        | AsmCilMethodSemantics
        | AsmCilMethodSemanticsTable
        | AsmCilMethodSpec
        | AsmCilMethodSpecTable
        | AsmCilModule
        | AsmCilModuleRef
        | AsmCilModuleRefTable
        | AsmCilModuleTable
        | AsmCilNestedClass
        | AsmCilNestedClassTable
        | AsmCilParam
        | AsmCilParamTable
        | AsmCilProperty
        | AsmCilPropertyMap
        | AsmCilPropertyMapTable
        | AsmCilPropertyTable
        | AsmCilStandAloneSig
        | AsmCilStandAloneSigTable
        | AsmCilTypeDef
        | AsmCilTypeDefTable
        | AsmCilTypeRef
        | AsmCilTypeRefTable
        | AsmCilTypeSpec
        | AsmCilTypeSpecTable
    , false);
assert(AsmCilMetadata.associatedGrammar != nullptr);
AsmCilMetadata.setCppCondition("!defined(DOCUMENTATION)");
AsmCilMetadata.isBoostSerializable(true);
AsmCilMetadata.setAutomaticGenerationOfConstructor(false);
AsmCilMetadata.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmCilMetadata.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for CIL branch of binary analysis IR nodes. */
class SgAsmCilMetadata: public SgAsmCilNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmCilMetadata);
#if defined(SgAsmCilMetadata_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilMetadata -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilMetadata");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        debugSerializationEnd("SgAsmCilMetadata");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmCilMetadata();

protected:
    /** Default constructor. */
    SgAsmCilMetadata();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadata_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmCilNode = nonTerminalConstructor(
    "AsmCilNode",
    *this,
    "AsmCilNode",
    "AsmCilNodeTag",
    SubclassListBuilder()
        | AsmCilDataStream
        | AsmCilExceptionData
        | AsmCilMetadata
        | AsmCilMetadataRoot
        | AsmCilMethodData
    , false);
assert(AsmCilNode.associatedGrammar != nullptr);
AsmCilNode.setCppCondition("!defined(DOCUMENTATION)");
AsmCilNode.isBoostSerializable(true);
AsmCilNode.setAutomaticGenerationOfConstructor(false);
AsmCilNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmCilNode.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for CIL branch of binary analysis IR nodes. */
class SgAsmCilNode: public SgAsmNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmCilNode);
#if defined(SgAsmCilNode_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmCilNode -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmCilNode");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        debugSerializationEnd("SgAsmCilNode");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmCilNode();

protected:
    /** Default constructor. */
    SgAsmCilNode();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNode_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmByteOrder           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmByteOrder);
IS_SERIALIZABLE(AsmByteOrder);

#ifndef DOCUMENTATION
AsmByteOrder.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmByteOrder);
#if defined(SgAsmByteOrder_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/ByteOrder.h>
#endif // SgAsmByteOrder_HEADERS

#ifdef DOCUMENTATION
/** Byte order specification. */
class SgAsmByteOrder: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmByteOrder);
#if defined(SgAsmByteOrder_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmByteOrder -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmByteOrder");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(byteOrder_);
        debugSerializationEnd("SgAsmByteOrder");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Rose::BinaryAnalysis::ByteOrder::Endianness byteOrder_;

public:
    /** Property: Byte order. 
     * 
     * @{ */
    Rose::BinaryAnalysis::ByteOrder::Endianness const& byteOrder() const;
    void byteOrder(Rose::BinaryAnalysis::ByteOrder::Endianness const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmByteOrder();

public:
    /** Default constructor. */
    SgAsmByteOrder();

public:
    /** Constructor. */
    explicit SgAsmByteOrder(Rose::BinaryAnalysis::ByteOrder::Endianness const& byteOrder);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmByteOrder_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBlock);
IS_SERIALIZABLE(AsmBlock);

#ifndef DOCUMENTATION
AsmBlock.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmBlock);
#if defined(SgAsmBlock_HEADERS) || defined(DOCUMENTATION)
#include <sageContainer.h>

#ifdef ROSE_SgAsmBlock_IMPL
#include <SgAsmInstruction.h>                           // for SgAsmInstruction::INVALID_STACK_DELTA
#endif
#endif // SgAsmBlock_HEADERS

#ifdef DOCUMENTATION
/** Instruction basic block.
 *
 *  A SgAsmBlock usually represents a sequence of instructions. It's also used for grouping other things such as
 *  functions. A SgAsmBlock represents a basic block if and only if it has at least one descendant of type @ref
 *  SgAsmInstruction and it has no descendants of type SgAsmBlock.
 *
 *  In the absence of interrupt handling, the instructions of a basic block are executed entirely.  In the absense of
 *  multi-threading, no other instructions intervene.
 *
 *  The instructions of a basic block need not be contiguous in virtual memory. They also do not need to be at increasing
 *  virtual addresses.
 *
 *  If the basic block has a parent pointer, then the closest @ref SgAsmFunction ancestor is the one to which this basic
 *  block belongs. In the @ref Rose::BinaryAnalysis::Partitioner2::Partitioner "Partitioner" API, a basic block can be
 *  owned by more than one function.
 *
 *  An AST may have multiple SgAsmBlock objects that represent the same basic block. This happens when a single block
 *  belongs to more than one function.
 *
 *  See also, @ref Rose::BinaryAnalysis::Partitioner2::BasicBlock, which represents a basic block outside the AST. */
class SgAsmBlock: public SgAsmStatement {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "rose_addr_t", "id", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "unsigned", "reason", "= SgAsmBlock::BLK_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "SgAsmStatementPtrList", "statementList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "SgAsmIntegerValuePtrList", "successors", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "bool", "successorsComplete", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "SgAsmBlock*", "immediateDominator", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "size_t", "cachedVertex", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "double", "codeLikelihood", "= 0.0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBlock.setDataPrototype(
        "int64_t", "stackDeltaOut", "= SgAsmInstruction::INVALID_STACK_DELTA",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmBlock);
#if defined(SgAsmBlock_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBlock -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBlock");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
        s & BOOST_SERIALIZATION_NVP(p_reason);
        s & BOOST_SERIALIZATION_NVP(p_statementList);
        s & BOOST_SERIALIZATION_NVP(p_successors);
        s & BOOST_SERIALIZATION_NVP(p_successorsComplete);
        s & BOOST_SERIALIZATION_NVP(p_immediateDominator);
        s & BOOST_SERIALIZATION_NVP(p_cachedVertex);
        s & BOOST_SERIALIZATION_NVP(p_codeLikelihood);
        s & BOOST_SERIALIZATION_NVP(p_stackDeltaOut);
        debugSerializationEnd("SgAsmBlock");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Reasons why a basic block might have been assigned to a function. */
    enum Reason {
        // Please update SgAsmBlock::reasonString() if you change this enum!
        BLK_NONE        = 0x00000000,           /**< No particular reason.  Mostly just for initialization. */
        BLK_ENTRY_POINT = 0x00010000,           /**< Block is an entry point for the function. */
        BLK_PADDING     = 0x00020000,           /**< Block is used for padding. */
        BLK_FRAGMENT    = 0x00080000,           /**< This block created because it seems to belong to the function although
                                                 *   CFG traversal did not find it. */
        BLK_CFGHEAD     = 0x00100000,           /**< Block serves as an explicit starting point for CFG analysis. */
        BLK_USERDEF     = 0x00200000,           /**< User says block belongs to the function. */
        BLK_LEFTOVERS   = 0x00400000,           /**< Block is being assigned to a FUNC_LEFTOVERS function because it could
                                                 *   not be assigned to any other function. */
        BLK_JUMPTABLE   = 0x00800000,           /**< Table of code addresses used by indirect branches. */
        BLK_GRAPH1      = 0x01000000,           /**< Block was added by the main CFG analysis. */
        BLK_GRAPH2      = 0x02000000,           /**< Block was added by a second pass of CFG analysis. */
        BLK_GRAPH3      = 0x04000000,           /**< Block was added by a third pass of CFG analysis. */

        BLK_DEFAULT     = BLK_NONE,             //NO_STRINGIFY

        // ========= Miscellaneous Reasons ===========================================================================
        // The first half of the range (1-127, inclusive) is used for algorithms defined by ROSE.  The second half is
        // availalble for users to use as they see fit.
        BLK_MISCMASK    = 0x000000ff,           /**< Miscellaneous reasons go here. We can store only one such reason at
                                                 *   a time. */
        BLK_FINDDATA    = 0x00000001,           /**< Added by Partitioner::FindData, which attaches unassigned parts of the
                                                 *   disassembly address space to the preceding function. */
        BLK_POSTFUNC    = 0x00000002            /**< Added by Partitioner::FindPostFunctionInsns, which adds unassigned
                                                 *   instructions to the immediately preceding function. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:

    // FIXME[Robb Matzke 2023-03-18]: is the lack of serialization a bug?
public:
    /** Property: Identification.
     *
     *  Block unique identification number. Not used by ROSE. 
     *  
     *  @{ */
    rose_addr_t const& get_id() const;
    void set_id(rose_addr_t const&);
    /** @} */

public:
    /** Property: Reasons this block was created.
     *
     *  This property holds a bit mask of @ref SgAsmBlock::Reason bits that indicate why this block was created. 
     *  
     *  @{ */
    unsigned const& get_reason() const;
    void set_reason(unsigned const&);
    /** @} */
    // statementList and successors should have been pointers to nodes that contain the list rather than being the lists
    // themselves because ROSETTA doesn't allow traversals on multiple list data members--we can traverse either one list or
    // the other, but not both.  It's too late to change how this part of the AST is structured because so much user code
    // already depends on it, therefore we can only traverse statementList and not successors. [Robb Matzke 2016-02-25]
public:
    /** Property: Statements of which this block is composed.
     *
     *  This is the list of "statements" that belong to this block. Statements are usually instructions, but historical
     *  code may have used basic blocks with other children. 
     *  
     *  @{ */
    SgAsmStatementPtrList const& get_statementList() const;
    SgAsmStatementPtrList& get_statementList();
    void set_statementList(SgAsmStatementPtrList const&);
    /** @} */
    // statementList and successors should have been pointers to nodes that contain the list rather than being the lists
    // themselves because ROSETTA doesn't allow traversals on multiple list data members--we can traverse either one list or
    // the other, but not both.  It's too late to change how this part of the AST is structured because so much user code
    // already depends on it, therefore we can only traverse statementList and not successors. [Robb Matzke 2016-02-25]
public:
    /** Property: Control flow successors.
     *
     *  This property holds the list of addresses which are control flow successors of this block.  The @ref
     *  Rose::BinaryAnalysis::Partitioner2 "Partitioner2" name space has a more useful definition of control flow graph
     *  that can reference indeterminate addresses and store data in the edges, and which is copiable. 
     *  
     *  @{ */
    SgAsmIntegerValuePtrList const& get_successors() const;
    SgAsmIntegerValuePtrList& get_successors();
    void set_successors(SgAsmIntegerValuePtrList const&);
    /** @} */

public:
    /** Property: Whether the successors list is complete.
     *
     *  This property is true if the "successors" property holds an incomplete list of successors. Since this
     *  representation of a control flow graph is unable to represent edges that point to indeterminate addresses (e.g.,
     *  computed branches), the "successors_complete" property can be used.
     *
     *  The @ref Rose::BinaryAnalysis::Partitioner2 "Partitioner2" name space has a more useful definition of control flow
     *  graph that can reference indeterminate addresses and store data in the edges, and which is copiable. 
     *  
     *  @{ */
    bool const& get_successorsComplete() const;
    void set_successorsComplete(bool const&);
    /** @} */

public:
    /** Property: Holds the immediate dominator block in the control flow graph.
     *
     *  The immediate dominator is the closest block to this one (by following reverse control flow edges) through which
     *  all control paths pass in order to get from the function entry block to this block.
     *
     *  The @ref Rose::BinaryAnalysis::Partitioner2 "Partitioner2" name space has a more useful definition of control flow
     *  graph that can reference indeterminate addresses and store data in the edges, and which is copiable. 
     *  
     *  @{ */
    SgAsmBlock* const& get_immediateDominator() const;
    void set_immediateDominator(SgAsmBlock* const&);
    /** @} */

public:
    /** Property: Cached vertex for control flow graphs.
     *
     *  This property is used by the virtual control flow graph mechanism.
     *
     *  The @ref Rose::BinaryAnalysis::Partitioner2 "Partitioner2" name space has a more useful definition of control flow
     *  graph that can reference indeterminate addresses and store data in the edges, and which is copiable. 
     *  
     *  @{ */
    size_t const& get_cachedVertex() const;
    void set_cachedVertex(size_t const&);
    /** @} */
 // see BinaryAnalysis::ControlFlow
public:
    /** Property: Likelihood that this block represents real instructions.
     *
     *  This property holds the results of an analysis that determines how likely it is that the memory from which this
     *  basic block was disassembled represents actual instructions that would be executed when the specimen runs. 
     *  
     *  @{ */
    double const& get_codeLikelihood() const;
    void set_codeLikelihood(double const&);
    /** @} */

public:
    /** Property: Stack pointer at block exit w.r.t. stack pointer at function entry.
     *
     *  This is the difference between the stack pointer after the last instruction of this block executes and the stack
     *  pointer when this block's function was entered.  It stores the result of a stack delta analysis. If stack delta
     *  analysis hasn't run, or was unable to determine a constant delta, then the special value @ref
     *  SgAsmInstruction::INVALID_STACK_DELTA is stored. 
     *  
     *  @{ */
    int64_t const& get_stackDeltaOut() const;
    void set_stackDeltaOut(int64_t const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Add the specified statement to the end of the statement list.
     *
     *  This is is usually used to add the next instruction to the end of a basic block. */
    void appendStatement(SgAsmStatement*);

    /** Erase the specified statement.
     *
     *  If the specified statement exists in the "statementList" property then it is erased but not deleted. */
    void removeStatement(SgAsmStatement*);

    // FIXME[Robb P Matzke 2017-02-13]: wrong name -- erases only statements, not all children
    /** Removes all statements from the block.
     *
     *  This makes the block empty, and not having a unique starting virtual address. It does not erase all children, just
     *  the statement children.  None of the statements that are erased are deleted. */
    void removeChildren();

    /** Fall-through virtual address.
     *
     *  A block's fall-through address is the virtual address that follows the last byte of the block's last instruction.
     *  The block must have instructions (e.g., it cannot be a strict data block). */
    rose_addr_t get_fallthroughVa();

    /** Returns the function that owns this block.
     *
     *  This is just a convenience wrapper around @ref SageInterface::getEnclosingNode. */
    SgAsmFunction *get_enclosingFunction() const;

    /** Determins if a block contains instructions.
     *
     *  Returns true if the block has instructions, false otherwise. We look only at the immediate descendants of this
     *  block.  See also, @ref SageInterface::querySubTree in order to get the list of all instructions or to consider all
     *  descendants. */
    bool hasInstructions() const;

    /** Determine if a block contains instructions.
     *
     *  Returns true if the block has instructions, false otherwise. We look only at the immediate descendants of this
     *  block.  See also, @ref SageInterface::querySubTree in order to get the list of all instructions or to consider all
     *  descendants. */
    bool isBasicBlock() const;

    /** Returns true if basic block appears to be a function call.
     *
     *  If the target address is known and is a single value then it is stored in the @p target_va argument, otherwise we
     *  store the maximum 64-bit address.  If the return address for the function call is known then it is stored in the @p
     *  return_va argument, otherwise @p return_va will contain the maximum 64-bit address. The return address is usually
     *  the fall-through address of the basic block.
     *
     * Note: Use this function in preference to SgAsmInstruction::isFunctionCallSlow() because the latter is intended to be
     * used by the Partitioner before an AST is created and might not be as accurate. */
    bool isFunctionCall(rose_addr_t &target_va/*out*/, rose_addr_t &return_va/*out*/);

    /** Multi-line string describing the letters used for basic block reasons.
     *
     *  The letters are returned by the padding version of @ref reasonString and appear in unparser output. */
    static std::string reasonKey(const std::string &prefix = "");

    /** Returns reason string for this block.
     *
     *  The reason string is a very short string describing the reason that the block was created. */
    std::string reasonString(bool pad) const;

    /** Converts a reason bit vector to a human-friendly string.
     *
     *  The second argument is the bit vector of @ref SgAsmBlock::Reason bits.  Some of the positions in the padded return
     *  value are used for more than one bit.  For instance, the first character can be "L" for leftovers, "N" for padding,
     *  "E" for entry point, or "-" for none of the above. */
    static std::string reasonString(bool pad, unsigned reason);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // [Robb Matzke 2023-11-06]: deprecated 2023-11
    bool get_successors_complete() const ROSE_DEPRECATED("use get_successorsComplete");
    void set_successors_complete(bool) ROSE_DEPRECATED("use get_successorsComplete");
    SgAsmBlock* get_immediate_dominator() const ROSE_DEPRECATED("use get_immediateDominator");
    void set_immediate_dominator(SgAsmBlock*) ROSE_DEPRECATED("use set_immediateDominator");
    size_t get_cached_vertex() const ROSE_DEPRECATED("use get_cachedVertex");
    void set_cached_vertex(size_t) ROSE_DEPRECATED("use set_cachedVertex");
    double get_code_likelihood() const ROSE_DEPRECATED("use get_codeLikelihood");
    void set_code_likelihood(double) ROSE_DEPRECATED("use set_codeLikelihood");
    void append_statement(SgAsmStatement*) ROSE_DEPRECATED("use appendStatement");
    void remove_statement(SgAsmStatement*) ROSE_DEPRECATED("use removeStatement");
    void remove_children() ROSE_DEPRECATED("use removeChildren");
    rose_addr_t get_fallthrough_va() ROSE_DEPRECATED("use getFallthroughVa");
    SgAsmFunction* get_enclosing_function() const ROSE_DEPRECATED("use get_enclosingFunction");
    bool has_instructions() const ROSE_DEPRECATED("use hasInstructions");
    bool is_basic_block() const ROSE_DEPRECATED("use isBasicBlock");
    bool is_function_call(rose_addr_t&, rose_addr_t&) ROSE_DEPRECATED("use isFunctionCall");
    static std::string reason_key(const std::string& = "") ROSE_DEPRECATED("use reasonKey");
    std::string reason_str(bool) const ROSE_DEPRECATED("use reasonString");
    static std::string reason_str(bool, unsigned) ROSE_DEPRECATED("use reasonString");
public:
    /** Destructor. */
    virtual ~SgAsmBlock();

public:
    /** Default constructor. */
    SgAsmBlock();

public:
    /** Constructor. */
    explicit SgAsmBlock(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBlock_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinarySubtract           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinarySubtract);
IS_SERIALIZABLE(AsmBinarySubtract);

#ifndef DOCUMENTATION
AsmBinarySubtract.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that subtracts the second operand from the first. */
class SgAsmBinarySubtract: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinarySubtract);
#if defined(SgAsmBinarySubtract_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinarySubtract -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinarySubtract");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinarySubtract");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinarySubtract();

public:
    /** Default constructor. */
    SgAsmBinarySubtract();

public:
    /** Constructor. */
    SgAsmBinarySubtract(SgAsmExpression* const& lhs,
                        SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinarySubtract_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryRor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryRor);
IS_SERIALIZABLE(AsmBinaryRor);

#ifndef DOCUMENTATION
AsmBinaryRor.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that performs a right rotate. */
class SgAsmBinaryRor: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryRor);
#if defined(SgAsmBinaryRor_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryRor -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryRor");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryRor");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryRor();

public:
    /** Default constructor. */
    SgAsmBinaryRor();

public:
    /** Constructor. */
    SgAsmBinaryRor(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryRor_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryPreupdate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryPreupdate);
IS_SERIALIZABLE(AsmBinaryPreupdate);

#ifndef DOCUMENTATION
AsmBinaryPreupdate.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that represents an update to a storage location.
 *
 *  The left-hand-side must be a register or memory location, and the right-hand-side is an expression that will be
 *  computed and stored at that location. Pre-updates happen before an instruction is evaluated. */
class SgAsmBinaryPreupdate: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryPreupdate);
#if defined(SgAsmBinaryPreupdate_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryPreupdate -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryPreupdate");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryPreupdate");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryPreupdate();

public:
    /** Default constructor. */
    SgAsmBinaryPreupdate();

public:
    /** Constructor. */
    SgAsmBinaryPreupdate(SgAsmExpression* const& lhs,
                         SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryPreupdate_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryPostupdate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryPostupdate);
IS_SERIALIZABLE(AsmBinaryPostupdate);

#ifndef DOCUMENTATION
AsmBinaryPostupdate.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that represents an update to a storage location.
 *
 *  The left-hand-side must be a register or memory location, and the right-hand-side is an expression that will be
 *  computed and stored at that location. Post-updates happen after an instruction is evaluated. */
class SgAsmBinaryPostupdate: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryPostupdate);
#if defined(SgAsmBinaryPostupdate_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryPostupdate -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryPostupdate");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryPostupdate");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryPostupdate();

public:
    /** Default constructor. */
    SgAsmBinaryPostupdate();

public:
    /** Constructor. */
    SgAsmBinaryPostupdate(SgAsmExpression* const& lhs,
                          SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryPostupdate_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMultiply           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryMultiply);
IS_SERIALIZABLE(AsmBinaryMultiply);

#ifndef DOCUMENTATION
AsmBinaryMultiply.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that multiplies two operands. */
class SgAsmBinaryMultiply: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryMultiply);
#if defined(SgAsmBinaryMultiply_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryMultiply -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryMultiply");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryMultiply");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryMultiply();

public:
    /** Default constructor. */
    SgAsmBinaryMultiply();

public:
    /** Constructor. */
    SgAsmBinaryMultiply(SgAsmExpression* const& lhs,
                        SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMultiply_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMsl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryMsl);
IS_SERIALIZABLE(AsmBinaryMsl);

#ifndef DOCUMENTATION
AsmBinaryMsl.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that performs a logical left shift operation filling low-order bits with one.
 *
 *  This is identical to the Lsl operation except instead of low-order bits being cleared they are set. */
class SgAsmBinaryMsl: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryMsl);
#if defined(SgAsmBinaryMsl_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryMsl -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryMsl");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryMsl");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryMsl();

public:
    /** Default constructor. */
    SgAsmBinaryMsl();

public:
    /** Constructor. */
    SgAsmBinaryMsl(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMsl_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryMod);
IS_SERIALIZABLE(AsmBinaryMod);

#ifndef DOCUMENTATION
AsmBinaryMod.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that returns the remainder when dividing the first operand by the second. */
class SgAsmBinaryMod: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryMod);
#if defined(SgAsmBinaryMod_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryMod -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryMod");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryMod");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryMod();

public:
    /** Default constructor. */
    SgAsmBinaryMod();

public:
    /** Constructor. */
    SgAsmBinaryMod(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMod_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryLsr           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryLsr);
IS_SERIALIZABLE(AsmBinaryLsr);

#ifndef DOCUMENTATION
AsmBinaryLsr.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that performs a logical, sign-bit non-preserving right shift. */
class SgAsmBinaryLsr: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryLsr);
#if defined(SgAsmBinaryLsr_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryLsr -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryLsr");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryLsr");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryLsr();

public:
    /** Default constructor. */
    SgAsmBinaryLsr();

public:
    /** Constructor. */
    SgAsmBinaryLsr(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryLsr_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryLsl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryLsl);
IS_SERIALIZABLE(AsmBinaryLsl);

#ifndef DOCUMENTATION
AsmBinaryLsl.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that performs a logical left shift operation. */
class SgAsmBinaryLsl: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryLsl);
#if defined(SgAsmBinaryLsl_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryLsl -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryLsl");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryLsl");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryLsl();

public:
    /** Default constructor. */
    SgAsmBinaryLsl();

public:
    /** Constructor. */
    SgAsmBinaryLsl(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryLsl_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryDivide           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryDivide);
IS_SERIALIZABLE(AsmBinaryDivide);

#ifndef DOCUMENTATION
AsmBinaryDivide.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that divides the first operand by the second. */
class SgAsmBinaryDivide: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryDivide);
#if defined(SgAsmBinaryDivide_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryDivide -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryDivide");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryDivide");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryDivide();

public:
    /** Default constructor. */
    SgAsmBinaryDivide();

public:
    /** Constructor. */
    SgAsmBinaryDivide(SgAsmExpression* const& lhs,
                      SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryDivide_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryConcat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryConcat);
IS_SERIALIZABLE(AsmBinaryConcat);

#ifndef DOCUMENTATION
AsmBinaryConcat.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that concatenates two values to form a wider value. */
class SgAsmBinaryConcat: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryConcat);
#if defined(SgAsmBinaryConcat_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryConcat -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryConcat");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryConcat");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryConcat();

public:
    /** Default constructor. */
    SgAsmBinaryConcat();

public:
    /** Constructor. */
    SgAsmBinaryConcat(SgAsmExpression* const& lhs,
                      SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryConcat_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryAsr           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryAsr);
IS_SERIALIZABLE(AsmBinaryAsr);

#ifndef DOCUMENTATION
AsmBinaryAsr.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that performs an arithmetic, sign-bit preserving right shift. */
class SgAsmBinaryAsr: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryAsr);
#if defined(SgAsmBinaryAsr_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryAsr -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryAsr");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryAsr");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryAsr();

public:
    /** Default constructor. */
    SgAsmBinaryAsr();

public:
    /** Constructor. */
    SgAsmBinaryAsr(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryAsr_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryAdd           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBinaryAdd);
IS_SERIALIZABLE(AsmBinaryAdd);

#ifndef DOCUMENTATION
AsmBinaryAdd.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Expression that adds two operands. */
class SgAsmBinaryAdd: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryAdd);
#if defined(SgAsmBinaryAdd_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryAdd -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryAdd");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
        debugSerializationEnd("SgAsmBinaryAdd");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

public:
    /** Destructor. */
    virtual ~SgAsmBinaryAdd();

public:
    /** Default constructor. */
    SgAsmBinaryAdd();

public:
    /** Constructor. */
    SgAsmBinaryAdd(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryAdd_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmBinaryExpression = nonTerminalConstructor(
    "AsmBinaryExpression",
    *this,
    "AsmBinaryExpression",
    "AsmBinaryExpressionTag",
    SubclassListBuilder()
        | AsmBinaryAdd
        | AsmBinaryAsr
        | AsmBinaryConcat
        | AsmBinaryDivide
        | AsmBinaryLsl
        | AsmBinaryLsr
        | AsmBinaryMod
        | AsmBinaryMsl
        | AsmBinaryMultiply
        | AsmBinaryPostupdate
        | AsmBinaryPreupdate
        | AsmBinaryRor
        | AsmBinarySubtract
    , false);
assert(AsmBinaryExpression.associatedGrammar != nullptr);
AsmBinaryExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmBinaryExpression.isBoostSerializable(true);
AsmBinaryExpression.setAutomaticGenerationOfConstructor(false);
AsmBinaryExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmBinaryExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for binary expressions. */
class SgAsmBinaryExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBinaryExpression.setDataPrototype(
        "SgAsmExpression*", "lhs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBinaryExpression.setDataPrototype(
        "SgAsmExpression*", "rhs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmBinaryExpression);
#if defined(SgAsmBinaryExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBinaryExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBinaryExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(p_lhs);
        s & BOOST_SERIALIZATION_NVP(p_rhs);
        debugSerializationEnd("SgAsmBinaryExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Left-hand side operand. 
     * 
     * @{ */
    SgAsmExpression* const& get_lhs() const;
    void set_lhs(SgAsmExpression* const&);
    /** @} */

public:
    /** Property: Right-hand side operand. 
     * 
     * @{ */
    SgAsmExpression* const& get_rhs() const;
    void set_rhs(SgAsmExpression* const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmBinaryExpression();

protected:
    /** Default constructor. */
    SgAsmBinaryExpression();

protected:
    /** Constructor. */
    SgAsmBinaryExpression(SgAsmExpression* const& lhs,
                          SgAsmExpression* const& rhs);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBasicString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmBasicString);
IS_SERIALIZABLE(AsmBasicString);

#ifndef DOCUMENTATION
AsmBasicString.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** String associated with a binary file.
 *
 *  Basic strings need not be stored in the binary specimen; they can be generated on the fly by the parser. See also, @ref
 *  SgAsmStoredString, which is present in the binary specimen. */
class SgAsmBasicString: public SgAsmGenericString {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmBasicString.setDataPrototype(
        "std::string", "string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmBasicString);
#if defined(SgAsmBasicString_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmBasicString -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmBasicString");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericString);
        s & BOOST_SERIALIZATION_NVP(p_string);
        debugSerializationEnd("SgAsmBasicString");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    virtual std::string get_string(bool escape=false) const override;
    virtual void set_string(const std::string&) override;
    virtual void set_string(rose_addr_t) override;

public:
    /** Constructor that gives a value to the object.
     *
     * @{ */
    explicit SgAsmBasicString(const std::string&);
    explicit SgAsmBasicString(const char*);
    /** @} */

    // Overrides documented in base class
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
public:
    /** Destructor. */
    virtual ~SgAsmBasicString();

public:
    /** Default constructor. */
    SgAsmBasicString();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBasicString_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmGenericString = nonTerminalConstructor(
    "AsmGenericString",
    *this,
    "AsmGenericString",
    "AsmGenericStringTag",
    SubclassListBuilder()
        | AsmBasicString
        | AsmStoredString
    , false);
assert(AsmGenericString.associatedGrammar != nullptr);
AsmGenericString.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericString.isBoostSerializable(true);
AsmGenericString.setAutomaticGenerationOfConstructor(false);
AsmGenericString.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmGenericString.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for strings related to binary specimens. */
class SgAsmGenericString: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmGenericString);
#if defined(SgAsmGenericString_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmGenericString -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmGenericString");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
        debugSerializationEnd("SgAsmGenericString");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
    /** Constant for addresses of unallocated strings. */
    static const rose_addr_t unallocated;

    /** Property: String value.
     *
     *  When retrieving the string, if @p escape is true then escape special charactes like the would be in C source code.
     *
     *  The base class implementation cannot be called and exists only due to ROSETTA limitations, otherwise we would have
     *  made them pure virtual.
     *
     * @{ */
    virtual std::string get_string(bool escape=false) const;
    virtual void set_string(const std::string &s);
    virtual void set_string(rose_addr_t);
    /** @} */

    virtual rose_addr_t get_offset() const {return unallocated;}

    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
public:
    /** Destructor. */
    virtual ~SgAsmGenericString();

protected:
    /** Default constructor. */
    SgAsmGenericString();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericString_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExecutableFileFormat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmExecutableFileFormat = nonTerminalConstructor(
    "AsmExecutableFileFormat",
    *this,
    "AsmExecutableFileFormat",
    "AsmExecutableFileFormatTag",
    SubclassListBuilder()
        | AsmCoffSymbolList
        | AsmDwarfInformation
        | AsmElfDynamicEntry
        | AsmElfDynamicEntryList
        | AsmElfEHFrameEntryCI
        | AsmElfEHFrameEntryCIList
        | AsmElfEHFrameEntryFD
        | AsmElfEHFrameEntryFDList
        | AsmElfNoteEntry
        | AsmElfNoteEntryList
        | AsmElfRelocEntry
        | AsmElfRelocEntryList
        | AsmElfSectionTableEntry
        | AsmElfSegmentTableEntry
        | AsmElfSegmentTableEntryList
        | AsmElfSymbolList
        | AsmElfSymverDefinedAux
        | AsmElfSymverDefinedAuxList
        | AsmElfSymverDefinedEntry
        | AsmElfSymverDefinedEntryList
        | AsmElfSymverEntry
        | AsmElfSymverEntryList
        | AsmElfSymverNeededAux
        | AsmElfSymverNeededAuxList
        | AsmElfSymverNeededEntry
        | AsmElfSymverNeededEntryList
        | AsmGenericDLL
        | AsmGenericDLLList
        | AsmGenericFile
        | AsmGenericFormat
        | AsmGenericHeaderList
        | AsmGenericSection
        | AsmGenericSectionList
        | AsmGenericString
        | AsmGenericStrtab
        | AsmGenericSymbol
        | AsmGenericSymbolList
        | AsmLEEntryPoint
        | AsmLEPageTableEntry
        | AsmLESectionTableEntry
        | AsmNEEntryPoint
        | AsmNERelocEntry
        | AsmNESectionTableEntry
        | AsmPEExportDirectory
        | AsmPEExportEntry
        | AsmPEExportEntryList
        | AsmPEImportDirectory
        | AsmPEImportDirectoryList
        | AsmPEImportItem
        | AsmPEImportItemList
        | AsmPERVASizePair
        | AsmPERVASizePairList
        | AsmPESectionTableEntry
        | AsmStringStorage
    , false);
assert(AsmExecutableFileFormat.associatedGrammar != nullptr);
AsmExecutableFileFormat.setCppCondition("!defined(DOCUMENTATION)");
AsmExecutableFileFormat.isBoostSerializable(true);
AsmExecutableFileFormat.setAutomaticGenerationOfConstructor(false);
AsmExecutableFileFormat.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmExecutableFileFormat.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmExecutableFileFormat);
#if defined(SgAsmExecutableFileFormat_HEADERS) || defined(DOCUMENTATION)
#include <Rose/Exception.h>
#endif // SgAsmExecutableFileFormat_HEADERS

#ifdef DOCUMENTATION
/** Base class for many binary analysis nodes. */
class SgAsmExecutableFileFormat: public SgAsmNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmExecutableFileFormat);
#if defined(SgAsmExecutableFileFormat_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmExecutableFileFormat -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmExecutableFileFormat");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        debugSerializationEnd("SgAsmExecutableFileFormat");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Exception for reading past the end of something.
     *
     *  This object is thrown when an attempt is made to read past the end of a file, section, header, segment, etc. */
    class ShortRead: public Rose::Exception {
    public:
        const SgAsmGenericSection *section;         /**< Section from which read occurred; null implies file-level write. */
        rose_addr_t offset;                         /**< Byte offset into section (or file). */
        rose_addr_t size;                           /**< Number of bytes of attempted read. */

        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size)
            : Rose::Exception("short read"), section(section), offset(offset), size(size) {}
        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ~ShortRead() throw () {}
    };

    /** Exception for writing past the end of something.
     *
     *  This object is thrown when an attempt is made to write past the end of a file, section, header, segment, etc. */
    class ShortWrite: public Rose::Exception {
    public:
        const SgAsmGenericSection *section;         /**< Section to which write occurred; null implies file-level write. */
        rose_addr_t          offset;                /**< Byte offset into section (or file). */
        rose_addr_t          size;                  /**< Number of bytes of attempted write. */

        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size)
            : Rose::Exception(""), section(section), offset(offset), size(size) {}
        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
    };

    /** Exception for container syntax errors.
     *
     *  This object is thrown when the file contains an error that prevents ROSE from parsing it. */
    class FormatError: public Rose::Exception {
    public:
        FormatError(const std::string &mesg)
            : Rose::Exception(mesg) {}
        FormatError(const char *mesg)
            : Rose::Exception(mesg) {}
        ~FormatError() throw () {}
    };

    /** Information about the file in the filesystem. */
    typedef struct stat fileDetails;

    /** Architecture family. */
    enum ExecFamily {
        FAMILY_UNSPECIFIED,                         /**< Unspecified family. */
        FAMILY_DOS,                                 /**< Microsoft DOS format. */
        FAMILY_ELF,                                 /**< Unix Executable and Linking Format. */
        FAMILY_JVM,                                 /**< Java Virtual Machine (JVM) format. */
        FAMILY_LE,                                  /**< Microsft Linear Executable format. */
        FAMILY_LX,                                  /**< OS/2 LX (Windows 9x VxD device drivers, extension of LE). */
        FAMILY_NE,                                  /**< Microsoft New Executable Format. */
        FAMILY_PE                                   /**< Microsoft Portable Executable Format. */
    };

    /** Application binary interface. */
    enum ExecABI {
        ABI_UNSPECIFIED,                            /**< Not specified in file and could not be inferred */
        ABI_OTHER,                                  /**< Anything other than values below */
        ABI_86OPEN,                                 /**< 86Open Common IA32 */
        ABI_AIX,                                    /**< AIX */
        ABI_ARM,                                    /**< ARM architecture */
        ABI_FREEBSD,                                /**< FreeBSD */
        ABI_HPUX,                                   /**< HP/UX */
        ABI_IRIX,                                   /**< IRIX */
        ABI_HURD,                                   /**< GNU/Hurd */
        ABI_JVM,                                    /**< Java Virtual Machine (JVM). */
        ABI_LINUX,                                  /**< GNU/Linux */
        ABI_MODESTO,                                /**< Novell Modesto */
        ABI_MONTEREY,                               /**< Monterey project */
        ABI_MSDOS,                                  /**< Microsoft DOS */
        ABI_NT,                                     /**< Windows NT */
        ABI_NETBSD,                                 /**< NetBSD */
        ABI_OS2,                                    /**< OS/2 */
        ABI_SOLARIS,                                /**< Sun Solaris */
        ABI_SYSV,                                   /**< SysV R4 */
        ABI_TRU64,                                  /**< Compaq TRU64 UNIX */
        ABI_WIN386                                  /**< Microsoft Windows */
    };

    /** Instruction sets organized by families */
    enum InsSetArchitecture {
        ISA_UNSPECIFIED             = 0x0000,       /**< File does not specify an architecture */
        ISA_OTHER                   = 0xffff,       /**< Architecture is something other than below */
        ISA_FAMILY_MASK             = 0xff00,       /**< Mask to get family part of ISA */

        ISA_IA32_Family             = 0x0100,       /**< x86 IA-32 family of architectures; Intel, AMD, VIA, ... */
        ISA_IA32_286                = 0x0101,       /**< 80286 */
        ISA_IA32_386                = 0x0102,       /**< MMU with paging */
        ISA_IA32_486                = 0x0103,       /**< risc-like pipelining, integrated FPU, on-chip cache */
        ISA_IA32_Pentium            = 0x0104,       /**< superscalar, 64-bit databus, MMX */
        ISA_IA32_Cyrix6x86          = 0x0105,       /**< register renaming, speculative execution */
        ISA_IA32_AMDK5              = 0x0106,       /**< micro-op translation */
        ISA_IA32_PentiumPro         = 0x0107,       /**< PAE, integrated L2 cache */
        ISA_IA32_PentiumII          = 0x0108,       /**< L3-cache, 3D Now, SSE */
        ISA_IA32_Athlon             = 0x0109,       /**< superscalar FPU, wide design */
        ISA_IA32_Pentium4           = 0x010a,       /**< deeply pipelined, high frequency, SSE2, hyper-threading */
        ISA_IA32_PentiumM           = 0x010b,       /**< low power */

        ISA_X8664_Family            = 0x0200,       /**< x86-64 family of architectures: Intel, AMD, VIA, ... */
        ISA_X8664_Athlon64          = 0x0201,       /**< on-die memory controller, 40-bit phys address space */
        ISA_X8664_Prescott          = 0x0202,       /**< deeply pipelined, high frequency, SSE3 */
        ISA_X8664_IntelCore         = 0x0203,       /**< low power, multi-core, lower clock frequency */
        ISA_X8664_AMDPhenom         = 0x0204,       /**< quad core, 128-bit FPUs, SSE4a, native mem ctrl, on-die L3 cache */

        ISA_SPARC_Family            = 0x0300,       /**< SPARC family of architectures; Sun Microsystems */
        ISA_SPARC_V7                = 0x0301,
        ISA_SPARC_V8                = 0x0302,
        ISA_SPARC_V8E               = 0x0303,
        ISA_SPARC_V9                = 0x0304,
        ISA_SPARC_V9JPS1            = 0x0305,
        ISA_SPARC_V9UA              = 0x0306,
        ISA_SPARC_V9JPS2            = 0x0307,

        ISA_M68K_Family             = 0x0400,       /**< Motorala m68k family */
        ISA_M68K_68000              = 0x0401,       /**< generation one: 16/32 internal; 8-, 16-, 32-bit interface */
        ISA_M68K_68EC000            = 0x0402,
        ISA_M68K_68HC000            = 0x0403,
        ISA_M68K_68008              = 0x0404,
        ISA_M68K_68010              = 0x0405,
        ISA_M68K_68012              = 0x0406,
        ISA_M68K_68020              = 0x0407,       /**< generation two: fully 32-bit */
        ISA_M68K_68EC020            = 0x0408,
        ISA_M68K_68030              = 0x0409,
        ISA_M68K_68EC030            = 0x040a,
        ISA_M68K_68040              = 0x040b,       /**< generation three: pipelined */
        ISA_M68K_68EC040            = 0x040c,
        ISA_M68K_68LC040            = 0x040d,
        ISA_M68K_68060              = 0x040e,       /**< generation four: superscalar */
        ISA_M68K_ColdFire           = 0x040f,       /**< other */
        ISA_M68K_DragonBall         = 0x0410,       /**< other */

        ISA_M88K_Family             = 0x0500,       /**< Motorola m88k family (not very popular) */
        ISA_M88K_88100              = 0x0501,       /**< 32-bit, integrated FPU mated with 88200 MMU and cache controller */
        ISA_M88K_88110              = 0x0502,       /**< single package of 88100+88200 */
        ISA_M88K_88110MP            = 0x0503,       /**< on-chip comm for use in multi-processor systems */
        ISA_M88K_88120              = 0x0504,       /**< superscalar (never actually released) */

        ISA_MIPS_Family             = 0x0600,       /**< 32/64-bit RISC; MIPS Technologies, Inc. */
        ISA_MIPS_MarkI              = 0x0601,       /**< R2000, R3000 */
        ISA_MIPS_MarkII             = 0x0602,       /**< R6000 */
        ISA_MIPS_MarkIII            = 0x0603,       /**< R4000 */
        ISA_MIPS_R2000              = 0x0604,       /**< 32-bit, Big or little endian */
        ISA_MIPS_R3000              = 0x0605,       /**< virtual identical: Pacempi's R3400, IDT's R3500, Toshiba R3900 */
        ISA_MIPS_R4000              = 0x0606,       /**< 64-bit; others in the series had larger caches and bug fixes */
        ISA_MIPS_R4200              = 0x0607,       /**< low-cost version of R4000 */
        ISA_MIPS_R4300              = 0x0608,       /**< low-cost version of R4000 with 32-bit external bus */
        ISA_MIPS_R4600              = 0x0609,       /**< "Orion" by Qauntum Effect Devices (QED); larger caches */
        ISA_MIPS_R4650              = 0x060a,       /**< by QED */
        ISA_MIPS_R4700              = 0x060b,       /**< "Orion" by QED */
        ISA_MIPS_R5000              = 0x060c,       /**< by QED */
        ISA_MIPS_RM7000             = 0x060d,       /**< by PMC-Sierra; 256kB L2 and optional L3 */
        ISA_MIPS_R8000              = 0x060e,       /**< superscalar, fairly rare */
        ISA_MIPS_R10000             = 0x060f,       /**< R8000 on a single chip; 32kB caches; out-of-order */
        ISA_MIPS_R12000             = 0x0610,       /**< R10000 + higher clock rates */
        ISA_MIPS_R14000             = 0x0611,       /**< R12000 + support for DDR SRAM; 200MHz front side bus */
        ISA_MIPS_R16000             = 0x0612,       /**< R14000 + increased freq, more L1, smaller die */
        ISA_MIPS_R16000A            = 0x0613,
        ISA_MIPS_16                 = 0x0614,       /**< Unknown. Windows PE architecture 0x266 "MIPS16" */
        ISA_MIPS_FPU                = 0x0615,       /**< Unknown. Windows PE architecture 0x366 "MIPS with FPU" */
        ISA_MIPS_16FPU              = 0x0616,       /**< Unknown. Windows PE architecture 0x466 "MIPS16 with FPU" */

        ISA_I860_Family             = 0x0700,       /**< Intel i860 family; 1989-mid 90's; RISC VLIW */
        ISA_I860_860XR              = 0x0701,       /**< (code named N10) 25-40MHz */
        ISA_I860_860XP              = 0x0702,       /**< (code named N11) larger caches; 40-50MHz; same IS as XR */

        ISA_IA64_Family             = 0x0800,       /**< Intel 64-bit architecture */
        ISA_IA64_Itanium            = 0x0801,       /**< First generation */
        ISA_IA64_Itanium2           = 0x0802,       /**< Second generation starting Nov 2007 */

        // See http://en.wikipedia.org/wiki/ARM_architecture
        ISA_ARM_Family              = 0x0900,       /**< Acorn RISC Machine, Advanced RISC Machines, ARM Limited */
        ISA_ARM_ARM1                = 0x0901,       /**< ARM evaluation system */
        ISA_ARM_ARM2                = 0x0902,       /**< ARM2, ARM250 cores */
        ISA_ARM_ARM3                = 0x0903,       /**< ARM2a core */
        ISA_ARM_ARM6                = 0x0904,       /**< ARM60, ARM600, ARM610 cores */
        ISA_ARM_ARM7                = 0x0905,       /**< ARM{700,710,710a,7100,7500,7500FE} cores */
        ISA_ARM_ARM7TDMI            = 0x0906,       /**< ARM{7TDMI,7TDMI-S,710T,720T,740T,7EJ-S} cores */
        ISA_ARM_StrongARM           = 0x0907,       /**< SA-110, SA-1110 cores */
        ISA_ARM_ARM8                = 0x0908,       /**< ARM810 core */
        ISA_ARM_ARM9TDMI            = 0x0909,       /**< ARM{9TDMI,920T,922T,940T} cores */
        ISA_ARM_ARM9E               = 0x090a,       /**< ARM{946E-S,966E-S,968E-S,926EJ-S,966HS} cores */
        ISA_ARM_ARM10E              = 0x090b,       /**< ARM{1020E,1022E,1026EJ-S} cores */
        ISA_ARM_XScale              = 0x090c,       /**< 80200, IOP310, IOP315, 80219, IOP321, IOP33x, IOP34x, PXA210,
                                                     *   PXA250, PXA255, PXA26x, PXA27x, PXA800(E)F, Monahans, PXA900,
                                                     *   IXC1100, IXP2400, IXP2800, IXP2850, IXP2325, IXP2350, IXP42x,
                                                     *   IXP460, IXP465 cores */
        ISA_ARM_ARM11               = 0x090d,       /**< ARMv{6,6T2,6KZ,6K} cores */
        ISA_ARM_Cortex              = 0x090e,       /**< Cortex-{A8,A9,A9 MPCore,R4(F),M3,M1} cores */
        ISA_ARM_A64                 = 0x090f,       /**< ARM AArch64 A64 instruction set. */

        ISA_JVM                     = 0x0a00,       /**< Java Virtual Machine (JVM) instruction set. */

        // Others, not yet incorporated into this enum
        ISA_OTHER_Family            = 0xf000,

        ISA_ATT_WE_32100            = 0xf001,       /**< Sometimes simply "M32" */
        ISA_IBM_System_370          = 0xf002,
        ISA_HPPA                    = 0xf003,
        ISA_Fujitsu_VPP500          = 0xf004,
        ISA_Sun_v8plus              = 0xf005,
        ISA_PowerPC                 = 0xf006,
        ISA_PowerPC_64bit           = 0xf007,
        ISA_IBM_S390                = 0xf008,
        ISA_NEC_V800_series         = 0xf009,
        ISA_Fujitsu_FR20            = 0xf00a,
        ISA_TRW_RH_32               = 0xf00b,
        ISA_Motorola_RCE            = 0xf00c,
        ISA_Digital_Alpha_fake      = 0xf00e,
        ISA_Hitachi_SH              = 0xf00f,
        ISA_Siemens_Tricore         = 0xf010,
        ISA_Argonaut_RISC_Core      = 0xf011,
        ISA_Hitachi_H8_300          = 0xf012,
        ISA_Hitachi_H8_300H         = 0xf013,
        ISA_Hitachi_H8S             = 0xf014,
        ISA_Hitachi_H8_500          = 0xf015,
        ISA_Stanford_MIPS_X         = 0xf016,
        ISA_Motorola_M68HC12        = 0xf017,
        ISA_Fujitsu_MMA_Multimedia_Accelerator=0xf018,
        ISA_Siemens_PCP             = 0xf019,
        ISA_Sony_nCPU_embeeded_RISC = 0xf01a,
        ISA_Denso_NDR1_microprocessor=0xf01b,
        ISA_Motorola_Start_Core_processor=0xf01c,
        ISA_Toyota_ME16_processor   = 0xf01d,
        ISA_STMicroelectronic_ST100_processor=0xf01e,
        ISA_Advanced_Logic_Corp_Tinyj_emb_family=0xf01f,
        ISA_AMD_x86_64_architecture = 0xf020,
        ISA_Sony_DSP_Processor      = 0xf021,
        ISA_Siemens_FX66_microcontroller=0xf022,
        ISA_STMicroelectronics_ST9_plus_8_16_microcontroller=0xf023,
        ISA_STMicroelectronics_ST7_8bit_microcontroller=0xf024,
        ISA_Motorola_MC68HC16_microcontroller=0xf025,
        ISA_Motorola_MC68HC11_microcontroller=0xf026,
        ISA_Motorola_MC68HC08_microcontroller=0xf027,
        ISA_Motorola_MC68HC05_microcontroller=0xf028,
        ISA_Silicon_Graphics_SVx    = 0xf029,
        ISA_STMicroelectronics_ST19_8bit_microcontroller=0xf02a,
        ISA_Digital_VAX             = 0xf02b,
        ISA_Axis_Communications_32bit_embedded_processor=0xf02c,
        ISA_Infineon_Technologies_32bit_embedded_processor=0xf02d,
        ISA_Element_14_64bit_DSP_Processor=0xf02e,
        ISA_LSI_Logic_16bit_DSP_Processor=0xf02f,
        ISA_Donald_Knuths_educational_64bit_processor=0xf030,
        ISA_Harvard_University_machine_independent_object_files=0xf031,
        ISA_SiTera_Prism            = 0xf032,
        ISA_Atmel_AVR_8bit_microcontroller=0xf033,
        ISA_Fujitsu_FR30            = 0xf034,
        ISA_Mitsubishi_D10V         = 0xf035,
        ISA_Mitsubishi_D30V         = 0xf036,
        ISA_NEC_v850                = 0xf037,
        ISA_Mitsubishi_M32R         = 0xf038,
        ISA_Matsushita_MN10300      = 0xf039,
        ISA_Matsushita_MN10200      = 0xf03a,
        ISA_picoJava                = 0xf03b,
        ISA_OpenRISC_32bit_embedded_processor=0xf03c,
        ISA_ARC_Cores_Tangent_A5    = 0xf03d,
        ISA_Tensilica_Xtensa_Architecture=0xf03e,
        ISA_Digital_Alpha         = 0xf03f,
        ISA_Matsushita_AM33         = 0xf040,
        ISA_EFI_ByteCode            = 0xf041
    };

    /** General purpose of a binary executable file. */
    enum ExecPurpose {
        PURPOSE_UNSPECIFIED,                        /**< Purpose is not specified and could not be inferred */
        PURPOSE_OTHER,                              /**< A purpose other than any defined below */
        PURPOSE_EXECUTABLE,                         /**< Executable program */
        PURPOSE_LIBRARY,                            /**< Library (shared or relocatable) */
        PURPOSE_CORE_DUMP,                          /**< Post mortem image */
        PURPOSE_OS_SPECIFIC,                        /**< Some operating system specific purpose */
        PURPOSE_PROC_SPECIFIC                       /**< Some processor specific purpose */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Factory method that parses a binary file. */
    static SgAsmGenericFile *parseBinaryFormat(const char *name);

    /** Dump debugging information into a named text file.
     *
     *  Writes a new file from the IR node for a parsed executable file. Warning: This function might modify the AST by calling @ref
     *  SgAsmGenericSection::reallocate, which makes sure all parts of the AST are consistent with respect to each other. */
    static void unparseBinaryFormat(const std::string &name, SgAsmGenericFile*);

    /** Dump debugging information to specified stream.
     *
     *  Unparses an executable file into the supplied output stream. Warning: This function might modify the AST by calling @ref
     *  SgAsmGenericSection::reallocate, which makes sure all parts of the AST are consistent with respect to each other. */
    static void unparseBinaryFormat(std::ostream&, SgAsmGenericFile*);

    /** Diagnostic stream. */
    static Sawyer::Message::Facility mlog;

    /** Initialize diagnostic streams.
     *
     *  This is called automatically by @ref Rose::initialize. */
    static void initDiagnostics();

    // These convert enums to strings. It is better to use the automatic enum stringification instead. They have names like
    // Rose::stringifySgAsmExecutableFileFormatInsnSetArchitecture, etc. */
    static std::string isaFamilyToString(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string isaToString(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string toString(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string toString(SgAsmExecutableFileFormat::ExecFamily);
    static std::string toString(SgAsmExecutableFileFormat::ExecABI);
    static std::string toString(SgAsmExecutableFileFormat::ExecPurpose);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated 2023-11
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    static std::string isa_family_to_string(SgAsmExecutableFileFormat::InsSetArchitecture) ROSE_DEPRECATED("use isaFamilyToString");
    static std::string isa_to_string(SgAsmExecutableFileFormat::InsSetArchitecture) ROSE_DEPRECATED("use isaToString");
    static std::string to_string(SgAsmExecutableFileFormat::InsSetArchitecture) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmExecutableFileFormat::ExecFamily) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmExecutableFileFormat::ExecABI) ROSE_DEPRECATED("use toString");
    static std::string to_string(SgAsmExecutableFileFormat::ExecPurpose) ROSE_DEPRECATED("use toString");
public:
    /** Destructor. */
    virtual ~SgAsmExecutableFileFormat();

protected:
    /** Default constructor. */
    SgAsmExecutableFileFormat();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExecutableFileFormat_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64SysMoveOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64SysMoveOperand);
IS_SERIALIZABLE(AsmAarch64SysMoveOperand);

#ifndef DOCUMENTATION
AsmAarch64SysMoveOperand.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64SysMoveOperand);
#if defined(SgAsmAarch64SysMoveOperand_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64
#endif
#endif // SgAsmAarch64SysMoveOperand_HEADERS

#ifdef DOCUMENTATION
/** Describes a system register for the ARM AArch64 A64 MRS and MSR instructions. */
class SgAsmAarch64SysMoveOperand: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64SysMoveOperand);
#if defined(SgAsmAarch64SysMoveOperand_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64SysMoveOperand -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64SysMoveOperand");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(access_);
        debugSerializationEnd("SgAsmAarch64SysMoveOperand");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    unsigned access_;

public:
    /** Property: system register access bits.
     *
     *  The bits describing how to access a system register. These come directly from the encoded instruction. 
     *  
     *  @{ */
    unsigned const& access() const;
    void access(unsigned const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64SysMoveOperand();

public:
    /** Default constructor. */
    SgAsmAarch64SysMoveOperand();

public:
    /** Constructor. */
    explicit SgAsmAarch64SysMoveOperand(unsigned const& access);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64SysMoveOperand_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64PState           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64PState);
IS_SERIALIZABLE(AsmAarch64PState);

#ifndef DOCUMENTATION
AsmAarch64PState.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64PState);
#if defined(SgAsmAarch64PState_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64PState_HEADERS

#ifdef DOCUMENTATION
/** Operand for an ARM AArch64 A64 MSR instruction. */
class SgAsmAarch64PState: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64PState);
#if defined(SgAsmAarch64PState_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64PState -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64PState");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(pstate_);
        debugSerializationEnd("SgAsmAarch64PState");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Rose::BinaryAnalysis::Aarch64PState pstate_;

public:
    /** Property: PState.
     *
     *  An enum representing the operand. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch64PState const& pstate() const;
    void pstate(Rose::BinaryAnalysis::Aarch64PState const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64PState();

public:
    /** Default constructor. */
    SgAsmAarch64PState();

public:
    /** Constructor. */
    explicit SgAsmAarch64PState(Rose::BinaryAnalysis::Aarch64PState const& pstate);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64PState_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64PrefetchOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64PrefetchOperand);
IS_SERIALIZABLE(AsmAarch64PrefetchOperand);

#ifndef DOCUMENTATION
AsmAarch64PrefetchOperand.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64PrefetchOperand);
#if defined(SgAsmAarch64PrefetchOperand_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64PrefetchOperand_HEADERS

#ifdef DOCUMENTATION
/** Operand for an ARM AArch64 A64 prefetch instruction. */
class SgAsmAarch64PrefetchOperand: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64PrefetchOperand);
#if defined(SgAsmAarch64PrefetchOperand_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64PrefetchOperand -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64PrefetchOperand");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(operation_);
        debugSerializationEnd("SgAsmAarch64PrefetchOperand");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Rose::BinaryAnalysis::Aarch64PrefetchOperation operation_;

public:
    /** Property: Prefetch operation.
     *
     *  An enum representing the operation to be performed. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch64PrefetchOperation const& operation() const;
    void operation(Rose::BinaryAnalysis::Aarch64PrefetchOperation const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64PrefetchOperand();

public:
    /** Default constructor. */
    SgAsmAarch64PrefetchOperand();

public:
    /** Constructor. */
    explicit SgAsmAarch64PrefetchOperand(Rose::BinaryAnalysis::Aarch64PrefetchOperation const& operation);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64PrefetchOperand_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64Instruction);
IS_SERIALIZABLE(AsmAarch64Instruction);

#ifndef DOCUMENTATION
AsmAarch64Instruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64Instruction);
#if defined(SgAsmAarch64Instruction_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64
#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64Instruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one ARM A64 machine instruction. */
class SgAsmAarch64Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch64Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch64InstructionKind", "kind", "= Rose::BinaryAnalysis::Aarch64InstructionKind::ARM64_INS_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch64Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch64InstructionCondition", "condition", "= Rose::BinaryAnalysis::Aarch64InstructionCondition::ARM64_CC_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch64Instruction.setDataPrototype(
        "bool", "updatesFlags", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64Instruction);
#if defined(SgAsmAarch64Instruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64Instruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64Instruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        s & BOOST_SERIALIZATION_NVP(p_condition);
        debugSerializationEnd("SgAsmAarch64Instruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the AArch64 A64 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch64InstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::Aarch64InstructionKind const&);
    /** @} */

public:
    /** Property: ARM A64 instruction condition. 
     * 
     * @{ */
    Rose::BinaryAnalysis::Aarch64InstructionCondition const& get_condition() const;
    void set_condition(Rose::BinaryAnalysis::Aarch64InstructionCondition const&);
    /** @} */
    // FIXME[Robb Matzke 2023-03-18]: is the lack of serialization a bug?
public:
    /** Property: Whether this instruction updates N, Z, C, and/or V status flags. 
     * 
     * @{ */
    bool const& get_updatesFlags() const;
    void set_updatesFlags(bool const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmAarch64Instruction();

public:
    /** Default constructor. */
    SgAsmAarch64Instruction();

public:
    /** Constructor. */
    SgAsmAarch64Instruction(rose_addr_t const& address,
                            uint8_t const& architectureId,
                            Rose::BinaryAnalysis::Aarch64InstructionKind const& kind,
                            Rose::BinaryAnalysis::Aarch64InstructionCondition const& condition);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64Instruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64CImmediateOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64CImmediateOperand);
IS_SERIALIZABLE(AsmAarch64CImmediateOperand);

#ifndef DOCUMENTATION
AsmAarch64CImmediateOperand.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64CImmediateOperand);
#if defined(SgAsmAarch64CImmediateOperand_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64
#endif
#endif // SgAsmAarch64CImmediateOperand_HEADERS

#ifdef DOCUMENTATION
/** C-Immediate operand for SYS, AT, CFP, CPP, DC, DVP, IC, and TLBI instructions. */
class SgAsmAarch64CImmediateOperand: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64CImmediateOperand);
#if defined(SgAsmAarch64CImmediateOperand_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64CImmediateOperand -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64CImmediateOperand");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(immediate_);
        debugSerializationEnd("SgAsmAarch64CImmediateOperand");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    unsigned immediate_;

public:
    /** Property: C-immediate value.
     *
     *  The C-immediate value for the instruction. 
     *  
     *  @{ */
    unsigned const& immediate() const;
    void immediate(unsigned const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64CImmediateOperand();

public:
    /** Default constructor. */
    SgAsmAarch64CImmediateOperand();

public:
    /** Constructor. */
    explicit SgAsmAarch64CImmediateOperand(unsigned const& immediate);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64CImmediateOperand_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64BarrierOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64BarrierOperand);
IS_SERIALIZABLE(AsmAarch64BarrierOperand);

#ifndef DOCUMENTATION
AsmAarch64BarrierOperand.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64BarrierOperand);
#if defined(SgAsmAarch64BarrierOperand_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64BarrierOperand_HEADERS

#ifdef DOCUMENTATION
/** Barriar operation operand for ISB, DMB, and DSB instructions. */
class SgAsmAarch64BarrierOperand: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64BarrierOperand);
#if defined(SgAsmAarch64BarrierOperand_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64BarrierOperand -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64BarrierOperand");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(operation_);
        debugSerializationEnd("SgAsmAarch64BarrierOperand");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Rose::BinaryAnalysis::Aarch64BarrierOperation operation_;

public:
    /** Property: Barrier operation. 
     * 
     * @{ */
    Rose::BinaryAnalysis::Aarch64BarrierOperation const& operation() const;
    void operation(Rose::BinaryAnalysis::Aarch64BarrierOperation const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64BarrierOperand();

public:
    /** Default constructor. */
    SgAsmAarch64BarrierOperand();

public:
    /** Constructor. */
    explicit SgAsmAarch64BarrierOperand(Rose::BinaryAnalysis::Aarch64BarrierOperation const& operation);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64BarrierOperand_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64AtOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
DECLARE_LEAF_CLASS(AsmAarch64AtOperand);
IS_SERIALIZABLE(AsmAarch64AtOperand);

#ifndef DOCUMENTATION
AsmAarch64AtOperand.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch64AtOperand);
#if defined(SgAsmAarch64AtOperand_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64AtOperand_HEADERS

#ifdef DOCUMENTATION
/** Operand for an ARM AArch64 A64 AT instruction. */
class SgAsmAarch64AtOperand: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch64AtOperand);
#if defined(SgAsmAarch64AtOperand_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch64AtOperand -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch64AtOperand");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(operation_);
        debugSerializationEnd("SgAsmAarch64AtOperand");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Rose::BinaryAnalysis::Aarch64AtOperation operation_;

public:
    /** Property: AT Operation.
     *
     *  An enum representing the operation to be performed. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch64AtOperation const& operation() const;
    void operation(Rose::BinaryAnalysis::Aarch64AtOperation const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch64AtOperand();

public:
    /** Default constructor. */
    SgAsmAarch64AtOperand();

public:
    /** Constructor. */
    explicit SgAsmAarch64AtOperand(Rose::BinaryAnalysis::Aarch64AtOperation const& operation);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64AtOperand_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch32Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH32
DECLARE_LEAF_CLASS(AsmAarch32Instruction);
IS_SERIALIZABLE(AsmAarch32Instruction);

#ifndef DOCUMENTATION
AsmAarch32Instruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmAarch32Instruction);
#if defined(SgAsmAarch32Instruction_HEADERS) || defined(DOCUMENTATION)
#ifdef ROSE_ENABLE_ASM_AARCH32
#include <Rose/BinaryAnalysis/InstructionEnumsAarch32.h>
#endif
#endif // SgAsmAarch32Instruction_HEADERS

#ifdef DOCUMENTATION
/** Represents one A32 or T32 machine instruction. */
class SgAsmAarch32Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch32Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch32InstructionKind", "kind", "= Rose::BinaryAnalysis::Aarch32InstructionKind::ARM_INS_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch32Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch32InstructionCondition", "condition", "= Rose::BinaryAnalysis::Aarch32InstructionCondition::ARM_CC_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch32Instruction.setDataPrototype(
        "bool", "updatesFlags", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch32Instruction.setDataPrototype(
        "bool", "writesBack", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmAarch32Instruction.setDataPrototype(
        "bool", "writesToIp", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmAarch32Instruction);
#if defined(SgAsmAarch32Instruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch32Instruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch32Instruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
        s & BOOST_SERIALIZATION_NVP(p_kind);
        s & BOOST_SERIALIZATION_NVP(p_condition);
        s & BOOST_SERIALIZATION_NVP(p_updatesFlags);
        s & BOOST_SERIALIZATION_NVP(p_writesBack);
        s & BOOST_SERIALIZATION_NVP(p_writesToIp);
        debugSerializationEnd("SgAsmAarch32Instruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the AArch32 A32 or T32 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch32InstructionKind const& get_kind() const;
    void set_kind(Rose::BinaryAnalysis::Aarch32InstructionKind const&);
    /** @} */

public:
    /** Property: ARM AArch32 instruction condition.
     *
     *  This property indicates when the instruction is executed. 
     *  
     *  @{ */
    Rose::BinaryAnalysis::Aarch32InstructionCondition const& get_condition() const;
    void set_condition(Rose::BinaryAnalysis::Aarch32InstructionCondition const&);
    /** @} */

public:
    /** Property: Whether this instruction updates N, Z, C, and/or V status flags. 
     * 
     * @{ */
    bool const& get_updatesFlags() const;
    void set_updatesFlags(bool const&);
    /** @} */

public:
    /** Property: Whether this instruction writes back to an operand at the end. 
     * 
     * @{ */
    bool const& get_writesBack() const;
    void set_writesBack(bool const&);
    /** @} */

public:
    /** Property: Whether this instruction writes to the instruction pointer register.
     *
     *  On ARM architectures, the instruction pointer register is named "PC", for "program counter". ROSE always calls this
     *  register the instruction pointer register. 
     *  
     *  @{ */
    bool const& get_writesToIp() const;
    void set_writesToIp(bool const&);
    /** @} */
public:
    // Overrides are documented in the base class
    virtual unsigned get_anyKind() const override;
public:
    /** Destructor. */
    virtual ~SgAsmAarch32Instruction();

public:
    /** Default constructor. */
    SgAsmAarch32Instruction();

public:
    /** Constructor. */
    SgAsmAarch32Instruction(rose_addr_t const& address,
                            uint8_t const& architectureId,
                            Rose::BinaryAnalysis::Aarch32InstructionKind const& kind,
                            Rose::BinaryAnalysis::Aarch32InstructionCondition const& condition);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch32Instruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmInstruction = nonTerminalConstructor(
    "AsmInstruction",
    *this,
    "AsmInstruction",
    "AsmInstructionTag",
    SubclassListBuilder()
#ifdef ROSE_ENABLE_ASM_AARCH32
        | AsmAarch32Instruction
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64Instruction
#endif
        | AsmCilInstruction
        | AsmJvmInstruction
        | AsmM68kInstruction
        | AsmMipsInstruction
        | AsmNullInstruction
        | AsmPowerpcInstruction
        | AsmUserInstruction
        | AsmX86Instruction
    , true);
assert(AsmInstruction.associatedGrammar != nullptr);
AsmInstruction.setCppCondition("!defined(DOCUMENTATION)");
AsmInstruction.isBoostSerializable(true);
AsmInstruction.setAutomaticGenerationOfConstructor(false);
AsmInstruction.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmInstruction.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmInstruction);
#if defined(SgAsmInstruction_HEADERS) || defined(DOCUMENTATION)
#include <Rose/BinaryAnalysis/Architecture/BasicTypes.h>
#include <Rose/BinaryAnalysis/MemoryMap.h>
#include <sageContainer.h>
#include <Sawyer/Cached.h>

#ifdef ROSE_SgAsmInstruction_IMPL
#include <SgAsmExprListExp.h>
#include <SgAsmOperandList.h>
#endif
#endif // SgAsmInstruction_HEADERS

#ifdef DOCUMENTATION
/** Base class for machine instructions.
 *
 *  @li Each instruction is represented by one or more instances of SgAsmInstruction.
 *
 *  @li An instruction obtained from a full AST will have a parent pointer. The instruction's first ancestor of type @ref
 *  SgAsmBlock is the basic block in which the instruction appears, and its first ancestor of type @ref SgAsmFunction is
 *  the function in which the instruction appears. There may be intervening AST nodes having other types.
 *
 *  @li An instruction obtained from a @ref Rose::BinaryAnalysis::Partitioner2::Partitioner "Partitioner" will not have a
 *  parent pointer. You can find ownership information using the Partitioner API.
 *
 *  @li An instruction's bytes will always be contiguous in the virtual address space from which the instruction was
 *  decoded, but might not be contiguous in the file (if any) where the instruction was stored. In fact, there's no
 *  guarantee that the instruction even exists entirely within one file.
 *
 *  @li Two distinct instructions (with different encodings) can start at the same virtual address if the specimen is
 *  self-modifying. Most ROSE analysis assumes that specimens are not self-modifying and uses the instruction's starting
 *  virtual address to uniquely identify the instruction.
 *
 *  @li Two distinct instructions (with different encodings) can occupy overlapping bytes in the virtual address space, and
 *  are guaranteed to have different starting addresses unless the specimen is self-modifying. */
class SgAsmInstruction: public SgAsmStatement {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstruction.setDataPrototype(
        "uint8_t", "architectureId", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstruction.setDataPrototype(
        "SgUnsignedCharList", "rawBytes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstruction.setDataPrototype(
        "SgAsmOperandList*", "operandList", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstruction.setDataPrototype(
        "SgAsmInstruction*", "delaySlot", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmInstruction.setDataPrototype(
        "SgAsmExprListExp*", "semantics", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmInstruction);
#if defined(SgAsmInstruction_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmInstruction -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmInstruction");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
        {
            auto temp = architectureIdSerialize(p_architectureId);
            s & boost::serialization::make_nvp("p_architectureId", temp);
            p_architectureId = architectureIdDeserialize(temp);
        }
        s & BOOST_SERIALIZATION_NVP(p_rawBytes);
        s & BOOST_SERIALIZATION_NVP(p_operandList);
        s & BOOST_SERIALIZATION_NVP(p_delaySlot);
        userSerializeBoost(s);
        debugSerializationEnd("SgAsmInstruction");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    struct SemanticFailure {
        size_t n;
        SemanticFailure(): n(0) {}

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(n);
        }
#endif
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
public:
    /** Property: Architecture registration ID.
     *
     *  Every instruction must belong to a registered architecture. This ID specifies the architecture of which this instruction
     *  is a member.
     *
     *  When an instruction is serialized to a file, the architecture name is saved in place of its registration ID, and when the
     *  instruction is deserialized, that name is looked up in the registry and the registration ID is saved in the reconstituted
     *  instruction. This mechanism enables the instruction to point to the correct architecture even if the writer and reader
     *  tools have slightly different sets of architectures registered. 
     *  
     *  @{ */
    uint8_t const& get_architectureId() const;
    /** @} */
    // Architecture registration IDs change from run to run, so serialize the architecture name instead. The architecture names
    // will probably not change as frequently as their registration IDs.
    std::string architectureIdSerialize(uint8_t id) const;
    uint8_t architectureIdDeserialize(const std::string &name) const;
public:
    /** Property: Raw bytes of an instruction.
     *
     *  These are the bytes that were actually decoded to obtain the instruction AST. 
     *  
     *  @{ */
    SgUnsignedCharList const& get_rawBytes() const;
    void set_rawBytes(SgUnsignedCharList const&);
    /** @} */

public:
    /** Property: AST node that holds all operands.
     *
     *  This is the @ref SgAsmOperandList AST node that holds all the operands of this instruction. A separate node is
     *  necessary (rather than storing the operand list directly in the instruction node) due to limitations of ROSETTA. 
     *  
     *  @{ */
    SgAsmOperandList* const& get_operandList() const;
    void set_operandList(SgAsmOperandList* const&);
    /** @} */

public:
    /** Property: Delay slot instructions.
     *
     *  The instruction occupying the delay slot for this instruction. A delay slot is an instruction that is executed without the
     *  effects of a preceding instruction. The most common form is a single arbitrary instruction located immediately after a
     *  branch instruction on a RISC architecture, in which case the delay instruction will execute even if the preceding branch is
     *  taken. This makes the instruction execute out-of-order compared to its location in memory or in the original assembler
     *  language code.
     *
     *  The address of the instruction pointed to by the delay slot must immediately follow this instruction. There is no AST edge
     *  from this instruction to its delay slot instruction. 
     *  
     *  @{ */
    SgAsmInstruction* const& get_delaySlot() const;
    void set_delaySlot(SgAsmInstruction* const&);
    /** @} */
    // FIXME[Robb Matzke 2023-03-18]: is the lack of serialization a bug?
public:
    /** Property: Ordered list of instruction semantics.
     *
     *  If instruction semantics are available and attached to the instruction, then this subtree will contain a list of
     *  semantic side effects of the instruction. The semantics are attached by using the @ref
     *  Rose::BinaryAnalysis::InstructionSemantics::StaticSemantics semantic domain. 
     *  
     *  @{ */
    SgAsmExprListExp* const& get_semantics() const;
    void set_semantics(SgAsmExprListExp* const&);
    /** @} */
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    SemanticFailure semanticFailure_;

public:
    /** Represents an invalid stack delta.
     *
     *  This value is used for the result of a stack delta analysis stored in the instruction AST if the stack delta
     *  analysis was not run or did not produce a numeric result. */
    static const int64_t INVALID_STACK_DELTA;           // [Robb Matzke 2024-10-01]: deprecated; use an optional type instead

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Architecture for instruction.
     *
     *  The architecture is looked up in the architecture registery in constant time by using the @ref architectureId property.
     *  It is generally unwise to change the architecture registery after instructions have been created since this may cause
     *  instructions to refer to an incorrect architecture.
     *
     *  Thread safety: This function is thread safe. */
    Rose::BinaryAnalysis::Architecture::BaseConstPtr architecture() const /*final*/;

    /** Property: Instruction mnemonic string.
     *
     *  The short string that describes the instruction. When comparing instructions, it's faster to use the @c kind property
     *  defined in the subclasses, or the @ref SgAsmInstruction::get_anyKind function instead of comparing mnemonic strings. But be
     *  aware that some architectures have mnemonics that include information about the instruction operands and this information is
     *  typically not represented by the instruction kind enum constants. */
    std::string get_mnemonic() const;

    // [Robb Matzke 2023-12-04]: deprecated
    virtual std::string description() const final ROSE_DEPRECATED("use Architecture::Base::instructionDescription");

    /** Number of operands. */
    size_t nOperands() const;

    /** Nth operand.
     *
     *  If the operand index is out of range, then null is returned. */
    SgAsmExpression* operand(size_t) const;

    // [Robb Matzke 2023-12-04]: deprecated
    virtual bool terminatesBasicBlock() final ROSE_DEPRECATED("use Architecture::Base::terminatesBasicBlock");
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&, rose_addr_t *target, rose_addr_t *ret) final
        ROSE_DEPRECATED("use Architecture::Base::isFunctionCallFast");
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&, rose_addr_t *target, rose_addr_t *ret) final
        ROSE_DEPRECATED("use Architecture::Base::isFunctionCallSlow");
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&) final
        ROSE_DEPRECATED("use Architecture::Base::isFunctionReturnFast");
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&) final
        ROSE_DEPRECATED("use Architecture::Base::isFunctionReturnSlow");
    virtual Sawyer::Optional<rose_addr_t> branchTarget() final
        ROSE_DEPRECATED("use Architecture::Base::branchTarget");

    /** Returns true if this instruction is the first instruction in a basic block.
     *
     *  This method looks only at the AST to make this determination. */
    bool isFirstInBlock();

    /** Returns true if this instruction is the last instruction in a basic block.
     *
     *  This method looks only at the AST to make this determination. */
    bool isLastInBlock();

    /** Determines whether a single instruction has an effect.
     *
     *  An instruction has an effect if it does anything other than setting the instruction pointer to a concrete
     *  value. Instructions that have no effect are called "no-ops".  The x86 NOP instruction is an example of a no-op, but
     *  there are others also.
     *
     *  The following information about x86 no-ops is largely from Cory Cohen at CMU/SEI. In the discussion that follows,
     *  we are careful to distinguish between NOP (the mneumonic for instructions 90, and 0f1f) and "no-op" (any
     *  instruction whose only effect is to advance the instruction pointer).
     *
     * @code
     *  Opcode bytes         Intel assembly syntax
     *  -------------------- ----------------------
     *  90                   nop
     *
     *  89c0                 mov eax,eax            Intel's old recommended two-byte no-op was to
     *  89c9                 mov ecx,ecx            move a register to itself...  The second byte of these are mod/rm
     *  89d2                 mov edx,edx            bytes, and can generally be substituded wherever you see 0xc0 in
     *  89db                 mov ebx,ebx            subsequent examples.
     *  89e4                 mov esp,esp
     *  89ed                 mov ebp,ebp
     *  89f6                 mov esi,esi
     *  89ff                 mov edi,edi
     *
     *  88c0                 mov al,al              The above are also available in 8-bit form with a leading byte of 0x88
     *  6689c0               mov ax,ax              and with an operand size prefix (0x66).
     *
     *  66666689c0           mov ax,ax              The prefixes can be repeated. One source seemed to imply that up to
     *                                              three are reliably supported by the actual Intel processors. ROSE
     *                                              supports any number up to the maximum instruction size (varies by mode).
     *
     *  6688c0               mov al,al              The operand size prefix can even be nonsensical.
     *
     *  8ac0                 mov al,al              These are also presumabely no-ops.  As with most instructions, these
     *  8bc0                 mov eax,eax            will accept operand size prefixes as well.
     *
     *  f090                 lock nop               Most of these instructions will accept a lock prefix as well, which does
     *  f0f090               lock nop               not materially affect the result. As before, they can occur repeatedly,
     *  f066f090             lock nop               and even in wacky combinations.
     *  f066f06666f0f066f090 lock nop
     *
     *  f290                 repne nop              Cory Cohen strongly suspects that the other instruction prefixes are
     *  f390                 rep nop                ignored as well, although to be complete, we might want to conduct a
     *  2690                 es nop                 few tests into the behavior of common processors.
     *  2e90                 cs nop
     *  3690                 ss nop
     *  3e90                 ds nop
     *  6490                 fs nop
     *  6590                 gs nop
     *  6790                 nop
     *
     *  8d00                 lea eax,[eax]          Intel's old recommendation for larger no-ops was to use the LEA
     *  8d09                 lea ecx,[ecx]          instruction in various dereferencing modes.
     *  8d12                 lea edx,[edx]
     *  8d1b                 lea ebx,[ebx]
     *  8d36                 lea esi,[esi]
     *  8d3f                 lea edi,[edi]
     *
     *  8d4000               lea eax,[eax+0x0]
     *  8d4900               lea ecx,[ecx+0x0]
     *  8d5200               lea edx,[edx+0x0]
     *  8d5b00               lea ebx,[ebx+0x0]
     *  8d7600               lea esi,[esi+0x0]
     *  8d7f00               lea edi,[edi+0x0]
     *
     *  8d8000000000         lea eax,[eax+0x0]      This last block is really the [reg*0x1+0x0] dereferencing mode.
     *  8d8900000000         lea ecx,[ecx+0x0]
     *  8d9200000000         lea edx,[edx+0x0]
     *  8d9b00000000         lea ebx,[ebx+0x0]
     *  8db600000000         lea esi,[esi+0x0]
     *  8dbf00000000         lea edi,[edi+0x0]
     *
     *  8d0420               lea eax,[eax]          Then there's funky equivalents involving SIB bytes.
     *  8d0c21               lea ecx,[ecx]
     *  8d1422               lea edx,[edx]
     *  8d1c23               lea ebx,[ebx]
     *  8d2424               lea esp,[esp]
     *  8d3426               lea esi,[esi]
     *  8d3c27               lea edi,[edi]
     *
     *  8d442000             lea eax,[eax+0x0]
     *  8d4c2100             lea ecx,[ecx+0x0]
     *  8d542200             lea edx,[edx+0x0]
     *  8d5c2300             lea ebx,[ebx+0x0]
     *  8d642400             lea esp,[esp+0x0]
     *  8d742600             lea esi,[esi+0x0]
     *  8d7c2700             lea edi,[edi+0x0]
     *
     *  8d842000000000       lea eax,[eax+0x0]
     *  8d8c2100000000       lea ecx,[ecx+0x0]
     *  8d942200000000       lea edx,[edx+0x0]
     *  8d9c2300000000       lea ebx,[ebx+0x0]
     *  8da42400000000       lea esp,[esp+0x0]
     *  8db42600000000       lea esi,[esi+0x0]
     *  8dbc2700000000       lea edi,[edi+0x0]
     *
     *  8d2c2d00000000       lea ebp,[ebp+0x0]      The EBP variants don't exactly follow the pattern above.
     *  8d6c2500             lea ebp,[ebp+0x0]
     *  8dac2500000000       lea ebp,[ebp+0x0]
     *
     *  0f1f00               nop [eax]              P4+ adds the 0f1f instruction. Each of these can be prefixed with the
     *  0f1f4000             nop [eax+0x0]          0x66 operand size prefix. In fact, Intel recommends doing this now
     *  0f1f440000           nop [eax+0x0]          for the optimally efficient 6- and 9-byte sequences.
     *  0f1f8000000000       nop [eax+0x0]
     *  0f1f840000000000     nop [eax+0x0]
     *
     *  0f0dxx               nop [xxx]              The latest version of the manual implies that this sequence is also
     *                                              reserved for NOP, although I can find almost no references to it except
     *                                              in the latest instruction manual on page A-13 of volume 2B. It's also
     *                                              mentioned on x86asm.net. [CORY 2010-04]
     *
     *  d9d0                 fnop                   These aren't really no-ops on the chip, but are no-ops from the
     *  9b                   wait                   program's perspective. Most of these instructions are related to
     *  0f08                 invd                   improving cache efficiency and performance, but otherwise do not
     *  0f09                 wbinvd                 affect the program behavior.
     *  0f01c9               mwait
     *  0f0138               invlpg [eax]
     *  0f01bf00000000       invlpg [edi+0x0]       and more...
     *  0f18 /0              prefetchnta [xxx]
     *  0f18 /1              prefetch0 [xxx]
     *  0f18 /2              prefetch1 [xxx]
     *  0f18 /3              prefetch2 [xxx]
     *  0fae /5              lfence [xxx]
     *  0fae /6              mfence [xxx]
     *  0fae /7              sfence [xxx]
     *
     *  0f18xx through 0f1exx                       This opcode rante is officially undefined but is probably reserved
     *                                              for no-ops as well.  Any instructions encountered in this range are
     *                                              probably consequences of bad code and should be ingored.
     *
     *  JMP, Jcc, PUSH/RET, etc.                    Branches are considered no-ops if they can be proven to always branch
     *                                              to the fall-through address.
     * @endcode
     */
    virtual bool hasEffect();

    /** Determine if an instruction sequence has an effect.
     *
     *  A sequence of instructions has an effect if it does something other than setting the instruction pointer to a
     *  concrete value.
     *
     *  This is mostly a wrapper around the @ref Rose::BinaryAnalysis::NoOperation "NoOperation" analysis. The @p
     *  allow_branch and @p relax_stack_semantics are no longer supported but perhaps will be added eventually to the
     *  NoOperation analysis. */
    virtual bool hasEffect(const std::vector<SgAsmInstruction*>&, bool allow_branch=false,
                           bool relax_stack_semantics=false);

    /** Determines what subsequences of an instruction sequence have no cumulative effect.
     *
     *  The return value is a vector of pairs where each pair is the starting index and length of subsequence.  The
     *  algorithm we use is to compute the machine state after each instruction and then look for pairs of states that are
     *  identical except for the instruction pointer.
     *
     *  This is mostly a wrapper around the @ref Rose::BinaryAnalysis::NoOperation "NoOperation" analysis. The @p
     *  allow_branch and @p relax_stack_semantics are no longer supported but perhaps will be added eventually to the
     *  NoOperation analysis. */
    virtual std::vector<std::pair<size_t,size_t> >
    findNoopSubsequences(const std::vector<SgAsmInstruction*>& insns, bool allow_branch=false,
                         bool relax_stack_semantics=false);

    // [Robb Matzke 2023-12-04]: deprecated
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete)
        ROSE_DEPRECATED("use Architecture::Base::getSuccessors");
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*> &basicBlock,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr())
        ROSE_DEPRECATED("use Architecture::Base::getSuccessors");

    /** Returns the size of an instruction in bytes.
     *
     *  This is only a convenience function that returns the size of the instruction's raw byte vector.  If an instruction
     *  or its arguments are modified, then the size returned by this function might not reflect the true size of the
     *  modified instruction if it were to be reassembled. */
    virtual size_t get_size() const;

    // [Robb Matzke 2023-12-05]: deprecated
    virtual bool isUnknown() const final ROSE_DEPRECATED("use Architecture::Base::isUnknown");

    /** Returns instruction kind for any architecture.
     *
     *  Instruction kinds are specific to the architecture so it doesn't make sense to compare an instruction kind from x86
     *  with an instruction kind from m68k.  However, this virtual function exists so that we don't need to implement
     *  switch statements every time we want to compare two instructions from the same architecture.  For instance, instead
     *  of code like this:
     *
     * @code
     *  bool areSame(SgAsmInstruction *a, SgAsmInstruction *b) {
     *      if (a->variantT() != b->variantT())
     *          return false;
     *      if (SgAsmM68kInstruction *aa = isSgAsmM68kInstruction(a)) {
     *          SgAsmM68kInstruction *bb = isSgAsmM68kInstruction(b);
     *          return aa->get_kind() == bb->get_kind();
     *      }
     *      if (SgAsmMipsInstruction *aa = isSgAsmMipsInstruction(a)) {
     *          SgAsmMipsInstruction *bb = isSgAsmMipsInstruction(b);
     *          return aa->get_kind() == bb->get_kind();
     *      }
     *      ...
     *      ... // and many others
     *      ...
     *      ASSERT_not_reachable("architecture is not implemented yet");
     *  }
     * @endcode
     *
     *  we can write future-proof code:
     *
     * @code
     *  bool areSame(SgAsmInstruction *a, SgAsmInstruction *b) {
     *      return a->variantT()==b->variantT() && a->get_anyKind()==b->get_anyKind();
     *  }
     * @endcode */
    virtual unsigned get_anyKind() const;

    /** Converts the instruction to a string.
     *
     *  The return value is an address, colon, mnemonic, and arguments. Only one space is used between the parts. */
    virtual std::string toString() const;

    /** Converts the instruction to a string.
     *
     *  The return value is a mnemonic, and arguments. Only one space is used between the parts. */
    virtual std::string toStringNoAddr() const;

    /** Explicit constants.
     *
     *  Return the set of integer constants that appear explicitly in the instruction's operands. These are called
     *  "immediates" for some architectures such as X86. */
    virtual std::set<rose_addr_t> explicitConstants() const;

    /** Property: Whether instruction semantics failed at this location.
     *
     *  This property is incremented by various analyses that evaluate instructions semantically when semantics fails
     *  in a way that is not recoverable.  Some analyses can work around failed semantics by operating in a degraded
     *  mode, and it is up to the analysis whether to increment this property.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    size_t semanticFailure() const;
    void semanticFailure(size_t);
    void incrementSemanticFailure();
    /** @} */

    /** Rewrite certain addressing modes for operands.
     *
     *  The addressing mode: <code>REG1 + REG2 * SIZE + OFFSET</code> is changed from <code>(+ (+ REG1 (* REG2 SIZE))
     *  OFFSET)</code> to <code>(+ (+ REG1 OFFSET) (* REG2 SIZE))</code>, which during instruction semantic executions causes
     *  the base register and offset to be added first to obtain the starting address of an array, and then an additional offset
     *  added to obtain the address of the desired element of that array.
     *
     *  Returns true if anything changed, false otherwise. */
    bool normalizeOperands();

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Serialization
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    template<class S>
    void userSerializeBoost(S &s) {
        s & BOOST_SERIALIZATION_NVP(semanticFailure_);
    }
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    // [Robb Matzke 2023-11-07]: deprecated
    const SgUnsignedCharList& get_raw_bytes() const ROSE_DEPRECATED("use get_rawBytes");
    void set_raw_bytes(const SgUnsignedCharList&) ROSE_DEPRECATED("use set_rawBytes");
public:
    /** Destructor. */
    virtual ~SgAsmInstruction();

public:
    /** Default constructor. */
    SgAsmInstruction();

public:
    /** Constructor. */
    SgAsmInstruction(rose_addr_t const& address,
                     uint8_t const& architectureId);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInstruction_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStatement           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmStatement = nonTerminalConstructor(
    "AsmStatement",
    *this,
    "AsmStatement",
    "AsmStatementTag",
    SubclassListBuilder()
        | AsmBlock
        | AsmInstruction
        | AsmStaticData
        | AsmSynthesizedDeclaration
    , false);
assert(AsmStatement.associatedGrammar != nullptr);
AsmStatement.setCppCondition("!defined(DOCUMENTATION)");
AsmStatement.isBoostSerializable(true);
AsmStatement.setAutomaticGenerationOfConstructor(false);
AsmStatement.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmStatement.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for statement-like subclasses.
 *
 *  This is a base class for those binary analysis entities, such as instructions and basic blocks, that have a starting
 *  address in the virtual address space. */
class SgAsmStatement: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStatement.setDataPrototype(
        "rose_addr_t", "address", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmStatement.setDataPrototype(
        "std::string", "comment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmStatement);
#if defined(SgAsmStatement_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmStatement -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmStatement");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_address);
        s & BOOST_SERIALIZATION_NVP(p_comment);
        debugSerializationEnd("SgAsmStatement");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Starting virtual address.
     *
     *  Virtual address of first byte of instruction, block, or whatever, depending on subclass. 
     *  
     *  @{ */
    rose_addr_t const& get_address() const;
    void set_address(rose_addr_t const&);
    /** @} */

public:
    /** Property: Commentary. 
     * 
     * @{ */
    std::string const& get_comment() const;
    void set_comment(std::string const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmStatement();

protected:
    /** Default constructor. */
    SgAsmStatement();

protected:
    /** Constructor. */
    explicit SgAsmStatement(rose_addr_t const& address);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStatement_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch32Coprocessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

DECLARE_LEAF_CLASS(AsmAarch32Coprocessor);
IS_SERIALIZABLE(AsmAarch32Coprocessor);

#ifndef DOCUMENTATION
AsmAarch32Coprocessor.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Operand referencing a Co-processor. */
class SgAsmAarch32Coprocessor: public SgAsmExpression {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmAarch32Coprocessor);
#if defined(SgAsmAarch32Coprocessor_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmAarch32Coprocessor -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmAarch32Coprocessor");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
        s & BOOST_SERIALIZATION_NVP(coprocessor_);
        debugSerializationEnd("SgAsmAarch32Coprocessor");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    int coprocessor_;

public:
    /** Property: Coprocessor number. 
     * 
     * @{ */
    int const& coprocessor() const;
    void coprocessor(int const&);
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmAarch32Coprocessor();

public:
    /** Default constructor. */
    SgAsmAarch32Coprocessor();

public:
    /** Constructor. */
    explicit SgAsmAarch32Coprocessor(int const& coprocessor);

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch32Coprocessor_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmExpression = nonTerminalConstructor(
    "AsmExpression",
    *this,
    "AsmExpression",
    "AsmExpressionTag",
    SubclassListBuilder()
        | AsmAarch32Coprocessor
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64AtOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64BarrierOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64CImmediateOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64PrefetchOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64PState
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64SysMoveOperand
#endif
        | AsmBinaryExpression
        | AsmByteOrder
        | AsmCommonSubExpression
        | AsmControlFlagsExpression
        | AsmExprListExp
        | AsmMemoryReferenceExpression
        | AsmRegisterNames
        | AsmRegisterReferenceExpression
        | AsmRiscOperation
        | AsmStackExpression
        | AsmUnaryExpression
        | AsmValueExpression
    , false);
assert(AsmExpression.associatedGrammar != nullptr);
AsmExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmExpression.isBoostSerializable(true);
AsmExpression.setAutomaticGenerationOfConstructor(false);
AsmExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmExpression.useSmallHeader(true);
#endif // !DOCUMENTATION

#ifdef DOCUMENTATION
/** Base class for expressions. */
class SgAsmExpression: public SgAsmNode {
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
    AsmExpression.setDataPrototype(
        "SgAsmType*", "type", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
    AsmExpression.setDataPrototype(
        "std::string", "comment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#endif // !DOCUMENTATION

    DECLARE_OTHERS(AsmExpression);
#if defined(SgAsmExpression_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmExpression -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmExpression");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        s & BOOST_SERIALIZATION_NVP(p_type);
        s & BOOST_SERIALIZATION_NVP(p_comment);
        debugSerializationEnd("SgAsmExpression");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
public:
    /** Property: Type of expression.
     *
     *  The type node is not considered a child of this node in the AST. 
     *  
     *  @{ */
    SgAsmType* const& get_type() const;
    void set_type(SgAsmType* const&);
    /** @} */

public:
    /** Property: Comment.
     *
     *  User-defined comment for an expression. 
     *  
     *  @{ */
    std::string const& get_comment() const;
    void set_comment(std::string const&);
    /** @} */
public:
    /** Property: Width of expression in bits.
     *
     *  Returns the width of the expression in bits according to its data type. The "type" property must be non-null. */
    size_t get_nBits() const;

    /** Return a constant if possible.
     *
     *  If this expression is an integer expression with a constant that fits in a 64-bit unsigned type, then return it,
     *  otherwise return nothing. */
    Sawyer::Optional<uint64_t> asUnsigned() const;

    /** Return a signed constant if possible.
     *
     *  If this expression is an integer expression with a constant that fits in a 64-bit signed type, then return it,
     *  otherwise return nothing. */
    Sawyer::Optional<int64_t> asSigned() const;

    /** Converts an expression to a string.
     *
     *  The string is a single line with no leading or trailing white space. This expression must be a child of a @ref
     *  SgAsmInstruction because the instruction set architecture might have an influence on the way the expression is displayed. Attempting
     *  to call this method on a detached expression will return the string "detached_expression". */
    virtual std::string toString() const;
public:
    /** Destructor. */
    virtual ~SgAsmExpression();

protected:
    /** Default constructor. */
    SgAsmExpression();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExpression_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef DOCUMENTATION
AstNodeClass& AsmNode = nonTerminalConstructor(
    "AsmNode",
    *this,
    "AsmNode",
    "AsmNodeTag",
    SubclassListBuilder()
        | AsmCilNode
        | AsmExecutableFileFormat
        | AsmExpression
        | AsmGenericFileList
        | AsmInstructionList
        | AsmInterpretation
        | AsmInterpretationList
        | AsmJvmNode
        | AsmOperandList
        | AsmStatement
        | AsmType
    , false);
assert(AsmNode.associatedGrammar != nullptr);
AsmNode.setCppCondition("!defined(DOCUMENTATION)");
AsmNode.isBoostSerializable(true);
AsmNode.setAutomaticGenerationOfConstructor(false);
AsmNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#ifndef DOCUMENTATION
AsmNode.useSmallHeader(true);
#endif // !DOCUMENTATION

DECLARE_HEADERS(AsmNode);
#if defined(SgAsmNode_HEADERS) || defined(DOCUMENTATION)
#include <Sawyer/Attribute.h>
#include <boost/format.hpp>
#endif // SgAsmNode_HEADERS

#ifdef DOCUMENTATION
/** Base class for all binary analysis IR nodes. */
class SgAsmNode: public SgNode {
#endif // DOCUMENTATION

    DECLARE_OTHERS(AsmNode);
#if defined(SgAsmNode_OTHERS) || defined(DOCUMENTATION)

    //----------------------- Boost serialization for SgAsmNode -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        debugSerializationBegin("SgAsmNode");
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgNode);
        debugSerializationEnd("SgAsmNode");
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB
public:
private:
    Sawyer::Attribute::Storage<> attributes_;

public:
    /** Attribute storage.
     *
     *  An attribute is extra user-defined data stored in an AST node.
     *
     *  Once ROSETTA is out of the picture, this interface will become cleaner because the typical way to add attribute storage to a
     *  type is to have the type be derived from @c Sawyer::Attribute::Storage. But as things stand now, ROSETTA doesn't support
     *  multiple inheritance and we must therefore use an awkward interface that reads like @c node->attributes().setAttribute(....)
     *  instead of the more streamlined @c node->setAttribute(....). 
     *  
     *  @{ */
    Sawyer::Attribute::Storage<> const& attributes() const;
    Sawyer::Attribute::Storage<>& attributes();
    /** @} */

public:
    /** Destructor. */
    virtual ~SgAsmNode();

protected:
    /** Default constructor. */
    SgAsmNode();

protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNode_OTHERS
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION

#ifndef DOCUMENTATION
} // Grammar::setUpBinaryInstructions
#endif // !DOCUMENTATION
#endif // defined(ROSE_ENABLE_BINARY_ANALYSIS)
