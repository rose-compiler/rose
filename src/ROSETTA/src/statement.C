#include "grammar.h"
#include "ROSETTA_macros.h"
#include "AstNodeClass.h"

/*
  DQ (3/2/2004): After March 1st meeting with Bjarne, it seems clear we should
                 support a few more IR nodes specific to templates.

     The idea here is to simplfy analysis and manipulation of templates.
It is not clear if this does not favor the relationship of a templated
class to template rather than to a class declaration.  We can only put the
IR node at one location in the hierarchy, but any choise is a compromise.

Fundamentally, is a template class declaration more of a template or a
class declaration?  Or should we go down the road of multiple inheritance
as a way to describe the template relationship the non-template IR nodes?

Possible Design of Template IR nodes:

    // parameters to template declaration
       TemplateParameters // new IR node to SAGE

    // arguments to template instantiations (not clear how to handle partial specialization)
       TemplateArguments // new IR node

    // Support for class templates
       TemplateDeclaration
            TemplateClassDeclaration
                 TemplateClassInstantiationDeclaration
                 TemplateClassSpecializationDeclaration                   // new IR node to SAGE
                      TemplateClassSpecializationInstantiationDeclaration // new IR node to SAGE
                 TemplateClassInstantiationDefinition

         // Support for function templates
            TemplateFunctionDeclaration
                 TemplateSpecializationFunctionDeclaration                   // new IR node to SAGE
                      TemplateSpecializationInstantiationFunctionDeclaration // new IR node to SAGE
                 TemplateInstantiationFunctionDeclaration
                 TemplateMemberFunctionDeclaration
                      TemplateSpecializationMemberFunctionDeclaration                   // new IR node to SAGE
                           TemplateSpecializationInstantiationMemberFunctionDeclaration // new IR node to SAGE
                      TemplateInstantiationMemberFunctionDeclaration

         // TemplateTemplateDeclaration
         // TemplateStaticDataMemberDeclaration

    NOTE: Current Design has TemplateClassInstantiationDeclaration derived from SgClassDeclaration
          This allows instiated templates to be treated as classes (which they are!).
 */

void
Grammar::setUpStatements ()
   {
  // This function sets up the type system for the grammar.  In this case it implements the
  // C++ grammar, but this will be modified to permit all grammars to contain elements of the
  // C++ grammar.  Modified grammars will add and subtract elements from this default C++ grammar.

     NEW_TERMINAL_MACRO (ForStatement,              "ForStatement",              "FOR_STMT");
     NEW_TERMINAL_MACRO (ForInitStatement,          "ForInitStatement",          "FOR_INIT_STMT" );

  // DQ (3/25/2018): Adding Range-based For statement support (previously missed in C++11 support).
     NEW_TERMINAL_MACRO (RangeBasedForStatement,    "RangeBasedForStatement",    "RANGE_BASED_FOR_STMT");

     NEW_TERMINAL_MACRO (CatchStatementSeq,         "CatchStatementSeq",         "CATCH_STATEMENT_SEQ" );
     NEW_TERMINAL_MACRO (FunctionParameterList,     "FunctionParameterList",     "FUNCTION_PARAMETER_LIST" );
     NEW_TERMINAL_MACRO (AdaParameterList,          "AdaParameterList",          "ADA_PARAMETER_LIST" );
     NEW_TERMINAL_MACRO (CtorInitializerList,       "CtorInitializerList",       "CTOR_INITIALIZER_LIST" );
     NEW_TERMINAL_MACRO (BasicBlock,                "BasicBlock",                "BASIC_BLOCK_STMT");
     NEW_TERMINAL_MACRO (Global,                    "Global",                    "GLOBAL_STMT" );
     NEW_TERMINAL_MACRO (IfStmt,                    "IfStmt",                    "IF_STMT" );

  // DQ (7/25/2020): Adding C++17 constexpr_if statement.
  // NEW_TERMINAL_MACRO (IfConstexprStatement,      "IfConstexprStatement",      "IF_CONSTEXPR_STATEMENT" );

  // NEW_TERMINAL_MACRO (FunctionDefinition,        "FunctionDefinition",        "FUNC_DEFN_STMT" );
     NEW_TERMINAL_MACRO (WhileStmt,                 "WhileStmt",                 "WHILE_STMT" );
     NEW_TERMINAL_MACRO (DoWhileStmt,               "DoWhileStmt",               "DO_WHILE_STMT" );
     NEW_TERMINAL_MACRO (SwitchStatement,           "SwitchStatement",           "SWITCH_STMT" );
     NEW_TERMINAL_MACRO (CatchOptionStmt,           "CatchOptionStmt",           "CATCH_STMT" );

  // DQ (2/10/2016): Adding support for C99 function parameter references in nondefining function declarations.
     NEW_TERMINAL_MACRO (FunctionParameterScope,    "FunctionParameterScope",    "FUNCTION_PARAMETER_SCOPE" );

  // DQ (7/17/2017): Adding support for a new concept of declaration scope.  This allows the declaration to
  // have a scope which would be used for declarations generated by the non-defining declaration (examples
  // are classes built as part of processing a nondefining template class declaration (see test2017_44.C and
  // test2017_47.C).  the purpose of this scope is similar to the unused FunctionParameterScope (above),
  // which was developed to support the case of "void foobar (int n, int array[n]);" type declarations
  // which are allowed in C99, but not in C++.  This nondefining (prototype) declaration works in ROSE,
  // but is still assigned the scope of the function parameters to global scope (but not assigning symbols
  // for them, so working OK, but is still not ideal).  The case of templates generating class declarations
  // (which in EDG are listed as proxy and nonreal classes) requires a better fix to support getting the
  // name qualification correct.  This is part of fixing a bug in the "backstroke" project (the last one
  // known for ROSE's support of that project).
     NEW_TERMINAL_MACRO (DeclarationScope,    "DeclarationScope",    "DECLARATION_SCOPE" );

     NEW_TERMINAL_MACRO (VariableDefinition,        "VariableDefinition",        "VAR_DEFN_STMT" );
  // NEW_TERMINAL_MACRO (ClassDeclaration,          "ClassDeclaration",          "CLASS_DECL_STMT" );
  // NEW_TERMINAL_MACRO (ClassDefinition,           "ClassDefinition",           "CLASS_DEFN_STMT" );
     NEW_TERMINAL_MACRO (StmtDeclarationStatement,  "StmtDeclarationStatement",  "STMT_DECL_STMT" );
     NEW_TERMINAL_MACRO (EnumDeclaration,           "EnumDeclaration",           "ENUM_DECL_STMT" );

  // DQ (1/25/2017): Adding support for C++11 strongly typed enums ("enum class" or "enum struct").
  // NEW_TERMINAL_MACRO (StronglyTypedEnumDeclaration, "StronglyTypedEnumDeclaration", "STRONGLY_TYPED_ENUM_DECL_STMT" );

     NEW_TERMINAL_MACRO (AsmStmt,                   "AsmStmt",                   "ASM_STMT" );
     NEW_TERMINAL_MACRO (FunctionTypeTable,         "FunctionTypeTable",         "FUNC_TBL_STMT" );
     NEW_TERMINAL_MACRO (ExprStatement,             "ExprStatement",             "EXPR_STMT" );
     NEW_TERMINAL_MACRO (LabelStatement,            "LabelStatement",            "LABEL_STMT" );
     NEW_TERMINAL_MACRO (CaseOptionStmt,            "CaseOptionStmt",            "CASE_STMT" );
     NEW_TERMINAL_MACRO (TryStmt,                   "TryStmt",                   "TRY_STMT" );
     NEW_TERMINAL_MACRO (DefaultOptionStmt,         "DefaultOptionStmt",         "DEFAULT_STMT" );
     NEW_TERMINAL_MACRO (BreakStmt,                 "BreakStmt",                 "BREAK_STMT" );
     NEW_TERMINAL_MACRO (ContinueStmt,              "ContinueStmt",              "CONTINUE_STMT" );
     NEW_TERMINAL_MACRO (ReturnStmt,                "ReturnStmt",                "RETURN_STMT" );
     NEW_TERMINAL_MACRO (GotoStatement,             "GotoStatement",             "GOTO_STMT" );
     NEW_TERMINAL_MACRO (AdaExitStmt,               "AdaExitStmt",               "ADA_EXIT_STMT" );
     NEW_TERMINAL_MACRO (AdaLoopStmt,               "AdaLoopStmt",               "ADA_LOOP_STMT" );
     NEW_TERMINAL_MACRO (AdaDelayStmt,              "AdaDelayStmt",              "ADA_DELAY_STMT" );
     NEW_TERMINAL_MACRO (AdaSelectStmt,             "AdaSelectStmt",             "ADA_SELECT_STMT" );
     NEW_TERMINAL_MACRO (AdaSelectAlternativeStmt,  "AdaSelectAlternativeStmt",  "ADA_SELECT_ALTERNATIVE_STMT" );
     NEW_TERMINAL_MACRO (AdaTerminateStmt,          "AdaTerminateStmt",          "ADA_TERMINATE_STMT" );
     NEW_TERMINAL_MACRO (AdaUnscopedBlock,          "AdaUnscopedBlock",          "ADA_UNSCOPED_BLOCK" );
     NEW_TERMINAL_MACRO (AdaVariantWhenStmt,        "AdaVariantWhenStmt",        "ADA_VARIANT_WHEN_STMT" );
     NEW_TERMINAL_MACRO (SpawnStmt,                 "SpawnStmt",                 "SPAWN_STMT" );

  // Fortran continue statement has different semantics from C/C++ continue statement [Rasmussen 6/10/2023]
     NEW_TERMINAL_MACRO (FortranContinueStmt,       "FortranContinueStmt",       "FORTRAN_CONTINUE_STMT");

  // DQ (10/14/2014): Added template typedef as part of C++11 support.
  // NEW_TERMINAL_MACRO (TypedefDeclaration,        "TypedefDeclaration",        "TYPEDEF_STMT" );
     NEW_TERMINAL_MACRO (TemplateTypedefDeclaration, "TemplateTypedefDeclaration",    "TEMPLATE_TYPEDEF_DECL_STMT" );
     NEW_TERMINAL_MACRO (TemplateInstantiationTypedefDeclaration, "TemplateInstantiationTypedefDeclaration", "TEMPLATE_INST_TYPEDEF_DECL_STMT" );
     NEW_NONTERMINAL_MACRO (TypedefDeclaration, TemplateTypedefDeclaration | TemplateInstantiationTypedefDeclaration, "TypedefDeclaration", "TYPEDEF_STMT", true );

  // DQ (12/13/2005): Added support for empty statement (and empty expression).
     NEW_TERMINAL_MACRO (NullStatement,             "NullStatement",             "NULL_STMT" );

  // DQ (12/13/2005): Added variant statement to support future patterns
  // specifications (contains RegEx string specifier for SgStatement IR node).
     NEW_TERMINAL_MACRO (VariantStatement,          "VariantStatement",          "VARIANT_STMT" );

  // Addition to SAGE3 (not present in SAGE2) this permits the representation of unbound pragmas in SAGE3
  // NEW_TERMINAL_MACRO (PragmaStatement, "PragmaStatement", "PRAGMA_STMT" );
     NEW_TERMINAL_MACRO (PragmaDeclaration, "PragmaDeclaration", "PRAGMA_DECL" );


  // Added template support
  // Note: TemplateInstantiationDecl should have been called TemplateClassInstantiationDecl
  //       to better match TemplateInstantiationFunctionDecl (suggested name change).

  // DQ (6/10/2011): Added more IR nodes specific to template declarations. Note that later we want
  // TemplateDeclaration to not be allowed so that we can force the derived IR nodes to be used instead.
  // NEW_TERMINAL_MACRO (TemplateDeclaration,       "TemplateDeclaration",       "TEMPLATE_DECL_STMT" );
     NEW_TERMINAL_MACRO (TemplateClassDeclaration,    "TemplateClassDeclaration",    "TEMPLATE_CLASS_DECL_STMT" );
  // NEW_TERMINAL_MACRO (TemplateFunctionDeclaration, "TemplateFunctionDeclaration", "TEMPLATE_FUNCTION_DECL_STMT" );
     NEW_TERMINAL_MACRO (TemplateMemberFunctionDeclaration, "TemplateMemberFunctionDeclaration", "TEMPLATE_MEMBER_FUNCTION_DECL_STMT" );

     NEW_TERMINAL_MACRO (TemplateFunctionDeclaration, "TemplateFunctionDeclaration", "TEMPLATE_FUNCTION_DECL_STMT" );

  // DQ (12/6/2011): Adding support for template variables (static data members).
     NEW_TERMINAL_MACRO (TemplateVariableDeclaration, "TemplateVariableDeclaration",    "TEMPLATE_VARIABLE_DECL_STMT" );

  // DQ (12/21/2011): This is the newer design, we want template declaration to act just like functions and classes since they are used as such in the AST
  // representation of the template declaration.  In this case a template function declaration is more like a function declaration than a template declaration.
     NEW_TERMINAL_MACRO (TemplateDeclaration, "TemplateDeclaration", "TEMPLATE_DECL_STMT");

  // DQ (12/21/2011): Newer version of code.
     NEW_NONTERMINAL_MACRO (VariableDeclaration, TemplateVariableDeclaration,
           "VariableDeclaration",       "VAR_DECL_STMT", true );

     NEW_TERMINAL_MACRO (TemplateInstantiationDecl, "TemplateInstantiationDecl", "TEMPLATE_INST_DECL_STMT" );
     NEW_TERMINAL_MACRO (TemplateInstantiationDefn, "TemplateInstantiationDefn", "TEMPLATE_INST_DEFN_STMT" );
     NEW_TERMINAL_MACRO (TemplateInstantiationFunctionDecl,
                         "TemplateInstantiationFunctionDecl", "TEMPLATE_INST_FUNCTION_DECL_STMT" );
     NEW_TERMINAL_MACRO (TemplateInstantiationMemberFunctionDecl,
                         "TemplateInstantiationMemberFunctionDecl", "TEMPLATE_INST_MEMBER_FUNCTION_DECL_STMT" );

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     NEW_TERMINAL_MACRO ( NonrealDecl, "NonrealDecl", "NONREAL_DECL" );

  // driscoll6 (6/27/11): Support for Python
     NEW_TERMINAL_MACRO (WithStatement,             "WithStatement",             "WITH_STATEMENT" );
     NEW_TERMINAL_MACRO (PythonGlobalStmt,          "PythonGlobalStmt",          "PYTHON_GLOBAL_STMT" );
     NEW_TERMINAL_MACRO (PythonPrintStmt,           "PythonPrintStmt",           "PYTHON_PRINT_STMT" );
     NEW_TERMINAL_MACRO (PassStatement,             "PassStatement",             "PASS_STATEMENT" );
     NEW_TERMINAL_MACRO (AssertStmt,                "AssertStmt",                "ASSERT_STMT" );
     NEW_TERMINAL_MACRO (ExecStatement,             "ExecStatement",             "EXEC_STMT" );

#if USE_FORTRAN_IR_NODES
  // Fortran language constructs that map directly to C/C++ IR nodes:
  //    Fortran: cycle        --> C: continue
  //    Fortran: exit         --> C: break
  //    Fortran: select case  --> C: switch
  //    Fortran: case         --> C: case option
  //    Fortran: case default --> C: default
  //    Fortran: type         --> C: struct
  //    Fortran: sequence     --> C: ???
  //    Fortran:   --> C:

  // DQ (2/2/2006): Support for Fortran IR nodes
     NEW_TERMINAL_MACRO (ProgramHeaderStatement,    "ProgramHeaderStatement",    "PROGRAM_HEADER_STMT" );
     NEW_TERMINAL_MACRO (ProcedureHeaderStatement,  "ProcedureHeaderStatement",  "PROCEDURE_HEADER_STMT" );
     NEW_TERMINAL_MACRO (EntryStatement,            "EntryStatement",            "ENTRY_STMT" );
     NEW_TERMINAL_MACRO (FortranNonblockedDo,       "FortranNonblockedDo",       "FORTRAN_NONBLOCKED_DO" );
     NEW_TERMINAL_MACRO (InterfaceStatement,        "InterfaceStatement",        "INTERFACE_STATEMENT" );
     NEW_TERMINAL_MACRO (ParameterStatement,        "ParameterStatement",        "PARAMETER_STATEMENT" );
     NEW_TERMINAL_MACRO (CommonBlock,               "CommonBlock",               "COMMON_BLOCK" );
     NEW_TERMINAL_MACRO (ModuleStatement,           "ModuleStatement",           "MODULE_STATEMENT" );
     NEW_TERMINAL_MACRO (UseStatement,              "UseStatement",              "USE_STATEMENT" );
     NEW_TERMINAL_MACRO (ProcessControlStatement,   "ProcessControlStatement",   "PROCESS_CONTROL_STATEMENT" );

  // DQ (11/25/2007): Make this the base class of all the IR nodes for Fortran I/O
  // NEW_TERMINAL_MACRO (IOStatement,               "IOStatement",               "IO_STATEMENT" );

  // NEW_TERMINAL_MACRO (InputOutputStatement,      "InputOutputStatement",      "INPUT_OUTPUT_STATEMENT" );
     NEW_TERMINAL_MACRO (PrintStatement,            "PrintStatement",            "PRINT_STATEMENT" );
     NEW_TERMINAL_MACRO (ReadStatement,             "ReadStatement",             "READ_STATEMENT" );
     NEW_TERMINAL_MACRO (WriteStatement,            "WriteStatement",            "WRITE_STATEMENT" );
     NEW_TERMINAL_MACRO (OpenStatement,             "OpenStatement",             "OPEN_STATEMENT" );
     NEW_TERMINAL_MACRO (CloseStatement,            "CloseStatement",            "CLOSE_STATEMENT" );
     NEW_TERMINAL_MACRO (InquireStatement,          "InquireStatement",          "INQUIRE_STATEMENT" );
     NEW_TERMINAL_MACRO (FlushStatement,            "FlushStatement",            "FLUSH_STATEMENT" );
     NEW_TERMINAL_MACRO (BackspaceStatement,        "BackspaceStatement",        "BACKSPACE_STATEMENT" );
     NEW_TERMINAL_MACRO (RewindStatement,           "RewindStatement",           "REWIND_STATEMENT" );
     NEW_TERMINAL_MACRO (EndfileStatement,          "EndfileStatement",          "ENDFILE_STATEMENT" );
     NEW_TERMINAL_MACRO (WaitStatement,             "WaitStatement",             "WAIT_STATEMENT" );

  // FMZ (2/3/2009): Added co-array "withteam" stmt
  //  NEW_TERMINAL_MACRO (WithTeamStatement,         "WithTeamStatement",         "WITHTEAM_DECL_STMT" );
  // FMZ (2/17/2009): We re-defined "withteam" stmt
     NEW_TERMINAL_MACRO (CAFWithTeamStatement,         "CAFWithTeamStatement",         "WITHTEAM_STMT" );

  // DQ (12/18/2007): Added support for Fortran Format statement
     NEW_TERMINAL_MACRO (FormatStatement,           "FormatStatement",           "FORMAT_STATEMENT" );

  // DQ (3/22/2007): Added Fortran non-blocked do statement (derived from FortranDo)
     NEW_NONTERMINAL_MACRO (FortranDo, FortranNonblockedDo, "FortranDo", "FORTRAN_DO", true);

     NEW_TERMINAL_MACRO (ForAllStatement,  "ForAllStatement",              "FOR_ALL_STMT");

     NEW_NONTERMINAL_MACRO (IOStatement,
       // InputOutputStatement | OpenStatement | CloseStatement | InquireStatement | IOFileControlStmt,
          PrintStatement   | ReadStatement  | WriteStatement     | OpenStatement   | CloseStatement   |
          InquireStatement | FlushStatement | BackspaceStatement | RewindStatement | EndfileStatement |
          WaitStatement,
          "IOStatement", "IO_STATEMENT", false);

  // Rasmussen (9/25/2018): Fortran 2018 nodes related to synchronization
     NEW_TERMINAL_MACRO (SyncAllStatement,     "SyncAllStatement",            "SYNC_ALL_STATEMENT" );
     NEW_TERMINAL_MACRO (SyncImagesStatement,  "SyncImagesStatement",         "SYNC_IMAGES_STATEMENT" );
     NEW_TERMINAL_MACRO (SyncMemoryStatement,  "SyncMemoryStatement",         "SYNC_MEMORY_STATEMENT" );
     NEW_TERMINAL_MACRO (SyncTeamStatement,    "SyncTeamStatement",           "SYNC_TEAM_STATEMENT" );
     NEW_TERMINAL_MACRO (LockStatement,        "LockStatement",               "LOCK_STATEMENT" );
     NEW_TERMINAL_MACRO (UnlockStatement,      "UnlockStatement",             "UNLOCK_STATEMENT" );

     NEW_NONTERMINAL_MACRO (ImageControlStatement,
          SyncAllStatement | SyncImagesStatement | SyncMemoryStatement | SyncTeamStatement |
          LockStatement    | UnlockStatement,
          "ImageControlStatement", "IMAGE_CONTROL_STATEMENT", false);
#endif

     NEW_TERMINAL_MACRO (JovialCompoolStatement, "JovialCompoolStatement", "JOVIAL_COMPOOL_STATEMENT" );
     NEW_TERMINAL_MACRO (JovialDefineDeclaration,  "JovialDefineDeclaration",  "JOVIAL_DEFINE_DECLARATION" );
     NEW_TERMINAL_MACRO (JovialDirectiveStatement, "JovialDirectiveStatement", "JOVIAL_DIRECTIVE_STATEMENT" );
     NEW_TERMINAL_MACRO (JovialLabelDeclaration,   "JovialLabelDeclaration",   "JOVIAL_LABEL_DECLARATION" );

  // Rasmussen (5/17/2020): Jovial overlays are used to control memory layout.
     NEW_TERMINAL_MACRO (JovialOverlayDeclaration, "JovialOverlayDeclaration", "JOVIAL_OVERLAY_DECLARATION" );

  // Rasmussen (10/22/2018): Node specific to Jovial for statements with a then construct.
     NEW_TERMINAL_MACRO (JovialForThenStatement, "JovialForThenStatement", "JOVIAL_FOR_THEN_STATEMENT");


     //SK(08/20/2015): Matlab For-loop
     NEW_TERMINAL_MACRO (MatlabForStatement,    "MatlabForStatement",    "MATLAB_FOR_STATEMENT");


#if USE_UPC_IR_NODES
  // DQ and Liao (6/10/2008): Added new IR nodes specific to UPC.
     NEW_TERMINAL_MACRO (UpcNotifyStatement,    "UpcNotifyStatement",    "UPC_NOTIFY_STMT" );
     NEW_TERMINAL_MACRO (UpcWaitStatement,      "UpcWaitStatement",      "UPC_WAIT_STMT" );
     NEW_TERMINAL_MACRO (UpcBarrierStatement,   "UpcBarrierStatement",   "UPC_BARRIER_STMT" );
     NEW_TERMINAL_MACRO (UpcFenceStatement,     "UpcFenceStatement",     "UPC_FENCE_STMT" );
     NEW_TERMINAL_MACRO (UpcForAllStatement,    "UpcForAllStatement",    "UPC_FORALL_STMT" );
#endif

// Common OpenMP nodes for both C/C++ and Fortran, Liao, 5/29/2009
#if USE_OMP_IR_NODES
     // define terminals and non-terminals  and their hierarchy
     //------------------------------------------------------------
    // +body+ clauses
    NEW_TERMINAL_MACRO (OmpParallelStatement,  "OmpParallelStatement",   "OMP_PARALLEL_STMT" );
    NEW_TERMINAL_MACRO (OmpSingleStatement,    "OmpSingleStatement",     "OMP_SINGLE_STMT" );
    NEW_TERMINAL_MACRO (OmpTaskStatement,      "OmpTaskStatement",       "OMP_TASK_STMT" );
    NEW_TERMINAL_MACRO (OmpForStatement,       "OmpForStatement",        "OMP_FOR_STMT" );
    NEW_TERMINAL_MACRO (OmpForSimdStatement,   "OmpForSimdStatement",     "OMP_FOR_SIMD_STMT" );
    NEW_TERMINAL_MACRO (OmpDoStatement,        "OmpDoStatement",         "OMP_DO_STMT" );
    NEW_TERMINAL_MACRO (OmpSectionsStatement,  "OmpSectionsStatement",   "OMP_SECTIONS_STMT" );
    // OpenMP 4.x : atomic can have clause now.
    NEW_TERMINAL_MACRO (OmpAtomicStatement,    "OmpAtomicStatement",    "OMP_ATOMIC_STMT" );
     // experimental omp target directive, Liao 1/22/2012
     // use for testing OpenMP accelerator model
    NEW_TERMINAL_MACRO (OmpTargetStatement,  "OmpTargetStatement",   "OMP_TARGET_STMT" );
    NEW_TERMINAL_MACRO (OmpTargetDataStatement,  "OmpTargetDataStatement",   "OMP_TARGET_DATA_STMT" );

    NEW_TERMINAL_MACRO (OmpSimdStatement,    "OmpSimdStatement",     "OMP_SIMD_STMT" );

    // A base class for the most commonly formed directives with both clauses and a structured body
    // We treat OmpSectionsStatement separatedly by move the body to a list of SgOmpSectionStatement
    // sensitive to
    NEW_NONTERMINAL_MACRO (OmpClauseBodyStatement,  OmpParallelStatement | OmpSingleStatement | OmpAtomicStatement |
              OmpTaskStatement| OmpForStatement| OmpDoStatement | OmpSectionsStatement | OmpTargetStatement| OmpTargetDataStatement |
              OmpSimdStatement| OmpForSimdStatement ,
        "OmpClauseBodyStatement",   "OMP_CLAUSEBODY_STMT", false );

    // + a statement / block
    NEW_TERMINAL_MACRO (OmpMasterStatement,    "OmpMasterStatement",    "OMP_MASTER_STMT" );
    NEW_TERMINAL_MACRO (OmpSectionStatement,   "OmpSectionStatement",    "OMP_SECTION_STMT" ); // need this?
    NEW_TERMINAL_MACRO (OmpOrderedStatement,   "OmpOrderedStatement",   "OMP_ORDERED_STMT" );
    NEW_TERMINAL_MACRO (OmpWorkshareStatement,    "OmpWorkshareStatement",    "OMP_WORKSHARE_STMT" );
    // + stmt/block + name
    NEW_TERMINAL_MACRO (OmpCriticalStatement,  "OmpCriticalStatement",   "OMP_CRITICAL_STMT" );

    // A base class for all directives with a body/statement
    NEW_NONTERMINAL_MACRO (OmpBodyStatement,  OmpMasterStatement  | OmpOrderedStatement
        | OmpCriticalStatement   |  OmpSectionStatement | OmpWorkshareStatement  | OmpClauseBodyStatement ,
        "OmpBodyStatement",      "OMP_BODY_STMT", false );


#endif

#include "java/terminals.cpp"
#include "x10/terminals.cpp"


  // DQ (8/21/2007): More IR nodes required for Fortran support
     NEW_TERMINAL_MACRO (BlockDataStatement,        "BlockDataStatement",         "TEMP_Block_Data_Statement" );
     NEW_TERMINAL_MACRO (ImplicitStatement,         "ImplicitStatement",          "TEMP_Implicit_Statement" );
     NEW_TERMINAL_MACRO (StatementFunctionStatement,"StatementFunctionStatement", "TEMP_Statement_Function_Statement" );
     NEW_TERMINAL_MACRO (WhereStatement,            "WhereStatement",             "TEMP_Where_Statement" );
     NEW_TERMINAL_MACRO (NullifyStatement,          "NullifyStatement",           "TEMP_Nullify_Statement" );
     NEW_TERMINAL_MACRO (EquivalenceStatement,      "EquivalenceStatement",       "TEMP_Equivalence_Statement" );
     NEW_TERMINAL_MACRO (DerivedTypeStatement,      "DerivedTypeStatement",       "TEMP_Derived_Type_Statement" );

  // Rasmussen (3/18/2019): New IR node for Jovial tables (arrays of structs)
     NEW_TERMINAL_MACRO (JovialTableStatement,      "JovialTableStatement",       "TEMP_Jovial_Table_Statement" );

  // DQ (9/4/2007): Added DIMENSION statement (for array declaration support)
  // These are the type attributes: ALLOCATABLE, DIMENSION, EXTERNAL, INTENT, INTRINSIC, OPTIONAL, PARAMETER, POINTER, SAVE, TARGET
  // These are the ones that have associated statements: ALLOCATE, DIMENSION, EXTERNAL, INTRINSIC, OPTIONAL, PARAMETER, POINTER, SAVE, TARGET
  // Attributes that are not an associated statement: INTENT
  // Paired statements: ALLOCATE, DEALLOCATE
  // Additional statements that I expect we will require: AccessStatement, AllocatableStatement, AllocateStatement,
  //    AsynchronousStatement, BindStatement, DataStatement, DeallocateStatement, DimensionStatement, ContainsStatement,
  //    ValueStatement, VolatileStatement, ExternalStatement, IntentStatement, IntrinsicStatement, OptionalStatement,
  //    PointerStatement, ProtectedStatement, SaveStatement, SequenceStatement, TargetStatement

  // Alternatively we could defined an AttributeSpecificationStatement to be:
  //      AccessStatement, AllocatableStatement, AsynchronousStatement, BindStatement, DataStatement, DimensionStatement,
  //      IntentStatement, IntrinsicStatement, OptionalStatement, ParameterStatement, PointerStatement, ProtectedStatement, SaveStatement,
  //      TargetStatement, ValueStatement, VolatileStatement
  // And then define separate statements for: AllocateStatement, DeallocateStatement, ContainsStatement, SequenceStatement

     NEW_TERMINAL_MACRO (AttributeSpecificationStatement, "AttributeSpecificationStatement",   "TEMP_Attribute_Specification_Statement" );
     NEW_TERMINAL_MACRO (AllocateStatement,        "AllocateStatement",         "TEMP_Allocate_Statement" );
     NEW_TERMINAL_MACRO (DeallocateStatement,      "DeallocateStatement",       "TEMP_Deallocate_Statement" );
     NEW_TERMINAL_MACRO (ContainsStatement,        "ContainsStatement",         "TEMP_Contains_Statement" );
     NEW_TERMINAL_MACRO (SequenceStatement,        "SequenceStatement",         "TEMP_Sequence_Statement" );

  // DQ (9/23/2007): Added elsewhere IR node to handle cascading elsewhere in where statement
     NEW_TERMINAL_MACRO (ElseWhereStatement,       "ElseWhereStatement",        "TEMP_Else_Where_Statement" );

  // Required for F77 support (but deprecated in F90)
     NEW_TERMINAL_MACRO (ArithmeticIfStatement,     "ArithmeticIfStatement",      "TEMP_Arithmetic_If_Statement" );
     NEW_TERMINAL_MACRO (AssignStatement,           "AssignStatement",            "TEMP_Assign_Statement" );
     NEW_TERMINAL_MACRO (ComputedGotoStatement,     "ComputedGotoStatement",      "TEMP_Computed_Goto_Statement" );
     NEW_TERMINAL_MACRO (AssignedGotoStatement,     "AssignedGotoStatement",      "TEMP_Assigned_Goto_Statement" );

     NEW_TERMINAL_MACRO (NamelistStatement,         "NamelistStatement",          "TEMP_Namelist_Statement" );
     NEW_TERMINAL_MACRO (ImportStatement,           "ImportStatement",            "TEMP_Import_Statement" );

  // DQ (11/30/2007): Added new IR node to support "associate" statement (F2003)
     NEW_TERMINAL_MACRO (AssociateStatement,        "AssociateStatement",         "TEMP_Associate_Statement" );

  // DQ (2/18/2008): Added support for language specific Fortran include line (not a statement in Fortran,
  // but a declaration statement in ROSE similar to the CPP IncludeDirectiveStatement).
     NEW_TERMINAL_MACRO (FortranIncludeLine,        "FortranIncludeLine",         "TEMP_Fortran_Include_Line" );

  // NEW_TERMINAL_MACRO (ClinkageStartStatement, "ClinkageStartStatement", "C_LINKAGE_START_STMT" );

  // DQ (4/19/2004): Support for namespaces: NamespaceDeclarationStatement,
  //      NamespaceAliasDeclarationStatement, UsingDeclarationStatement
     NEW_TERMINAL_MACRO (NamespaceDeclarationStatement,"NamespaceDeclarationStatement","NAMESPACE_DECLARATION_STMT" );
     NEW_TERMINAL_MACRO (NamespaceAliasDeclarationStatement,
                         "NamespaceAliasDeclarationStatement",
                         "NAMESPACE_ALIAS_DECLARATION_STMT");
     NEW_TERMINAL_MACRO (NamespaceDefinitionStatement,"NamespaceDefinitionStatement","NAMESPACE_DEFINITION_STMT" );
     NEW_TERMINAL_MACRO (UsingDeclarationStatement, "UsingDeclarationStatement", "USING_DECLARATION_STMT" );
     NEW_TERMINAL_MACRO (UsingDirectiveStatement,   "UsingDirectiveStatement",   "USING_DIRECTIVE_STMT"   );

  // DQ (4/16/2005): Added specific support in the IR for explicit template instantiation directives (to fix linking issues)
     NEW_TERMINAL_MACRO (TemplateInstantiationDirectiveStatement, "TemplateInstantiationDirectiveStatement", "TEMPLATE_INST_DIRECTIVE_STMT" );

  // DQ (7/25/2014): Adding support for C11 static assertions (as declarations).
     NEW_TERMINAL_MACRO (StaticAssertionDeclaration,   "StaticAssertionDeclaration",   "STATIC_ASSERTION_DECLARATION"   );

  // DQ (6/10/2011): Added template specific definitions.
     NEW_TERMINAL_MACRO (TemplateClassDefinition,          "TemplateClassDefinition",    "TEMPLATE_CLASS_DEF_STMT" );
     NEW_TERMINAL_MACRO (TemplateFunctionDefinition,       "TemplateFunctionDefinition", "TEMPLATE_FUNCTION_DEF_STMT" );

  // DQ (12/21/2011): New design...
     NEW_NONTERMINAL_MACRO (ClassDeclaration,
          TemplateClassDeclaration | TemplateInstantiationDecl | DerivedTypeStatement | ModuleStatement | JavaPackageDeclaration | JovialTableStatement,
          "ClassDeclaration", "CLASS_DECL_STMT", true );
  // NEW_NONTERMINAL_MACRO (ClassDefinition,  TemplateInstantiationDefn, "ClassDefinition",  "CLASS_DEFN_STMT", true );
     NEW_NONTERMINAL_MACRO (ClassDefinition,  TemplateInstantiationDefn | TemplateClassDefinition, "ClassDefinition",  "CLASS_DEFN_STMT", true );

  // DQ (6/10/2011): Changed this to be a non-AstNodeClass and added TemplateFunctionDefinition
     NEW_NONTERMINAL_MACRO (FunctionDefinition, TemplateFunctionDefinition, "FunctionDefinition",  "FUNC_DEFN_STMT", true );

  // PP 05/07/20: Add Ada nodes
     NEW_TERMINAL_MACRO (AdaAcceptStmt,  "AdaAcceptStmt", "ADA_ACCEPT_STMT" );
     NEW_TERMINAL_MACRO (AdaPackageBody, "AdaPackageBody", "ADA_PACKAGE_BODY");
     NEW_TERMINAL_MACRO (AdaPackageSpec, "AdaPackageSpec", "ADA_PACKAGE_SPEC");
     NEW_TERMINAL_MACRO (AdaTaskBody,    "AdaTaskBody",    "ADA_TASK_BODY");
     NEW_TERMINAL_MACRO (AdaTaskSpec,    "AdaTaskSpec",    "ADA_TASK_SPEC");
     NEW_TERMINAL_MACRO (AdaProtectedBody, "AdaProtectedBody", "ADA_PROTECTED_BODY");
     NEW_TERMINAL_MACRO (AdaProtectedSpec, "AdaProtectedSpec", "ADA_PROTECTED_SPEC");
     NEW_TERMINAL_MACRO (AdaGenericDefn, "AdaGenericDefn", "ADA_GENERIC_DEFN" );

  // Note that the associate statement is really a scope, with its own declarations of variables declared by reference to
  // other variables or expressions.  They are only l-values if and only if the rhs is a l-value (I think).
  // Rasmussen (10/22/2018): Added JovialForThenStatement
     NEW_NONTERMINAL_MACRO (ScopeStatement,
          Global                       | BasicBlock           | IfStmt                    | /* IfConstexprStatement   | */
          ForStatement                 | FunctionDefinition   |
          ClassDefinition              | WhileStmt            | DoWhileStmt               | SwitchStatement        | CatchOptionStmt    |
          NamespaceDefinitionStatement | BlockDataStatement   | AssociateStatement        | FortranDo              | ForAllStatement    |
          UpcForAllStatement           | CAFWithTeamStatement | JavaForEachStatement      | JavaLabelStatement     | MatlabForStatement |
          FunctionParameterScope       | DeclarationScope     | RangeBasedForStatement    | JovialForThenStatement | AdaAcceptStmt  |
          AdaPackageSpec               | AdaPackageBody       | AdaTaskSpec               | AdaTaskBody            | AdaProtectedBody |
          AdaProtectedSpec             | AdaGenericDefn
     /* | TemplateInstantiationDefn */ ,
          "ScopeStatement","SCOPE_STMT", false);

  // DQ (3/22/2004): Added to support template member functions (removed MemberFunctionDeclaration as AstNodeClass)
  // DQ (12/21/2011): New design...
     NEW_NONTERMINAL_MACRO (MemberFunctionDeclaration, TemplateMemberFunctionDeclaration | TemplateInstantiationMemberFunctionDecl,"MemberFunctionDeclaration","MFUNC_DECL_STMT", true);

  // PP 08/05/20 Ada Nodes
     NEW_TERMINAL_MACRO (AdaEntryDecl,            "AdaEntryDecl",            "ADA_ENTRY_DECL_STMT" );
  // MS 12/20/20 Ada Nodes
     NEW_TERMINAL_MACRO (AdaFunctionRenamingDecl, "AdaFunctionRenamingDecl", "ADA_FUNCTION_RENAMING_DECL_STMT" );

  // DQ (3/20/2007): ProgramHeaderStatement and ProcedureHeaderStatement are derived from FunctionDeclaration
  // DQ (12/21/2011): New design...
     NEW_NONTERMINAL_MACRO (FunctionDeclaration,
          TemplateFunctionDeclaration | MemberFunctionDeclaration | TemplateInstantiationFunctionDecl | ProgramHeaderStatement |
          ProcedureHeaderStatement    | EntryStatement            | AdaEntryDecl                      | AdaFunctionRenamingDecl ,
          "FunctionDeclaration","FUNC_DECL_STMT", true);

  // DQ (8/17/2007): Added CPP directives back into the IR to better support analysis and transformations.
     NEW_TERMINAL_MACRO (IncludeDirectiveStatement,     "IncludeDirectiveStatement", "INCLUDE_DIRECTIVE_STMT" );
     NEW_TERMINAL_MACRO (DefineDirectiveStatement,      "DefineDirectiveStatement",      "DEFINE_DIRECTIVE_STMT"  );
     NEW_TERMINAL_MACRO (UndefDirectiveStatement,       "UndefDirectiveStatement",       "UNDEF_DIRECTIVE_STMT"   );
     NEW_TERMINAL_MACRO (IfdefDirectiveStatement,       "IfdefDirectiveStatement",       "IFDEF_DIRECTIVE_STMT"   );
     NEW_TERMINAL_MACRO (IfndefDirectiveStatement,      "IfndefDirectiveStatement",      "IFNDEF_DIRECTIVE_STMT"  );
     NEW_TERMINAL_MACRO (IfDirectiveStatement,          "IfDirectiveStatement",          "IF_DIRECTIVE_STMT"      );
     NEW_TERMINAL_MACRO (DeadIfDirectiveStatement,      "DeadIfDirectiveStatement",      "DEAD_IF_DIRECTIVE_STMT" );
     NEW_TERMINAL_MACRO (ElseDirectiveStatement,        "ElseDirectiveStatement",        "ELSE_DIRECTIVE_STMT"    );
     NEW_TERMINAL_MACRO (ElseifDirectiveStatement,      "ElseifDirectiveStatement",      "ELSEIF_DIRECTIVE_STMT"  );
     NEW_TERMINAL_MACRO (EndifDirectiveStatement,       "EndifDirectiveStatement",       "ENDIF_DIRECTIVE_STMT"   );
     NEW_TERMINAL_MACRO (LineDirectiveStatement,        "LineDirectiveStatement",        "LINE_DIRECTIVE_STMT"    );
     NEW_TERMINAL_MACRO (WarningDirectiveStatement,     "WarningDirectiveStatement",     "WARNING_DIRECTIVE_STMT" );
     NEW_TERMINAL_MACRO (ErrorDirectiveStatement,       "ErrorDirectiveStatement",       "ERROR_DIRECTIVE_STMT"   );
     NEW_TERMINAL_MACRO (EmptyDirectiveStatement,       "EmptyDirectiveStatement",       "EMPTY_DIRECTIVE_STMT"   );

  // DQ (11/28/2008): Added new IR nodes.
     NEW_TERMINAL_MACRO (IncludeNextDirectiveStatement, "IncludeNextDirectiveStatement", "INCLUDE_NEXT_DIRECTIVE_STMT" );
     NEW_TERMINAL_MACRO (IdentDirectiveStatement,       "IdentDirectiveStatement",       "IDENT_DIRECTIVE_STMT"   );

  // Note that this IR nodes is critical to Fortran support for CPP processed generated code.
     NEW_TERMINAL_MACRO (LinemarkerDirectiveStatement,  "LinemarkerDirectiveStatement",  "LINEMARKER_DIRECTIVE_STMT"   );

     NEW_NONTERMINAL_MACRO (C_PreprocessorDirectiveStatement,
          IncludeDirectiveStatement     | DefineDirectiveStatement  | UndefDirectiveStatement  |
          IfdefDirectiveStatement       | IfndefDirectiveStatement  | IfDirectiveStatement     | DeadIfDirectiveStatement   |
          ElseDirectiveStatement        | ElseifDirectiveStatement  | EndifDirectiveStatement  |
          LineDirectiveStatement        | WarningDirectiveStatement | ErrorDirectiveStatement  | EmptyDirectiveStatement |
          IncludeNextDirectiveStatement | IdentDirectiveStatement   | LinemarkerDirectiveStatement,
          "C_PreprocessorDirectiveStatement", "CPP_DIRECTIVE_STMT", false );

     NEW_TERMINAL_MACRO (ClinkageStartStatement,"ClinkageStartStatement","C_LINKAGE_START_STMT" );

     NEW_TERMINAL_MACRO (ClinkageEndStatement,"ClinkageEndStatement","C_LINKAGE_END_STMT" );

     NEW_NONTERMINAL_MACRO (ClinkageDeclarationStatement,
          ClinkageStartStatement | ClinkageEndStatement,
          "ClinkageDeclarationStatement", "C_LINKAGE_DECLARATION_STMT", false );

  // + variable list
     NEW_TERMINAL_MACRO (OmpFlushStatement,     "OmpFlushStatement",      "OMP_FLUSH_STMT" );
     NEW_TERMINAL_MACRO (OmpDeclareSimdStatement, "OmpDeclareSimdStatement",  "OMP_DECLARE_SIMD_STMT" );
  // simplest directives, just one line
     NEW_TERMINAL_MACRO (OmpBarrierStatement,   "OmpBarrierStatement",   "OMP_BARRIER_STMT" );
     NEW_TERMINAL_MACRO (OmpTaskwaitStatement,  "OmpTaskwaitStatement",  "OMP_TASKWAIT_STMT" );


  // + variable list
     NEW_TERMINAL_MACRO (OmpThreadprivateStatement, "OmpThreadprivateStatement",    "OMP_THREADPRIVATE_STMT" );

  // DQ (8/16/2014): Adding support for Microsoft attributes (e.g. "[repeatable] int x;")
     NEW_TERMINAL_MACRO (MicrosoftAttributeDeclaration, "MicrosoftAttributeDeclaration", "MS_ATTRIBUTE_DECL_STMT"    );

  // DQ (3/22/2019): Adding EmptyDeclaration to support addition of comments and CPP directives that will permit
  // token-based unparsing to work with greater precision. For example, used to add an include directive with
  // greater precission to the global scope and permit the unparsing via the token stream to be used as well.
     NEW_TERMINAL_MACRO (EmptyDeclaration,"EmptyDeclaration","EMPTY_DECLARATION_STMT" );

  // PP (05/04/20): Adding Ada scoped declarations (tasks, ...)
     NEW_TERMINAL_MACRO (AdaPackageSpecDecl,    "AdaPackageSpecDecl", "ADA_PACKAGE_SPEC_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaPackageBodyDecl,    "AdaPackageBodyDecl", "ADA_PACKAGE_BODY_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaTaskSpecDecl,       "AdaTaskSpecDecl", "ADA_TASK_SPEC_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaTaskTypeDecl,       "AdaTaskTypeDecl", "ADA_TASK_TYPE_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaTaskBodyDecl,       "AdaTaskBodyDecl", "ADA_TASK_BODY_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaProtectedSpecDecl,  "AdaProtectedSpecDecl", "ADA_PROTECTED_SPEC_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaProtectedTypeDecl,  "AdaProtectedTypeDecl", "ADA_PROTECTED_TYPE_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaProtectedBodyDecl,  "AdaProtectedBodyDecl", "ADA_PROTECTED_BODY_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaRepresentationClause, "AdaRepresentationClause", "ADA_REPRESENTATION_CLAUSE" );
     NEW_TERMINAL_MACRO (AdaEnumRepresentationClause,   "AdaEnumRepresentationClause",   "ADA_ENUM_REPRESENTATION_CLAUSE" );
     NEW_TERMINAL_MACRO (AdaAttributeClause,            "AdaAttributeClause",            "ADA_ATTRIBUTE_CLAUSE" );
     NEW_TERMINAL_MACRO (AdaComponentClause,            "AdaComponentClause",            "ADA_COMPONENT_CLAUSE" );
  // PP (07/14/20): Adding Ada renaming declarations
     NEW_TERMINAL_MACRO (AdaRenamingDecl,       "AdaRenamingDecl", "ADA_RENAMING_DECL_STMT" );
  // MS (08/01/21): Adding Ada generics
     NEW_TERMINAL_MACRO (AdaGenericDecl,        "AdaGenericDecl", "ADA_GENERIC_DECL" );
     NEW_TERMINAL_MACRO (AdaGenericInstanceDecl,"AdaGenericInstanceDecl", "ADA_GENERIC_INSTANCE_DECL" );
     NEW_TERMINAL_MACRO (AdaFormalTypeDecl,     "AdaFormalTypeDecl", "ADA_FORMAL_TYPE_DECL_STMT" );
     NEW_TERMINAL_MACRO (AdaFormalPackageDecl,  "AdaFormalPackageDecl", "ADA_FORMAL_PACKAGE_DECL_STMT" );
  // PP (07/14/20): Adding Ada discriminated type declarations
     NEW_TERMINAL_MACRO (AdaDiscriminatedTypeDecl, "AdaDiscriminatedTypeDecl", "ADA_DISCRIMINATED_TYPE_DECL" );
     NEW_TERMINAL_MACRO (AdaVariantDecl,      "AdaVariantDecl", "ADA_VARIANT_DECL_STATEMENT" );

     NEW_NONTERMINAL_MACRO (DeclarationStatement,
          FunctionParameterList                   | VariableDeclaration       | VariableDefinition           |
          ClinkageDeclarationStatement            | EnumDeclaration           | /* StronglyTypedEnumDeclaration | */  AsmStmt                  |
          AttributeSpecificationStatement         | FormatStatement           | TemplateDeclaration          |
          TemplateInstantiationDirectiveStatement | UseStatement              | ParameterStatement           |
          NamespaceDeclarationStatement           | EquivalenceStatement      | InterfaceStatement           |
          NamespaceAliasDeclarationStatement      | CommonBlock               | TypedefDeclaration           |
          StatementFunctionStatement              | CtorInitializerList       | PragmaDeclaration            |
          UsingDirectiveStatement                 | ClassDeclaration          | ImplicitStatement            |
          UsingDeclarationStatement               | NamelistStatement         | ImportStatement              |
          FunctionDeclaration                  /* | ModuleStatement */        | ContainsStatement            |
          C_PreprocessorDirectiveStatement        | OmpThreadprivateStatement | FortranIncludeLine           |
          JavaImportStatement                     | JavaPackageStatement      | StmtDeclarationStatement     |
          StaticAssertionDeclaration              | OmpDeclareSimdStatement   | MicrosoftAttributeDeclaration|
          JovialCompoolStatement                  | JovialDirectiveStatement  | JovialDefineDeclaration      |
          JovialLabelDeclaration                  | JovialOverlayDeclaration  |
          NonrealDecl                             | EmptyDeclaration          |
          AdaPackageBodyDecl                      | AdaPackageSpecDecl        | AdaRenamingDecl              |
          AdaTaskSpecDecl                         | AdaTaskBodyDecl           | AdaTaskTypeDecl              |
          AdaProtectedSpecDecl                    | AdaProtectedBodyDecl      | AdaProtectedTypeDecl         |
          AdaRepresentationClause                 | AdaComponentClause        | AdaAttributeClause           |
          AdaEnumRepresentationClause             | AdaGenericDecl            | AdaFormalTypeDecl            |
          AdaDiscriminatedTypeDecl                | AdaGenericInstanceDecl    | AdaFormalPackageDecl         |
          AdaParameterList                        | AdaVariantDecl
          /*| ClassPropertyList |*/,
          "DeclarationStatement", "DECL_STMT", false);


  // Rasmussen (9/20/2018): Added ImageControlStatement
  //           (7/11/2020): Changed StopOrPauseStatement to ProcessControlStatement to allow more variants
     NEW_NONTERMINAL_MACRO (Statement,
             ScopeStatement            | FunctionTypeTable      | DeclarationStatement            | ExprStatement         |
             LabelStatement            | CaseOptionStmt         | TryStmt                         | DefaultOptionStmt     |
             BreakStmt                 | ContinueStmt           | ReturnStmt                      | GotoStatement         |
             SpawnStmt                 | NullStatement          | VariantStatement                | ForInitStatement      |
             CatchStatementSeq         | ProcessControlStatement| IOStatement                     | FortranContinueStmt   |
             WhereStatement            | ElseWhereStatement     | NullifyStatement                | ArithmeticIfStatement |
             AssignStatement           | ComputedGotoStatement  | AssignedGotoStatement           |
             AllocateStatement         | DeallocateStatement    | UpcNotifyStatement              |
             UpcWaitStatement          | UpcBarrierStatement    | UpcFenceStatement               |
             OmpBarrierStatement       | OmpTaskwaitStatement   |  OmpFlushStatement              | OmpBodyStatement      |
             SequenceStatement         | WithStatement          | PythonPrintStmt                 | PassStatement         |
             AssertStmt                | ExecStatement          | PythonGlobalStmt                | JavaThrowStatement    |
             JavaSynchronizedStatement | AsyncStmt              | FinishStmt                      | AtStmt                |
             AtomicStmt                | WhenStmt               | ImageControlStatement | /* JavaPackageDeclaration | */
             AdaExitStmt               | AdaDelayStmt           | AdaLoopStmt                     | AdaSelectStmt         |
             AdaSelectAlternativeStmt  | AdaTerminateStmt       | AdaUnscopedBlock                | AdaVariantWhenStmt,
             "Statement","StatementTag", false);

  // DQ (11/24/2007): These have been moved to be declarations, so they can appear where only declaration statements are allowed
  // InterfaceStatement   | ModuleStatement        | UseStatement                    | ContainsStatement     |
  // DQ (11/24/2007): These are derived from IOControlStatement and are not directly derived from SgStatement
  // InputOutputStatement | OpenStatement          | CloseStatement                  | InquireStatement      | IOFileControlStmt |

  // ***********************************************************************
  // ***********************************************************************
  //                       Header Code Declaration
  // ***********************************************************************
  // ***********************************************************************

  // Statement.setSubTreeFunctionPrototype ( "HEADER", "../Grammar/sageCommon.code" );
  // Statement.excludeFunctionPrototype    ( "HEADER", "../Grammar/sageCommon.code" );

     Statement.setFunctionPrototype     ("HEADER", "../Grammar/Statement.code" );

  // DQ (12/30/2009): Added post declaration support for the template function StatementReplace
  // which was previously buried into the generated source code and which work only when
  // all the references were in the same file.  Now with the new support to build smaller
  // ROSETTA generated files this template function must be put into the header file where
  // all the different source code files can see it defined.
     Statement.setPostdeclarationString ("HEADER_STATEMENT_POSTDECLARATION", "../Grammar/Statement.code");

  // MK: the following two function calls could be wrapped into a single one:
     Statement.setFunctionPrototype("HEADER_POST_CONSTRUCTION_INITIALIZATION", "../Grammar/Statement.code");
     Statement.setSubTreeFunctionPrototype("HEADER_POST_CONSTRUCTION_INITIALIZATION", "../Grammar/Statement.code" );

  // DQ (12/4/2004): Now we automate the generation of the destructors
  // Statement.setAutomaticGenerationOfDestructor(false);

  // Statement.excludeFunctionPrototype    ( "HEADER_POST_CONSTRUCTION_INITIALIZATION",
  //                                         "../Grammar/Statement.code" );
  // Statement.setDataPrototype    ( "SgStatement*","parent","= NULL");
  // Statement.excludeDataPrototype( "SgStatement*","parent","= NULL");

  // The functions we want to generate for setting the parent data are special
  // Statement.setAutomaticGenerationOfDataAccessFunctions(false);

  // DQ (3/21/2007): Added numeric label to support Fortran (any statement can have a label)
  // A value of -1 indicates that no label is explicit in the source code.
  // Statement.setDataPrototype("int", "numeric_label", "= -1",
  //           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     Statement.setDataPrototype("SgLabelRefExp*", "numeric_label", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/1/2009): Adding support for source sequence numbers as part of name qualification support
  // which would include a test for if statements containing references to declarations appear before
  // or after the defining declaration they are associated with. More subtle rules also apply and are
  // critical for correct name qualification in the generated code (unparser).
     Statement.setDataPrototype("int", "source_sequence_value", "= -1",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ScopeStatement.setFunctionPrototype( "HEADER_SCOPE_STATEMENT", "../Grammar/Statement.code" );
     ScopeStatement.setAutomaticGenerationOfConstructor(false);

  // Switch between inlcuding the SgSymbolTable as a pointer or as a data member
  // ScopeStatement.setDataPrototype    ( "SgSymbolTable*","symbol_table","= NULL",
  //                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE, NO_COPY_DATA);
     ScopeStatement.setDataPrototype    ( "SgSymbolTable*","symbol_table","= NULL",
                                          NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE, NO_COPY_DATA);

  // DQ (7/23/2010): Build a local type table because during construction of the AST we can't yet build the global type table.
  // After construction of the AST it might be that we can build a global type table and then perhaps not use this local one at each scope.
     ScopeStatement.setDataPrototype    ( "SgTypeTable*","type_table","= NULL",
                                          NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE, NO_COPY_DATA);

  // DQ (5/11/2011): This should be deprecated since we now have a newer name qualification implementation going into place.
  // DQ (6/5/2007): Specify no access functions so that we can build special ones that return by reference.
  // DQ (5/8/2007): Added type elaboration list. If a symbol is in this list then it requires type elaboration ("typically "class" keyword).
     ScopeStatement.setDataPrototype    ( "std::set<SgSymbol*>","type_elaboration_list","",
                                          NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);

  // DQ (6/5/2007): Specify no access functions so that we can build special ones that return by reference.
  // DQ (5/8/2007): Added hidden type list. If a symbol is in this list then it requires name qualification ("typically "::" keyword).
     ScopeStatement.setDataPrototype    ( "std::set<SgSymbol*>","hidden_type_list","",
                                          NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);

  // DQ (6/5/2007): Specify no access functions so that we can build special ones that return by reference.
  // DQ (5/8/2007): Added hidden declaration list. If a symbol is in this list then it requires name qualification ("typically "::" keyword).
     ScopeStatement.setDataPrototype    ( "std::set<SgSymbol*>","hidden_declaration_list","",
                                          NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);

  // DQ (9/23/2020): Add a pointer to hold a SgPragma that can be attached to a log of scope IR nodes.
  // e.g. Cxx11_tests/test2020_102.C through test2020_107.C
  // ScopeStatement.setDataPrototype    ( "SgPragma*","pragma","= NULL",
  //                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE, NO_COPY_DATA);
     ScopeStatement.setDataPrototype    ( "SgPragma*","pragma","= NULL",
                                          NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE, NO_COPY_DATA);

  // DQ (5/9/2021): Added to support token-based unparsing with unparsing of headers.  Each scope records which header files are included in that scope.
  // This is done so that we can determine which scopes are characterized by only included files and which ones also have other statements.
  // ScopeStatement.setDataPrototype    ( "std::set<SgIncludeFile*>","includeFileSet","",
  //                                      NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // DQ (5/9/2021): Support for token-based unparsing when used with header file unparsing.
  // ScopeStatement.setDataPrototype   ( "bool", "allStatementsAreFromHeaderFiles", "= false",
  //                                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     FunctionTypeTable.setFunctionPrototype( "HEADER_FUNCTION_TYPE_TABLE", "../Grammar/Statement.code" );
     FunctionTypeTable.setDataPrototype    ( "SgSymbolTable*","function_type_table","= NULL",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);
     FunctionTypeTable.setAutomaticGenerationOfConstructor(false);

     Global.setFunctionPrototype( "HEADER_GLOBAL", "../Grammar/Statement.code" );
     Global.editSubstitute      ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
  // Global.setFunctionPrototype( "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     Global.editSubstitute      ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     Global.editSubstitute      ( "LIST_NAME", "declarations" );
     Global.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     Global.editSubstitute      ( "LIST_FUNCTION_NAME", "declaration" );
     Global.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     Global.setDataPrototype    ( "SgDeclarationStatementPtrList", "declarations", "",
                                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // We need a custom destructor until we have automated support for deletion of list elements.
  // DQ (12/4/2004): Now we automate the generation of the destructors
  // Global.setAutomaticGenerationOfDestructor(false);

  // DQ (6/26/2007): Moved to SgNode to support AST merge
  // DQ (10/6/2006): Support for caching of mangle names unique to global scope; this is a performance improvement.
  // Global.setDataPrototype ( "std::map<SgNode*,std::string>", "mangledNameCache", "",
  //        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // Global.setDataPrototype ( "std::map<std::string, int>", "shortMangledNameCache", "",
  //        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     DeclarationStatement.setFunctionPrototype( "HEADER_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (3/9/2012): Moved this function to be declared after the SgDeclarationStatement was declared.
  // It used to be a part of the BASIC_BLOCK_POSTDECLARATION (see that part of the code below for more details).
     DeclarationStatement.setPostdeclarationString ("HEADER_DECLARATION_STATEMENT_POSTDECLARATION", "../Grammar/Statement.code");

  // DQ (4/22/2004): Remove these later when the new modifiers are working
     DeclarationStatement.setDataPrototype    ( "unsigned int","decl_attributes","= 0",
                                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DeclarationStatement.setDataPrototype    ( "char*","linkage","= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // DQ (11/23/2007): This string is used to hold the Fortran binding language as well.
  // DQ (11/16/2007): Added "" as initializer for linkage string. Because we have this
  // string explicit, we are not using the SgLinkageModifier (which might be a better idea).
     DeclarationStatement.setDataPrototype    ( "std::string","linkage","= \"\"",
                                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/22/2004): Adding new modifier support (might not need/want to use the
  //                 SgDeclarationModifier node???  When might this not be enough???)
     DeclarationStatement.setDataPrototype ("SgDeclarationModifier", "declarationModifier", "",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeclarationStatement.setDataPrototype ("bool","nameOnly","= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeclarationStatement.setDataPrototype ("bool","forward","= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeclarationStatement.setDataPrototype ("bool","externBrace","= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeclarationStatement.setDataPrototype ("bool","skipElaborateType","= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/10/2006): Use the SgQualifiedNamePtrList instead of a boolean value, and remove this data member.
  // DQ (9/7/2004): Moved to declaration from variable declarations
  // DQ (9/4/2004): Added support for qualification of type names in variable declarations

  // DQ (9/23/2004): Removed this since it is better to compute the qualified name dynamically than to have it
  // statically specified in the AST and possibly set incorrectly after a possible transformation.  This also
  // simplifies the transformations since they don't have to worry about setting this correctly.
  // DQ (9/7/2004): Moved to declaration from variable declarations
  // DQ (9/6/2004): Instead of storing the name store a symbol (either a SgClassSymbol or SgNamespaceSymbol), since
  // this can be a cascading set of names (as in A::B::C::x) we need to store a list of these name qualifiers.
  // As long as the traversal does not traverse the list then we can put it into the current IR node.  This would have
  // to be moved to its own IR node if we later want to traverse it!  Until we have an example of this implemented
  // we will use a list of SgSymbols and later move it to a new IR node where it can be used more generally in
  // variable declarations, initializers, base class specifiers, global and member functions and tose in namespaces, etc.

  // DQ (9/23/2004): Added support for references to the defining declaration (all others are forward or non-defining)
  // as in the following declaration of a typedef of a function pointer:
  //      typedef struct foobar *(*foobarFunctionPointer)();
  // where the "struct foobar" is not not really a forward declaration in a typical sense (it is the base type of a pointer
  // which is a function return type), but not a defining declaration either!
  // Having a concept of a "defining declaration" allows us to simplify the unparser and more accurately know when to output
  // a definition.  The idea is not specific to class declarations and perhaps should be in the SgDeclaration object.
     DeclarationStatement.setDataPrototype ("SgDeclarationStatement*", "definingDeclaration", "= NULL",
                                         NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/23/2004): Keep track of the first non-defining declaration (so it can be reused to avoid redundant
  // declarations (explicitly or implicitly forward declarations).
     DeclarationStatement.setDataPrototype ("SgDeclarationStatement*", "firstNondefiningDeclaration", "= NULL",
                                         NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/10/2006): Not all declarations make sense with qualified names, but enough do that I have placed
  // this here for now! I have removed these lists from the SgNamedType IR nodes since SgTypes are shared and
  // name qualification is require non-uniformally within the AST (making share IR nodes holding name
  // qualification list a problem).
     DeclarationStatement.setDataPrototype ("SgQualifiedNamePtrList", "qualifiedNameList", "",
               NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/23/2007): In Fortran, we now support the bind attribute (fixed to be handled on the DeclarationStatement
  // instead of separately on SgFunctionDeclaration, SgVariableDeclaration, and SgClassDeclaration IR nodes).
  // Use the "linkage" string already stored in the SgDeclarationStatement (above).
     DeclarationStatement.setDataPrototype ("std::string", "binding_label", "=\"\"",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/17/2017): Adding support for a new concept of declaration scope (see documentation above).
     DeclarationStatement.setDataPrototype ( "SgDeclarationScope*", "declarationScope", "= NULL",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/26/2020): Adding support to unparse the templates from the AST on a declaration by declaration basis.
     DeclarationStatement.setDataPrototype ("bool", "unparse_template_ast", "= false",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PP (09/18/23): Adding support for Ada aspects
  //                \todo set traversal and DEF_DELETE?
     DeclarationStatement.setDataPrototype ("SgExprListExp*", "adaAspects", "= nullptr",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     BasicBlock.setFunctionPrototype ( "HEADER_BASIC_BLOCK", "../Grammar/Statement.code" );

  // DQ (12/30/2009): As part of building separate smaller files using ROSETTA, we have to
  // declare this template function in the headers instead of the source file AND it can
  // only appear after the declaration of SgBasicBlock.
     BasicBlock.setPostdeclarationString ("HEADER_BASIC_BLOCK_POSTDECLARATION", "../Grammar/Statement.code");

     BasicBlock.setAutomaticGenerationOfConstructor(false);
     BasicBlock.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     BasicBlock.editSubstitute       ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     BasicBlock.editSubstitute       ( "LIST_NAME", "statements" );
     BasicBlock.editSubstitute       ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     BasicBlock.editSubstitute       ( "LIST_FUNCTION_NAME", "statement" );
     BasicBlock.editSubstitute       ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );
     BasicBlock.setDataPrototype    ( "SgStatementPtrList", "statements", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (12/4/2004): Now we automate the generation of the destructors
  // BasicBlock.setAutomaticGenerationOfDestructor(false);

  // DQ (3/4/2010): Added support for asm functions in ROSE.  This is support is required for
  // handling embedded code. When used the SgBasicBlock can only appear in a SgFunctionDefinition
  // and can contain any string (only meaningful if they are assembly instructions).
     BasicBlock.setDataPrototype ( "std::string", "asm_function_body", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PP (06/04/20) - block label for ADA (in analogy to for and while labels)
     BasicBlock.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     IfStmt.setFunctionPrototype ( "HEADER_IF_STATEMENT", "../Grammar/Statement.code" );
     IfStmt.setDataPrototype ( "SgStatement*",  "conditional", "= NULL",
                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "SgStatement*", "true_body",   "= NULL",
                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "SgStatement*", "false_body",  "= NULL",
                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (7/26/2020): C++17 specific feature support for "if constexpr() {} else {}".
     IfStmt.setDataPrototype ( "bool", "is_if_constexpr_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "bool", "if_constexpr_value_known", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "bool", "if_constexpr_value", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/4/2004): Now we automate the generation of the destructors
  // IfStmt.setAutomaticGenerationOfDestructor(false);

  // DQ (12/16/2007): The else part of the if can have its own label (fortran only)!
  // IfStmt.setDataPrototype ( "int", "else_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "SgLabelRefExp*", "else_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/16/2007): Added support for string labels (for Fortran).
     IfStmt.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (8/24/2007): Added to support Fortran specific use of WhileStmt
  //  IfStmt.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfStmt.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/26/2007): Fortran specific, has associated endif statement
     IfStmt.setDataPrototype     ( "bool", "has_end_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/7/2010): Fortran specific, has associated then keyword.
     IfStmt.setDataPrototype     ( "bool", "use_then_keyword", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/7/2010): Fortran specific, has associated else keyword before if (is an else-if statement).
     IfStmt.setDataPrototype     ( "bool", "is_else_if_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ForStatement.setFunctionPrototype ( "HEADER_FOR_STATEMENT", "../Grammar/Statement.code" );
     ForStatement.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     ForStatement.editSubstitute      ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     ForStatement.editSubstitute      ( "LIST_NAME", "init_stmt" );
     ForStatement.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     ForStatement.editSubstitute      ( "LIST_FUNCTION_NAME", "init_stmt" );
     ForStatement.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );

  // DQ (10/24/2007): Copy the SgForInitStatement
     ForStatement.setDataPrototype ( "SgForInitStatement*", "for_init_stmt", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);


  // DQ (11/23/2005): This replaces the SgExpressionRoot with a SgStatement
  // so that declarations can be used (required for C and C++).
     ForStatement.setDataPrototype ( "SgStatement*", "test", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (10/24/2007): Copy the SgForInitStatement
  // DQ (11/7/2006): Trying to remove the WRAP mechanism since it is overly complex and not required
     ForStatement.setDataPrototype ( "SgExpression*", "increment", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);

     ForStatement.setDataPrototype ( "SgStatement*", "loop_body",        "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ForStatement.setDataPrototype ( "SgStatement*", "else_body",        "= NULL",
                                     NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (11/16/2007): Added support for string labels (for Fortran and Ada (PP)).
     ForStatement.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


  // DQ (12/4/2004): Now we automate the generation of the destructors
  // ForStatement.setAutomaticGenerationOfDestructor(false);

     ForInitStatement.setFunctionPrototype ( "HEADER_FOR_INIT_STATEMENT", "../Grammar/Statement.code" );
     ForInitStatement.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     ForInitStatement.editSubstitute      ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     ForInitStatement.editSubstitute      ( "LIST_NAME", "init_stmt" );
     ForInitStatement.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     ForInitStatement.editSubstitute      ( "LIST_FUNCTION_NAME", "init_stmt" );
     ForInitStatement.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );
     ForInitStatement.setDataPrototype ( "SgStatementPtrList", "init_stmt", "",
                                         NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (12/4/2004): Now we automate the generation of the destructors
  // ForInitStatement.setAutomaticGenerationOfDestructor(false);


  // DQ and Liao (6/11/2008): Added support for UPC forall IR node.
     UpcForAllStatement.setFunctionPrototype ( "HEADER_UPC_FORALL_STATEMENT", "../Grammar/Statement.code" );
     UpcForAllStatement.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     UpcForAllStatement.editSubstitute      ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     UpcForAllStatement.editSubstitute      ( "LIST_NAME", "init_stmt" );
     UpcForAllStatement.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     UpcForAllStatement.editSubstitute      ( "LIST_FUNCTION_NAME", "init_stmt" );
     UpcForAllStatement.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );
     UpcForAllStatement.setDataPrototype ( "SgForInitStatement*", "for_init_stmt", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     UpcForAllStatement.setDataPrototype ( "SgStatement*", "test", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     UpcForAllStatement.setDataPrototype ( "SgExpression*", "increment", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     UpcForAllStatement.setDataPrototype ( "SgExpression*", "affinity", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     UpcForAllStatement.setDataPrototype ( "SgStatement*", "loop_body",        "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);


  // DQ (3/25/2018): Adding Range-based For statement support (previously missed in C++11 support).
     RangeBasedForStatement.setFunctionPrototype ( "HEADER_RANGE_BASED_FOR_STATEMENT", "../Grammar/Statement.code" );

     RangeBasedForStatement.setDataPrototype     ( "SgVariableDeclaration*", "iterator_declaration", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     RangeBasedForStatement.setDataPrototype     ( "SgVariableDeclaration*", "range_declaration", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     RangeBasedForStatement.setDataPrototype     ( "SgVariableDeclaration*", "begin_declaration", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     RangeBasedForStatement.setDataPrototype     ( "SgVariableDeclaration*", "end_declaration", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     RangeBasedForStatement.setDataPrototype     ( "SgExpression*", "not_equal_expression", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     RangeBasedForStatement.setDataPrototype     ( "SgExpression*", "increment_expression", "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     RangeBasedForStatement.setDataPrototype ( "SgStatement*", "loop_body",        "= NULL",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (7/25/2014): Adding support for C11 static assertions.
     StaticAssertionDeclaration.setFunctionPrototype ( "HEADER_STATIC_ASSERTION_DECLARATION", "../Grammar/Statement.code" );
     StaticAssertionDeclaration.setDataPrototype ( "SgExpression*", "condition", "= NULL",
                   CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     StaticAssertionDeclaration.setDataPrototype ( "SgName", "string_literal", "= \"\"",
                   CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


// Rasmussen (09/24/2020): Finishing implementation of SgFunctionParameterScope for Jovial
     FunctionParameterScope.setFunctionPrototype( "HEADER_FUNCTION_PARAMETER_SCOPE", "../Grammar/Statement.code" );
     FunctionParameterScope.editSubstitute      ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     FunctionParameterScope.editSubstitute      ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     FunctionParameterScope.editSubstitute      ( "LIST_NAME", "declarations" );
     FunctionParameterScope.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     FunctionParameterScope.editSubstitute      ( "LIST_FUNCTION_NAME", "declaration" );
     FunctionParameterScope.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     FunctionParameterScope.setDataPrototype    ( "SgDeclarationStatementPtrList", "declarations", "",
                                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (7/17/2017): Added to support concept of scope in nondefining declarations (required for more sophisticated level of template useage).
  // PP (8/03/20): Note, DeclarationScope is also used by the AdaDiscriminatedTypeDecl decorator
     DeclarationScope.setFunctionPrototype ( "HEADER_DECLARATION_SCOPE", "../Grammar/Statement.code" );


     FunctionDeclaration.setFunctionPrototype ( "HEADER_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     FunctionDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

     FunctionDeclaration.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     FunctionDeclaration.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     FunctionDeclaration.editSubstitute      ( "LIST_NAME", "args" );
     FunctionDeclaration.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
     FunctionDeclaration.editSubstitute      ( "LIST_FUNCTION_NAME", "arg" );

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // FunctionDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "const SgInitializedName &" );
     FunctionDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );

#if 1
  // DQ (10/20/2004): Since constructor names don't require their template arguments this has a far simpler solution!
  // for example: "template <typename T> class X { X(); }; X<int>::X() {}"

  // DQ (10/20/2004): Changed to disallow ROSETTA to generate the get_name() function.  This function is now
  // modified to handle the special case of a constructor and destructor (to output the class name in these cases).
  // It is left as a constructor parameter, but ignored interanlly in the case of a member function constructor
  // of destructor.
     FunctionDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
                   CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#else
     FunctionDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
                   CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

  // DQ (3/4/2007): We want to force the copy mechanism to skip building a new SgFunctionParameterList
  // when making a copy (use NO_COPY_DATA to do this).  The p_parameterList is handled internally
  // in SageIII.
  // DQ (3/10/2007) But now were we make a copy of a function we will get the parameter list wrong!
  // This is a problem in building template function forward declarations!
  // FunctionDeclaration.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "=NULL",
  //               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // FunctionDeclaration.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "= NULL",
  //               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
#if 1
  // Original code.
     FunctionDeclaration.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "= NULL",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
#else
  // DQ (10/11/2014): Make this a constructor parameter list so that we can support the generation from ATerms.
     FunctionDeclaration.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "= NULL",
                                            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
#endif

  // DQ (4/25/2004): Add modifier FunctionModifier and SpecialFunctionModifier
     FunctionDeclaration.setDataPrototype ( "SgFunctionModifier", "functionModifier", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FunctionDeclaration.setDataPrototype ( "SgSpecialFunctionModifier", "specialFunctionModifier", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/27/2006): Support for function declaration exception specifications
     FunctionDeclaration.setDataPrototype ( "SgTypePtrList", "exceptionSpecification", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/3/2007): In Fortran, the function name has been used in the end statement.
     FunctionDeclaration.setDataPrototype ( "bool", "named_in_end_statement", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (1/25/2009): Added support for asm names for functions (see test2009_10.C)
     FunctionDeclaration.setDataPrototype ( "std::string", "asm_name", "= \"\"",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     /* driscoll6 (7/14/11) support for python decorators */
     FunctionDeclaration.setDataPrototype ( "SgExprListExp*", "decoratorList", "= NULL",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     // MS (01/24/22) support for Ada formal subprogram declarations */
     FunctionDeclaration.setDataPrototype ( "bool", "ada_formal_subprogram_decl", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FunctionDeclaration.setDataPrototype ( "bool", "ada_formal_decl_with_box", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     FunctionParameterList.setFunctionPrototype ( "HEADER_FUNCTION_PARAMETER_LIST", "../Grammar/Statement.code" );

     FunctionParameterList.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     FunctionParameterList.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     FunctionParameterList.editSubstitute      ( "LIST_NAME", "args" );
     FunctionParameterList.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
     FunctionParameterList.editSubstitute      ( "LIST_FUNCTION_NAME", "arg" );

  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
     FunctionParameterList.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );
     FunctionParameterList.setDataPrototype ( "SgInitializedNamePtrList", "args", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // We would like to have a class include data members which are terminals/nonterminals within the grammar.
  // In the case where these are X terminals/nonterminals the data members should be X versions of these.
  // It is difficult for it to be either the X or non_X version since these are different types.
  // There are three cases to consider:
  //   1) Data member is an X version (matching Xness of the outer AstNodeClass)
  //           Implementation proceedure: build X version
  //   2) Data member is a non X version (not matching the Xness of the outer AstNodeClass)
  //           Implementation proceedure: build non X version
  //   3) Data member can be the X OR non X version (independent of the Xness of the outer AstNodeClass)
  //           Implementation proceedure: build X and non X versions?

  // In this case we want the Xness of the data member to match that of the outer AstNodeClass
     FunctionDeclaration.setDataPrototype ( "SgFunctionType*", "type", "= NULL",
                                            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/18/2005): Removed this data member since it is redundent with the firstNondefiningDeclaration in the base class (SgDeclarationStatement)
  // QY: need forward definition so that we can set definition pointer as NULL for forward decls
     FunctionDeclaration.setDataPrototype ( "SgFunctionDefinition*", "definition", "= NULL",
                                            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (2/15/2004): Add support for old-style C function definitions (K&R style)
     FunctionDeclaration.setDataPrototype ( "bool","oldStyleDefinition", "= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/15/2004): class declarations for nested classes can appear outside the scope of the class to which
  // they belong, thus the parent information is not sufficent to define the relationship of nested classes
  // (and typedefs within the classes, as well, which is the current bug in Kull).  So we need an additional
  // data member to explicitly represent the scope of a class (consistant with the design of the member
  // function declaration).
     FunctionDeclaration.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/9/2005): Adding special template support.  These data members help control the instantiation of
  // templates and there representation in the unparsed code (code generated by ROSE).
  // Note that the File_Info object is where IR nodes are marked as compiler generated (also relavant here).
     FunctionDeclaration.setDataPrototype ( "SgDeclarationStatement::template_specialization_enum", "specialization", "= SgDeclarationStatement::e_no_specialization",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (8/20/2006): Record if global name qualification is required on the type.
  // See test2003_01.C for an example of where this is required.
     FunctionDeclaration.setDataPrototype("bool", "requiresNameQualificationOnReturnType", "= false",
                 NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/22/2007): Added this data member to the SgFunctionDeclaration since it is used for functions and subroutines in Fortran.

  // DQ (12/4/2007): Added support for GNU attributes
     FunctionDeclaration.setDataPrototype ("std::string", "gnu_extension_section", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FunctionDeclaration.setDataPrototype ("std::string", "gnu_extension_alias", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FunctionDeclaration.setDataPrototype ("SgDeclarationStatement::gnu_extension_visability_attribute_enum", "gnu_extension_visability", "= SgDeclarationStatement::e_gnu_attribute_visability_unspecified",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/13/2011): Added support for name qualification.
     FunctionDeclaration.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/13/2011): Added information required for new name qualification support.
     FunctionDeclaration.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/13/2011): Added information required for new name qualification support.
     FunctionDeclaration.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/15/2011): Added support for name qualification.
     FunctionDeclaration.setDataPrototype ( "int", "name_qualification_length_for_return_type", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/15/2011): Added information required for new name qualification support.
     FunctionDeclaration.setDataPrototype("bool","type_elaboration_required_for_return_type","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/15/2011): Added information required for new name qualification support.
     FunctionDeclaration.setDataPrototype("bool","global_qualification_required_for_return_type","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/18/2014): Add support for old-style C function prototypes without function parameters (K&R style)
     FunctionDeclaration.setDataPrototype ( "bool","prototypeIsWithoutParameters", "= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/27/2015): Note that zero is a ligitimate value to use, so the default should be -1.
  // DQ (2/19/2014): Add support for gnu attribute regnum (required to compile valgrind).
     FunctionDeclaration.setDataPrototype ( "int","gnu_regparm_attribute", "= -1",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/9/2014): Example test2014_85.C demonstrates that the declared type of a function can be
  // equivalent to other same functions (associated defining and non-defining declarations), but
  // syntatically different in a way that makes a difference to the code generated from the unparser
  // (but not to the formal type system).  I am not clear if this type should be traversed, I think
  // not, since it is a function type used only for the representation of syntax.
     FunctionDeclaration.setDataPrototype ( "SgFunctionType*", "type_syntax", "= NULL",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/9/2014): Added boolean flag to communicate when the function's type syntax is different from
  // the function's type.  However, when the type_syntax is non-null, it is always an equivalent type.
  // Future work will enforce this concept fo type equivalence, not yet supported.
     FunctionDeclaration.setDataPrototype ( "bool","type_syntax_is_available", "= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/12/2018): This is the parameter list that is used to support function prototypes where the
  // function parameter type or parameter names are different from the defining declaration (see example
  // in C_tests/test2018_32.c).  This data member is only non-null when type_syntax_is_available == true.
     FunctionDeclaration.setDataPrototype ( "SgFunctionParameterList*", "parameterList_syntax", "= NULL",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/26/2014): Added support for C11 "_Noreturn" keyword (alternative noreturn specification).
  // This could maybe be moved to the SgFunctionModifier.
     FunctionDeclaration.setDataPrototype("bool","using_C11_Noreturn_keyword","= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/1/2014): Added support for C++11 "constexpr" keyword.
  // This could maybe be moved to the SgFunctionModifier.
     FunctionDeclaration.setDataPrototype("bool","is_constexpr","= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/3/2014): Added support for C++11 new function return type syntax.
     FunctionDeclaration.setDataPrototype("bool","using_new_function_return_type_syntax","= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/10/2016): Adding support for a scope to put function parameters to support C99 cases such as: "foobar(int size, int array[size]);"
     FunctionDeclaration.setDataPrototype ( "SgFunctionParameterScope*", "functionParameterScope", "= NULL",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/30/2016): Add a data member to detect specific EDG normalizations to functions defined in
  // templates and moved to be declarations outside of the template declarations (also effects the
  // associated template instantiations).
     FunctionDeclaration.setDataPrototype ("bool", "marked_as_edg_normalization", "= false",
            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/10/2018): Add a data member to record when this is an implicit function. Implicit functions can have no explicit
  // parameters and yet have function arguments where they are called (default type is int for such parameters).
     FunctionDeclaration.setDataPrototype ("bool", "is_implicit_function", "= false",
            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/12/2019): Mark this explicitly when it is a literal operator (C++11) (this information is held in the special function modifier).
  // FunctionDeclaration.setDataPrototype ("bool", "is_literal_operator", "= false",
  //        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     FunctionDefinition.setFunctionPrototype ( "HEADER_FUNCTION_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
     FunctionDefinition.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );

     FunctionDefinition.setDataPrototype ( "SgBasicBlock*", "body", "= NULL",
                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (10/13/2007): Modifed to avoid copying within copy mechanism so that it can be built as required.
     FunctionDefinition.setDataPrototype ( "std::map<SgNode*,int>", "scope_number_list", "",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);

     MemberFunctionDeclaration.setFunctionPrototype ( "HEADER_MEMBER_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     MemberFunctionDeclaration.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );

     MemberFunctionDeclaration.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     MemberFunctionDeclaration.editSubstitute      ( "LIST_NAME", "ctors" );
     MemberFunctionDeclaration.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     MemberFunctionDeclaration.editSubstitute      ( "LIST_FUNCTION_NAME", "ctor_initializer" );
     MemberFunctionDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );

  // DQ (3/4/2007): We want to force the copy mechanism to skip building a new SgCtorInitializerList
  // when making a copy (use NO_COPY_DATA to do this).  The p_CtorInitializerList is handled internally
  // in SageIII.
  // DQ (11/16/2004): Remove this since it is redundent with the scope data member for a function (which a member function inherits!
  // This will of course effect the number of parameters for the constructor (I hope that that will not be too drastic a change).
  // If this is a drastic change then we can include this and remove it later. Iteratively!
  // MemberFunctionDeclaration.setDataPrototype ( "SgClassDefinition*", "scope", "= NULL",
  //                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // MemberFunctionDeclaration.setDataPrototype ( "SgCtorInitializerList*", "CtorInitializerList", "= NULL",
  //                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
#if 1
  // DQ (7/20/2010): This at least does not fail our tests in the tests/nonsmoke/functional/CompileTests/copyAST_tests directory.
  // DQ (7/19/2010): This was a reported error, the copy function will not copy this even when specified using the deep copy.
     MemberFunctionDeclaration.setDataPrototype ( "SgCtorInitializerList*", "CtorInitializerList", "= NULL",
                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
#else
  // DQ (7/20/2010): This appears to cause an error in tests/nonsmoke/functional/CompileTests/copyAST_tests/test2004_160.C.
     MemberFunctionDeclaration.setDataPrototype ( "SgCtorInitializerList*", "CtorInitializerList", "= NULL",
                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
#endif

  // DQ (7/25/2007): A SgClassDefinition may not exist so we need to have a pointer to a SgClassDefinition
  // (see test2007_116.C). This pointer is only valid when the scope can not be set to the SgClassDefinition.
  // MemberFunctionDeclaration.setDataPrototype ( "SgClassDeclaration*", "associatedClassDeclaration", "= NULL",
  //                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     MemberFunctionDeclaration.setDataPrototype ( "SgDeclarationStatement*", "associatedClassDeclaration", "= NULL",
                    NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     CtorInitializerList.setFunctionPrototype ( "HEADER_CTOR_INITIALIZER_LIST", "../Grammar/Statement.code" );
     CtorInitializerList.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     CtorInitializerList.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     CtorInitializerList.editSubstitute      ( "LIST_NAME", "ctors" );
     CtorInitializerList.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     CtorInitializerList.editSubstitute      ( "LIST_FUNCTION_NAME", "ctor_initializer" );
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // CtorInitializerList.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "const SgInitializedName &" );
     CtorInitializerList.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );
     CtorInitializerList.setDataPrototype ( "SgInitializedNamePtrList", "ctors", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (12/4/2004): Now we automate the generation of the destructors
  // CtorInitializerList.setAutomaticGenerationOfDestructor(false);


  // DQ (8/15/2014): Note that VariableDeclaration data members must be initialized explicitly in the
  // void SgVariableDeclaration::post_construction_initialization() function implementation.
  //
  // [DT] 5/11/2000 -- Should have a TemplateInstantiationDefn scope as well? DQ: No, I don't think so.
  //
     VariableDeclaration.setFunctionPrototype ( "HEADER_VARIABLE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     VariableDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

  // DQ (10/17/2007): This appears to be always NULL, also there is no way to set it. Since it is
  // accessed within the traversal code  through a custom member function (compute_baseTypeDefiningDeclaration())
  // we want to avoid having this traversed within it is non-NULL.  So Mark it as not to be traversed NO_TRAVERSAL
  // and check that the correct code is output in Cxx_GrammarTreeTraversalContainer.C. No, we need to mark is as
  // DEF_TRAVERSAL so that the custom code using the compute_baseTypeDefiningDeclaration() member function will
  // be generated. So leave it as DEF_TRAVERSAL and add a memberfunction to allow the p_baseTypeDefiningDeclaration
  // data member to be set.  Then modify the compute_baseTypeDefiningDeclaration() member function to return the
  // p_baseTypeDefiningDeclaration data member when p_variableDeclarationContainsBaseTypeDefiningDeclaration == true.
  // This will allow the p_baseTypeDefiningDeclaration data member to be used (be non-null) and will avoid references
  // to the definingDeclaration (when it exists) to be found through the type (SgClassType) which is a problem
  // for the AST copy mechanism because types are shared and the defining declaration of the SgClassDeclaration from
  // the original AST is found when we search for it is the copy (the AST copied from the original AST).
  // DQ (10/16/2007): Removed NO_COPY_DATA so that the copy mechanims would work for this data member.
  // GB (8/16/2007): Added the pointer to the base type's defining
  // declaration. This is either NULL or the definition of the base type
  // (computed via the first variable's type), depending on the
  // variableDeclarationContainsBaseTypeDefiningDeclaration flag.
  // (That logic is in grammar.C where the traversal successor container code
  // is generated.)
  // VariableDeclaration.setDataPrototype("SgDeclarationStatement*", "baseTypeDefiningDeclaration", "= NULL",
  //                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // VariableDeclaration.setDataPrototype("SgDeclarationStatement*", "baseTypeDefiningDeclaration", "= NULL",
  //                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // VariableDeclaration.setDataPrototype("SgDeclarationStatement*", "baseTypeDefiningDeclaration", "= NULL",
  //                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     VariableDeclaration.setDataPrototype("SgDeclarationStatement*", "baseTypeDefiningDeclaration", "= NULL",
                      NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     VariableDeclaration.setDataPrototype("SgInitializedNamePtrList", "variables", "",
                                          NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (12/4/2004): Now we automate the generation of the destructors
  // VariableDeclaration.setAutomaticGenerationOfDestructor(false);

  // DQ (9/4/2004): Added support for qualification of type names in variable declarations
  // VariableDeclaration.setDataPrototype("bool", "need_name_qualifier", "= false",
  //                              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/5/2004): This was decided against, qualified names are now generated on the fly as required, which
  // results in a more robust mechanism.
  // DQ (9/6/2004): Instead of storing the name store a symbol (either a SgClassSymbol or SgNamespaceSymbol), since
  // this can be a cascading set of names (as in A::B::C::x) we need to store a list of these name qualifiers.
  // As long as the traversal does not traverse the list then we can put it into the current IR node.  This would have
  // to be moved to its own IR node if we later want to traverse it!  Until we have an example of this implemented
  // we will use a list of SgSymbols and later move it to a new IR node where it can be used more generally in
  // variable declarations, initializers, base class specifiers, global and member functions and tose in namespaces, etc.
  // VariableDeclaration.setDataPrototype("string", "name_qualifier", "",
  //             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // VariableDeclaration.setDataPrototype("SgSymbolPtrList", "name_qualifier_list", "",
  //                              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/5/2004): Eplicitly record if the base type of this variable declaration is to be output.
  // This is part of the support for defining vs. non-defining declarations but all types are shared
  // and the declaration is hidden in the type so we must specify external to the type if the full
  // type definition is to be output or not and we have to do it in the variable declaration instead
  // of the type.  This is also called autonomous declaration handling.  The following examples make
  // clear the definition of autonomous and non autonomous declarations:
  //      struct A { int i; };         // autonomous declaration
  //      struct B { int i; } b;       // non autonomous declaration
  // Clearly the autonomous case is the more common, but we must handle both.  Since all types and many
  // declarations are shared we can't store such information in the types or declarations. Although we
  // provide for defining and non-defining declarations, the declarations are stored in the type and the
  // type is always shared so we are forced to makr the variable declaration as containing a type to be
  // output with full definition.  Note that this is not the same concept as "type elaboration" which is
  // the use of the keyword "class" before variable names (used to distinguish them from functions since
  // within C++ both functions and variables can co-exist with the same name in the same scope).
  // VariableDeclaration.setDataPrototype("bool", "contains_non_autonomous_declaration", "= false",
  //             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     VariableDeclaration.setDataPrototype("bool", "variableDeclarationContainsBaseTypeDefiningDeclaration", "= false",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/9/2005): Adding special template support.  These data members help control the instantiation of
  // templates and there representation in the unparsed code (code generated by ROSE).
  // Note that the File_Info object is where IR nodes are marked as compiler generated (also relavant here).
     VariableDeclaration.setDataPrototype ( "SgDeclarationStatement::template_specialization_enum", "specialization", "= SgDeclarationStatement::e_no_specialization",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/15/2004): class declarations for nested classes can appear outside the scope of the class to which
  // they belong, thus the parent information is not sufficent to define the relationship of nested classes
  // (and typedefs within the classes, as well, which is the current bug in Kull).  So we need an additional
  // data member to explicitly represent the scope of a class (consistant with the design of the member
  // function declaration).

  // DQ (8/20/2006): Record if global name qualification is required on the type.
  // See test2003_01.C for an example of where this is required.
     VariableDeclaration.setDataPrototype("bool", "requiresGlobalNameQualificationOnType", "= false",
                 NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/4/2007): Support for GNU attribute mechanism.
     VariableDeclaration.setDataPrototype ("std::string", "gnu_extension_section", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     VariableDeclaration.setDataPrototype ("std::string", "gnu_extension_alias", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     VariableDeclaration.setDataPrototype ("unsigned short", "gnu_extension_initialization_priority", "= 0",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/1/2013): I think that this should be exclusively on the SgInitializedName since there can be multiple alignment specifications (one for each variable in a multi-variable variable declaration).
  // This has to be of type "unsigned long" (I think)

     VariableDeclaration.setDataPrototype ("SgDeclarationStatement::gnu_extension_visability_attribute_enum", "gnu_extension_visability", "= SgDeclarationStatement::e_gnu_attribute_visability_unspecified",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     VariableDeclaration.setDataPrototype ("SgVariableDeclaration::gnu_extension_declaration_attributes_enum", "gnu_extension_declaration_attribute", "= SgVariableDeclaration::e_gnu_attribute_unspecified",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added support for name qualification.
     VariableDeclaration.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
     VariableDeclaration.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
     VariableDeclaration.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/28/2012): We need to support lists of types at the end of a variable declaration. ROSE presently
  // will output separate declarations for each type.  This is OK (but will be fixed) however it interferes
  // with the new support for un-named types in typedef declarations.  so we want to mark declarations that
  // are output assocuated with a previous declaration.  Example of where this is relevant is:
  //      struct { } S,T;
  // which will be output as (using __xxx as an internal name):
  //      struct __xxx { } S;
  //      struct __xxx T;
  // But the second (associated) declaration need to use the name of the un-named type "S"
  // See test2012_141.C for an example of this issue.
     VariableDeclaration.setDataPrototype("bool","isAssociatedWithDeclarationList","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/30/2012): Mark this as the first declaration of a declaration list.
  // DQ (4/5/2015): NOTE: I think this data member is not used!
     VariableDeclaration.setDataPrototype("bool","isFirstDeclarationOfDeclarationList","= true",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/25/2014): Added support for C11 thread local marking.
     VariableDeclaration.setDataPrototype("bool","is_thread_local","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/1/2014): Added support for C++11 "constexpr" keyword.
  // This could maybe be moved to the SgInitializedName.
     VariableDeclaration.setDataPrototype("bool","is_constexpr","= false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/25/2019): Record when a variable declaration is built associated with a variable that is used before it is declared.
  // These variable declaration are marked as being built from a use (e.g. in a class declaration) and this allows
  // them to be reused later when the variable declaration is seen.  See Cxx11_tests/test2019_121.C for an example
  // of multiple variable declarations for the same varialbe (in different scopes).  And test2019_479.C for a case
  // of a variable use triggering the varialbe declaration and the reuse of the variable declaration later when the
  // variable declaration is processed in the members of the class definition.
     VariableDeclaration.setDataPrototype ( "bool", "builtFromUseOnly", "= false",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     VariableDefinition.setFunctionPrototype ( "HEADER_VARIABLE_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

  // backward pointer!
     VariableDefinition.setDataPrototype ( "SgInitializedName*" , "vardefn" , "= NULL",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/20/2014): This must be a SgValueExp, it is a constant expression ROSE uses a SgValueExp for this).
  // It is usually a SgUnsignedLongVal, but it can sometimes be a SgIntVal.  I wonderif it could be a cast (SgCastExp)
  // at some point.  For now we need to change this to be at least a SgValueExp instead of a SgUnsignedLongVal.
  // We need to reepresent it in the AST as an expression so that we can record the original expression tree from
  // which it was computed.  This is required where the expression contains the sizeof operator applied to machine
  // dependent types (see test2014_48.c for an example of this).  This is a problem when ROSE is using the -m32 mode.
  // Note that test2012_166.c demonstrates that this can be a SgIntVal expresion.
  // It is hard to believe that the "SgUnsignedLongVal" should not be an "int" instead!
  // VariableDefinition.setDataPrototype ( "SgUnsignedLongVal*", "bitfield", "= NULL",
  //                                       CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     VariableDefinition.setDataPrototype ( "SgExpression*", "bitfield", "= NULL",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaVariantDecl.setFunctionPrototype  ( "HEADER_ADA_VARIANT_DECL", "../Grammar/Statement.code" );
     AdaVariantDecl.setDataPrototype("SgExpression*", "discriminant", "= nullptr",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaVariantDecl.setDataPrototype("SgAdaUnscopedBlock*", "variants", "= nullptr",
                                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);



  // VariableDefinition.setDataPrototype("SgExpressionRoot*", "initializer_expr_root", "= NULL",
  //                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL,
  //                                      NO_COPY_DATA);

     AdaParameterList.setFunctionPrototype ( "HEADER_ADA_PARAMETER_LIST", "../Grammar/Statement.code" );

     AdaParameterList.editSubstitute ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     AdaParameterList.editSubstitute ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     AdaParameterList.editSubstitute ( "LIST_NAME", "parameters" );
     AdaParameterList.editSubstitute ( "LIST_FUNCTION_RETURN_TYPE", "SgDeclarationStatementPtrList::iterator" );
     AdaParameterList.editSubstitute ( "LIST_FUNCTION_NAME", "parameter" );
     AdaParameterList.editSubstitute ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     AdaParameterList.setDataPrototype ( "SgDeclarationStatementPtrList", "parameters", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);




     ClassDeclaration.setFunctionPrototype ( "HEADER_CLASS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     ClassDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

  // ClassDeclaration.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
  // ClassDeclaration.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
  // ClassDeclaration.editSubstitute      ( "LIST_NAME", "variables" );
  // ClassDeclaration.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
  // ClassDeclaration.editSubstitute      ( "LIST_FUNCTION_NAME", "variable" );
  // ClassDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "const SgInitializedName &" );

     ClassDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/10/2007): Moved to appear at the end of the class and changed to be a boolean type
  // ClassDeclaration.setDataPrototype ( "int", "class_type", "= 0",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ClassDeclaration.setDataPrototype ( "SgClassDeclaration::class_types", "class_type", "= SgClassDeclaration::e_class",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/17/2007): Modified to reflect that the SgClassType should be cloned instead of copied, however,
  // we might need a copy constructor to support this!
  // ClassDeclaration.setDataPrototype ( "SgClassType*", "type", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ClassDeclaration.setDataPrototype ( "SgClassType*", "type", "= NULL",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);

     ClassDeclaration.setDataPrototype ( "SgClassDefinition*", "definition", "= NULL",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (3/10/2007): Moved to appear at the end of the class and changed to be a boolean type
  // ClassDeclaration.setDataPrototype ( "int", "from_template", "= 0",
  //            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/15/2004): class declarations for nested classes can appear outside the scope of the class to which
  // they belong, thus the parent information is not sufficient to define the relationship of nested classes
  // (and typedefs within the classes, as well, which is the current bug in Kull).  So we need an additional
  // data member to explicitly represent the scope of a class (consistent with the design of the member
  // function declaration).
     ClassDeclaration.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // Ignore these in the constructor parameter list
  // MK: ClassDeclaration.excludeDataPrototype ( "int", "from_template", "= 0");

  // DQ (5/9/2005): Adding special template support.  These data members help control the instantiation of
  // templates and their representation in the unparsed code (code generated by ROSE).
  // Note that the File_Info object is where IR nodes are marked as compiler generated (also relavant here).
     ClassDeclaration.setDataPrototype ( "SgDeclarationStatement::template_specialization_enum", "specialization", "= SgDeclarationStatement::e_no_specialization",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/10/2007): Moved to appear at the end of the class and changed to be an enum type
  // This has to appear in its original order because it is used as a constructor parameter.
  // ClassDeclaration.setDataPrototype ( "SgClassDeclaration::class_types", "class_type", "= SgClassDeclaration::e_class",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (3/10/2007): Moved to appear at the end of the class and changed to be a boolean type
     ClassDeclaration.setDataPrototype ( "bool", "from_template", "= false",
                                         NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/10/2007): Moved to appear at the end of the class
  // DQ (12/14/2005): Where a class is referenced before it is build (common in name qualified types using
  // templates) we have to build the SgClassSymbol and so the SgClassDeclaration too early to know where the
  // class is defined (so we can't know the scope yet).  In this case we don't want to leave the scope pointer
  // NULL since this is indistinguishable from an error.  So we build a field value that indicates that the
  // we did the best we could and we will fixup the pointer when the defining declaration is built. The
  // semantics if the AST is that this is only true for a period of time during the construction of the Sage
  // AST. It should be tested in the AST consistancy tests.
     ClassDeclaration.setDataPrototype ( "bool", "fixupScope", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/10/2007): Added to support un-named constructions (specifically for SgClassDeclaration and SgEnumDeclaration)
  // Note that un-named declarations are assigned a name, for at least internal use, but that the code generation
  // phase has to be extra careful about using those names (e.g. never in a typedef, and only where more than one
  // variable was declared in in a SgVariableDeclaration, this later pointe can be difficult to distinguish because
  // we currently normalize the case of multiple variables in a single variable declaration.
     ClassDeclaration.setDataPrototype ( "bool", "isUnNamed", "= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/30/2008): Added support suggested by Ryan for PHP interface specification.
     ClassDeclaration.setDataPrototype ( "bool", "explicit_annotation_interface", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ClassDeclaration.setDataPrototype ( "bool", "explicit_interface", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ClassDeclaration.setDataPrototype ( "bool", "explicit_enum", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ClassDeclaration.setDataPrototype ( "bool", "explicit_anonymous", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     /* driscoll6 (7/19/11) support for python decorators */
     ClassDeclaration.setDataPrototype ( "SgExprListExp*", "decoratorList", "= NULL",
                                         NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (6/5/2011): Added support for name qualification.
     ClassDeclaration.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (6/5/2011): Added information required for new name qualification support.
     ClassDeclaration.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (6/5/2011): Added information required for new name qualification support.
     ClassDeclaration.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/9/2012): Added information required to indicate that declaration is contained in a type reference (as part of another declaration).
  // This is also called autonomous declaration handling.  The following examples make
  // clear the definition of autonomous and non autonomous declarations:
  //      struct A { int i; };         // autonomous declaration
  //      struct B { int i; } b;       // non autonomous declaration
  // Clearly the autonomous case is the more common, but we must handle both.
     ClassDeclaration.setDataPrototype("bool","isAutonomousDeclaration","= true",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/26/2012): Use this to mark clases that are build to represent SgTemplateType IR nodes used in
  // template argument lists inside of template declarations.  Related to concept of is_non_real setting.
     ClassDeclaration.setDataPrototype("bool","isRepresentingTemplateParameterInTemplateDeclaration","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PP (2/22/2021): To support declarations of Ada private types (aka forward declarations).
  //                 In Ada, programmers can specify the base record as part of the public portion of
  //                 a private type.
  //                 e.g., type Manager is new Employee with private;
     ClassDeclaration.setDataPrototype("SgBaseClass*","adaParentType","= NULL",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // This class contains two lists (we don't know if this edit/substitution mechanism for work for two lists)
     ClassDefinition.setFunctionPrototype ( "HEADER_CLASS_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
     ClassDefinition.editSubstitute       ( "HEADER_LIST_DECLARATIONS_1", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     ClassDefinition.editSubstitute      ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     ClassDefinition.editSubstitute      ( "LIST_NAME", "members" );
     ClassDefinition.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     ClassDefinition.editSubstitute      ( "LIST_FUNCTION_NAME", "member" );
     ClassDefinition.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     ClassDefinition.setDataPrototype("SgDeclarationStatementPtrList", "members", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     ClassDefinition.editSubstitute       ( "HEADER_LIST_DECLARATIONS_2", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     ClassDefinition.editSubstitute      ( "LIST_DATA_TYPE", "SgBaseClassPtrList" );
     ClassDefinition.editSubstitute      ( "LIST_NAME", "inheritances" );
     ClassDefinition.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     ClassDefinition.editSubstitute      ( "LIST_FUNCTION_NAME", "inheritance" );
     ClassDefinition.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgBaseClass*" );

  // DQ (10/19/2007): AST copy mechanism needs to copy this object.
     ClassDefinition.setDataPrototype("SgBaseClassPtrList", "inheritances", "",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_TREE);

  // DQ (6/13/2006): Added to support more detail in packing pragmas (packing pragmas are handled specially)
  // We might post process this information to generate the actual SgPragmaDeclaration
     ClassDefinition.setDataPrototype("unsigned int", "packingAlignment", "= 0",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/28/2007): Support for Fortran sequence statement (when used in type it is used as a type attribute).
  // This feature is considered deprecated in F2003.
     ClassDefinition.setDataPrototype("bool", "isSequence", "= false",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/28/2007): Support for Fortran private statement (when used in type it is used as a type attribute).
  // This feature is considered deprecated in F2003.
     ClassDefinition.setDataPrototype("bool", "isPrivate", "= false",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PC (7/27/2009): Support for identifying abstract classes.
     ClassDefinition.setDataPrototype("bool", "isAbstract", "= false",
                 NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     StmtDeclarationStatement.setFunctionPrototype ( "HEADER_STMT_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     StmtDeclarationStatement.setDataPrototype ( "SgStatement*", "statement", "= NULL",
                 CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_TREE);
     StmtDeclarationStatement.setFunctionSource ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     TemplateDeclaration.setFunctionPrototype  ( "HEADER_TEMPLATE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     //
     // [DT] 5/10/2000 -- Added "type".
     //
     //      5/11/2000 -- Actually, I don't think this belongs here.  It belongs in the
     //      new template instantiation declaration.
     //
     // TemplateDeclaration.setDataPrototype ( "SgClassType*", "type", "= NULL");

     TemplateDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TemplateDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateDeclaration.setDataPrototype ( "SgTemplateDeclaration::template_type_enum" , "template_kind", "= SgTemplateDeclaration::e_template_none",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/15/2004): class declarations for nested classes can appear outside the scope of the class to which
  // they belong, thus the parent information is not sufficent to define the relationship of nested classes
  // (and typedefs within the classes, as well, which is the current bug in Kull).  So we need an additional
  // data member to explicitly represent the scope of a class (consistant with the design of the member
  // function declaration).
     TemplateDeclaration.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TemplateDeclaration.setDataPrototype ( "SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);


  // DQ (6/10/2011): Added support for template class declaration, also template function declaration,
  // and template member function declaration.  Might also want a TemplateVariableDeclaration (using
  // a TemplateDeclaration for now).
     TemplateClassDeclaration.setFunctionPrototype  ( "HEADER_TEMPLATE_CLASS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );


  // **************************************************************************************************
  // DQ (11/19/2011): Added support for template handling for template declarations (interface is made
  // to match that of the SgClassDeclaration and is only supported in the EDG 4.x support).
  // **************************************************************************************************

  // TemplateClassDeclaration.setDataPrototype ( "SgTemplateClassDefinition*", "definition", "= NULL",
  //            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // TemplateClassDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TemplateClassDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateClassDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateSpecializationArguments", "= SgTemplateArgumentPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateClassDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/12/2012): Added template name support to distinguish from the other "name" which can have template specialization arguments.
     TemplateClassDeclaration.setDataPrototype ( "SgName", "templateName", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     TemplateClassDeclaration.setDataPrototype("SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // **************************************************************************************************
  // **************************************************************************************************


     TemplateFunctionDeclaration.setFunctionPrototype  ( "HEADER_TEMPLATE_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // **************************************************************************************************************
  // DQ (11/23/2011): Added matching function data members to TemplateFunctionDeclaration as in FunctionDeclaration
  // **************************************************************************************************************

     TemplateFunctionDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateFunctionDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateSpecializationArguments", "= SgTemplateArgumentPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateFunctionDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/5/2014): This marks the function as only partially represented in the text string saved and used in the unparser.
  // Functions like this were modified in the class template representation to be a function prototype and the
  // the defining declaration represented seperately (and with a partial string internally (representing only the function body)).
     TemplateFunctionDeclaration.setDataPrototype ( "bool", "string_represents_function_body", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     TemplateFunctionDeclaration.setDataPrototype("SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // **************************************************************************************************************
  // **************************************************************************************************************

     TemplateMemberFunctionDeclaration.setFunctionPrototype  ( "HEADER_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // **************************************************************************************************************************
  // DQ (11/23/2011): Added matching function data members to TemplateMemberFunctionDeclaration as in MemberFunctionDeclaration
  // **************************************************************************************************************************

     TemplateMemberFunctionDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateMemberFunctionDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateSpecializationArguments", "= SgTemplateArgumentPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateMemberFunctionDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/5/2014): This marks the function as only partially represented in the text string saved and used in the unparser.
  // Functions like this were modified in the class template representation to be a function prototype and the
  // the defining declaration represented seperately (and with a partial string internally (representing only the function body)).
     TemplateMemberFunctionDeclaration.setDataPrototype ( "bool", "string_represents_function_body", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     TemplateMemberFunctionDeclaration.setDataPrototype("SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // **************************************************************************************************************************
  // **************************************************************************************************************************


  // *******************************************************************************
  // DQ (12/6/2011): Adding support for template variables into the AST.
  // *******************************************************************************

     TemplateVariableDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_VARIABLE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

     TemplateVariableDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateVariableDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateSpecializationArguments", "= SgTemplateArgumentPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateVariableDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     TemplateVariableDeclaration.setDataPrototype("SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // *******************************************************************************




  // DQ (10/14/2014): Adding template typedef for C++11 support.
     TemplateTypedefDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

     TemplateTypedefDeclaration.setDataPrototype ( "SgTemplateParameterPtrList", "templateParameters", "= SgTemplateParameterPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateTypedefDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateSpecializationArguments", "= SgTemplateArgumentPtrList()",
                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateTypedefDeclaration.setDataPrototype ( "SgName", "string", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     TemplateTypedefDeclaration.setDataPrototype("SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // DQ (11/4/2014): Adding IR support for the instantiation of a template typedef (for C++11 support).
  // All of these data members are generally required for any template instantiation.
     TemplateInstantiationTypedefDeclaration.setFunctionPrototype ( "HEADER_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateInstantiationTypedefDeclaration.setDataPrototype ( "SgName", "templateName", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationTypedefDeclaration.setDataPrototype ( "SgName", "templateHeader", "= \"\"",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationTypedefDeclaration.setDataPrototype ( "SgTemplateTypedefDeclaration*", "templateDeclaration", "= NULL",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationTypedefDeclaration.setDataPrototype ( "SgTemplateArgumentPtrList", "templateArguments",  "= SgTemplateArgumentPtrList()",
                CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationTypedefDeclaration.setDataPrototype ( "bool", "nameResetFromMangledForm", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     TemplateClassDefinition.setFunctionPrototype    ( "HEADER_TEMPLATE_CLASS_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
     TemplateFunctionDefinition.setFunctionPrototype ( "HEADER_TEMPLATE_FUNCTION_DEFINITION_STATEMENT", "../Grammar/Statement.code" );


  // DQ (4/16/2005): Added support for explicit template instantiation to IR (required to address template linking issues)
     TemplateInstantiationDirectiveStatement.setFunctionPrototype  ( "HEADER_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/23/2015): After fixing up the AST generation to make the declaration a unique IR node, we can allow this to be traversed.
  // DQ (11/23/2015): Mark this IR node as CLONE_TREE instead of CLONE_PTR (which will not compile since IR nodes don't have copy constructors, by design).
  // DQ (11/23/2015): Mark this IR node as CLONE_PTR instead of NO_COPY_DATA.
  // DQ (11/21/2015): Mark this IR node as NO_COPY_DATA instead of CLONE_TREE (which is the default).
  // DQ (4/8/2014): Restored the original behavior (traversing the associated child declaration).
  // Upon investigation, it is not a shared IR node and traversing it is important to the
  // support for the AST Copy mechanims (else we fail test2006_08.C and test2008_37.C).
  // DQ (4/7/2014): Added support for the AST copy mechanism which fails for test2006_08.C
  // and test2008_37.C.
  // DQ (4/3/2014): This will refer to an existing template instantiation so when we traverse
  // it we will be sharing the template instantiation.  For this reason we should supress the
  // traversal of the declaration in this SgTemplateInstantiationDirectiveStatement IR node.
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);
  // TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_TREE);
     TemplateInstantiationDirectiveStatement.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_TREE);


  // DQ (8/2/2014): Added to support C++11 "extern template class vector<float>;" used to specify
  // that a template should not be instantiated (see Cxx11_tests/test2014_18.C).
     TemplateInstantiationDirectiveStatement.setDataPrototype("bool","do_not_instantiate","= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     TemplateInstantiationDecl.setFunctionPrototype ( "HEADER_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
  // This might have to be made to be type == "int" but it makes more sense as a template_type_enum
  // TemplateInstantiationDecl.setDataPrototype ( "template_type_enum" , "template_kind", "= e_template_none");

  // DQ (2/29/2004): Added to support templates.
  // With the other infomation here the original template declaration can be constructed
  // (e.g. templateHeader + "class" + templateName + templateParameters = "template <class T> ABC"
  // or "class" + templateName + templateParameters = "class ABC<int>")
     TemplateInstantiationDecl.setDataPrototype ( "SgName", "templateName", "= \"\"",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (2/29/2004): Added to support templates
     TemplateInstantiationDecl.setDataPrototype ( "SgName", "templateHeader", "= \"\"",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/6/2007): The templateDeclaration data member should not be copied, is should be shared
  // and then the reference fixed up as required if the SgTemplateDeclaration it is pointing to was
  // copied were it wwas structyreally represented in the original AST.
  // DQ (10/13/2004): This is not defined to be part of the traversal since it is shared between
  // many nodes (template instantiations for both functions and class using this template).
  // Traversing it would not cause a cycle so it might not be a bad idea, but for now we limit
  // the traversal so that we try to visit IR nodes only once if possible.
  // DQ (12/22/2011): This is required by the new design to support SgTemplateClassDeclaration derived from SgClassDeclaration.
     TemplateInstantiationDecl.setDataPrototype ( "SgTemplateClassDeclaration*",
          "templateDeclaration", "= NULL",CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/15/2004): Modified to include in traversal (didn't work, need to make the TemplateArgumentPtrList a new IR node in Sage III)
  // DQ (2/29/2004): Should this be changed to contain a list
  // (if so it can't be traversed, since we can't have list and data be traversed in the same object)
  // DQ (3/12/2004): Move the template parameters to the SgTemplateDeclaration (now that we have
  // access to it from the SgTemplateInstantiationDecl object).
     TemplateInstantiationDecl.setDataPrototype ( "SgTemplateArgumentPtrList", "templateArguments",  "= SgTemplateArgumentPtrList()",
                    CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/11/2004): instantiated template names must be reset once the template parameters are known
  // We want to use names like "ABC<int>" instead of the mangled equivalent names.  This variable records
  // if the name has been reset or not to avoid using mangled names in the unparsed (generated) code.
     TemplateInstantiationDecl.setDataPrototype ( "bool", "nameResetFromMangledForm", "= false",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TemplateInstantiationDefn.setFunctionPrototype ( "HEADER_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (3/22/2004): Support for template functions
     TemplateInstantiationFunctionDecl.setFunctionPrototype (
                   "HEADER_TEMPLATE_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
  // DQ (2/15/2005): Added to hold original function name without template arguments
     TemplateInstantiationFunctionDecl.setDataPrototype ( "SgName", "templateName", "= \"\"",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/6/2007): The templateDeclaration data member should not be copied, is should be shared
  // and then the reference fixed up as required if the SgTemplateDeclaration it is pointing to was
  // copied were it was structure really represented in the original AST.
  // DQ (12/22/2011): This is required by the new design to support SgTemplateClassDeclaration derived from SgClassDeclaration.
     TemplateInstantiationFunctionDecl.setDataPrototype ( "SgTemplateFunctionDeclaration*", "templateDeclaration", "= NULL",
                    CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationFunctionDecl.setDataPrototype ( "SgTemplateArgumentPtrList", "templateArguments",  "= SgTemplateArgumentPtrList()",
                                                  CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/15/2005): instantiated function template names must be reset once the template parameters are known
  // We want to use names like "ABC<int>" instead of the mangled equivalent names.  This variable records
  // if the name has been reset or not to avoid using mangled names in the unparsed (generated) code.
     TemplateInstantiationFunctionDecl.setDataPrototype ( "bool", "nameResetFromMangledForm", "= false",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/28/2013): The template arguments should not always be output where the function is used in a SgTemplateFunctionRefExp
  // and so we need to record this.  This does not handle where individual function reference expression may or may not explicitly
  // specify the template argument list, but only where some do or all do not explicitly specify the template argument list.
  // See test2013_242.C for an example of where this is required (a boost graph example test code).
     TemplateInstantiationFunctionDecl.setDataPrototype ( "bool", "template_argument_list_is_explicit", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/22/2004): Support for template member functions
     TemplateInstantiationMemberFunctionDecl.setFunctionPrototype (
                   "HEADER_TEMPLATE_MEMBER_FUNCTION_INSTANTIATION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (2/15/2005): Added to hold original function name without template arguments
     TemplateInstantiationMemberFunctionDecl.setDataPrototype ( "SgName", "templateName", "= \"\"",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/6/2007): The templateDeclaration data member should not be copied, is should be shared
  // and then the reference fixed up as required if the SgTemplateDeclaration it is pointing to was
  // copied were it wwas structyreally represented in the original AST.
  // DQ (12/22/2011): This is required by the new design to support SgTemplateClassDeclaration derived from SgClassDeclaration.
     TemplateInstantiationMemberFunctionDecl.setDataPrototype ( "SgTemplateMemberFunctionDeclaration*", "templateDeclaration", "= NULL",
                    CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TemplateInstantiationMemberFunctionDecl.setDataPrototype ( "SgTemplateArgumentPtrList", "templateArguments",  "= SgTemplateArgumentPtrList()",
                                                  CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/15/2005): instantiated member function template names must be reset once the template parameters are known
  // We want to use names like "ABC<int>" instead of the mangled equivalent names.  This variable records
  // if the name has been reset or not to avoid using mangled names in the unparsed (generated) code.
     TemplateInstantiationMemberFunctionDecl.setDataPrototype ( "bool", "nameResetFromMangledForm", "= false",
                                                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (6/28/2013): The template arguments should not always be output where the function is used in a SgTemplateMemberFunctionRefExp
  // and so we need to record this.  This does not handle where individual function reference expression may or may not explicitly
  // specify the template argument list, but only where some do or all do not explicitly specify the template argument list.
     TemplateInstantiationMemberFunctionDecl.setDataPrototype ( "bool", "template_argument_list_is_explicit", "= false",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/11/2018): Introducing representation for non-real "stuff" (template parameters)
     NonrealDecl.setFunctionPrototype ( "HEADER_NONREAL_DECL", "../Grammar/Statement.code");

     NonrealDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                        CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ( "SgDeclarationScope*", "nonreal_decl_scope", "= NULL",
                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);
     NonrealDecl.setDataPrototype ( "SgNonrealType*", "type", "= NULL",
                        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TV (04/16/2018):
     NonrealDecl.setDataPrototype ("int","template_parameter_position","= -1",
                                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("int","template_parameter_depth","= -1",
                                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     NonrealDecl.setDataPrototype ( "SgDeclarationStatement*", "templateDeclaration", "= NULL",
                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     NonrealDecl.setDataPrototype ("SgTemplateArgumentPtrList", "tpl_args", "= SgTemplateArgumentPtrList()",
                                   NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("SgTemplateParameterPtrList", "tpl_params", "= SgTemplateParameterPtrList()",
                                   NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     NonrealDecl.setDataPrototype ("bool","is_class_member","= false", NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("bool","is_template_param","= false", NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("bool","is_template_template_param","= false", NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("bool","is_nonreal_template","= false", NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NonrealDecl.setDataPrototype ("bool","is_nonreal_function","= false", NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     EnumDeclaration.setFunctionPrototype ( "HEADER_ENUM_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     EnumDeclaration.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     EnumDeclaration.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     EnumDeclaration.editSubstitute      ( "LIST_NAME", "enumerators" );
     EnumDeclaration.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
     EnumDeclaration.editSubstitute      ( "LIST_FUNCTION_NAME", "enumerator" );
  // DQ (6/1/2004): Changed list to contain pointers to SgInitializedName elements
  // EnumDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "const SgInitializedName &" );
     EnumDeclaration.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );

  // We do not traverse the following data member for the moment!
     EnumDeclaration.setDataPrototype ( "SgName"     , "name", "= \"\"",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     EnumDeclaration.setDataPrototype ( "bool", "embedded", "=false",
                                       NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/18/2007): Modified to force AST copy mechanim to copy the type (using CLONE_PTR option).
     EnumDeclaration.setDataPrototype ( "SgEnumType*", "type", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);

  // PP (10/28/2021): Added link to the parent type of a derived enum. Other derived types are represented by (TypedefDeclaration -> AdaDerivedType).
  //                  For enums this is insufficient, because the inherited enumerators (elements) get different type and different scope.
  //                  Thus, a derived enum is represented as normal enum, but its adaParentType points to the base type of the derived type.
  //                  \todo should this always be a SgAdaDerivedType to better indicate the relationship?
     EnumDeclaration.setDataPrototype ( "SgType*", "adaParentType", "= NULL",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/31/2006): I think that we should be traversing the SgInitializedName objects in the enumerator list
     EnumDeclaration.setDataPrototype ( "SgInitializedNamePtrList", "enumerators", "",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (6/23/2005): Enum declarations can require name qualification to support the identification of functions
  // taking enum types.  Since the EnumType must then be qualified the declaration must support name qualification
  // even though it's definition does not appear separately from it's declaration (by the C standard). To support
  // the name qualification we have to rely on either an explicit representation of the scope, or use the parent
  // information (from get_parent() member function).  Because we want to use this within the name mangling during
  // construction of the global symbol table for function symbols (durring the EDG/Sage III translation), and the
  // parents are only properly and consistantly set after the EDG/Sage III translation (see AstFixes.C), we must
  // store the scope explicitly in the AST.  Too bad we have to store it explicitly, we nearly didn't need it.
  // this fixes a bug in the function symbol table construction where symbols from function types are shared and
  // functions with close but not identical functions types were sharing the same symbols because the gnerated
  // names failed to include the qulified names in the key used to hash the function symbols in the global table.
  // this lead to nearly the correct generated code, but subtle errors, difficult bugs to fix until template
  // specializations of STL code failed to compile and provide tests cases (overly complex test codes which were
  // distilled into test2005_93.C and test2005_94.C
     EnumDeclaration.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


  // DQ (3/10/2007): Added to support un-named constructions (specifically for SgClassDeclaration and SgEnumDeclaration)
  // Note that un-named declarations are assigned a name, for at least internal use, but that the code generation
  // phase has to be extra careful about using those names (e.g. never in a typedef, and only where more than one
  // variable was declared in in a SgVariableDeclaration, this later pointe can be difficult to distinguish because
  // we currently normalize the case of multiple variables in a single variable declaration.
     EnumDeclaration.setDataPrototype ( "bool", "isUnNamed", "= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/10/2012): Added information required to indicate that declaration is contained in a type reference (as part of another declaration).
  // This is also called autonomous declaration handling.  The following examples make
  // clear the definition of autonomous and non autonomous declarations:
  //      enum A { i; }; typedef A a;    // autonomous declaration
  //      typedef enum B { i; } b;       // non autonomous declaration
  // Clearly the autonomous case is the more common, but we must handle both.
     EnumDeclaration.setDataPrototype("bool","isAutonomousDeclaration","= true",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/12/2014): Adding support for enum field type specifier.
     EnumDeclaration.setDataPrototype ( "SgType*", "field_type", "= NULL",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);

  // DQ (8/12/2014): Adding support for C++11 scoped enum declarations.
     EnumDeclaration.setDataPrototype("bool","isScopedEnum","= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/13/2019): C++11 allows enum prototypes, which means that the defining declarations (and even othr prototype
  // (nondefining declarations) can be located in a different scope from the local scope for the enum, so we need name
  // qualification support.
     EnumDeclaration.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     EnumDeclaration.setDataPrototype("bool","type_elaboration_required","= false",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     EnumDeclaration.setDataPrototype("bool","global_qualification_required","= false",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);



     ExprStatement.setFunctionPrototype ( "HEADER_EXPRESSION_STATEMENT", "../Grammar/Statement.code" );

     ExprStatement.setDataPrototype ( "SgExpression*", "expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     LabelStatement.setFunctionPrototype ( "HEADER_LABEL_STATEMENT", "../Grammar/Statement.code" );
     LabelStatement.setDataPrototype     ( "SgName", "label", "= \"\"",
                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     LabelStatement.setDataPrototype     ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (1/6/2018): This should be handled as a compound statement, meaning that the statement in
  // the label should not be NULL and that it should be traversed.
     LabelStatement.setDataPrototype     ( "SgStatement*", "statement", "= nullptr",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     LabelStatement.setDataPrototype     ( "SgLabelStatement::label_type_enum", "label_type", "= SgLabelStatement::e_default",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     LabelStatement.setDataPrototype     ( "bool", "gnu_extension_unused", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Not that the SgWhileStmt is used for the Fortran do while statement (because the test is
  // at the top of the loop and so is more closely matched to the C/C++ "while(){}" statement
  // than the C/C++ "do {} while();")
     WhileStmt.setFunctionPrototype ( "HEADER_WHILE_STATEMENT", "../Grammar/Statement.code" );
     WhileStmt.setDataPrototype     ( "SgStatement*", "condition", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WhileStmt.setDataPrototype     ( "SgStatement*", "body", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // driscoll6 (7/21/11) support for python
     WhileStmt.setDataPrototype ( "SgStatement*", "else_body",  "= NULL",
                               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     WhileStmt.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/17/2007): Added support for string labels (for Fortran).
     WhileStmt.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/26/2007): Fortran specific, has associated enddo statement
     WhileStmt.setDataPrototype ( "bool", "has_end_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     DoWhileStmt.setFunctionPrototype ( "HEADER_DO_WHILE_STATEMENT", "../Grammar/Statement.code" );
  // DQ (11/17/2005): Swapped order to force order of traversal to reflect structure.
     DoWhileStmt.setDataPrototype     ( "SgStatement*", "body", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     DoWhileStmt.setDataPrototype     ( "SgStatement*", "condition", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     SwitchStatement.setFunctionPrototype ( "HEADER_SWITCH_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/7/2006): Trying to remove the WRAP mechanism since it is overly complex and not required
     SwitchStatement.setDataPrototype ( "SgStatement*", "item_selector", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // JJW (12/9/2008): The body does not need to be a block
     SwitchStatement.setDataPrototype ( "SgStatement*", "body", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (8/24/2007): Added to support Fortran specific use of WhileStmt
     SwitchStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/16/2007): Added support for string labels (for Fortran).
     SwitchStatement.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     CaseOptionStmt.setFunctionPrototype ( "HEADER_CASE_OPTION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/7/2006): Trying to remove the WRAP mechanism since it is overly complex and not required
     CaseOptionStmt.setDataPrototype ( "SgExpression*", "key", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/3/2018): Restored the original behavior (case options statment MUST be a compound statement, see test2017_20.c).
  // DQ (12/23/2017): Removing body from AST for case statement. This is part of a minor design change to address
  // the required flexability to support duff's devices and more complex switch statements.
     CaseOptionStmt.setDataPrototype ( "SgStatement*", "body", "= NULL",
                                       CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/6/2006): Added support for GNU case label ranges (e.g. "case 2 ... 5:" in switch statements; see test2005_202.C)
     CaseOptionStmt.setDataPrototype ( "SgExpression*", "key_range_end", " = NULL",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/31/2009): Added support for named case construct.
     CaseOptionStmt.setDataPrototype ( "std::string", "case_construct_name", " = \"\"",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (8/21/2018): Added support for Jovial FALLTHRU option.
     CaseOptionStmt.setDataPrototype ( "bool", "has_fall_through", " = false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TryStmt.setFunctionPrototype ( "HEADER_TRY_STATEMENT", "../Grammar/Statement.code" );
     TryStmt.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     TryStmt.editSubstitute       ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     TryStmt.editSubstitute       ( "LIST_NAME", "catch_statement_seq" );
     TryStmt.editSubstitute       ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     TryStmt.editSubstitute       ( "LIST_FUNCTION_NAME", "catch_statement" );
     TryStmt.editSubstitute       ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );

     TryStmt.setDataPrototype     ( "SgStatement*", "body", "= NULL",
                                    CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     TryStmt.setDataPrototype ( "SgCatchStatementSeq*", "catch_statement_seq_root", "= NULL",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     TryStmt.setDataPrototype     ( "SgStatement*", "else_body", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     TryStmt.setDataPrototype     ( "SgStatement*", "finally_body", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     CatchStatementSeq.setFunctionPrototype ( "HEADER_CATCH_STATEMENT_SEQ", "../Grammar/Statement.code" );
     CatchStatementSeq.editSubstitute   ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     CatchStatementSeq.editSubstitute   ( "LIST_DATA_TYPE", "SgStatementPtrList" );
     CatchStatementSeq.editSubstitute   ( "LIST_NAME", "catch_statement_seq" );
     CatchStatementSeq.editSubstitute   ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     CatchStatementSeq.editSubstitute   ( "LIST_FUNCTION_NAME", "catch_statement" );
     CatchStatementSeq.editSubstitute   ( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );
     CatchStatementSeq.setDataPrototype ( "SgStatementPtrList", "catch_statement_seq", "",
                                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (12/4/2004): Now we automate the generation of the destructors
  // CatchStatementSeq.setAutomaticGenerationOfDestructor(false);

     CatchOptionStmt.setFunctionPrototype ( "HEADER_CATCH_OPTION_STATEMENT", "../Grammar/Statement.code" );

     CatchOptionStmt.setDataPrototype ( "SgVariableDeclaration*", "condition", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     CatchOptionStmt.setDataPrototype ( "SgStatement*"         , "body"     , "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     CatchOptionStmt.setDataPrototype ( "SgTryStmt*"            , "trystmt"  , "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     DefaultOptionStmt.setFunctionPrototype ( "HEADER_DEFAULT_OPTION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (1/3/2018): Restored the original behavior (case options statment MUST be a compound statement, see test2017_20.c).
  // DQ (12/23/2017): Removing body from AST for case statement. This is part of a minor design change to address
  // the required flexability to support duff's devices and more complex switch statements.
  // DefaultOptionStmt.setDataPrototype ( "SgStatement*", "body"   , "= NULL",
  //                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DefaultOptionStmt.setDataPrototype ( "SgStatement*", "body"   , "= NULL",
  //                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DefaultOptionStmt.setDataPrototype ( "SgStatement*", "body"   , "= NULL",
                                          CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/31/2009): Added support for named default case construct.
     DefaultOptionStmt.setDataPrototype ( "std::string", "default_construct_name", " = \"\"",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (8/21/2018): Added support for Jovial FALLTHRU option.
     DefaultOptionStmt.setDataPrototype ( "bool", "has_fall_through", " = false",
                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     BreakStmt.setFunctionPrototype ( "HEADER_BREAK_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/17/2007): Fortran support requires string label target ("break" in C == "exit" in Fortran)
     BreakStmt.setDataPrototype     ( "std::string", "do_string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ContinueStmt.setFunctionPrototype ( "HEADER_CONTINUE_STATEMENT", "../Grammar/Statement.code" );
     FortranContinueStmt.setFunctionPrototype ( "HEADER_FORTRAN_CONTINUE_STATEMENT", "../Grammar/Statement.code" );

  // Fortran requires string label target ("continue" in C == "cycle" in Fortran)
     ContinueStmt.setDataPrototype ( "std::string", "do_string_label", "= \"\"",
                                     NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     ReturnStmt.setFunctionPrototype ( "HEADER_RETURN_STATEMENT", "../Grammar/Statement.code" );

#if 0
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
  // DQ (12/9/2004): As additional comments to the code below.
  // The following data members MUST appear in this order since a wrapper mechanism is used
  // to preserve an older interface within Sage III using newer automatically generated
  // functions.  We can at some point explore what might be a fix less sensative to ordering.

  // QY 11/9/04  set return_expr as the indirect member "operand" wrapped inside expr_root.
     ReturnStmt.setDataPrototype      ( "SgExpression*", "return_expr", " = NULL",
                                     INDIRECT_CONSTRUCTOR_PARAMETER,
                                     BUILD_INDIRECT_ACCESS_FUNCTIONS,
                                     NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // QY 11/9/04 expression_root needs to follow expr immediately
     ReturnStmt.setDataPrototype("SgExpressionRoot*", "expression_root",
                                 "operand", WRAP_CONSTRUCTOR_PARAMETER,
                                 BUILD_WRAP_ACCESS_FUNCTIONS,
                                 DEF_TRAVERSAL, NO_DELETE, CLONE_TREE);
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
#else
  // DQ (11/7/2006): Trying to remove the WRAP mechanism since it is overly complex and not required
     ReturnStmt.setDataPrototype ( "SgExpression*", "expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
#endif

     GotoStatement.setFunctionPrototype ( "HEADER_GOTO_STATEMENT", "../Grammar/Statement.code" );
     GotoStatement.setDataPrototype     ( "SgLabelStatement*", "label", "= NULL",
                                          CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/16/2007): Added to support new way to handle labels and goto (as implemented in Fortran support)
     GotoStatement.setDataPrototype     ( "SgLabelRefExp*", "label_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/22/2017): Adding support for GNU extension computed goto for C (different enough from
  // Fortran to just extend the C IR node instead of reuse the Fortran computd goto IR node).
  // Note that in Fortran this is the asigned goto, but in C GNU explicitly calls it the computed
  // goto (and it is different from Fortran's computed goto).  GNU claims that the name "assigned
  // goto" does not make sense for the C language.
     GotoStatement.setDataPrototype     ( "SgExpression*", "selector_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Ada begin
  // PP (03/23/20) Ada Exit Stmt
     AdaExitStmt.setFunctionPrototype ( "HEADER_ADA_EXIT_STATEMENT", "../Grammar/Statement.code" );
     AdaExitStmt.setDataPrototype     ( "SgStatement*", "loop", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaExitStmt.setDataPrototype     ( "SgExpression*", "condition", "= NULL",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaExitStmt.setDataPrototype     ( "bool", "explicitLoopName", "= false",
                                        CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaLoopStmt.setFunctionPrototype ( "HEADER_ADA_LOOP_STATEMENT", "../Grammar/Statement.code" );
     AdaLoopStmt.setDataPrototype     ( "SgBasicBlock*", "body", "= NULL",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     // in analogy to for and while loops
     AdaLoopStmt.setDataPrototype     ( "std::string", "string_label", "= \"\"",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaDelayStmt.setFunctionPrototype ( "HEADER_ADA_DELAY_STATEMENT", "../Grammar/Statement.code" );
     AdaDelayStmt.setDataPrototype     ( "SgExpression*", "time", "= NULL",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaDelayStmt.setDataPrototype     ( "bool", "isRelative", "= false",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (11/09/2020)
     AdaSelectStmt.setFunctionPrototype            ( "HEADER_ADA_SELECT_STATEMENT", "../Grammar/Statement.code" );
     AdaSelectStmt.setDataPrototype                ( "SgAdaSelectAlternativeStmt*", "select_path", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectStmt.setDataPrototype                ( "SgAdaSelectAlternativeStmt*", "or_path", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectStmt.setDataPrototype                ( "SgBasicBlock*", "else_path", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectStmt.setDataPrototype                ( "SgBasicBlock*", "abort_path", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectStmt.setDataPrototype                ( "SgAdaSelectStmt::select_type_enum",
                                                     "select_type", "= SgAdaSelectStmt::e_unknown",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL,  NO_DELETE);
     AdaSelectAlternativeStmt.setFunctionPrototype ( "HEADER_ADA_SELECT_ALTERNATIVE_STATEMENT", "../Grammar/Statement.code" );
     AdaSelectAlternativeStmt.setDataPrototype     ( "SgBasicBlock*", "body", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectAlternativeStmt.setDataPrototype     ( "SgExpression*", "guard", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaSelectAlternativeStmt.setDataPrototype     ( "SgAdaSelectAlternativeStmt*", "next", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaTerminateStmt.setFunctionPrototype ( "HEADER_ADA_TERMINATE_STATEMENT", "../Grammar/Statement.code" );

     AdaUnscopedBlock.setFunctionPrototype ( "HEADER_ADA_UNSCOPED_BLOCK", "../Grammar/Statement.code" );
     AdaUnscopedBlock.editSubstitute( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     AdaUnscopedBlock.editSubstitute( "LIST_DATA_TYPE", "SgStatementPtrList");
     AdaUnscopedBlock.editSubstitute( "LIST_NAME", "statements" );
     AdaUnscopedBlock.editSubstitute( "LIST_FUNCTION_RETURN_TYPE", "void" );
     AdaUnscopedBlock.editSubstitute( "LIST_FUNCTION_NAME", "statement" );
     AdaUnscopedBlock.editSubstitute( "LIST_ELEMENT_DATA_TYPE", "SgStatement*" );
     AdaUnscopedBlock.setDataPrototype( "SgStatementPtrList", "statements", "= {}",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE );

     AdaVariantWhenStmt.setFunctionPrototype ( "HEADER_ADA_VARIANT_WHEN_STMT", "../Grammar/Statement.code" );
     AdaVariantWhenStmt.setDataPrototype( "SgExprListExp*", "choices", "= nullptr",
                                          CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE );
     AdaVariantWhenStmt.setDataPrototype( "SgAdaUnscopedBlock*", "components", "= nullptr",
                                          CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE );

     // Ada end

     AsmStmt.setFunctionPrototype  ( "HEADER_ASM_STATEMENT", "../Grammar/Statement.code" );

#if 0
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
  // DQ (12/9/2004): As additional comments to the code below.
  // The following data members MUST appear in this order since a wrapper mechanism is used
  // to preserve an older interface within Sage III using newer automatically generated
  // functions.  We can at some point explore what might be a fix less sensative to ordering.

  // QY 11/9/04  set expr as the indirect member "operand" wrapped inside expr_root.
     AsmStmt.setDataPrototype      ( "SgExpression*", "expr", " = NULL",
                                     INDIRECT_CONSTRUCTOR_PARAMETER,
                                     BUILD_INDIRECT_ACCESS_FUNCTIONS,
                                     NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // QY 11/9/04 expr_root needs to follow expr immediately
     AsmStmt.setDataPrototype("SgExpressionRoot*", "expr_root", "operand",
                              WRAP_CONSTRUCTOR_PARAMETER, BUILD_WRAP_ACCESS_FUNCTIONS,
                              DEF_TRAVERSAL, NO_DELETE, CLONE_TREE);
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
#else
     AsmStmt.setDataPrototype ( "std::string", "assemblyCode", "= \"\"",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (7/22/2006): This is a list of operands (SgAsmOp IR nodes) (see test2006_93.C)
  // Note that the asm template is the first entry in the operand list!
  // AsmStmt.setDataPrototype ( "SgExpressionPtrList", "operands", "",
  //           NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, DEF_DELETE);
  // DQ (8/13/2006): This variable should not be deleted (since it is a value instead of a pointer).
     AsmStmt.setDataPrototype ( "bool", "useGnuExtendedFormat", "= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AsmStmt.setDataPrototype ( "SgExpressionPtrList", "operands", "",
               NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (7/26/2006): The clobber list is a list of register codes (architecture specific, but gnu standard register names).
     AsmStmt.setDataPrototype ( "SgAsmStmt::AsmRegisterNameList", "clobberRegisterList", "",
               NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AsmStmt.setDataPrototype ( "bool", "isVolatile", "= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

     SpawnStmt.setFunctionPrototype  ( "HEADER_SPAWN_STATEMENT", "../Grammar/Statement.code" );

#if 0
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
  // DQ (12/9/2004): As additional comments to the code below.
  // The following data members MUST appear in this order since a wrapper mechanism is used
  // to preserve an older interface within Sage III using newer automatically generated
  // functions.  We can at some point explore what might be a fix less sensative to ordering.

  // QY 11/9/04  set expr as the indirect member "operand" wrapped inside expr_root.
     SpawnStmt.setDataPrototype      ( "SgFunctionCallExp*", "the_func",
                                        " = NULL", INDIRECT_CONSTRUCTOR_PARAMETER,
                                       BUILD_INDIRECT_ACCESS_FUNCTIONS,
                                       NO_TRAVERSAL, NO_DELETE, NO_COPY_DATA);
  // QY 11/9/04 expr_root needs to follow the_func immediately
     SpawnStmt.setDataPrototype("SgExpressionRoot*", "the_func_root", "operand",
                                WRAP_CONSTRUCTOR_PARAMETER, BUILD_WRAP_ACCESS_FUNCTIONS,
                                DEF_TRAVERSAL, NO_DELETE, CLONE_TREE);
  // ***** Warning ****** Warning ****** Warning ****** Warning ****** Warning ******
#else
  // DQ (11/7/2006): Trying to remove the WRAP mechanism since it is overly complex and not required
     SpawnStmt.setDataPrototype ( "SgFunctionCallExp*", "the_func", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
#endif

  // DQ (12/13/2005): Added support for empty statement (and empty expression).
     NullStatement.setFunctionPrototype  ( "HEADER_NULL_STATEMENT", "../Grammar/Statement.code" );

  // DQ (12/13/2005): Added variant statement to support future patterns
  // specifications (contains RegEx string specifier for SgStatement IR node).
     VariantStatement.setFunctionPrototype  ( "HEADER_VARIANT_STATEMENT", "../Grammar/Statement.code" );

     TypedefDeclaration.setFunctionPrototype  ( "HEADER_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TypedefDeclaration.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype ( "SgType*", "base_type", "= NULL",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // TypedefDeclaration.setDataPrototype ( "SgTypedefType*", "type", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype ( "SgTypedefType*", "type", "= NULL",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, CLONE_PTR);

  // DQ (7/22/2004): Where this has been changed to be a valid pointer in the AST
  // (fix to EDG/Sage connetion), its traversal now causes a cycle in the example
  // "typedef struct Atag4 { typedef Atag4 Btag; } A4;".  To fix this we need to
  // disallow the traversal of the declaration in a typedef when it is a valid pointer.
  // GB (8/13/2007): This is now traversed again, but the traversal successor
  // code generated by ROSETTA takes care of returning NULL whenever the
  // typedefBaseTypeContainsDefiningDeclaration flag is false.
     TypedefDeclaration.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // TypedefDeclaration.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     TypedefDeclaration.setDataPrototype ( "SgSymbol*", "parent_scope", "= NULL",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (10/5/2004): Support for defining declarations hidden within typedefs (e.g. "typedef struct A { int x; } Atype;")
  // Such base types are considered unnamed and they get their name from the typedef directly. Because the types
  // are shared (and contain the declarations) we can't mark either type or the declarations directly, so we have to
  // mark the typedef directly.  This information is used in the unparser to know when to unparse the defining declaration.
  // This allows the unparser to generate code exactly as it appears originally which is the most conservative approach
  // since we assume that anything handed to ROSE had to first be compiled by EDG (front-end) and so it represents valid
  // C++ code with the declarations in the precise order required to compile correctly.
     TypedefDeclaration.setDataPrototype ( "bool", "typedefBaseTypeContainsDefiningDeclaration", "= false",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/22/2004): This is likely redundant with the parent_scope except that it appears that parent_scope is likely set wrong!
  // DQ (11/22/2004): class declarations for nested classes can appear outside the scope of the class to which
  // they belong, thus the parent information is not sufficent to define the relationship of nested classes
  // (and typedefs within the classes, as well, which is the current bug in Kull).  So we need an additional
  // data member to explicitly represent the scope of a class (consistant with the design of the member
  // function declaration).
     TypedefDeclaration.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

#if 0
  // DQ (12/21/2005): This global qualification is now replaced by a more general mechanism to handle
  // qualified names. Here we have a list of qualified names a global qualification is represented by
  // a SgQualifiedName that contains a pointer to the SgGlobal scope. This is so variables such as
  // "::X::Y::Z::variable" can be represented properly.
  // DQ (8/25/2005): Added to support use of global qualification in typedef (e.g. "typedef ::Xtype globalXtype;")
  // TypedefDeclaration.setDataPrototype ( "bool", "isGlobalScopeExplicitlySpecified", "= false",
  //            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype ( "SgQualifiedNamePtrList", "qualifiedNameList", "",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (8/20/2006): Record if global name qualification is required on the type.
  // See test2003_01.C for an example of where this is required.
  // TypedefDeclaration.setDataPrototype("bool", "requiresGlobalNameQualificationOnType", "= false",
  //             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype("bool", "requiresGlobalNameQualificationOnType", "= false",
                 NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/14/2011): Added support for name qualification.
  // TypedefDeclaration.setDataPrototype ( "int", "name_qualification_length_for_base_type", "= 0",
  //        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype ( "int", "name_qualification_length_for_base_type", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/14/2011): Added information required for new name qualification support.
  // TypedefDeclaration.setDataPrototype("bool","type_elaboration_required_for_base_type","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype("bool","type_elaboration_required_for_base_type","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/14/2011): Added information required for new name qualification support.
  // TypedefDeclaration.setDataPrototype("bool","global_qualification_required_for_base_type","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     TypedefDeclaration.setDataPrototype("bool","global_qualification_required_for_base_type","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/9/2012): Added information required to indicate that declaration is contained in a type reference (as part of another declaration).
  // This is also called autonomous declaration handling.  The following examples make
  // clear the definition of autonomous and non autonomous declarations:
  //      class A { int i; }; typedef A a;    // autonomous declaration
  //      typedef class B { int i; } b;       // non autonomous declaration
  // Clearly the autonomous case is the more common, but we must handle both.
     TypedefDeclaration.setDataPrototype("bool","isAutonomousDeclaration","= true",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/28/2012): We need to support lists of types at the end of a typedef declaration. ROSE presently
  // will output seperate declarations for each type.  This is OK (but will be fixed) however it interferes
  // with the new support for un-named types in typedef declarations.  so we want to mark declarations that
  // are output assocuated with a previous declaration.  Example of where this is relevant is:
  //      typedef struct { } S,T;
  // which will be output as:
  //      typedef struct { } S;
  //      typedef S T;
  // But the second (associated) declaration need to use the name of the un-named type "S"
  // See test2012_141.C for an example of this issue.
     TypedefDeclaration.setDataPrototype("bool","isAssociatedWithDeclarationList","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/30/2012): Mark this as the first declaration of a declaration list.
     TypedefDeclaration.setDataPrototype("bool","isFirstDeclarationOfDeclarationList","= true",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/10/2019): This is needed to support pointers to member type variables.
     TypedefDeclaration.setDataPrototype ( "int", "name_qualification_length", "= 0",
                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/10/2019): This is needed to support pointers to member type variables.
     TypedefDeclaration.setDataPrototype("bool","type_elaboration_required","= false",
                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/10/2019): This is needed to support pointers to member type variables.
     TypedefDeclaration.setDataPrototype("bool","global_qualification_required","= false",
                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     PragmaDeclaration.setFunctionPrototype ( "HEADER_PRAGMA_STATEMENT", "../Grammar/Statement.code" );

  // DQ (3/17/2007): Since we traverse the SgPragma in a SgPragmaDeclaration, don't delete it. OK to share in AST merge also.
     PragmaDeclaration.setDataPrototype     ( "SgPragma*"   , "pragma", "= NULL",
                   CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
#if 0
  // DQ (6/13/2006): Added to support more detail in pragmas
     PragmaDeclaration.setDataPrototype     ( "bool"   , "isIdentPragma", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     PragmaDeclaration.setDataPrototype     ( "bool"   , "isPackPragma", "= false",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     PragmaDeclaration.setDataPrototype     ( "unsigned int"   , "packPragmaValue", "= 0",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


  // DQ (3/22/2019): Adding EmptyDeclaration to support addition of comments and CPP directives that will permit
  // token-based unparsing to work with greater precision. For example, used to add an include directive with
  // greater precision to the global scope and permit the unparsing via the token stream to be used as well.
     EmptyDeclaration.setFunctionPrototype ( "HEADER_EMPTY_DECLARATION", "../Grammar/Statement.code" );


  // Support for extern "C" and extern "C++"
  // ClinkageStatement.setDataPrototype      ( "char*"   , "languageSpecifier", "= \"\"",
  //                                         NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);
  // ClinkageStartStatement.setDataPrototype ( "std::string"   , "dummyString14", "= \"\"",
  //                                         NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ClinkageEndStatement.setDataPrototype   ( "char*"   , "dummyString15", "= \"\"",
  //                                         NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, DEF_DELETE);

  // DQ (4/22/2004): Support for namespaces: NamespaceDeclarationStatement,
  //      NamespaceAliasDeclarationStatement, UsingDeclarationStatement
     NamespaceDeclarationStatement.setFunctionPrototype ( "HEADER_NAMESPACE_DECLARATION_STATEMENT",
                                                          "../Grammar/Statement.code" );
     NamespaceDeclarationStatement.setDataPrototype ( "SgName", "name", "= \"\"",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceDeclarationStatement.setDataPrototype ( "SgNamespaceDefinitionStatement*", "definition", "= NULL",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     NamespaceDeclarationStatement.setDataPrototype ( "bool", "isUnnamedNamespace", "= false",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/12/2014): Adding support for C++11 inlined namespaces.
     NamespaceDeclarationStatement.setDataPrototype ( "bool", "isInlinedNamespace", "= false",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#if 0
  // DQ (2/19/2006): Added to handle case destribed in the header file.
     NamespaceDeclarationStatement.setDataPrototype ( "SgScopeStatement*", "scope", "= NULL",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

  // NamespaceDeclarationStatement.setDataPrototype ("SgDeclarationStatementPtrList", "declarationList", "",
  //                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     NamespaceAliasDeclarationStatement.setFunctionPrototype (
          "HEADER_NAMESPACE_ALIAS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     NamespaceAliasDeclarationStatement.setDataPrototype ( "SgName", "name", "= \"\"",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceAliasDeclarationStatement.setDataPrototype (
               "SgNamespaceDeclarationStatement*", "namespaceDeclaration", "= NULL",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (7/8/2014): Added support for name qualification.
  // NamespaceAliasDeclarationStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
  //        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceAliasDeclarationStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (7/8/2014): Added information required for new name qualification support.
  // NamespaceAliasDeclarationStatement.setDataPrototype("bool","type_elaboration_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceAliasDeclarationStatement.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (7/8/2014): Added information required for new name qualification support.
  // NamespaceAliasDeclarationStatement.setDataPrototype("bool","global_qualification_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceAliasDeclarationStatement.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/8/2018): WE need to add a new data member to support a namespace alias to another namespace alias (see test2018_26.C).
  // Note that the namespaceDeclaration data member represents the semantics, but a namespaceAliasDeclaration will support
  // the structure of the original source code.  Not clear if this should be traversed within the AST (not for now).
     NamespaceAliasDeclarationStatement.setDataPrototype("bool","is_alias_for_another_namespace_alias","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceAliasDeclarationStatement.setDataPrototype ("SgNamespaceAliasDeclarationStatement*", "namespaceAliasDeclaration", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     NamespaceDefinitionStatement.setFunctionPrototype ( "HEADER_NAMESPACE_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
  // NamespaceDefinitionStatement.setDataPrototype ("SgDeclarationStatementPtrList", "declarationList", "",
  //           NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL);
     NamespaceDefinitionStatement.editSubstitute   ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     NamespaceDefinitionStatement.editSubstitute   ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     NamespaceDefinitionStatement.editSubstitute   ( "LIST_NAME", "declarations" );
     NamespaceDefinitionStatement.editSubstitute   ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     NamespaceDefinitionStatement.editSubstitute   ( "LIST_FUNCTION_NAME", "declaration" );
     NamespaceDefinitionStatement.editSubstitute   ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     NamespaceDefinitionStatement.setDataPrototype ( "SgDeclarationStatementPtrList", "declarations", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     NamespaceDefinitionStatement.setDataPrototype ( "SgNamespaceDeclarationStatement*", "namespaceDeclaration", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (7/23/2011): Pointers to previous and next matching namespace definitions (C++ namespaces are reintrant).
     NamespaceDefinitionStatement.setDataPrototype ( "SgNamespaceDefinitionStatement*", "previousNamespaceDefinition", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceDefinitionStatement.setDataPrototype ( "SgNamespaceDefinitionStatement*", "nextNamespaceDefinition", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (5/16/2013): This is where we put the union of all of the symbols for all of the namespace definitions that
  // are logically the same namespace, but seperated structurally because C++ namespaces can be re-entrant.
  // Note that only SgAliasSymbols are put here and that the original symbol is placed into the namespace definition
  // associated with its declaration.
     NamespaceDefinitionStatement.setDataPrototype ( "SgNamespaceDefinitionStatement*", "global_definition", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     NamespaceDefinitionStatement.setDataPrototype ( "bool", "isUnionOfReentrantNamespaceDefinitions", "= false",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     UsingDeclarationStatement.setFunctionPrototype ( "HEADER_USING_DECLARATION_STATEMENT",
                                                          "../Grammar/Statement.code" );
  // DQ (9/11/2004): A using declaration is more general than I first understood. It can have a declaration
  // more general than just a SgNamespaceDeclarationStatement.  So we have to use a SgDeclarationStatement
  // so that we can reference variables, functions, member functions, AND namespace declarations!
  // since we can get the name from the declaration (it should be qualified so we want to use the
  // declaration's mechanism for name qualification rather than implement the mechanism for using
  // declarations explicitly).
  // DQ (7/20/2005): Actually it can be more general then just a declaration (SgDeclaration) since
  // it can also handle a variable name or a enum field (SgInitializedName). (see test2005_114.C)
  // UsingDeclarationStatement.setDataPrototype     (
  //           "SgDeclarationStatement*", "declaration", "= NULL",
  //           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDeclarationStatement.setDataPrototype     ( "SgDeclarationStatement*", "declaration", "= NULL",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDeclarationStatement.setDataPrototype     ( "SgInitializedName*", "initializedName", "= NULL",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added support for name qualification.
  // UsingDeclarationStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
  //        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDeclarationStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
  // UsingDeclarationStatement.setDataPrototype("bool","type_elaboration_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDeclarationStatement.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
  // UsingDeclarationStatement.setDataPrototype("bool","global_qualification_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDeclarationStatement.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (1/10/2019): Adding support for C++11 inheriting constructor.
     UsingDeclarationStatement.setDataPrototype("bool","is_inheriting_constructor","= false",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PP (3/20/2023): Ada uses UsingDeclarationStatement for modeling use/use type directives
  //                 Attributes can be used to specify class wide application: use some.type'class
     //~ UsingDeclarationStatement.setDataPrototype("bool","is_ada_class_wide","= false",
                                //~ NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // PP (4/18/23): replaced flag (above) with proper attribute name
     UsingDeclarationStatement.setDataPrototype("SgName", "adaTypeAttribute","= \"\"",
                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);



     UsingDirectiveStatement.setFunctionPrototype ( "HEADER_USING_DIRECTIVE_STATEMENT",
                                                    "../Grammar/Statement.code" );
     UsingDirectiveStatement.setDataPrototype     ( "SgNamespaceDeclarationStatement*", "namespaceDeclaration", "= NULL",
               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     WithStatement.setFunctionPrototype      ( "HEADER_WITH_STATEMENT", "../Grammar/Statement.code" );
     WithStatement.setDataPrototype("SgExpression*", "expression", "= NULL",
                                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WithStatement.setDataPrototype("SgStatement*", "body", "= NULL",
                                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     PassStatement.setFunctionPrototype  ( "HEADER_PASS_STATEMENT", "../Grammar/Statement.code" );

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added support for name qualification.
  // UsingDirectiveStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
  //        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDirectiveStatement.setDataPrototype ( "int", "name_qualification_length", "= 0",
            NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
  // UsingDirectiveStatement.setDataPrototype("bool","type_elaboration_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDirectiveStatement.setDataPrototype("bool","type_elaboration_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (6/11/2015): Skip building of access functions (because it sets the isModified flag, not wanted for the name qualification step).
  // DQ (5/12/2011): Added information required for new name qualification support.
  // UsingDirectiveStatement.setDataPrototype("bool","global_qualification_required","= false",
  //                            NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UsingDirectiveStatement.setDataPrototype("bool","global_qualification_required","= false",
                                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // PP ADA types
     // packages
     AdaPackageBodyDecl.setFunctionPrototype  ( "HEADER_ADA_PACKAGE_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaPackageBodyDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaPackageBodyDecl.setDataPrototype ( "SgAdaPackageBody*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     // \todo PP could we compute the scope from the AdaPackageSpecDecl instead?
     AdaPackageBodyDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaPackageBodyDecl.setDataPrototype ( "SgAdaPackageSpecDecl*", "spec", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

/*
 *     OmpCriticalStatement.setDataPrototype ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
 */

     AdaPackageSpecDecl.setFunctionPrototype  ( "HEADER_ADA_PACKAGE_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaPackageSpecDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaPackageSpecDecl.setDataPrototype ( "SgAdaPackageSpec*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaPackageSpecDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaPackageSpecDecl.setDataPrototype ( "SgAdaPackageBodyDecl*", "body", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     // generics
     AdaGenericDefn.setFunctionPrototype ( "HEADER_ADA_GENERIC_DEFN", "../Grammar/Statement.code" );
     AdaGenericDefn.setDataPrototype     ( "SgDeclarationStatementPtrList", "declarations", "",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaGenericDecl.setFunctionPrototype ( "HEADER_ADA_GENERIC_DECL", "../Grammar/Statement.code" );
     // PP(10/14/22) added name to generic decl, b/c the name mangler may get invoked when the
     //              formal parameter list is processed, and at that time the generified declaration
     //              has not been processed.
     AdaGenericDecl.setDataPrototype     ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaGenericDecl.setDataPrototype     ( "SgAdaGenericDefn*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaGenericDecl.setDataPrototype     ( "SgDeclarationStatement*", "declaration", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     // PP(4/19/23) added explicit scope, so we can wire the child declaration's scope to the generic defn
     //             (which is the proper nesting). Then the generic decl requires a scope, so we can define a generic
     //             sub-unit independently.
     AdaGenericDecl.setDataPrototype     ( "SgScopeStatement*", "scope", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     AdaFormalTypeDecl.setFunctionPrototype ( "HEADER_ADA_FORMAL_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaFormalTypeDecl.setDataPrototype ( "SgName", "name", "=\"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaFormalTypeDecl.setDataPrototype ( "SgAdaFormalType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaFormalTypeDecl.setDataPrototype ( "SgAdaParameterList*", "discriminants", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaFormalPackageDecl.setFunctionPrototype ( "HEADER_ADA_FORMAL_PACKAGE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaFormalPackageDecl.setDataPrototype ( "SgName", "name", "=\"\"",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (3/31/22) like AdaGenericInstanceDecl, AdaFormalPackageDecl refers to a generic package, but that could also be
     //              a package renaming declaration. => use SgDeclarationStatement
     AdaFormalPackageDecl.setDataPrototype ( "SgDeclarationStatement*", "declaration", "= nullptr",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaFormalPackageDecl.setDataPrototype ( "SgExprListExp*", "actual_parameters", "= nullptr",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (7/15/22): adding support for storing prototype instantiations
     AdaFormalPackageDecl.setDataPrototype ( "SgDeclarationStatement*", "prototype", "= nullptr",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaFormalPackageDecl.setDataPrototype ( "SgScopeStatement*", "prototypeScope", "= nullptr",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaGenericInstanceDecl.setFunctionPrototype ( "HEADER_ADA_GENERIC_INSTANCE_DECL", "../Grammar/Statement.code" );
     AdaGenericInstanceDecl.setDataPrototype ( "SgName", "name", "=\"\"",
                                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (4/7/23) type is SgDeclarationStatement (and not SgAdaGenericDecl) to allow for renamed generics
     AdaGenericInstanceDecl.setDataPrototype ( "SgDeclarationStatement*", "genericDeclaration", "= nullptr",
                                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (4/1/22): adding scope to store actual instantiation
     //              \todo specify which scope it will be..
     AdaGenericInstanceDecl.setDataPrototype ( "SgScopeStatement*", "instantiatedScope", "= nullptr",
                                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaGenericInstanceDecl.setDataPrototype ( "SgExprListExp*", "actual_parameters", "= nullptr",
                                               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaGenericInstanceDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                                               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (4/7/23): \todo consider storing the instantiated declaration as convenience link


     // tasks
     AdaTaskSpecDecl.setFunctionPrototype  ( "HEADER_ADA_TASK_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskSpecDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskSpecDecl.setDataPrototype ( "SgAdaTaskSpec*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaTaskSpecDecl.setDataPrototype ( "SgAdaTaskType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaTaskTypeDecl.setFunctionPrototype  ( "HEADER_ADA_TASK_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskTypeDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskTypeDecl.setDataPrototype ( "SgAdaTaskSpec*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaTaskTypeDecl.setDataPrototype ( "SgAdaTaskType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskTypeDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                                        NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);



     AdaTaskBodyDecl.setFunctionPrototype  ( "HEADER_ADA_TASK_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskBodyDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskBodyDecl.setDataPrototype ( "SgDeclarationStatement*", "specificationDeclaration", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskBodyDecl.setDataPrototype ( "SgAdaTaskBody*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     // protected objects
     AdaProtectedSpecDecl.setFunctionPrototype  ( "HEADER_ADA_PROTECTED_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedSpecDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedSpecDecl.setDataPrototype ( "SgAdaProtectedSpec*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaProtectedSpecDecl.setDataPrototype ( "SgAdaProtectedType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaProtectedTypeDecl.setFunctionPrototype  ( "HEADER_ADA_PROTECTED_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedTypeDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedTypeDecl.setDataPrototype ( "SgAdaProtectedSpec*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaProtectedTypeDecl.setDataPrototype ( "SgAdaProtectedType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedTypeDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaProtectedBodyDecl.setFunctionPrototype  ( "HEADER_ADA_PROTECTED_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedBodyDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedBodyDecl.setDataPrototype ( "SgDeclarationStatement*", "specificationDeclaration", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaProtectedBodyDecl.setDataPrototype ( "SgAdaProtectedBody*", "definition", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     // renaming
     AdaRenamingDecl.setFunctionPrototype  ( "HEADER_ADA_RENAMING_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaRenamingDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // PP (4/6/21): renamed initially was designed to rename another declaration. To make it work for
     //              initialized names and 'real' declarations, the symbol was used as common denominator.
     //              Ada allows to rename array elements and ranges, which is why a symbol is insufficient.
     //              Thus the AST type of renamed was changed to SgExpression.
     //~ AdaRenamingDecl.setDataPrototype ( "SgSymbol*", "renamed", "= nullptr",
                                           //~ CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaRenamingDecl.setDataPrototype ( "SgExpression*", "renamed", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaRenamingDecl.setDataPrototype ( "SgType*", "type", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaDiscriminatedTypeDecl.setFunctionPrototype  ( "HEADER_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );


     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgDeclarationScope*", "discriminantScope", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgAdaParameterList*", "discriminants", "= nullptr",
                                           CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgDeclarationStatement*", "discriminatedDecl", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgAdaDiscriminatedType*", "type", "= nullptr",
                                           NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgScopeStatement*", "scope", "= nullptr",
                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

#if 0 /* NO_NAME */
     // the name is computed from the child
     AdaDiscriminatedTypeDecl.setDataPrototype ( "SgName", "name", "= \"\"",
                                                 CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

#endif /* NO_NAME */



     AdaRepresentationClause.setFunctionPrototype("HEADER_ADA_REPRESENTATION_CLAUSE", "../Grammar/Statement.code" );
     AdaRepresentationClause.setDataPrototype ( "SgType*", "recordType", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaRepresentationClause.setDataPrototype ( "SgExpression*", "alignment", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaRepresentationClause.setDataPrototype ( "SgBasicBlock*", "components", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
/*
     \pp replaced list of SgAdaComponentClausePtrList with an SgBasicBlock, because we need to also store pragmas.
     AdaRepresentationClause.editSubstitute( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     AdaRepresentationClause.editSubstitute( "LIST_DATA_TYPE", "SgAdaComponentClausePtrList" );
     AdaRepresentationClause.editSubstitute( "LIST_NAME", "components" );
     AdaRepresentationClause.editSubstitute( "LIST_FUNCTION_RETURN_TYPE", "void" );
     AdaRepresentationClause.editSubstitute( "LIST_FUNCTION_NAME", "component" );
     AdaRepresentationClause.editSubstitute( "LIST_ELEMENT_DATA_TYPE", "SgAdaComponentClause*" );
     AdaRepresentationClause.setDataPrototype("SgAdaComponentClausePtrList", "components", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
*/

     AdaEnumRepresentationClause.setFunctionPrototype("HEADER_ADA_ENUM_REPRESENTATION_CLAUSE", "../Grammar/Statement.code" );
     AdaEnumRepresentationClause.setDataPrototype ( "SgType*", "enumType", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaEnumRepresentationClause.setDataPrototype ( "SgExprListExp*", "components", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);


     AdaAttributeClause.setFunctionPrototype("HEADER_ADA_ATTRIBUTE_CLAUSE", "../Grammar/Statement.code" );
     AdaAttributeClause.setDataPrototype ( "SgAdaAttributeExp*", "attribute", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaAttributeClause.setDataPrototype ( "SgExpression*", "size", "= nullptr",
                                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);



  // PP (01/28/21): Making AdaComponentClause a declaration
     AdaComponentClause.setFunctionPrototype ( "HEADER_ADA_COMPONENT_CLAUSE"     , "../Grammar/Statement.code");

     AdaComponentClause.setDataPrototype("SgVarRefExp*", "component", "",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaComponentClause.setDataPrototype("SgExpression*", "offset", "",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaComponentClause.setDataPrototype("SgRangeExp*", "range", "",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);



#if USE_FORTRAN_IR_NODES
     ProgramHeaderStatement.setFunctionPrototype ( "HEADER_PROGRAM_HEADER_STATEMENT", "../Grammar/Statement.code" );

  // DQ (3/20/2007): This is derived from a SgFunctionDeclaration (so it does not need much more).
  // DQ (3/20/2007): Program Header statement does not have arguments (see 2003 standard)
  // ProgramHeaderStatement.editSubstitute      ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
  // ProgramHeaderStatement.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
  // ProgramHeaderStatement.editSubstitute      ( "LIST_NAME", "args" );
  // ProgramHeaderStatement.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
  // ProgramHeaderStatement.editSubstitute      ( "LIST_FUNCTION_NAME", "arg" );
  // ProgramHeaderStatement.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );
  // DQ (3/20/2007): Added name of program (and removed explicitly defined functions in ../Grammar/Statement.code)
  // ProgramHeaderStatement.setDataPrototype    ( "SgName", "name", "",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (3/20/2007): This Fortran construct does not have a return type.
  // ProgramHeaderStatement.setDataPrototype    ( "SgType*", "result_type", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ProgramHeaderStatement.setDataPrototype ( "SgVariableSymbol*", "function_result", "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ProgramHeaderStatement.setDataPrototype ( "SgBasicBlock*", "body"   , "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ProgramHeaderStatement.setDataPrototype ( "bool", "program_statement_explicit"   , "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/25/2007): Added storage for the label that can be associated with the end statement that is
  // implicit with a ProcedureHeaderStatement (even were it is explicit in the source code).
  // ProgramHeaderStatement.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ProgramHeaderStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (3/20/2007): This is derived from a SgFunctionDeclaration (so it does not need much more).
     ProcedureHeaderStatement.setFunctionPrototype ( "HEADER_PROCEDURE_HEADER_STATEMENT", "../Grammar/Statement.code" );
  // ProcedureHeaderStatement.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
  // ProcedureHeaderStatement.editSubstitute       ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
  // ProcedureHeaderStatement.editSubstitute       ( "LIST_NAME", "args" );
  // ProcedureHeaderStatement.editSubstitute       ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
  // ProcedureHeaderStatement.editSubstitute       ( "LIST_FUNCTION_NAME", "arg" );
  // ProcedureHeaderStatement.editSubstitute       ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );

  // DQ (3/20/2007): Added the procedure name (not is work from Rice, not sure why).
  // ProcedureHeaderStatement.setDataPrototype     ( "SgName", "name", "",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ProcedureHeaderStatement.setDataPrototype     ( "SgType*", "result_type", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ProcedureHeaderStatement.setDataPrototype     ( "SgVariableSymbol*", "function_result", "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/26/2007): Added support for ProcedureHeaderStatement to be used for different types
  // of Fortran subprograms: functions, subroutines, and data blocks.
  // DQ (3/21/2007): Consider removing this IR node and using a SgFunctionDeclaration.
  // We can evaluate this idea after we get the Rice stuff more in place.  Also
  // this function could be impimented to just check for a void return type.
  // ProcedureHeaderStatement.setDataPrototype ( "bool", "is_a_function", "= false",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ProcedureHeaderStatement.setDataPrototype ( "SgProcedureHeaderStatement::subprogram_kind_enum", "subprogram_kind", "= SgProcedureHeaderStatement::e_unknown_kind",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // ProcedureHeaderStatement.setDataPrototype ( "SgBasicBlock*", "body"   , "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // ProcedureHeaderStatement.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);

  // DQ (3/25/2007): Added storage for the label that can be associated with the end statement that is
  // implicit with a ProcedureHeaderStatement (even were it is explicit in the source code).
  // ProcedureHeaderStatement.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ProcedureHeaderStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/30/2007): Support for return variable
     ProcedureHeaderStatement.setDataPrototype ( "SgInitializedName*", "result_name", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (12/27/2007): Added fortran entry statement.
     EntryStatement.setFunctionPrototype ( "HEADER_ENTRY_STATEMENT", "../Grammar/Statement.code" );
  // DQ (1/20/2008): Support for return variable
     EntryStatement.setDataPrototype ( "SgInitializedName*", "result_name", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     InterfaceStatement.setFunctionPrototype ( "HEADER_INTERFACE_STATEMENT", "../Grammar/Statement.code" );
     InterfaceStatement.setDataPrototype ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (10/2/2008): Added support for specification of interface types
     InterfaceStatement.setDataPrototype ( "SgInterfaceStatement::generic_spec_enum", "generic_spec", "= SgInterfaceStatement::e_default_interface_type",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#if 0
  // InterfaceStatement.setDataPrototype ( "SgFunctionDeclaration*", "function", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     InterfaceStatement.setDataPrototype ( "SgDeclarationStatementPtrList", "interface_procedure_declarations", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (10/2/2008): When we build the SgInterfaceStatement IR node we only have limited information about the functions.
  // Later when we see the functions following the "contains statement" we can access the function declarations.
  // This information is saved and the names are connected to the function declaration in the final processing of
  // the module (I hope that earlier than that will not be required).
     InterfaceStatement.setDataPrototype ( "SgStringList", "interface_procedure_names", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif
     InterfaceStatement.setDataPrototype ( "SgInterfaceBodyPtrList", "interface_body_list", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

#if 0
     InterfaceStatement.setDataPrototype ( "SgBasicBlock*", "body"   , "= NULL",
                                         CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (3/20/2007): This should be a SgScopeStatement (Gina has it as a SgStatement, so we might have a problem later)
  // InterfaceStatement.setDataPrototype ( "SgScopeStatement*",  "scope", "= NULL",
  //            CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     InterfaceStatement.setDataPrototype ( "SgScopeStatement*",  "scope", "= NULL",
                               CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // InterfaceStatement.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif
     InterfaceStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     CommonBlock.setFunctionPrototype ( "HEADER_COMMON_BLOCK_STATEMENT", "../Grammar/Statement.code" );
  // CommonBlock.setDataPrototype ("SgName", "name", "= \"\"",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     CommonBlock.setDataPrototype ( "SgCommonBlockObjectPtrList", "block_list", "",
  // Liao 12/8/2010, This must be traversable to reach variable references underneath it.
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  //                NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // CommonBlock.setDataPrototype("SgInitializedNamePtrList", "variables", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     CommonBlock.setAutomaticGenerationOfDestructor(false);

  // DQ (3/20/2007): Removed this since it is better to compute the qualified name dynamically than to have it
  // statically specified in the AST and possibly set incorrectly after a possible transformation.  This also
  // simplifies the transformations since they don't have to worry about setting this correctly.
  // CommonBlock.setDataPrototype("SgSymbolPtrList", "name_qualifier_list", "",
  //      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/19/2007): New IR node
     NamelistStatement.setFunctionPrototype ( "HEADER_NAMELIST_STATEMENT", "../Grammar/Statement.code" );
  // Implement this as a list of strings for now, since it is not clear that it is limited to variables.
  // If it is limited to variable then use an expression list of variable references, or a list of initialized name objects.
     NamelistStatement.setDataPrototype     ( "SgNameGroupPtrList", "group_list", "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (4/16/2011): This is the Fortran specific import statment IR node, there is also a Java specific SgJavaImportStatement (which is a declaration).
     ImportStatement.setFunctionPrototype ( "HEADER_IMPORT_STATEMENT", "../Grammar/Statement.code" );
  // Implement this as a list of strings for now, since it is not clear that it is limited to variables.
  // If it is limited to variable then use an expression list of variable references, or a list of initialized name objects.
     ImportStatement.setDataPrototype     ( "SgExpressionPtrList", "import_list", "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/30/2007): Added Associate statement
     AssociateStatement.setFunctionPrototype ( "HEADER_ASSOCIATE_STATEMENT", "../Grammar/Statement.code" );
  // The AssociateStatement has a variable declaration and a body, the AssociateStatement is a scope
  // Pei-Hung (07/24/2019): added DeclarationStatement list for multiple associates
     AssociateStatement.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     AssociateStatement.editSubstitute       ( "LIST_DATA_TYPE", "SgDeclarationStatementPtrList" );
     AssociateStatement.editSubstitute       ( "LIST_NAME", "associates" );
     AssociateStatement.editSubstitute       ( "LIST_FUNCTION_RETURN_TYPE", "void" );
     AssociateStatement.editSubstitute       ( "LIST_FUNCTION_NAME", "associate" );
     AssociateStatement.editSubstitute       ( "LIST_ELEMENT_DATA_TYPE", "SgDeclarationStatement*" );
     AssociateStatement.setDataPrototype ( "SgDeclarationStatementPtrList", "associates"   , "",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AssociateStatement.setDataPrototype     ( "SgBasicBlock*", "body", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     ModuleStatement.setFunctionPrototype ( "HEADER_MODULE_STATEMENT", "../Grammar/Statement.code" );
#if 0
     ModuleStatement.setDataPrototype ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // ModuleStatement.setDataPrototype ( "SgBasicBlock*", "body"   , "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ModuleStatement.setDataPrototype ( "SgDeclarationStatementPtrList", "members"   , "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // ModuleStatement.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif
     ModuleStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     UseStatement.setFunctionPrototype ( "HEADER_USE_STATEMENT", "../Grammar/Statement.code" );
     UseStatement.setDataPrototype ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UseStatement.setDataPrototype ( "bool", "only_option", "= false",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UseStatement.setDataPrototype ( "std::string", "module_nature", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // UseStatement.setDataPrototype ( "SgExprListExp*", "rename_list", "= NULL",
  //              CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     UseStatement.setDataPrototype ( "SgRenamePairPtrList", "rename_list", "",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (11/12/2008): With the Rice support for module files (thanks) we can now always reference
  // the module statement used by any use statement.  There can only be a single module per use statement.
  // UseStatement.setDataPrototype ( "SgModuleStatementPtrList", "module_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UseStatement.setDataPrototype ( "SgModuleStatement*", "module", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // UseStatement.setDataPrototype ( "SgUseOnlyExpression*", "use_only"   , "= NULL",
  //      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (3/22/2007): Note that the FortranDo statement is not a scope and that I have changed
  // the Rice version to use SgExpressions where they had SgStatement (to conform to the grammar).
  // This is the concept of "labeled or non-labeled do" and "block do"
     FortranDo.setFunctionPrototype ( "HEADER_FORTRAN_DO", "../Grammar/Statement.code" );
     FortranDo.setDataPrototype     ( "SgExpression*", "initialization", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     FortranDo.setDataPrototype     ( "SgExpression*", "bound", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     FortranDo.setDataPrototype     ( "SgExpression*", "increment", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     FortranDo.setDataPrototype     ( "SgBasicBlock*", "body", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // FortranDo.setDataPrototype     ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FortranDo.setDataPrototype     ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FortranDo.setDataPrototype     ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (12/21/2007): This controls use of old style vs. new style DO loops.
  // --- New style uses a "do i=0,n ... end do" statement
  // --- Old style uses a "do xxx i=0,n ... xxx continue" statement
     FortranDo.setDataPrototype     ( "bool", "old_style", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/26/2007): This is different from old_style, since old_stype uses a label and a
  // labled statement (commonly a continue statement).
     FortranDo.setDataPrototype     ( "bool", "has_end_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  //FMZ (2/3/2009): Added for co-array "withteam" stmt
     //WithTeamStatement.setDataPrototype("SgWithTeamStatement*", "withteamStmt", "= NULL",
                      //NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     //WithTeamStatement.setDataPrototype("SgInitializedName", "variable", "",
                      //NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     CAFWithTeamStatement.setFunctionPrototype( "HEADER_WITH_TEAM_STATEMENT", "../Grammar/Statement.code" );
     CAFWithTeamStatement.setFunctionSource ( "SOURCE_WITH_TEAM_STATEMEMT", "../Grammar/Statement.code" );

     // CAFWithTeamStatement.setDataPrototype ( "SgName" , "teamId", "= \"\"",
      CAFWithTeamStatement.setDataPrototype ( "SgVarRefExp*" , "teamId", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     CAFWithTeamStatement.setDataPrototype ( "SgBasicBlock*", "body", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);

     CAFWithTeamStatement.setDataPrototype ( "bool", "endHasTeamId", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Fortran 95 specific construct (different from C/C++ for loop).
  // Rasmussen (10/25/2018): Added forall_statement_kind_enum to allow specifying as a DO CONCURRENT statement
     ForAllStatement.setFunctionPrototype ( "HEADER_FORALL_STATEMENT", "../Grammar/Statement.code" );
     ForAllStatement.setDataPrototype ( "SgExprListExp*", "forall_header", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     ForAllStatement.setDataPrototype ( "SgBasicBlock*", "body", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     ForAllStatement.setDataPrototype ( "bool", "has_end_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ForAllStatement.setDataPrototype ( "std::string", "string_label", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ForAllStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ForAllStatement.setDataPrototype ( "SgForAllStatement::forall_statement_kind_enum",
                                        "forall_statement_kind", "= SgForAllStatement::e_forall_statement",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (10/22/2018): Added JovialForThenStatement; An SgForStatement is used for other
  // forms of Jovial for statements to allow analysis be the same as C.
     JovialForThenStatement.setFunctionPrototype ( "HEADER_JOVIAL_FOR_THEN_STATEMENT", "../Grammar/Statement.code" );
     JovialForThenStatement.setDataPrototype     ( "SgExpression*", "initialization", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     JovialForThenStatement.setDataPrototype     ( "SgExpression*", "while_expression", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     JovialForThenStatement.setDataPrototype     ( "SgExpression*", "by_or_then_expression", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     JovialForThenStatement.setDataPrototype     ( "SgBasicBlock*", "loop_body", "= NULL",
                                      CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     JovialForThenStatement.setDataPrototype     ( "SgJovialForThenStatement::loop_statement_type_enum",
                                         "loop_statement_type", "= SgJovialForThenStatement::e_unknown",
                                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS,  NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (11/12/2018): Added to support Jovial COMPOOL modules
     JovialCompoolStatement.setFunctionPrototype ( "HEADER_JOVIAL_COMPOOL_STATEMENT", "../Grammar/Statement.code" );
     JovialCompoolStatement.setDataPrototype     ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     //SK: Matlab specific for loop
     MatlabForStatement.setFunctionPrototype ("HEADER_MATLAB_FOR_STATEMENT", "../Grammar/Statement.code" );
     MatlabForStatement.setDataPrototype ( "SgExpression*", "index", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     MatlabForStatement.setDataPrototype ( "SgExpression*", "range", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     MatlabForStatement.setDataPrototype ( "SgBasicBlock*", "body", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);


  // DQ (3/22/2007): Added new Fortran Nonblocked do loop construct. For example: "do 10 i=... \n 10 a = 1 \n"
     FortranNonblockedDo.setFunctionPrototype ( "HEADER_FORTRAN_NONBLOCKED_DO", "../Grammar/Statement.code" );
  // This end_statement can be shared so don't traverse it (to avoid errors if not marked as explicitly shared.
     FortranNonblockedDo.setDataPrototype     ( "SgStatement*", "end_statement", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/14/2007): Added new data members to Fortran IR nodes.
  // Rasmussen (7/11/2020): Added F2018 addition, quiet
     ProcessControlStatement.setFunctionPrototype ( "HEADER_PROCESS_CONTROL_STATEMENT", "../Grammar/Statement.code" );
     ProcessControlStatement.setDataPrototype     ( "SgProcessControlStatement::control_enum",
                                                    "control_kind", "= SgProcessControlStatement::e_unknown",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ProcessControlStatement.setDataPrototype     ( "SgExpression*", "code", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ProcessControlStatement.setDataPrototype     ( "SgExpression*", "quiet", "= NULL",
               NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (8/14/2007): Added new data members to Fortran IR nodes.
     IOStatement.setFunctionPrototype ( "HEADER_IO_STATEMENT", "../Grammar/Statement.code" );
     IOStatement.setDataPrototype    ( "SgIOStatement::io_statement_enum", "io_statement", "= SgIOStatement::e_unknown",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IOStatement.setDataPrototype    ( "SgExprListExp*", "io_stmt_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IOStatement.setDataPrototype ( "SgExpression*", "unit", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IOStatement.setDataPrototype ( "SgExpression*", "iostat", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IOStatement.setDataPrototype ( "SgExpression*", "err", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     IOStatement.setDataPrototype ( "SgExpression*", "iomsg", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Rasmussen (9/20/2018): Added F2018 image control statements
     ImageControlStatement.setFunctionPrototype ( "HEADER_IMAGE_CONTROL_STATEMENT", "../Grammar/Statement.code" );
     ImageControlStatement.setDataPrototype     ( "SgImageControlStatement::image_control_statement_enum", "image_control_statement", "= SgImageControlStatement::e_unknown",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ImageControlStatement.setDataPrototype     ( "SgExpression*", "stat", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ImageControlStatement.setDataPrototype     ( "SgExpression*", "err_msg", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ImageControlStatement.setDataPrototype     ( "SgExpression*", "acquired_lock", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Derived from ImageControlStatement
     SyncAllStatement.setFunctionPrototype      ( "HEADER_SYNC_ALL_STATEMENT", "../Grammar/Statement.code" );
     SyncImagesStatement.setFunctionPrototype   ( "HEADER_SYNC_IMAGES_STATEMENT", "../Grammar/Statement.code" );
     SyncImagesStatement.setDataPrototype       ( "SgExpression*", "image_set", "= NULL",
                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     SyncMemoryStatement.setFunctionPrototype   ( "HEADER_SYNC_MEMORY_STATEMENT", "../Grammar/Statement.code" );
     SyncTeamStatement.setFunctionPrototype     ( "HEADER_SYNC_TEAM_STATEMENT", "../Grammar/Statement.code" );
     SyncTeamStatement.setDataPrototype         ( "SgExpression*", "team_value", "= NULL",
                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     LockStatement.setFunctionPrototype         ( "HEADER_LOCK_STATEMENT", "../Grammar/Statement.code" );
     LockStatement.setDataPrototype             ( "SgExpression*", "lock_variable", "= NULL",
                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     UnlockStatement.setFunctionPrototype       ( "HEADER_UNLOCK_STATEMENT", "../Grammar/Statement.code" );
     UnlockStatement.setDataPrototype           ( "SgExpression*", "lock_variable", "= NULL",
                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Derived from IOStatement, this adds the status (either "KEEP" or "DELETE")
     CloseStatement.setFunctionPrototype ( "HEADER_CLOSE_STATEMENT", "../Grammar/Statement.code" );
     CloseStatement.setDataPrototype ( "SgExpression*", "status", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // The Fortran print only requires a format field (and not the unit, iostat, err fields)
     PrintStatement.setFunctionPrototype ( "HEADER_PRINT_STATEMENT", "../Grammar/Statement.code" );
     PrintStatement.setDataPrototype ( "SgExpression*", "format", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     FlushStatement.setFunctionPrototype     ( "HEADER_FLUSH_STATEMENT", "../Grammar/Statement.code" );
     RewindStatement.setFunctionPrototype    ( "HEADER_REWIND_STATEMENT", "../Grammar/Statement.code" );
     BackspaceStatement.setFunctionPrototype ( "HEADER_BACKSPACE_STATEMENT", "../Grammar/Statement.code" );
     EndfileStatement.setFunctionPrototype   ( "HEADER_ENDFILE_STATEMENT", "../Grammar/Statement.code" );
     WaitStatement.setFunctionPrototype      ( "HEADER_WAIT_STATEMENT", "../Grammar/Statement.code" );

  // Derived from IOStatement, this adds:
     OpenStatement.setFunctionPrototype ( "HEADER_OPEN_STATEMENT", "../Grammar/Statement.code" );
     OpenStatement.setDataPrototype ( "SgExpression*", "file", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "status", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "access", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "form", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "recl", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "blank", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "position", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "action", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "delim", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "pad", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // F2003 features
     OpenStatement.setDataPrototype ( "SgExpression*", "round", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "sign", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     OpenStatement.setDataPrototype ( "SgExpression*", "asynchronous", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Derived from IOStatement, this adds:
  // Added missing items to the io-control-spec-list [CR, 2019.05.31]
     WriteStatement.setFunctionPrototype ( "HEADER_WRITE_STATEMENT", "../Grammar/Statement.code" );
     WriteStatement.setDataPrototype ( "SgExpression*", "format", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "namelist", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "advance", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "asynchronous", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "blank", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "decimal", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "delim", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "end", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "eor", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "id", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "pad", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "pos", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "rec", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "round", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "sign", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WriteStatement.setDataPrototype ( "SgExpression*", "size", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Derived from IOStatement, this adds:
  // Added missing items to the io-control-spec-list [CR, 2019.05.31]
     ReadStatement.setFunctionPrototype ( "HEADER_READ_STATEMENT", "../Grammar/Statement.code" );
     ReadStatement.setDataPrototype ( "SgExpression*", "format", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "namelist", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "advance", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "asynchronous", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "blank", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "decimal", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "delim", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "end", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "eor", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "id", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "pad", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "pos", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "rec", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "round", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "sign", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ReadStatement.setDataPrototype ( "SgExpression*", "size", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // Derived from IOStatement, this adds (the most complex I/O statement):
     InquireStatement.setFunctionPrototype ( "HEADER_INQUIRE_STATEMENT", "../Grammar/Statement.code" );
     InquireStatement.setDataPrototype ( "SgExpression*", "file", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "access", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "form", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "recl", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "blank", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "exist", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "opened", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "number", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "named", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "name", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "sequential", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "direct", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "formatted", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "unformatted", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "nextrec", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "position", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "action", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "read", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "write", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "readwrite", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "delim", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "pad", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // F2003 features
     InquireStatement.setDataPrototype ( "SgExpression*", "asynchronous", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "decimal", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "stream", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "size", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InquireStatement.setDataPrototype ( "SgExpression*", "pending", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/3/2010): Added to handle case of "INQUIRE (IOLENGTH=<VarRefExp>)"
     InquireStatement.setDataPrototype ( "SgVarRefExp*", "iolengthExp", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

#if 0
  // This IR node combined read and write, which I have decided to separate into individual IR nodes.

  // DQ (8/15/2007): Added new data members to Fortran IR nodes.

  // DQ (11/24/2007): This is the READ and WRITE statement (in one IR node)
  // DQ (11/24/2007): format can be a "*" so make this SgExpression
  // InputOutputStatement.setDataPrototype    ( "SgVarRefExp*", "format", "= NULL",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "format", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgVarRefExp*", "namelist_nm", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "advance", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "end_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "eor_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "rec", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     InputOutputStatement.setDataPrototype    ( "SgExpression*", "size", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#if 1
  // More IR nodes required for Fortran support
     BlockDataStatement.setFunctionPrototype         ("HEADER_BLOCK_DATA_STATEMENT",         "../Grammar/Statement.code" );
     ImplicitStatement.setFunctionPrototype          ("HEADER_IMPLICIT_STATEMENT",           "../Grammar/Statement.code" );
     StatementFunctionStatement.setFunctionPrototype ("HEADER_STATEMENT_FUNCTION_STATEMENT", "../Grammar/Statement.code" );
     WhereStatement.setFunctionPrototype             ("HEADER_WHERE_STATEMENT",              "../Grammar/Statement.code" );
     ElseWhereStatement.setFunctionPrototype         ("HEADER_ELSE_WHERE_STATEMENT",         "../Grammar/Statement.code" );
     NullifyStatement.setFunctionPrototype           ("HEADER_NULLIFY_STATEMENT",            "../Grammar/Statement.code" );
     EquivalenceStatement.setFunctionPrototype       ("HEADER_EQUIVALENCE_STATEMENT",        "../Grammar/Statement.code" );
     DerivedTypeStatement.setFunctionPrototype       ("HEADER_DERIVED_TYPE_STATEMENT",       "../Grammar/Statement.code" );

     AttributeSpecificationStatement.setFunctionPrototype ("HEADER_ATTRIBUTE_SPECIFICATION_STATEMENT",            "../Grammar/Statement.code" );
     AllocateStatement.setFunctionPrototype          ("HEADER_ALLOCATE_STATEMENT",           "../Grammar/Statement.code" );
     DeallocateStatement.setFunctionPrototype        ("HEADER_DEALLOCATE_STATEMENT",         "../Grammar/Statement.code" );
     ContainsStatement.setFunctionPrototype          ("HEADER_CONTAINS_STATEMENT",           "../Grammar/Statement.code" );
     SequenceStatement.setFunctionPrototype          ("HEADER_SEQUENCE_STATEMENT",           "../Grammar/Statement.code" );

  // Required for F77 support (but deprecated in F90)
     ArithmeticIfStatement.setFunctionPrototype      ("HEADER_ARITHMETIC_IF_STATEMENT", "../Grammar/Statement.code" );
     AssignStatement.setFunctionPrototype            ("HEADER_ASSIGN_STATEMENT",        "../Grammar/Statement.code" );
     ComputedGotoStatement.setFunctionPrototype      ("HEADER_COMPUTED_GOTO_STATEMENT", "../Grammar/Statement.code" );
     AssignedGotoStatement.setFunctionPrototype      ("HEADER_ASSIGNED_GOTO_STATEMENT", "../Grammar/Statement.code" );
#endif

  // Rasmussen (3/18/2019): Added new IR node for Jovial support
     JovialTableStatement.setFunctionPrototype       ("HEADER_JOVIAL_TABLE_STATEMENT",  "../Grammar/Statement.code" );

  // DQ (7/21/2007): More IR nodes required for Fortran support
     BlockDataStatement.setDataPrototype    ( "SgBasicBlock*", "body", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Rasmussen (8/3/2020): Added implicit_type enum for F2018 syntax (implicit_none becomes redundant)
     ImplicitStatement.setDataPrototype("bool", "implicit_none", "= false",
                     CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ImplicitStatement.setDataPrototype("SgImplicitStatement::implicit_spec_enum",
                                        "implicit_spec", "= SgImplicitStatement::e_unknown_implicit_spec",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ImplicitStatement.setDataPrototype("SgInitializedNamePtrList", "variables", "",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     StatementFunctionStatement.setDataPrototype    ( "SgFunctionDeclaration*", "function", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     StatementFunctionStatement.setDataPrototype    ( "SgExpression*", "expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     WhereStatement .setDataPrototype    ( "SgExpression*", "condition", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WhereStatement .setDataPrototype    ( "SgBasicBlock*", "body", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     WhereStatement .setDataPrototype    ( "SgElseWhereStatement*", "elsewhere", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (12/16/2007): If we change the design to be similar to the IfStmt, removing the
  // ElseWhereStatement, then we will need a similar filed for the else_numeric_label
  // WhereStatement.setDataPrototype ( "int", "else_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // WhereStatement.setDataPrototype ( "int", "end_numeric_label", "= -1",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     WhereStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/16/2007): Added support for string labels (for Fortran).
     WhereStatement.setDataPrototype ( "std::string", "string_label", "= \"\"",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     WhereStatement.setDataPrototype     ( "bool", "has_end_statement", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/16/2007): I would rather have this design be similar to the SgIfStmt, so that we don't
  // need a special ElseWhereStatement statement.  We could just nest the elsewhere into the false
  // block of the where as a second where statement.
     ElseWhereStatement .setDataPrototype    ( "SgExpression*", "condition", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ElseWhereStatement .setDataPrototype    ( "SgBasicBlock*", "body", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ElseWhereStatement .setDataPrototype    ( "SgElseWhereStatement*", "elsewhere", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  //FMZ   NullifyStatement.setDataPrototype    ( "SgInitializedNamePtrList", "pointer_list", "",
  //                   NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     NullifyStatement.setDataPrototype    ( "SgExprListExp*", "pointer_list", "",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (7/21/2007): Examples such as: "EQUIVALENCE (N<NUMBERS), (B(1),BONE), (HRS, HOURS, TIME)" must be represented.
     EquivalenceStatement.setDataPrototype    ( "SgExprListExp*", "equivalence_set_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (8/25/2007): Added new IR node to represent the Fortran derived type statement
     DerivedTypeStatement.setDataPrototype ( "SgLabelRefExp*", "end_numeric_label", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     JovialTableStatement.setDataPrototype ( "SgExpression*", "table_entry_size", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     JovialTableStatement.setDataPrototype ( "bool", "has_table_entry_size", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     JovialTableStatement.setDataPrototype ("SgJovialTableStatement::WordsPerEntry",
                                            "words_per_entry", "= SgJovialTableStatement::WordsPerEntry::e_default",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // Like TableTypeName option
     JovialTableStatement.setDataPrototype ("std::string", "like_table_name", "= \"\"",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     JovialTableStatement.setDataPrototype ("bool", "has_like_option", "= false",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (9/11/2007): Added support for new IR nodes, but have not added the correct data members yet!
  // AttributeSpecificationStatement.setDataPrototype    ( "SgInitializedNamePtrList", "pointer_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AttributeSpecificationStatement.setDataPrototype    ( "SgStringList", "name_list", "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AttributeSpecificationStatement.setDataPrototype    ( "SgAttributeSpecificationStatement::attribute_spec_enum", "attribute_kind", "= SgAttributeSpecificationStatement::e_unknown_attribute_spec",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AttributeSpecificationStatement.setDataPrototype    ( "int", "intent", "= 0",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AttributeSpecificationStatement.setDataPrototype    ( "SgExprListExp*", "parameter_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (11/20/2007): Added support for data statements
     AttributeSpecificationStatement.setDataPrototype    ( "SgDataStatementGroupPtrList", "data_statement_group_list", "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AttributeSpecificationStatement.setDataPrototype    ( "SgExprListExp*", "bind_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (12/1/2007): Addes support for dimension statement
     AttributeSpecificationStatement.setDataPrototype    ( "SgDimensionObjectPtrList", "dimension_object_list", "",
                  NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (1/29/2009): I think we want an expression list and not a name list, also the
  // F2003 case is more complex (and not yet supported in ROSE).
  // AllocateStatement.setDataPrototype    ( "SgStringList", "name_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AllocateStatement.setDataPrototype    ( "SgExprListExp*", "expr_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AllocateStatement.setDataPrototype    ( "SgExpression*", "stat_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AllocateStatement.setDataPrototype    ( "SgExpression*", "errmsg_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AllocateStatement.setDataPrototype    ( "SgExpression*", "source_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/29/2009): I think we want an expression list and not a name list, also the
  // F2003 case is more complex (and not yet supported in ROSE).
  // DeallocateStatement.setDataPrototype    ( "SgStringList", "name_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeallocateStatement.setDataPrototype    ( "SgExprListExp*", "expr_list", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     DeallocateStatement.setDataPrototype    ( "SgExpression*", "stat_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     DeallocateStatement.setDataPrototype    ( "SgExpression*", "errmsg_expression", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (1/29/2009): The "contains" statment does not have a name list (or expression list)
  // ContainsStatement.setDataPrototype    ( "SgStringList", "name_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // DQ (1/29/2009): The "sequence" statment does not have a name list (or expression list)
  // SequenceStatement.setDataPrototype    ( "SgStringList", "name_list", "",
  //              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Required for F77 support (but deprecated in F90)
     ArithmeticIfStatement.setDataPrototype    ( "SgExpression*", "conditional", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ArithmeticIfStatement.setDataPrototype    ( "SgLabelRefExp*", "less_label", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ArithmeticIfStatement.setDataPrototype    ( "SgLabelRefExp*", "equal_label", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ArithmeticIfStatement.setDataPrototype    ( "SgLabelRefExp*", "greater_label", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AssignStatement.setDataPrototype    ( "SgLabelRefExp*", "label", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AssignStatement.setDataPrototype    ( "SgExpression*", "value", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     ComputedGotoStatement.setDataPrototype    ( "SgExprListExp*", "labelList", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ComputedGotoStatement.setDataPrototype    ( "SgExpression*", "label_index", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AssignedGotoStatement.setDataPrototype    ( "SgExprListExp*", "targets", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     FormatStatement.setFunctionPrototype      ( "HEADER_FORMAT_STATEMENT", "../Grammar/Statement.code" );
  // FormatStatement.setDataPrototype          ( "SgFormatItemPtrList", "format_item_list", "",
  //              CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     FormatStatement.setDataPrototype          ( "SgFormatItemList*", "format_item_list", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (2/18/2008): Added support for Fortran specific include mechanism (separate from CPP
  // include mechanism which is language independent).
     FortranIncludeLine.setFunctionPrototype   ( "HEADER_FORTRAN_INCLUDE_LINE", "../Grammar/Statement.code" );
     FortranIncludeLine.setDataPrototype       ( "std::string"   , "filename", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#if USE_UPC_IR_NODES
  // UpcNotifyStatement, UpcWaitStatement, UpcBarrierStatement, UpcFenceStatement, UpcForAllStatement

     UpcNotifyStatement.setFunctionPrototype ( "HEADER_UPC_NOTIFY_STATEMENT", "../Grammar/Statement.code" );
     UpcNotifyStatement.setDataPrototype     ( "SgExpression*", "notify_expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     UpcWaitStatement.setFunctionPrototype ( "HEADER_UPC_WAIT_STATEMENT", "../Grammar/Statement.code" );
     UpcWaitStatement.setDataPrototype     ( "SgExpression*", "wait_expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     UpcBarrierStatement.setFunctionPrototype ( "HEADER_UPC_BARRIER_STATEMENT", "../Grammar/Statement.code" );
     UpcBarrierStatement.setDataPrototype     ( "SgExpression*", "barrier_expression", "= NULL",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     UpcFenceStatement.setFunctionPrototype ( "HEADER_UPC_FENCE_STATEMENT", "../Grammar/Statement.code" );
#endif

#if 0
  // Support for comments within the AST (it would be nice to use a string as a data member)
  // CommentStatement.setFunctionPrototype ( "HEADER_COMMENT_STATEMENT", "Grammar/Statement.code" );
     CommentStatement.setDataPrototype     ( "std::string"   , "comment", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL);
     CxxStyleCommentStatement.setDataPrototype     ( "std::string"   , "dummyString1", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL);
     C_StyleCommentStatement.setDataPrototype     ( "std::string"   , "dummyString2", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL);
#endif

     JovialDirectiveStatement.setFunctionPrototype ( "HEADER_JOVIAL_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     JovialDirectiveStatement.setFunctionSource    ( "SOURCE_JOVIAL_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     JovialDirectiveStatement.setDataPrototype     ( "std::string", "content_string", "= \"\"",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     JovialDirectiveStatement.setDataPrototype     ( "SgJovialDirectiveStatement::directive_types", "directive_type", "= SgJovialDirectiveStatement::e_unknown",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     JovialDefineDeclaration.setFunctionPrototype  ( "HEADER_JOVIAL_DEFINE_DECLARATION", "../Grammar/Statement.code" );
     JovialDefineDeclaration.setFunctionSource     ( "SOURCE_JOVIAL_DEFINE_DECLARATION", "../Grammar/Statement.code" );
     JovialDefineDeclaration.setDataPrototype      ( "std::string", "define_string", "= \"\"",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     JovialLabelDeclaration.setFunctionPrototype   ( "HEADER_JOVIAL_LABEL_DECLARATION", "../Grammar/Statement.code" );
     JovialLabelDeclaration.setFunctionSource      ( "SOURCE_JOVIAL_LABEL_DECLARATION", "../Grammar/Statement.code" );
     JovialLabelDeclaration.setDataPrototype       ( "std::string", "label", "= \"\"",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     JovialLabelDeclaration.setDataPrototype       ( "SgJovialLabelDeclaration::label_type_enum", "label_type", "= SgJovialLabelDeclaration::e_unknown",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     JovialOverlayDeclaration.setFunctionPrototype ( "HEADER_JOVIAL_OVERLAY_DECLARATION", "../Grammar/Statement.code" );
     JovialOverlayDeclaration.setFunctionSource    ( "SOURCE_JOVIAL_OVERLAY_DECLARATION", "../Grammar/Statement.code" );
     JovialOverlayDeclaration.setDataPrototype     ( "SgExpression*", "address", "= NULL",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     JovialOverlayDeclaration.setDataPrototype     ( "SgExprListExp*", "overlay", "= NULL",
                                                CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (11/23/2008): Added support for CPP directives as IR nodes.
     C_PreprocessorDirectiveStatement.setFunctionPrototype ( "HEADER_PREPROCESSOR_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/23/2008): After we have these into the AST, then we can decide if we want more information to be stored.
  // Examples of more information could include:
  //    1) the substring after the #<directive specification>,
  //    2) the integer values used for compiler generate line numbers, etc.
  // For now the "directiveString" stores the full line represented by the CPP directive.
     C_PreprocessorDirectiveStatement.setDataPrototype     ( "std::string"   , "directiveString", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // negara1 (08/12/2011): Added header file body as a field of include directive statement.
     IncludeDirectiveStatement.setDataPrototype( "SgHeaderFileBody*", "headerFileBody", "= NULL",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // DQ (9/18/2018): Adding support for the include fine heirarchy as generated in the EDG/ROSE translation. This
  // is exact in the since that it is the files included instead of just the CPP Include directives that were processed.
     IncludeDirectiveStatement.setDataPrototype( "SgIncludeFile*", "include_file_heirarchy", "= NULL",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // DQ (11/5/2018): Pass the name that was used to the SgIncludeDirectiveStatement.
     IncludeDirectiveStatement.setDataPrototype ("std::string", "name_used_in_include_directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


#if 0
  // DQ (3/23/2019): We want to use these to improve the precision of transformation, especially when using the token based unparsing.
  // DQ (11/23/2008): I am unclear why this is here, these are not used anywhere.
     IncludeDirectiveStatement.setDataPrototype ( "std::string"   , "dummyString3", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DefineDirectiveStatement.setDataPrototype  ( "std::string"   , "dummyString4", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UndefDirectiveStatement.setDataPrototype   ( "std::string"   , "dummyString5", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfdefDirectiveStatement.setDataPrototype   ( "std::string"   , "dummyString6", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfndefDirectiveStatement.setDataPrototype  ( "std::string"   , "dummyString7", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfDirectiveStatement.setDataPrototype      ( "std::string"   , "dummyString8", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeadIfDirectiveStatement.setDataPrototype  ( "std::string"   , "dummyString8", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ElseDirectiveStatement.setDataPrototype    ( "std::string"   , "dummyString9", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ElseifDirectiveStatement.setDataPrototype  ( "std::string"   , "dummyString10", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     EndifDirectiveStatement.setDataPrototype   ( "std::string"   , "dummyString11", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     LineDirectiveStatement.setDataPrototype    ( "std::string"   , "dummyString12", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     WarningDirectiveStatement.setDataPrototype ( "std::string"   , "dummyString13", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ErrorDirectiveStatement.setDataPrototype   ( "std::string"   , "dummyString14", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     EmptyDirectiveStatement.setDataPrototype   ( "std::string"   , "dummyString15", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#if 0
  // DQ (3/24/2019): The base class has this information.
  // DQ (3/23/2019): We want to use these to improve the precision of transformation, especially when using the token based unparsing.
  // DQ (11/23/2008): I am unclear why this is here, these are not used anywhere.
     IncludeDirectiveStatement.setDataPrototype ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DefineDirectiveStatement.setDataPrototype  ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     UndefDirectiveStatement.setDataPrototype   ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfdefDirectiveStatement.setDataPrototype   ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfndefDirectiveStatement.setDataPrototype  ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     IfDirectiveStatement.setDataPrototype      ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     DeadIfDirectiveStatement.setDataPrototype  ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ElseDirectiveStatement.setDataPrototype    ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ElseifDirectiveStatement.setDataPrototype  ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     EndifDirectiveStatement.setDataPrototype   ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     LineDirectiveStatement.setDataPrototype    ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     WarningDirectiveStatement.setDataPrototype ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ErrorDirectiveStatement.setDataPrototype   ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     EmptyDirectiveStatement.setDataPrototype   ( "std::string"   , "directive", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


  // DQ (11/28/2008): Thes are used to mark line numbers in generated CPP output.
     LinemarkerDirectiveStatement.setFunctionPrototype ( "HEADER_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     LinemarkerDirectiveStatement.setDataPrototype ( "int", "linenumber", "= -1",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     LinemarkerDirectiveStatement.setDataPrototype ( "std::string", "filename", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
  // The integer values are stored as char (values are '1', '2', '3', '4'), flag values are seperated by spaces.
     LinemarkerDirectiveStatement.setDataPrototype ( "SgUnsignedCharList", "flaglist", "",
                                             NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Support for extern "C" and extern "C++"
     ClinkageDeclarationStatement.setDataPrototype ( "std::string"   , "languageSpecifier", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#if 0
  // DQ (11/23/2008): I am unclear why this is here, these are not used anywhere.
     ClinkageStartStatement.setDataPrototype ( "std::string"   , "dummyString16", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     ClinkageEndStatement.setDataPrototype   ( "std::string"   , "dummyString17", "= \"\"",
                                             NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


     MicrosoftAttributeDeclaration.setFunctionPrototype ( "HEADER_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     MicrosoftAttributeDeclaration.setDataPrototype ("SgName", "attribute_string", "= \"\"",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Support for C preprocessor declarations within the AST (does not solve the problem of not
  // knowing where they might be expanded within source code (something we can't see).
  // This support allows transformations to introduce their own macros.
  // C_PreprocessorDirectiveStatement.setDataPrototype (
  //      "std::string"   , "directiveString", "", CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

  // Support for extern "C" and extern "C++" declared explicitly as header file include guards
  // ClinkageSpecificationDeclarationStatement.setDataPrototype (
  //      "std::string"   , "languageSpecifier", "", CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // ***********************************************************************
  // ***********************************************************************
  //                       Source Code Definition
  // ***********************************************************************
  // ***********************************************************************

     Statement.setFunctionSource            ( "SOURCE_MAIN_STATEMENT", "../Grammar/Statement.code" );

#ifdef HL_GRAMMARS
     X_StatementUnknown.setFunctionSource   ( "SOURCE_X_STATEMENT_UNKNOWN", "../Grammar/Statement.code" );
     X_Statement.setFunctionSource          ( "SOURCE_X_STATEMENT", "../Grammar/Statement.code" );
     non_X_Statement.setFunctionSource      ( "SOURCE_NON_X_STATEMENT", "../Grammar/Statement.code" );
#endif

     ScopeStatement.setFunctionSource       ( "SOURCE_SCOPE_STATEMENT", "../Grammar/Statement.code" );
     FunctionTypeTable.setFunctionSource    ( "SOURCE_FUNCTION_TYPE_TABLE_STATEMENT", "../Grammar/Statement.code" );
     Global.setFunctionSource               ( "SOURCE_GLOBAL_STATEMENT", "../Grammar/Statement.code" );

  // Parse functions are only built for the higher level grammars since they parse
  // from a lower level grammar into a higher level grammer (thus they are not defined
  // within the root grammar (the C+ grammar)).
     if (isRootGrammar() == false)
        {
       // Use the specialized unparse function for this AstNodeClass
          Global.excludeFunctionSource ( "SOURCE_PARSER", "../Grammar/parserSourceCode.macro" );
          Global.setFunctionSource     ( "SOURCE_GLOBAL_STATEMENT_PARSER", "../Grammar/Statement.code" );
        }

     DeclarationStatement.setFunctionSource ( "SOURCE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     BasicBlock.setFunctionSource           ( "SOURCE_BASIC_BLOCK_STATEMENT", "../Grammar/Statement.code" );
     IfStmt.setFunctionSource               ( "SOURCE_IF_STATEMENT", "../Grammar/Statement.code" );
     ForStatement.setFunctionSource         ( "SOURCE_FOR_STATEMENT", "../Grammar/Statement.code" );
  // ForStatement.editSubstitute            ( "$CLASSNAME", "SgForStatement" );
     ForStatement.editSubstitute            ( "get_body", "get_loop_body" );

  // DQ (3/25/2018): Adding Range-based For statement support (previously missed in C++11 support).
     RangeBasedForStatement.setFunctionSource         ( "SOURCE_RANGE_BASED_FOR_STATEMENT", "../Grammar/Statement.code" );


#if USE_UPC_IR_NODES
  // UpcNotifyStatement, UpcWaitStatement, UpcBarrierStatement, UpcFenceStatement, UpcForAllStatement

     UpcNotifyStatement.setFunctionSource  ( "SOURCE_UPC_NOTIFY_STATEMENT", "../Grammar/Statement.code" );
     UpcWaitStatement.setFunctionSource    ( "SOURCE_UPC_WAIT_STATEMENT", "../Grammar/Statement.code" );
     UpcBarrierStatement.setFunctionSource ( "SOURCE_UPC_BARRIER_STATEMENT", "../Grammar/Statement.code" );
     UpcFenceStatement.setFunctionSource   ( "SOURCE_UPC_FENCE_STATEMENT", "../Grammar/Statement.code" );
     UpcForAllStatement.setFunctionSource   ( "SOURCE_UPC_FORALL_STATEMENT", "../Grammar/Statement.code" );
     UpcForAllStatement.editSubstitute       ( "get_body", "get_loop_body" );
#endif

  // DQ (7/25/2014): Adding support for C11 static assertions.
     StaticAssertionDeclaration.setFunctionSource  ( "SOURCE_STATIC_ASSERTION_DECLARATION", "../Grammar/Statement.code" );

  // DQ (2/10/2016): Adding support for a scope for function parametes in non-defining declarations.
     FunctionParameterScope.setFunctionSource  ( "SOURCE_FUNCTION_PARAMETER_SCOPE", "../Grammar/Statement.code" );

  // DQ (7/17/2017): Added to support concept of scope in nondefining declarations (required for more sophisticated level of template useage).
     DeclarationScope.setFunctionSource  ( "SOURCE_DECLARATION_SCOPE", "../Grammar/Statement.code" );


     FunctionDeclaration.setFunctionSource  ( "SOURCE_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     FunctionDeclaration.setFunctionSource  ( "SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

  // Parse functions are only built for the higher level grammars since they parse
  // from a lower level grammar into a higher level grammer (thus they are not defined
  // within the root grammar (the C+ grammar)).
     if (isRootGrammar() == false)
        {
       // Use the specialized unparse function for this AstNodeClass
          FunctionDeclaration.excludeFunctionSource ( "SOURCE_PARSER", "../Grammar/parserSourceCode.macro" );
          FunctionDeclaration.setFunctionSource     ( "SOURCE_FUNCTION_DECLARATION_STATEMENT_PARSER", "../Grammar/Statement.code" );
        }

     FunctionDefinition.setFunctionSource   ( "SOURCE_FUNCTION_DEFINTION_STATEMENT", "../Grammar/Statement.code" );
     FunctionDefinition.editSubstitute            ( "$CLASSNAME", "SgFunctionDefinition" );

  // Parse functions are only built for the higher level grammars since they parse
  // from a lower level grammar into a higher level grammer (thus they are not defined
  // within the root grammar (the C+ grammar)).
     if (isRootGrammar() == false)
        {
       // Use the specialized unparse function for this AstNodeClass
          FunctionDefinition.excludeFunctionSource ( "SOURCE_PARSER", "../Grammar/parserSourceCode.macro" );
          FunctionDefinition.setFunctionSource     ( "SOURCE_FUNCTION_DEFINTION_STATEMENT_PARSER", "../Grammar/Statement.code" );
        }

     MemberFunctionDeclaration.setFunctionSource ( "SOURCE_MEMBER_FUNCTION_DECLARATION_STATEMENT",
                                                        "../Grammar/Statement.code" );
     VariableDeclaration.setFunctionSource  ( "SOURCE_VARIABLE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     VariableDeclaration.setFunctionSource  ( "SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

     VariableDefinition.setFunctionSource   ( "SOURCE_VARIABLE_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

     ClassDeclaration.setFunctionSource     ( "SOURCE_CLASS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     ClassDeclaration.setFunctionSource     ( "SOURCE_TEMPLATE_SPECIALIZATION_SUPPORT", "../Grammar/Statement.code" );

     NonrealDecl.setFunctionSource          ( "SOURCE_NONREAL_DECL", "../Grammar/Statement.code" );

     ClassDefinition.setFunctionSource      ( "SOURCE_CLASS_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

     StmtDeclarationStatement.setFunctionSource  ( "SOURCE_STMT_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

     EnumDeclaration.setFunctionSource      ( "SOURCE_ENUM_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     ExprStatement.setFunctionSource        ( "SOURCE_EXPRESSION_STATEMENT", "../Grammar/Statement.code" );
     LabelStatement.setFunctionSource       ( "SOURCE_LABEL_STATEMENT", "../Grammar/Statement.code" );

     WhileStmt.setFunctionSource            ( "SOURCE_WHILE_STATEMENT", "../Grammar/Statement.code" );
     WhileStmt.editSubstitute               ( "$CLASSNAME", "SgWhileStmt" );
     DoWhileStmt.setFunctionSource          ( "SOURCE_DO_WHILE_STATEMENT", "../Grammar/Statement.code" );
     DoWhileStmt.editSubstitute             ( "$CLASSNAME", "SgDoWhileStmt" );

     SwitchStatement.setFunctionSource      ( "SOURCE_SWITCH_STATEMENT", "../Grammar/Statement.code" );
     SwitchStatement.editSubstitute             ( "$CLASSNAME", "SgSwitchStatement" );
     CaseOptionStmt.setFunctionSource       ( "SOURCE_CASE_OPTION_STATEMENT", "../Grammar/Statement.code" );
     CaseOptionStmt.editSubstitute          ( "$CLASSNAME", "SgCaseOptionStmt" );

     TryStmt.setFunctionSource              ( "SOURCE_TRY_STATEMENT", "../Grammar/Statement.code" );
     CatchOptionStmt.setFunctionSource      ( "SOURCE_CATCH_OPTION_STATEMENT", "../Grammar/Statement.code" );
     CatchOptionStmt.editSubstitute             ( "$CLASSNAME", "SgCatchOptionStmt" );
     DefaultOptionStmt.setFunctionSource    ( "SOURCE_DEFAULT_OPTION_STATEMENT", "../Grammar/Statement.code" );
     BreakStmt.setFunctionSource            ( "SOURCE_BREAK_STATEMENT", "../Grammar/Statement.code" );
     ContinueStmt.setFunctionSource         ( "SOURCE_CONTINUE_STATEMENT", "../Grammar/Statement.code" );
     FortranContinueStmt.setFunctionSource  ( "SOURCE_FORTRAN_CONTINUE_STATEMENT", "../Grammar/Statement.code" );

     ReturnStmt.setFunctionSource           ( "SOURCE_RETURN_STATEMENT", "../Grammar/Statement.code" );
     GotoStatement.setFunctionSource        ( "SOURCE_GOTO_STATEMENT", "../Grammar/Statement.code" );
     AdaExitStmt.setFunctionSource          ( "SOURCE_ADA_EXIT_STATEMENT", "../Grammar/Statement.code" );
     AdaLoopStmt.setFunctionSource          ( "SOURCE_ADA_LOOP_STATEMENT", "../Grammar/Statement.code" );
     AdaDelayStmt.setFunctionSource         ( "SOURCE_ADA_DELAY_STATEMENT", "../Grammar/Statement.code" );
     AdaSelectStmt.setFunctionSource        ( "SOURCE_ADA_SELECT_STATEMENT", "../Grammar/Statement.code" );
     AdaSelectAlternativeStmt.setFunctionSource ( "SOURCE_ADA_SELECT_ALTERNATIVE_STATEMENT", "../Grammar/Statement.code" );
     AdaTerminateStmt.setFunctionSource     ( "SOURCE_ADA_TERMINATE_STATEMENT", "../Grammar/Statement.code" );
     AdaUnscopedBlock.setFunctionSource     ( "SOURCE_ADA_UNSCOPED_BLOCK", "../Grammar/Statement.code" );
     AdaVariantWhenStmt.setFunctionSource           ( "SOURCE_ADA_VARIANT_WHEN_STMT", "../Grammar/Statement.code" );

     AsmStmt.setFunctionSource              ( "SOURCE_ASM_STATEMENT", "../Grammar/Statement.code" );
     SpawnStmt.setFunctionSource            ( "SOURCE_SPAWN_STATEMENT", "../Grammar/Statement.code" );

  // DQ (12/13/2005): Added support for empty statement (and empty expression).
     NullStatement.setFunctionSource        ( "SOURCE_NULL_STATEMENT", "../Grammar/Statement.code" );

  // DQ (12/13/2005): Added variant statement to support future patterns
  // specifications (contains RegEx string specifier for SgStatement IR node).
     VariantStatement.setFunctionSource     ( "SOURCE_VARIANT_STATEMENT", "../Grammar/Statement.code" );

     ForInitStatement.setFunctionSource     ( "SOURCE_FOR_INIT_STATEMENT", "../Grammar/Statement.code" );
     CatchStatementSeq.setFunctionSource           ( "SOURCE_CATCH_STATEMENT_SEQ", "../Grammar/Statement.code" );
     FunctionParameterList.setFunctionSource( "SOURCE_FUNCTION_PARAMETER_LIST", "../Grammar/Statement.code" );
     AdaParameterList.setFunctionSource( "SOURCE_ADA_PARAMETER_LIST", "../Grammar/Statement.code" );
     CtorInitializerList.setFunctionSource  ( "SOURCE_CTOR_INITIALIZER_LIST", "../Grammar/Statement.code" );

     TypedefDeclaration.setFunctionSource   ( "SOURCE_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );


     TemplateDeclaration.setFunctionSource  ( "SOURCE_TEMPLATE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateInstantiationDecl.setFunctionSource( "SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateInstantiationDefn.setFunctionSource( "SOURCE_TEMPLATE_INSTANTIATION_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (3/22/2004): Using SOURCE_TEMPLATE_INSTANTIATION_DECLARATION_STATEMENT since the source code is the same.
  //                 This could be handled better if we were to permit multiple inheritance in ROSETTA!
     TemplateInstantiationFunctionDecl.setFunctionSource( "SOURCE_TEMPLATE_INSTANTIATION_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateInstantiationMemberFunctionDecl.setFunctionSource( "SOURCE_TEMPLATE_INSTANTIATION_MEMBER_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/23/2004): Since SOURCE_RESET_TEMPLATE_NAME was only used for TemplateInstantiationDecl it is included directly!
  // DQ (3/23/2004): Use of common resetTemplateName function in three different classes
  //                 (perhaps it should be a service of SgTemplateDeclaration).
  // TemplateInstantiationDecl.editSubstitute ( "SOURCE_RESET_TEMPLATE_NAME", "SOURCE_RESET_TEMPLATE_NAME", "../Grammar/Statement.code" );
     TemplateInstantiationDecl.editSubstitute ( "$CLASSNAME", "SgTemplateInstantiationDecl" );
  // TemplateInstantiationFunctionDecl.editSubstitute ( "SOURCE_RESET_TEMPLATE_NAME", "SOURCE_RESET_TEMPLATE_NAME", "../Grammar/Statement.code" );
     TemplateInstantiationFunctionDecl.editSubstitute ( "$CLASSNAME", "SgTemplateInstantiationFunctionDecl" );
  // TemplateInstantiationMemberFunctionDecl.editSubstitute ( "SOURCE_RESET_TEMPLATE_NAME", "SOURCE_RESET_TEMPLATE_NAME", "../Grammar/Statement.code" );
     TemplateInstantiationMemberFunctionDecl.editSubstitute ( "$CLASSNAME", "SgTemplateInstantiationMemberFunctionDecl" );

  // DQ (6/10/2011): Added support for more detail in the template declaration support.
     TemplateClassDeclaration.setFunctionSource          ( "SOURCE_TEMPLATE_CLASS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateFunctionDeclaration.setFunctionSource       ( "SOURCE_TEMPLATE_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateMemberFunctionDeclaration.setFunctionSource ( "SOURCE_TEMPLATE_MEMBER_FUNCTION_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     TemplateClassDefinition.setFunctionSource           ( "SOURCE_TEMPLATE_CLASS_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
     TemplateFunctionDefinition.setFunctionSource        ( "SOURCE_TEMPLATE_FUNCTION_DEFINITION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (12/6/2011): Adding support for template variables (e.g. static template data members).
     TemplateVariableDeclaration.setFunctionSource       ( "SOURCE_TEMPLATE_VARIABLE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (10/14/2014): Adding template typedef for C++11 support.
     TemplateTypedefDeclaration.setFunctionSource       ( "SOURCE_TEMPLATE_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (11/4/2014): Adding IR node for instantiation of template typedef for C++11 support.
     TemplateInstantiationTypedefDeclaration.setFunctionSource ( "SOURCE_TEMPLATE_INSTANTIATION_TYPEDEF_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

  // Support for pragmas in the IR
     PragmaDeclaration.setFunctionSource      ( "SOURCE_PRAGMA_STATEMENT", "../Grammar/Statement.code" );

  // Ada support
     AdaPackageSpecDecl.setFunctionSource ( "SOURCE_ADA_PACKAGE_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaPackageBodyDecl.setFunctionSource ( "SOURCE_ADA_PACKAGE_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskSpecDecl.setFunctionSource   ( "SOURCE_ADA_TASK_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskTypeDecl.setFunctionSource   ( "SOURCE_ADA_TASK_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskBodyDecl.setFunctionSource   ( "SOURCE_ADA_TASK_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedSpecDecl.setFunctionSource   ( "SOURCE_ADA_PROTECTED_SPEC_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedTypeDecl.setFunctionSource   ( "SOURCE_ADA_PROTECTED_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedBodyDecl.setFunctionSource   ( "SOURCE_ADA_PROTECTED_BODY_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaRenamingDecl.setFunctionSource   ( "SOURCE_ADA_RENAMING_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaDiscriminatedTypeDecl.setFunctionSource   ( "SOURCE_ADA_DISCRIMINATED_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaRepresentationClause.setFunctionSource ( "SOURCE_ADA_REPRESENTATION_CLAUSE", "../Grammar/Statement.code" );
     AdaEnumRepresentationClause.setFunctionSource ( "SOURCE_ADA_ENUM_REPRESENTATION_CLAUSE", "../Grammar/Statement.code" );
     AdaComponentClause.setFunctionSource ( "SOURCE_ADA_COMPONENT_CLAUSE", "../Grammar/Statement.code");
     AdaAttributeClause.setFunctionSource ( "SOURCE_ADA_ATTRIBUTE_CLAUSE", "../Grammar/Statement.code" );
     AdaGenericDecl.setFunctionSource ( "SOURCE_ADA_GENERIC_DECL", "../Grammar/Statement.code" );
     AdaGenericDefn.setFunctionSource ( "SOURCE_ADA_GENERIC_DEFN", "../Grammar/Statement.code" );
     AdaGenericInstanceDecl.setFunctionSource ( "SOURCE_ADA_GENERIC_INSTANCE_DECL", "../Grammar/Statement.code" );
     AdaFormalTypeDecl.setFunctionSource ( "SOURCE_ADA_FORMAL_TYPE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaFormalPackageDecl.setFunctionSource ( "SOURCE_ADA_FORMAL_PACKAGE_DECL_STATEMENT", "../Grammar/Statement.code" );
     AdaVariantDecl.setFunctionSource ( "SOURCE_ADA_VARIANT_DECL", "../Grammar/Statement.code" );

  // DQ (3/22/2019): Adding EmptyDeclaration to support addition of comments and CPP directives that will permit
  // token-based unparsing to work with greater precision. For example, used to add an include directive with
  // greater precision to the global scope and permit the unparsing via the token stream to be used as well.
     EmptyDeclaration.setFunctionSource      ( "SOURCE_EMPTY_DECLARATION", "../Grammar/Statement.code" );

  // driscoll6 (6/30/11) Support for python
     PythonPrintStmt.setFunctionPrototype ( "HEADER_PYTHON_PRINT_STMT", "../Grammar/Statement.code" );
     PythonPrintStmt.setFunctionSource    ( "SOURCE_PYTHON_PRINT_STMT", "../Grammar/Statement.code" );
     PythonPrintStmt.setDataPrototype     ( "SgExpression*", "destination", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     PythonPrintStmt.setDataPrototype     ( "SgExprListExp*", "values", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     PythonGlobalStmt.setFunctionPrototype ( "HEADER_PYTHON_GLOBAL_STMT", "../Grammar/Statement.code" );
     PythonGlobalStmt.setFunctionSource    ( "SOURCE_PYTHON_GLOBAL_STMT", "../Grammar/Statement.code" );
     PythonGlobalStmt.editSubstitute       ( "HEADER_LIST_DECLARATIONS", "HEADER_LIST_DECLARATIONS", "../Grammar/Statement.code" );
     PythonGlobalStmt.editSubstitute      ( "LIST_DATA_TYPE", "SgInitializedNamePtrList" );
     PythonGlobalStmt.editSubstitute      ( "LIST_NAME", "names" );
     PythonGlobalStmt.editSubstitute      ( "LIST_FUNCTION_RETURN_TYPE", "SgInitializedNamePtrList::iterator" );
     PythonGlobalStmt.editSubstitute      ( "LIST_FUNCTION_NAME", "name" );
     PythonGlobalStmt.editSubstitute      ( "LIST_ELEMENT_DATA_TYPE", "SgInitializedName*" );
     PythonGlobalStmt.setDataPrototype    ( "SgInitializedNamePtrList", "names", "",
                                            NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     PassStatement.setFunctionSource        ( "SOURCE_PASS_STATEMENT", "../Grammar/Statement.code" );

     AssertStmt.setFunctionPrototype        ( "HEADER_ASSERT_STMT", "../Grammar/Statement.code" );
     AssertStmt.setFunctionSource           ( "SOURCE_ASSERT_STMT", "../Grammar/Statement.code" );
     AssertStmt.setDataPrototype            ( "SgExpression*", "test", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
  // DQ (9/2/2011): Added support for Java (which uses this IR node but requires an additional argument.
     AssertStmt.setDataPrototype            ( "SgExpression*", "exception_argument", "= NULL",
             NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     ExecStatement.setFunctionSource           ( "SOURCE_EXEC_STATEMENT", "../Grammar/Statement.code" );
     ExecStatement.setFunctionSource ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ExecStatement.setDataPrototype            ( "SgExpression*", "executable", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ExecStatement.setDataPrototype            ( "SgExpression*", "globals", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     ExecStatement.setDataPrototype            ( "SgExpression*", "locals", "= NULL",
             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

  // ClinkageStatement.setFunctionSource       ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
  // ClinkageStartStatement.setFunctionSource  ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

#if 0
     ClinkageSpecificationDeclarationStatement.setFunctionSource  ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ClinkageSpecificationDeclarationStartStatement.setFunctionSource  ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ClinkageSpecificationDeclarationEndStatement.setFunctionSource  ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
#endif

  // DQ (4/22/2004): Support for namespaces: NamespaceDeclarationStatement,
  //      NamespaceAliasDeclarationStatement, UsingDeclarationStatement
     NamespaceDeclarationStatement.setFunctionSource (
          "SOURCE_NAMESPACE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     NamespaceDeclarationStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     NamespaceAliasDeclarationStatement.setFunctionSource (
          "SOURCE_NAMESPACE_ALIAS_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     NamespaceAliasDeclarationStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     NamespaceDefinitionStatement.setFunctionSource (
          "SOURCE_NAMESPACE_DEFINITION_STATEMENT", "../Grammar/Statement.code" );
#if 0
     NamespaceDefinitionStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
#endif

     UsingDirectiveStatement.setFunctionSource (
          "SOURCE_USING_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     UsingDirectiveStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     UsingDeclarationStatement.setFunctionSource (
          "SOURCE_USING_DECLARATION_STATEMENT", "../Grammar/Statement.code" );
     UsingDeclarationStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

  // DQ (4/16/2005): Added support for explicit template instantiation to IR (required to address template linking issues)
     TemplateInstantiationDirectiveStatement.setFunctionSource ( "SOURCE_TEMPLATE_INSTANTIATION_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     TemplateInstantiationDirectiveStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     WithStatement.setFunctionSource            ("SOURCE_WITH_STATEMENT", "../Grammar/Statement.code" );
     WithStatement.setFunctionSource (
          "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

    AdaPackageSpec.setFunctionSource            ( "SOURCE_ADA_PACKAGE_SPEC_STATEMENT", "../Grammar/Statement.code" );
    AdaPackageBody.setFunctionSource            ( "SOURCE_ADA_PACKAGE_BODY_STATEMENT", "../Grammar/Statement.code" );
    AdaTaskSpec.setFunctionSource            ( "SOURCE_ADA_TASK_SPEC_STATEMENT", "../Grammar/Statement.code" );
    AdaTaskBody.setFunctionSource            ( "SOURCE_ADA_TASK_BODY_STATEMENT", "../Grammar/Statement.code" );
    AdaProtectedSpec.setFunctionSource            ( "SOURCE_ADA_PROTECTED_SPEC_STATEMENT", "../Grammar/Statement.code" );
    AdaProtectedBody.setFunctionSource            ( "SOURCE_ADA_PROTECTED_BODY_STATEMENT", "../Grammar/Statement.code" );
    AdaAcceptStmt.setFunctionSource          ( "SOURCE_ADA_ACCEPT_STATEMENT",    "../Grammar/Statement.code" );

#if USE_FORTRAN_IR_NODES
     ProgramHeaderStatement.setFunctionSource   ("SOURCE_PROGRAM_HEADER_STATEMENT", "../Grammar/Statement.code" );
     ProcedureHeaderStatement.setFunctionSource ("SOURCE_PROCEDURE_HEADER_STATEMENT", "../Grammar/Statement.code" );
     FortranDo.setFunctionSource                ("SOURCE_FORTRAN_DO_STATEMENT", "../Grammar/Statement.code" );
     FortranNonblockedDo.setFunctionSource      ("SOURCE_FORTRAN_NONBLOCKED_DO_STATEMENT", "../Grammar/Statement.code" );
     InterfaceStatement.setFunctionSource       ("SOURCE_INTERFACE_STATEMENT", "../Grammar/Statement.code" );
     ParameterStatement.setFunctionSource       ("SOURCE_PARAMETER_STATEMENT", "../Grammar/Statement.code" );
     CommonBlock.setFunctionSource              ("SOURCE_COMMON_BLOCK_STATEMENT", "../Grammar/Statement.code" );
     ModuleStatement.setFunctionSource          ("SOURCE_MODULE_STATEMENT", "../Grammar/Statement.code" );
     UseStatement.setFunctionSource             ("SOURCE_USE_STATEMENT", "../Grammar/Statement.code" );
     ProcessControlStatement.setFunctionSource  ("SOURCE_PROCESS_CONTROL_STATEMENT", "../Grammar/Statement.code" );

     IOStatement.setFunctionSource              ("SOURCE_IO_STATEMENT", "../Grammar/Statement.code" );

  // Rasmussen (9/20/2018): Added F2018 image control statements
     ImageControlStatement.setFunctionSource    ("SOURCE_IMAGE_CONTROL_STATEMENT", "../Grammar/Statement.code" );

  // Derived from ImageControlStatement
     SyncAllStatement.setFunctionSource         ("SOURCE_SYNC_ALL_STATEMENT", "../Grammar/Statement.code" );
     SyncImagesStatement.setFunctionSource      ("SOURCE_SYNC_IMAGES_STATEMENT", "../Grammar/Statement.code" );
     SyncMemoryStatement.setFunctionSource      ("SOURCE_SYNC_MEMORY_STATEMENT", "../Grammar/Statement.code" );
     SyncTeamStatement.setFunctionSource        ("SOURCE_SYNC_TEAM_STATEMENT", "../Grammar/Statement.code" );
     LockStatement.setFunctionSource            ("SOURCE_LOCK_STATEMENT", "../Grammar/Statement.code" );
     UnlockStatement.setFunctionSource          ("SOURCE_UNLOCK_STATEMENT", "../Grammar/Statement.code" );

  // DQ (12/27/2007): Added fortran entry statement.
     EntryStatement.setFunctionSource           ("SOURCE_ENTRY_STATEMENT", "../Grammar/Statement.code" );

  // IOControlStatement.setFunctionSource       ("SOURCE_IO_CONTROL_STATEMENT", "../Grammar/Statement.code" );

  // InputOutputStatement.setFunctionSource     ("SOURCE_INPUT_OUTPUT_STATEMENT", "../Grammar/Statement.code" );
     PrintStatement.setFunctionSource           ("SOURCE_PRINT_STATEMENT", "../Grammar/Statement.code" );
     ReadStatement.setFunctionSource            ("SOURCE_READ_STATEMENT", "../Grammar/Statement.code" );
     WriteStatement.setFunctionSource           ("SOURCE_WRITE_STATEMENT", "../Grammar/Statement.code" );
     OpenStatement.setFunctionSource            ("SOURCE_OPEN_STATEMENT", "../Grammar/Statement.code" );
     CloseStatement.setFunctionSource           ("SOURCE_CLOSE_STATEMENT", "../Grammar/Statement.code" );
     InquireStatement.setFunctionSource         ("SOURCE_INQUIRE_STATEMENT", "../Grammar/Statement.code" );
     FlushStatement.setFunctionSource           ("SOURCE_FLUSH_STATEMENT", "../Grammar/Statement.code" );
     RewindStatement.setFunctionSource          ("SOURCE_REWIND_STATEMENT", "../Grammar/Statement.code" );
     BackspaceStatement.setFunctionSource       ("SOURCE_BACKSPACE_STATEMENT", "../Grammar/Statement.code" );
     EndfileStatement.setFunctionSource         ("SOURCE_ENDFILE_STATEMENT", "../Grammar/Statement.code" );
     WaitStatement.setFunctionSource            ("SOURCE_WAIT_STATEMENT", "../Grammar/Statement.code" );

  // IOFileControlStmt.setFunctionSource        ("SOURCE_IO_FILE_CONTROL_STATEMENT", "../Grammar/Statement.code" );
  // EndFileStatement.setFunctionSource         ("SOURCE_END_FILE_STATEMENT", "../Grammar/Statement.code" );


#if 1
  // Note that some IR nodes as so close to the semantics of C/C++
  // IR nodes that we can reuse them directly, examples include:
  //      SgContinueStatement maps to Fortran CYCLE statement
  //      SgBreakStatement maps to Fortran EXIT statement

  // More IR nodes required for Fortran support
     BlockDataStatement.setFunctionSource         ("SOURCE_BLOCK_DATA_STATEMENT",   "../Grammar/Statement.code" );
     ImplicitStatement.setFunctionSource          ("SOURCE_IMPLICIT_STATEMENT",     "../Grammar/Statement.code" );
     StatementFunctionStatement.setFunctionSource ("SOURCE_STATEMENT_FUNCTION_STATEMENT", "../Grammar/Statement.code" );
     WhereStatement.setFunctionSource             ("SOURCE_WHERE_STATEMENT",        "../Grammar/Statement.code" );
     ElseWhereStatement.setFunctionSource         ("SOURCE_ELSE_WHERE_STATEMENT",   "../Grammar/Statement.code" );
     NullifyStatement.setFunctionSource           ("SOURCE_NULLIFY_STATEMENT",      "../Grammar/Statement.code" );
     EquivalenceStatement.setFunctionSource       ("SOURCE_EQUIVALENCE_STATEMENT",  "../Grammar/Statement.code" );
     DerivedTypeStatement.setFunctionSource       ("SOURCE_DERIVED_TYPE_STATEMENT", "../Grammar/Statement.code" );

     AttributeSpecificationStatement.setFunctionSource ("SOURCE_ATTRIBUTE_SPECIFICATION_STATEMENT", "../Grammar/Statement.code" );
     AllocateStatement.setFunctionSource          ("SOURCE_ALLOCATE_STATEMENT",   "../Grammar/Statement.code" );
     DeallocateStatement.setFunctionSource        ("SOURCE_DEALLOCATE_STATEMENT", "../Grammar/Statement.code" );
     ContainsStatement.setFunctionSource          ("SOURCE_CONTAINS_STATEMENT",   "../Grammar/Statement.code" );
     SequenceStatement.setFunctionSource          ("SOURCE_SEQUENCE_STATEMENT",   "../Grammar/Statement.code" );

  // Required for F77 support (but deprecated in F90)
     ArithmeticIfStatement.setFunctionSource      ("SOURCE_ARITHMETIC_IF_STATEMENT", "../Grammar/Statement.code" );
     AssignStatement.setFunctionSource            ("SOURCE_ASSIGN_STATEMENT", "../Grammar/Statement.code" );
     ComputedGotoStatement.setFunctionSource      ("SOURCE_COMPUTED_GOTO_STATEMENT", "../Grammar/Statement.code" );
     AssignedGotoStatement.setFunctionSource      ("SOURCE_ASSIGNED_GOTO_STATEMENT", "../Grammar/Statement.code" );
#endif

  // Rasmussen (3/18/2019): Added new IR node for Jovial support
     JovialTableStatement.setFunctionSource       ("SOURCE_JOVIAL_TABLE_STATEMENT", "../Grammar/Statement.code" );

     NamelistStatement.setFunctionSource          ("SOURCE_NAMELIST_STATEMENT", "../Grammar/Statement.code" );
     ImportStatement.setFunctionSource            ("SOURCE_IMPORT_STATEMENT", "../Grammar/Statement.code" );

     AssociateStatement.setFunctionSource         ("SOURCE_ASSOCIATE_STATEMENT", "../Grammar/Statement.code" );

     FormatStatement.setFunctionSource            ("SOURCE_FORMAT_STATEMENT", "../Grammar/Statement.code" );

     ForAllStatement.setFunctionSource            ( "SOURCE_FORALL_STATEMENT", "../Grammar/Statement.code" );
#endif

  // Rasmussen (11/12/2018): Added to support Jovial COMPOOL modules
     JovialCompoolStatement.setFunctionSource     ( "SOURCE_JOVIAL_COMPOOL_STATEMENT",  "../Grammar/Statement.code" );
     JovialForThenStatement.setFunctionSource     ( "SOURCE_JOVIAL_FOR_THEN_STATEMENT", "../Grammar/Statement.code" );


  // PP 05/08/20 Adding Ada nodes
     // packages
     AdaPackageSpec.setFunctionPrototype ( "HEADER_ADA_PACKAGE_SPEC_STATEMENT", "../Grammar/Statement.code" );
     //~ AdaPackageSpec.setDataPrototype ( "SgAdaPackageBody*", "body", "= NULL",
                                    //~ NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaPackageSpec.setDataPrototype ( "bool", "hasPrivate", "= false",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaPackageSpec.setDataPrototype ( "SgDeclarationStatementPtrList", "declarations", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaPackageBody.setFunctionPrototype ( "HEADER_ADA_PACKAGE_BODY_STATEMENT", "../Grammar/Statement.code" );
     //~ AdaPackageBody.setDataPrototype ( "SgAdaPackageSpec*", "spec", "= NULL",
                                    //~ NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaPackageBody.setDataPrototype ( "SgStatementPtrList", "statements", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     // tasks
     AdaTaskSpec.setFunctionPrototype ( "HEADER_ADA_TASK_SPEC_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskSpec.setDataPrototype ( "SgAdaTaskBody*", "body", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     // PP (9/18/23): commented out; instead, just check the number of declarations
     // hasMembers is true, if the task specification has an explicit member list
     //               false, for cases like "task type The_Task_Type;"
     //~ AdaTaskSpec.setDataPrototype ( "bool", "hasMembers", "= false",
                                    //~ NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskSpec.setDataPrototype ( "SgDeclarationStatementPtrList", "declarations", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaTaskSpec.setDataPrototype ( "bool", "hasPrivate", "= false",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);


     AdaTaskBody.setFunctionPrototype ( "HEADER_ADA_TASK_BODY_STATEMENT", "../Grammar/Statement.code" );
     AdaTaskBody.setDataPrototype ( "SgAdaTaskSpec*", "spec", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaTaskBody.setDataPrototype ( "SgStatementPtrList", "statements", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     // protected objects (PP 01/11/22)
     AdaProtectedSpec.setFunctionPrototype ( "HEADER_ADA_PROTECTED_SPEC_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedSpec.setDataPrototype ( "SgAdaProtectedBody*", "body", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     // hasMembers is true, if the task specification has an explicit member list
     //               false, for cases like "task type The_Task_Type;"
     //~ AdaProtectedSpec.setDataPrototype ( "bool", "hasMembers", "= false",
                                    //~ NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedSpec.setDataPrototype ( "SgDeclarationStatementPtrList", "declarations", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaProtectedSpec.setDataPrototype ( "bool", "hasPrivate", "= false",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

     AdaProtectedBody.setFunctionPrototype ( "HEADER_ADA_PROTECTED_BODY_STATEMENT", "../Grammar/Statement.code" );
     AdaProtectedBody.setDataPrototype ( "SgAdaProtectedSpec*", "spec", "= NULL",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaProtectedBody.setDataPrototype ( "SgStatementPtrList", "statements", "",
                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);


     AdaAcceptStmt.setFunctionPrototype ( "HEADER_ADA_ACCEPT_STATEMENT", "../Grammar/Statement.code" );
     AdaAcceptStmt.setDataPrototype ( "SgFunctionParameterScope*", "parameterScope", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
     AdaAcceptStmt.setDataPrototype ( "SgFunctionParameterList*", "parameterList", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, CLONE_PTR);
     AdaAcceptStmt.setDataPrototype ( "SgExpression*", "entry", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaAcceptStmt.setDataPrototype ( "SgExpression*", "index", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaAcceptStmt.setDataPrototype ( "SgStatement*", "body", "= NULL",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaEntryDecl.setFunctionPrototype ( "HEADER_ADA_ENTRY_DECL_STMT", "../Grammar/Statement.code" );
     AdaEntryDecl.setDataPrototype ( "SgInitializedName*", "entryIndex", "= nullptr",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
     AdaEntryDecl.setDataPrototype ( "SgExpression*", "entryBarrier", "= nullptr",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

/*
     // PP (2/11/22) the type of the index variable is determined by the type of the possibly unnamed entryIndex variable.
     AdaEntryDecl.setDataPrototype ( "SgType*", "discrete_index_type", "= NULL",
                  NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
*/
     AdaEntryDecl.setFunctionSource ( "SOURCE_ADA_ENTRY_DECL_STMT", "../Grammar/Statement.code");

     AdaFunctionRenamingDecl.setFunctionPrototype ( "HEADER_ADA_FUNCTION_RENAMING_DECL_STMT", "../Grammar/Statement.code" );

     // PP 9/2/22 : updated renamed_function from SgFunctionDeclaration to SgExpression
     //             and enabled traversal
     //             \todo could the whole use of the class be replaced with AdaRenamingDecl
     AdaFunctionRenamingDecl.setDataPrototype ( "SgExpression*", "renamed_function", "= NULL",
                                                NO_CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

     AdaFunctionRenamingDecl.setFunctionSource ( "SOURCE_ADA_FUNCTION_RENAMING_DECL_STMT", "../Grammar/Statement.code" );

     MatlabForStatement.setFunctionSource         ( "SOURCE_MATLAB_FOR_STATEMENT", "../Grammar/Statement.code" );

#if 0
  // Every node needs a definition of the post_construction_initialization() member function
     CommentStatement.setFunctionSource         ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     CxxStyleCommentStatement.setFunctionSource ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     C_StyleCommentStatement.setFunctionSource  ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
#endif

  // DQ (11/23/2008): Added support for CPP directives as IR nodes.
     C_PreprocessorDirectiveStatement.setFunctionSource ( "SOURCE_PREPROCESSOR_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );
     LinemarkerDirectiveStatement.setFunctionSource     ( "SOURCE_LINEMARKER_PREPROCESSOR_DIRECTIVE_STATEMENT", "../Grammar/Statement.code" );

#if 1
  // DQ (11/23/2008): Removed this by putting the post_construction_initialization into the base class.
  // C_PreprocessorDirectiveStatement.setFunctionSource ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IncludeDirectiveStatement.setFunctionSource        ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     DefineDirectiveStatement.setFunctionSource         ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     UndefDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IfdefDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IfndefDirectiveStatement.setFunctionSource         ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     DeadIfDirectiveStatement.setFunctionSource         ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IfDirectiveStatement.setFunctionSource             ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ElseDirectiveStatement.setFunctionSource           ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ElseifDirectiveStatement.setFunctionSource         ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     EndifDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     LineDirectiveStatement.setFunctionSource           ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     WarningDirectiveStatement.setFunctionSource        ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ErrorDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     EmptyDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     ClinkageDeclarationStatement.setFunctionSource     ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ClinkageStartStatement.setFunctionSource           ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     ClinkageEndStatement.setFunctionSource             ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     FortranIncludeLine.setFunctionSource               ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );

     LinemarkerDirectiveStatement.setFunctionSource     ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IncludeNextDirectiveStatement.setFunctionSource    ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
     IdentDirectiveStatement.setFunctionSource          ( "SOURCE_POST_CONSTRUCTION_INITIALIZATION_STATEMENT", "../Grammar/Statement.code" );
#endif

     FortranIncludeLine.setFunctionSource               ( "SOURCE_FORTRAN_INCLUDE_LINE", "../Grammar/Statement.code" );

#if USE_OMP_IR_NODES
     // define members for each AstNodeClass/non-AstNodeClass
     //------------------------------------------------------------
    // every statement needs post_construction_initialization(){} but why ???

    OmpDoStatement.setFunctionSource            ("SOURCE_OMP_DO_STATEMENT", "../Grammar/Statement.code" );
    OmpWorkshareStatement.setFunctionSource            ("SOURCE_OMP_WORKSHARE_STATEMENT", "../Grammar/Statement.code" );
    OmpClauseBodyStatement.setFunctionPrototype         ( "HEADER_OMP_CLAUSEBODY_STATEMENT", "../Grammar/Statement.code" );
    OmpClauseBodyStatement.setFunctionSource            ("SOURCE_OMP_CLAUSEBODY_STATEMENT", "../Grammar/Statement.code" );

    OmpBodyStatement.setFunctionPrototype         ("HEADER_OMP_BODY_STATEMENT", "../Grammar/Statement.code");
    OmpBodyStatement.setFunctionSource            ("SOURCE_OMP_BODY_STATEMENT", "../Grammar/Statement.code");
    OmpCriticalStatement.setFunctionSource            ("SOURCE_OMP_CRITICAL_STATEMENT", "../Grammar/Statement.code");
    OmpFlushStatement.setFunctionSource            ("SOURCE_OMP_FLUSH_STATEMENT", "../Grammar/Statement.code" );
    OmpDeclareSimdStatement.setFunctionPrototype   ("HEADER_OMP_DECLARE_SIMD_STATEMENT", "../Grammar/Statement.code");
    OmpDeclareSimdStatement.setFunctionSource      ("SOURCE_OMP_DECLARE_SIMD_STATEMENT", "../Grammar/Statement.code");

    OmpParallelStatement.setFunctionSource            ("SOURCE_OMP_PARALLEL_STATEMENT", "../Grammar/Statement.code" );
    OmpSectionsStatement.setFunctionSource            ("SOURCE_OMP_SECTIONS_STATEMENT", "../Grammar/Statement.code" );
    OmpSectionStatement.setFunctionSource            ("SOURCE_OMP_SECTION_STATEMENT", "../Grammar/Statement.code" );
    OmpTaskStatement.setFunctionSource            ("SOURCE_OMP_TASK_STATEMENT", "../Grammar/Statement.code" );
    OmpSingleStatement.setFunctionSource            ("SOURCE_OMP_SINGLE_STATEMENT", "../Grammar/Statement.code" );

    OmpThreadprivateStatement.setFunctionPrototype    ( "HEADER_OMP_THREADPRIVATE_STATEMENT", "../Grammar/Statement.code" );

    OmpThreadprivateStatement.setFunctionSource            ("SOURCE_OMP_THREADPRIVATE_STATEMENT", "../Grammar/Statement.code" );
    OmpForStatement.setFunctionSource            ("SOURCE_OMP_FOR_STATEMENT", "../Grammar/Statement.code" );
    OmpForSimdStatement.setFunctionSource            ("SOURCE_OMP_FOR_SIMD_STATEMENT", "../Grammar/Statement.code" );
    OmpAtomicStatement.setFunctionSource            ("SOURCE_OMP_ATOMIC_STATEMENT", "../Grammar/Statement.code" );
    OmpBarrierStatement.setFunctionSource            ("SOURCE_OMP_BARRIER_STATEMENT", "../Grammar/Statement.code" );
    OmpMasterStatement.setFunctionSource            ("SOURCE_OMP_MASTER_STATEMENT", "../Grammar/Statement.code" );
    OmpOrderedStatement.setFunctionSource            ("SOURCE_OMP_ORDERED_STATEMENT", "../Grammar/Statement.code" );
    OmpTaskwaitStatement.setFunctionSource            ("SOURCE_OMP_TASKWAIT_STATEMENT", "../Grammar/Statement.code" );

    OmpTargetStatement.setFunctionSource            ("SOURCE_OMP_TARGET_STATEMENT", "../Grammar/Statement.code" );
    OmpTargetDataStatement.setFunctionSource            ("SOURCE_OMP_TARGET_DATA_STATEMENT", "../Grammar/Statement.code" );
    OmpSimdStatement.setFunctionSource            ("SOURCE_OMP_SIMD_STATEMENT", "../Grammar/Statement.code" );

   // sections {section, section} // `containerSuccessors >1 is not allowed in ROSETTA's traversal
   // We hack the code to handle this special case
//    OmpSectionsStatement.setDataPrototype("SgOmpSectionStatementPtrList", "sections", "",
//                                    NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
//    OmpSectionsStatement.setDataPrototype("SgOmpClausePtrList", "clauses", "",
//         NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
    // directives with variable lists
            // omp flush [(var-list)]
    // Liao 9/27/2010, per user's report, modeling the variable reference use SgVarRefExp
    //OmpFlushStatement.setDataPrototype( "SgInitializedNamePtrList", "variables", "",
    OmpFlushStatement.setDataPrototype( "SgVarRefExpPtrList", "variables", "",
                                                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

    OmpDeclareSimdStatement.setDataPrototype("SgOmpClausePtrList", "clauses", "",
                              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

   // omp threadprivate [(var-list)]
    OmpThreadprivateStatement.setDataPrototype( "SgVarRefExpPtrList", "variables", "",
                                                NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
   // Directives with a statement/ structured body
    OmpBodyStatement.setDataPrototype ( "SgStatement*", "body",        "= NULL",
                                             CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);
    // Directive with a body + a name:
        // omp critical [name]  \n structured_block
    OmpCriticalStatement.setDataPrototype ( "SgName", "name", "= \"\"",
                  CONSTRUCTOR_PARAMETER, BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);

    // omp clause-body : e.g: parallel clause \n  body
    // having both
    OmpClauseBodyStatement.setDataPrototype("SgOmpClausePtrList", "clauses", "",
                              NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE);

//    OmpClauseBodyStatement.setAutomaticGenerationOfDestructor(false);
#endif

     MicrosoftAttributeDeclaration.setFunctionSource ( "SOURCE_MICROSOFT_ATTRIBUTE_DECLARATION_STATEMENT", "../Grammar/Statement.code" );

   }
