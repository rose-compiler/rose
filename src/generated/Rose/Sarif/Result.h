//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This file was generated by Rosebud
//     ./rosebud --no-locations --backend=sawyer '--serializer=boost,cereal'
//         --sawyer-generated=/Users/rasmussen17/ROSE/rose-develop/src/generated/Rose/Sarif --sawyer-header-prefix=rose/Rose/Sarif
//
// See documentation for the ::Rosebud namespace for information about the input language and how to best run
// the commands to (re)generate this file. See `rosebud --help` for documentation about command-line switches.
//
// The ::Rosebud namespace might be documented at one of these places:
//     https://rpm.is/rose
//     http://rosecompiler.org/ROSE_HTML_Reference/index.html
//
#ifndef ROSE_Sarif_Result_H
#define ROSE_Sarif_Result_H
#include <RoseFirst.h>

#include <rosePublicConfig.h>
#ifdef ROSE_ENABLE_BOOST_SERIALIZATION
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/version.hpp>
#endif

#include <rosePublicConfig.h>
#ifdef ROSE_HAVE_CEREAL
#include <cereal/access.hpp>
#include <cereal/cereal.hpp>
#include <cereal/types/memory.hpp>
#endif

#include <featureTests.h>
#ifdef ROSE_ENABLE_SARIF
#include <Rose/Sarif/Node.h>

#include <Sawyer/Optional.h>

#ifdef ROSE_Sarif_Result_IMPL
#include <Rose/Sarif/CodeFlow.h>
#include <Rose/Sarif/Location.h>
#endif

namespace Rose {
namespace Sarif {

/** A single result from an analysis.
 *
 *  A result is the child of an @ref Analysis in a SARIF @ref Log. A result has a @ref Kind such as @c PASS or @c FAIL. A failure
 *  result has a @ref Severity such as @c WARNING or @c ERROR. Other result properties are a @ref message, an @ref id "ID", a
 *  reference to a particular @ref rule, a reference to the @ref analysisTarget "analysis target artifact", etc. A result also has
 *  a list of @ ref locations.
 *
 *  Example:
 *
 *  @snippet{trimleft} sarifUnitTests.C sarif_result */
class Result: public Node {
public:
    // Automatically generated; do not modify!
    /** Shared-ownership pointer to @ref Result.
     *
     *  @{ */
    using Ptr = ResultPtr;
    using ConstPtr = ResultConstPtr;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:

    /** Property: Kind of result.
     *
     *  The kind is set by the constructor and is read-only. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    Kind const& kind() const;
private:
    // Automatically generated; do not modify!
    void kind(Kind const&);
private:
    // Automatically generated; do not modify!
    Kind kind_P4703_;
    /** @} */

    /** Property: Severity of result.
     *
     *  The severity is set by the constructor and is read-only. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    Severity const& severity() const;
private:
    // Automatically generated; do not modify!
    void severity(Severity const&);
private:
    // Automatically generated; do not modify!
    Severity severity_P3287_;
    /** @} */

    /** Property: Message.
     *
     *  An optional multi-line text message. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& message() const;
public:
    // Automatically generated; do not modify!
    void message(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string message_P8759_;
    /** @} */

    /** Property: Stable ID.
     *
     *  A result may have a stable ID. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& id() const;
public:
    // Automatically generated; do not modify!
    void id(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string id_P6463_;
    /** @} */

    /** Property: Associated rule.
     *
     *  Pointer to an optional rule associated with this result. If this result points to a rule, then the rule must be attached to
     *  the same @ref Analysis as this result before this result can be emitted. Attempting to emit a result pointing to a detached
     *  rule will result in an exception. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    RulePtr const& rule() const;
public:
    // Automatically generated; do not modify!
    void rule(RulePtr const&);
private:
    // Automatically generated; do not modify!
    RulePtr rule_P2631_;
    /** @} */

    /** Property: Analysis target.
     *
     *  Pointer to an optional artifact associated with this result. If this result points to an analysis target, then that target
     *  must be attached to the same @ref Analysis as one of its artifacts before this result can be emitted. Attempting to emit a
     *  result pointing to a detached artifact will result in an exception. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    ArtifactPtr const& analysisTarget() const;
public:
    // Automatically generated; do not modify!
    void analysisTarget(ArtifactPtr const&);
private:
    // Automatically generated; do not modify!
    ArtifactPtr analysisTarget_P3770_;
    /** @} */

public:

    /** Locations associated with this result. 
     * 
     * @{ */
public:
    // Automatically generated; do not modify!
    EdgeVector<Location> const& locations() const;
public:
    // Automatically generated; do not modify!
    EdgeVector<Location>& locations();
private:
    // Automatically generated; do not modify!
    EdgeVector<Location> locations_P2292_;
    /** @} */

    /** Code flows associated with this result. 
     * 
     * @{ */
public:
    // Automatically generated; do not modify!
    EdgeVector<CodeFlow> const& codeFlows() const;
public:
    // Automatically generated; do not modify!
    EdgeVector<CodeFlow>& codeFlows();
private:
    // Automatically generated; do not modify!
    EdgeVector<CodeFlow> codeFlows_P1620_;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Public functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:

    // Find index, if any, of the specified rule within the parent analysis.
    Sawyer::Optional<size_t> findRuleIndex(const RulePtr&);

    // Find index, if any, of the specified artifact within the parent analysis.
    Sawyer::Optional<size_t> findArtifactIndex(const ArtifactPtr&);

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Allocating constructor.
     *
     *  If a @ref Kind is specified then it must not be @ref Kind::FAIL. If a @ref Severity is specified then is must not be @ref
     *  Severity::NONE.
     *
     *  If a location is specified, then it becomes the first location. Locations can be added/removed/modified later by adjusting
     *  the @ref locations property.
     *
     * @{ */
    static Ptr instance(Kind, const std::string &mesg);
    static Ptr instance(Kind, const std::string &mesg, const LocationPtr &location);
    static Ptr instance(Severity, const std::string &mesg);
    static Ptr instance(Severity, const std::string &mesg, const LocationPtr &location);
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Overrides
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool emit(std::ostream&) override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Generated constructors, etc.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

protected:
    /** Default constructor. */
    Result();

public:
    virtual ~Result();

    //----------------------- Boost serialization for Result -----------------------
#ifdef ROSE_ENABLE_BOOST_SERIALIZATION
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Node);
        s & BOOST_SERIALIZATION_NVP(kind_P4703_);
        s & BOOST_SERIALIZATION_NVP(severity_P3287_);
        s & BOOST_SERIALIZATION_NVP(message_P8759_);
        s & BOOST_SERIALIZATION_NVP(id_P6463_);
        s & BOOST_SERIALIZATION_NVP(rule_P2631_);
        s & BOOST_SERIALIZATION_NVP(analysisTarget_P3770_);
        s & BOOST_SERIALIZATION_NVP(locations_P2292_);
        s & BOOST_SERIALIZATION_NVP(codeFlows_P1620_);
    }
#endif // ROSE_ENABLE_BOOST_SERIALIZATION

#ifdef ROSE_HAVE_CEREAL
private:
    friend class cereal::access;

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_SAVE_FUNCTION_NAME(Archive &archive) const {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("kind", kind_P4703_));
        archive(cereal::make_nvp("severity", severity_P3287_));
        archive(cereal::make_nvp("message", message_P8759_));
        archive(cereal::make_nvp("id", id_P6463_));
        archive(cereal::make_nvp("rule", rule_P2631_));
        archive(cereal::make_nvp("analysisTarget", analysisTarget_P3770_));
        archive(cereal::make_nvp("locations", locations_P2292_));
        archive(cereal::make_nvp("codeFlows", codeFlows_P1620_));
    }

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_LOAD_FUNCTION_NAME(Archive &archive) {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("kind", kind_P4703_));
        archive(cereal::make_nvp("severity", severity_P3287_));
        archive(cereal::make_nvp("message", message_P8759_));
        archive(cereal::make_nvp("id", id_P6463_));
        archive(cereal::make_nvp("rule", rule_P2631_));
        archive(cereal::make_nvp("analysisTarget", analysisTarget_P3770_));
        archive(cereal::make_nvp("locations", locations_P2292_));
        archive(cereal::make_nvp("codeFlows", codeFlows_P1620_));
    }
#endif // ROSE_HAVE_CEREAL
};

} // namespace
} // namespace
#endif

#endif // include once
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
