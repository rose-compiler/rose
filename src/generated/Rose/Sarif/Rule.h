//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This file was generated by Rosebud
//     ./rosebud --no-locations --backend=sawyer '--serializer=boost,cereal'
//         --sawyer-generated=/home/matzke/rose-wip/rose/src/generated/Rose/Sarif --sawyer-header-prefix=rose/Rose/Sarif
//
// See documentation for the ::Rosebud namespace for information about the input language and how to best run
// the commands to (re)generate this file. See `rosebud --help` for documentation about command-line switches.
//
// The ::Rosebud namespace might be documented at one of these places:
//     https://rpm.is/rose
//     http://rosecompiler.org/ROSE_HTML_Reference/index.html
//
#ifndef ROSE_Sarif_Rule_H
#define ROSE_Sarif_Rule_H

#include <rosePublicConfig.h>
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/version.hpp>
#endif

#include <rosePublicConfig.h>
#ifdef ROSE_HAVE_CEREAL
#include <cereal/access.hpp>
#include <cereal/cereal.hpp>
#include <cereal/types/memory.hpp>
#endif

#include <featureTests.h>
#ifdef ROSE_ENABLE_SARIF
#include <Rose/Sarif/Node.h>

#include <boost/uuid/uuid.hpp>
#include <rose_serialize_uuid.h>

namespace Rose {
namespace Sarif {

/** Information that describes a tool analysis result.
 *
 *  This object represents meta data about an analysis result. An analysis result may refer to a particular rule in order to impart
 *  additional meta information to the result.
 *
 *  In the SARIF standard, this object is called a "reportingDescriptor" object and is more general than how we use it here.  The
 *  standard says "A 'reportingDescriptor' object contains information that describes a 'reporting item' generated by a tool. A
 *  reporting item is either a result produced by the tool's analysis, or a notification of a condition encountered by the tool. We
 *  refer to this descriptive information as 'reporting item metadata'. When referring to the metadata that describes a result, we
 *  use the more specific term 'rule metadata'. Some of the properties of the reportingDescriptor object are interpreted differently
 *  depending on whether the object represents a rule or a notification. The description of each property will specify any such
 *  differences."
 *
 *  A rule has properties such as @ref id "ID", @ref name, @ref description, @ref helpUri "help URI", @ref uuid "UUID", etc.
 *
 *  Example:
 *
 *  @snippet{trimleft} sarifUnitTests.C sarif_rule */
class Rule: public Node {
public:
    // Automatically generated; do not modify!
    /** Shared-ownership pointer to @ref Rule.
     *
     *  @{ */
    using Ptr = RulePtr;
    using ConstPtr = RuleConstPtr;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:

    /** Property: Identification string.
     *
     *  The identification string should be a short, stable string that identifies the rule. This string is set by the constructor
     *  and not modifiable thereafter. Identifiers may be opaque to the user. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& id() const;
private:
    // Automatically generated; do not modify!
    void id(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string id_P6463_;
    /** @} */

    /** Property: Optional name.
     *
     *  A rule may contain a non-null name that is understandable to the user. If the name of a rule contains implementation details
     *  that change over time, a tool author might alter a rule's name while leaving the stable ID property unchanged. A rule name
     *  is suitable in contexts where a readable identifier is preferable and where the lack of stability is not a concern. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& name() const;
public:
    // Automatically generated; do not modify!
    void name(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string name_P8119_;
    /** @} */

    /** Property: Full description.
     *
     *  The full description is a multi-line, multi-paragraph string describing the rule in detail. It is initially set during
     *  construction but can be changed later. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& description() const;
public:
    // Automatically generated; do not modify!
    void description(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string description_P6653_;
    /** @} */

    /** Property: Help URI.
     *
     *  A URI pointing to the primary documentation for the reporting item. The documentation might include examples, author contact
     *  information, and links to additional information. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    std::string const& helpUri() const;
public:
    // Automatically generated; do not modify!
    void helpUri(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string helpUri_P6519_;
    /** @} */

    /** Property: Universally unique identifier.
     *
     *  The universally unique identification. This is assigned during construction, but can be changed later. 
     *  
     *  @{ */
public:
    // Automatically generated; do not modify!
    boost::uuids::uuid const& uuid() const;
public:
    // Automatically generated; do not modify!
    void uuid(boost::uuids::uuid const&);
private:
    // Automatically generated; do not modify!
    boost::uuids::uuid uuid_P543_;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Overrides
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool emit(std::ostream&) override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Generated constructors, etc.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

protected:
    /** Constructor. */
    Rule(std::string const& id,
         std::string const& description);

public:
    /** Allocating constructor. */
    static Ptr instance(std::string const& id,
                        std::string const& description);

protected:
    /** Default constructor. */
    Rule();

private:
    // Automatically generated; do not modify!
    /** Default allocating constructor. */
    static Ptr instance();

public:
    virtual ~Rule();

    //----------------------- Boost serialization for Rule -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Node);
        s & BOOST_SERIALIZATION_NVP(id_P6463_);
        s & BOOST_SERIALIZATION_NVP(name_P8119_);
        s & BOOST_SERIALIZATION_NVP(description_P6653_);
        s & BOOST_SERIALIZATION_NVP(helpUri_P6519_);
        s & BOOST_SERIALIZATION_NVP(uuid_P543_);
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION_LIB

#ifdef ROSE_HAVE_CEREAL
private:
    friend class cereal::access;

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_SAVE_FUNCTION_NAME(Archive &archive) const {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("id", id_P6463_));
        archive(cereal::make_nvp("name", name_P8119_));
        archive(cereal::make_nvp("description", description_P6653_));
        archive(cereal::make_nvp("helpUri", helpUri_P6519_));
        archive(cereal::make_nvp("uuid", uuid_P543_));
    }

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_LOAD_FUNCTION_NAME(Archive &archive) {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("id", id_P6463_));
        archive(cereal::make_nvp("name", name_P8119_));
        archive(cereal::make_nvp("description", description_P6653_));
        archive(cereal::make_nvp("helpUri", helpUri_P6519_));
        archive(cereal::make_nvp("uuid", uuid_P543_));
    }
#endif // ROSE_HAVE_CEREAL
};

} // namespace
} // namespace
#endif

#endif // include once
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
