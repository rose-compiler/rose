//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// This file was generated by Rosebud
//     ./rosebud --no-locations --backend=sawyer '--serializer=boost,cereal'
//         --sawyer-generated=/home/matzke/devel/rose/src/generated/Rose/Sarif --sawyer-header-prefix=rose/Rose/Sarif
//
// See documentation for the ::Rosebud namespace for information about the input language and how to best run
// the commands to (re)generate this file. See `rosebud --help` for documentation about command-line switches.
//
// The ::Rosebud namespace might be documented at one of these places:
//     https://rpm.is/rose
//     http://rosecompiler.org/ROSE_HTML_Reference/index.html
//
#ifndef ROSE_Sarif_Location_H
#define ROSE_Sarif_Location_H
#include <RoseFirst.h>

#include <rosePublicConfig.h>
#ifdef ROSE_ENABLE_BOOST_SERIALIZATION
#include <boost/serialization/access.hpp>
#include <boost/serialization/base_object.hpp>
#include <boost/serialization/map.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/shared_ptr.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/version.hpp>
#endif

#include <rosePublicConfig.h>
#ifdef ROSE_HAVE_CEREAL
#include <cereal/access.hpp>
#include <cereal/cereal.hpp>
#include <cereal/types/memory.hpp>
#endif

#include <featureTests.h>
#ifdef ROSE_ENABLE_SARIF
#include <Rose/Sarif/Node.h>

#include <Rose/BinaryAnalysis/AddressInterval.h>
#include <Rose/SourceLocation.h>

namespace Rose {
namespace Sarif {

/** Location or region for a result.
 *
 *  A location is either a source location or a binary location and defines a particular point in an artifact. Source locations
 *  have a file name, a 1-origin line number, and an optional 1-origin column number. A binary location is a binary specimen name
 *  and an address within the specimen. Binary locations are only supported when ROSE is configured to support binary anslysis.
 *
 *  A region consists of two locations: a begin location (inclusive) and an end location (exclusive). The two locations must refer
 *  to the same artifact, and the end location must be greater than the begin location. For source regions, if a begin location
 *  lacks a column number, then column 1 is assumed and if an end location lacks a column number then one past the last column is
 *  assumed.
 *
 *  Each location may also have a @ref message "text message" property.
 *
 *  Example:
 *
 *  @snippet{trimleft} sarifUnitTests.C sarif_location */
class Location: public Node {
public:
    // Automatically generated; do not modify!
    /** Shared-ownership pointer to @ref Location.
     *
     *  @{ */
    using Ptr = LocationPtr;
    using ConstPtr = LocationConstPtr;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    // Info for a source location or region. If the end location is valid, then the begin location is also valid.
private:
    // Automatically generated; do not modify!
    SourceLocation const& sourceBegin() const;
private:
    // Automatically generated; do not modify!
    void sourceBegin(SourceLocation const&);
private:
    // Automatically generated; do not modify!
    SourceLocation sourceBegin_P8769_;
private:
    // Automatically generated; do not modify!
    SourceLocation const& sourceEnd() const;
private:
    // Automatically generated; do not modify!
    void sourceEnd(SourceLocation const&);
private:
    // Automatically generated; do not modify!
    SourceLocation sourceEnd_P2636_;

    // Info for a binary location or region. These are valid only if source is not valid.
private:
    // Automatically generated; do not modify!
    std::string const& binaryArtifact() const;
private:
    // Automatically generated; do not modify!
    void binaryArtifact(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string binaryArtifact_P9330_;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
private:
    // Automatically generated; do not modify!
    BinaryAnalysis::AddressInterval const& binaryAddresses() const;
private:
    // Automatically generated; do not modify!
    void binaryAddresses(BinaryAnalysis::AddressInterval const&);
private:
    // Automatically generated; do not modify!
    BinaryAnalysis::AddressInterval binaryAddresses_P7439_;

#endif

public:

    /** Property: Text message. 
     * 
     * @{ */
public:
    // Automatically generated; do not modify!
    std::string const& message() const;
public:
    // Automatically generated; do not modify!
    void message(std::string const&);
private:
    // Automatically generated; do not modify!
    std::string message_P8759_;
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Allocating constructor for a source location. */
    static Ptr instance(const SourceLocation&, const std::string &mesg = "");

    /** Allocating constructor for a source region.
     *
     *  See the @ref Location "class documentation" for how @p begin and @p end relate to each other. If the relationship
     *  constraints are violated then an exception is thrown. */
    static Ptr instance(const SourceLocation &begin, const SourceLocation &end, const std::string &mesg = "");

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
    /** Allocating constructor for a binary location.
     *
     *  This is only available when ROSE is configured to support binary analysis. */
    static Ptr instance(const std::string &binaryArtifact, rose_addr_t, const std::string &mesg = "");
#endif

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
    /** Allocating constructor for a binary region.
     *
     *  The region must not be empty or an exception is thrown.
     *
     *  @note Although this API is able to represent a region containing an entire address space, the SARIF design has a flaw that
     *  makes it impossible to represent such a region. Therefore, during output to the SARIF file, such a region will have its size
     *  decreased by one, thereby excluding the maximum address but resulting in a size that can be represented in the same number
     *  of bits as the address.
     *
     *  This is only available when ROSE is configured to support binary analysis. */
    static Ptr instance(const std::string &binaryArtifact, const BinaryAnalysis::AddressInterval&, const std::string &mesg = "");
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Public functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Source location.
     *
     *  Returns the source location. If this is a source region, then the beginning location of the region is returned. If this is a
     *  binary location then an empty source location is returned instead. */
    const SourceLocation& sourceLocation() const;

    /** Source region.
     *
     *  Returns the source region as a pair of locations: the begin (inclusive) and end (exclusive) locations. See the @ref Location
     *  "class documentation" for how these locations relate to each other. If this object represents only a single location instead
     *  of a region, then the second return value is empty. If this is a binary location or region, then both members of the
     *  returned pair will be empty. */
    std::pair<SourceLocation, SourceLocation> sourceRegion() const;

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
    /** Binary location.
     *
     *  Returns the binary location as a pair consisting of the binary artifact name and the address. If this is not a binary
     *  location then an empty string and the address zero is returned. Since the empty string and zero address are a valid binary
     *  location, the correct way to tell whether a location is a binary location is to test whether it is not a @ref sourceLocation
     *  "source location". A location is a binary location if and only if it is not a source location.
     *
     *  This is only available if ROSE is configured to support binary analysis. */
    std::pair<std::string, rose_addr_t> binaryLocation() const;
#endif

#ifdef ROSE_ENABLE_BINARY_ANALYSIS
    /** Binary region.
     *
     *  Returns the binary region as pair consisting of the binary artifact name, and the address interval. If this object stores
     *  only a binary location (not a region) then the address interval is a singleton. If this object stores a source location or
     *  region, then the return value is an empty string and an empty address interval.
     *
     *  This is only available if ROSE is configured to support binary analysis. */
    std::pair<std::string, BinaryAnalysis::AddressInterval> binaryRegion() const;
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Private functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    void checkConsistency() const;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Overrides
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    bool emit(std::ostream&) override;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Generated constructors, etc.
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

protected:
    /** Default constructor. */
    Location();

public:
    // Automatically generated; do not modify!
    /** Default allocating constructor. */
    static Ptr instance();

public:
    virtual ~Location();

    //----------------------- Boost serialization for Location -----------------------
#ifdef ROSE_ENABLE_BOOST_SERIALIZATION
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(Node);
        s & BOOST_SERIALIZATION_NVP(sourceBegin_P8769_);
        s & BOOST_SERIALIZATION_NVP(sourceEnd_P2636_);
        s & BOOST_SERIALIZATION_NVP(binaryArtifact_P9330_);
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
        s & BOOST_SERIALIZATION_NVP(binaryAddresses_P7439_);
#endif
        s & BOOST_SERIALIZATION_NVP(message_P8759_);
    }
#endif // ROSE_ENABLE_BOOST_SERIALIZATION

#ifdef ROSE_HAVE_CEREAL
private:
    friend class cereal::access;

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_SAVE_FUNCTION_NAME(Archive &archive) const {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("sourceBegin", sourceBegin_P8769_));
        archive(cereal::make_nvp("sourceEnd", sourceEnd_P2636_));
        archive(cereal::make_nvp("binaryArtifact", binaryArtifact_P9330_));
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
        archive(cereal::make_nvp("binaryAddresses", binaryAddresses_P7439_));
#endif
        archive(cereal::make_nvp("message", message_P8759_));
    }

    // Automatically generated; do not modify!
    template<class Archive>
    void CEREAL_LOAD_FUNCTION_NAME(Archive &archive) {
        archive(cereal::base_class<Node>(this));
        archive(cereal::make_nvp("sourceBegin", sourceBegin_P8769_));
        archive(cereal::make_nvp("sourceEnd", sourceEnd_P2636_));
        archive(cereal::make_nvp("binaryArtifact", binaryArtifact_P9330_));
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
        archive(cereal::make_nvp("binaryAddresses", binaryAddresses_P7439_));
#endif
        archive(cereal::make_nvp("message", message_P8759_));
    }
#endif // ROSE_HAVE_CEREAL
};

} // namespace
} // namespace
#endif

#endif // include once
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                         THIS FILE IS MACHINE GENERATED  --  DO NOT MODIFY
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
