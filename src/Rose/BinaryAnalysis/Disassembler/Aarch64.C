#include <featureTests.h>
#ifdef ROSE_ENABLE_ASM_AARCH64
#include <Rose/BinaryAnalysis/Disassembler/Aarch64.h>

#include <Rose/BitOps.h>
#include <Rose/BinaryAnalysis/Architecture/Base.h>
#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#include <Rose/BinaryAnalysis/RegisterDictionary.h>
#include <ROSE_UNUSED.h>

#include <SgAsmAarch64AtOperand.h>
#include <SgAsmAarch64BarrierOperand.h>
#include <SgAsmAarch64CImmediateOperand.h>
#include <SgAsmAarch64Instruction.h>
#include <SgAsmAarch64PrefetchOperand.h>
#include <SgAsmAarch64PState.h>
#include <SgAsmAarch64SysMoveOperand.h>
#include <SgAsmBinaryAdd.h>
#include <SgAsmBinaryAsr.h>
#include <SgAsmBinaryLsl.h>
#include <SgAsmBinaryLsr.h>
#include <SgAsmBinaryMsl.h>
#include <SgAsmBinaryPostupdate.h>
#include <SgAsmBinaryPreupdate.h>
#include <SgAsmBinaryRor.h>
#include <SgAsmDirectRegisterExpression.h>
#include <SgAsmFloatType.h>
#include <SgAsmFloatValueExpression.h>
#include <SgAsmIntegerType.h>
#include <SgAsmIntegerValueExpression.h>
#include <SgAsmMemoryReferenceExpression.h>
#include <SgAsmUnarySignedExtend.h>
#include <SgAsmUnaryTruncate.h>
#include <SgAsmUnaryUnsignedExtend.h>
#include <SgAsmVectorType.h>

#include <Cxx_GrammarDowncast.h>
#include <SageBuilderAsm.h>

using namespace Rose::Diagnostics;

namespace Rose {
namespace BinaryAnalysis {
namespace Disassembler {

Aarch64::Aarch64(const Architecture::Base::ConstPtr &arch, Modes modes)
    : Base(arch), modes_(modes) {
    instructionAlignment_ = 4;

    ASSERT_forbid(modes_.isAnySet(~Mode::MODE_MCLASS));

    // Architecture independent ROSE disassembler properties
    REG_IP = architecture()->registerDictionary()->instructionPointerRegister();
    REG_SP = architecture()->registerDictionary()->stackPointerRegister();
    REG_LINK = architecture()->registerDictionary()->callReturnRegister();
    ASSERT_require(REG_IP);
    ASSERT_require(REG_SP);
    ASSERT_require(REG_LINK);
}

Aarch64::Ptr
Aarch64::instance(const Architecture::Base::ConstPtr &arch, Modes modes) {
    return Ptr(new Aarch64(arch, modes));
}

Base::Ptr
Aarch64::clone() const {
    return Ptr(new Aarch64(*this));
}

void
Aarch64::openCapstone() {
    // Build the Capstone context object, which must be explicitly closed in the destructor. Furthermore, since capstone is a
    // shared library, it might not be possible to call cs_close (in the Aarch32 destructor) after libcapstone has been shut
    // down during program termination. For instance, if you store any static pointers to Aarch32 objects that have open
    // capstone connections, then its likely that the C++ runtime will close the capstone library before calling the
    // destructors for those Aarch32 objects.

    // Warning: the "mode" constants are not orthogonal with each other or the "arch" values.
    cs_mode mode = (cs_mode)modes_.vector();

    if (CS_ERR_OK != cs_open(CS_ARCH_ARM64, mode, &capstone_))
        throw Exception("capstone cs_open failed");
    capstoneOpened_ = true;
    if (CS_ERR_OK != cs_option(capstone_, CS_OPT_DETAIL, CS_OPT_ON))
        throw Exception("capstone cs_option failed");
}

Aarch64::~Aarch64() {
    if (capstoneOpened_) {
        cs_err err = cs_close(&capstone_);
        ASSERT_always_require2(CS_ERR_OK == err, "capstone cs_close failed");
    }
}

SgAsmInstruction*
Aarch64::disassembleOne(const MemoryMap::Ptr &map, Address va, AddressSet *successors/*=nullptr*/) {
    openCapstone();

    // Resources that must be explicitly reclaimed before returning.
    struct Resources {
        cs_insn *csi = nullptr;
        size_t nInsns = 0;
        ~Resources() {
            if (csi)
                cs_free(csi, nInsns);
        }
    } r;

    // Read the encoded instruction bytes into a temporary buffer to be used by capstone
    if (va % instructionAlignment_ != 0)
        throw Exception("instruction pointer not aligned", va);
    uint8_t bytes[4];                                   // largest possible instruction is 4 bytes
    size_t nRead = map->at(va).limit(sizeof bytes).require(MemoryMap::EXECUTABLE).read(bytes).size();
    if (0 == nRead)
        throw Exception("short read", va);

    // Disassemble the instruction with capstone
    r.nInsns = cs_disasm(capstone_, bytes, nRead, va, 1, &r.csi);
    if (0 == r.nInsns)
        return makeUnknownInstruction(Exception("unable to decode instruction", va, SgUnsignedCharList(bytes+0, bytes+nRead), 0));

    ASSERT_require(1 == r.nInsns);
    ASSERT_not_null(r.csi);
    ASSERT_require(r.csi->address == va);
    ASSERT_not_null(r.csi->detail);

    // Convert disassembled capstone instruction to ROSE AST
    SgAsmInstruction *retval = nullptr;
    const cs_arm64 &detail = r.csi->detail->arm64;
#if 0 // DEBGUGGING: show the disassembly string from capstone itself
    std::cerr <<"ROBB: capstone disassembly:"
              <<" " <<StringUtility::addrToString(va) <<":"
              <<" " <<StringUtility::toHex2(bytes[0], 8, false, false).substr(2)
              <<" " <<StringUtility::toHex2(bytes[1], 8, false, false).substr(2)
              <<" " <<StringUtility::toHex2(bytes[2], 8, false, false).substr(2)
              <<" " <<StringUtility::toHex2(bytes[3], 8, false, false).substr(2)
              <<" " <<r.csi->mnemonic <<" " <<r.csi->op_str <<"\n";
#endif
    auto operands = new SgAsmOperandList;
    for (uint8_t i = 0; i < detail.op_count; ++i) {
        SgAsmExpression *operand = makeOperand(*r.csi, detail.operands[i]);
        ASSERT_not_null(operand);
        ASSERT_not_null(operand->get_type());
        operands->get_operands().push_back(operand);
        operand->set_parent(operands);
    }
    wrapPrePostIncrement(operands, detail);
    auto insn = new SgAsmAarch64Instruction(va, *architecture()->registrationId(), (Aarch64InstructionKind)r.csi->id, detail.cc);
    insn->set_rawBytes(SgUnsignedCharList(r.csi->bytes, r.csi->bytes + r.csi->size));
    insn->set_operandList(operands);
    insn->set_updatesFlags(detail.update_flags);
    operands->set_parent(insn);
    retval = insn;

    // Work around capstone bugs
    if (BitOps::bits(opcode(insn), 24, 31) == 0b10011000) {
        // LDRSW (literal) is decoded incorrectly. The second operand should be a 32-bit memory read, not an immediate value.
        if (auto ival = isSgAsmIntegerValueExpression(insn->get_operandList()->get_operands()[1])) {
            // Remove ival from the AST
            insn->get_operandList()->get_operands()[1] = nullptr;
            ival->set_parent(nullptr);

            // Create a memory reference with ival as the address
            auto memref = new SgAsmMemoryReferenceExpression;
            memref->set_type(SageBuilderAsm::buildTypeU32());
            memref->set_address(ival);
            ival->set_parent(memref);

            // Insert the memref into the AST
            insn->get_operandList()->get_operands()[1] = memref;
            memref->set_parent(insn->get_operandList());
        }
    } else if (insn->get_kind() == Aarch64InstructionKind::ARM64_INS_XTN) {
        // The XTN instruction is disassembled incorrectly: the type of the destination argument is wrong.  XTN reads the
        // elements of the source vector, truncates each to half its width, packs the half-sizes together, and writes them to
        // the low half of the destination register while clearing the upper half of the destination.  I.e., it writes as many
        // bits as it reads. However, the destination type is only half as wide as the source type. In contrast, the XTN2
        // instruction which is the same except it writes the result to the upper half of the destination while clearing the
        // lower half, has the correct type.
        ASSERT_require(insn->nOperands() == 2);
        ASSERT_require(insn->operand(0)->get_nBits() * 2 == insn->operand(1)->get_nBits());
        SgAsmVectorType *dstType = isSgAsmVectorType(insn->operand(0)->get_type());
        ASSERT_not_null(dstType);
        insn->operand(0)->set_type(SageBuilderAsm::buildTypeVector(2 * dstType->get_nElmts(), dstType->get_elmtType()));
    }
    ASSERT_not_null(retval);

    // Note successors if necessary
    if (successors) {
        bool complete = false;
        *successors |= architecture()->getSuccessors(retval, complete/*out*/);
    }

    return retval;
}

SgAsmInstruction*
Aarch64::makeUnknownInstruction(const Exception &e) {
    SgAsmAarch64Instruction *insn = new SgAsmAarch64Instruction(e.ip, *architecture()->registrationId(), ARM64_INS_INVALID,
                                                                ARM64_CC_INVALID);
    SgAsmOperandList *operands = new SgAsmOperandList();
    insn->set_operandList(operands);
    operands->set_parent(insn);
    insn->set_rawBytes(e.bytes);
    return insn;
}

SgAsmExpression*
Aarch64::makeOperand(const cs_insn &insn, const cs_arm64_op &op) {
    SgAsmExpression *retval = nullptr;

    switch (op.type) {
        case ARM64_OP_INVALID:
            ASSERT_not_reachable("invalid operand type from Capstone");

        case ARM64_OP_REG: {                            // register operand
            RegisterDescriptor reg = makeRegister(op.reg);
            reg = subRegister(reg, op.vector_index, op.vess);
            retval = new SgAsmDirectRegisterExpression(reg);
            retval->set_type(registerType(reg, op.vas));
            //retval = extractElement(retval, op.vess, op.vector_index);
            retval = extendOperand(retval, insn, op.ext, retval->get_type(), op.shift.type, op.shift.value);
            break;
        }

        case ARM64_OP_IMM:                              // immediate operand
            // Capstone doesn't have any types. It just stores all immediate values in a 64 bit field and assumes that the
            // instruction semantics and unparser will only use that part of the field that is applicable for this instruction
            // and argument type.
            retval = new SgAsmIntegerValueExpression(op.imm, SageBuilderAsm::buildTypeU64());
            retval = extendOperand(retval, insn, op.ext, retval->get_type(), op.shift.type, op.shift.value);
            break;

        case ARM64_OP_MEM: {                            // memory operand
            RegisterDescriptor reg = makeRegister(op.mem.base);
            auto base = new SgAsmDirectRegisterExpression(reg);
            base->set_type(registerType(reg, ARM64_VAS_INVALID));
            SgAsmExpression *addr = base;
            SgAsmType *u64 = SageBuilderAsm::buildTypeU64();

            if (op.mem.index != ARM64_REG_INVALID) {
                RegisterDescriptor indexReg = makeRegister(op.mem.index);
                auto index = new SgAsmDirectRegisterExpression(indexReg);
                index->set_type(registerType(indexReg, ARM64_VAS_INVALID));

                if (op.mem.disp != 0) {
                    auto disp = new SgAsmIntegerValueExpression(op.mem.disp, u64);
                    switch (op.shift.type) {
                        case ARM64_SFT_INVALID:
                            addr = SageBuilderAsm::buildAddExpression(addr, SageBuilderAsm::buildAddExpression(index, disp, u64), u64);
                            break;
                        case ARM64_SFT_LSL:
                            addr = SageBuilderAsm::buildLslExpression(addr, disp, u64);
                            break;
                        case ARM64_SFT_MSL:             // Same as LSL but filling low bits with ones
                            addr = SageBuilderAsm::buildMslExpression(addr, disp, u64);
                            break;
                        case ARM64_SFT_LSR:
                            addr = SageBuilderAsm::buildLsrExpression(addr, disp, u64);
                            break;
                        case ARM64_SFT_ASR:
                            addr = SageBuilderAsm::buildAsrExpression(addr, disp, u64);
                            break;
                        case ARM64_SFT_ROR:
                            addr = SageBuilderAsm::buildRorExpression(addr, disp, u64);
                            break;
                    }
                } else {
                    addr = SageBuilderAsm::buildAddExpression(addr, index, u64);
                }
            } else if (op.mem.disp != 0) {
                auto disp = new SgAsmIntegerValueExpression(op.mem.disp, u64);
                addr = SageBuilderAsm::buildAddExpression(addr, disp, u64);
            }
            addr = extendOperand(addr, insn, op.ext, addr->get_type(), op.shift.type, op.shift.value);

            auto mre = new SgAsmMemoryReferenceExpression;
            mre->set_address(addr);
            mre->set_type(typeForMemoryRead(insn));
            retval = mre;
            break;
        }

        case ARM64_OP_FP:                               // floating-point operand
            retval = SageBuilderAsm::buildValueFloat(op.fp, SageBuilderAsm::buildIeee754Binary64());
            break;

        case ARM64_OP_CIMM:                             // C-immediate
            retval = new SgAsmAarch64CImmediateOperand(op.sys);
            retval->set_type(SageBuilderAsm::buildTypeU(1)); // FIXME: not sure what the type should be, but probably not this
            break;

        case ARM64_OP_REG_MRS:                          // MRS register operand
        case ARM64_OP_REG_MSR: {                        // MSR register operand
#if 1
            // Capstone appears to decode this incorrectly, so we do it according to the ARM documentation instead.
            uint32_t reg = BitOps::bits(opcode(insn), 5, 19);
#else
            uint32_t reg = op.reg;
#endif
            retval = new SgAsmAarch64SysMoveOperand(reg);
            retval->set_type(SageBuilderAsm::buildTypeU(1)); // FIXME: not sure what the type should be, but probably not this
            break;
        }

        case ARM64_OP_PSTATE:                           // PState operand
            retval = new SgAsmAarch64PState(op.pstate);
            retval->set_type(SageBuilderAsm::buildTypeU(1)); // FIXME: not sure what the type should be, but probably not this
            break;

        case ARM64_OP_SYS:                              // SYS operand for IC/DC/AT/TLBI
            retval = new SgAsmAarch64AtOperand((Aarch64AtOperation)op.sys);
            retval->set_type(SageBuilderAsm::buildTypeU(1)); // FIXME: not sure what the type should be, but probably not this
            break;

        case ARM64_OP_PREFETCH:                         // prefetch operand
            retval = new SgAsmAarch64PrefetchOperand(op.prefetch);
            retval->set_type(SageBuilderAsm::buildTypeU(1)); // FIXME: not sure what the type should be, but probably not this
            break;

        case ARM64_OP_BARRIER:                          // memory barrier operand for ISB/DMB/DSB instruction
            retval = new SgAsmAarch64BarrierOperand(op.barrier);
            retval->set_type(SageBuilderAsm::buildTypeU(4)); // the operation is just a constant from 0 through 16
            break;
    }
    ASSERT_not_null(retval);
    ASSERT_not_null(retval->get_type());
    return retval;
}

RegisterDescriptor
Aarch64::subRegister(RegisterDescriptor reg, int idx, arm64_vess elmtSize) {
    size_t nBits = reg.nBits();
    switch (elmtSize) {
        case ARM64_VESS_INVALID:
            break;
        case ARM64_VESS_B:
            nBits = 8;
            break;
        case ARM64_VESS_H:
            nBits = 16;
            break;
        case ARM64_VESS_S:
            nBits = 32;
            break;
        case ARM64_VESS_D:
            nBits = 64;
            break;
    }

    size_t offset = 0;
    if (idx > 0)
        offset = nBits * idx;

    ASSERT_require(offset + nBits <= reg.nBits());
    return RegisterDescriptor(reg.majorNumber(), reg.minorNumber(), offset, nBits);
}

//SgAsmExpression*
//Aarch64::extractElement(SgAsmExpression *expr, arm64_vess elmtSizeSpec, int idx) {
//    ASSERT_not_null(expr);
//    ASSERT_not_null(expr->get_type());
//    if (idx < 0)
//        return expr;
//    size_t elmtNBits = 0;
//    switch (elmtSizeSpec) {
//        case ARM64_VESS_INVALID:
//            ASSERT_not_reachable("invalid vector element size specifier when index is present");
//        case ARM64_VESS_B:
//            elmtNBits = 8;
//            break;
//        case ARM64_VESS_H:
//            elmtNBits = 16;
//            break;
//        case ARM64_VESS_S:
//            elmtNBits = 32;
//            break;
//        case ARM64_VESS_D:
//            elmtNBits = 64;
//            break;
//    }
//
//    size_t offset = idx * elmtNBits;
//    size_t end = offset + elmtNBits;
//    ASSERT_require(end <= expr->get_nBits());
//
//    if (offset > 0) {
//        expr = SageBuilderAsm::buildLsrExpression(expr, SageBuilderAsm::buildValueU8(offset),
//                                                  SageBuilderAsm::buildTypeU(expr->get_nBits()));
//    }
//
//    if (elmtNBits < expr->get_nBits())
//        expr = SageBuilderAsm::buildTruncateExpression(expr, SageBuilderAsm::buildTypeU(elmtNBits));
//
//    return expr;
//}

SgAsmExpression*
Aarch64::extendOperand(SgAsmExpression *expr, const cs_insn &insn, arm64_extender extender, SgAsmType *dstType,
                       arm64_shifter shifter, unsigned shiftAmount) const {
    using namespace ::Rose::BitOps;
    ROSE_UNUSED(insn);

    ASSERT_not_null(expr);
    ASSERT_not_null(expr->get_type());

    if (extender != ARM64_EXT_INVALID) {
        ASSERT_require(isSgAsmIntegerType(expr->get_type()));
        ASSERT_require(isSgAsmIntegerType(dstType));

        // First we need to truncate the incoming value to the specified input size.
        SgAsmIntegerType *tmpType = nullptr;
        switch (extender) {
            case ARM64_EXT_INVALID:
                ASSERT_not_reachable("invalid extender function");
            case ARM64_EXT_UXTB:
                tmpType = SageBuilderAsm::buildTypeU8();
                break;
            case ARM64_EXT_SXTB:
                tmpType = SageBuilderAsm::buildTypeI8();
                break;
            case ARM64_EXT_UXTH:
                tmpType = SageBuilderAsm::buildTypeU16();
                break;
            case ARM64_EXT_SXTH:
                tmpType = SageBuilderAsm::buildTypeI16();
                break;
            case ARM64_EXT_UXTW:
                tmpType = SageBuilderAsm::buildTypeU32();
                break;
            case ARM64_EXT_SXTW:
                tmpType = SageBuilderAsm::buildTypeI32();
                break;
            case ARM64_EXT_UXTX:
                tmpType = SageBuilderAsm::buildTypeU64();
                break;
            case ARM64_EXT_SXTX:
                tmpType = SageBuilderAsm::buildTypeI64();
                break;
        }
        if (tmpType->get_nBits() != expr->get_type()->get_nBits())
            expr = SageBuilderAsm::buildTruncateExpression(expr, tmpType);

        // Now that we have the intermediate type of the correct size, extend it to the final size. If the intermediate
        // expression is already the same as the destination size then there's nothing to do.
        if (tmpType->get_nBits() != dstType->get_nBits()) {
            switch (extender) {
                case ARM64_EXT_UXTB:
                case ARM64_EXT_UXTH:
                case ARM64_EXT_UXTW:
                case ARM64_EXT_UXTX:
                    expr = SageBuilderAsm::buildUnsignedExtendExpression(expr, dstType);
                    break;
                default:
                    expr = SageBuilderAsm::buildSignedExtendExpression(expr, dstType);
                    break;
            }
        }
    }

    if (shifter != ARM64_SFT_INVALID && shiftAmount != 0) {
        ASSERT_require(shiftAmount < dstType->get_nBits());
        auto amount = SageBuilderAsm::buildValueU8(shiftAmount);
        switch (shifter) {
            case ARM64_SFT_LSL:
                expr = SageBuilderAsm::buildLslExpression(expr, amount);
                break;
            case ARM64_SFT_MSL:
                expr = SageBuilderAsm::buildMslExpression(expr, amount);
                break;
            case ARM64_SFT_LSR:
                expr = SageBuilderAsm::buildLsrExpression(expr, amount);
                break;
            case ARM64_SFT_ASR:
                expr = SageBuilderAsm::buildAsrExpression(expr, amount);
                break;
            case ARM64_SFT_ROR:
                expr = SageBuilderAsm::buildRorExpression(expr, amount);
                break;
            case ARM64_SFT_INVALID:
                ASSERT_not_reachable("invalid shifter");
        }
    }

    ASSERT_not_null(expr);
    ASSERT_not_null(expr->get_type());
    ASSERT_require(expr->get_type() == dstType);
    return expr;
}

void
Aarch64::wrapPrePostIncrement(SgAsmOperandList *operands, const cs_arm64 &cs_detail) {
    ASSERT_not_null(operands);

    if (cs_detail.writeback) {
        // This AArch64 instruction must have a memory reference operand and is either pre-update or post-update.  A pre-update
        // instruction will have both the register and the increment within the memory address expression, such as:
        //
        //    Opcode:      95 9d 87 ad
        //    ARM syntax:  stp q21, q7, [x12, #0xf0]!
        //    ROSE syntax: stp q21, q7, u128 [x12 + 0xf0]                  (before the transformation)
        //    ROSE syntax: stp q21, q7, u128 [x12 after x12 = x12 + 0xf0]  (after the transformation)
        //
        // Semantically, the above means that the value in register x12 is added to the constant 0xf0 resulting in the first
        // (lowest) address where data is written to memory.
        //
        // The post-increment operations is slightly different in that Capstone disassembles the expression as two separate
        // instruction operands. For instance:
        //
        //    Opcode:       95 9d 87 ac
        //    ARM syntax:   stp q21, q7, [x12], #0xf0
        //    ROSE syntax:  stp q21, q7, u128 [x12], 0xf0                  (before the transformation)
        //    ROSE syntax:  stp q21, q7, u128 [x12 then x12 = x12 + 0xf0]  (after the transofmration)
        //
        // Semantically, the value stored originally in x12 is used as the memory address, and then the register is incremented
        // by 0xf0. ROSE combines these two arguments into a single expression containing a SgAsmBinaryAddPostupdate node.
        for (size_t i = 0; i < operands->get_operands().size(); ++i) {
            if (auto mre = isSgAsmMemoryReferenceExpression(operands->get_operands()[i])) {
                if (i + 1 == operands->get_operands().size()) {
                    // The memory reference expression is the last operand, therefore this is a pre-increment. The address must
                    // be an addition expression whose lhs is a register reference (or just a register expression, in which
                    // case the pre-increment is a no-op).  Replace the SgAsmBinaryAdd with a SgAsmBinaryAddPreupdate node.
                    // First unlink things from the tree...
                    SgAsmBinaryAdd *add = isSgAsmBinaryAdd(mre->get_address());
                    if (!add) {
                        ASSERT_require(isSgAsmDirectRegisterExpression(mre->get_address()));
                        return; // if the offset is zero then we have already removed it and the pre-increment is a no-op.
                    }
                    SgAsmType *type = add->get_type();
                    ASSERT_not_null(type);

                    // Create a new register reference expression for the lhs of the pre-update operator.
                    ASSERT_require(isSgAsmDirectRegisterExpression(add->get_lhs()));
                    auto lhs = new SgAsmDirectRegisterExpression(isSgAsmDirectRegisterExpression(add->get_lhs())->get_descriptor());
                    lhs->set_type(type);

                    // Unlink things from the AST and construct a new address, linking it back into the AST.
                    mre->set_address(nullptr); add->set_parent(nullptr);
                    auto preUpdate = SageBuilderAsm::buildPreupdateExpression(lhs, add);
                    mre->set_address(preUpdate); preUpdate->set_parent(mre);
                    return;

                } else {
                    // The memory reference must be a post-increment, in which case it must the the penultimate argument. The
                    // address must be a register reference. First unlink things from the tree...
                    ASSERT_require(i + 2 == operands->get_operands().size());
                    auto postLhs = isSgAsmDirectRegisterExpression(mre->get_address());
                    ASSERT_not_null(postLhs);
                    mre->set_address(nullptr); postLhs->set_parent(nullptr);
                    auto inc = operands->get_operands()[i + 1];
                    operands->get_operands().pop_back();
                    inc->set_parent(nullptr);

                    // Create a new register reference expression that's the old value of the register
                    auto oldValue = new SgAsmDirectRegisterExpression(postLhs->get_descriptor());
                    oldValue->set_type(postLhs->get_type());

                    // Create the post-update expression and link it into the AST
                    auto newValue = SageBuilderAsm::buildAddExpression(oldValue, inc);
                    auto postUpdate = SageBuilderAsm::buildPostupdateExpression(postLhs, newValue);
                    mre->set_address(postUpdate); postUpdate->set_parent(mre);
                    return;
                }
            }
        }
        ASSERT_not_reachable("writeback was set but there is no memory reference operand");
    }
}

uint32_t
Aarch64::opcode(const cs_insn &insn) {
    uint32_t code = insn.bytes[0] | (insn.bytes[1] << 8) | (insn.bytes[2] << 16) | (insn.bytes[3] << 24);
    return ByteOrder::diskToHost(byteOrder(), code);
}

uint32_t
Aarch64::opcode(SgAsmInstruction *insn) {
    ASSERT_not_null(insn);
    const std::vector<uint8_t> &bytes = insn->get_rawBytes();
    ASSERT_require(bytes.size() == 4);
    uint32_t code = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24);
    return ByteOrder::diskToHost(byteOrder(), code);
}

SgAsmType*
Aarch64::typeForMemoryRead(const cs_insn &insn) {
    using namespace ::Rose::BitOps;
    using Kind = ::Rose::BinaryAnalysis::Aarch64InstructionKind;
    uint32_t code = opcode(insn);

    switch ((Kind)insn.id) {
        //--------------------------------------------------------------------------------------------------------
        //case Kind::ARM64_INS_LDADDB:    // atomic add on byte in memory                       -- not in capstone
        //case Kind::ARM64_INS_LDADDAB:   // atomic add on byte in memorym                      -- not in capstone
        //case Kind::ARM64_INS_LDADDALB:  // atomic add on byte in memory                       -- not in capstone
        //case Kind::ARM64_INS_LDADDLB:   // atomic add on byte in memory                       -- not in capstone
        //case Kind::ARM64_INS_LDAPRB:    // load-acquire RCpc register byte                    -- not in capstone
        //case Kind::ARM64_INS_LDAPURB:   // load-acquire RCpc register byte unscaled           -- not in capstone
        //case Kind::ARM64_INS_LDAPURSB:  // load-acquire RCpc regiater signed byte unscaled    -- not in capstone
        case Kind::ARM64_INS_LDARB:     // load-acquire register byte
        case Kind::ARM64_INS_LDAXRB:    // load-acquire exclusive register byte
        //case Kind::ARM64_INS_LDCLRB:    // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_LDCLRAB:   // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_LDCLRALB:  // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_LDCLRLB:   // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_LDEORB:    // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_LDEORAB:   // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_LDEORALB:  // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_LDEORLB:   // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_LDLARB:    // load LOAcquire register byte                       -- not in capstone
        case Kind::ARM64_INS_LDRB:      // load register byte
        case Kind::ARM64_INS_LDRSB:     // load register signed byte
        //case Kind::ARM64_INS_LDSETB:    // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDSETAB:   // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDSETALB:  // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDSETLB:   // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDSMAXB:   // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMAXAB:  // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMAXALB: // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMAXLB:  // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMINB:   // atomic signed minimum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMINAB:  // atomic signed minimum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMINALB: // atomic signed minimum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_LDSMINLB:  // atomic signed minimum on byte in memory            -- not in capstone
        case Kind::ARM64_INS_LDTRB:     // load register byte unprivileged
        case Kind::ARM64_INS_LDTRSB:    // load register signed byte unprivileged
        //case Kind::ARM64_INS_LDUMAXB:   // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMAXAB:  // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMAXALB: // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMAXLB:  // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMINB:   // atomic unsigned minimum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMINAB:  // atomic unsigned minimum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMINALB: // atomic unsigned minimum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_LDUMINLB:  // atomic unsigned minimum on byte in memory          -- not in capstone
        case Kind::ARM64_INS_LDURB:     // load register byte unscaled
        case Kind::ARM64_INS_LDURSB:    // load register signed byte unscaled
        case Kind::ARM64_INS_LDXRB:     // load exclusive register byte
        case Kind::ARM64_INS_PRFM:      // prefetch memory
        case Kind::ARM64_INS_PRFUM:     // prefetch memory, unscaled offset
        //case Kind::ARM64_INS_STADDB:    // atomic add on byte in memory                       -- not in capstone
        //case Kind::ARM64_INS_STADDLB:   // atomic add on byte in memory                       -- not in capstone
        //case Kind::ARM64_INS_STCLRB:    // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_STCLRLB:   // atomic bit clear on byte in memory                 -- not in capstone
        //case Kind::ARM64_INS_STEORB:    // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_STEORLB:   // atomic exclusive OR on byte in memory              -- not in capstone
        //case Kind::ARM64_INS_STLLRB:    // store LORelease register byte                      -- not in capstone
        case Kind::ARM64_INS_STLRB:     // store-release register byte
        //case Kind::ARM64_INS_STLURB:    // store-release register byte                        -- not in capstone
        case Kind::ARM64_INS_STLXRB:    // store-release exclusive register byte
        case Kind::ARM64_INS_STRB:      // store register byte
        //case Kind::ARM64_INS_STSETB:    // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_STSETLB:   // atomic bit set on byte in memory                   -- not in capstone
        //case Kind::ARM64_INS_STSMAXB:   // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_STSMAXLB:  // atomic signed maximum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_STSMINB:   // atomic signed minimum on byte in memory            -- not in capstone
        //case Kind::ARM64_INS_STSMINLB:  // atomic signed minimum on byte in memory            -- not in capstone
        case Kind::ARM64_INS_STTRB:     // store register byte unprivileged
        //case Kind::ARM64_INS_STUMAXB:   // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_STUMAXLB:  // atomic unsigned maximum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_STUMINB:   // atomic unsigned minimum on byte in memory          -- not in capstone
        //case Kind::ARM64_INS_STUMINLB:  // atomic unsigned minimum on byte in memory          -- not in capstone
        case Kind::ARM64_INS_STURB:     // store register byte unscaled
        case Kind::ARM64_INS_STXRB:     // store exclusive register byte
            return SageBuilderAsm::buildTypeU(8);

        //--------------------------------------------------------------------------------------------------------
        //case Kind::ARM64_INS_LDADDH:    // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDADDAH:   // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDADDALH:  // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDADDLH:   // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDAPRH:    // load-acquire RCpc register halfword                -- not in capstone
        //case Kind::ARM64_INS_LDAPURH:   // load-acquire RCpc register halfword unscaled       -- not in capstone
        //case Kind::ARM64_INS_LDAPURSH:  // load-acquire RCpc register signed halfword unscaled-- not in capstone
        case Kind::ARM64_INS_LDARH:     // load-acquire register halfword
        case Kind::ARM64_INS_LDAXRH:    // load-acquire exclusive register halfword
        //case Kind::ARM64_INS_LDCLRH:    // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_LDCLRAH:   // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_LDCLRALH:  // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_LDCLRLH:   // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_LDEORH:    // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_LDEORAH:   // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_LDEORALH:  // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_LDEORLH:   // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_LDLARH:    // load LOAcquire register halfword                   -- not in capstone
        case Kind::ARM64_INS_LDRH:      // load register halfword
        case Kind::ARM64_INS_LDRSH:     // load register signed halfword
        //case Kind::ARM64_INS_LDSETH:    // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_LDSETAH:   // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_LDSETALH:  // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_LDSETLH:   // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_LDSMAXH:   // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMAXAH:  // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMAXALH: // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMAXLH:  // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMINH:   // atomic signed minimum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMINAH:  // atomic signed minimum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMINALH: // atomic signed minimum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_LDSMINLH:  // atomic signed minimum on halfword in memory        -- not in capstone
        case Kind::ARM64_INS_LDTRH:     // load register halfword unprivileged
        case Kind::ARM64_INS_LDTRSH:    // load register signed halfword unprivileged
        //case Kind::ARM64_INS_LDUMAXH:   // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMAXAH:  // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMAXALH: // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMAXLH:  // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMINH:   // atomic unsigned minimum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMINAH:  // atomic unsigned minimum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMINALH: // atomic unsigned minimum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_LDUMINLH:  // atomic unsigned minimum on halfword in memory      -- not in capstone
        case Kind::ARM64_INS_LDURH:     // load register halfword unscaled
        case Kind::ARM64_INS_LDURSH:    // load register signed halfword unscaled
        case Kind::ARM64_INS_LDXRH:     // load exclusive register halfword
        //case Kind::ARM64_INS_LDADDH:    // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_LDADDLH:   // atomic add on halfword in memory                   -- not in capstone
        //case Kind::ARM64_INS_STCLRH:    // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_STCLRLH:   // atomic bit clear on halfword in memory             -- not in capstone
        //case Kind::ARM64_INS_STEORH:    // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_STEORLH:   // atomic exclusive OR on halfword in memory          -- not in capstone
        //case Kind::ARM64_INS_STLLRH:    // store LORelease register halfword                  -- not in capstone
        case Kind::ARM64_INS_STLRH:     // store-release register halfword
        //case Kind::ARM64_INS_STLURH:    // store-release reigster halfword                    -- not in capstone
        case Kind::ARM64_INS_STLXRH:    // store-release exclusive register halfword
        case Kind::ARM64_INS_STRH:      // store register halfword
        //case Kind::ARM64_INS_STSETH:    // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_STSETLH:   // atomic bit set on halfword in memory               -- not in capstone
        //case Kind::ARM64_INS_STSMAXH:   // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_STSMAXLH:  // atomic signed maximum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_STSMINH:   // atomic signed minimum on halfword in memory        -- not in capstone
        //case Kind::ARM64_INS_STSMINLH:  // atomic signed minimum on halfword in memory        -- not in capstone
        case Kind::ARM64_INS_STTRH:     // store register halfword unprivileged
        //case Kind::ARM64_INS_STUMAXH:   // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_STUMAXLH:  // atomic unsigned maximum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_STUMINH:   // atomic unsigned minimum on halfword in memory      -- not in capstone
        //case Kind::ARM64_INS_STUMINLH:  // atomic unsigned minimum on halfword in memory      -- not in capstone
        case Kind::ARM64_INS_STURH:     // store register halfword unscaled
        case Kind::ARM64_INS_STXRH:     // store exclusive register halfword
            return SageBuilderAsm::buildTypeU(16);

        //--------------------------------------------------------------------------------------------------------
        case Kind::ARM64_INS_LDRSW:     // load register signed word
        //case Kind::ARM64_INS_LDAPURSW:  // load-acquire RCpc register signed word unscaled    -- not in capstone
        case Kind::ARM64_INS_LDTRSW:    // load register signed word unprivileged
        case Kind::ARM64_INS_LDURSW:    // laod register signed word
            return SageBuilderAsm::buildTypeU(32);

        //--------------------------------------------------------------------------------------------------------
        case Kind::ARM64_INS_LDPSW:     // load pair of registers signed word
        //case Kind::ARM64_INS_LDRAA:     // load register with pointer authentication          -- not in capstone
        //case Kind::ARM64_INS_LDRAB:     // load register with pointer authentication          -- not in capstone
            return SageBuilderAsm::buildTypeU(64); // two 32-bit words

        //--------------------------------------------------------------------------------------------------------
        //case Kind::ARM64_INS_LDADD:     // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_LDADDA:    // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_LDADDAL:   // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_LDADDL:    // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_LDALR:     // load LOAcquire register                            -- not in capstone
        //case Kind::ARM64_INS_LDAPR:     // load-acquire RCpc register                         -- not in capstone
        //case Kind::ARM64_INS_LDAPUR:    // load-acquire RCpe register unscaled                -- not in capstone
        case Kind::ARM64_INS_LDAR:      // load-acquire register
        case Kind::ARM64_INS_LDAXR:     // load-acquire exclusive register
        //case Kind::ARM64_INS_LDCLR:     // atomic bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_LDCLRA:    // atomic bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_LDCLRAL:   // atomic bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_LDCLRL:    // atomic bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_LDEOR:     // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDEORA:    // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDEORAL:   // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDEORL:    // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSET:     // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_LDSETA:    // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_LDSETAL:   // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_LDSETL:    // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_LDSMAX:    // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMAXA:   // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMAXAL:  // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMAXL:   // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMIN:    // atomic signed minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMINA:   // atomic signed minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMINAL:  // atomic signed minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDSMINL:   // atomic signed minimum on word or doubleword in memory-- not in capstone
        case Kind::ARM64_INS_LDTR:      // load register unprivileged
        //case Kind::ARM64_INS_LDUMAX:    // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMAXA:   // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMAXAL:  // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMAXL:   // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMIN:    // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMINA:   // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMINAL:  // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_LDUMINL:   // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        case Kind::ARM64_INS_LDXR:      // load exclusive register
        //case Kind::ARM64_INS_STADD:     // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_STADDL:    // atomic add on word or doubleword in memory         -- not in capstone
        //case Kind::ARM64_INS_STCLR:     // atomci bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_STCLRL:    // atomic bit clear on word or doubleword in memory   -- not in capstone
        //case Kind::ARM64_INS_STEOR:     // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STEORL:    // atomic exclusive OR on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STLLR:     // store LORelease register                           -- not in capstone
        case Kind::ARM64_INS_STLR:      // store-release register
        //case Kind::ARM64_INS_STLUR:     // store-release register unscaled                    -- not in capstone
        case Kind::ARM64_INS_STLXR:     // store-release exclusive register
        //case Kind::ARM64_INS_STSET:     // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_STSETL:    // atomic bit set on word or doubleword in memory     -- not in capstone
        //case Kind::ARM64_INS_STSMAX:    // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STSMAXL:   // atomic signed maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STSMIN:    // atomic signed minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STSMINL:   // atomic signed minimum on word or doubleword in memory-- not in capstone
        case Kind::ARM64_INS_STTR:      // store register
        //case Kind::ARM64_INS_STUMAX:    // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STUMAXL:   // atomic unsigned maximum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STUMIN:    // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        //case Kind::ARM64_INS_STUMINL:   // atomic unsigned minimum on word or doubleword in memory-- not in capstone
        case Kind::ARM64_INS_STXR:      // store exclusive register
            return SageBuilderAsm::buildTypeU(bit(code, 30) ? 64 : 32);

        //--------------------------------------------------------------------------------------------------------
        case Kind::ARM64_INS_LD1:       // load (multiple or single) 1-element structures
        case Kind::ARM64_INS_LD1R:      // load one single-element structure and replicate to all lanes
        case Kind::ARM64_INS_LD2:       // load (multiple or single) 2-element structures
        case Kind::ARM64_INS_LD2R:      // load single 2-element structure and replicate to all lanes
        case Kind::ARM64_INS_LD3:       // load (multiple or single) 3-element structures
        case Kind::ARM64_INS_LD3R:      // load single 3-element structure and replicate to all lanes
        case Kind::ARM64_INS_LD4:       // load (multiple or single) 4-element structures
        case Kind::ARM64_INS_LD4R:      // load single 4-element structure and replicate to all lanes
        case Kind::ARM64_INS_LDAXP:     // load-acquire exclusive pair of registers
        case Kind::ARM64_INS_LDXP:      // load exclusive pair of registers
        case Kind::ARM64_INS_ST1:       // store (multiple or single) 1-element structures
        case Kind::ARM64_INS_ST2:       // store (multiple or single) 2-element structures
        case Kind::ARM64_INS_ST3:       // store (multiple or single) 3-element structures
        case Kind::ARM64_INS_ST4:       // store (multiple or single) 4-element structures
        case Kind::ARM64_INS_STLXP:    // store-release exclusive pair of registers
        case Kind::ARM64_INS_STXP:      // store exclusive pair of registers
            return SageBuilderAsm::buildTypeU(bit(code, 30) ? 128 : 64);

        //--------------------------------------------------------------------------------------------------------
        case Kind::ARM64_INS_LDNP:      // load pair of registers with non-temporal hint
        case Kind::ARM64_INS_LDP:       // load pair of registers
        case Kind::ARM64_INS_STNP:      // store pair of registers with non-temporal hint
        case Kind::ARM64_INS_STP: {     // store pair of registers
            if (bits(code, 22, 29) == 0b10110001 || // LDNP (SIMD&FP)
                bits(code, 22, 29) == 0b10110011 || // LDP (SIMD&FP) Post-index
                bits(code, 22, 29) == 0b10110111 || // LDP (SIMD&FP) Pre-index
                bits(code, 22, 29) == 0b10110101 || // LDP (SIMD&FP) Signed offset
                bits(code, 22, 29) == 0b10110000 || // STNP (SIMD&FP)
                bits(code, 22, 29) == 0b10110010 || // STP (SIMD&FP) Post-index
                bits(code, 22, 29) == 0b10110110 || // STP (SIMD&FP) Pre-index
                bits(code, 22, 29) == 0b10110100) { // STP (SIMD&FP) Signed offset
                uint32_t opc = bits(code, 30, 31);
                // Memory access is twice as wide as the registers because we're loading or storing two registers.
                return SageBuilderAsm::buildTypeU(8 << (3 + opc));
            } else if (bits(code, 22, 30) == 0b010100001 || // LDNP
                       bits(code, 22, 30) == 0b010100011 || // LDP Post-index
                       bits(code, 22, 30) == 0b010100111 || // LDP Pre-index
                       bits(code, 22, 30) == 0b010100101 || // LDP Signed offset
                       bits(code, 22, 30) == 0b010100000 || // STNP
                       bits(code, 22, 30) == 0b010100010 || // STP Post-index
                       bits(code, 22, 30) == 0b010100110 || // STP Pre-index
                       bits(code, 22, 30) == 0b010100100) { // STP Signed offset
                // Memory access is twice as wide as the registers because we're loading or storing two registers.
                return SageBuilderAsm::buildTypeU(bit(code, 31) ? 128 : 64);
            } else {
                ASSERT_not_reachable("invalid opcode");
            }
        }

        //--------------------------------------------------------------------------------------------------------
        case Kind::ARM64_INS_LDR:       // load register
        case Kind::ARM64_INS_LDUR:      // load register unscaled
        case Kind::ARM64_INS_STR:       // store register
        case Kind::ARM64_INS_STUR: {    // store register unscaled offset
            if ((bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b10 && bits(code, 10, 11) == 0b01) || // LDR (immediate, SIMD&FP) Post-index
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b10 && bits(code, 10, 11) == 0b11) || // LDR (immediate, SIMD&FP) Pre-index
                (bits(code, 24, 29) == 0b111101 && bit(code, 22)) || // LDR (immediate, SIMD&FP) Unsigned offset
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b11 && bits(code, 10, 11) == 0b10) || // LDR (register, SIMD&FP)
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b10 && bits(code, 10, 11) == 0b00) || // LDUR (SIMD&FP)
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b00 && bits(code, 10, 11) == 0b01) || // STR (immediate, SIMD&FP) Post-index
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b00 && bits(code, 10, 11) == 0b11) || // STR (immediate, SIMD&FP) Pre-index
                (bits(code, 24, 29) == 0b111101 && !bit(code, 22)) || // STR (immediate, SIMD&FP) Unsigned offset
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b01 && bits(code, 10, 11) == 0b10) || // STR (register, SIMD&FP)
                (bits(code, 24, 29) == 0b111100 && bits(code, 21, 22) == 0b00 && bits(code, 10, 11) == 0b00)) { // STUR (SIMD&FP)
                if (bits(code, 30, 31) == 0b00 && !bit(code, 23)) {
                    return SageBuilderAsm::buildTypeU(8);
                } else if (bits(code, 30, 31) == 0b01 && !bit(code, 23)) {
                    return SageBuilderAsm::buildTypeU(16);
                } else if (bits(code, 30, 31) == 0b10 && !bit(code, 23)) {
                    return SageBuilderAsm::buildTypeU(32);
                } else if (bits(code, 30, 31) == 0b11 && !bit(code, 23)) {
                    return SageBuilderAsm::buildTypeU(64);
                } else {
                    ASSERT_require(bits(code, 30, 31) == 0b00);
                    ASSERT_require(bit(code, 23));
                    return SageBuilderAsm::buildTypeU(128);
                }
            } else if (( bit(code, 31) && bits(code, 21, 29) == 0b111000010 && bits(code, 10, 11) == 0b01) || // LDR (immediate) Post-index
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000010 && bits(code, 10, 11) == 0b11) || // LDR (immediate) Pre-index
                       ( bit(code, 31) && bits(code, 22, 29) == 0b11100101) || // LDR (immediate) unsigned offset
                       (!bit(code, 31) && bits(code, 24, 29) == 0b011000) || // LDR (literal)
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000011 && bits(code, 10, 11) == 0b10) || // LDR (register)
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000010 && bits(code, 10, 11) == 0b00) || // LDUR
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000000 && bits(code, 10, 11) == 0b01) || // STR (immediate) Post-index
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000000 && bits(code, 10, 11) == 0b11) || // STR (immediate) Pre-index
                       ( bit(code, 31) && bits(code, 22, 29) == 0b11100100) || // STR (immediate) unsigned offset
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000001 && bits(code, 10, 11) == 0b10) || // STR (register)
                       ( bit(code, 31) && bits(code, 21, 29) == 0b111000000 && bits(code, 10, 11) == 0b00)) { // STUR
                if (bit(code, 30) == 0) {
                    return SageBuilderAsm::buildTypeU(32);
                } else {
                    return SageBuilderAsm::buildTypeU(64);
                }
            } else if (bits(code, 24, 29) == 0b011100) { // LDR (literal, SIMD&FP)
                if (bits(code, 30, 31) == 0b00) {
                    return SageBuilderAsm::buildTypeU(32);
                } else if (bits(code, 30, 31) == 0b01) {
                    return SageBuilderAsm::buildTypeU(64);
                } else {
                    ASSERT_require(bits(code, 30, 31) == 0b10);
                    return SageBuilderAsm::buildTypeU(128);
                }
            } else {
                ASSERT_not_reachable("invalid opcode");
            }
            break;
        }

        //--------------------------------------------------------------------------------------------------------
        default:
            ASSERT_not_reachable("memory read instruction not handled");
    }
}

SgAsmType*
Aarch64::registerType(RegisterDescriptor reg, arm64_vas arrangement) {
    SgAsmType *type = nullptr;
    switch (arrangement) {
        case ARM64_VAS_INVALID:
            type = SageBuilderAsm::buildTypeU(reg.nBits());
            break;
        case ARM64_VAS_8B:
            type = SageBuilderAsm::buildTypeVector(8, SageBuilderAsm::buildTypeU8());
            break;
        case ARM64_VAS_16B:
            type = SageBuilderAsm::buildTypeVector(16, SageBuilderAsm::buildTypeU8());
            break;
        case ARM64_VAS_4H:
            type = SageBuilderAsm::buildTypeVector(4, SageBuilderAsm::buildTypeU16());
            break;
        case ARM64_VAS_8H:
            type = SageBuilderAsm::buildTypeVector(8, SageBuilderAsm::buildTypeU16());
            break;
        case ARM64_VAS_2S:
            type = SageBuilderAsm::buildTypeVector(2, SageBuilderAsm::buildTypeU32());
            break;
        case ARM64_VAS_4S:
            type = SageBuilderAsm::buildTypeVector(4, SageBuilderAsm::buildTypeU32());
            break;
        case ARM64_VAS_1D:
            type = SageBuilderAsm::buildTypeU(64);
            break;
        case ARM64_VAS_2D:
            type = SageBuilderAsm::buildTypeVector(2, SageBuilderAsm::buildTypeU64());
            break;
        case ARM64_VAS_1Q:
            type = SageBuilderAsm::buildTypeU(128);
            break;
    }
    ASSERT_not_null(type);
    return type;
}

RegisterDescriptor
Aarch64::makeRegister(arm64_reg reg) {
    RegisterDictionary::Ptr dict = architecture()->registerDictionary();
    RegisterDescriptor retval;

    switch (reg) {
        case ARM64_REG_INVALID:
        case ARM64_REG_ENDING:
            ASSERT_not_reachable("invalid register from Capstone");
        case ARM64_REG_X29:
            retval = dict->find("x29");
            break;
        case ARM64_REG_X30:
            retval = dict->find("x30");
            break;
        case ARM64_REG_NZCV:
            retval = dict->find("nzcv");
            break;
        case ARM64_REG_SP:
            retval = dict->find("sp");
            break;
        case ARM64_REG_WSP:
            retval = dict->find("wsp");
            break;
        case ARM64_REG_WZR:
            retval = dict->find("wzr");
            break;
        case ARM64_REG_XZR:
            retval = dict->find("xzr");
            break;
        case ARM64_REG_B0:
            retval = dict->find("b0");
            break;
        case ARM64_REG_B1:
            retval = dict->find("b1");
            break;
        case ARM64_REG_B2:
            retval = dict->find("b2");
            break;
        case ARM64_REG_B3:
            retval = dict->find("b3");
            break;
        case ARM64_REG_B4:
            retval = dict->find("b4");
            break;
        case ARM64_REG_B5:
            retval = dict->find("b5");
            break;
        case ARM64_REG_B6:
            retval = dict->find("b6");
            break;
        case ARM64_REG_B7:
            retval = dict->find("b7");
            break;
        case ARM64_REG_B8:
            retval = dict->find("b8");
            break;
        case ARM64_REG_B9:
            retval = dict->find("b9");
            break;
        case ARM64_REG_B10:
            retval = dict->find("b10");
            break;
        case ARM64_REG_B11:
            retval = dict->find("b11");
            break;
        case ARM64_REG_B12:
            retval = dict->find("b12");
            break;
        case ARM64_REG_B13:
            retval = dict->find("b13");
            break;
        case ARM64_REG_B14:
            retval = dict->find("b14");
            break;
        case ARM64_REG_B15:
            retval = dict->find("b15");
            break;
        case ARM64_REG_B16:
            retval = dict->find("b16");
            break;
        case ARM64_REG_B17:
            retval = dict->find("b17");
            break;
        case ARM64_REG_B18:
            retval = dict->find("b18");
            break;
        case ARM64_REG_B19:
            retval = dict->find("b19");
            break;
        case ARM64_REG_B20:
            retval = dict->find("b20");
            break;
        case ARM64_REG_B21:
            retval = dict->find("b21");
            break;
        case ARM64_REG_B22:
            retval = dict->find("b22");
            break;
        case ARM64_REG_B23:
            retval = dict->find("b23");
            break;
        case ARM64_REG_B24:
            retval = dict->find("b24");
            break;
        case ARM64_REG_B25:
            retval = dict->find("b25");
            break;
        case ARM64_REG_B26:
            retval = dict->find("b26");
            break;
        case ARM64_REG_B27:
            retval = dict->find("b27");
            break;
        case ARM64_REG_B28:
            retval = dict->find("b28");
            break;
        case ARM64_REG_B29:
            retval = dict->find("b29");
            break;
        case ARM64_REG_B30:
            retval = dict->find("b30");
            break;
        case ARM64_REG_B31:
            retval = dict->find("b31");
            break;
        case ARM64_REG_D0:
            retval = dict->find("d0");
            break;
        case ARM64_REG_D1:
            retval = dict->find("d1");
            break;
        case ARM64_REG_D2:
            retval = dict->find("d2");
            break;
        case ARM64_REG_D3:
            retval = dict->find("d3");
            break;
        case ARM64_REG_D4:
            retval = dict->find("d4");
            break;
        case ARM64_REG_D5:
            retval = dict->find("d5");
            break;
        case ARM64_REG_D6:
            retval = dict->find("d6");
            break;
        case ARM64_REG_D7:
            retval = dict->find("d7");
            break;
        case ARM64_REG_D8:
            retval = dict->find("d8");
            break;
        case ARM64_REG_D9:
            retval = dict->find("d9");
            break;
        case ARM64_REG_D10:
            retval = dict->find("d10");
            break;
        case ARM64_REG_D11:
            retval = dict->find("d11");
            break;
        case ARM64_REG_D12:
            retval = dict->find("d12");
            break;
        case ARM64_REG_D13:
            retval = dict->find("d13");
            break;
        case ARM64_REG_D14:
            retval = dict->find("d14");
            break;
        case ARM64_REG_D15:
            retval = dict->find("d15");
            break;
        case ARM64_REG_D16:
            retval = dict->find("d16");
            break;
        case ARM64_REG_D17:
            retval = dict->find("d17");
            break;
        case ARM64_REG_D18:
            retval = dict->find("d18");
            break;
        case ARM64_REG_D19:
            retval = dict->find("d19");
            break;
        case ARM64_REG_D20:
            retval = dict->find("d20");
            break;
        case ARM64_REG_D21:
            retval = dict->find("d21");
            break;
        case ARM64_REG_D22:
            retval = dict->find("d22");
            break;
        case ARM64_REG_D23:
            retval = dict->find("d23");
            break;
        case ARM64_REG_D24:
            retval = dict->find("d24");
            break;
        case ARM64_REG_D25:
            retval = dict->find("d25");
            break;
        case ARM64_REG_D26:
            retval = dict->find("d26");
            break;
        case ARM64_REG_D27:
            retval = dict->find("d27");
            break;
        case ARM64_REG_D28:
            retval = dict->find("d28");
            break;
        case ARM64_REG_D29:
            retval = dict->find("d29");
            break;
        case ARM64_REG_D30:
            retval = dict->find("d30");
            break;
        case ARM64_REG_D31:
            retval = dict->find("d31");
            break;
        case ARM64_REG_H0:
            retval = dict->find("h0");
            break;
        case ARM64_REG_H1:
            retval = dict->find("h1");
            break;
        case ARM64_REG_H2:
            retval = dict->find("h2");
            break;
        case ARM64_REG_H3:
            retval = dict->find("h3");
            break;
        case ARM64_REG_H4:
            retval = dict->find("h4");
            break;
        case ARM64_REG_H5:
            retval = dict->find("h5");
            break;
        case ARM64_REG_H6:
            retval = dict->find("h6");
            break;
        case ARM64_REG_H7:
            retval = dict->find("h7");
            break;
        case ARM64_REG_H8:
            retval = dict->find("h8");
            break;
        case ARM64_REG_H9:
            retval = dict->find("h9");
            break;
        case ARM64_REG_H10:
            retval = dict->find("h10");
            break;
        case ARM64_REG_H11:
            retval = dict->find("h11");
            break;
        case ARM64_REG_H12:
            retval = dict->find("h12");
            break;
        case ARM64_REG_H13:
            retval = dict->find("h13");
            break;
        case ARM64_REG_H14:
            retval = dict->find("h14");
            break;
        case ARM64_REG_H15:
            retval = dict->find("h15");
            break;
        case ARM64_REG_H16:
            retval = dict->find("h16");
            break;
        case ARM64_REG_H17:
            retval = dict->find("h17");
            break;
        case ARM64_REG_H18:
            retval = dict->find("h18");
            break;
        case ARM64_REG_H19:
            retval = dict->find("h19");
            break;
        case ARM64_REG_H20:
            retval = dict->find("h20");
            break;
        case ARM64_REG_H21:
            retval = dict->find("h21");
            break;
        case ARM64_REG_H22:
            retval = dict->find("h22");
            break;
        case ARM64_REG_H23:
            retval = dict->find("h23");
            break;
        case ARM64_REG_H24:
            retval = dict->find("h24");
            break;
        case ARM64_REG_H25:
            retval = dict->find("h25");
            break;
        case ARM64_REG_H26:
            retval = dict->find("h26");
            break;
        case ARM64_REG_H27:
            retval = dict->find("h27");
            break;
        case ARM64_REG_H28:
            retval = dict->find("h28");
            break;
        case ARM64_REG_H29:
            retval = dict->find("h29");
            break;
        case ARM64_REG_H30:
            retval = dict->find("h30");
            break;
        case ARM64_REG_H31:
            retval = dict->find("h31");
            break;
        case ARM64_REG_Q0:
            retval = dict->find("q0");
            break;
        case ARM64_REG_Q1:
            retval = dict->find("q1");
            break;
        case ARM64_REG_Q2:
            retval = dict->find("q2");
            break;
        case ARM64_REG_Q3:
            retval = dict->find("q3");
            break;
        case ARM64_REG_Q4:
            retval = dict->find("q4");
            break;
        case ARM64_REG_Q5:
            retval = dict->find("q5");
            break;
        case ARM64_REG_Q6:
            retval = dict->find("q6");
            break;
        case ARM64_REG_Q7:
            retval = dict->find("q7");
            break;
        case ARM64_REG_Q8:
            retval = dict->find("q8");
            break;
        case ARM64_REG_Q9:
            retval = dict->find("q9");
            break;
        case ARM64_REG_Q10:
            retval = dict->find("q10");
            break;
        case ARM64_REG_Q11:
            retval = dict->find("q11");
            break;
        case ARM64_REG_Q12:
            retval = dict->find("q12");
            break;
        case ARM64_REG_Q13:
            retval = dict->find("q13");
            break;
        case ARM64_REG_Q14:
            retval = dict->find("q14");
            break;
        case ARM64_REG_Q15:
            retval = dict->find("q15");
            break;
        case ARM64_REG_Q16:
            retval = dict->find("q16");
            break;
        case ARM64_REG_Q17:
            retval = dict->find("q17");
            break;
        case ARM64_REG_Q18:
            retval = dict->find("q18");
            break;
        case ARM64_REG_Q19:
            retval = dict->find("q19");
            break;
        case ARM64_REG_Q20:
            retval = dict->find("q20");
            break;
        case ARM64_REG_Q21:
            retval = dict->find("q21");
            break;
        case ARM64_REG_Q22:
            retval = dict->find("q22");
            break;
        case ARM64_REG_Q23:
            retval = dict->find("q23");
            break;
        case ARM64_REG_Q24:
            retval = dict->find("q24");
            break;
        case ARM64_REG_Q25:
            retval = dict->find("q25");
            break;
        case ARM64_REG_Q26:
            retval = dict->find("q26");
            break;
        case ARM64_REG_Q27:
            retval = dict->find("q27");
            break;
        case ARM64_REG_Q28:
            retval = dict->find("q28");
            break;
        case ARM64_REG_Q29:
            retval = dict->find("q29");
            break;
        case ARM64_REG_Q30:
            retval = dict->find("q30");
            break;
        case ARM64_REG_Q31:
            retval = dict->find("q31");
            break;
        case ARM64_REG_S0:
            retval = dict->find("s0");
            break;
        case ARM64_REG_S1:
            retval = dict->find("s1");
            break;
        case ARM64_REG_S2:
            retval = dict->find("s2");
            break;
        case ARM64_REG_S3:
            retval = dict->find("s3");
            break;
        case ARM64_REG_S4:
            retval = dict->find("s4");
            break;
        case ARM64_REG_S5:
            retval = dict->find("s5");
            break;
        case ARM64_REG_S6:
            retval = dict->find("s6");
            break;
        case ARM64_REG_S7:
            retval = dict->find("s7");
            break;
        case ARM64_REG_S8:
            retval = dict->find("s8");
            break;
        case ARM64_REG_S9:
            retval = dict->find("s9");
            break;
        case ARM64_REG_S10:
            retval = dict->find("s10");
            break;
        case ARM64_REG_S11:
            retval = dict->find("s11");
            break;
        case ARM64_REG_S12:
            retval = dict->find("s12");
            break;
        case ARM64_REG_S13:
            retval = dict->find("s13");
            break;
        case ARM64_REG_S14:
            retval = dict->find("s14");
            break;
        case ARM64_REG_S15:
            retval = dict->find("s15");
            break;
        case ARM64_REG_S16:
            retval = dict->find("s16");
            break;
        case ARM64_REG_S17:
            retval = dict->find("s17");
            break;
        case ARM64_REG_S18:
            retval = dict->find("s18");
            break;
        case ARM64_REG_S19:
            retval = dict->find("s19");
            break;
        case ARM64_REG_S20:
            retval = dict->find("s20");
            break;
        case ARM64_REG_S21:
            retval = dict->find("s21");
            break;
        case ARM64_REG_S22:
            retval = dict->find("s22");
            break;
        case ARM64_REG_S23:
            retval = dict->find("s23");
            break;
        case ARM64_REG_S24:
            retval = dict->find("s24");
            break;
        case ARM64_REG_S25:
            retval = dict->find("s25");
            break;
        case ARM64_REG_S26:
            retval = dict->find("s26");
            break;
        case ARM64_REG_S27:
            retval = dict->find("s27");
            break;
        case ARM64_REG_S28:
            retval = dict->find("s28");
            break;
        case ARM64_REG_S29:
            retval = dict->find("s29");
            break;
        case ARM64_REG_S30:
            retval = dict->find("s30");
            break;
        case ARM64_REG_S31:
            retval = dict->find("s31");
            break;
        case ARM64_REG_W0:
            retval = dict->find("w0");
            break;
        case ARM64_REG_W1:
            retval = dict->find("w1");
            break;
        case ARM64_REG_W2:
            retval = dict->find("w2");
            break;
        case ARM64_REG_W3:
            retval = dict->find("w3");
            break;
        case ARM64_REG_W4:
            retval = dict->find("w4");
            break;
        case ARM64_REG_W5:
            retval = dict->find("w5");
            break;
        case ARM64_REG_W6:
            retval = dict->find("w6");
            break;
        case ARM64_REG_W7:
            retval = dict->find("w7");
            break;
        case ARM64_REG_W8:
            retval = dict->find("w8");
            break;
        case ARM64_REG_W9:
            retval = dict->find("w9");
            break;
        case ARM64_REG_W10:
            retval = dict->find("w10");
            break;
        case ARM64_REG_W11:
            retval = dict->find("w11");
            break;
        case ARM64_REG_W12:
            retval = dict->find("w12");
            break;
        case ARM64_REG_W13:
            retval = dict->find("w13");
            break;
        case ARM64_REG_W14:
            retval = dict->find("w14");
            break;
        case ARM64_REG_W15:
            retval = dict->find("w15");
            break;
        case ARM64_REG_W16:
            retval = dict->find("w16");
            break;
        case ARM64_REG_W17:
            retval = dict->find("w17");
            break;
        case ARM64_REG_W18:
            retval = dict->find("w18");
            break;
        case ARM64_REG_W19:
            retval = dict->find("w19");
            break;
        case ARM64_REG_W20:
            retval = dict->find("w20");
            break;
        case ARM64_REG_W21:
            retval = dict->find("w21");
            break;
        case ARM64_REG_W22:
            retval = dict->find("w22");
            break;
        case ARM64_REG_W23:
            retval = dict->find("w23");
            break;
        case ARM64_REG_W24:
            retval = dict->find("w24");
            break;
        case ARM64_REG_W25:
            retval = dict->find("w25");
            break;
        case ARM64_REG_W26:
            retval = dict->find("w26");
            break;
        case ARM64_REG_W27:
            retval = dict->find("w27");
            break;
        case ARM64_REG_W28:
            retval = dict->find("w28");
            break;
        case ARM64_REG_W29:
            retval = dict->find("w29");
            break;
        case ARM64_REG_W30:
            retval = dict->find("w30");
            break;
        case ARM64_REG_X0:
            retval = dict->find("x0");
            break;
        case ARM64_REG_X1:
            retval = dict->find("x1");
            break;
        case ARM64_REG_X2:
            retval = dict->find("x2");
            break;
        case ARM64_REG_X3:
            retval = dict->find("x3");
            break;
        case ARM64_REG_X4:
            retval = dict->find("x4");
            break;
        case ARM64_REG_X5:
            retval = dict->find("x5");
            break;
        case ARM64_REG_X6:
            retval = dict->find("x6");
            break;
        case ARM64_REG_X7:
            retval = dict->find("x7");
            break;
        case ARM64_REG_X8:
            retval = dict->find("x8");
            break;
        case ARM64_REG_X9:
            retval = dict->find("x9");
            break;
        case ARM64_REG_X10:
            retval = dict->find("x10");
            break;
        case ARM64_REG_X11:
            retval = dict->find("x11");
            break;
        case ARM64_REG_X12:
            retval = dict->find("x12");
            break;
        case ARM64_REG_X13:
            retval = dict->find("x13");
            break;
        case ARM64_REG_X14:
            retval = dict->find("x14");
            break;
        case ARM64_REG_X15:
            retval = dict->find("x15");
            break;
        case ARM64_REG_X16:
            retval = dict->find("x16");
            break;
        case ARM64_REG_X17:
            retval = dict->find("x17");
            break;
        case ARM64_REG_X18:
            retval = dict->find("x18");
            break;
        case ARM64_REG_X19:
            retval = dict->find("x19");
            break;
        case ARM64_REG_X20:
            retval = dict->find("x20");
            break;
        case ARM64_REG_X21:
            retval = dict->find("x21");
            break;
        case ARM64_REG_X22:
            retval = dict->find("x22");
            break;
        case ARM64_REG_X23:
            retval = dict->find("x23");
            break;
        case ARM64_REG_X24:
            retval = dict->find("x24");
            break;
        case ARM64_REG_X25:
            retval = dict->find("x25");
            break;
        case ARM64_REG_X26:
            retval = dict->find("x26");
            break;
        case ARM64_REG_X27:
            retval = dict->find("x27");
            break;
        case ARM64_REG_X28:
            retval = dict->find("x28");
            break;
        case ARM64_REG_V0:
            retval = dict->find("v0");
            break;
        case ARM64_REG_V1:
            retval = dict->find("v1");
            break;
        case ARM64_REG_V2:
            retval = dict->find("v2");
            break;
        case ARM64_REG_V3:
            retval = dict->find("v3");
            break;
        case ARM64_REG_V4:
            retval = dict->find("v4");
            break;
        case ARM64_REG_V5:
            retval = dict->find("v5");
            break;
        case ARM64_REG_V6:
            retval = dict->find("v6");
            break;
        case ARM64_REG_V7:
            retval = dict->find("v7");
            break;
        case ARM64_REG_V8:
            retval = dict->find("v8");
            break;
        case ARM64_REG_V9:
            retval = dict->find("v9");
            break;
        case ARM64_REG_V10:
            retval = dict->find("v10");
            break;
        case ARM64_REG_V11:
            retval = dict->find("v11");
            break;
        case ARM64_REG_V12:
            retval = dict->find("v12");
            break;
        case ARM64_REG_V13:
            retval = dict->find("v13");
            break;
        case ARM64_REG_V14:
            retval = dict->find("v14");
            break;
        case ARM64_REG_V15:
            retval = dict->find("v15");
            break;
        case ARM64_REG_V16:
            retval = dict->find("v16");
            break;
        case ARM64_REG_V17:
            retval = dict->find("v17");
            break;
        case ARM64_REG_V18:
            retval = dict->find("v18");
            break;
        case ARM64_REG_V19:
            retval = dict->find("v19");
            break;
        case ARM64_REG_V20:
            retval = dict->find("v20");
            break;
        case ARM64_REG_V21:
            retval = dict->find("v21");
            break;
        case ARM64_REG_V22:
            retval = dict->find("v22");
            break;
        case ARM64_REG_V23:
            retval = dict->find("v23");
            break;
        case ARM64_REG_V24:
            retval = dict->find("v24");
            break;
        case ARM64_REG_V25:
            retval = dict->find("v25");
            break;
        case ARM64_REG_V26:
            retval = dict->find("v26");
            break;
        case ARM64_REG_V27:
            retval = dict->find("v27");
            break;
        case ARM64_REG_V28:
            retval = dict->find("v28");
            break;
        case ARM64_REG_V29:
            retval = dict->find("v29");
            break;
        case ARM64_REG_V30:
            retval = dict->find("v30");
            break;
        case ARM64_REG_V31:
            retval = dict->find("v31");
            break;
    }
    ASSERT_require(retval);
    return retval;
}

} // namespace
} // namespace
} // namespace

#endif
