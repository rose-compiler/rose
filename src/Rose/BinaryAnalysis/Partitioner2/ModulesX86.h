#ifndef ROSE_BinaryAnalysis_Partitioner2_ModulesX86_H
#define ROSE_BinaryAnalysis_Partitioner2_ModulesX86_H
#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <Rose/BinaryAnalysis/Partitioner2/BasicTypes.h>

#include <Rose/BinaryAnalysis/Partitioner2/JumpTable.h>
#include <Rose/BinaryAnalysis/Partitioner2/Modules.h>

namespace Rose {
namespace BinaryAnalysis {
namespace Partitioner2 {

/** Disassembly and partitioning utilities for Intel x86 and amd64. */
namespace ModulesX86 {

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Classes for matching function prologues
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Matches an x86 function prologue.
 *
 *  The standard x86 function prologue is:
 *
 * @code
 *  push ebp
 *  mov ebp, esp
 * @endcode
 *
 *  The width of ebp and esp must match the word size for the architecture (i.e., they must be EBP and ESP for the i386 family,
 *  and RBP, RSP for the amd64 family). */
class MatchStandardPrologue: public FunctionPrologueMatcher {
protected:
    FunctionPtr function_;
protected:
    MatchStandardPrologue();
public:
    ~MatchStandardPrologue();

public:
    static Ptr instance();                              /**< Allocating constructor. */
    virtual std::vector<FunctionPtr> functions() const override;
    virtual bool match(const PartitionerConstPtr&, Address anchor) override;
};

/** Matches an x86 function prologue with hot patch.
 *
 *  A hot-patch prologue is a MOV EDI, EDI instruction followed by a standard prologue. These are generated by Microsoft
 *  compilers.
 *
 *  @todo: FIXME[Robb P. Matzke 2014-08-24]: this function should also check for and attach the bytes prior to the MOV EDI,
 *  EDI. We should also have a version that matches after a patch is activated in case we're disassembling the memory of a
 *  process. */
class MatchHotPatchPrologue: public MatchStandardPrologue {
public:
    static Ptr instance() { return Ptr(new MatchHotPatchPrologue); } /**< Allocating constructor. */
    virtual std::vector<FunctionPtr> functions() const override { return std::vector<FunctionPtr>(1, function_); }
    virtual bool match(const PartitionerConstPtr&, Address anchor) override;
};

/** Matches an x86 `MOV EDI,EDI; PUSH ESI` function prologe. */
class MatchAbbreviatedPrologue: public FunctionPrologueMatcher {
protected:
    FunctionPtr function_;
protected:
    MatchAbbreviatedPrologue();
public:
    ~MatchAbbreviatedPrologue();

public:
    static Ptr instance();                              /**< Allocating constructor. */
    virtual std::vector<FunctionPtr> functions() const override;
    virtual bool match(const PartitionerConstPtr&, Address anchor) override;
};

/** Matches an x86 "ENTER xxx, 0" prologue. */
class MatchEnterPrologue: public FunctionPrologueMatcher {
protected:
    FunctionPtr function_;
public:
    static Ptr instance() { return Ptr(new MatchEnterPrologue); } /**< Allocating constructor. */
    virtual std::vector<FunctionPtr> functions() const override { return std::vector<FunctionPtr>(1, function_); }
    virtual bool match(const PartitionerConstPtr&, Address anchor) override;
};

/** Match RET followed by PUSH with intervening no-op padding. */
class MatchRetPadPush: public FunctionPrologueMatcher {
protected:
    FunctionPtr function_;
public:
    static Ptr instance() { return Ptr(new MatchRetPadPush); } /**< Allocating constructor. */
    virtual std::vector<FunctionPtr> functions() const override { return std::vector<FunctionPtr>(1, function_); }
    virtual bool match(const PartitionerConstPtr&, Address anchor) override;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FunctionReturnDetector for CFG edges at a function return
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Basic block callback to detect function returns.
 *
 *  The architecture agnostic isFunctionReturn test for basic blocks does not detect x86 "RET N" (N!=0) instructions as
 *  returning from a function because such instructions have side effects that apply after the return-to address is popped from
 *  the stack.  Therefore this basic block callback looks for such instructions and sets the isFunctionReturn property for the
 *  basic block. */
class FunctionReturnDetector: public BasicBlockCallback {
public:
    static Ptr instance() { return Ptr(new FunctionReturnDetector); } /**< Allocating constructor. */
    virtual bool operator()(bool chain, const Args&) override;
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SwitchSuccessors for CFG edges from a C `switch` statement or similar
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Basic block callback to detect "switch" statements.
 *
 *  Examines the instructions of a basic block to determine if they are from a C "switch"-like statement and attempts to find the
 *  "case" labels, adding them as successors to this basic block.
 *
 *  Since this is called during partitioning, we don't have a full CFG or even full basic blocks. Therefore, the analysis it
 *  performs is restricted to the current (partial) basic block. */
class SwitchSuccessors: public BasicBlockCallback {
public:
private:
    // These get filled in during the pattern matching phase when we're looking at the content of the basic block in question to try
    // to figure out if it has a jump table and if so, some characteristics of that table. */
    std::string matcherName_;                           // pattern matcher that matched
    Sawyer::Optional<Address> tableVa_;                 // possible address for jump table
    JumpTable::EntryType entryType_ = JumpTable::EntryType::ABSOLUTE;
    size_t entrySizeBytes_ = 4;                         // size of each table entry
    Address entryOffset_ = 0;                           // value added to every table entry

    // These members are initialized after the jump table is loaded and are used to update the successors and attach basic blocks.
    JumpTable::Ptr mainTable_;
    std::vector<uint8_t> indexes_;                      // indexes into the main table immediately following the main table

public:
    ~SwitchSuccessors();
    SwitchSuccessors();
    static Ptr instance(); /**< Allocating constructor. */
    virtual bool operator()(bool chain, const Args&) override;


    // Adjust successors and for the basic block, create a data block, and add everything to the partitioner.
    void addToPartitioner(const Args&, const std::set<Address> &successors) const;

private:
    // Pattern matchers that look at
    bool matchPattern1(SgAsmExpression *jmpArg);
    bool matchPattern2(const BasicBlockPtr&, SgAsmInstruction *jmp);
    bool matchPattern3(const PartitionerConstPtr&, const BasicBlockPtr&, SgAsmInstruction *jmp);
    bool matchPattern4(const PartitionerConstPtr&, const BasicBlockPtr&);
    bool matchPattern5(const PartitionerConstPtr&, const BasicBlockPtr&);
    bool matchPatterns(const PartitionerConstPtr&, const BasicBlockPtr&);

    // Try to parse the jump table. If successful, create a `table` in this object.
    void parseJumpTable(const Args&);
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Supporting functions used by this module
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** Matches "ENTER x, 0" */
bool matchEnterAnyZero(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "JMP constant".
 *
 *  Returns the constant if matched, nothing otherwise. */
Sawyer::Optional<Address> matchJmpConst(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "LEA ECX, [EBP + constant]" or variant. */
bool matchLeaCxMemBpConst(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "JMP [address]" or variant. */
bool matchJmpMem(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "MOV EBP, ESP" or variant. */
bool matchMovBpSp(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "MOV EDI, EDI" or variant. */
bool matchMovDiDi(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "PUSH EBP" or variant. */
bool matchPushBp(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Matches "PUSH SI" or variant. */
bool matchPushSi(const PartitionerConstPtr&, SgAsmX86Instruction*);

/** Try to match a base+offset expression.
 *
 *  Matches expressions like:
 *
 * @li base + register
 * @li base + register * size
 * @li [ base + register ]
 * @li [ base + register * size ]
 *
 * Returns the numeric value of @c base or nothing if the expression is not a recognized form. */
Sawyer::Optional<Address> findTableBase(SgAsmExpression*);


} // namespace
} // namespace
} // namespace
} // namespace

#endif
#endif
