#ifndef ROSE_BinaryAnalysis_Partitioner2_BasicTypes_H
#define ROSE_BinaryAnalysis_Partitioner2_BasicTypes_H
#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS

#include <Rose/BinaryAnalysis/AddressInterval.h>

#include <boost/filesystem.hpp>
#include <boost/regex.hpp>
#include <boost/serialization/access.hpp>
#include <boost/serialization/nvp.hpp>
#include <boost/serialization/version.hpp>
#include <Sawyer/Graph.h>
#include <Sawyer/Map.h>
#include <Sawyer/Set.h>
#include <set>
#include <string>
#include <vector>

// Define this as one if you want extra invariant checks that are quite expensive, or define as zero. This only makes a
// difference if NDEBUG and SAWYER_NDEBUG are both undefined--if either one of them are defined then no expensive (or
// inexpensive) checks are performed.
#define ROSE_PARTITIONER_EXPENSIVE_CHECKS 0

namespace Rose {
namespace BinaryAnalysis {
namespace Partitioner2 {

/** Level of precision for analysis. */
namespace Precision {
enum Level {                                            /**< Enum type for precision. */
    LOW,                                                /**< Low precision, but fast. This usually works reasonably well for
                                                         *   code generated by mainstream compilers. */
    HIGH                                                /**< High precision, but slow. This usually works better for
                                                         *   hand-written or obfuscated code. */
};
} // namespace

/** Flag whether to allow parallel edges in a graph. */
namespace AllowParallelEdges {
enum Type {                                             /**< Enum type for allowing parallel edges. */
    NO,                                                 /**< Don't allow parallel edges; use counts instead. */
    YES                                                 /**< Allow parallel edges, so each edge has a unit count. */
};
} // namespace

/** Partitioner control flow vertex types. */
enum VertexType {
    V_BASIC_BLOCK,                                      /**< A basic block or placeholder for a basic block. */
    V_UNDISCOVERED,                                     /**< The special "undiscovered" vertex. */
    V_INDETERMINATE,                                    /**< Special vertex destination for indeterminate edges. */
    V_NONEXISTING,                                      /**< Special vertex destination for non-existing basic blocks. */
    V_USER_DEFINED,                                     /**< User defined vertex. These vertices don't normally appear in the
                                                         *   global control flow graph but might appear in other kinds of
                                                         *   graphs that are closely related to a CFG, such as a paths graph. */
};

/** Partitioner control flow edge types. */
enum EdgeType {
    E_NORMAL            = 0x00000001,                   /**< Normal control flow edge, nothing special. */
    E_FUNCTION_CALL     = 0x00000002,                   /**< Edge is a function call. */
    E_FUNCTION_RETURN   = 0x00000004,                   /**< Edge is a function return. Such edges represent the actual
                                                         *   return-to-caller and usually originate from a return instruction
                                                         *   (e.g., x86 @c RET, m68k @c RTS, etc.). */
    E_CALL_RETURN       = 0x00000008,                   /**< Edge is a function return from the call site. Such edges are from
                                                         *   a caller basic block to (probably) the fall-through address of the
                                                         *   call and don't actually exist directly in the specimen.  They
                                                         *   represent the fact that the called function eventually returns
                                                         *   even if the instructions for the called function are not available
                                                         *   to analyze. */
    E_FUNCTION_XFER     = 0x00000010,                   /**< Edge is a function call transfer. A function call transfer is
                                                         *   similar to @ref E_FUNCTION_CALL except the entire call frame is
                                                         *   transferred to the target function and this function is no longer
                                                         *   considered part of the call stack; a return from the target
                                                         *   function will skip over this function. Function call transfers
                                                         *   most often occur as the edge leaving a thunk. */
    E_USER_DEFINED      = 0x00000020,                   /**< User defined edge.  These edges don't normally appear in the
                                                         *   global control flow graph but might appear in other kinds of
                                                         *   graphs that are closely related to a CFG, such as a paths graph. */
};

/** How sure are we of something. */
enum Confidence {
    ASSUMED,                                            /**< The value is an assumption without any proof. */
    PROVED,                                             /**< The value was somehow proved. */
};

/** Organization of semantic memory. */
enum SemanticMemoryParadigm {
    LIST_BASED_MEMORY,                                  /**< Precise but slow. */
    MAP_BASED_MEMORY                                    /**< Fast but not precise. */
};

/** Settings that control building the AST.
 *
 *  The runtime descriptions and command-line parser for these switches can be obtained from @ref Engine::settings. */
struct AstConstructionSettings {
    /** Whether to allow an empty global block.
     *
     *  If the partitioner contains no functions then either create an empty global block (top-level @ref SgAsmBlock) when
     *  this setting is true, or return a null global block pointer when this setting is false. */
    bool allowEmptyGlobalBlock = false;

    /** Whether to allow functions with no basic blocks.
     *
     *  If the the partitioner knows about a function but was unable to produce any basic blocks then we have two choices
     *  for constructing the @ref SgAsmFunction node in the AST: if this setting is true, then create a function node with
     *  no @ref SgAsmBlock children; otherwise return a null pointer and do not add ths function to the AST. */
    bool allowFunctionWithNoBasicBlocks = false;

    /** Whether to allow a basic block to be empty.
     *
     *  If the partitioner contains a basic block with no instructions, such as a block whose starting address is not
     *  mapped, then we have two choices when creating the corresponding @ref SgAsmBlock node in the AST: if this setting
     *  is true, then create a basic block with no @ref SgAsmInstruction children; otherwise return a null pointer and do
     *  not add the basic block to the AST. */
    bool allowEmptyBasicBlocks = false;

    /** Whether to allow shared instructions in the AST.
     *
     *  This setting controls how an instruction that is shared between two or more functions by virtue of its basic block
     *  being part of both functions is represented in the AST.  If this setting is true, instruction ASTs (rooted at @ref
     *  SgAsmInstruction) are deep-copied into the AST at each place they occur.
     *
     *  The partitioner allows an instruction to be shared by two or functions by virtue of the instruction's basic block
     *  being shared by those functions.  If the copying is not performed then the AST will no longer be a tree (it will be
     *  a lattice) but each instruction can point to only one parent basic block (chosen arbitrarily). Thus, a depth-first
     *  traversal of the AST will find the same @ref SgAsmInstruction node more than once, yet following the instruction's
     *  parent pointer will always return the same basic block. */
    bool copyAllInstructions = true;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, unsigned version) {
        s & BOOST_SERIALIZATION_NVP(allowEmptyGlobalBlock);
        s & BOOST_SERIALIZATION_NVP(allowFunctionWithNoBasicBlocks);
        s & BOOST_SERIALIZATION_NVP(allowEmptyBasicBlocks);
        s & BOOST_SERIALIZATION_NVP(copyAllInstructions);
    }

public:
    /** Default strict settings.
     *
     *  These settings try to construct an AST that will work with all old AST-based analyses. Some information represented
     *  in the partitioner might not be copied into the AST. */
    static AstConstructionSettings strict() {
        AstConstructionSettings s;
        s.allowEmptyGlobalBlock = false;
        s.allowFunctionWithNoBasicBlocks = false;
        s.allowEmptyBasicBlocks = false;
        s.copyAllInstructions = true;
        return s;
    }

    /** Default permissive settings.
     *
     *  These settings allow as much of the partitioner's information as possible to be copied into the AST even if it means
     *  that AST might violate some invariants that are expected by old analyses.  For instance, it will allow creation of a
     *  basic block with no instructions if the block exists at a virtual addresses that could not be disassembled. */
    static AstConstructionSettings permissive() {
        AstConstructionSettings s;
        s.allowEmptyGlobalBlock = true;
        s.allowFunctionWithNoBasicBlocks = true;
        s.allowEmptyBasicBlocks = true;
        s.copyAllInstructions = true;               // true keeps the AST a tree instead of a lattice
        return s;
    }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Settings.  All settings must act like properties, which means the following:
//   1. Each setting must have a name that does not begin with a verb.
//   2. Each setting must have a command-line switch to manipulate it.
//   3. Each setting must have a method that queries the property (same name as the property and taking no arguments).
//   4. Each setting must have a modifier method (same name as property but takes a value and returns void)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/** How the partitioner should globally treat memory. */
enum MemoryDataAdjustment {
    DATA_IS_CONSTANT,                               /**< Treat all memory as if it were constant. This is accomplished by
                                                     *   removing @c MemoryMap::READABLE from all segments. */
    DATA_IS_INITIALIZED,                            /**< Treat all memory as if it were initialized. This is a little
                                                     *   weaker than @c MEMORY_IS_CONSTANT in that it allows the
                                                     *   partitioner to read the value from memory as if it were constant,
                                                     *   but also marks the value as being indeterminate. This is
                                                     *   accomplished by adding @c MemoryMap::INITIALIZED to all
                                                     *   segments. */
    DATA_NO_CHANGE,                                 /**< Do not make any global changes to the memory map. */
};

/** Settings for loading specimens.
 *
 *  The runtime descriptions and command-line parser for these switches can be obtained from @ref Engine::settings. */
struct LoaderSettings {
    /** When to remove execute permission from zero bytes.
     *
     *  This is the number of consecutive zero bytes that must be present before execute permission is removed from this part
     *  of the memory map.  A value of zero disables this feature.  The @ref deExecuteZerosThreshold is the number of
     *  consecutive zero bytes that must be found to trigger this alteration, while the @ref deExecuteZerosLeaveAtFront and
     *  @ref deExecuteZerosLeaveAtBack narrow each region slightly before removing execute permission in order to leave some
     *  zeros unaffected.
     *
     *  This action happens after the @ref memoryIsExecutable property is processed.
     *
     * @{ */
    size_t deExecuteZerosThreshold = 0;
    size_t deExecuteZerosLeaveAtFront = 16;
    size_t deExecuteZerosLeaveAtBack = 1;
    /** @} */

    /** How to globally adjust memory segment access bits for data areas.
     *
     *  This property controls whether the partitioner makes any global adjustments to the memory map.  The readable, writable,
     *  and initialized bits (see @ref MemoryMap) determine how the partitioner treats memory read operations.  Reading from
     *  memory that is non-writable is treated as if the memory location holds a constant value; reading from memory that is
     *  writable and initialized is treated as if the memory contains a valid initial value that can change during program
     *  execution, and reading from memory that is writable and not initialized is treated as if it has no current value.
     *
     *  The default is to use the memory map supplied by the executable or the user without making any changes to these access
     *  bits. */
    MemoryDataAdjustment memoryDataAdjustment = DATA_IS_INITIALIZED;

    /** Whether all of memory should be made executable.
     *
     *  If this property is set, then the engine will remap all memory to be executable.  Executability determines whether the
     *  partitioner is able to make instructions at that address. The default, false, means that the engine will not globally
     *  modify the execute bits in the memory map.  This action happens before the various de-execute-zeros stuff is processed
     *  according to @ref deExecuteZerosThreshold et al. */
    bool memoryIsExecutable = false;

    /** Whether to link object files before parsing.
     *
     *  Object files (".o" files) typically don't contain information about how the object is mapped into virtual memory, and
     *  thus machine instructions are not found. Turning on linking causes all the object files (and possibly library archives)
     *  to be linked into an output file and the output file is analyzed instead.
     *
     *  See also, @ref linkStaticArchives, @ref linker. */
    bool linkObjectFiles = true;

    /** Whether to link library archives before parsing.
     *
     *  Static library archives (".a" files) contain object files that typically don't have information about where the object
     *  is mapped in virtual memory. Turning on linking causes all archives (and possibly object files) to be linked into an
     *  output file that is analyzed instead.
     *
     *  See also, @ref linkObjectFiles, @ref linker. */
    bool linkStaticArchives = true;

    /** Linker command.
     *
     *  ELF object files typically don't contain information about how the object is mapped into memory. If this setting is a
     *  non-empty string then a shell command is constructed and run on all the supplied object and library files and the
     *  resulting file is used instead.
     *
     *  This is the Bourne shell command used to link object files and static library archives depending on the @ref
     *  linkObjectFiles and @ref linkStaticArchives properties.  The "%o" substring is replaced by the name of the linker
     *  output file, and the "%f" substring is replaced by a space separated list of input files (the objects and
     *  libraries). These substitutions are escaped using Bourne shell syntax and thus should not be quoted. */
    std::string linker = "ld -o %o --unresolved-symbols=ignore-all --whole-archive %f";

    /** Names to erase from the environment.
     *
     *  This property is a list of environment variable names that will be removed before launching a "run:" style specimen.
     *  These names are matched exactly. */
    std::vector<std::string> envEraseNames;

    /** Patterns to erase from the environment.
     *
     *  This property is a list of regular expressions that will erase matching environment variable names before launching
     *  a "run:" style specimen. The expressions match only the variable name, not its value. */
    std::vector<boost::regex> envErasePatterns;

    /** Environment variables to insert.
     *
     *  This property is a list of environment variables and values to insert before launching a "run:" style
     *  specimen. Insertions always occur after all environment variable erasures have been processed.  Each string must
     *  contain at least one equal sign ("="), the first of which separates the variable name from its value. */
    std::vector<std::string> envInsert;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, unsigned version) {
        s & BOOST_SERIALIZATION_NVP(deExecuteZerosThreshold);
        s & BOOST_SERIALIZATION_NVP(deExecuteZerosLeaveAtFront);
        s & BOOST_SERIALIZATION_NVP(deExecuteZerosLeaveAtBack);
        s & BOOST_SERIALIZATION_NVP(memoryDataAdjustment);
        s & BOOST_SERIALIZATION_NVP(memoryIsExecutable);
        if (version >= 1) {
            s & BOOST_SERIALIZATION_NVP(envEraseNames);
            s & BOOST_SERIALIZATION_NVP(envInsert);

            // There's no serialization for boost::regex, so we do it ourselves.
            std::vector<std::string> reStrings;
            for (const boost::regex &re: envErasePatterns)
                reStrings.push_back(re.str());
            s & BOOST_SERIALIZATION_NVP(reStrings);
            if (envErasePatterns.empty()) {
                for (const std::string &reStr: reStrings)
                    envErasePatterns.push_back(boost::regex(reStr));
            }
        }
    }
};

/** Settings that control the disassembler.
 *
 *  The runtime descriptions and command-line parser for these switches can be obtained from @ref Engine::settings. */
struct DisassemblerSettings {
    /** Whether to disassemble instructions.
     *
     *  If true, then disassembly is performed, otherwise it's skipped. If false, then it is not an error if no
     *  disassembler can be found. */
    bool doDisassemble = true;

    /** Instruction set architecture name.
     *
     *  The instruction set architecture name is used to obtain a disassembler and overrides the disassembler that would
     *  otherwise be found by examining the binary container. Specifying a non-empty ISA name will override the architecture
     *  that's chosen from the binary container(s) such as ELF or PE. */
    std::string isaName;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, unsigned version) {
        if (version >= 1)
            s & BOOST_SERIALIZATION_NVP(doDisassemble);
        s & BOOST_SERIALIZATION_NVP(isaName);
    }
};

/** Controls whether the function may-return analysis runs. */
enum FunctionReturnAnalysis {
    MAYRETURN_DEFAULT_YES,                          /**< Assume a function returns if the may-return analysis cannot
                                                     *   decide whether it may return. */
    MAYRETURN_DEFAULT_NO,                           /**< Assume a function cannot return if the may-return analysis cannot
                                                     *   decide whether it may return. */
    MAYRETURN_ALWAYS_YES,                           /**< Assume that all functions return without ever running the
                                                     *   may-return analysis. */
    MAYRETURN_ALWAYS_NO,                            /**< Assume that a function cannot return without ever running the
                                                     *   may-return analysis. */
};

/** Settings that directly control a partitioner.
 *
 *  These settings are specific to a @ref Partitioner object. */
struct BasePartitionerSettings {
    /** Whether instruction semantics are used.
     *
     *  If semantics are used, then the partitioner will have more accurate reasoning about the control flow graph.  For
     *  instance, semantics enable the detection of certain kinds of opaque predicates. */
    bool usingSemantics = false;

    /** Whether to look for function calls used as branches.
     *
     *  If this property is set, then function call instructions are not automatically assumed to be actual function calls. */
    bool checkingCallBranch = false;

    /** Whether to automatically drop semantics for attached basic blocks.
     *
     *  Basic blocks normally cache their semantic state as they're being discovered so that the state does not need to be
     *  recomputed from the beginning of the block each time a new instruction is appended.  However, caching this information
     *  can consume a large number of symbolic expression nodes which are seldom needed once the basic block is fully
     *  discovered.  Therefore, setting this property to true will cause a basic block's semantic information to be forgotten
     *  as soon as the basic block is attached to the CFG.
     *
     *  @sa Partitioner::basicBlockDropSemantics */
    bool basicBlockSemanticsAutoDrop = true;

    /** Whether unknown instructions are ignored.
     *
     *  If set, then instructions that cannot be disassembled are treated like no-ops for the purpose of building the global
     *  control flow graph (otherwise they terminate a basic block). This is useful when working with fixed-width instruction
     *  set architectures for which ROSE has an incomplete disassembler. For instance, PowerPC architectures that are augmented
     *  with additional undocumented co-processor instructions. */
    bool ignoringUnknownInsns = false;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned version) {
        s & BOOST_SERIALIZATION_NVP(usingSemantics);
        s & BOOST_SERIALIZATION_NVP(checkingCallBranch);
        s & BOOST_SERIALIZATION_NVP(basicBlockSemanticsAutoDrop);
        if (version >= 1)
            s & BOOST_SERIALIZATION_NVP(ignoringUnknownInsns);
    }
};

/** Settings that control the engine partitioning.
 *
 *  These switches are used by the engine to control how it partitions addresses into instructions and static data,
 *  instructions into basic blocks, and basic blocks and static data into functions.  Some of these settings are copied into a
 *  @ref Partitioner object while others affect the @ref Engine directly.
 *
 *  The runtime descriptions and command-line parser for these switches can be obtained from @ref Engine::settings. */
struct PartitionerSettings {
    /** Base partitioner settings. */
    BasePartitionerSettings base;

    /** Starting addresses for disassembly.
     *
     *  This is a list of addresses where functions will be created to start recursive disassembly. These addresses are in
     *  addition to entry addresses, addresses from symbols, addresses from configuration files, etc. */
    std::vector<rose_addr_t> functionStartingVas;

    /** Whether to follow ghost edges.
     *
     *  A "ghost edge" is a control flow graph (CFG) edge that would be present if the CFG-building analysis looked only at
     *  individual instructions, but would be absent when the analysis considers coarser units of code.  For instance, consider
     *  the following x86 instructions:
     *
     * @code
     *  1: mov eax, 0
     *  2: cmp eax, 0
     *  3: jne 5
     *  4: nop
     *  5: hlt
     * @endcode
     *
     *  If the analysis looks only at instruction 3, then it appears to have two CFG successors: instructions 4 and 5. But if
     *  the analysis looks at the first three instructions collectively it will ascertain that instruction 3 has an opaque
     *  predicate, that the only valid CFG successor is instruction 4, and that the edge from 3 to 5 is a \"ghost\". In fact,
     *  if there are no other incoming edges to these instructions, then instructions 1 through 4 will form a basic block with
     *  the (unconditional) branch instruction in its interior.  The ability to look at larger units of code than single
     *  instructions is controlled by the @ref BasePartitionerSettings::usingSemantics property.
     *
     *  If this @ref followingGhostEdges property is true then ghost edges will be added back into the CFG as real edges,
     *  which might force a basic block to end, as in this example, at the branch instruction and may attempt to disassemble
     *  additional code by folowing all edges. */
    bool followingGhostEdges = false;

    /** Whether to allow discontiguous basic blocks.
     *
     *  ROSE's definition of a basic block allows two consecutive instructions, A and B, to be arranged in memory such that B
     *  does not immediately follow A.  Clearing this property prevents this and would force A and B to belong to separate
     *  basic blocks. */
    bool discontiguousBlocks = true;

    /** Maximum size for basic blocks.
     *
     *  This property is the maximum size for basic blocks measured in number of instructions. Any basic block that would
     *  contain more than this number of instructions is split into multiple basic blocks.  Having smaller basic blocks makes
     *  some intra-block analysis faster, but they have less information.  A value of zero indicates no limit. */
    size_t maxBasicBlockSize = 0;

    /** CFG edge rewrite pairs.
     *
     *  This property is a list of old/new instruction pointer pairs that describe how to rewrite edges of the global control
     *  flow graph. Whenever an instruction has a successor whose address is an old address, it will be replaced with a successor
     *  edge that points to the new address.  This list must have an even number of elements where element <code>2*i+0</code> is
     *  and old address and element <code>2*i+1</code> is the corresponding new address. */
    std::vector<rose_addr_t> ipRewrites;

    /** Whether to find function padding.
     *
     *  If set, then the partitioner will look for certain padding bytes appearing before the lowest address of a function and
     *  add those bytes to the function as static data. */
    bool findingFunctionPadding = true;

    /** Whether to find dead code.
     *
     *  If ghost edges are being discovered (see @ref BasePartitionerSettings::usingSemantics and @ref followingGhostEdges) and are
     *  not being inserted into the global CFG, then the target address of the ghost edges might not be used as code addresses
     *  during the code discovery phase.  This property, when true, will cause the target address of ghost edges to be used to
     *  discover additional instructions even if they have no incoming CFG edges. */
    bool findingDeadCode = true;

    /** PE-Scrambler dispatcher address.
     *
     *  If non-zero then the partitioner defeats PE-scrambled binary obfuscation by replacing control flow edges that go
     *  through this function with the de-scrambled control flow edge. */
    rose_addr_t peScramblerDispatcherVa = 0;

    /** Whether to find intra-function code.
     *
     *  If positive, the partitioner will look for parts of memory that were not disassembled and occur between other parts of
     *  the same function, and will attempt to disassemble that missing part and link it into the surrounding function. It will
     *  perform up to @p n passes across the entire address space. */
    size_t findingIntraFunctionCode = 10;

    /** Whether to find intra-function data.
     *
     *  If set, the partitioner will look for parts of memory that were not disassembled and occur between other parts of the
     *  same function, and will treat the missing part as static data belonging to that function. */
    bool findingIntraFunctionData = true;

    /** Whether to search for function calls between exiting functions.
     *
     *  If set, then @ref EngineBinary::makeFunctionFromInterFunctionCalls is invoked, which looks for call-like code between
     *  existing functions in order to create new functions at the call target addresses. */
    bool findingInterFunctionCalls = true;

    /** Whether to turn function call targets into functions.
     *
     *  If set, then sequences of instructions that behave like a function call (including plain old function call
     *  instructions) will cause a function to be created at the call's target address under most circumstances. */
    bool findingFunctionCallFunctions = true;

    /** Whether to make functions at program entry points.
     *
     *  If set, then all program entry points are assumed to be the start of a function. */
    bool findingEntryFunctions = true;

    /** Whether to make error handling functions.
     *
     *  If set and information is available about error handling and exceptions, then that information is used to create entry
     *  points for functions. */
    bool findingErrorFunctions = true;

    /** Whether to make functions at import addresses.
     *
     *  If set and the file contains a table describing the addresses of imported functions, then each of those addresses is
     *  assumed to be the entry point of a function. */
    bool findingImportFunctions = true;

    /** Whether to make functions at export addresses.
     *
     *  If set and the file contains a table describing the addresses of exported functions, then each of those addresses is
     *  assumed to be the entry point of a function. */
    bool findingExportFunctions = true;

    /** Whether to make functions according to symbol tables.
     *
     *  If set and the file contains symbol tables, then symbols that define function addresses cause functions to be created
     *  at those addresses. */
    bool findingSymbolFunctions = true;

    /** Property: Location of machine interrupt vector.
     *
     *  If non-empty, the partitioner will treat the specified area as a machine interrupt vector. The effect of the vector
     *  varies by architecture. */
    AddressInterval interruptVector;

    /** Whether to perform any post-partitioning analysis steps.
     *
     *  If set, then each of the enabled post-partitioning analysis steps are executed.  Some of these can be quite expensive,
     *  but they can be enabled and disabled individually. Those that are enabled are only run if this property also is set. */
    bool doingPostAnalysis = true;

    /** Whether to run the function may-return analysis.
     *
     *  Determines whether the may-return analysis is run when @ref doingPostAnalysis is true. */
    bool doingPostFunctionMayReturn = true;

    /** Whether to run the function stack delta analysis.
     *
     *  Determines whether the stack delta analysis is run when @ref doingPostAnalysis is true. */
    bool doingPostFunctionStackDelta = true;

    /** Whether to run calling-convention analysis.
     *
     *  Determines whether calling convention analysis is run on each function when @ref doingPostAnalysis is true. */
    bool doingPostCallingConvention = false;

    /** Whether to run no-op function analysis.
     *
     *  Determines whether function no-op analysis is run on each function when @ref doingPostAnalysis is true. This analysis
     *  determines whether a function is effectively a no-op and gives it a name indicative of a no-op if it is one. */
    bool doingPostFunctionNoop = false;

    /** How to run the function may-return analysis.
     *
     *  The caller can decide if and how may-return analysis runs and whether an indeterminate result should be
     *  considered true or false. */
    FunctionReturnAnalysis functionReturnAnalysis = MAYRETURN_DEFAULT_YES;

    /** Maximum number of function may-return sorting operations.
     *
     *  If function may-return analysis is being run, the functions are normally sorted according to their call depth (after
     *  arbitrarily breaking cycles) and the analysis is run from the leaf functions to the higher functions in order to
     *  minimize forward dependencies. However, the functions need to be resorted each time a new function is discovered and/or
     *  when the global CFG is sufficiently modified. Therefore, the total cost of the sorting can be substantial for large
     *  specimens. This property limits the total number of sorting operations and reverts to unsorted analysis once the limit
     *  is reached. This allows smaller specimens to be handled as accurately as possible, but still allows large specimens to
     *  be processed in a reasonable amount of time.  The limit is based on the number of sorting operations rather than the
     *  specimen size. */
    size_t functionReturnAnalysisMaxSorts = 50;

    /** Whether to search static data for function pointers.
     *
     *  If this property is set, then the partitioner will scan static data to look for things that might be pointers to
     *  functions. */
    bool findingDataFunctionPointers = false;

    /** Whether to search existing instructions for function pointers.
     *
     *  If this property is set, then the partitioner scans existing instructions to look for constants that seem to be
     *  pointers to functions that haven't been discovered yet. */
    bool findingCodeFunctionPointers = false;

    /** Whether to match thunk patterns.
     *
     *  If set, then the partitioner expands the list of function prologue patterns to include common thunk patterns when
     *  searching for funcitons in undiscovered areas of memory.  This setting does not control whether thunk instructions are
     *  split into their own functions (see @ref splittingThunks). */
    bool findingThunks = true;

    /** Whether to split thunk instructions into mini functions.
     *
     *  If set, then functions whose entry instructions match a thunk pattern are split so that those thunk instructions are in
     *  their own function. */
    bool splittingThunks = false;

    /** Type of container for semantic memory.
     *
     *  Determines whether @ref Partitioner objects created by this engine will be configured to use list-based or map-based
     *  semantic memory states.  The list-based states are more precise, but they're also slower. */
    SemanticMemoryParadigm semanticMemoryParadigm = LIST_BASED_MEMORY;

    /** Whether to give names to constants.
     *
     *  Within instruciton operands, any constants that fall within this set of addresses and which have a label associated
     *  with them (such as names of symbols) are given a comment consisting of that label. Setting this to empty disables
     *  assigning such labels to integer values.
     *
     *  See also, @ref Modules::nameConstants. */
    AddressInterval namingConstants = AddressInterval::hull(4096, AddressInterval::whole().greatest());

    /** Addresses where strings might start.
     *
     *  Within instruction operands, any constants that fall within this set of addresses are checked to see if they point into
     *  an ASCII C-style NUL-terminated string. If so, and if the constant doesn't already have a comment, then a comment is
     *  attached describing the string.  Setting this to empty disables assigning string literal comments to integer values. */
    AddressInterval namingStrings = AddressInterval::hull(4096, AddressInterval::whole().greatest());

    /** Whether to give names to system calls.
     *
     *  If this property is set, then the partitioner makes a pass after the control flow graph is finalized and tries to give
     *  names to system calls using the @ref Rose::BinaryAnalysis::SystemCall analysis. */
    bool namingSyscalls = true;

    /** Header file in which system calls are defined.
     *
     *  If this property is not empty, then the specified Linux header file is parsed to obtain the mapping between system call
     *  numbers and their names. Otherwise, any analysis that needs system call names obtains them by looking in predetermined
     *  system header files. */

    boost::filesystem::path syscallHeader;

    /** Whether to demangle names.
     *
     *  If this property is set, then names are passed through a demangle step, which generally converts them from a low-level
     *  format to a source language format. */
    bool demangleNames = true;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, unsigned version) {
        s & BOOST_SERIALIZATION_NVP(base);
        s & BOOST_SERIALIZATION_NVP(functionStartingVas);
        s & BOOST_SERIALIZATION_NVP(followingGhostEdges);
        s & BOOST_SERIALIZATION_NVP(discontiguousBlocks);
        s & BOOST_SERIALIZATION_NVP(maxBasicBlockSize);
        if (version >= 6)
            s & BOOST_SERIALIZATION_NVP(ipRewrites);
        s & BOOST_SERIALIZATION_NVP(findingFunctionPadding);
        s & BOOST_SERIALIZATION_NVP(findingDeadCode);
        s & BOOST_SERIALIZATION_NVP(peScramblerDispatcherVa);
        if (version >= 2) {
            s & BOOST_SERIALIZATION_NVP(findingIntraFunctionCode);
        } else {
            bool temp = false;
            if (S::is_saving::value)
                temp = findingIntraFunctionCode > 0;
            s & boost::serialization::make_nvp("findingIntraFunctionCode", temp);
            if (S::is_loading::value)
                findingIntraFunctionCode = temp ? 10 : 0; // arbitrary number of passes
        }
        s & BOOST_SERIALIZATION_NVP(findingIntraFunctionData);
        s & BOOST_SERIALIZATION_NVP(findingInterFunctionCalls);
        if (version >= 4)
            s & BOOST_SERIALIZATION_NVP(findingFunctionCallFunctions);
        if (version >= 5) {
            s & BOOST_SERIALIZATION_NVP(findingEntryFunctions);
            s & BOOST_SERIALIZATION_NVP(findingErrorFunctions);
            s & BOOST_SERIALIZATION_NVP(findingImportFunctions);
            s & BOOST_SERIALIZATION_NVP(findingExportFunctions);
            s & BOOST_SERIALIZATION_NVP(findingSymbolFunctions);
        }
        s & BOOST_SERIALIZATION_NVP(interruptVector);
        s & BOOST_SERIALIZATION_NVP(doingPostAnalysis);
        s & BOOST_SERIALIZATION_NVP(doingPostFunctionMayReturn);
        s & BOOST_SERIALIZATION_NVP(doingPostFunctionStackDelta);
        s & BOOST_SERIALIZATION_NVP(doingPostCallingConvention);
        s & BOOST_SERIALIZATION_NVP(doingPostFunctionNoop);
        s & BOOST_SERIALIZATION_NVP(functionReturnAnalysis);
        if (version >= 3)
            s & BOOST_SERIALIZATION_NVP(functionReturnAnalysisMaxSorts);
        s & BOOST_SERIALIZATION_NVP(findingDataFunctionPointers);
        s & BOOST_SERIALIZATION_NVP(findingCodeFunctionPointers);
        s & BOOST_SERIALIZATION_NVP(findingThunks);
        s & BOOST_SERIALIZATION_NVP(splittingThunks);
        s & BOOST_SERIALIZATION_NVP(semanticMemoryParadigm);
        if (version >= 8) {
            s & BOOST_SERIALIZATION_NVP(namingConstants);
        } else if (S::is_loading()) {
            bool b;
            s & boost::serialization::make_nvp("namingConstants", b);
            if (b) {
                namingConstants = AddressInterval::whole();
            } else {
                namingConstants = AddressInterval();
            }
        }
        if (version >= 7) {
            s & BOOST_SERIALIZATION_NVP(namingStrings);
        } else if (S::is_loading()) {
            bool b;
            s & boost::serialization::make_nvp("namingStrings", b);
            if (b) {
                namingStrings = AddressInterval::whole();
            } else {
                namingStrings = AddressInterval();
            }
        }
        s & BOOST_SERIALIZATION_NVP(demangleNames);
        if (version >= 1) {
            s & BOOST_SERIALIZATION_NVP(namingSyscalls);

            // There is no support for boost::filesystem serialization due to arguments by the maintainers over who has
            // responsibility, so we do it the hard way.
            std::string temp;
            if (S::is_saving::value)
                temp = syscallHeader.string();
            s & boost::serialization::make_nvp("syscallHeader", temp);
            if (S::is_loading::value)
                syscallHeader = temp;
        }
    }
};

/** Settings for controling the engine behavior.
 *
 *  These settings control the behavior of the engine itself irrespective of how the partitioner is configured. The runtime
 *  descriptions and command-line parser for these switches can be obtained from the @ref Engine::settings property. */
struct EngineSettings {
    /** Configuration files names.
     *
     *  A list of configuration files or directories. */
    std::vector<std::string> configurationNames;

    /** Setting: Error handling.
     *
     *  If an exception occurs during certain high-level functions and this property is set, then the exception is caught, its
     *  text is written to a fatal error stream, and exit is called with a non-zero value.  Since the error message is more
     *  user-friendly and professional looking than the uncaught exception message produced by the C++ runtime, the default is
     *  that exceptions are caught.  If a tool needs to perform its own error handling, then it should clear this property. */
    bool exitOnError = true;

private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, unsigned version) {
        s & BOOST_SERIALIZATION_NVP(configurationNames);
        s & BOOST_SERIALIZATION_NVP(exitOnError);
    }
};

// Additional declarations incomplete definitions.
class AddressUser;
class AddressUsers;
class AddressUsageMap;

class BasicBlock;
using BasicBlockPtr = Sawyer::SharedPointer<BasicBlock>; /**< Shared-ownersip pointer for @ref BasicBlock. */

class BasicBlockError;

class BasicBlockCallback;
using BasicBlockCallbackPtr = Sawyer::SharedPointer<BasicBlockCallback>; /**< Shared ownership pointer. */

class BasicBlockSuccessor;
using BasicBlockSuccessors = std::vector<BasicBlockSuccessor>; /**< All successors in no particular order. */

class CfgAdjustmentCallback;

class CfgEdge;

class CfgVertex;

using ControlFlowGraph = Sawyer::Container::Graph<CfgVertex, CfgEdge>; /**< Control flow graph. */

class Configuration;

class DataBlock;
using DataBlockPtr = Sawyer::SharedPointer<DataBlock>;  /**< Shared-ownership pointer for @ref DataBlock. */

class DataBlockError;

class Engine;
using EnginePtr = Sawyer::SharedPointer<Engine>;  /**< Shared-ownership pointer for @ref Engine. */;

class EngineBinary;
using EngineBinaryPtr = Sawyer::SharedPointer<EngineBinary>;  /**< Shared-ownership pointer for @ref EngineBinary. */;

class EngineJvm;
using EngineJvmPtr = Sawyer::SharedPointer<EngineJvm>;  /**< Shared-ownership pointer for @ref EngineJvm. */;

class Exception;

class Function;
using FunctionPtr = Sawyer::SharedPointer<Function>;    /**< Shared-ownership pointer for @ref Function. */

using Functions = Sawyer::Container::Map<rose_addr_t, FunctionPtr>; /**< Mapping from address to function. */

class FunctionCallGraph;

class FunctionPaddingMatcher;
using FunctionPaddingMatcherPtr = Sawyer::SharedPointer<FunctionPaddingMatcher>; /**< Shared ownership pointer. */

class FunctionPrologueMatcher;
using FunctionPrologueMatcherPtr = Sawyer::SharedPointer<FunctionPrologueMatcher>; /**< Shared ownership pointer. */

using FunctionSet = Sawyer::Container::Set<FunctionPtr>; /**< Set of functions. */

class FunctionError;

class Partitioner;
using PartitionerPtr = Sawyer::SharedPointer<Partitioner>;            /**< Shared-ownership pointer for @ref Partitioner. */
using PartitionerConstPtr = Sawyer::SharedPointer<const Partitioner>; /**< Shared-ownership pointer for @ref Partitioner. */

class PlaceholderError;

class Reference;
using ReferenceSet = std::set<Reference>;                                /**< Set of references. */
using CrossReferences = Sawyer::Container::Map<Reference, ReferenceSet>; /**< Cross references. */

class ThunkPredicates;
using ThunkPredicatesPtr = Sawyer::SharedPointer<ThunkPredicates>; /**< Shared-ownership pointer for @ref ThunkPredicates. */

} // namespace
} // namespace
} // namespace

// Class versions must be at global scope
BOOST_CLASS_VERSION(Rose::BinaryAnalysis::Partitioner2::PartitionerSettings, 8);
BOOST_CLASS_VERSION(Rose::BinaryAnalysis::Partitioner2::BasePartitionerSettings, 1);
BOOST_CLASS_VERSION(Rose::BinaryAnalysis::Partitioner2::LoaderSettings, 1);
BOOST_CLASS_VERSION(Rose::BinaryAnalysis::Partitioner2::DisassemblerSettings, 1);

#endif
#endif
