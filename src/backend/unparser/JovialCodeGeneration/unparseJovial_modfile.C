#include "sage3basic.h"
#include "unparser_opt.h"
#include "unparser.h"
#include "unparseJovial_modfile.h"

using namespace Rose::Diagnostics;


std::string 
get_rcompool_dir(SgFile* sfile)
{
   std::string compool_dir;
   std::vector<std::string> args = sfile->get_originalCommandLineArgumentList();

   if (CommandlineProcessing::isOptionWithParameter(args,"-outputdir","",compool_dir,true) == true) {
      return compool_dir + "/";
   }
   else {
      return "";
   }
}


void
generateJovialCompoolFile(SgFile *sfile)
{
   ASSERT_not_null(sfile);

   // file name, with full path.
   std::string originalModuleFilenameWithPath = sfile->get_file_info()->get_filenameString();

   // For Jovial we shouldn't need to unparse or compile a module file already seen
   if ((sfile->get_skip_unparse() == true) || (sfile->get_skipfinalCompileStep() == true)) {
      if (SgProject::get_verbose() > 0) {
         mlog[INFO] << "Skipping generation of rcmp file: " << originalModuleFilenameWithPath << std::endl;
      }
      return;
   }

   if (SgProject::get_verbose() > 0) {
      mlog[INFO] << "In generateJovialCompoolFile(): Generating a Jovial specific module (*.rcmp file) for file = "
                 << originalModuleFilenameWithPath << std::endl;
   }

   // Get the list of SgJovialCompoolStatement objects for the current AST.
   Rose_STL_Container<SgNode*> moduleDeclarationList = NodeQuery::querySubTree (sfile,V_SgJovialCompoolStatement);

   for (auto decl : moduleDeclarationList) {
      SgJovialCompoolStatement* compool_stmt = isSgJovialCompoolStatement(decl);
      ASSERT_not_null(compool_stmt);

      // Remove single quote characters and convert to lower case for rcmp filename
      std::string compool_name{};
      for (auto c : std::string{compool_stmt->get_name()}) {
         if (c == '\'') continue;
         compool_name.push_back(c);
      }
      compool_name = Rose::StringUtility::convertToLowerCase(compool_name);

      std::string output_directory = get_rcompool_dir(sfile);
      std::string output_filename = output_directory + compool_name + CMP_FILE_SUFFIX;

      if (SgProject::get_verbose() > 0) {
         mlog[INFO] << "In generateJovialCompoolFile() (loop over module declarations): Generating a Jovial specific module file "
                    << output_filename << " for module " << compool_name << std::endl;
      }

      std::ofstream output_stream(output_filename);

      if (!output_stream.is_open()) {
         mlog[ERROR] << "Error detected in opening file " << output_filename << " for output\n";
         throw std::runtime_error("File could not be opened.");
      }

      // Output header at the top of the generate *.rcmp file.
      output_stream << std::endl
                    << "% =================================================================================== %\n"
                    << "% <<Automatically generated by Rose for Jovial COMPOOL directives, DO NOT MODIFY IT>> %\n"
                    << "% =================================================================================== %\n"
                    << std::endl;
      SgUnparse_Info ninfo;

      SgScopeStatement* compool_scope = isSgScopeStatement(compool_stmt->get_parent());
      ASSERT_not_null(compool_scope);

      SgGlobal* global_scope = SageInterface::getGlobalScope(compool_scope);
      ASSERT_not_null(global_scope);

      ninfo.set_current_scope(compool_scope);
      ninfo.set_SkipFormatting();

      // This may be needed in future. If so it will require change to ROSETTA ninfo class
      // ninfo.set_outputJovialModFile();

      std::ostringstream outputString;
      Unparser_Opt options(false, false,false,false,true,false,false,false,false,false);

      // This is a confusing use of originalModuleFilename vs. output_filename (Oh, the first one has the full path!).
      // The originalModuleFilename will be used to build a FortranCodeGeneration_locatedNode using
      // the originalModuleFilename as a basis.
      //
      Unparser unp(&output_stream, originalModuleFilenameWithPath, options, NULL, NULL);
      unp.currentFile = sfile;

      ASSERT_not_null(isSgSourceFile(sfile));
      ninfo.set_current_source_file(isSgSourceFile(sfile));

      // The output_filename is the name that will be matched against in the selection of statements to unparse.
      // However, that its suffix is ".rcmp" will cause UnparseLanguageIndependentConstructs::statementFromFile()
      // to always return true.  So use of output_filename should map to the file from the file constructed.
      UnparseJovial myunp{&unp, output_filename};
      myunp.unparseGlobalStmt(global_scope, ninfo);

      output_stream.flush();
      output_stream.close();
   }
}
