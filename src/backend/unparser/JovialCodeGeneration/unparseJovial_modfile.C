#include "sage3basic.h"
#include "unparser_opt.h"
#include "unparser.h"
#include "unparseJovial_modfile.h"

using namespace Rose::Diagnostics;


std::string 
get_rcompool_dir(SgFile* sfile)
{
   std::string compool_dir;
   std::vector<std::string> args = sfile->get_originalCommandLineArgumentList();

   if (CommandlineProcessing::isOptionWithParameter(args,"-outputdir","",compool_dir,true) == true) {
      return compool_dir + "/";
   }
   else {
      return "";
   }
}


void
generateJovialCompoolFile(SgFile *sfile)
   {
     ASSERT_not_null(sfile);

  // file name, with full path.
     std::string originalModuleFilenameWithPath = sfile->get_file_info()->get_filenameString();

  // For Jovial we shouldn't need to compile a module file already seen
     if (sfile->get_skipfinalCompileStep() == true)
        {
           if (SgProject::get_verbose() > 0) {
              mlog[INFO] << "Skipping generation of rcmp file: " << originalModuleFilenameWithPath << std::endl;
           }
           return;
        }

     if (SgProject::get_verbose() > 0)
        {
          mlog[INFO] << "In generateJovialCompoolFile(): Generating a Jovial specific module (*.rcmp file) for file = "
                     << originalModuleFilenameWithPath << std::endl;
        }

  // Get the list of SgJovialCompoolStatement objects for the current AST.
     Rose_STL_Container<SgNode*> moduleDeclarationList = NodeQuery::querySubTree (sfile,V_SgJovialCompoolStatement);

     for (Rose_STL_Container<SgNode*>::iterator i = moduleDeclarationList.begin(); i != moduleDeclarationList.end(); i++)
        {
          SgJovialCompoolStatement* compool_stmt = isSgJovialCompoolStatement(*i);
          ASSERT_not_null(compool_stmt);

          std::string outputDir = get_rcompool_dir(sfile);
          std::string outputFilename = outputDir + compool_stmt->get_name() + MOD_FILE_SUFFIX;

          std::string lowerCaseOutputFilename = Rose::StringUtility::convertToLowerCase(outputFilename);

          if (SgProject::get_verbose() > 0)
             {
               mlog[INFO] << "In generateJovialCompoolFile() (loop over module declarations): Generating a Jovial specific module file "
                          << lowerCaseOutputFilename << " for module = " << outputFilename << std::endl;
             }

       // C style string needed for C++98
          std::ofstream output_stream(lowerCaseOutputFilename.c_str());

          if (output_stream.is_open() == false) {
             mlog[ERROR] << "Error detected in opening file " << lowerCaseOutputFilename << "for output\n";
             ROSE_ASSERT(false);
          }

       // Output header at the top of the generate *.rcmp file.
          output_stream << std::endl
               << "% ==================================================================================== %\n"
               << "% <<Automatically generated by Rose for Jovial COMPOOL directives, DO NOT MODIFY IT>>  %\n"
               << "% ==================================================================================== %\n"
               << std::endl;
          SgUnparse_Info ninfo;

          SgScopeStatement* compool_scope = isSgScopeStatement(compool_stmt->get_parent());
          ASSERT_not_null(compool_scope);

          ninfo.set_current_scope(compool_scope);
          ninfo.set_SkipFormatting();

       // This may be needed in future. If so it will require change to ROSETTA ninfo class
       // ninfo.set_outputJovialModFile();

          std::ostringstream outputString;
          Unparser_Opt options(false, false,false,false,true,false,false,false,false,false);

       // This is a confusing use of originalModuleFilename vs. outputFilename (Oh, the first one has the full path!).
       // The originalModuleFilename will be used to build a FortranCodeGeneration_locatedNode using
       // the originalModuleFilename as a basis.
       //
          Unparser unp(&output_stream, originalModuleFilenameWithPath, options, NULL, NULL);
          unp.currentFile = sfile;

          ASSERT_not_null(isSgSourceFile(sfile));
          ninfo.set_current_source_file(isSgSourceFile(sfile));

       // The outputFilename is the name that will be matched against in the selection of statements to unparse.
       // However, that its suffix is ".rcmp" will cause UnparseLanguageIndependentConstructs::statementFromFile() 
       // to always return true.  So use of outputFilename should map to the file from the file constructed.
          Unparse_Jovial myunp(&unp, outputFilename);

          output_stream << "START\n";
          myunp.unparseStatement(compool_scope, (SgUnparse_Info&)ninfo);
          output_stream << "TERM\n";

          output_stream.flush();
          output_stream.close();
        }
   }
