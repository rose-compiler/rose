// This is the location of all the name qualification support functions
// required for code generation (unparser) (only applicable to C++).

#include "sage3basic.h"
#include "unparser.h"

using namespace std;

// DQ (5/11/2011): New name qualification for ROSE (the 4th try).
// This is a part of a rewrite of the name qualification support in ROSE with the follwoing properties:
//    1) It is exact (no over qualification).
//    2) It handles visibility of names constructs
//    3) It resolves ambiguity of named constructs.
//    4) It resolves where type elaboration is required.
//    5) The inputs are carried in the SgUnparse_Info object for uniform handling.
//    6) The the values in the SgUnparse_Info object are copied from the AST references to the named
//       constructs to avoid where named constructs are referenced from multiple locations and the
//       name qualification might be different.
//
//    7) What about base class qualification? I might have forgotten this one! No, this works,
//       but might not generate the minimum length qualified name.

SgName
Unparser_Nameq::lookup_generated_qualified_name ( SgNode* referencedNode )
   {
  // These are all of the types of IR nodes that can reference anything that is qualified.
  // It is a longer list than I expected (or designed for initially), but still not unreasonable.

     SgName nameQualifier;

     if (referencedNode == NULL)
        {
       // DQ (6/25/2011): This is the case of the using the unparseToString() function.  Our more sophisticated name
       // qualification support is not possible to support in this case (because we don;'t have the scope from which
       // to compute the qualified name) and so a fully qualified name is generated by default.

       // printf ("Note that info.set_reference_node_for_qualification(SgNode*) should have been called before calling this function. \n");
       // DQ (6/23/2011): This test fails this assertion: tests/nonsmoke/functional/roseTests/programAnalysisTests/testCallGraphAnalysis/test3.C
       // but allow it to pass as a test.
       // printf ("WARNING: referencedNode in Unparser_Nameq::lookup_generated_qualified_name() should be a valid pointer! \n");
#if 0
       // DQ (3/5/2012): Uncommenting this for debugging.
          printf ("WARNING: referencedNode in Unparser_Nameq::lookup_generated_qualified_name() should be a valid pointer! \n");
#endif
          return nameQualifier;
        }
     ASSERT_not_null(referencedNode);

  // TV (10/24/2018): (ROSE-1399) unparsing template from AST requires to namequal expressions in template arguments
     SgExpression* expr = isSgExpression(referencedNode);
     if (expr != NULL) {
       nameQualifier = expr->get_qualified_name_prefix_for_referenced_type();
#if 0
     printf ("In Unparser_Nameq::lookup_generated_qualified_name(): case of SgExpression: referencedNode = %p = %s \n",referencedNode,referencedNode->class_name().c_str());
#endif
       return nameQualifier;
     }

#if 0
     printf ("In Unparser_Nameq::lookup_generated_qualified_name(): referencedNode = %p = %s \n",referencedNode,referencedNode->class_name().c_str());
#endif

     switch (referencedNode->variantT())
        {
          case V_SgInitializedName:
             {
               SgInitializedName* initializedName = isSgInitializedName(referencedNode);
               nameQualifier = initializedName->get_qualified_name_prefix_for_type();
               break;
             }

       // DQ (12/29/2011): Added cases for new template IR nodes.
          case V_SgTemplateFunctionDeclaration:
          case V_SgTemplateMemberFunctionDeclaration:

          case V_SgFunctionDeclaration:
          case V_SgMemberFunctionDeclaration:
          case V_SgTemplateInstantiationFunctionDecl:
          case V_SgTemplateInstantiationMemberFunctionDecl:
             {
               SgFunctionDeclaration* node = isSgFunctionDeclaration(referencedNode);
               nameQualifier = node->get_qualified_name_prefix_for_return_type();
               break;
             }

          case V_SgTypedefDeclaration:
       // DQ (11/3/2014): Added support for templated typedef (part of C++11 support).
          case V_SgTemplateTypedefDeclaration:
       // Rose::CodeGen instantiates templated typedef. It never happens with EDG as those are "const-propagated".
          case V_SgTemplateInstantiationTypedefDeclaration:
             {
               SgTypedefDeclaration* node = isSgTypedefDeclaration(referencedNode);
#if 0
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): case V_SgTypedefDeclaration: calling SgTypedefDeclaration::get_qualified_name_prefix_for_base_type() \n");
#endif
               nameQualifier = node->get_qualified_name_prefix_for_base_type();
               break;
             }

       // DQ (2/18/2019): Adding support for name qualification of enum declaration in typedef declarations (and SgClassDeclaration, SgTemplateInstantiationDecl).
          case V_SgTemplateInstantiationDecl:
          case V_SgClassDeclaration:
          case V_SgEnumDeclaration:
             {
            // SgEnumDeclaration* node = isSgEnumDeclaration(referencedNode);
               SgDeclarationStatement* node = isSgDeclarationStatement(referencedNode);
#if 0
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): node = %p = %s \n",node,node->class_name().c_str());
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): case V_SgEnumDeclaration: calling SgEnumDeclaration::get_qualified_name_prefix_for_base_type() \n");
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): SgNode::get_globalQualifiedNameMapForNames().size() = %zu \n",SgNode::get_globalQualifiedNameMapForNames().size());
#endif
            // DQ (2/18/2019): If this works then we might want to generate an associated get_qualified_name_prefix_for_base_type() function for the SgEnumDeclaration.
            // nameQualifier = node->get_qualified_name_prefix_for_base_type();

            // std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(const_cast<SgTypedefDeclaration*>(this));
            // std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(node);
            // std::map<SgNode*,std::string>::iterator i = SgNode::get_qualifiedNameMapForNames().find(node);
               auto const /*iterator*/ i = SgNode::get_globalQualifiedNameMapForNames().find(node);

            // if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
               if (i != SgNode::get_globalQualifiedNameMapForNames().end())
                  {
#if 0
                    printf ("FOUND a valid name qualification: i->first = %p \n",i->first);
                    printf ("FOUND a valid name qualification: i->second = %s \n",i->second.c_str());
#endif
                 // DQ (2/22/2019): Added assertion.
                    ROSE_ASSERT(node == i->first);

#if 1
                    nameQualifier = i->second;
#else
                 // DQ (2/22/2019): This only appears to be a problem for ROSE when compiled with GNU 4.9.3.
                 // It might be a special case of the implementation of SgName and it's constructor that
                 // take a string as well.  But it only appears as an issue for GNU 4.9.3.
#if 0
                    printf ("before test for empty string \n");

#endif
                    if (i->second.empty() == false)
                       {
#if 0
                         printf ("before assignment to nameQualifier \n");
#endif
                         nameQualifier = i->second;
#if 0
                         printf ("after assignment to nameQualifier \n");
#endif
                       }
#if 0
                    printf ("FOUND a valid name qualification: nameQualifier %s \n",nameQualifier.str());
#endif
#endif
                  }
                 else
                  {
#if 0
                    printf ("COULD NOT find a valid name qualification \n");
#endif
                  }

#if 0
               printf ("nameQualifier for SgEnumDeclaration = %p = %s = %s \n",node,node->class_name().c_str(),nameQualifier.str());
#endif
               break;
             }

          case V_SgTemplateArgument:
             {
#if 0
            // DQ (5/4/2013): This was previously disabled, maybe because the SgTemplateArgument is shared between too many declarations (in different scopes).
               printf ("WARNING: lookup of qualifier prefix from SgTemplateArgument was previously disabled \n");
#endif
#if 0
            // DQ (3/14/2019): Avaliable collections of data to support name qualification.
            // SgNode::get_globalQualifiedNameMapForNames(),
            // SgNode::get_globalQualifiedNameMapForTypes(),
            // SgNode::get_globalQualifiedNameMapForTemplateHeaders(),
            // SgNode::get_globalTypeNameMap(),
            // SgNode::get_globalQualifiedNameMapForMapsOfTypes(),
            // referencedNameSet

               printf ("Calling outputNameQualificationMap(): using SgNode::get_globalQualifiedNameMapForNames() \n");
               outputNameQualificationMap(SgNode::get_globalQualifiedNameMapForNames());
               printf ("Calling outputNameQualificationMap(): using SgNode::get_globalQualifiedNameMapForTypes() \n");
               outputNameQualificationMap(SgNode::get_globalQualifiedNameMapForTypes());
               printf ("Calling outputNameQualificationMap(): using SgNode::get_globalQualifiedNameMapForTemplateHeaders() \n");
               outputNameQualificationMap(SgNode::get_globalQualifiedNameMapForTemplateHeaders());
               printf ("Calling outputNameQualificationMap(): using SgNode::get_globalTypeNameMap() \n");
               outputNameQualificationMap(SgNode::get_globalTypeNameMap());
#endif
               SgTemplateArgument* node = isSgTemplateArgument(referencedNode);
               nameQualifier = node->get_qualified_name_prefix_for_type();
               break;
             }

       // DQ (7/13/2013): I think we need this here, but wait until we generate the error to drive it to be introduced.
       // Also this does not permit handling of multiple types requiring different name qualification (same as for throw support).
       // DQ (7/12/2013): Added support to type trait builtin functions
          case V_SgTypeTraitBuiltinOperator:

          case V_SgAssignInitializer:

       // DQ (8/19/2013): Added support for constructor initializers that might have an associated
       // qualified name string associated with the templated class or instantiated template class.
          case V_SgConstructorInitializer:

       // DQ (9/5/2015): I think this is the support we need for test2015_57.C (compound literals used as expressions).
          case V_SgAggregateInitializer:

       // DQ (9/12/2016): Adding support for whatever types are used within alignOf operators.
          case V_SgAlignOfOp:

       // DQ (1/19/2019): Added support for SgDotExp (required for some unparseToString_tests test codes (e.g. test2010_24.C, and a dozen others).
          case V_SgDotExp:

          case V_SgTypeIdOp:
          case V_SgSizeOfOp:
          case V_SgNewExp:
          case V_SgCastExp:
             {
            // SgCastExp* node = isSgCastExp(referencedNode);
               SgExpression* node = isSgExpression(referencedNode);
               nameQualifier = node->get_qualified_name_prefix_for_referenced_type();
               break;
             }

           // Liao, 2021/11/1. We skip translation of some Ada AST from system packages in Ada2Cpp. The C++ unparser  will see them.
           // So we just skip them
          case V_SgAdaFunctionRenamingDecl:
             {
               break;
             }
          case V_SgClassType:
             {
            // These can appear in throw expression lists...ignore for now...
            // SgType* node = isSgType(referencedNode);
            // nameQualifier = node->get_qualified_name_prefix_for_type();
            // printf ("WARNING: Note that qualified types in throw expression lists are not yet supported... \n");
               break;
             }

          case V_SgFunctionType:
             {
            // These can appear in typedefs of function pointers...ignore for now...
            // SgType* node = isSgType(referencedNode);
            // nameQualifier = node->get_qualified_name_prefix_for_type();
            // printf ("WARNING: Note that qualified types in function pointer typedefs are not yet supported... \n");
               break;
             }

          case V_SgTypedefType:
             {
            // These can appear in typedef types...ignore for now...
            // SgType* node = isSgType(referencedNode);
            // nameQualifier = node->get_qualified_name_prefix_for_type();
            // printf ("WARNING: Note that qualified types in typedef types are not yet supported... \n");
               break;
             }

          case V_SgPointerMemberType:
             {
               SgPointerMemberType* node = isSgPointerMemberType(referencedNode);
            // nameQualifier = node->get_qualified_name_prefix_for_type();

            // DQ (4/21/2019): Added support for SgPointerMemberType, but not clear which of these functions should be called here.
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): case SgPointerMemberType: calling node->get_qualified_name_prefix_for_class_of() \n");

            // nameQualifier = node->get_qualified_name_prefix_for_base_type();
               nameQualifier = node->get_qualified_name_prefix_for_class_of();
               break;
             }

#if 0
          case V_:
             {
               * node = is (referencedNode);
               nameQualifier = node->get_qualified_name_prefix_for_type();
               break;
             }
#endif
          default:
             {
               printf ("In Unparser_Nameq::lookup_generated_qualified_name(): Sorry not implemented case of name qualification for info.get_reference_node_for_qualification() = %s \n",referencedNode->class_name().c_str());
               ROSE_ABORT();
             }
        }

#if 0
     printf ("In Unparser_Nameq::lookup_generated_qualified_name(): info.get_reference_node_for_qualification() = %p = %s nameQualifier = %s \n",
          referencedNode,referencedNode->class_name().c_str(),nameQualifier.str());
#endif

     return nameQualifier;
   }

// DQ (3/14/2019): Adding debugging support to output the map of names.
void
Unparser_Nameq::outputNameQualificationMap( const std::map<SgNode*,std::string> & qualifiedNameMap )
   {
     printf ("qualifiedNameMap.size() = %zu \n",qualifiedNameMap.size());
     std::map<SgNode*,std::string>::const_iterator i = qualifiedNameMap.begin();
     while (i != qualifiedNameMap.end())
       {
         ASSERT_not_null(i->first);

         printf (" --- *i = i->first = %p = %s i->second = %s \n",i->first,i->first->class_name().c_str(),i->second.c_str());

         i++;
       }
   }



#if 0
// DQ (7/20/2011): Test compilation without these functions.

SgName
Unparser_Nameq::generateNameQualifier( SgInitializedName* initializedName, const SgUnparse_Info& info, bool qualificationOfType )
   {
  // This unparser support for name qualification is C++ specific.
  // This interface takes a boolean value to distinquish which of
  // the two maps of IR nodes to qualified name strings to use
  // (the map for named constructs and the map for types).

     ASSERT_not_null(initializedName);
     return generateNameQualifierSupport(initializedName->get_scope(),info,qualificationOfType);
   }

#error "DEAD CODE!"

SgName
Unparser_Nameq::generateNameQualifier( SgDeclarationStatement* declarationStatement, const SgUnparse_Info & info, bool qualificationOfType )
   {
  // This unparser support for name qualification is C++ specific.

#if 0
     printf ("In Unparser_Nameq::generateNameQualifier(): qualificationOfType                      = %s \n",qualificationOfType ? "true" : "false");
     printf ("In Unparser_Nameq::generateNameQualifier(): info.get_name_qualification_length()     = %d \n",info.get_name_qualification_length());
     printf ("In Unparser_Nameq::generateNameQualifier(): info.get_type_elaboration_required()     = %s \n",info.get_type_elaboration_required() ? "true" : "false");
     printf ("In Unparser_Nameq::generateNameQualifier(): info.get_global_qualification_required() = %s \n",info.get_global_qualification_required() ? "true" : "false");
#endif

     ASSERT_not_null(declarationStatement);
     return generateNameQualifierSupport(declarationStatement->get_scope(),info,qualificationOfType);
   }

#error "DEAD CODE!"

SgName
Unparser_Nameq::generateNameQualifierSupport ( SgScopeStatement* scope, const SgUnparse_Info& info, bool qualificationOfType )
   {
  // DQ (5/28/2011): We need this information to be passed in from the outside (qualificationOfType):
  //    qualificationOfName == true implies this is name qualification for a name vs a type.
  //    qualificationOfName == false implies this is name qualification for a type.
  // note that the complete minimally qualified name is stored and retrieved from the map using
  // either SgNode::get_globalQualifiedNameMapForNames() or SgNode::get_globalQualifiedNameMapForTypes().
  // bool qualificationOfType = false;

     SgName qualifiedName;

  // If the name qualification length required is zero then we can return an empty string and avoid the logic below.
     if (info.get_name_qualification_length() > 0)
        {
       // DQ (5/28/2011): Adding support for qualified name lookup.
          SgNode* nameQualificationReferenceNode = info.get_reference_node_for_qualification();
          if (nameQualificationReferenceNode != NULL)
             {
               if (qualificationOfType == false)
                  {
                    std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForNames().find(nameQualificationReferenceNode);
                    if (i != SgNode::get_globalQualifiedNameMapForNames().end())
                       {
                         qualifiedName = i->second;
                       }
                      else
                       {
                         printf ("key not found in node map nameQualificationReferenceNode = %s \n",nameQualificationReferenceNode->class_name().c_str());
                         ROSE_ABORT();
                       }
#error "DEAD CODE!"

                  }
                 else
                  {
                    std::map<SgNode*,std::string>::iterator i = SgNode::get_globalQualifiedNameMapForTypes().find(nameQualificationReferenceNode);
                    if (i != SgNode::get_globalQualifiedNameMapForTypes().end())
                       {
                         qualifiedName = i->second;
                       }
                      else
                       {
                      // Debugging support...
                         printf ("key not found in type map nameQualificationReferenceNode = %s \n",nameQualificationReferenceNode->class_name().c_str());

                      // Extra Debugging support...
                         switch(nameQualificationReferenceNode->variantT())
                            {
                              case V_SgInitializedName:
                                 {
                                   SgInitializedName* initializedName = isSgInitializedName(nameQualificationReferenceNode);
                                   printf ("initializedName = %s \n",initializedName->get_name().str());
                                   break;
                                 }

                              default:
                                 {
                                   printf ("Default reached in switch(nameQualificationReferenceNode->variantT()) \n");
                                   ROSE_ABORT();
                                 }
                            }
                         ROSE_ABORT();
                       }
                  }
#error "DEAD CODE!"

             }
            else
             {
            // This should be an error.
               printf ("Error: nameQualificationReferenceNode == NULL but info.get_name_qualification_length() = %d \n",info.get_name_qualification_length());
               ROSE_ABORT();
             }
        }
       else
        {
       // printf ("return empty qualified name since info.get_name_qualification_length() == 0 \n");
        }

     return qualifiedName;
   }

#error "DEAD CODE!"

#endif
